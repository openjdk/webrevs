{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/opcodes.hpp\"\n@@ -698,0 +699,2 @@\n+  } else if (mem->Opcode() == Op_StrInflatedCopy || mem->Opcode() == Op_StrCompressedCopy || mem->Opcode() == Op_EncodeISOArray) {\n+    res = mem->in(1);\n@@ -1604,0 +1607,3 @@\n+        } else if (mem->Opcode() == Op_StrInflatedCopy || mem->Opcode() == Op_StrCompressedCopy || mem->Opcode() == Op_EncodeISOArray) {\n+          stack.push(mem, mem->req());\n+          mem = mem->in(1);\n@@ -2148,1 +2154,2 @@\n-      } else if ((u->adr_type() == TypePtr::BOTTOM && u->Opcode() != Op_StrInflatedCopy) ||\n+      } else if ((u->adr_type() == TypePtr::BOTTOM &&\n+                  u->Opcode() != Op_StrInflatedCopy && mem->Opcode() != Op_StrCompressedCopy && mem->Opcode() != Op_EncodeISOArray) ||\n@@ -2334,1 +2341,2 @@\n-      } else if ((u->adr_type() == TypePtr::BOTTOM && u->Opcode() != Op_StrInflatedCopy) ||\n+      } else if ((u->adr_type() == TypePtr::BOTTOM &&\n+                  u->Opcode() != Op_StrInflatedCopy && mem->Opcode() != Op_StrCompressedCopy && mem->Opcode() != Op_EncodeISOArray) ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/type.hpp\"\n@@ -4157,1 +4158,1 @@\n-Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {\n+Node* GraphKit::capture_memory(const TypePtr*& combined_type, const TypePtr* src_type, const TypePtr* dst_type) {\n@@ -4160,0 +4161,1 @@\n+    combined_type = src_type;\n@@ -4162,7 +4164,4 @@\n-  MergeMemNode* merge = MergeMemNode::make(map()->memory());\n-  record_for_igvn(merge); \/\/ fold it up later, if possible\n-  int src_idx = C->get_alias_index(src_type);\n-  int dst_idx = C->get_alias_index(dst_type);\n-  merge->set_memory_at(src_idx, memory(src_idx));\n-  merge->set_memory_at(dst_idx, memory(dst_idx));\n-  return merge;\n+  Node* mem = reset_memory();\n+  set_all_memory(mem);\n+  combined_type = TypePtr::BOTTOM;\n+  return mem;\n@@ -4174,1 +4173,1 @@\n-  \/\/ If input and output memory types differ, capture both states to preserve\n+  \/\/ If input and output memory types differ, capture the whole memory to preserve\n@@ -4186,3 +4185,4 @@\n-  \/\/  LoadB -> compress_string -> MergeMem(CharMem, StoreB(ByteMem))\n-  Node* mem = capture_memory(src_type, TypeAryPtr::BYTES);\n-  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, src, dst, count);\n+  \/\/  LoadB -> compress_string -> MergeMem -> StoreB\n+  const TypePtr* adr_type;\n+  Node* mem = capture_memory(adr_type, src_type, TypeAryPtr::BYTES);\n+  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, adr_type, src, dst, count);\n@@ -4190,1 +4190,5 @@\n-  set_memory(res_mem, TypeAryPtr::BYTES);\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n@@ -4198,3 +4202,9 @@\n-  Node* mem = capture_memory(TypeAryPtr::BYTES, dst_type);\n-  StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, src, dst, count);\n-  set_memory(_gvn.transform(str), dst_type);\n+  const TypePtr* adr_type;\n+  Node* mem = capture_memory(adr_type, TypeAryPtr::BYTES, dst_type);\n+  StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, adr_type, src, dst, count);\n+  Node* res_mem = _gvn.transform(str);\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-  Node* capture_memory(const TypePtr* src_type, const TypePtr* dst_type);\n+  Node* capture_memory(const TypePtr*& combined_type, const TypePtr* src_type, const TypePtr* dst_type);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-uint StrIntrinsicNode::size_of() const { return sizeof(*this); }\n-\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-class StrIntrinsicNode: public Node {\n+class StrIntrinsicNode : public Node {\n@@ -59,1 +59,5 @@\n-  virtual uint size_of() const;\n+  virtual uint size_of() const override { return sizeof(StrIntrinsicNode); }\n+  virtual uint hash() const override { return Node::hash() + _encoding; }\n+  virtual bool cmp(const Node& n) const override {\n+    return Node::cmp(n) && _encoding == static_cast<const StrIntrinsicNode&>(n)._encoding;\n+  }\n@@ -77,6 +81,6 @@\n-  virtual bool depends_only_on_test() const { return false; }\n-  virtual const TypePtr* adr_type() const { return TypeAryPtr::BYTES; }\n-  virtual uint match_edge(uint idx) const;\n-  virtual uint ideal_reg() const { return Op_RegI; }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual bool depends_only_on_test() const override { return false; }\n+  virtual const TypePtr* adr_type() const override = 0;\n+  virtual uint match_edge(uint idx) const override;\n+  virtual uint ideal_reg() const override { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  virtual const Type* Value(PhaseGVN* phase) const override;\n@@ -87,1 +91,1 @@\n-class StrCompNode: public StrIntrinsicNode {\n+class StrCompNode final : public StrIntrinsicNode {\n@@ -92,2 +96,3 @@\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const override { return TypeAryPtr::BYTES; }\n@@ -97,1 +102,1 @@\n-class StrEqualsNode: public StrIntrinsicNode {\n+class StrEqualsNode final : public StrIntrinsicNode {\n@@ -102,2 +107,3 @@\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::BOOL; }\n+  virtual const TypePtr* adr_type() const override { return TypeAryPtr::BYTES; }\n@@ -107,1 +113,1 @@\n-class StrIndexOfNode: public StrIntrinsicNode {\n+class StrIndexOfNode final : public StrIntrinsicNode {\n@@ -112,2 +118,3 @@\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const override { return TypeAryPtr::BYTES; }\n@@ -117,1 +124,1 @@\n-class StrIndexOfCharNode: public StrIntrinsicNode {\n+class StrIndexOfCharNode final : public StrIntrinsicNode {\n@@ -122,2 +129,3 @@\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const override { return TypeAryPtr::BYTES; }\n@@ -127,3 +135,6 @@\n-class StrCompressedCopyNode: public StrIntrinsicNode {\n- public:\n-  StrCompressedCopyNode(Node* control, Node* arymem,\n+class StrCompressedCopyNode final : public StrIntrinsicNode {\n+private:\n+  const TypePtr* const _adr_type;\n+\n+public:\n+  StrCompressedCopyNode(Node* control, Node* arymem, const TypePtr* adr_type,\n@@ -131,5 +142,12 @@\n-  StrIntrinsicNode(control, arymem, s1, s2, c, none) {};\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  StrIntrinsicNode(control, arymem, s1, s2, c, none), _adr_type(adr_type) {};\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(StrCompressedCopyNode); }\n+  virtual uint hash() const override { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _adr_type; }\n+  virtual bool cmp(const Node& n) const override {\n+    return StrIntrinsicNode::cmp(n) && _adr_type == static_cast<const StrCompressedCopyNode&>(n)._adr_type;\n+  }\n+  virtual const TypePtr* adr_type() const override { return _adr_type; }\n@@ -139,3 +157,6 @@\n-class StrInflatedCopyNode: public StrIntrinsicNode {\n- public:\n-  StrInflatedCopyNode(Node* control, Node* arymem,\n+class StrInflatedCopyNode final : public StrIntrinsicNode {\n+private:\n+  const TypePtr* const _adr_type;\n+\n+public:\n+  StrInflatedCopyNode(Node* control, Node* arymem, const TypePtr* adr_type,\n@@ -143,5 +164,12 @@\n-  StrIntrinsicNode(control, arymem, s1, s2, c, none) {};\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return Type::MEMORY; }\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  StrIntrinsicNode(control, arymem, s1, s2, c, none), _adr_type(adr_type) {};\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return Type::MEMORY; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(StrInflatedCopyNode); }\n+  virtual uint hash() const override { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _adr_type; }\n+  virtual bool cmp(const Node& n) const override {\n+    return StrIntrinsicNode::cmp(n) && _adr_type == static_cast<const StrInflatedCopyNode&>(n)._adr_type;\n+  }\n+  virtual const TypePtr* adr_type() const override { return _adr_type; }\n@@ -151,3 +179,6 @@\n-class AryEqNode: public StrIntrinsicNode {\n- public:\n-  AryEqNode(Node* control, Node* char_array_mem,\n+class AryEqNode final : public StrIntrinsicNode {\n+private:\n+  const TypeAryPtr* const _in_adr_type;\n+\n+public:\n+  AryEqNode(Node* control, Node* char_array_mem, const TypeAryPtr* in_adr_type,\n@@ -155,3 +186,11 @@\n-  StrIntrinsicNode(control, char_array_mem, s1, s2, encoding) {};\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+  StrIntrinsicNode(control, char_array_mem, s1, s2, encoding), _in_adr_type(in_adr_type) {};\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::BOOL; }\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(AryEqNode); }\n+  virtual uint hash() const override { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _in_adr_type; }\n+  virtual bool cmp(const Node& n) const override {\n+    return StrIntrinsicNode::cmp(n) && _in_adr_type == static_cast<const AryEqNode&>(n)._in_adr_type;\n+  }\n+  virtual const TypePtr* adr_type() const override { return _in_adr_type; }\n@@ -161,1 +200,1 @@\n-class CountPositivesNode: public StrIntrinsicNode {\n+class CountPositivesNode final : public StrIntrinsicNode {\n@@ -165,2 +204,3 @@\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::POS; }\n+  virtual int Opcode() const override;\n+  virtual const Type* bottom_type() const override { return TypeInt::POS; }\n+  virtual const TypePtr* adr_type() const override { return TypeAryPtr::BYTES; }\n@@ -170,12 +210,22 @@\n-class VectorizedHashCodeNode: public Node {\n- public:\n-  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n-    : Node(control, ary_mem, arg1, cnt1, result, basic_type) {};\n-  virtual int Opcode() const;\n-  virtual bool depends_only_on_test() const { return false; }\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n-  virtual uint match_edge(uint idx) const;\n-  virtual uint ideal_reg() const { return Op_RegI; }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+class VectorizedHashCodeNode final : public Node {\n+private:\n+  const TypeAryPtr* const _in_adr_type;\n+\n+public:\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, const TypeAryPtr* in_adr_type, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n+    : Node(control, ary_mem, arg1, cnt1, result, basic_type), _in_adr_type(in_adr_type) {};\n+  virtual int Opcode() const override;\n+  virtual bool depends_only_on_test() const override { return false; }\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual uint match_edge(uint idx) const override;\n+  virtual uint ideal_reg() const override { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  virtual const Type* Value(PhaseGVN* phase) const override;\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(VectorizedHashCodeNode); }\n+  virtual uint hash() const override { return Node::hash() + (uint)(uintptr_t) _in_adr_type; }\n+  virtual bool cmp(const Node& n) const override {\n+    return Node::cmp(n) && _in_adr_type == static_cast<const VectorizedHashCodeNode&>(n)._in_adr_type;\n+  }\n+  virtual const TypePtr* adr_type() const override { return _in_adr_type; }\n@@ -186,1 +236,3 @@\n-class EncodeISOArrayNode: public Node {\n+class EncodeISOArrayNode final : public Node {\n+private:\n+  const TypePtr* const _adr_type;\n@@ -188,3 +240,4 @@\n- public:\n-  EncodeISOArrayNode(Node* control, Node* arymem, Node* s1, Node* s2, Node* c, bool ascii)\n-    : Node(control, arymem, s1, s2, c), _ascii(ascii) {}\n+\n+public:\n+  EncodeISOArrayNode(Node* control, Node* arymem, const TypePtr* adr_type, Node* s1, Node* s2, Node* c, bool ascii)\n+    : Node(control, arymem, s1, s2, c), _adr_type(adr_type), _ascii(ascii) {}\n@@ -193,12 +246,14 @@\n-  virtual int Opcode() const;\n-  virtual bool depends_only_on_test() const { return false; }\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n-  virtual uint match_edge(uint idx) const;\n-  virtual uint ideal_reg() const { return Op_RegI; }\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual uint size_of() const { return sizeof(EncodeISOArrayNode); }\n-  virtual uint hash() const { return Node::hash() + _ascii; }\n-  virtual bool cmp(const Node& n) const {\n-    return Node::cmp(n) && _ascii == ((EncodeISOArrayNode&)n).is_ascii();\n+  virtual int Opcode() const override;\n+  virtual bool depends_only_on_test() const override { return false; }\n+  virtual const Type* bottom_type() const override { return TypeInt::INT; }\n+  virtual uint match_edge(uint idx) const override;\n+  virtual uint ideal_reg() const override { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) override;\n+  virtual const Type* Value(PhaseGVN* phase) const override;\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(EncodeISOArrayNode); }\n+  virtual uint hash() const override { return Node::hash() + (uint)(uintptr_t) _adr_type + _ascii; }\n+  virtual bool cmp(const Node& n) const override {\n+    const EncodeISOArrayNode& e = static_cast<const EncodeISOArrayNode&>(n);\n+    return Node::cmp(n) && _ascii == e._ascii && _adr_type == e._adr_type;\n@@ -206,0 +261,1 @@\n+  virtual const TypePtr* adr_type() const override { return _adr_type; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":129,"deletions":73,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -1125,1 +1125,1 @@\n-  set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));\n+  set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), mtype, arg1, arg2, ae)));\n@@ -6238,2 +6238,3 @@\n-  const TypeAryPtr* mtype = TypeAryPtr::BYTES;\n-  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length, ascii);\n+  const TypePtr* adr_type;\n+  Node* mem = capture_memory(adr_type, TypeAryPtr::get_array_body_type(src_elem), TypeAryPtr::BYTES);\n+  Node* enc = new EncodeISOArrayNode(control(), mem, adr_type, src_start, dst_start, length, ascii);\n@@ -6242,1 +6243,5 @@\n-  set_memory(res_mem, mtype);\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n@@ -6721,1 +6726,2 @@\n-  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+  const TypeAryPtr* in_adr_type = TypeAryPtr::get_array_body_type(bt);\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(in_adr_type), in_adr_type,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import compiler.lib.ir_framework.DontInline;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8373591\n+ * @summary Verify that StringLatin1::inflate and StringUTF16::compress are scheduled properly\n+ * @library \/test\/lib \/\n+ * @modules java.base\/java.lang:+open\n+ * @run driver ${test.main.class}\n+ *\/\n+public class TestAntiDependency {\n+    static final MethodHandle COMPRESS_HANDLE;\n+    static final MethodHandle INFLATE_HANDLE;\n+    static {\n+        try {\n+            var lookup = MethodHandles.privateLookupIn(String.class, MethodHandles.lookup());\n+            Class<?> stringUtf16Class = lookup.findClass(\"java.lang.StringUTF16\");\n+            COMPRESS_HANDLE = lookup.findStatic(stringUtf16Class, \"compress\",\n+                    MethodType.methodType(int.class, char[].class, int.class, byte[].class, int.class, int.class));\n+            Class<?> stringLatin1Class = lookup.findClass(\"java.lang.StringLatin1\");\n+            INFLATE_HANDLE = lookup.findStatic(stringLatin1Class, \"inflate\",\n+                    MethodType.methodType(void.class, byte[].class, int.class, char[].class, int.class, int.class));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-opens=java.base\/java.lang=ALL-UNNAMED\");\n+    }\n+\n+    @DontInline\n+    static void consume(Object o1, Object o2) {}\n+\n+    @Test\n+    static int testStringCompress() throws Throwable {\n+        byte[] dst = new byte[4];\n+        char[] src = new char[4];\n+        consume(dst, src);\n+\n+        \/\/ The compiler must not schedule this after the store to src, either by having\n+        \/\/ StringCompressedCopyNode kill the whole memory, or by taking into consideration the\n+        \/\/ anti-dependency between 2 nodes\n+        int _ = (int) COMPRESS_HANDLE.invokeExact(src, 0, dst, 0, 4);\n+        src[0] = 1;\n+        return dst[0];\n+    }\n+\n+    @Test\n+    static int testStringInflate() throws Throwable {\n+        char[] dst = new char[4];\n+        byte[] src = new byte[4];\n+        consume(dst, src);\n+\n+        \/\/ The compiler must not schedule this after the store to src, either by having\n+        \/\/ StringInflatedCopyNode kill the whole memory, or by taking into consideration the\n+        \/\/ anti-dependency between 2 nodes\n+        INFLATE_HANDLE.invokeExact(src, 0, dst, 0, 4);\n+        src[0] = 1;\n+        return dst[0];\n+    }\n+\n+    @Run(test = {\"testStringCompress\", \"testStringInflate\"})\n+    public void run() throws Throwable {\n+        Asserts.assertEQ(0, testStringCompress());\n+        Asserts.assertEQ(0, testStringInflate());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestAntiDependency.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}