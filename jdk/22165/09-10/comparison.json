{"files":[{"patch":"@@ -343,0 +343,3 @@\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_HasReferencePendingList(JNIEnv *env);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3072,0 +3072,5 @@\n+JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))\n+  MonitorLocker ml(Heap_lock);\n+  return Universe::has_reference_pending_list();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+    \/*\n+     * Test whether the VM's pending-Reference list contains any entries.\n+     *\/\n+    private static native boolean hasReferencePendingList();\n+\n@@ -226,0 +231,3 @@\n+    private static final Object processPendingLock = new Object();\n+    private static boolean processPendingActive = false;\n+\n@@ -229,0 +237,2 @@\n+        \/\/ These are separate operations to avoid a race with other threads\n+        \/\/ that are calling waitForReferenceProcessing().\n@@ -230,1 +240,5 @@\n-        Reference<?> pendingList = getAndClearReferencePendingList();\n+        Reference<?> pendingList;\n+        synchronized (processPendingLock) {\n+            pendingList = getAndClearReferencePendingList();\n+            processPendingActive = true;\n+        }\n@@ -237,0 +251,25 @@\n+        \/\/ Notify any waiters of completion of current round.\n+        synchronized (processPendingLock) {\n+            processPendingActive = false;\n+            processPendingLock.notifyAll();\n+        }\n+    }\n+\n+    \/\/ Wait for progress in reference processing.\n+    \/\/\n+    \/\/ Returns true after waiting (for notification from the reference\n+    \/\/ processing thread) if either (1) the VM has any pending\n+    \/\/ references, or (2) the reference processing thread is\n+    \/\/ processing references. Otherwise, returns false immediately.\n+    private static boolean waitForReferenceProcessing()\n+        throws InterruptedException\n+    {\n+        synchronized (processPendingLock) {\n+            if (processPendingActive || hasReferencePendingList()) {\n+                \/\/ Wait for progress, not necessarily completion.\n+                processPendingLock.wait();\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n@@ -265,0 +304,7 @@\n+            @Override\n+            public boolean waitForReferenceProcessing()\n+                throws InterruptedException\n+            {\n+                return Reference.waitForReferenceProcessing();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -37,0 +37,10 @@\n+    \/**\n+     * Wait for progress in {@link java.lang.ref.Reference}\n+     * processing.  If there aren't any pending {@link\n+     * java.lang.ref.Reference}s, return immediately.\n+     *\n+     * @return {@code true} if there were any pending\n+     * {@link java.lang.ref.Reference}s, {@code false} otherwise.\n+     *\/\n+    boolean waitForReferenceProcessing() throws InterruptedException;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,6 @@\n+JNIEXPORT jboolean JNICALL\n+Java_java_lang_ref_Reference_hasReferencePendingList(JNIEnv *env, jclass ignore)\n+{\n+    return JVM_HasReferencePendingList(env);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/Reference.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}