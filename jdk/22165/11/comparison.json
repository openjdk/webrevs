{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -33,1 +32,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -202,5 +200,0 @@\n-            \/\/ pre-load and initialize Cleaner class so that we don't\n-            \/\/ get into trouble later in the run loop if there's\n-            \/\/ memory shortage while loading\/initializing it lazily.\n-            Unsafe.getUnsafe().ensureClassInitialized(Cleaner.class);\n-\n@@ -256,12 +249,1 @@\n-\n-            if (ref instanceof Cleaner) {\n-                ((Cleaner)ref).clean();\n-                \/\/ Notify any waiters that progress has been made.\n-                \/\/ This improves latency for nio.Bits waiters, which\n-                \/\/ are the only important ones.\n-                synchronized (processPendingLock) {\n-                    processPendingLock.notifyAll();\n-                }\n-            } else {\n-                ref.enqueueFromPending();\n-            }\n+            ref.enqueueFromPending();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+    private static final Object RESERVE_SLOW_LOCK = new Object();\n+\n@@ -110,1 +112,0 @@\n-\n@@ -116,1 +117,1 @@\n-        \/\/ optimist!\n+        \/\/ Optimistic path: enough memory to satisfy allocation.\n@@ -121,1 +122,20 @@\n-        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        \/\/ Short on memory, with potentially many threads competing for it.\n+        \/\/ To alleviate progress races, acquire the lock and go slow.\n+        synchronized (RESERVE_SLOW_LOCK) {\n+            reserveMemorySlow(size, cap);\n+        }\n+    }\n+\n+    static void reserveMemorySlow(long size, long cap) {\n+        \/\/ Slow path under the lock. This code would try to trigger cleanups and\n+        \/\/ sense if cleaning was performed. Since the failure mode is OOME,\n+        \/\/ there is no need to rush.\n+        \/\/\n+        \/\/ If this code is modified, make sure a stress test like DirectBufferAllocTest\n+        \/\/ performs well.\n+\n+        \/\/ Semi-optimistic attempt after acquiring the slow-path lock.\n+        if (tryReserveMemory(size, cap)) {\n+           return;\n+        }\n+\n@@ -124,0 +144,11 @@\n+            BufferCleaner.Canary canary = null;\n+\n+            long sleepTime = 1;\n+            for (int sleeps = 0; sleeps < MAX_SLEEPS; sleeps++) {\n+                if (canary == null || canary.isDead()) {\n+                    \/\/ If canary is not yet initialized, we have not triggered a cleanup.\n+                    \/\/ If canary is dead, there was progress, and it was not enough.\n+                    \/\/ Trigger GC to perform reference processing and then cleaning.\n+                    canary = BufferCleaner.newCanary();\n+                    System.gc();\n+                }\n@@ -125,5 +156,1 @@\n-            \/\/ Retry allocation until success or there are no more\n-            \/\/ references (including Cleaners that might free direct\n-            \/\/ buffer memory) to process and allocation still fails.\n-            boolean refprocActive;\n-            do {\n+                \/\/ Exponentially back off waiting for Cleaner to catch up.\n@@ -131,1 +158,2 @@\n-                    refprocActive = jlra.waitForReferenceProcessing();\n+                    Thread.sleep(sleepTime);\n+                    sleepTime *= 2;\n@@ -133,1 +161,0 @@\n-                    \/\/ Defer interrupts and keep trying.\n@@ -135,4 +162,0 @@\n-                    refprocActive = true;\n-                }\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n@@ -140,17 +163,2 @@\n-            } while (refprocActive);\n-\n-            \/\/ trigger VM's Reference processing\n-            System.gc();\n-\n-            \/\/ A retry loop with exponential back-off delays.\n-            \/\/ Sometimes it would suffice to give up once reference\n-            \/\/ processing is complete.  But if there are many threads\n-            \/\/ competing for memory, this gives more opportunities for\n-            \/\/ any given thread to make progress.  In particular, this\n-            \/\/ seems to be enough for a stress test like\n-            \/\/ DirectBufferAllocTest to (usually) succeed, while\n-            \/\/ without it that test likely fails.  Since failure here\n-            \/\/ ends in OOME, there's no need to hurry.\n-            long sleepTime = 1;\n-            int sleeps = 0;\n-            while (true) {\n+\n+                \/\/ See if we can satisfy the allocation now.\n@@ -160,12 +168,0 @@\n-                if (sleeps >= MAX_SLEEPS) {\n-                    break;\n-                }\n-                try {\n-                    if (!jlra.waitForReferenceProcessing()) {\n-                        Thread.sleep(sleepTime);\n-                        sleepTime <<= 1;\n-                        sleeps++;\n-                    }\n-                } catch (InterruptedException e) {\n-                    interrupted = true;\n-                }\n@@ -174,1 +170,1 @@\n-            \/\/ no luck\n+            \/\/ No luck:\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":40,"deletions":44,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.nio;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+\n+\/**\n+ * Handles buffer cleaners.\n+ *\/\n+class BufferCleaner {\n+    private static final Cleaner CLEANER = Cleaner.create();\n+\n+    private BufferCleaner() {\n+        \/\/ No instantiation.\n+    }\n+\n+    \/**\n+     * Register a new cleanable for object and associated action.\n+     *\n+     * @param obj object to track\n+     * @param action cleanup action\n+     * @return associated cleanable\n+     *\/\n+    static Cleanable register(Object obj, Runnable action) {\n+        if (action != null) {\n+            return CLEANER.register(obj, action);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Sets up a new canary on the same cleaner. When canary is dead,\n+     * it is a signal that cleaner had acted.\n+     *\n+     * @return a canary\n+     *\/\n+    static Canary newCanary() {\n+        Canary canary = new Canary();\n+        register(new Object(), canary);\n+        return canary;\n+    }\n+\n+    \/**\n+     * A canary.\n+     *\/\n+    static class Canary implements Runnable {\n+        volatile boolean dead;\n+\n+        @Override\n+        public void run() {\n+            dead = true;\n+        }\n+\n+        public boolean isDead() {\n+            return dead;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -40,1 +41,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -81,2 +81,10 @@\n-            UNSAFE.freeMemory(address);\n-            Bits.unreserveMemory(size, capacity);\n+            try {\n+                UNSAFE.freeMemory(address);\n+                Bits.unreserveMemory(size, capacity);\n+            } catch (Throwable x) {\n+                \/\/ Long-standing behavior: when deallocation fails, VM exits.\n+                if (System.err != null) {\n+                    new Error(\"Cleaner terminated abnormally\", x).printStackTrace();\n+                }\n+                System.exit(1);\n+            }\n@@ -86,1 +94,1 @@\n-    private final Cleaner cleaner;\n+    private final Cleanable cleanable;\n@@ -88,1 +96,3 @@\n-    public Cleaner cleaner() { return cleaner; }\n+    public Cleanable cleanable() {\n+        return cleanable;\n+    }\n@@ -92,1 +102,1 @@\n-    public Cleaner cleaner() { return null; }\n+    public Cleanable cleanable() { return null; }\n@@ -125,1 +135,1 @@\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            cleanable = BufferCleaner.register(this, new Deallocator(base, size, cap));\n@@ -147,1 +157,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -157,1 +167,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -168,1 +178,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -200,1 +210,1 @@\n-        cleaner = Cleaner.create(this, unmapper);\n+        cleanable = BufferCleaner.register(this, unmapper);\n@@ -227,1 +237,1 @@\n-        cleaner = null;\n+        cleanable = null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -3875,3 +3875,3 @@\n-        Cleaner cleaner = db.cleaner();\n-        if (cleaner != null) {\n-            cleaner.clean();\n+        Cleanable cleanable = db.cleanable();\n+        if (cleanable != null) {\n+            cleanable.clean();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.*;\n-\n-\n-\/**\n- * General-purpose phantom-reference-based cleaners.\n- *\n- * <p> Cleaners are a lightweight and more robust alternative to finalization.\n- * They are lightweight because they are not created by the VM and thus do not\n- * require a JNI upcall to be created, and because their cleanup code is\n- * invoked directly by the reference-handler thread rather than by the\n- * finalizer thread.  They are more robust because they use phantom references,\n- * the weakest type of reference object, thereby avoiding the nasty ordering\n- * problems inherent to finalization.\n- *\n- * <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary\n- * cleanup code.  Some time after the GC detects that a cleaner's referent has\n- * become phantom-reachable, the reference-handler thread will run the cleaner.\n- * Cleaners may also be invoked directly; they are thread safe and ensure that\n- * they run their thunks at most once.\n- *\n- * <p> Cleaners are not a replacement for finalization.  They should be used\n- * only when the cleanup code is extremely simple and straightforward.\n- * Nontrivial cleaners are inadvisable since they risk blocking the\n- * reference-handler thread and delaying further cleanup and finalization.\n- *\n- *\n- * @author Mark Reinhold\n- *\/\n-\n-public class Cleaner\n-    extends PhantomReference<Object>\n-{\n-\n-    \/\/ Dummy reference queue, needed because the PhantomReference constructor\n-    \/\/ insists that we pass a queue.  Nothing will ever be placed on this queue\n-    \/\/ since the reference handler invokes cleaners explicitly.\n-    \/\/\n-    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue<>();\n-\n-    \/\/ Doubly-linked list of live cleaners, which prevents the cleaners\n-    \/\/ themselves from being GC'd before their referents\n-    \/\/\n-    private static Cleaner first = null;\n-\n-    private Cleaner\n-        next = null,\n-        prev = null;\n-\n-    private static synchronized Cleaner add(Cleaner cl) {\n-        if (first != null) {\n-            cl.next = first;\n-            first.prev = cl;\n-        }\n-        first = cl;\n-        return cl;\n-    }\n-\n-    private static synchronized boolean remove(Cleaner cl) {\n-\n-        \/\/ If already removed, do nothing\n-        if (cl.next == cl)\n-            return false;\n-\n-        \/\/ Update list\n-        if (first == cl) {\n-            if (cl.next != null)\n-                first = cl.next;\n-            else\n-                first = cl.prev;\n-        }\n-        if (cl.next != null)\n-            cl.next.prev = cl.prev;\n-        if (cl.prev != null)\n-            cl.prev.next = cl.next;\n-\n-        \/\/ Indicate removal by pointing the cleaner to itself\n-        cl.next = cl;\n-        cl.prev = cl;\n-        return true;\n-\n-    }\n-\n-    private final Runnable thunk;\n-\n-    private Cleaner(Object referent, Runnable thunk) {\n-        super(referent, dummyQueue);\n-        this.thunk = thunk;\n-    }\n-\n-    \/**\n-     * Creates a new cleaner.\n-     *\n-     * @param  ob the referent object to be cleaned\n-     * @param  thunk\n-     *         The cleanup code to be run when the cleaner is invoked.  The\n-     *         cleanup code is run directly from the reference-handler thread,\n-     *         so it should be as simple and straightforward as possible.\n-     *\n-     * @return  The new cleaner\n-     *\/\n-    public static Cleaner create(Object ob, Runnable thunk) {\n-        if (thunk == null)\n-            return null;\n-        return add(new Cleaner(ob, thunk));\n-    }\n-\n-    \/**\n-     * Runs this cleaner, if it has not been run before.\n-     *\/\n-    public void clean() {\n-        if (!remove(this))\n-            return;\n-        try {\n-            thunk.run();\n-        } catch (final Throwable x) {\n-            if (System.err != null) {\n-                new Error(\"Cleaner terminated abnormally\", x)\n-                        .printStackTrace();\n-            }\n-            System.exit(1);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/Cleaner.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -44,1 +44,1 @@\n-    public Cleaner cleaner();\n+    public Cleanable cleanable();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.lang.ref.Cleaner;\n@@ -61,1 +62,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -1440,2 +1440,2 @@\n-        Cleaner cl = ((DirectBuffer)bb).cleaner();\n-        if (cl != null)\n+        Cleanable cl = ((DirectBuffer)bb).cleanable();\n+        if (cl != null) {\n@@ -1443,0 +1443,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            assertTrue(directBuffer.cleaner() == null);\n+            assertTrue(directBuffer.cleanable() == null);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4954921 8009259\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.ref\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.Asserts\n- *        jdk.test.lib.JDKToolFinder\n- *        jdk.test.lib.JDKToolLauncher\n- *        jdk.test.lib.Platform\n- *        jdk.test.lib.process.*\n- * @run main ExitOnThrow\n- * @summary Ensure that if a cleaner throws an exception then the VM exits\n- *\/\n-\n-import jdk.internal.ref.Cleaner;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ExitOnThrow {\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            ProcessTools.executeTestJava(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n-                                         \"ExitOnThrow\",\n-                                         \"-executeCleaner\")\n-                        .outputTo(System.out)\n-                        .errorTo(System.out)\n-                        .shouldHaveExitValue(1)\n-                        .shouldContain(\"java.lang.RuntimeException: Foo!\");\n-        } else {\n-            Cleaner.create(new Object(),\n-                           () -> { throw new RuntimeException(\"Foo!\"); } );\n-            while (true) {\n-                System.gc();\n-                Thread.sleep(100);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/ExitOnThrow.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean direct = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return direct ? ByteBuffer.allocateDirect(1) : ByteBuffer.allocate(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferChurn.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all buffers are reachable and available for GC. Buffers\n+    \/\/ directly reference their Cleanables, so we do not want to provide\n+    \/\/ excess GC parallelism opportunities here, this is why reference\n+    \/\/ buffers from a linked list.\n+    \/\/\n+    \/\/ This exposes the potential GC parallelism problem in Cleaner lists.\n+    LinkedList<ByteBuffer> buffers;\n+\n+    @Setup\n+    public void setup() {\n+        buffers = new LinkedList<>();\n+        for (int c = 0; c < count; c++) {\n+            buffers.add(ByteBuffer.allocateDirect(1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferGC.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}