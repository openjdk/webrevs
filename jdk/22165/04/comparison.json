{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -33,1 +32,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -202,5 +200,0 @@\n-            \/\/ pre-load and initialize Cleaner class so that we don't\n-            \/\/ get into trouble later in the run loop if there's\n-            \/\/ memory shortage while loading\/initializing it lazily.\n-            Unsafe.getUnsafe().ensureClassInitialized(Cleaner.class);\n-\n@@ -256,12 +249,1 @@\n-\n-            if (ref instanceof Cleaner) {\n-                ((Cleaner)ref).clean();\n-                \/\/ Notify any waiters that progress has been made.\n-                \/\/ This improves latency for nio.Bits waiters, which\n-                \/\/ are the only important ones.\n-                synchronized (processPendingLock) {\n-                    processPendingLock.notifyAll();\n-                }\n-            } else {\n-                ref.enqueueFromPending();\n-            }\n+            ref.enqueueFromPending();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -40,1 +42,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -81,2 +82,10 @@\n-            UNSAFE.freeMemory(address);\n-            Bits.unreserveMemory(size, capacity);\n+            try {\n+                UNSAFE.freeMemory(address);\n+                Bits.unreserveMemory(size, capacity);\n+            } catch (Throwable x) {\n+                \/\/ Long-standing behavior: when deallocation fails, VM exits.\n+                if (System.err != null) {\n+                    new Error(\"Cleaner terminated abnormally\", x).printStackTrace();\n+                }\n+                System.exit(1);\n+            }\n@@ -86,1 +95,4 @@\n-    private final Cleaner cleaner;\n+    \/\/ Singleton Cleaner for all relevant Buffer instances.\n+    \/\/ Lazily initialized to avoid bootstrapping circularities involving <clinit>.\n+    private static class CleanerHolder {\n+        private static final Cleaner CLEANER = Cleaner.create();\n@@ -88,1 +100,14 @@\n-    public Cleaner cleaner() { return cleaner; }\n+        static Cleanable register(Object buffer, Runnable action) {\n+            if (action != null) {\n+                return CLEANER.register(buffer, action);\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private final Cleanable cleanable;\n+\n+    public Cleanable cleanable() {\n+        return cleanable;\n+    }\n@@ -92,1 +117,1 @@\n-    public Cleaner cleaner() { return null; }\n+    public Cleanable cleanable() { return null; }\n@@ -125,1 +150,1 @@\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            cleanable = CleanerHolder.register(this, new Deallocator(base, size, cap));\n@@ -147,1 +172,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -157,1 +182,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -168,1 +193,1 @@\n-        cleaner = null;\n+        cleanable = null;\n@@ -200,1 +225,1 @@\n-        cleaner = Cleaner.create(this, unmapper);\n+        cleanable = CleanerHolder.register(this, unmapper);\n@@ -227,1 +252,1 @@\n-        cleaner = null;\n+        cleanable = null;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -3865,3 +3865,3 @@\n-        Cleaner cleaner = db.cleaner();\n-        if (cleaner != null) {\n-            cleaner.clean();\n+        Cleanable cleanable = db.cleanable();\n+        if (cleanable != null) {\n+            cleanable.clean();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.ref;\n-\n-import java.lang.ref.*;\n-\n-\n-\/**\n- * General-purpose phantom-reference-based cleaners.\n- *\n- * <p> Cleaners are a lightweight and more robust alternative to finalization.\n- * They are lightweight because they are not created by the VM and thus do not\n- * require a JNI upcall to be created, and because their cleanup code is\n- * invoked directly by the reference-handler thread rather than by the\n- * finalizer thread.  They are more robust because they use phantom references,\n- * the weakest type of reference object, thereby avoiding the nasty ordering\n- * problems inherent to finalization.\n- *\n- * <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary\n- * cleanup code.  Some time after the GC detects that a cleaner's referent has\n- * become phantom-reachable, the reference-handler thread will run the cleaner.\n- * Cleaners may also be invoked directly; they are thread safe and ensure that\n- * they run their thunks at most once.\n- *\n- * <p> Cleaners are not a replacement for finalization.  They should be used\n- * only when the cleanup code is extremely simple and straightforward.\n- * Nontrivial cleaners are inadvisable since they risk blocking the\n- * reference-handler thread and delaying further cleanup and finalization.\n- *\n- *\n- * @author Mark Reinhold\n- *\/\n-\n-public class Cleaner\n-    extends PhantomReference<Object>\n-{\n-\n-    \/\/ Dummy reference queue, needed because the PhantomReference constructor\n-    \/\/ insists that we pass a queue.  Nothing will ever be placed on this queue\n-    \/\/ since the reference handler invokes cleaners explicitly.\n-    \/\/\n-    private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue<>();\n-\n-    \/\/ Doubly-linked list of live cleaners, which prevents the cleaners\n-    \/\/ themselves from being GC'd before their referents\n-    \/\/\n-    private static Cleaner first = null;\n-\n-    private Cleaner\n-        next = null,\n-        prev = null;\n-\n-    private static synchronized Cleaner add(Cleaner cl) {\n-        if (first != null) {\n-            cl.next = first;\n-            first.prev = cl;\n-        }\n-        first = cl;\n-        return cl;\n-    }\n-\n-    private static synchronized boolean remove(Cleaner cl) {\n-\n-        \/\/ If already removed, do nothing\n-        if (cl.next == cl)\n-            return false;\n-\n-        \/\/ Update list\n-        if (first == cl) {\n-            if (cl.next != null)\n-                first = cl.next;\n-            else\n-                first = cl.prev;\n-        }\n-        if (cl.next != null)\n-            cl.next.prev = cl.prev;\n-        if (cl.prev != null)\n-            cl.prev.next = cl.next;\n-\n-        \/\/ Indicate removal by pointing the cleaner to itself\n-        cl.next = cl;\n-        cl.prev = cl;\n-        return true;\n-\n-    }\n-\n-    private final Runnable thunk;\n-\n-    private Cleaner(Object referent, Runnable thunk) {\n-        super(referent, dummyQueue);\n-        this.thunk = thunk;\n-    }\n-\n-    \/**\n-     * Creates a new cleaner.\n-     *\n-     * @param  ob the referent object to be cleaned\n-     * @param  thunk\n-     *         The cleanup code to be run when the cleaner is invoked.  The\n-     *         cleanup code is run directly from the reference-handler thread,\n-     *         so it should be as simple and straightforward as possible.\n-     *\n-     * @return  The new cleaner\n-     *\/\n-    public static Cleaner create(Object ob, Runnable thunk) {\n-        if (thunk == null)\n-            return null;\n-        return add(new Cleaner(ob, thunk));\n-    }\n-\n-    \/**\n-     * Runs this cleaner, if it has not been run before.\n-     *\/\n-    public void clean() {\n-        if (!remove(this))\n-            return;\n-        try {\n-            thunk.run();\n-        } catch (final Throwable x) {\n-            if (System.err != null) {\n-                new Error(\"Cleaner terminated abnormally\", x)\n-                        .printStackTrace();\n-            }\n-            System.exit(1);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/Cleaner.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -44,1 +44,1 @@\n-    public Cleaner cleaner();\n+    public Cleanable cleanable();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.lang.ref.Cleaner;\n@@ -61,1 +62,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -1440,2 +1440,2 @@\n-        Cleaner cl = ((DirectBuffer)bb).cleaner();\n-        if (cl != null)\n+        Cleanable cl = ((DirectBuffer)bb).cleanable();\n+        if (cl != null) {\n@@ -1443,0 +1443,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            assertTrue(directBuffer.cleaner() == null);\n+            assertTrue(directBuffer.cleanable() == null);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4954921 8009259\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.ref\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.Asserts\n- *        jdk.test.lib.JDKToolFinder\n- *        jdk.test.lib.JDKToolLauncher\n- *        jdk.test.lib.Platform\n- *        jdk.test.lib.process.*\n- * @run main ExitOnThrow\n- * @summary Ensure that if a cleaner throws an exception then the VM exits\n- *\/\n-\n-import jdk.internal.ref.Cleaner;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class ExitOnThrow {\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            ProcessTools.executeTestJava(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n-                                         \"ExitOnThrow\",\n-                                         \"-executeCleaner\")\n-                        .outputTo(System.out)\n-                        .errorTo(System.out)\n-                        .shouldHaveExitValue(1)\n-                        .shouldContain(\"java.lang.RuntimeException: Foo!\");\n-        } else {\n-            Cleaner.create(new Object(),\n-                           () -> { throw new RuntimeException(\"Foo!\"); } );\n-            while (true) {\n-                System.gc();\n-                Thread.sleep(100);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/ExitOnThrow.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean direct = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return direct ? ByteBuffer.allocateDirect(1) : ByteBuffer.allocate(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferChurn.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all buffers are reachable and available for GC. Buffers\n+    \/\/ directly reference their Cleanables, so we do not want to provide\n+    \/\/ excess GC parallelism opportunities here, this is why reference\n+    \/\/ buffers from a linked list.\n+    \/\/\n+    \/\/ This exposes the potential GC parallelism problem in Cleaner lists.\n+    LinkedList<ByteBuffer> buffers;\n+\n+    @Setup\n+    public void setup() {\n+        buffers = new LinkedList<>();\n+        for (int c = 0; c < count; c++) {\n+            buffers.add(ByteBuffer.allocateDirect(1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferGC.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}