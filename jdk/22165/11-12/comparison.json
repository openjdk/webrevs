{"files":[{"patch":"@@ -142,0 +142,33 @@\n+        \/\/ No free memory. We need to trigger cleanups and wait for them to make progress.\n+        \/\/ This requires triggering the GC and waiting for eventual buffer cleanups\n+        \/\/ or the absence of any profitable cleanups.\n+        \/\/\n+        \/\/ To do this efficiently, we need to wait for several activities to run:\n+        \/\/   1. GC needs to discover dead references and hand them over to Reference\n+        \/\/      processing thread. This activity can be asynchronous and can complete after\n+        \/\/      we unblock from System.gc().\n+        \/\/   2. Reference processing thread needs to process dead references and enqueue them\n+        \/\/      to Cleaner thread. This activity is normally concurrent with the rest of\n+        \/\/      Java code, and is subject to reference processing thread having time to process.\n+        \/\/   3. Cleaner thread needs to process the enqueued references and call cleanables\n+        \/\/      on dead buffers. Like (2), this activity is also concurrent, and relies on\n+        \/\/      Cleaner getting time to act.\n+        \/\/\n+        \/\/ It is somewhat simple to wait for Reference processing and Cleaner threads to be idle.\n+        \/\/ However, that is not a good indicator they have processed buffers since our last\n+        \/\/ System.gc() request: they may not have started yet after System.gc() unblocked,\n+        \/\/ or have not yet seen that previous step ran. It is Really Hard (tm) to coordinate\n+        \/\/ all these activities.\n+        \/\/\n+        \/\/ Instead, we are checking directly if Cleaner have acted on since our last System.gc():\n+        \/\/ install the canary, call System.gc(), wait for canary to get processed (dead). This\n+        \/\/ signals that since our last call to System.gc(), steps (1) and (2) have finished, and\n+        \/\/ step (3) is currently in progress.\n+        \/\/\n+        \/\/ The last bit is a corner case: since canary is not ordered with other buffer cleanups,\n+        \/\/ it is possible that canary gets dead before the rest of the buffers get cleaned. This\n+        \/\/ corner case would be handled with a normal retry attempt, after trying to allocate.\n+        \/\/ If allocation succeeds even after partial cleanup, we are done. If it does not, we get\n+        \/\/ to try again, this time reliably getting the results of the first cleanup run. Not\n+        \/\/ handling this case specially simplifies implementation.\n+\n@@ -151,1 +184,1 @@\n-                    \/\/ Trigger GC to perform reference processing and then cleaning.\n+                    \/\/ Trigger GC -> Reference processing -> Cleaner again.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}