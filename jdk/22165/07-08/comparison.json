{"files":[{"patch":"@@ -343,3 +343,0 @@\n-\n-JNIEXPORT jboolean JNICALL\n-JVM_HasReferencePendingList(JNIEnv *env);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3073,5 +3073,0 @@\n-JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))\n-  MonitorLocker ml(Heap_lock);\n-  return Universe::has_reference_pending_list();\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,5 +211,0 @@\n-    \/*\n-     * Test whether the VM's pending-Reference list contains any entries.\n-     *\/\n-    private static native boolean hasReferencePendingList();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+\/**\n+ * Handles buffer cleaners.\n+ *\/\n@@ -34,1 +37,12 @@\n-    static Cleanable register(Object buffer, Runnable action) {\n+    private BufferCleaner() {\n+        \/\/ No instantiation.\n+    }\n+\n+    \/**\n+     * Register a new cleanable for object and associated action.\n+     *\n+     * @param obj object to track\n+     * @param action cleanup action\n+     * @return associated cleanable\n+     *\/\n+    static Cleanable register(Object obj, Runnable action) {\n@@ -36,1 +50,1 @@\n-            return CLEANER.register(buffer, action);\n+            return CLEANER.register(obj, action);\n@@ -42,0 +56,6 @@\n+    \/**\n+     * Sets up a new canary on the same cleaner. When canary is dead,\n+     * it is a signal that cleaner had acted.\n+     *\n+     * @return a canary\n+     *\/\n@@ -48,0 +68,3 @@\n+    \/**\n+     * A canary.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,6 +35,0 @@\n-JNIEXPORT jboolean JNICALL\n-Java_java_lang_ref_Reference_hasReferencePendingList(JNIEnv *env, jclass ignore)\n-{\n-    return JVM_HasReferencePendingList(env);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/Reference.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          java.base\/java.lang.ref:open\n@@ -135,0 +136,1 @@\n+     *   java.lang.ref.Reference.waitForReferenceProcessing\n@@ -138,0 +140,1 @@\n+        private static final Method waitForReferenceProcessingMethod;\n@@ -149,0 +152,4 @@\n+                waitForReferenceProcessingMethod =\n+                    Reference.class.getDeclaredMethod(\"waitForReferenceProcessing\");\n+                waitForReferenceProcessingMethod.setAccessible(true);\n+\n@@ -176,0 +183,19 @@\n+        static boolean Reference_waitForReferenceProcessing() {\n+            try {\n+                return (boolean) waitForReferenceProcessingMethod.invoke(null);\n+            } catch (InvocationTargetException e) {\n+                Throwable te = e.getTargetException();\n+                if (te instanceof InterruptedException) {\n+                    return true;\n+                } else if (te instanceof RuntimeException) {\n+                    throw (RuntimeException) te;\n+                } else if (te instanceof Error) {\n+                    throw (Error) te;\n+                } else {\n+                    throw new UndeclaredThrowableException(te);\n+                }\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/provider\/FileInputStreamPool\/FileInputStreamPoolTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}