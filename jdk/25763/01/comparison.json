{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -708,2 +709,2 @@\n-  \/\/ AOT profiles are supported only in the JEP 483 workflow.\n-  bool can_dump_profiles = AOTClassLinking && new_aot_flags_used();\n+  \/\/ AOT profiles and AOT-compiled code are supported only in the JEP 483 workflow.\n+  bool can_dump_profile_and_compiled_code = AOTClassLinking && new_aot_flags_used();\n@@ -711,1 +712,1 @@\n-  if (is_dumping_preimage_static_archive() && can_dump_profiles) {\n+  if (is_dumping_preimage_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -715,1 +716,2 @@\n-  } else if (is_dumping_final_static_archive() && can_dump_profiles) {\n+    AOTCodeCache::disable_caching(); \/\/ No AOT code generation during training run\n+  } else if (is_dumping_final_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -719,0 +721,2 @@\n+    AOTCodeCache::enable_caching(); \/\/ Generate AOT code during assembly phase.\n+    disable_dumping_aot_code();     \/\/ Don't dump AOT code until metadata and heap are dumped.\n@@ -723,0 +727,1 @@\n+    AOTCodeCache::enable_caching();\n@@ -726,0 +731,1 @@\n+    AOTCodeCache::disable_caching();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -926,1 +926,1 @@\n-     aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2017,4 +2017,1 @@\n-    if (AOTCodeCache::is_on_for_use()) {\n-      tty->print_cr(\"\\n\\nAOT Code\");\n-      AOTCodeCache::print_on(tty);\n-    }\n+    AOTCodeCache::print_on(tty);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -87,2 +86,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -91,0 +89,21 @@\n+\/\/ The sequence of AOT code caching flags and parametters settings.\n+\/\/\n+\/\/ 1. The initial AOT code caching flags setting is done\n+\/\/ during call to CDSConfig::check_vm_args_consistency().\n+\/\/\n+\/\/ 2. The earliest AOT code state check done in compilationPolicy_init()\n+\/\/ where we set number of compiler threads for AOT assembly phase.\n+\/\/\n+\/\/ 3. We determine presence of AOT code in AOT Cache in\n+\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ after compilationPolicy_init() but before codeCache_init().\n+\/\/\n+\/\/ 4. AOTCodeCache::initialize() is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n+\/\/\n+\/\/ 5. Finally AOTCodeCache::init2() is called after universe_init()\n+\/\/ when all GC settings are finalized.\n+\n+\/\/ Next methods determine which action we do with AOT code depending\n+\/\/ on phase of AOT process: assembly or production.\n+\n@@ -107,0 +126,17 @@\n+\/\/ Next methods could be called regardless AOT code cache status.\n+\/\/ Initially they are called during flags parsing and finilized\n+\/\/ in AOTCodeCache::initialize().\n+void AOTCodeCache::enable_caching() {\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+}\n+\n+void AOTCodeCache::disable_caching() {\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+  FLAG_SET_ERGO(AOTAdapterCaching, false);\n+}\n+\n+bool AOTCodeCache::is_caching_enabled() {\n+  return AOTStubCaching || AOTAdapterCaching;\n+}\n+\n@@ -128,2 +164,4 @@\n-\/\/ This method is called during universe_init()\n-\/\/ and does final AOT state and flags settings.\n+\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ which is called from universe_init().\n+\/\/ At this point all AOT class linking seetings are finilized\n+\/\/ and AOT cache is open so we can map AOT code region.\n@@ -133,2 +171,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  disable_caching();\n@@ -139,2 +176,1 @@\n-    AOTAdapterCaching = false;\n-    AOTStubCaching = false;\n+    disable_caching();\n@@ -161,2 +197,0 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -164,0 +198,2 @@\n+    enable_caching();\n+    is_dumping = is_caching_enabled();\n@@ -165,3 +201,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n-    is_using = true;\n+    enable_caching();\n+    is_using = is_caching_enabled();\n@@ -170,0 +205,1 @@\n+    disable_caching();\n@@ -172,1 +208,2 @@\n-  if (!AOTAdapterCaching && !AOTStubCaching) {\n+  if (!(is_dumping || is_using)) {\n+    disable_caching();\n@@ -185,0 +222,1 @@\n+    disable_caching();\n@@ -204,0 +242,1 @@\n+DEBUG_ONLY( bool AOTCodeCache::_passed_init2 = false; )\n@@ -205,2 +244,1 @@\n-\/\/ This method is called after universe_init()\n-\/\/ when all GC settings are finalized.\n+\/\/ It is called after universe_init() when all GC settings are finalized.\n@@ -208,0 +246,1 @@\n+  DEBUG_ONLY( _passed_init2 = true; )\n@@ -223,1 +262,0 @@\n-  table->init_early_stubs();\n@@ -315,0 +353,7 @@\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n@@ -1694,0 +1739,2 @@\n+\/\/ This is called after initialize() but before init2()\n+\/\/ and _cache is not set yet.\n@@ -1695,4 +1742,4 @@\n-  AOTCodeCache* cache = open_for_use();\n-  if (cache != nullptr) {\n-    uint count = cache->_load_header->entries_count();\n-    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+  if (opened_cache != nullptr && opened_cache->for_use()) {\n+    st->print_cr(\"\\nAOT Code Cache\");\n+    uint count = opened_cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)opened_cache->addr(opened_cache->_load_header->entries_offset()); \/\/ [id, index]\n@@ -1708,1 +1755,1 @@\n-      const char* saved_name = cache->addr(name_offset);\n+      const char* saved_name = opened_cache->addr(name_offset);\n@@ -1710,2 +1757,2 @@\n-      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n-                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+      st->print_cr(\"%4u: %10s idx:%4u Id:%u size=%u '%s'\",\n+                   i, aot_code_entry_kind_name[entry->kind()], index, entry->id(), entry->size(), saved_name);\n@@ -1713,2 +1760,0 @@\n-  } else {\n-    st->print_cr(\"failed to map code cache\");\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":74,"deletions":29,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,0 +300,1 @@\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n@@ -349,1 +350,2 @@\n-  static AOTCodeCache*  _cache;\n+  static AOTCodeCache* _cache;\n+  DEBUG_ONLY( static bool _passed_init2; )\n@@ -359,1 +361,1 @@\n-  static AOTCodeCache* cache() { return _cache; }\n+  static AOTCodeCache* cache() { assert(_passed_init2, \"Too early to ask\"); return _cache; }\n@@ -363,1 +365,1 @@\n-  static bool is_on() CDS_ONLY({ return _cache != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on() CDS_ONLY({ return cache() != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n@@ -366,4 +368,0 @@\n-\n-  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n-  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n-\n@@ -371,0 +369,1 @@\n+  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n@@ -372,0 +371,4 @@\n+  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n+  static void enable_caching() NOT_CDS_RETURN;\n+  static void disable_caching() NOT_CDS_RETURN;\n+  static bool is_caching_enabled() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  static address  base_addr()        { return  (address)&_base; }\n+  static address  base_addr()        { return (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,2 +223,2 @@\n-       last_ctd = ctd;\n-       mtd->notice_toplevel_compilation(level);\n+      last_ctd = ctd;\n+      mtd->notice_toplevel_compilation(level);\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4554,1 +4554,1 @@\n-    log()->head(\"late_inline method='%d'  inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n+    log()->head(\"late_inline method='%d' inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-jint universe_init();           \/\/ depends on codeCache_init and initial_stubs_init\n+jint universe_init();           \/\/ depends on codeCache_init and preuniverse_stubs_init\n@@ -135,7 +135,2 @@\n-  \/\/ stub routines in initial blob are referenced by later generated code\n-  initial_stubs_init();\n-  \/\/ stack overflow exception blob is referenced by the interpreter\n-  SharedRuntime::generate_initial_stubs();\n-  jint status = universe_init();  \/\/ dependent on codeCache_init and\n-                                  \/\/ initial_stubs_init and metaspace_init.\n-  if (status != JNI_OK)\n+  jint status = universe_init();  \/\/ dependent on codeCache_init and preuniverse_stubs_init\n+  if (status != JNI_OK) {\n@@ -143,1 +138,1 @@\n-\n+  }\n@@ -151,1 +146,1 @@\n-  AOTCodeCache::init2();     \/\/ depends on universe_init\n+  AOTCodeCache::init2();     \/\/ depends on universe_init, must be before initial_stubs_init\n@@ -153,0 +148,5 @@\n+\n+  initial_stubs_init();      \/\/ initial stub routines\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n+  AOTCodeCache::init_early_stubs_table();  \/\/ need this after initial_stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -573,0 +573,1 @@\n+    assert (StubRoutines::catch_exception_entry() != nullptr, \"must be generated before\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -291,5 +291,20 @@\n-  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n-  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n-  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n-  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n-  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+  static address throw_AbstractMethodError_entry()          {\n+    assert(_throw_AbstractMethodError_blob != nullptr, \"\");\n+    return _throw_AbstractMethodError_blob->entry_point();\n+  }\n+  static address throw_IncompatibleClassChangeError_entry() {\n+    assert(_throw_IncompatibleClassChangeError_blob != nullptr, \"\");\n+    return  _throw_IncompatibleClassChangeError_blob->entry_point();\n+  }\n+  static address throw_NullPointerException_at_call_entry() {\n+    assert(_throw_NullPointerException_at_call_blob != nullptr, \"\");\n+    return  _throw_NullPointerException_at_call_blob->entry_point();\n+  }\n+  static address throw_StackOverflowError_entry()           {\n+    assert(_throw_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_StackOverflowError_blob->entry_point();\n+  }\n+  static address throw_delayed_StackOverflowError_entry()   {\n+    assert(_throw_delayed_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_delayed_StackOverflowError_blob->entry_point();\n+  }\n@@ -298,2 +313,8 @@\n-  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n-  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+  static address jfr_write_checkpoint() {\n+    assert(_jfr_write_checkpoint_blob != nullptr, \"\");\n+    return _jfr_write_checkpoint_blob->entry_point();\n+  }\n+  static address jfr_return_lease()     {\n+    assert(_jfr_return_lease_blob != nullptr, \"\");\n+    return _jfr_return_lease_blob->entry_point();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -184,4 +184,0 @@\n-\/\/\n-\/\/ Note: to break cycle with universe initialization, stubs are generated in two phases.\n-\/\/ The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).\n-\/\/ The second phase includes all other stubs (which may depend on universe being initialized.)\n@@ -197,0 +193,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -207,0 +204,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static CallStub call_stub()                              { assert(_call_stub_entry != nullptr, \"\"); return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}