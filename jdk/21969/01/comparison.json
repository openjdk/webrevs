{"files":[{"patch":"@@ -327,1 +327,1 @@\n-  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+  AssertionPredicateType _assertion_predicate_type;\n@@ -429,1 +429,1 @@\n-  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n+  IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);\n@@ -451,1 +451,0 @@\n-#ifndef PRODUCT\n@@ -456,0 +455,1 @@\n+#ifndef PRODUCT\n@@ -471,1 +471,0 @@\n-#ifndef PRODUCT\n@@ -476,1 +475,0 @@\n-#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-      _fcnt(fcnt)\n-      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(AssertionPredicateType::None) {\n@@ -58,1 +58,0 @@\n-#ifndef PRODUCT\n@@ -66,1 +65,0 @@\n-#endif \/\/ NOT_PRODUCT\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs\n-                                                        NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type)) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                        AssertionPredicateType assertion_predicate_type) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1783,6 +1783,2 @@\n-void PhaseIdealLoop::update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init,\n-                                                           const int stride_con) {\n-  Node* entry = ctrl;\n-  Node* prev_proj = ctrl;\n-  LoopNode* outer_loop_head = loop_head->skip_strip_mined();\n-  IdealLoopTree* outer_loop = get_loop(outer_loop_head);\n+void PhaseIdealLoop::update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head) {\n+  Node* init = main_loop_head->init_trip();\n@@ -1792,32 +1788,8 @@\n-  int new_stride_con = stride_con * 2;\n-  Node* max_value = _igvn.intcon(new_stride_con);\n-  set_ctrl(max_value, C->root());\n-\n-  while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n-    IfNode* iff = entry->in(0)->as_If();\n-    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n-    if (!proj->unique_ctrl_out()->is_Halt()) {\n-      break;\n-    }\n-    Node* bol = iff->in(1);\n-    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      \/\/ This is a Template Assertion Predicate for the initial or last access.\n-      \/\/ Create an Initialized Assertion Predicates for it accordingly:\n-      \/\/ - For the initial access a[init] (same as before)\n-      \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n-      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n-    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n-      \/\/ This is one of the two Initialized Assertion Predicates:\n-      \/\/ - For the initial access a[init]\n-      \/\/ - For the last access a[init+old_stride-orig_stride]\n-      \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n-      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n-    }\n-    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n-    entry = entry->in(0)->in(0);\n-  }\n-  if (prev_proj != ctrl) {\n-    _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);\n-    set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));\n-  }\n+  int unrolled_stride_con = main_loop_head->stride_con() * 2;\n+  Node* unrolled_stride = _igvn.intcon(unrolled_stride_con);\n+  set_ctrl(unrolled_stride, C->root());\n+\n+  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(loop_entry);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  predicate_iterator.for_each(update_stride_for_assertion_predicates);\n@@ -1940,1 +1912,1 @@\n-  update_main_loop_assertion_predicates(ctrl, loop_head, init, stride_con);\n+  update_main_loop_assertion_predicates(loop_head);\n@@ -2791,2 +2763,2 @@\n-                                                                        scale_con, int_offset, int_limit NOT_PRODUCT(\n-                                                                        COMMA AssertionPredicateType::FinalIv));\n+                                                                        scale_con, int_offset, int_limit,\n+                                                                        AssertionPredicateType::FinalIv);\n@@ -2805,2 +2777,2 @@\n-                                                                      int_offset, int_limit NOT_PRODUCT(COMMA\n-                                                                      AssertionPredicateType::InitValue));\n+                                                                      int_offset, int_limit,\n+                                                                      AssertionPredicateType::InitValue);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":15,"deletions":43,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-  void update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);\n+  void update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head);\n@@ -1355,2 +1355,2 @@\n-      bool rewire_uncommon_proj_phi_inputs = false\n-      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n+      bool rewire_uncommon_proj_phi_inputs = false,\n+      AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-\n@@ -175,2 +174,2 @@\n-                                                                                new_opaque_node NOT_PRODUCT(COMMA\n-                                                                                _if_node->assertion_predicate_type()));\n+                                                                                new_opaque_node,\n+                                                                                _if_node->assertion_predicate_type());\n@@ -182,0 +181,18 @@\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void TemplateAssertionPredicate::replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const {\n+  TemplateAssertionExpression expression(opaque_node());\n+  expression.replace_opaque_stride_input(new_stride, igvn);\n+}\n+\n+\/\/ Create a new Initialized Assertion Predicate from this template at 'new_control' and return the success projection\n+\/\/ of the newly created Initialized Assertion Predicate.\n+IfTrueNode* TemplateAssertionPredicate::initialize(PhaseIdealLoop* phase, Node* new_control) const {\n+  assert(phase->assertion_predicate_has_loop_opaque_node(head()),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(phase);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(head(), new_control);\n+  assert(!phase->assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  return success_proj;\n+}\n+\n@@ -192,0 +209,6 @@\n+void InitializedAssertionPredicate::kill(PhaseIdealLoop* phase) const {\n+  Node* true_con = phase->igvn().intcon(1);\n+  phase->set_ctrl(true_con, phase->C->root());\n+  phase->igvn().replace_input_of(_if_node, 1, true_con);\n+}\n+\n@@ -391,0 +414,57 @@\n+\/\/ This class is used to replace the input to OpaqueLoopStrideNode with a new node while leaving the other nodes\n+\/\/ unchanged.\n+class ReplaceOpaqueStrideInput : public StackObj {\n+  PhaseIterGVN& _igvn;\n+  Unique_Node_List _nodes_to_visit;\n+\n+ public:\n+  ReplaceOpaqueStrideInput(OpaqueTemplateAssertionPredicateNode* start_node, PhaseIterGVN& igvn) : _igvn(igvn) {\n+    _nodes_to_visit.push(start_node);\n+  }\n+  NONCOPYABLE(ReplaceOpaqueStrideInput);\n+\n+  void replace(Node* new_opaque_stride_input) {\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (input->is_OpaqueLoopStride()) {\n+          assert(TemplateAssertionExpressionNode::is_maybe_in_expression(input), \"must also pass node filter\");\n+          _igvn.replace_input_of(input, 1, new_opaque_stride_input);\n+        } else if (TemplateAssertionExpressionNode::is_maybe_in_expression(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void TemplateAssertionExpression::replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) {\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(_opaque_node, igvn);\n+  replace_opaque_stride_input.replace(new_stride);\n+}\n+\n+\/\/ The transformations of this class fold the OpaqueLoop* nodes by returning their inputs.\n+class RemoveOpaqueLoopNodesStrategy : public TransformStrategyForOpaqueLoopNodes {\n+ public:\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return opaque_init->in(1);\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return opaque_stride->in(1);\n+  }\n+};\n+\n+OpaqueInitializedAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_fold_opaque_loop_nodes(Node* new_control, PhaseIdealLoop* phase) {\n+  RemoveOpaqueLoopNodesStrategy remove_opaque_loop_nodes_strategy;\n+  OpaqueTemplateAssertionPredicateNode* cloned_template_opaque = clone(remove_opaque_loop_nodes_strategy, new_control,\n+                                                                       phase);\n+  OpaqueInitializedAssertionPredicateNode* opaque_initialized_opaque =\n+      new OpaqueInitializedAssertionPredicateNode(cloned_template_opaque->in(1)->as_Bool(), phase->C);\n+  phase->register_new_node(opaque_initialized_opaque, new_control);\n+  return opaque_initialized_opaque;\n+}\n+\n@@ -469,2 +549,2 @@\n-                                                             Node* assertion_expression NOT_PRODUCT(COMMA\n-                                                             const AssertionPredicateType assertion_predicate_type)) {\n+                                                             Node* assertion_expression,\n+                                                             const AssertionPredicateType assertion_predicate_type) {\n@@ -472,1 +552,1 @@\n-  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+  return create(new_control, if_opcode, assertion_expression, halt_message, assertion_predicate_type);\n@@ -478,2 +558,2 @@\n-                                                                Node* assertion_expression NOT_PRODUCT(COMMA\n-                                                                const AssertionPredicateType assertion_predicate_type)) {\n+                                                                Node* assertion_expression,\n+                                                                const AssertionPredicateType assertion_predicate_type) {\n@@ -481,1 +561,1 @@\n-  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+  return create(new_control, if_opcode, assertion_expression, halt_message, assertion_predicate_type);\n@@ -494,2 +574,2 @@\n-                                                const char* halt_message NOT_PRODUCT(COMMA\n-                                                const AssertionPredicateType assertion_predicate_type)) {\n+                                                const char* halt_message,\n+                                                const AssertionPredicateType assertion_predicate_type) {\n@@ -499,2 +579,1 @@\n-  IfNode* if_node = create_if_node(new_control, if_opcode, assertion_expression, loop\n-                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n+  IfNode* if_node = create_if_node(new_control, if_opcode, assertion_expression, loop, assertion_predicate_type);\n@@ -506,2 +585,2 @@\n-                                                    IdealLoopTree* loop NOT_PRODUCT(COMMA\n-                                                    const AssertionPredicateType assertion_predicate_type)) {\n+                                                    IdealLoopTree* loop,\n+                                                    const AssertionPredicateType assertion_predicate_type) {\n@@ -510,2 +589,1 @@\n-    if_node = new IfNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n-                         NOT_PRODUCT(COMMA assertion_predicate_type));\n+    if_node = new IfNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN, assertion_predicate_type);\n@@ -514,2 +592,1 @@\n-    if_node = new RangeCheckNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n-                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+    if_node = new RangeCheckNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN, assertion_predicate_type);\n@@ -554,2 +631,2 @@\n-                                        deopt_reason, if_opcode, does_overflow\n-                                        NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+                                        deopt_reason, if_opcode, does_overflow,\n+                                        AssertionPredicateType::InitValue);\n@@ -559,2 +636,2 @@\n-                                           deopt_reason, if_opcode, does_overflow\n-                                           NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+                                           deopt_reason, if_opcode, does_overflow,\n+                                           AssertionPredicateType::LastValue);\n@@ -579,2 +656,1 @@\n-    const int if_opcode, const bool does_overflow\n-    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+    const int if_opcode, const bool does_overflow, const AssertionPredicateType assertion_predicate_type) {\n@@ -582,2 +658,2 @@\n-                                                                 does_overflow ? Op_If : if_opcode, false\n-                                                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+                                                                 does_overflow ? Op_If : if_opcode, false,\n+                                                                 assertion_predicate_type);\n@@ -611,2 +687,2 @@\n-    Node* new_control, OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression, bool does_overflow\n-    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+    Node* new_control, OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n+    const bool does_overflow, const AssertionPredicateType assertion_predicate_type) {\n@@ -615,2 +691,2 @@\n-                                                            template_assertion_predicate_expression\n-                                                            NOT_PRODUCT(COMMA assertion_predicate_type));\n+                                                            template_assertion_predicate_expression,\n+                                                            assertion_predicate_type);\n@@ -627,2 +703,2 @@\n-      create_if_node_with_halt(new_control, template_assertion_predicate_expression, does_overflow\n-                               NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+      create_if_node_with_halt(new_control, template_assertion_predicate_expression, does_overflow,\n+                               AssertionPredicateType::InitValue);\n@@ -632,1 +708,1 @@\n-                                  does_overflow NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+                                  does_overflow, AssertionPredicateType::LastValue);\n@@ -663,2 +739,15 @@\n-  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression\n-                              NOT_PRODUCT(COMMA template_assertion_predicate->assertion_predicate_type()));\n+  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression,\n+                              template_assertion_predicate->assertion_predicate_type());\n+}\n+\n+\/\/ Create a new Initialized Assertion Predicate from 'template_assertion_predicate' by cloning it but omitting the\n+\/\/ OpaqueLoop*Notes (i.e. taking their inputs instead).\n+IfTrueNode* InitializedAssertionPredicateCreator::create_from_template(IfNode* template_assertion_predicate,\n+                                                                       Node* new_control) {\n+  OpaqueTemplateAssertionPredicateNode* template_opaque =\n+      template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n+  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      template_assertion_expression.clone_and_fold_opaque_loop_nodes(new_control, _phase);\n+  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression,\n+                              template_assertion_predicate->assertion_predicate_type());\n@@ -669,2 +758,2 @@\n-                                                         const int scale, Node* offset, Node* range NOT_PRODUCT(COMMA\n-                                                         AssertionPredicateType assertion_predicate_type)) {\n+                                                         const int scale, Node* offset, Node* range,\n+                                                         const AssertionPredicateType assertion_predicate_type) {\n@@ -675,2 +764,2 @@\n-  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression\n-                              NOT_PRODUCT(COMMA assertion_predicate_type));\n+  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression,\n+                              assertion_predicate_type);\n@@ -681,2 +770,2 @@\n-    Node* new_control, const int if_opcode, OpaqueInitializedAssertionPredicateNode* assertion_expression\n-    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+    Node* new_control, const int if_opcode, OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+    const AssertionPredicateType assertion_predicate_type) {\n@@ -684,2 +773,2 @@\n-  return assertion_predicate_if_creator.create_for_initialized(new_control, if_opcode, assertion_expression\n-                                                               NOT_PRODUCT(COMMA assertion_predicate_type));\n+  return assertion_predicate_if_creator.create_for_initialized(new_control, if_opcode, assertion_expression,\n+                                                               assertion_predicate_type);\n@@ -771,1 +860,1 @@\n-const TemplateAssertionPredicate& template_assertion_predicate) const {\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n@@ -786,0 +875,37 @@\n+\n+\/\/ Clone the Template Assertion Predicate and set a new input for the OpaqueLoopStrideNode.\n+void UpdateStrideForAssertionPredicates::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  if (!template_assertion_predicate.is_last_value()) {\n+    \/\/ Only Last Value Assertion Predicates have an OpaqueLoopStrideNode.\n+    return;\n+  }\n+  replace_opaque_stride_input(template_assertion_predicate);\n+  Node* template_tail_control_out = template_assertion_predicate.tail()->unique_ctrl_out();\n+  IfTrueNode* initialized_success_proj = initialize_from_updated_template(template_assertion_predicate);\n+  connect_initialized_assertion_predicate(template_tail_control_out, initialized_success_proj);\n+}\n+\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void UpdateStrideForAssertionPredicates::replace_opaque_stride_input(\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+  template_assertion_predicate.replace_opaque_stride_input(_new_stride, _phase->igvn());\n+}\n+\n+IfTrueNode* UpdateStrideForAssertionPredicates::initialize_from_updated_template(\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+  IfTrueNode* initialized_success_proj = template_assertion_predicate.initialize(_phase, template_assertion_predicate.tail());\n+  return initialized_success_proj;\n+}\n+\n+\/\/ The newly created Initialized Assertion Predicate can safely be inserted because this visitor is already visiting\n+\/\/ the Template Assertion Predicate above this. So, we will not accidentally visit this again and kill it with the\n+\/\/ visit() method for Initialized Assertion Predicates.\n+void UpdateStrideForAssertionPredicates::connect_initialized_assertion_predicate(\n+    Node* new_control_out, IfTrueNode* initialized_success_proj) const {\n+  if (new_control_out->is_Loop()) {\n+    _phase->igvn().replace_input_of(new_control_out, LoopNode::EntryControl, initialized_success_proj);\n+  } else {\n+    _phase->igvn().replace_input_of(new_control_out, 0, initialized_success_proj);\n+  }\n+  _phase->set_idom(new_control_out, initialized_success_proj, _phase->dom_depth(new_control_out));\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":171,"deletions":45,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-#ifndef PRODUCT\n@@ -214,1 +213,0 @@\n-#endif \/\/ NOT PRODUCT\n@@ -380,2 +378,2 @@\n-  IfTrueNode* _success_proj;\n-  IfNode* _if_node;\n+  IfTrueNode* const _success_proj;\n+  IfNode* const _if_node;\n@@ -406,0 +404,4 @@\n+  bool is_last_value() const {\n+    return _if_node->assertion_predicate_type() == AssertionPredicateType::LastValue;\n+  }\n+\n@@ -407,0 +409,2 @@\n+  void replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const;\n+  IfTrueNode* initialize(PhaseIdealLoop* phase, Node* new_control) const;\n@@ -415,2 +419,2 @@\n-  IfTrueNode* _success_proj;\n-  IfNode* _if_node;\n+  IfTrueNode* const _success_proj;\n+  IfNode* const _if_node;\n@@ -437,0 +441,5 @@\n+  bool is_last_value() const {\n+    return _if_node->assertion_predicate_type() == AssertionPredicateType::LastValue;\n+  }\n+\n+  void kill(PhaseIdealLoop* phase) const;\n@@ -464,0 +473,2 @@\n+  void replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn);\n+  OpaqueInitializedAssertionPredicateNode* clone_and_fold_opaque_loop_nodes(Node* new_ctrl, PhaseIdealLoop* phase);\n@@ -548,4 +559,4 @@\n-  IfTrueNode* create_for_initialized(Node* new_control, int if_opcode, Node* assertion_expression\n-                                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n-  IfTrueNode* create_for_template(Node* new_control, int if_opcode, Node* assertion_expression\n-                                  NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_for_initialized(Node* new_control, int if_opcode, Node* assertion_expression,\n+                                     AssertionPredicateType assertion_predicate_type);\n+  IfTrueNode* create_for_template(Node* new_control, int if_opcode, Node* assertion_expression,\n+                                  AssertionPredicateType assertion_predicate_type);\n@@ -553,4 +564,4 @@\n-  IfTrueNode* create(Node* new_control, int if_opcode, Node* assertion_expression, const char* halt_message\n-                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n-  IfNode* create_if_node(Node* new_control, int if_opcode, Node* assertion_expression, IdealLoopTree* loop\n-                         NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create(Node* new_control, int if_opcode, Node* assertion_expression, const char* halt_message,\n+                     AssertionPredicateType assertion_predicate_type);\n+  IfNode* create_if_node(Node* new_control, int if_opcode, Node* assertion_expression, IdealLoopTree* loop,\n+                         AssertionPredicateType assertion_predicate_type);\n@@ -579,2 +590,1 @@\n-                                                bool does_overflow\n-                                                NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+                                                bool does_overflow, AssertionPredicateType assertion_predicate_type);\n@@ -583,2 +593,1 @@\n-                                       bool does_overflow\n-                                       NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+                                       bool does_overflow, AssertionPredicateType assertion_predicate_type);\n@@ -611,2 +620,3 @@\n-  IfTrueNode* create(Node* operand, Node* new_control, jint stride, int scale, Node* offset, Node* range\n-                     NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_from_template(IfNode* template_assertion_predicate, Node* new_control);\n+  IfTrueNode* create(Node* operand, Node* new_control, jint stride, int scale, Node* offset, Node* range,\n+                     AssertionPredicateType assertion_predicate_type);\n@@ -619,2 +629,2 @@\n-                                   OpaqueInitializedAssertionPredicateNode* assertion_expression\n-                                   NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+                                   OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+                                   AssertionPredicateType assertion_predicate_type);\n@@ -1035,0 +1045,31 @@\n+\/\/ This visitor updates the stride for an Assertion Predicate during Loop Unrolling. The inputs to the OpaqueLoopStride\n+\/\/ nodes Template of Template Assertion Predicates are updated and new Initialized Assertion Predicates are created\n+\/\/ from the updated templates. The old Initialized Assertion Predicates are killed.\n+class UpdateStrideForAssertionPredicates : public PredicateVisitor {\n+  Node* const _new_stride;\n+  PhaseIdealLoop* const _phase;\n+\n+  void replace_opaque_stride_input(const TemplateAssertionPredicate& template_assertion_predicate) const;\n+  IfTrueNode* initialize_from_updated_template(const TemplateAssertionPredicate& template_assertion_predicate) const;\n+  void connect_initialized_assertion_predicate(Node* new_control_out, IfTrueNode* initialized_success_proj) const;\n+\n+ public:\n+  UpdateStrideForAssertionPredicates(Node* const new_stride, PhaseIdealLoop* phase)\n+      : _new_stride(new_stride),\n+        _phase(phase) {}\n+  NONCOPYABLE(UpdateStrideForAssertionPredicates);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+\n+  \/\/ Kill the old Initialized Assertion Predicates with old strides before unrolling. The new Initialized Assertion\n+  \/\/ Predicates are inserted after the Template Assertion Predicate which ensures that we are not accidentally visiting\n+  \/\/ and killing a newly created Initialized Assertion Predicate here.\n+  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override {\n+    if (initialized_assertion_predicate.is_last_value()) {\n+      \/\/ Only Last Value Initialized Assertion Predicates need to be killed and updated.\n+      initialized_assertion_predicate.kill(_phase);\n+    }\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":63,"deletions":22,"binary":false,"changes":85,"status":"modified"}]}