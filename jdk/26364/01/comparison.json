{"files":[{"patch":"@@ -654,8 +654,1 @@\n-        \/* Detecting whether a double is negative is easy with the exception of\n-         * the value -0.0.  This is a double which has a zero mantissa (and\n-         * exponent), but a negative sign bit.  It is semantically distinct from\n-         * a zero with a positive sign bit, and this distinction is important\n-         * to certain kinds of computations.  However, it's a little tricky to\n-         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may\n-         * ask, does it behave distinctly from +0.0?  Well, 1\/(-0.0) ==\n-         * -Infinity.  Proper detection of -0.0 is needed to deal with the\n+        \/* Proper detection of -0.0 is needed to deal with the\n@@ -664,1 +657,1 @@\n-        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1\/number < 0.0)) ^ (multiplier < 0);\n+        boolean isNegative = Double.doubleToRawLongBits(number) < 0 ^ multiplier < 0;\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *\n+ * <p>\n@@ -58,1 +58,1 @@\n- *\n+ * <p>\n@@ -84,1 +84,1 @@\n-     *\n+     * <p>\n@@ -90,1 +90,1 @@\n-     *\n+     * <p>\n@@ -94,1 +94,1 @@\n-     *\n+     * <p>\n@@ -99,1 +99,1 @@\n-     *\n+     * <p>\n@@ -168,1 +168,1 @@\n-    public final double getDouble() {\n+    public double getDouble() {\n@@ -186,1 +186,1 @@\n-    public final long getLong() {\n+    public long getLong() {\n@@ -211,1 +211,1 @@\n-    public final BigDecimal getBigDecimal() {\n+    public BigDecimal getBigDecimal() {\n@@ -287,1 +287,1 @@\n-    final void set(boolean isNegative, double source, int maximumFractionDigits) {\n+    void set(boolean isNegative, double source, int maximumFractionDigits) {\n@@ -291,0 +291,16 @@\n+    \/*\n+     * This compatibility option will only be available for a *very* limited\n+     * number of releases.\n+     * It restores the original behavior to help migrating to the new one,\n+     * and is used by adding\n+     *      -Djdk.compat.DecimalFormat=true\n+     * to the launcher's command line.\n+     *\n+     * The new behavior differs from the old one only in very rare cases,\n+     * so migration should be painless.\n+     *\n+     * When this option is removed, the old behavior, including relevant\n+     * fields and methods, will be removed as well.\n+     *\/\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n@@ -302,3 +318,3 @@\n-    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n-\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);\n+    void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n+        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+                FloatingDecimal.getBinaryToASCIIConverter(source, COMPAT);\n@@ -422,1 +438,1 @@\n-    private final void round(int maximumDigits,\n+    private void round(int maximumDigits,\n@@ -589,1 +605,1 @@\n-    final void set(boolean isNegative, long source) {\n+    void set(boolean isNegative, long source) {\n@@ -602,1 +618,1 @@\n-    final void set(boolean isNegative, long source, int maximumDigits) {\n+    void set(boolean isNegative, long source, int maximumDigits) {\n@@ -652,1 +668,1 @@\n-    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n+    void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n@@ -669,1 +685,1 @@\n-    final void set(boolean isNegative, BigInteger source, int maximumDigits) {\n+    void set(boolean isNegative, BigInteger source, int maximumDigits) {\n@@ -757,1 +773,1 @@\n-    private static final int parseInt(char[] str, int offset, int strLen) {\n+    private static int parseInt(char[] str, int offset, int strLen) {\n@@ -807,1 +823,1 @@\n-    private final char[] getDataChars(int length) {\n+    private char[] getDataChars(int length) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":36,"deletions":20,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-                        return toChars(str, index, f, 0, fd) - start;\n+                        return toChars(str, index, f, 0, fd, true, false) - start;\n@@ -327,0 +327,3 @@\n+             *\n+             * Also,\n+             * d_v = v      iff     4 sp10 = vb\n@@ -333,1 +336,2 @@\n-                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n+                \/* Exactly one of u' or w' lies in Rv *\/\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd, sp10 << 2 == vb, wpin);\n@@ -342,0 +346,3 @@\n+         *\n+         * Also,\n+         * d_v = v      iff     4 s = vb\n@@ -348,1 +355,1 @@\n-            return toChars(str, index, uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd, s << 2 == vb, win);\n@@ -355,1 +362,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk, fd, s << 2 == vb, away);\n@@ -374,1 +382,2 @@\n-    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e,\n+                        FormattedFPDecimal fd, boolean exact, boolean away) {\n@@ -386,1 +395,1 @@\n-            fd.set(f, e, len);\n+            fd.set(f, e, len, exact, away);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+                \/* Exactly one of u' or w' lies in Rv *\/\n@@ -329,1 +330,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1732,1 +1732,2 @@\n-     * @param d The double precision value to convert.\n+     * @param d      The double precision value to convert.\n+     * @param compat    compatibility with releases < JDK 21\n@@ -1735,2 +1736,4 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n-        return getBinaryToASCIIConverter(d, true);\n+    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+        return compat\n+                ? getCompatBinaryToASCIIConverter(d, true)\n+                : getBinaryToASCIIConverter(d);\n@@ -1739,7 +1742,26 @@\n-    \/**\n-     * Returns a <code>BinaryToASCIIConverter<\/code> for a <code>double<\/code>.\n-     * The returned object is a <code>ThreadLocal<\/code> variable of this class.\n-     *\n-     * @param d The double precision value to convert.\n-     * @param isCompatibleFormat\n-     * @return The converter.\n+    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+        assert Double.isFinite(d);\n+\n+        FormattedFPDecimal dec = FormattedFPDecimal.split(d);\n+        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n+\n+        buf.nDigits = dec.getPrecision();\n+        buf.decExponent = dec.getExp() + buf.nDigits;\n+        buf.firstDigitIndex = 0;\n+        buf.exactDecimalConversion = dec.getExact();\n+        buf.decimalDigitsRoundedUp = dec.getAway();\n+\n+        long f = dec.getSignificand();\n+        char[] digits = buf.digits;\n+        for (int i = buf.nDigits - 1; i >= 0; --i) {\n+            long q = f \/ 10;\n+            digits[i] = (char) ((f - 10 * q) + '0');\n+            f = q;\n+        }\n+        return buf;\n+    }\n+\n+    \/*\n+     * The old implementation of getBinaryToASCIIConverter().\n+     * Should be removed in the future, along with its dependent methods and\n+     * fields (> 550 lines).\n@@ -1747,1 +1769,1 @@\n-    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-    private long f;\n+    private boolean exact;  \/\/ this decimal is an exact fp\n+    private boolean away;  \/\/ this decimal has a larger magnitude than fp\n@@ -53,0 +54,1 @@\n+    private long f;\n@@ -71,1 +73,1 @@\n-    private static FormattedFPDecimal split(double v) {\n+    static FormattedFPDecimal split(double v) {\n@@ -122,1 +124,1 @@\n-        fd.set(s, eNew, prec);\n+        fd.set(s, eNew, prec, fd.exact, fd.away);\n@@ -135,0 +137,8 @@\n+    public boolean getAway() {\n+        return away;\n+    }\n+\n+    public boolean getExact() {\n+        return exact;\n+    }\n+\n@@ -139,1 +149,1 @@\n-    public void set(long f, int e, int n) {\n+    public void set(long f, int e, int n, boolean exact, boolean away) {\n@@ -144,0 +154,2 @@\n+        this.exact = exact;\n+        this.away = away;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"}]}