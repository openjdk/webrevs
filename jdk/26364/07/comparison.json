{"files":[{"patch":"@@ -655,8 +655,1 @@\n-        \/* Detecting whether a double is negative is easy with the exception of\n-         * the value -0.0.  This is a double which has a zero mantissa (and\n-         * exponent), but a negative sign bit.  It is semantically distinct from\n-         * a zero with a positive sign bit, and this distinction is important\n-         * to certain kinds of computations.  However, it's a little tricky to\n-         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may\n-         * ask, does it behave distinctly from +0.0?  Well, 1\/(-0.0) ==\n-         * -Infinity.  Proper detection of -0.0 is needed to deal with the\n+        \/* Proper detection of -0.0 is needed to deal with the\n@@ -665,1 +658,1 @@\n-        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1\/number < 0.0)) ^ (multiplier < 0);\n+        boolean isNegative = Double.doubleToRawLongBits(number) < 0 ^ multiplier < 0;\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *\n+ * <p>\n@@ -59,1 +59,1 @@\n- *\n+ * <p>\n@@ -85,1 +85,1 @@\n-     *\n+     * <p>\n@@ -91,1 +91,1 @@\n-     *\n+     * <p>\n@@ -95,1 +95,1 @@\n-     *\n+     * <p>\n@@ -100,1 +100,1 @@\n-     *\n+     * <p>\n@@ -169,1 +169,1 @@\n-    public final double getDouble() {\n+    public double getDouble() {\n@@ -181,1 +181,1 @@\n-    public final long getLong() {\n+    public long getLong() {\n@@ -211,1 +211,1 @@\n-    public final BigDecimal getBigDecimal() {\n+    public BigDecimal getBigDecimal() {\n@@ -283,1 +283,1 @@\n-    final void set(boolean isNegative, double source, int maximumFractionDigits) {\n+    void set(boolean isNegative, double source, int maximumFractionDigits) {\n@@ -287,0 +287,16 @@\n+    \/*\n+     * This compatibility option will only be available for a *very* limited\n+     * number of releases.\n+     * It restores the original behavior to help migrating to the new one,\n+     * and is used by adding\n+     *      -Djdk.compat.DecimalFormat=true\n+     * to the launcher's command line.\n+     *\n+     * The new behavior differs from the old one only in very rare cases,\n+     * so migration should be painless.\n+     *\n+     * When this option is removed, the old behavior, including relevant\n+     * fields and methods, will be removed as well.\n+     *\/\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n@@ -298,3 +314,3 @@\n-    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n-\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);\n+    void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n+        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+                FloatingDecimal.getBinaryToASCIIConverter(source, COMPAT);\n@@ -418,1 +434,1 @@\n-    private final void round(int maximumDigits,\n+    private void round(int maximumDigits,\n@@ -585,1 +601,1 @@\n-    final void set(boolean isNegative, long source) {\n+    void set(boolean isNegative, long source) {\n@@ -598,1 +614,1 @@\n-    final void set(boolean isNegative, long source, int maximumDigits) {\n+    void set(boolean isNegative, long source, int maximumDigits) {\n@@ -648,1 +664,1 @@\n-    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n+    void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n@@ -665,1 +681,1 @@\n-    final void set(boolean isNegative, BigInteger source, int maximumDigits) {\n+    void set(boolean isNegative, BigInteger source, int maximumDigits) {\n@@ -775,1 +791,1 @@\n-    private final char[] getDataChars(int length) {\n+    private char[] getDataChars(int length) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-                        return toChars(str, index, f, 0, fd) - start;\n+                        return toChars(str, index, f, 0, fd, true, false) - start;\n@@ -327,0 +327,3 @@\n+             *\n+             * Also,\n+             * d_v = v      iff     4 sp10 = vb\n@@ -333,1 +336,2 @@\n-                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n+                \/* Exactly one of u' or w' lies in Rv *\/\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd, sp10 << 2 == vb, wpin);\n@@ -342,0 +346,3 @@\n+         *\n+         * Also,\n+         * d_v = v      iff     4 s = vb\n@@ -348,1 +355,1 @@\n-            return toChars(str, index, uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd, s << 2 == vb, win);\n@@ -355,1 +362,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk, fd, s << 2 == vb, away);\n@@ -374,1 +382,2 @@\n-    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e,\n+                        FormattedFPDecimal fd, boolean exact, boolean away) {\n@@ -386,1 +395,1 @@\n-            fd.set(f, e, len);\n+            fd.set(f, e, len, exact, away);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+                \/* Exactly one of u' or w' lies in Rv *\/\n@@ -329,1 +330,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1745,1 +1745,2 @@\n-     * @param d The double precision value to convert.\n+     * @param d      The double precision value to convert.\n+     * @param compat    compatibility with releases < JDK 21\n@@ -1748,2 +1749,4 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n-        return getBinaryToASCIIConverter(d, true);\n+    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+        return compat\n+                ? getCompatBinaryToASCIIConverter(d, true)\n+                : getBinaryToASCIIConverter(d);\n@@ -1752,7 +1755,26 @@\n-    \/**\n-     * Returns a <code>BinaryToASCIIConverter<\/code> for a <code>double<\/code>.\n-     * The returned object is a <code>ThreadLocal<\/code> variable of this class.\n-     *\n-     * @param d The double precision value to convert.\n-     * @param isCompatibleFormat\n-     * @return The converter.\n+    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+        assert Double.isFinite(d);\n+\n+        FormattedFPDecimal dec = FormattedFPDecimal.split(d);\n+        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n+\n+        buf.nDigits = dec.getPrecision();\n+        buf.decExponent = dec.getExp() + buf.nDigits;\n+        buf.firstDigitIndex = 0;\n+        buf.exactDecimalConversion = dec.getExact();\n+        buf.decimalDigitsRoundedUp = dec.getAway();\n+\n+        long f = dec.getSignificand();\n+        char[] digits = buf.digits;\n+        for (int i = buf.nDigits - 1; i >= 0; --i) {\n+            long q = f \/ 10;\n+            digits[i] = (char) ((f - 10 * q) + '0');\n+            f = q;\n+        }\n+        return buf;\n+    }\n+\n+    \/*\n+     * The old implementation of getBinaryToASCIIConverter().\n+     * Should be removed in the future, along with its dependent methods and\n+     * fields (> 550 lines).\n@@ -1760,1 +1782,1 @@\n-    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,1 +50,7 @@\n-    private long f;\n+    \/* Whether the decimal exactly represents the double *\/\n+    private boolean exact;\n+    \/*\n+     * When not exact, whether the magnitude of the decimal is larger than\n+     * the magnitude of the double. Aka \"away from zero\".\n+     *\/\n+    private boolean away;\n@@ -53,0 +59,1 @@\n+    private long f;\n@@ -71,1 +78,1 @@\n-    private static FormattedFPDecimal split(double v) {\n+    static FormattedFPDecimal split(double v) {\n@@ -122,1 +129,1 @@\n-        fd.set(s, eNew, prec);\n+        fd.set(s, eNew, prec, fd.exact, fd.away);\n@@ -135,0 +142,8 @@\n+    public boolean getAway() {\n+        return away;\n+    }\n+\n+    public boolean getExact() {\n+        return exact;\n+    }\n+\n@@ -139,1 +154,1 @@\n-    public void set(long f, int e, int n) {\n+    public void set(long f, int e, int n, boolean exact, boolean away) {\n@@ -144,0 +159,2 @@\n+        this.exact = exact;\n+        this.away = away;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8362448\n+ * @summary Verify DecimalFormat::format on doubles.\n+ * @run junit DoubleFormattingTest\n+ * @run junit\/othervm -Djdk.compat.DecimalFormat=true DoubleFormattingTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.util.Formatter;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DoubleFormattingTest {\n+\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n+    static Stream<Arguments> testFormat() {\n+        return Stream.of(\n+                Arguments.of(4.8726570057E288, 0),\n+                Arguments.of(7.3879E20, 0),\n+                Arguments.of(1.9400994884341945E25, 0),\n+                Arguments.of(6.3E-322, 324)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testFormat(double v, int minFractionDigits) {\n+        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ROOT);\n+        df.setGroupingUsed(false);\n+        df.setMinimumFractionDigits(minFractionDigits);\n+        String actual = df.format(v);\n+        Formatter fmt = new Formatter(Locale.ROOT);\n+        fmt.format(\"%.\" + minFractionDigits + \"f\", v);\n+        String expected = fmt.toString();\n+        if (COMPAT) {\n+            assertNotEquals(expected, actual);\n+        } else {\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DoubleFormattingTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}