{"files":[{"patch":"@@ -728,11 +728,0 @@\n-#ifdef ASSERT\n-class AssertNonScavengableClosure: public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    assert(!SerialHeap::heap()->is_in_partial_collection(*p),\n-      \"Referent should not be scavengable.\");  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-static AssertNonScavengableClosure assert_is_non_scavengable_closure;\n-#endif\n-\n@@ -769,4 +758,0 @@\n-  \/\/ Verify that the code cache contents are not subject to\n-  \/\/ movement by a scavenging collection.\n-  DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));\n-  DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&assert_code_is_non_scavengable));\n@@ -873,7 +858,0 @@\n-\/\/ Don't implement this by using is_in_young().  This method is used\n-\/\/ in some cases to check that is_in_young() is correct.\n-bool SerialHeap::is_in_partial_collection(const void* p) {\n-  assert(is_in_reserved(p) || p == nullptr,\n-    \"Does not work if address is non-null and outside of the heap\");\n-  return p < _young_gen->reserved().end() && p != nullptr;\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -181,4 +181,0 @@\n-#ifdef ASSERT\n-  bool is_in_partial_collection(const void* p);\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  debug_only(verify_unlisted_nmethods(nullptr));\n+  debug_only(verify_unlisted_nmethods());\n@@ -191,1 +191,1 @@\n-  debug_only(verify_unlisted_nmethods(nullptr));\n+  debug_only(verify_unlisted_nmethods());\n@@ -199,12 +199,0 @@\n-#ifndef PRODUCT\n-void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) {\n-  \/\/ While we are here, verify the integrity of the list.\n-  mark_on_list_nmethods();\n-  for (nmethod* cur = _head; cur != nullptr; cur = gc_data(cur).next()) {\n-    assert(gc_data(cur).on_list(), \"else shouldn't be on this list\");\n-    gc_data(cur).clear_marked();\n-  }\n-  verify_unlisted_nmethods(cl);\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -242,3 +230,2 @@\n-\/\/ If the closure is given, run it on the unlisted nmethods.\n-\/\/ Also make sure that the effects of mark_on_list_nmethods is gone.\n-void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* cl) {\n+\/\/ Make sure that the effects of mark_on_list_nmethods is gone.\n+void ScavengableNMethods::verify_unlisted_nmethods() {\n@@ -253,4 +240,0 @@\n-\n-    if (cl != nullptr && !gc_data(nm).on_list()) {\n-      cl->do_code_blob(nm);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-  static void asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) PRODUCT_RETURN;\n-\n@@ -67,1 +65,1 @@\n-  static void verify_unlisted_nmethods(CodeBlobClosure* cl) PRODUCT_RETURN;\n+  static void verify_unlisted_nmethods() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}