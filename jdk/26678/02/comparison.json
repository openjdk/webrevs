{"files":[{"patch":"@@ -1197,1 +1197,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,4 +1199,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n@@ -2264,19 +2259,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -111,5 +110,0 @@\n-  static uint size_exception_handler() {\n-    return ( 3 * 4 );\n-  }\n-\n-\n@@ -879,20 +873,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-\n-  \/\/ OK to trash LR, because exception blob will kill it\n-  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -185,2 +185,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2091,1 +2091,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2094,5 +2093,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ The exception_handler is a b64_patchable.\n-    return MacroAssembler::b64_patchable_size;\n-  }\n-\n@@ -2117,16 +2111,0 @@\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n-                       relocInfo::runtime_call_type);\n-  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1052,1 +1052,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1055,4 +1054,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_branch_size();\n-  }\n-\n@@ -1813,19 +1808,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ auipc t1, #exception_blob_entry_point\n-  \/\/ jr (offset)t1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,1 +1652,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1655,4 +1654,0 @@\n-  static uint size_exception_handler() {\n-    return NativeJump::max_instruction_size();\n-  }\n-\n@@ -1675,37 +1670,0 @@\n-\/\/ This exception handler code snippet is placed after the method's\n-\/\/ code. It is the return point if an exception occurred. it jumps to\n-\/\/ the exception blob.\n-\/\/\n-\/\/ If the method gets deoptimized, the method and this code snippet\n-\/\/ get patched.\n-\/\/\n-\/\/ 1) Trampoline code gets patched into the end of this exception\n-\/\/   handler. the trampoline code jumps to the deoptimization blob.\n-\/\/\n-\/\/ 2) The return address in the method's code will get patched such\n-\/\/   that it jumps to the trampoline.\n-\/\/\n-\/\/ 3) The handler will get patched such that it does not jump to the\n-\/\/   exception blob, but to an entry in the deoptimization blob being\n-\/\/   aware of the exception.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  Register temp_reg = Z_R1;\n-\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;          \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n-  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n-  __ z_br(temp_reg);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1137,1 +1137,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1140,9 +1139,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n-  }\n-\n@@ -1243,18 +1233,0 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1060,1 +1061,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1476,1 +1477,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1479,1 +1479,9 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -573,0 +573,4 @@\n+    } else {\n+      if (last_call_adr == blk_starts[i]+blk_size) {\n+        blk_size += nop_size;\n+      }\n@@ -1369,1 +1373,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1375,1 +1378,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1382,1 +1385,0 @@\n-          exception_handler_req +\n@@ -1800,0 +1802,8 @@\n+    auto emit_nops = [&](int nops_count) {\n+      MachNode *nop = new MachNopNode(nops_count);\n+      block->insert_node(nop, block->number_of_nodes());\n+      C->cfg()->map_node_to_block(nop, block);\n+      nop->emit(masm, C->regalloc());\n+      current_offset = masm->offset();\n+    };\n+\n@@ -1806,5 +1816,5 @@\n-        MachNode *nop = new MachNopNode(padding \/ nop_size);\n-        block->insert_node(nop, block->number_of_nodes());\n-        C->cfg()->map_node_to_block(nop, block);\n-        nop->emit(masm, C->regalloc());\n-        current_offset = masm->offset();\n+        emit_nops(padding \/ nop_size);\n+      }\n+    } else {\n+      if (last_call_offset == current_offset) {\n+        emit_nops(1);\n@@ -1872,2 +1882,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -89,0 +90,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -568,0 +572,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}