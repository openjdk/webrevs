{"files":[{"patch":"@@ -4,0 +4,1 @@\n+\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1197,1 +1198,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,4 +1200,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n@@ -1205,1 +1201,1 @@\n-    \/\/ count one adr and one far branch instruction\n+    \/\/ count one branch instruction and one far call instruction sequence\n@@ -2264,19 +2260,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2293,0 +2270,1 @@\n+\n@@ -2294,0 +2272,3 @@\n+  Label start;\n+  __ bind(start);\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2295,2 +2276,2 @@\n-  __ adr(lr, __ pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  int entry_point = __ offset();\n+  __ b(start);\n@@ -2300,1 +2281,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -456,1 +456,3 @@\n-  __ adr(lr, pc());\n+  Label start;\n+  __ bind(start);\n+\n@@ -458,0 +460,4 @@\n+\n+  int entry_point = __ offset();\n+  __ b(start);\n+\n@@ -461,1 +467,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -111,5 +110,0 @@\n-  static uint size_exception_handler() {\n-    return ( 3 * 4 );\n-  }\n-\n-\n@@ -879,20 +873,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-\n-  \/\/ OK to trash LR, because exception blob will kill it\n-  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -909,1 +883,0 @@\n-  address deopt_pc = __ pc();\n@@ -911,5 +884,3 @@\n-  __ sub(SP, SP, wordSize); \/\/ make room for saved PC\n-  __ push(LR); \/\/ save LR that may be live when we get here\n-  __ mov_relative_address(LR, deopt_pc);\n-  __ str(LR, Address(SP, wordSize)); \/\/ save deopt PC\n-  __ pop(LR); \/\/ restore LR\n+  Label start;\n+  __ bind(start);\n+\n@@ -918,0 +889,10 @@\n+  int entry_point = __ offset();\n+  address deopt_pc = __ pc();\n+  \/\/ Preserve R0 and reserve space for the address of the entry point\n+  __ push(RegisterSet(R0) | RegisterSet(R1));\n+  \/\/ Store the entry point address\n+  __ mov_relative_address(R0, deopt_pc);\n+  __ str(R0, Address(SP, wordSize));\n+  __ pop(R0); \/\/ restore R0\n+  __ b(start);\n+\n@@ -921,1 +902,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -275,0 +275,6 @@\n+  Label start;\n+  __ bind(start);\n+\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+\n+  int entry_point = __ offset();\n@@ -277,1 +283,1 @@\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+  __ b(start);\n@@ -282,1 +288,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _deopt_handler_size = 16\n+    _deopt_handler_size = 20\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,2 +185,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,0 +271,3 @@\n+  Label start;\n+\n+  __ bind(start);\n@@ -272,0 +275,2 @@\n+  int entry_point = __ offset();\n+  __ b(start);\n@@ -276,1 +281,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  _deopt_handler_size = MacroAssembler::bl64_patchable_size\n+  _deopt_handler_size = MacroAssembler::bl64_patchable_size + BytesPerInstWord\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2091,1 +2091,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2094,5 +2093,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ The exception_handler is a b64_patchable.\n-    return MacroAssembler::b64_patchable_size;\n-  }\n-\n@@ -2101,1 +2095,1 @@\n-    return MacroAssembler::bl64_patchable_size;\n+    return MacroAssembler::bl64_patchable_size + BytesPerInstWord;\n@@ -2117,16 +2111,0 @@\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n-                       relocInfo::runtime_call_type);\n-  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -2143,0 +2121,4 @@\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -2145,0 +2127,5 @@\n+\n+  int entry_point = __ offset();\n+\n+  __ b(start);\n+\n@@ -2148,1 +2135,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-                         int return_pc_adjustment,\n@@ -265,1 +264,0 @@\n-                         int return_pc_adjustment,\n@@ -274,1 +272,0 @@\n-  \/\/ If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.\n@@ -308,1 +305,1 @@\n-    case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, \"unsupported\"); break;\n+    case return_pc_is_pre_saved: break;\n@@ -313,3 +310,0 @@\n-    if (return_pc_adjustment != 0) {\n-      __ addi(R31, R31, return_pc_adjustment);\n-    }\n@@ -2980,2 +2974,0 @@\n-  \/\/ So currently SR_LR points behind the call in the deopt handler.\n-  \/\/ We adjust it such that it points to the start of the deopt handler.\n@@ -2985,4 +2977,0 @@\n-  \/\/ We can't grab a free register here, because all registers may\n-  \/\/ contain live values, so let the RegisterSaver do the adjustment\n-  \/\/ of the return pc.\n-  const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;\n@@ -2995,1 +2983,0 @@\n-                                                                   return_pc_adjustment_no_exception,\n@@ -3030,1 +3017,0 @@\n-                                                             \/*return_pc_adjustment_exception=*\/ 0,\n@@ -3048,1 +3034,0 @@\n-                                                             \/*return_pc_adjustment_reexecute=*\/ 0,\n@@ -3339,1 +3324,0 @@\n-                                                                   \/*return_pc_adjustment=*\/0,\n@@ -3440,1 +3424,0 @@\n-                                                                   \/*return_pc_adjustment*\/ 0,\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -384,2 +384,8 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_point = __ offset();\n+  __ j(start);\n+\n@@ -389,1 +395,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/\/ auipc (1) + far_jump (2)\n+    \/\/ far_jump (2) + j (1)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1052,1 +1052,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1055,4 +1054,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_branch_size();\n-  }\n-\n@@ -1060,1 +1055,1 @@\n-    \/\/ count auipc + far branch\n+    \/\/ count far call + j\n@@ -1813,19 +1808,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ auipc t1, #exception_blob_entry_point\n-  \/\/ jr (offset)t1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -1842,2 +1818,7 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_point = __ offset();\n+  __ j(start);\n@@ -1847,1 +1828,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,1 +279,7 @@\n-  }  int offset = code_offset();\n+  }\n+\n+  int offset = code_offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -283,0 +289,5 @@\n+\n+  int entry_point = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -286,1 +297,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,1 +1652,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1655,4 +1654,0 @@\n-  static uint size_exception_handler() {\n-    return NativeJump::max_instruction_size();\n-  }\n-\n@@ -1660,1 +1655,1 @@\n-    return NativeCall::max_instruction_size();\n+    return NativeCall::max_instruction_size() + MacroAssembler::jump_pcrelative_size();\n@@ -1675,37 +1670,0 @@\n-\/\/ This exception handler code snippet is placed after the method's\n-\/\/ code. It is the return point if an exception occurred. it jumps to\n-\/\/ the exception blob.\n-\/\/\n-\/\/ If the method gets deoptimized, the method and this code snippet\n-\/\/ get patched.\n-\/\/\n-\/\/ 1) Trampoline code gets patched into the end of this exception\n-\/\/   handler. the trampoline code jumps to the deoptimization blob.\n-\/\/\n-\/\/ 2) The return address in the method's code will get patched such\n-\/\/   that it jumps to the trampoline.\n-\/\/\n-\/\/ 3) The handler will get patched such that it does not jump to the\n-\/\/   exception blob, but to an entry in the deoptimization blob being\n-\/\/   aware of the exception.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  Register temp_reg = Z_R1;\n-\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;          \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n-  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n-  __ z_br(temp_reg);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -1723,0 +1681,3 @@\n+  Label start;\n+  __ bind(start);\n+\n@@ -1727,0 +1688,5 @@\n+\n+  int entry_point = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -1730,1 +1696,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2561,2 +2561,1 @@\n-  \/\/ Z_R14 points behind the call in the deopt handler. We adjust\n-  \/\/ it such that it points to the start of the deopt handler.\n+  \/\/ Z_R14 points to the entry point of the deopt handler.\n@@ -2566,3 +2565,0 @@\n-  \/\/ The (int) cast is necessary, because -((unsigned int)14)\n-  \/\/ is an unsigned int.\n-  __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -457,1 +457,0 @@\n-  InternalAddress here(__ pc());\n@@ -459,2 +458,9 @@\n-  __ pushptr(here.addr(), rscratch1);\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_point = __ offset();\n+\n+  __ jmp(start);\n+\n@@ -464,1 +470,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 17\n+    _deopt_handler_size = 10\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1137,1 +1137,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1140,9 +1139,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n-  }\n-\n@@ -1150,2 +1140,2 @@\n-    \/\/ three 5 byte instructions plus one move for unreachable address.\n-    return 15+3;\n+    \/\/ one call and one jmp.\n+    return 10;\n@@ -1243,18 +1233,0 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -1273,4 +1245,6 @@\n-  address the_pc = (address) __ pc();\n-  Label next;\n-  \/\/ push a \"the_pc\" on the stack without destroying any registers\n-  \/\/ as they all may be live.\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_point = __ offset();\n@@ -1278,5 +1252,1 @@\n-  \/\/ push address of \"next\"\n-  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n-  __ bind(next);\n-  \/\/ adjust it so it matches \"the_pc\"\n-  __ subptr(Address(rsp, 0), __ offset() - offset);\n+  __ jmp(start);\n@@ -1284,1 +1254,0 @@\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -1287,1 +1256,1 @@\n-  return offset;\n+  return entry_point;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":10,"deletions":41,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -625,2 +625,2 @@\n-          nm->deopt_mh_handler_begin() :\n-          nm->deopt_handler_begin();\n+          nm->deopt_mh_handler_entry() :\n+          nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2798,2 +2798,2 @@\n-            nm->deopt_mh_handler_begin() :\n-            nm->deopt_handler_begin();\n+            nm->deopt_mh_handler_entry() :\n+            nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1060,1 +1061,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1318,2 +1319,2 @@\n-    _deopt_handler_offset    = 0;\n-    _deopt_mh_handler_offset = 0;\n+    _deopt_handler_entry_offset    = 0;\n+    _deopt_mh_handler_entry_offset = 0;\n@@ -1463,1 +1464,1 @@\n-        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1465,1 +1466,1 @@\n-        _deopt_handler_offset    = -1;\n+        _deopt_handler_entry_offset    = -1;\n@@ -1468,1 +1469,1 @@\n-        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n+        _deopt_mh_handler_entry_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n@@ -1470,1 +1471,1 @@\n-        _deopt_mh_handler_offset = -1;\n+        _deopt_mh_handler_entry_offset = -1;\n@@ -1476,1 +1477,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1479,2 +1479,10 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n+      _deopt_handler_entry_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -1482,1 +1490,1 @@\n-        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n+        _deopt_mh_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n@@ -1484,1 +1492,1 @@\n-        _deopt_mh_handler_offset = -1;\n+        _deopt_mh_handler_entry_offset = -1;\n@@ -2709,1 +2717,1 @@\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n+  assert(has_method_handle_invokes() == (_deopt_mh_handler_entry_offset != -1), \"must have deopt mh handler\");\n@@ -3720,1 +3728,1 @@\n-  if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = \"[Deopt MH Handler Code]\";\n+  if (has_method_handle_invokes() && (pos == deopt_mh_handler_entry())) label = \"[Deopt MH Handler Entry Point]\";\n@@ -3725,1 +3733,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  int _deopt_handler_offset;\n+  int _deopt_handler_entry_offset;\n@@ -232,1 +232,1 @@\n-  int _deopt_mh_handler_offset;\n+  int _deopt_mh_handler_entry_offset;\n@@ -609,2 +609,2 @@\n-  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n+  address deopt_mh_handler_entry() const { return           header_begin() + _deopt_mh_handler_entry_offset ; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return pc == deopt_handler_begin();\n+  return pc == deopt_handler_entry();\n@@ -41,1 +41,1 @@\n-  return pc == deopt_mh_handler_begin();\n+  return pc == deopt_mh_handler_entry();\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1375,1 +1374,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1382,1 +1381,0 @@\n-          exception_handler_req +\n@@ -1872,2 +1870,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-      return nm->deopt_mh_handler_begin() - pc_return_offset;\n+      return nm->deopt_mh_handler_entry() - pc_return_offset;\n@@ -212,1 +212,1 @@\n-      return nm->deopt_handler_begin() - pc_return_offset;\n+      return nm->deopt_handler_entry() - pc_return_offset;\n@@ -362,2 +362,2 @@\n-                        nm->deopt_mh_handler_begin() :\n-                        nm->deopt_handler_begin();\n+                        nm->deopt_mh_handler_entry() :\n+                        nm->deopt_handler_entry();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -89,0 +90,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -568,0 +572,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -544,2 +544,2 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n-  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_mh_handler_entry_offset,                int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-    deoptHandlerOffsetField     = type.getCIntegerField(\"_deopt_handler_offset\");\n-    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n+    deoptHandlerOffsetField     = type.getCIntegerField(\"_deopt_handler_entry_offset\");\n+    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_entry_offset\");\n@@ -127,2 +127,2 @@\n-  public Address deoptHandlerBegin()    { return headerBegin().addOffsetTo(getDeoptHandlerOffset());   }\n-  public Address deoptMhHandlerBegin()  { return headerBegin().addOffsetTo(getDeoptMhHandlerOffset()); }\n+  public Address deoptHandlerEntry()    { return headerBegin().addOffsetTo(getDeoptHandlerEntryOffset());   }\n+  public Address deoptMhHandlerEntry()  { return headerBegin().addOffsetTo(getDeoptMhHandlerEntryOffset()); }\n@@ -267,2 +267,2 @@\n-  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }\n-  public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }\n+  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerEntry(); }\n+  public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerEntry(); }\n@@ -496,2 +496,2 @@\n-  private int getDeoptHandlerOffset()   { return (int) deoptHandlerOffsetField  .getValue(addr); }\n-  private int getDeoptMhHandlerOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n+  private int getDeoptHandlerEntryOffset()   { return (int) deoptHandlerOffsetField  .getValue(addr); }\n+  private int getDeoptMhHandlerEntryOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}