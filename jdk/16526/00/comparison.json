{"files":[{"patch":"@@ -6,1 +6,4 @@\n-modules = jdk.compiler jdk.zipfs\n+modules = java.base\/jdk.internal.classfile \\\n+          java.base\/jdk.internal.classfile.constantpool \\\n+          java.base\/jdk.internal.classfile.instruction \\\n+          jdk.compiler jdk.zipfs\n","filename":"test\/jdk\/jdk\/lambda\/TEST.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package separate;\n-\n-import java.io.*;\n-\n-public class AttributeInjector implements ClassFilePreprocessor {\n-\n-    private String attributeName;\n-    private byte[] attributeData;\n-\n-    public AttributeInjector(String attributeName, byte[] attributeData) {\n-        this.attributeName = attributeName;\n-        this.attributeData = attributeData;\n-    }\n-\n-    public byte[] preprocess(String name, byte[] cf) {\n-        ClassFile classfile = new ClassFile(cf);\n-\n-        short cpIndex = (short)classfile.constant_pool.size();\n-\n-        ClassFile.CpUtf8 entry = new ClassFile.CpUtf8();\n-        entry.bytes = new byte[attributeName.length()];\n-        for (int i = 0; i < attributeName.length(); ++i) {\n-            entry.bytes[i] = (byte)attributeName.charAt(i);\n-        }\n-\n-        classfile.constant_pool.add(entry);\n-\n-        ClassFile.Attribute attr = new ClassFile.Attribute();\n-        attr.attribute_name_index = cpIndex;\n-        attr.info = attributeData;\n-\n-        classfile.attributes.add(attr);\n-        return classfile.toByteArray();\n-    }\n-\n-\/*\n-    public static void main(String argv[]) throws Exception {\n-        File input = new File(argv[0]);\n-        byte[] buffer = new byte[(int)input.length()];\n-        new FileInputStream(input).read(buffer);\n-\n-        ClassFilePreprocessor cfp =\n-            new AttributeInjector(\"RequiresBridges\", new byte[0]);\n-        byte[] cf = cfp.preprocess(argv[0], buffer);\n-        new FileOutputStream(argv[0] + \".mod\").write(cf);\n-    }\n-*\/\n-}\n","filename":"test\/jdk\/jdk\/lambda\/separate\/AttributeInjector.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,452 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package separate;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-class CfInputStream extends ByteArrayInputStream {\n-    private int ct;\n-    public CfInputStream(byte[] input) {\n-        super(input);\n-    }\n-\n-    byte u1() { return (byte)read(); }\n-    short u2() {\n-        int b0 = read() << 8;\n-        int b1 = read();\n-        return (short)(b0 | b1);\n-    }\n-    int u4() {\n-        int b0 = read() << 24;\n-        int b1 = read() << 16;\n-        int b2 = read() << 8;\n-        int b3 = read();\n-        return b0 | b1 | b2 | b3;\n-    }\n-    byte[] array(int count) {\n-        byte[] ret = new byte[count];\n-        read(ret, 0, count);\n-        return ret;\n-    }\n-};\n-\n-class CfOutputStream extends ByteArrayOutputStream {\n-    void u1(byte b) { write((int)b); }\n-    void u2(short s) {\n-        write((s >> 8) & 0xff);\n-        write(s & 0xff);\n-    }\n-    void u4(int i) {\n-        write((i >> 24) & 0xff);\n-        write((i >> 16) & 0xff);\n-        write((i >> 8) & 0xff);\n-        write(i & 0xff);\n-    }\n-    void array(byte[] a) {\n-        write(a, 0, a.length);\n-    }\n-\n-    public byte[] toByteArray() { return super.toByteArray(); }\n-};\n-\n-\/\/ A quick and dirty class file parser and representation\n-public class ClassFile {\n-\n-    int magic;\n-    short minor_version;\n-    short major_version;\n-    ArrayList<CpEntry> constant_pool;\n-    short access_flags;\n-    short this_class;\n-    short super_class;\n-    ArrayList<Interface> interfaces;\n-    ArrayList<Field> fields;\n-    ArrayList<Method> methods;\n-    ArrayList<Attribute> attributes;\n-\n-    ClassFile(byte[] cf) {\n-        CfInputStream in = new CfInputStream(cf);\n-\n-        magic = in.u4();\n-        minor_version = in.u2();\n-        major_version = in.u2();\n-\n-        short cpCount = in.u2();\n-        constant_pool = new ArrayList<>();\n-        constant_pool.add(new CpNull());\n-        for (int i = 1; i < cpCount; ++i) {\n-            constant_pool.add(CpEntry.newCpEntry(in));\n-        }\n-\n-        access_flags = in.u2();\n-        this_class = in.u2();\n-        super_class = in.u2();\n-\n-        short ifaceCount = in.u2();\n-        interfaces = new ArrayList<>();\n-        for (int i = 0; i < ifaceCount; ++i) {\n-            interfaces.add(new Interface(in));\n-        }\n-\n-        short fieldCount = in.u2();\n-        fields = new ArrayList<>();\n-        for (int i = 0; i < fieldCount; ++i) {\n-            fields.add(new Field(in));\n-        }\n-\n-        short methodCount = in.u2();\n-        methods = new ArrayList<>();\n-        for (int i = 0; i < methodCount; ++i) {\n-            methods.add(new Method(in));\n-        }\n-\n-        short attributeCount = in.u2();\n-        attributes = new ArrayList<>();\n-        for (int i = 0; i < attributeCount; ++i) {\n-            attributes.add(new Attribute(in));\n-        }\n-    }\n-\n-    byte[] toByteArray() {\n-        CfOutputStream out = new CfOutputStream();\n-\n-        out.u4(magic);\n-        out.u2(minor_version);\n-        out.u2(major_version);\n-\n-        out.u2((short)(constant_pool.size()));\n-        for (CpEntry cp : constant_pool) {\n-            cp.write(out);\n-        }\n-\n-        out.u2(access_flags);\n-        out.u2(this_class);\n-        out.u2(super_class);\n-\n-        out.u2((short)interfaces.size());\n-        for (Interface iface : interfaces) {\n-            iface.write(out);\n-        }\n-\n-        out.u2((short)fields.size());\n-        for (Field field : fields) {\n-            field.write(out);\n-        }\n-\n-        out.u2((short)methods.size());\n-        for (Method method : methods) {\n-            method.write(out);\n-        }\n-\n-        out.u2((short)attributes.size());\n-        for (Attribute attribute : attributes) {\n-            attribute.write(out);\n-        }\n-\n-        return out.toByteArray();\n-    }\n-\n-    static abstract class CpEntry {\n-        byte tag;\n-\n-        CpEntry(byte t) { tag = t; }\n-        void write(CfOutputStream out) {\n-            out.u1(tag);\n-        }\n-\n-        static CpEntry newCpEntry(CfInputStream in) {\n-            byte tag = in.u1();\n-            switch (tag) {\n-                case CpUtf8.TAG: return new CpUtf8(in);\n-                case CpInteger.TAG: return new CpInteger(in);\n-                case CpFloat.TAG: return new CpFloat(in);\n-                case CpLong.TAG: return new CpLong(in);\n-                case CpDouble.TAG: return new CpDouble(in);\n-                case CpClass.TAG: return new CpClass(in);\n-                case CpString.TAG: return new CpString(in);\n-                case CpFieldRef.TAG: return new CpFieldRef(in);\n-                case CpMethodRef.TAG: return new CpMethodRef(in);\n-                case CpInterfaceMethodRef.TAG:\n-                    return new CpInterfaceMethodRef(in);\n-                case CpNameAndType.TAG: return new CpNameAndType(in);\n-                case CpMethodHandle.TAG: return new CpMethodHandle(in);\n-                case CpMethodType.TAG: return new CpMethodType(in);\n-                case CpInvokeDynamic.TAG: return new CpInvokeDynamic(in);\n-                default: throw new RuntimeException(\"Bad cp entry tag: \" + tag);\n-            }\n-        }\n-    }\n-\n-    static class CpNull extends CpEntry {\n-        CpNull() { super((byte)0); }\n-        CpNull(CfInputStream in) { super((byte)0); }\n-        void write(CfOutputStream out) {}\n-    }\n-\n-    static class CpUtf8 extends CpEntry {\n-        static final byte TAG = 1;\n-        byte[] bytes;\n-\n-        CpUtf8() { super(TAG); }\n-        CpUtf8(CfInputStream in) {\n-            this();\n-            short length = in.u2();\n-            bytes = in.array(length);\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2((short)bytes.length);\n-            out.array(bytes);\n-        }\n-    }\n-\n-    static class CpU4Constant extends CpEntry {\n-        byte[] bytes;\n-\n-        CpU4Constant(byte tag) { super(tag); }\n-        CpU4Constant(byte tag, CfInputStream in) {\n-            this(tag);\n-            bytes = in.array(4);\n-        }\n-        void write(CfOutputStream out) { super.write(out); out.array(bytes); }\n-    }\n-    static class CpInteger extends CpU4Constant {\n-        static final byte TAG = 3;\n-        CpInteger() { super(TAG); }\n-        CpInteger(CfInputStream in) { super(TAG, in); }\n-    }\n-    static class CpFloat extends CpU4Constant {\n-        static final byte TAG = 4;\n-        CpFloat() { super(TAG); }\n-        CpFloat(CfInputStream in) { super(TAG, in); }\n-    }\n-\n-    static class CpU8Constant extends CpEntry {\n-        byte[] bytes;\n-\n-        CpU8Constant(byte tag) { super(tag); }\n-        CpU8Constant(byte tag, CfInputStream in) {\n-            this(tag);\n-            bytes = in.array(8);\n-        }\n-        void write(CfOutputStream out) { super.write(out); out.array(bytes); }\n-    }\n-    static class CpLong extends CpU8Constant {\n-        static final byte TAG = 5;\n-        CpLong() { super(TAG); }\n-        CpLong(CfInputStream in) { super(TAG, in); }\n-    }\n-    static class CpDouble extends CpU8Constant {\n-        static final byte TAG = 6;\n-        CpDouble() { super(TAG); }\n-        CpDouble(CfInputStream in) { super(TAG, in); }\n-    }\n-\n-    static class CpClass extends CpEntry {\n-        static final byte TAG = 7;\n-        short name_index;\n-\n-        CpClass() { super(TAG); }\n-        CpClass(CfInputStream in) { super(TAG); name_index = in.u2(); }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(name_index);\n-        }\n-    }\n-\n-    static class CpString extends CpEntry {\n-        static final byte TAG = 8;\n-        short string_index;\n-\n-        CpString() { super(TAG); }\n-        CpString(CfInputStream in) { super(TAG); string_index = in.u2(); }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(string_index);\n-        }\n-    }\n-\n-    static class CpRef extends CpEntry {\n-        short class_index;\n-        short name_and_type_index;\n-\n-        CpRef(byte tag) { super(tag); }\n-        CpRef(byte tag, CfInputStream in) {\n-            this(tag);\n-            class_index = in.u2();\n-            name_and_type_index = in.u2();\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(class_index);\n-            out.u2(name_and_type_index);\n-        }\n-    }\n-    static class CpFieldRef extends CpRef {\n-        static final byte TAG = 9;\n-        CpFieldRef() { super(TAG); }\n-        CpFieldRef(CfInputStream in) { super(TAG, in); }\n-    }\n-    static class CpMethodRef extends CpRef {\n-        static final byte TAG = 10;\n-        CpMethodRef() { super(TAG); }\n-        CpMethodRef(CfInputStream in) { super(TAG, in); }\n-    }\n-    static class CpInterfaceMethodRef extends CpRef {\n-        static final byte TAG = 11;\n-        CpInterfaceMethodRef() { super(TAG); }\n-        CpInterfaceMethodRef(CfInputStream in) { super(TAG, in); }\n-    }\n-\n-    static class CpNameAndType extends CpEntry {\n-        static final byte TAG = 12;\n-        short name_index;\n-        short descriptor_index;\n-\n-        CpNameAndType() { super(TAG); }\n-        CpNameAndType(CfInputStream in) {\n-            this();\n-            name_index = in.u2();\n-            descriptor_index = in.u2();\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(name_index);\n-            out.u2(descriptor_index);\n-        }\n-    }\n-\n-    static class CpMethodHandle extends CpEntry {\n-        static final byte TAG = 15;\n-        byte reference_kind;\n-        short reference_index;\n-\n-        CpMethodHandle() { super(TAG); }\n-        CpMethodHandle(CfInputStream in) {\n-            this();\n-            reference_kind = in.u1();\n-            reference_index = in.u2();\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u1(reference_kind);\n-            out.u2(reference_index);\n-        }\n-    }\n-\n-    static class CpMethodType extends CpEntry {\n-        static final byte TAG = 16;\n-        short descriptor_index;\n-\n-        CpMethodType() { super(TAG); }\n-        CpMethodType(CfInputStream in) {\n-            this();\n-            descriptor_index = in.u2();\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(descriptor_index);\n-        }\n-    }\n-\n-    static class CpInvokeDynamic extends CpEntry {\n-        static final byte TAG = 18;\n-        short bootstrap_index;\n-        short name_and_type_index;\n-\n-        CpInvokeDynamic() { super(TAG); }\n-        CpInvokeDynamic(CfInputStream in) {\n-            this();\n-            bootstrap_index = in.u2();\n-            name_and_type_index = in.u2();\n-        }\n-        void write(CfOutputStream out) {\n-            super.write(out);\n-            out.u2(bootstrap_index);\n-            out.u2(name_and_type_index);\n-        }\n-    }\n-\n-    static class Interface {\n-        short index;\n-\n-        Interface() {}\n-        Interface(CfInputStream in) { index = in.u2(); }\n-        void write(CfOutputStream out) { out.u2(index); }\n-    }\n-\n-    static class FieldOrMethod {\n-        short access_flags;\n-        short name_index;\n-        short descriptor_index;\n-        ArrayList<Attribute> attributes;\n-\n-        FieldOrMethod() { attributes = new ArrayList<>(); }\n-        FieldOrMethod(CfInputStream in) {\n-            access_flags = in.u2();\n-            name_index = in.u2();\n-            descriptor_index = in.u2();\n-\n-            short attrCount = in.u2();\n-            attributes = new ArrayList<>();\n-            for (int i = 0; i < attrCount; ++i) {\n-                attributes.add(new Attribute(in));\n-            }\n-        }\n-        void write(CfOutputStream out) {\n-            out.u2(access_flags);\n-            out.u2(name_index);\n-            out.u2(descriptor_index);\n-            out.u2((short)attributes.size());\n-            for (Attribute attribute : attributes) { attribute.write(out); }\n-        }\n-    }\n-\n-    static class Field extends FieldOrMethod {\n-        Field() {}\n-        Field(CfInputStream in) { super(in); }\n-    }\n-    static class Method extends FieldOrMethod {\n-        Method() {}\n-        Method(CfInputStream in) { super(in); }\n-    }\n-\n-    static class Attribute {\n-        short attribute_name_index;\n-        byte[] info;\n-\n-        Attribute() { info = new byte[0]; }\n-        Attribute(CfInputStream in) {\n-            attribute_name_index = in.u2();\n-            int length = in.u4();\n-            info = in.array(length);\n-        }\n-        void write(CfOutputStream out) {\n-            out.u2(attribute_name_index);\n-            out.u4(info.length);\n-            out.array(info);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/lambda\/separate\/ClassFile.java","additions":0,"deletions":452,"binary":false,"changes":452,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n-import java.io.*;\n-import java.util.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import static jdk.internal.classfile.Opcode.*;\n@@ -31,1 +32,1 @@\n-    private String whichClass;\n+    private final String whichClass;\n@@ -37,47 +38,40 @@\n-    private boolean utf8Matches(ClassFile.CpEntry entry, String v) {\n-        if (!(entry instanceof ClassFile.CpUtf8)) {\n-            return false;\n-        }\n-        ClassFile.CpUtf8 utf8 = (ClassFile.CpUtf8)entry;\n-        if (v.length() != utf8.bytes.length) {\n-            return false;\n-        }\n-        for (int i = 0; i < v.length(); ++i) {\n-            if (v.charAt(i) != utf8.bytes[i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private void convertToInterface(ClassFile cf) {\n-        cf.access_flags = 0x0601; \/\/ ACC_INTERFACE | ACC_ABSTRACT | ACC_PUBLIC\n-        ArrayList<ClassFile.Method> new_methods = new ArrayList<>();\n-        \/\/ Find <init> method and delete it\n-        for (int i = 0; i < cf.methods.size(); ++i) {\n-            ClassFile.Method method = cf.methods.get(i);\n-            ClassFile.CpEntry name = cf.constant_pool.get(method.name_index);\n-            if (!utf8Matches(name, \"<init>\")) {\n-                new_methods.add(method);\n-            }\n-        }\n-        cf.methods = new_methods;\n-        \/\/  Convert method tag. Find Methodref, which is not \"<init>\" and only invoked by other methods\n-        \/\/  in the interface, convert it to InterfaceMethodref\n-        ArrayList<ClassFile.CpEntry> cpool = new ArrayList<>();\n-        for (int i = 0; i < cf.constant_pool.size(); i++) {\n-            ClassFile.CpEntry ce = cf.constant_pool.get(i);\n-            if (ce instanceof ClassFile.CpMethodRef) {\n-                ClassFile.CpMethodRef me = (ClassFile.CpMethodRef)ce;\n-                ClassFile.CpNameAndType nameType = (ClassFile.CpNameAndType)cf.constant_pool.get(me.name_and_type_index);\n-                ClassFile.CpEntry name = cf.constant_pool.get(nameType.name_index);\n-                if (!utf8Matches(name, \"<init>\") && cf.this_class == me.class_index) {\n-                    ClassFile.CpInterfaceMethodRef newEntry = new ClassFile.CpInterfaceMethodRef();\n-                    newEntry.class_index = me.class_index;\n-                    newEntry.name_and_type_index = me.name_and_type_index;\n-                    ce = newEntry;\n-                }\n-            }\n-            cpool.add(ce);\n-        }\n-        cf.constant_pool = cpool;\n+    private byte[] convertToInterface(ClassModel classModel) {\n+        return Classfile.of().build(classModel.thisClass().asSymbol(),\n+                classBuilder ->  {\n+                    for (ClassElement ce : classModel) {\n+                        if (ce instanceof AccessFlags accessFlags) {\n+                            classBuilder.withFlags(0x0601); \/\/ ACC_INTERFACE | ACC_ABSTRACT | ACC_PUBLIC);\n+                        } else if (ce instanceof MethodModel mm) {\n+                            \/\/ Find <init> method and delete it\n+                            if (mm.methodName().stringValue().equals(\"<init>\")) {\n+                                continue;\n+                            }\n+                            \/\/  Convert method tag. Find Methodref, which is not \"<init>\" and only invoked\n+                            \/\/  by other methods in the interface, convert it to InterfaceMethodref and\n+                            \/\/  if opcode is invokevirtual, convert it to invokeinterface\n+                            classBuilder.withMethod(mm.methodName().stringValue(),\n+                                    mm.methodTypeSymbol(),\n+                                    mm.flags().flagsMask(),\n+                                    methodBuilder -> {\n+                                        for (MethodElement me : mm) {\n+                                            if (me instanceof CodeModel xm) {\n+                                                methodBuilder.withCode(codeBuilder -> {\n+                                                    for (CodeElement e : xm) {\n+                                                        if (e instanceof InvokeInstruction i && i.owner() == classModel.thisClass()) {\n+                                                            Opcode opcode = i.opcode() == INVOKEVIRTUAL ? INVOKEINTERFACE : i.opcode();\n+                                                            codeBuilder.invokeInstruction(opcode, i.owner().asSymbol(),\n+                                                                    i.name().stringValue(), i.typeSymbol(), true);\n+                                                        } else {\n+                                                            codeBuilder.with(e);\n+                                                        }\n+                                                    }});\n+                                            } else {\n+                                                methodBuilder.with(me);\n+                                            }\n+                                        }\n+                                    });\n+                        } else {\n+                            classBuilder.with(ce);\n+                        }\n+                    }\n+                });\n@@ -87,8 +81,3 @@\n-        ClassFile cf = new ClassFile(bytes);\n-\n-        ClassFile.CpEntry entry = cf.constant_pool.get(cf.this_class);\n-        ClassFile.CpEntry name = cf.constant_pool.get(\n-            ((ClassFile.CpClass)entry).name_index);\n-        if (utf8Matches(name, whichClass)) {\n-            convertToInterface(cf);\n-            return cf.toByteArray();\n+        ClassModel classModel = Classfile.of().parse(bytes);\n+        if (classModel.thisClass().asInternalName().equals(whichClass)) {\n+            return convertToInterface(classModel);\n","filename":"test\/jdk\/jdk\/lambda\/separate\/ClassToInterfaceConverter.java","additions":48,"deletions":59,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.io.*;\n-\n@@ -29,1 +27,1 @@\n-import separate.*;\n+import separate.ClassToInterfaceConverter;\n@@ -31,0 +29,1 @@\n+import separate.TestHarness;\n@@ -74,2 +73,1 @@\n-    \/* excluded: 8187655 *\/\n-    @Test(enabled=false, groups = \"vm_prototype\")\n+    @Test(groups = \"vm_prototype\")\n","filename":"test\/jdk\/jdk\/lambda\/vm\/InterfaceAccessFlagsTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}