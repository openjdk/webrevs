{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -3199,0 +3199,2 @@\n+  assert_different_registers(temp1, temp2);\n+\n@@ -3202,1 +3204,1 @@\n-  z_lg(displacedHeader, 0, oop);\n+  z_lg(displacedHeader, oopDesc::mark_offset_in_bytes(), oop);\n@@ -3205,2 +3207,2 @@\n-    load_klass(Z_R1_scratch, oop);\n-    z_l(Z_R1_scratch, Address(Z_R1_scratch, Klass::access_flags_offset()));\n+    load_klass(temp, oop);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n@@ -3208,1 +3210,1 @@\n-    z_nilh(Z_R1_scratch, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n@@ -3215,3 +3217,2 @@\n-  z_lgr(temp, displacedHeader);\n-  z_nill(temp, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+  z_tmll(displacedHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3221,0 +3222,1 @@\n+    \/\/ From loading the markWord, we know that oop != nullptr\n@@ -3232,6 +3234,3 @@\n-    \/\/ Memory Fence (in cmpxchgd)\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-\n-    \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n-    \/\/ have now locked it.\n-    z_csg(displacedHeader, box, 0, oop);\n+    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n+    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n+    z_csg(displacedHeader, box, oopDesc::mark_offset_in_bytes(), oop);\n@@ -3241,2 +3240,4 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n+    \/\/ We did not see an unlocked object\n+    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n+    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n+    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n@@ -3247,2 +3248,4 @@\n-    \/\/   z_brne(done);\n-    \/\/   z_release();\n+\n+    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n+    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n+\n@@ -3258,0 +3261,2 @@\n+  bind(object_has_monitor);\n+\n@@ -3260,1 +3265,0 @@\n-  bind(object_has_monitor);\n@@ -3263,1 +3267,1 @@\n-  \/\/\n+\n@@ -3265,1 +3269,0 @@\n-  z_lghi(zero, 0);\n@@ -3267,0 +3270,2 @@\n+  \/\/ Otherwise, register zero is filled with the current owner.\n+  z_lghi(zero, 0);\n@@ -3272,8 +3277,12 @@\n-#ifdef ASSERT\n-  z_brne(done);\n-  \/\/ We've acquired the monitor, check some invariants.\n-  \/\/ Invariant 1: _recursions should be 0.\n-  asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,\n-                          \"monitor->_recursions should be 0\", -1);\n-  z_ltgr(zero, zero); \/\/ Set CR=EQ.\n-#endif\n+\n+  z_bre(done); \/\/ acquired the lock for the first time.\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+  \/\/ Check if we are already the owner (recursive lock)\n+  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+  z_brne(done); \/\/ not a recursive lock\n+\n+  \/\/ Current thread already owns the lock. Just increment recursion count.\n+  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+  z_cgr(zero, zero); \/\/ restore CC\n+  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n@@ -3292,1 +3301,0 @@\n-  Register monitor = temp2;\n@@ -3296,1 +3304,1 @@\n-  Label done, object_has_monitor;\n+  Label done, object_has_monitor, not_recursive;\n@@ -3311,5 +3319,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    z_lgr(temp, currentHeader);\n-  }\n-  z_nill(currentHeader, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+\n+  z_tmll(currentHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3322,1 +3328,1 @@\n-    \/\/ Check if it is still a light weight lock, this is true if we see\n+    \/\/ Check if it is still a lightweight lock, this is true if we see\n@@ -3326,1 +3332,1 @@\n-    z_csg(currentHeader, displacedHeader, 0, oop);\n+    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n@@ -3331,4 +3337,1 @@\n-    \/\/ don't load currentHead again from stack-top after monitor check, as it is possible\n-    \/\/ some other thread modified it.\n-    \/\/ currentHeader is altered, but it's contents are copied in temp as well\n-    lightweight_unlock(oop, temp, currentHeader, done);\n+    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n@@ -3343,4 +3346,2 @@\n-  z_lg(currentHeader, hdr_offset, oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+\n+  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n@@ -3348,0 +3349,13 @@\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+  \/\/ Recursive inflated unlock\n+  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+  z_bru(done);\n+\n+  bind(not_recursive);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":60,"deletions":46,"binary":false,"changes":106,"status":"modified"}]}