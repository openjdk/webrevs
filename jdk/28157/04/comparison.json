{"files":[{"patch":"@@ -29,0 +29,2 @@\n+#include <math.h>\n+\n@@ -64,0 +66,2 @@\n+  \/\/ cg v2 values must be in range [1-10000]\n+  assert(shares_int >= 1 && shares_int <= 10000, \"invariant\");\n@@ -67,1 +71,1 @@\n-  \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+  \/\/ https:\/\/github.com\/containers\/crun\/blob\/1.24\/crun.1.md#cpu-controller\n@@ -70,1 +74,12 @@\n-  \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+  \/\/ y = 10^(log2(x)^2\/612 + 125\/612 * log2(x) - 7.0\/34.0)\n+  \/\/\n+  \/\/ By re-arranging it to the standard quadratic form:\n+  \/\/ log2(x)^2 + 125 * log2(x) - (126 + 612 * log_10(y)) = 0\n+  \/\/\n+  \/\/ Therefore, log2(x) = (-125 + sqrt( 125^2 - 4 * (-(126 + 612 * log_10(y)))))\/2\n+  \/\/\n+  \/\/ As a result we have the inverse (we can discount substraction of the\n+  \/\/ square root value since those values result in very small numbers and the\n+  \/\/ cpu shares values - OCI - are in range [2,262144]):\n+  \/\/\n+  \/\/ x = 2^((-125 + sqrt(16129 + 2448* log10(y)))\/2)\n@@ -72,3 +87,6 @@\n-  int x = 262142 * shares_int - 1;\n-  double frac = x\/9999.0;\n-  x = ((int)frac) + 2;\n+  double log_multiplicand = log10(shares_int);\n+  double discriminant = 16129 + 2448 * log_multiplicand;\n+  double square_root = sqrt(discriminant);\n+  double exponent = (-125 + square_root)\/2;\n+  double scaled_val = pow(2, exponent);\n+  int x = (int) scaled_val;\n@@ -79,1 +97,2 @@\n-     \/\/ will always map to 1 CPU\n+     \/\/ Don't do the multiples of PER_CPU_SHARES mapping since we\n+     \/\/ have a value <= PER_CPU_SHARES\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -159,1 +159,2 @@\n-        if (sharesRaw == 100 || sharesRaw <= 0) {\n+        \/\/ cg v2 value must be in range [1,10000]\n+        if (sharesRaw == 100 || sharesRaw <= 0 || sharesRaw > 10000) {\n@@ -165,1 +166,1 @@\n-        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/1.24\/crun.1.md#cpu-controller\n@@ -168,1 +169,1 @@\n-        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/ y = 10^(log2(x)^2\/612 + 125\/612 * log2(x) - 7.0\/34.0)\n@@ -170,3 +171,18 @@\n-        int x = 262142 * shares - 1;\n-        double frac = x\/9999.0;\n-        x = ((int)frac) + 2;\n+        \/\/ By re-arranging it to the standard quadratic form:\n+        \/\/ log2(x)^2 + 125 * log2(x) - (126 + 612 * log_10(y)) = 0\n+        \/\/\n+        \/\/ Therefore, log2(x) = (-125 + sqrt( 125^2 - 4 * (-(126 + 612 * log_10(y)))))\/2\n+        \/\/\n+        \/\/ As a result we have the inverse (we can discount substraction of the\n+        \/\/ square root value since those values result in very small numbers and the\n+        \/\/ cpu shares values - OCI - are in range [2-262144])\n+        \/\/\n+        \/\/ x = 2^((-125 + sqrt(16129 + 2448* log10(y)))\/2)\n+        \/\/\n+        double logMultiplicand = Math.log10(shares);\n+        double discriminant = 16129 + 2448 * logMultiplicand;\n+        double squareRoot = Math.sqrt(discriminant);\n+        double exponent = (-125 + squareRoot)\/2;\n+        double scaledValue = Math.pow(2, exponent);\n+\n+        int x = (int)scaledValue;\n@@ -174,1 +190,2 @@\n-            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+            \/\/ Return the back-mapped value.\n+            return x;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ *          java.base\/jdk.internal.platform\n@@ -38,0 +39,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -43,0 +45,1 @@\n+import jtreg.SkippedException;\n@@ -46,0 +49,1 @@\n+    private static final Metrics metrics = Metrics.systemMetrics();\n@@ -61,0 +65,1 @@\n+            testPrintContainerInfoCPUShares();\n@@ -97,0 +102,45 @@\n+    \/\/ Test the mapping function on cgroups v2. Should also pass on cgroups v1 as it's\n+    \/\/ a direct mapping there.\n+    private static void testPrintContainerInfoCPUShares() throws Exception {\n+        \/\/ Test won't work on cgv1 rootless podman since resource limits don't\n+        \/\/ work there.\n+        if (\"cgroupv1\".equals(metrics.getProvider()) &&\n+            DockerTestUtils.isPodman() &&\n+            DockerTestUtils.isRootless()) {\n+            throw new SkippedException(\"Resource limits required for testPrintContainerInfoCPUShares(). \" +\n+                                       \"This is cgv1 with podman in rootless mode. Test skipped.\");\n+        }\n+        \/\/ Anything less than 1024 should return the back-mapped cpu-shares value without\n+        \/\/ rounding to next multiple of 1024 (on cg v2). Only ensure that we get\n+        \/\/ 'cpu_shares: <back-mapped-value>' over 'cpu_shares: no shares'.\n+        printContainerInfo(512, 1024, false);\n+        \/\/ Don't use 1024 exactly so as to avoid mapping to the unlimited\/uset case.\n+        \/\/ Use a value > 100 post-mapping so as to hit the non-default branch: 1052 => 103\n+        printContainerInfo(1052, 1024, true);\n+        \/\/ need at least 2 CPU cores for this test to work\n+        if (Runtime.getRuntime().availableProcessors() >= 2) {\n+            printContainerInfo(2048, 2048, true);\n+        }\n+    }\n+\n+    private static void printContainerInfo(int cpuShares, int expected, boolean numberMatch) throws Exception {\n+        Common.logNewTestCase(\"Test print_container_info() - cpu shares - given: \" + cpuShares + \", expected: \" + expected);\n+\n+        DockerRunOptions opts = Common.newOpts(imageName, \"PrintContainerInfo\");\n+        Common.addWhiteBoxOpts(opts);\n+        opts.addDockerOpts(\"--cpu-shares\", Integer.valueOf(cpuShares).toString());\n+\n+        OutputAnalyzer out = Common.run(opts);\n+        String str = out.getOutput();\n+        boolean isCgroupV2 = str.contains(\"cgroupv2\");\n+        \/\/ cg v1 maps cpu shares values verbatim. Only cg v2 uses the\n+        \/\/ mapping function.\n+        if (numberMatch) {\n+          int valueExpected = isCgroupV2 ? expected : cpuShares;\n+          out.shouldContain(\"cpu_shares: \" + valueExpected);\n+        } else {\n+          \/\/ must not print \"no shares\"\n+          out.shouldNotContain(\"cpu_shares: no shares\");\n+        }\n+    }\n+\n@@ -98,1 +148,1 @@\n-        Common.logNewTestCase(\"Test print_container_info()\");\n+        Common.logNewTestCase(\"Test print_container_info() - ActiveProcessorCount\");\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -148,3 +148,7 @@\n-            \/\/ Adjust input shares for < 1024 cpu shares as the\n-            \/\/ impl. rounds up to the next multiple of 1024\n-            shares = 1024;\n+            \/\/ Don't assert for shares values less than 1024 as we don't\n+            \/\/ have a 1-to-1 mapping from the cgroup v2 value to the OCI\n+            \/\/ value.\n+            System.out.println(\"Debug: cgv2 - Got CPU shares of: \" +\n+                               metrics.getCpuShares() + \" - Skipping assert.\");\n+            System.out.println(\"TEST PASSED!!!\");\n+            return;\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}