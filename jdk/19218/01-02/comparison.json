{"files":[{"patch":"@@ -3303,2 +3303,0 @@\n-    Node const* base_last;\n-    jint shift_last;\n@@ -3306,2 +3304,2 @@\n-    merged_input_value = first->in(MemNode::ValueIn);\n-    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+    Node* hi = _store->in(MemNode::ValueIn);\n+    Node* lo = first->in(MemNode::ValueIn);\n@@ -3309,4 +3307,3 @@\n-    \/\/ `_store` points to the lowest using store in the Memory chain. On big endian it stores the\n-    \/\/  unshifted `base`. `_store` and `first` need to be exchanged in the diagram above\n-    merged_input_value = _store->in(MemNode::ValueIn);\n-    bool is_true = is_con_RShift(first->in(MemNode::ValueIn), base_last, shift_last);\n+    \/\/ `_store` and `first` are swapped in the diagram above\n+    Node* hi = first->in(MemNode::ValueIn);\n+    Node* lo = _store->in(MemNode::ValueIn);\n@@ -3314,0 +3311,4 @@\n+    Node const* hi_base;\n+    jint hi_shift;\n+    merged_input_value = lo;\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n@@ -3315,1 +3316,1 @@\n-    if (merged_input_value != base_last && merged_input_value->Opcode() == Op_ConvL2I) {\n+    if (merged_input_value != hi_base && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3319,1 +3320,1 @@\n-    if (merged_input_value != base_last) {\n+    if (merged_input_value != hi_base) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -119,0 +119,8 @@\n+        testGroups.put(\"test2BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2BE\").put(\"test2RBE\", (_,_) -> { return test2RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2aBE\", (_,_) -> { return test2aBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2bBE\", (_,_) -> { return test2bBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2cBE\", (_,_) -> { return test2cBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2dBE\", (_,_) -> { return test2dBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2eBE\", (_,_) -> { return test2eBE(aB.clone(), offset1, vL1); });\n+\n@@ -217,0 +225,5 @@\n+                 \"test2aBE\",\n+                 \"test2bBE\",\n+                 \"test2cBE\",\n+                 \"test2dBE\",\n+                 \"test2eBE\",\n@@ -619,19 +632,8 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 56);\n-            a[offset + 1] = (byte)(v >> 48);\n-            a[offset + 2] = (byte)(v >> 40);\n-            a[offset + 3] = (byte)(v >> 32);\n-            a[offset + 4] = (byte)(v >> 24);\n-            a[offset + 5] = (byte)(v >> 16);\n-            a[offset + 6] = (byte)(v >> 8);\n-            a[offset + 7] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);\n-            a[offset + 1] = (byte)(v >> 8);\n-            a[offset + 2] = (byte)(v >> 16);\n-            a[offset + 3] = (byte)(v >> 24);\n-            a[offset + 4] = (byte)(v >> 32);\n-            a[offset + 5] = (byte)(v >> 40);\n-            a[offset + 6] = (byte)(v >> 48);\n-            a[offset + 7] = (byte)(v >> 56);\n-        }\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n@@ -643,1 +645,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -645,19 +653,8 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 56);\n-            a[offset + 1] = (byte)(v >> 48);\n-            a[offset + 2] = (byte)(v >> 40);\n-            a[offset + 3] = (byte)(v >> 32);\n-            a[offset + 4] = (byte)(v >> 24);\n-            a[offset + 5] = (byte)(v >> 16);\n-            a[offset + 6] = (byte)(v >> 8);\n-            a[offset + 7] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);\n-            a[offset + 1] = (byte)(v >> 8);\n-            a[offset + 2] = (byte)(v >> 16);\n-            a[offset + 3] = (byte)(v >> 24);\n-            a[offset + 4] = (byte)(v >> 32);\n-            a[offset + 5] = (byte)(v >> 40);\n-            a[offset + 6] = (byte)(v >> 48);\n-            a[offset + 7] = (byte)(v >> 56);\n-        }\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n@@ -673,1 +670,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, false \/* bigEndian *\/);\n@@ -679,1 +676,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -681,5 +684,1 @@\n-        if (IS_BIG_ENDIAN) {\n-            storeLongBE(a, offset, v);\n-        } else {\n-            storeLongLE(a, offset, v);\n-        }\n+        storeLongLE(a, offset, v);\n@@ -692,7 +691,2 @@\n-        if (IS_BIG_ENDIAN) {\n-            storeIntBE(a, offset + 0, (int)(v >> 32));\n-            storeIntBE(a, offset + 4, (int)(v >> 0));\n-        } else {\n-            storeIntLE(a, offset + 0, (int)(v >> 0));\n-            storeIntLE(a, offset + 4, (int)(v >> 32));\n-        }\n+        storeIntLE(a, offset + 0, (int)(v >> 0));\n+        storeIntLE(a, offset + 4, (int)(v >> 32));\n@@ -705,11 +699,80 @@\n-        if (IS_BIG_ENDIAN) {\n-            storeShortBE(a, offset + 0, (short)(v >> 48));\n-            storeShortBE(a, offset + 2, (short)(v >> 32));\n-            storeShortBE(a, offset + 4, (short)(v >> 16));\n-            storeShortBE(a, offset + 6, (short)(v >> 0));\n-        } else {\n-            storeShortLE(a, offset + 0, (short)(v >> 0));\n-            storeShortLE(a, offset + 2, (short)(v >> 16));\n-            storeShortLE(a, offset + 4, (short)(v >> 32));\n-            storeShortLE(a, offset + 6, (short)(v >> 48));\n-        }\n+        storeShortLE(a, offset + 0, (short)(v >> 0));\n+        storeShortLE(a, offset + 2, (short)(v >> 16));\n+        storeShortLE(a, offset + 4, (short)(v >> 32));\n+        storeShortLE(a, offset + 6, (short)(v >> 48));\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test2RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2aBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2bBE(byte[] a, int offset, long v) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, true \/* bigEndian *\/);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2cBE(byte[] a, int offset, long v) {\n+        storeLongBE(a, offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> int -> byte does not work\n+    static Object[] test2dBE(byte[] a, int offset, long v) {\n+        storeIntBE(a, offset + 0, (int)(v >> 32));\n+        storeIntBE(a, offset + 4, (int)(v >> 0));\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> short -> byte does not work\n+    static Object[] test2eBE(byte[] a, int offset, long v) {\n+        storeShortBE(a, offset + 0, (short)(v >> 48));\n+        storeShortBE(a, offset + 2, (short)(v >> 32));\n+        storeShortBE(a, offset + 4, (short)(v >> 16));\n+        storeShortBE(a, offset + 6, (short)(v >> 0));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":127,"deletions":64,"binary":false,"changes":191,"status":"modified"}]}