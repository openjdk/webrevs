{"files":[{"patch":"@@ -2884,1 +2884,1 @@\n-\/\/   RangeCheck[i+1]           RangeCheck[i+1]\n+\/\/   RangeCheck[i+3]           RangeCheck[i+3]\n@@ -2891,1 +2891,1 @@\n-\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+1], and StoreB[i+0] on the\n+\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+3], and StoreB[i+0] on the\n@@ -2903,1 +2903,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+1]     <- second store\n+\/\/                              StoreB[i+1]                             StoreB[i+1]     <- second store\n@@ -2905,1 +2905,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+2]\n+\/\/                              StoreB[i+2]                             StoreB[i+2]\n@@ -2907,1 +2907,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+3]     <- last store\n+\/\/                              StoreB[i+3]                             StoreB[i+3]     <- last store\n@@ -3070,0 +3070,5 @@\n+#ifndef VM_LITTLE_ENDIAN\n+  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n+  swap(n1, n2);\n+#endif \/\/ !VM_LITTLE_ENDIAN\n@@ -3284,0 +3289,1 @@\n+#ifdef VM_LITTLE_ENDIAN\n@@ -3286,0 +3292,4 @@\n+#else \/\/ VM_LITTLE_ENDIAN\n+      con_i = (mask & con_i) << (i * bits_per_store);\n+      con = con | con_i;\n+#endif \/\/ VM_LITTLE_ENDIAN\n@@ -3293,4 +3303,10 @@\n-    merged_input_value = first->in(MemNode::ValueIn);\n-    Node const* base_last;\n-    jint shift_last;\n-    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+    Node* hi = _store->in(MemNode::ValueIn);\n+    Node* lo = first->in(MemNode::ValueIn);\n+#ifndef VM_LITTLE_ENDIAN\n+    \/\/ `_store` and `first` are swapped in the diagram above\n+    swap(hi, lo);\n+#endif \/\/ !VM_LITTLE_ENDIAN\n+    Node const* hi_base;\n+    jint hi_shift;\n+    merged_input_value = lo;\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n@@ -3298,1 +3314,1 @@\n-    if (merged_input_value != base_last && merged_input_value->Opcode() == Op_ConvL2I) {\n+    if (merged_input_value != hi_base && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3302,1 +3318,1 @@\n-    if (merged_input_value != base_last) {\n+    if (merged_input_value != hi_base) {\n@@ -3476,1 +3492,0 @@\n-#ifdef VM_LITTLE_ENDIAN\n@@ -3486,1 +3501,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -45,1 +45,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -115,1 +115,9 @@\n-        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2e(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test2BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2BE\").put(\"test2RBE\", (_,_) -> { return test2RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2aBE\", (_,_) -> { return test2aBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2bBE\", (_,_) -> { return test2bBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2cBE\", (_,_) -> { return test2cBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2dBE\", (_,_) -> { return test2dBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2eBE\", (_,_) -> { return test2eBE(aB.clone(), offset1, vL1); });\n@@ -121,0 +129,4 @@\n+        testGroups.put(\"test3BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3BE\").put(\"test3RBE\", (_,_) -> { return test3RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3BE\").put(\"test3aBE\", (_,_) -> { return test3aBE(aB.clone(), offset1, vL1); });\n+\n@@ -125,0 +137,4 @@\n+        testGroups.put(\"test4BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4BE\").put(\"test4RBE\", (_,_) -> { return test4RBE(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4BE\").put(\"test4aBE\", (_,_) -> { return test4aBE(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+\n@@ -137,0 +153,4 @@\n+        testGroups.put(\"test7BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7BE\").put(\"test7RBE\", (_,_) -> { return test7RBE(aB.clone(), offset1, vI1); });\n+        testGroups.get(\"test7BE\").put(\"test7aBE\", (_,_) -> { return test7aBE(aB.clone(), offset1, vI1); });\n+\n@@ -149,0 +169,4 @@\n+        testGroups.put(\"test102BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test102BE\").put(\"test102RBE\", (_,_) -> { return test102RBE(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102BE\").put(\"test102aBE\", (_,_) -> { return test102aBE(aS.clone(), offset1, vL1, vI1, vS1); });\n+\n@@ -161,0 +185,4 @@\n+        testGroups.put(\"test202BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test202BE\").put(\"test202RBE\", (_,_) -> { return test202RBE(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202BE\").put(\"test202aBE\", (_,_) -> { return test202aBE(aI.clone(), offset1, vL1, vI1); });\n+\n@@ -187,0 +215,18 @@\n+        testGroups.put(\"test500BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test500BE\").put(\"test500RBE\", (_,_) -> { return test500RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test500BE\").put(\"test500aBE\", (_,_) -> { return test500aBE(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test501BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test501BE\").put(\"test500RBE\", (_,i) -> { return test500RBE(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test501BE\").put(\"test501aBE\", (_,i) -> { return test501aBE(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                               +-------------------+\n+        \/\/ Create offsets that are sometimes going to pass all RangeChecks, and sometimes one, and sometimes none.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n+        testGroups.put(\"test502BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test502BE\").put(\"test500RBE\", (w,i) -> { return test500RBE(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test502BE\").put(\"test502aBE\", (w,i) -> { return test502aBE(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                                   +-----+   +-------------------+\n+        \/\/ First use something in range, and after warmup randomize going outside the range.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n@@ -194,0 +240,8 @@\n+\n+        testGroups.put(\"test800\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test800\").put(\"test800R\", (_,_) -> { return test800R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test800\").put(\"test800a\", (_,_) -> { return test800a(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test800BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test800BE\").put(\"test800RBE\", (_,_) -> { return test800RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test800BE\").put(\"test800aBE\", (_,_) -> { return test800aBE(aB.clone(), offset1, vL1); });\n@@ -211,0 +265,5 @@\n+                 \"test2aBE\",\n+                 \"test2bBE\",\n+                 \"test2cBE\",\n+                 \"test2dBE\",\n+                 \"test2eBE\",\n@@ -212,0 +271,1 @@\n+                 \"test3aBE\",\n@@ -213,0 +273,1 @@\n+                 \"test4aBE\",\n@@ -216,0 +277,1 @@\n+                 \"test7aBE\",\n@@ -219,0 +281,1 @@\n+                 \"test102aBE\",\n@@ -222,0 +285,1 @@\n+                 \"test202aBE\",\n@@ -227,0 +291,3 @@\n+                 \"test500aBE\",\n+                 \"test501aBE\",\n+                 \"test502aBE\",\n@@ -228,1 +295,3 @@\n-                 \"test700a\"})\n+                 \"test700a\",\n+                 \"test800a\",\n+                 \"test800aBE\"})\n@@ -415,0 +484,33 @@\n+    \/\/ -------------------------------------------\n+    \/\/ -------      Big-Endian API      ----------\n+    \/\/ -------------------------------------------\n+\n+    \/\/ Store a short BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeShortBE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 8),\n+                                  (byte)(value >> 0));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeIntBE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeLongBE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 56),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n@@ -479,1 +581,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL, false \/* bigEndian *\/);\n@@ -592,1 +694,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -611,1 +719,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, false \/* bigEndian *\/);\n@@ -617,1 +725,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -641,0 +755,76 @@\n+    @DontCompile\n+    static Object[] test2RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2aBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2bBE(byte[] a, int offset, long v) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, true \/* bigEndian *\/);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2cBE(byte[] a, int offset, long v) {\n+        storeLongBE(a, offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> int -> byte does not work\n+    static Object[] test2dBE(byte[] a, int offset, long v) {\n+        storeIntBE(a, offset + 0, (int)(v >> 32));\n+        storeIntBE(a, offset + 4, (int)(v >> 0));\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> short -> byte does not work\n+    static Object[] test2eBE(byte[] a, int offset, long v) {\n+        storeShortBE(a, offset + 0, (short)(v >> 48));\n+        storeShortBE(a, offset + 2, (short)(v >> 32));\n+        storeShortBE(a, offset + 4, (short)(v >> 16));\n+        storeShortBE(a, offset + 6, (short)(v >> 0));\n+        return new Object[]{ a };\n+    }\n+\n@@ -656,1 +846,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -669,0 +865,34 @@\n+    @DontCompile\n+    static Object[] test3RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 24);\n+        a[offset + 1] = (byte)(v >> 16);\n+        a[offset + 2] = (byte)(v >> 8);\n+        a[offset + 3] = (byte)(v >> 0);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test3aBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 24);\n+        a[offset + 1] = (byte)(v >> 16);\n+        a[offset + 2] = (byte)(v >> 8);\n+        a[offset + 3] = (byte)(v >> 0);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n@@ -696,1 +926,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -718,0 +955,56 @@\n+    @DontCompile\n+    static Object[] test4RBE(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00;\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 8);\n+        a[offset +  5] = (byte)(v1 >> 0);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 24);\n+        a[offset + 11] = (byte)(v2 >> 16);\n+        a[offset + 12] = (byte)(v2 >> 8);\n+        a[offset + 13] = (byte)(v2 >> 0);\n+        a[offset + 14] = (byte)(v3 >> 8);\n+        a[offset + 15] = (byte)(v3 >> 0);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+ 1 for uncommon trap)\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test4aBE(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00; \/\/ individual load expected to go into state of RC\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 8);\n+        a[offset +  5] = (byte)(v1 >> 0);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 24);\n+        a[offset + 11] = (byte)(v2 >> 16);\n+        a[offset + 12] = (byte)(v2 >> 8);\n+        a[offset + 13] = (byte)(v2 >> 0);\n+        a[offset + 14] = (byte)(v3 >> 8);\n+        a[offset + 15] = (byte)(v3 >> 0);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n@@ -813,0 +1106,20 @@\n+    @DontCompile\n+    static Object[] test7RBE(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 24);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 8);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test7aBE(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 24);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 8);\n+        return new Object[]{ a };\n+    }\n+\n@@ -928,1 +1241,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -950,0 +1270,56 @@\n+    @DontCompile\n+    static Object[] test102RBE(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000;\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >> 16);\n+        a[offset +  5] = (short)(v1 >>  0);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 48);\n+        a[offset + 11] = (short)(v1 >> 32);\n+        a[offset + 12] = (short)(v1 >> 16);\n+        a[offset + 13] = (short)(v1 >> 0);\n+        a[offset + 14] = (short)(v2 >> 16);\n+        a[offset + 15] = (short)(v2 >> 0);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+1 that goes into RC)\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test102aBE(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000; \/\/ store goes into RC\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >> 16);\n+        a[offset +  5] = (short)(v1 >>  0);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 48);\n+        a[offset + 11] = (short)(v1 >> 32);\n+        a[offset + 12] = (short)(v1 >> 16);\n+        a[offset + 13] = (short)(v1 >> 0);\n+        a[offset + 14] = (short)(v2 >> 16);\n+        a[offset + 15] = (short)(v2 >> 0);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n@@ -1065,1 +1441,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"10\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\"}, \/\/ Stores of constants can be merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1078,1 +1461,1 @@\n-        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 11] = (int)(v1 >> 32); \/\/ Stores to +11 and +12 can be merged also on big-endian\n@@ -1087,0 +1470,56 @@\n+    @DontCompile\n+    static Object[] test202RBE(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000;\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >> 32);\n+        a[offset +  5] = (int)(v1 >>  0);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 32);\n+        a[offset + 11] = (int)(v1 >> 0);\n+        a[offset + 12] = (int)(v1 >> 32);\n+        a[offset + 13] = (int)(v1 >> 0);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"10\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\"}, \/\/ Stores of constants can be merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\", \/\/ 5 (+1 that goes into RC)\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test202aBE(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000; \/\/ merged with store below, but also kept unchanged for RC\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >> 32);\n+        a[offset +  5] = (int)(v1 >>  0);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 32);\n+        a[offset + 11] = (int)(v1 >> 0);  \/\/ Stores to +11 and +12 can be merged also on little-endian\n+        a[offset + 12] = (int)(v1 >> 32);\n+        a[offset + 13] = (int)(v1 >> 0);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n@@ -1178,1 +1617,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1258,0 +1703,134 @@\n+    @DontCompile\n+    \/\/ The 500-series has all the same code, but is executed with different inputs:\n+    \/\/ 500a: never violate a RangeCheck -> expect will always merge stores\n+    \/\/ 501a: randomly violate RangeCheck, also during warmup -> never merge stores\n+    \/\/ 502a: during warmup never violate RangeCheck -> compile once with merged stores\n+    \/\/       but then after warmup violate RangeCheck -> recompile without merged stores\n+    static Object[] test500RBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"}, \/\/ expect merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test500aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test501aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test502aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n@@ -1322,0 +1901,65 @@\n+\n+    @DontCompile\n+    static Object[] test800R(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test800a(byte[] a, int offset, long v) {\n+        \/\/ Merge attempts begin at the lowest store in the Memory chain.\n+        \/\/ Candidates are found following the chain. The list is trimmed to a\n+        \/\/ power of 2 length by removing higher stores.\n+        a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n+        a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n+        a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n+        a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n+        a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n+        a[offset + 5] = (byte)(v >> 40);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test800RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 40);\n+        a[offset + 1] = (byte)(v >> 32);\n+        a[offset + 2] = (byte)(v >> 24);\n+        a[offset + 3] = (byte)(v >> 16);\n+        a[offset + 4] = (byte)(v >> 8);\n+        a[offset + 5] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test800aBE(byte[] a, int offset, long v) {\n+        \/\/ Merge attempts begin at the lowest store in the Memory chain.\n+        \/\/ Candidates are found following the chain. The list is trimmed to a\n+        \/\/ power of 2 length by removing higher stores.\n+        a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n+        a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n+        a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n+        a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged on big endian platforms.\n+        a[offset + 4] = (byte)(v >> 8);\n+        a[offset + 5] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":658,"deletions":14,"binary":false,"changes":672,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -77,1 +78,4 @@\n-        \"64-bit\"\n+        \"64-bit\",\n+        \/\/ java.nio.ByteOrder\n+        \"little-endian\",\n+        \"big-endian\"\n@@ -359,1 +363,3 @@\n-        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+        String endianess = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)? \"big-endian\" : \"little-endian\";\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\") + \" \" + endianess;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}