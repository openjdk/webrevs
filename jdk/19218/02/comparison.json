{"files":[{"patch":"@@ -2884,1 +2884,1 @@\n-\/\/   RangeCheck[i+1]           RangeCheck[i+1]\n+\/\/   RangeCheck[i+3]           RangeCheck[i+3]\n@@ -2891,1 +2891,1 @@\n-\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+1], and StoreB[i+0] on the\n+\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+3], and StoreB[i+0] on the\n@@ -2903,1 +2903,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+1]     <- second store\n+\/\/                              StoreB[i+1]                             StoreB[i+1]     <- second store\n@@ -2905,1 +2905,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+2]\n+\/\/                              StoreB[i+2]                             StoreB[i+2]\n@@ -2907,1 +2907,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+3]     <- last store\n+\/\/                              StoreB[i+3]                             StoreB[i+3]     <- last store\n@@ -3070,0 +3070,5 @@\n+#ifndef VM_LITTLE_ENDIAN\n+  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n+  swap(n1, n2);\n+#endif \/\/ !VM_LITTLE_ENDIAN\n@@ -3284,0 +3289,1 @@\n+#ifdef VM_LITTLE_ENDIAN\n@@ -3286,0 +3292,4 @@\n+#else \/\/ VM_LITTLE_ENDIAN\n+      con_i = (mask & con_i) << (i * bits_per_store);\n+      con = con | con_i;\n+#endif \/\/ VM_LITTLE_ENDIAN\n@@ -3293,4 +3303,12 @@\n-    merged_input_value = first->in(MemNode::ValueIn);\n-    Node const* base_last;\n-    jint shift_last;\n-    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+#ifdef VM_LITTLE_ENDIAN\n+    Node* hi = _store->in(MemNode::ValueIn);\n+    Node* lo = first->in(MemNode::ValueIn);\n+#else \/\/ VM_LITTLE_ENDIAN\n+    \/\/ `_store` and `first` are swapped in the diagram above\n+    Node* hi = first->in(MemNode::ValueIn);\n+    Node* lo = _store->in(MemNode::ValueIn);\n+#endif \/\/ VM_LITTLE_ENDIAN\n+    Node const* hi_base;\n+    jint hi_shift;\n+    merged_input_value = lo;\n+    bool is_true = is_con_RShift(hi, hi_base, hi_shift);\n@@ -3298,1 +3316,1 @@\n-    if (merged_input_value != base_last && merged_input_value->Opcode() == Op_ConvL2I) {\n+    if (merged_input_value != hi_base && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3302,1 +3320,1 @@\n-    if (merged_input_value != base_last) {\n+    if (merged_input_value != hi_base) {\n@@ -3476,1 +3494,0 @@\n-#ifdef VM_LITTLE_ENDIAN\n@@ -3486,1 +3503,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -45,1 +45,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -57,0 +57,2 @@\n+    private static final boolean IS_BIG_ENDIAN = UNSAFE.isBigEndian();\n+\n@@ -115,1 +117,9 @@\n-        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2e(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test2BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2BE\").put(\"test2RBE\", (_,_) -> { return test2RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2aBE\", (_,_) -> { return test2aBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2bBE\", (_,_) -> { return test2bBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2cBE\", (_,_) -> { return test2cBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2dBE\", (_,_) -> { return test2dBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2BE\").put(\"test2eBE\", (_,_) -> { return test2eBE(aB.clone(), offset1, vL1); });\n@@ -194,0 +204,4 @@\n+\n+        testGroups.put(\"test800\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test800\").put(\"test800R\", (_,_) -> { return test800R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test800\").put(\"test800a\", (_,_) -> { return test800a(aB.clone(), offset1, vL1); });\n@@ -211,0 +225,5 @@\n+                 \"test2aBE\",\n+                 \"test2bBE\",\n+                 \"test2cBE\",\n+                 \"test2dBE\",\n+                 \"test2eBE\",\n@@ -228,1 +247,2 @@\n-                 \"test700a\"})\n+                 \"test700a\",\n+                 \"test800a\"})\n@@ -415,0 +435,33 @@\n+    \/\/ -------------------------------------------\n+    \/\/ -------      Big-Endian API      ----------\n+    \/\/ -------------------------------------------\n+\n+    \/\/ Store a short BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeShortBE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 8),\n+                                  (byte)(value >> 0));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeIntBE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeLongBE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 56),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n@@ -479,1 +532,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL, false \/* bigEndian *\/);\n@@ -592,1 +645,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -611,1 +670,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, false \/* bigEndian *\/);\n@@ -617,1 +676,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -641,0 +706,76 @@\n+    @DontCompile\n+    static Object[] test2RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2aBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 56);\n+        a[offset + 1] = (byte)(v >> 48);\n+        a[offset + 2] = (byte)(v >> 40);\n+        a[offset + 3] = (byte)(v >> 32);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2bBE(byte[] a, int offset, long v) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v, true \/* bigEndian *\/);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2cBE(byte[] a, int offset, long v) {\n+        storeLongBE(a, offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> int -> byte does not work\n+    static Object[] test2dBE(byte[] a, int offset, long v) {\n+        storeIntBE(a, offset + 0, (int)(v >> 32));\n+        storeIntBE(a, offset + 4, (int)(v >> 0));\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> short -> byte does not work\n+    static Object[] test2eBE(byte[] a, int offset, long v) {\n+        storeShortBE(a, offset + 0, (short)(v >> 48));\n+        storeShortBE(a, offset + 2, (short)(v >> 32));\n+        storeShortBE(a, offset + 4, (short)(v >> 16));\n+        storeShortBE(a, offset + 6, (short)(v >> 0));\n+        return new Object[]{ a };\n+    }\n+\n@@ -643,8 +784,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 0);\n-        a[offset + 5] = (byte)(v >> 8);\n-        a[offset + 6] = (byte)(v >> 16);\n-        a[offset + 7] = (byte)(v >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 24);\n+            a[offset + 1] = (byte)(v >> 16);\n+            a[offset + 2] = (byte)(v >> 8);\n+            a[offset + 3] = (byte)(v >> 0);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 0);\n+            a[offset + 5] = (byte)(v >> 8);\n+            a[offset + 6] = (byte)(v >> 16);\n+            a[offset + 7] = (byte)(v >> 24);\n+        }\n@@ -658,8 +810,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 0);\n-        a[offset + 5] = (byte)(v >> 8);\n-        a[offset + 6] = (byte)(v >> 16);\n-        a[offset + 7] = (byte)(v >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 24);\n+            a[offset + 1] = (byte)(v >> 16);\n+            a[offset + 2] = (byte)(v >> 8);\n+            a[offset + 3] = (byte)(v >> 0);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 0);\n+            a[offset + 5] = (byte)(v >> 8);\n+            a[offset + 6] = (byte)(v >> 16);\n+            a[offset + 7] = (byte)(v >> 24);\n+        }\n@@ -675,2 +838,7 @@\n-        a[offset +  4] = (byte)(v1 >> 0);\n-        a[offset +  5] = (byte)(v1 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (byte)(v1 >> 8);\n+            a[offset +  5] = (byte)(v1 >> 0);\n+        } else {\n+            a[offset +  4] = (byte)(v1 >> 0);\n+            a[offset +  5] = (byte)(v1 >> 8);\n+        }\n@@ -681,6 +849,15 @@\n-        a[offset + 10] = (byte)(v2 >> 0);\n-        a[offset + 11] = (byte)(v2 >> 8);\n-        a[offset + 12] = (byte)(v2 >> 16);\n-        a[offset + 13] = (byte)(v2 >> 24);\n-        a[offset + 14] = (byte)(v3 >> 0);\n-        a[offset + 15] = (byte)(v3 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (byte)(v2 >> 24);\n+            a[offset + 11] = (byte)(v2 >> 16);\n+            a[offset + 12] = (byte)(v2 >> 8);\n+            a[offset + 13] = (byte)(v2 >> 0);\n+            a[offset + 14] = (byte)(v3 >> 8);\n+            a[offset + 15] = (byte)(v3 >> 0);\n+        } else {\n+            a[offset + 10] = (byte)(v2 >> 0);\n+            a[offset + 11] = (byte)(v2 >> 8);\n+            a[offset + 12] = (byte)(v2 >> 16);\n+            a[offset + 13] = (byte)(v2 >> 24);\n+            a[offset + 14] = (byte)(v3 >> 0);\n+            a[offset + 15] = (byte)(v3 >> 8);\n+        }\n@@ -702,2 +879,7 @@\n-        a[offset +  4] = (byte)(v1 >> 0);\n-        a[offset +  5] = (byte)(v1 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (byte)(v1 >> 8);\n+            a[offset +  5] = (byte)(v1 >> 0);\n+        } else {\n+            a[offset +  4] = (byte)(v1 >> 0);\n+            a[offset +  5] = (byte)(v1 >> 8);\n+        }\n@@ -708,6 +890,15 @@\n-        a[offset + 10] = (byte)(v2 >> 0);\n-        a[offset + 11] = (byte)(v2 >> 8);\n-        a[offset + 12] = (byte)(v2 >> 16);\n-        a[offset + 13] = (byte)(v2 >> 24);\n-        a[offset + 14] = (byte)(v3 >> 0);\n-        a[offset + 15] = (byte)(v3 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (byte)(v2 >> 24);\n+            a[offset + 11] = (byte)(v2 >> 16);\n+            a[offset + 12] = (byte)(v2 >> 8);\n+            a[offset + 13] = (byte)(v2 >> 0);\n+            a[offset + 14] = (byte)(v3 >> 8);\n+            a[offset + 15] = (byte)(v3 >> 0);\n+        } else {\n+            a[offset + 10] = (byte)(v2 >> 0);\n+            a[offset + 11] = (byte)(v2 >> 8);\n+            a[offset + 12] = (byte)(v2 >> 16);\n+            a[offset + 13] = (byte)(v2 >> 24);\n+            a[offset + 14] = (byte)(v3 >> 0);\n+            a[offset + 15] = (byte)(v3 >> 8);\n+        }\n@@ -795,3 +986,9 @@\n-        a[offset1 +  1] = (byte)(v1 >> 8);\n-        a[offset1 +  2] = (byte)(v1 >> 16);\n-        a[offset1 +  3] = (byte)(v1 >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset1 +  1] = (byte)(v1 >> 24);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 8);\n+        } else {\n+            a[offset1 +  1] = (byte)(v1 >> 8);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 24);\n+        }\n@@ -807,3 +1004,9 @@\n-        a[offset1 +  1] = (byte)(v1 >> 8);\n-        a[offset1 +  2] = (byte)(v1 >> 16);\n-        a[offset1 +  3] = (byte)(v1 >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset1 +  1] = (byte)(v1 >> 24);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 8);\n+        } else {\n+            a[offset1 +  1] = (byte)(v1 >> 8);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 24);\n+        }\n@@ -907,12 +1110,27 @@\n-        a[offset +  4] = (short)(v1 >>  0);\n-        a[offset +  5] = (short)(v1 >> 16);\n-        a[offset +  6] = (short)0xAB11;\n-        a[offset +  7] = (short)0xCD36;\n-        a[offset +  8] = (short)0xEF89;\n-        a[offset +  9] = (short)0x0156;\n-        a[offset + 10] = (short)(v1 >> 0);\n-        a[offset + 11] = (short)(v1 >> 16);\n-        a[offset + 12] = (short)(v1 >> 32);\n-        a[offset + 13] = (short)(v1 >> 48);\n-        a[offset + 14] = (short)(v2 >> 0);\n-        a[offset + 15] = (short)(v2 >> 16);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (short)(v1 >> 16);\n+            a[offset +  5] = (short)(v1 >>  0);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 48);\n+            a[offset + 11] = (short)(v1 >> 32);\n+            a[offset + 12] = (short)(v1 >> 16);\n+            a[offset + 13] = (short)(v1 >> 0);\n+            a[offset + 14] = (short)(v2 >> 16);\n+            a[offset + 15] = (short)(v2 >> 0);\n+        } else {\n+            a[offset +  4] = (short)(v1 >>  0);\n+            a[offset +  5] = (short)(v1 >> 16);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 0);\n+            a[offset + 11] = (short)(v1 >> 16);\n+            a[offset + 12] = (short)(v1 >> 32);\n+            a[offset + 13] = (short)(v1 >> 48);\n+            a[offset + 14] = (short)(v2 >> 0);\n+            a[offset + 15] = (short)(v2 >> 16);\n+        }\n@@ -934,12 +1152,27 @@\n-        a[offset +  4] = (short)(v1 >>  0);\n-        a[offset +  5] = (short)(v1 >> 16);\n-        a[offset +  6] = (short)0xAB11;\n-        a[offset +  7] = (short)0xCD36;\n-        a[offset +  8] = (short)0xEF89;\n-        a[offset +  9] = (short)0x0156;\n-        a[offset + 10] = (short)(v1 >> 0);\n-        a[offset + 11] = (short)(v1 >> 16);\n-        a[offset + 12] = (short)(v1 >> 32);\n-        a[offset + 13] = (short)(v1 >> 48);\n-        a[offset + 14] = (short)(v2 >> 0);\n-        a[offset + 15] = (short)(v2 >> 16);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (short)(v1 >> 16);\n+            a[offset +  5] = (short)(v1 >>  0);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 48);\n+            a[offset + 11] = (short)(v1 >> 32);\n+            a[offset + 12] = (short)(v1 >> 16);\n+            a[offset + 13] = (short)(v1 >> 0);\n+            a[offset + 14] = (short)(v2 >> 16);\n+            a[offset + 15] = (short)(v2 >> 0);\n+        } else {\n+            a[offset +  4] = (short)(v1 >>  0);\n+            a[offset +  5] = (short)(v1 >> 16);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 0);\n+            a[offset + 11] = (short)(v1 >> 16);\n+            a[offset + 12] = (short)(v1 >> 32);\n+            a[offset + 13] = (short)(v1 >> 48);\n+            a[offset + 14] = (short)(v2 >> 0);\n+            a[offset + 15] = (short)(v2 >> 16);\n+        }\n@@ -1044,2 +1277,7 @@\n-        a[offset +  4] = (int)(v1 >>  0);\n-        a[offset +  5] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (int)(v1 >> 32);\n+            a[offset +  5] = (int)(v1 >>  0);\n+        } else {\n+            a[offset +  4] = (int)(v1 >>  0);\n+            a[offset +  5] = (int)(v1 >> 32);\n+        }\n@@ -1050,4 +1288,11 @@\n-        a[offset + 10] = (int)(v1 >> 0);\n-        a[offset + 11] = (int)(v1 >> 32);\n-        a[offset + 12] = (int)(v1 >> 0);\n-        a[offset + 13] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (int)(v1 >> 32);\n+            a[offset + 11] = (int)(v1 >> 0);\n+            a[offset + 12] = (int)(v1 >> 32);\n+            a[offset + 13] = (int)(v1 >> 0);\n+        } else {\n+            a[offset + 10] = (int)(v1 >> 0);\n+            a[offset + 11] = (int)(v1 >> 32);\n+            a[offset + 12] = (int)(v1 >> 0);\n+            a[offset + 13] = (int)(v1 >> 32);\n+        }\n@@ -1071,2 +1316,7 @@\n-        a[offset +  4] = (int)(v1 >>  0);\n-        a[offset +  5] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (int)(v1 >> 32);\n+            a[offset +  5] = (int)(v1 >>  0);\n+        } else {\n+            a[offset +  4] = (int)(v1 >>  0);\n+            a[offset +  5] = (int)(v1 >> 32);\n+        }\n@@ -1077,4 +1327,11 @@\n-        a[offset + 10] = (int)(v1 >> 0);\n-        a[offset + 11] = (int)(v1 >> 32);\n-        a[offset + 12] = (int)(v1 >> 0);\n-        a[offset + 13] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (int)(v1 >> 32);\n+            a[offset + 11] = (int)(v1 >> 0);\n+            a[offset + 12] = (int)(v1 >> 32);\n+            a[offset + 13] = (int)(v1 >> 0);\n+        } else {\n+            a[offset + 10] = (int)(v1 >> 0);\n+            a[offset + 11] = (int)(v1 >> 32);\n+            a[offset + 12] = (int)(v1 >> 0);\n+            a[offset + 13] = (int)(v1 >> 32);\n+        }\n@@ -1151,20 +1408,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1180,20 +1460,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1206,1 +1509,8 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1208,20 +1518,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n+                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1234,1 +1567,8 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1236,20 +1576,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n+                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1322,0 +1685,54 @@\n+\n+    @DontCompile\n+    static Object[] test800R(byte[] a, int offset, long v) {\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 40);\n+            a[offset + 1] = (byte)(v >> 32);\n+            a[offset + 2] = (byte)(v >> 24);\n+            a[offset + 3] = (byte)(v >> 16);\n+            a[offset + 4] = (byte)(v >> 8);\n+            a[offset + 5] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 32);\n+            a[offset + 5] = (byte)(v >> 40);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test800a(byte[] a, int offset, long v) {\n+        \/\/ Merge attempts begin at the lowest store in the Memory chain.\n+        \/\/ Candidates are found following the chain. The list is trimmed to a\n+        \/\/ power of 2 length by removing higher stores.\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n+            a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n+            a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n+            a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged.\n+            a[offset + 4] = (byte)(v >> 8);\n+            a[offset + 5] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n+            a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n+            a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n+            a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n+            a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n+            a[offset + 5] = (byte)(v >> 40);\n+        }\n+        return new Object[]{ a };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":581,"deletions":164,"binary":false,"changes":745,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -77,1 +78,4 @@\n-        \"64-bit\"\n+        \"64-bit\",\n+        \/\/ java.nio.ByteOrder\n+        \"little-endian\",\n+        \"big-endian\"\n@@ -359,1 +363,3 @@\n-        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+        String endianess = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)? \"big-endian\" : \"little-endian\";\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\") + \" \" + endianess;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}