{"files":[{"patch":"@@ -2884,1 +2884,1 @@\n-\/\/   RangeCheck[i+1]           RangeCheck[i+1]\n+\/\/   RangeCheck[i+3]           RangeCheck[i+3]\n@@ -2891,1 +2891,1 @@\n-\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+1], and StoreB[i+0] on the\n+\/\/ the optimization, the new StoreI[i+0] is on the passing path of RangeCheck[i+3], and StoreB[i+0] on the\n@@ -2903,1 +2903,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+1]     <- second store\n+\/\/                              StoreB[i+1]                             StoreB[i+1]     <- second store\n@@ -2905,1 +2905,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+2]\n+\/\/                              StoreB[i+2]                             StoreB[i+2]\n@@ -2907,1 +2907,1 @@\n-\/\/                              StoreB[i+0]                             StoreB[i+3]     <- last store\n+\/\/                              StoreB[i+3]                             StoreB[i+3]     <- last store\n@@ -3070,0 +3070,5 @@\n+#ifndef VM_LITTLE_ENDIAN\n+  \/\/ Pattern: [n1 = base >> (shift + memory_size), n2 = base >> shift]\n+  \/\/ Swapping n1 with n2 gives same pattern as on little endian platforms.\n+  swap(n1, n2);\n+#endif \/\/ !VM_LITTLE_ENDIAN\n@@ -3284,0 +3289,1 @@\n+#ifdef VM_LITTLE_ENDIAN\n@@ -3286,0 +3292,4 @@\n+#else \/\/ VM_LITTLE_ENDIAN\n+      con_i = (mask & con_i) << (i * bits_per_store);\n+      con = con | con_i;\n+#endif \/\/ VM_LITTLE_ENDIAN\n@@ -3293,1 +3303,0 @@\n-    merged_input_value = first->in(MemNode::ValueIn);\n@@ -3296,0 +3305,2 @@\n+#ifdef VM_LITTLE_ENDIAN\n+    merged_input_value = first->in(MemNode::ValueIn);\n@@ -3297,0 +3308,6 @@\n+#else \/\/ VM_LITTLE_ENDIAN\n+    \/\/ `_store` points to the lowest using store in the Memory chain. On big endian it stores the\n+    \/\/  unshifted `base`. `_store` and `first` need to be exchanged in the diagram above\n+    merged_input_value = _store->in(MemNode::ValueIn);\n+    bool is_true = is_con_RShift(first->in(MemNode::ValueIn), base_last, shift_last);\n+#endif \/\/ VM_LITTLE_ENDIAN\n@@ -3476,1 +3493,0 @@\n-#ifdef VM_LITTLE_ENDIAN\n@@ -3486,1 +3502,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -45,1 +45,1 @@\n- * @bug 8318446 8331054\n+ * @bug 8318446 8331054 8331311\n@@ -57,0 +57,2 @@\n+    private static final boolean IS_BIG_ENDIAN = UNSAFE.isBigEndian();\n+\n@@ -115,1 +117,1 @@\n-        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2e(aB.clone(), offset1, vL1); });\n@@ -194,0 +196,4 @@\n+\n+        testGroups.put(\"test800\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test800\").put(\"test800R\", (_,_) -> { return test800R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test800\").put(\"test800a\", (_,_) -> { return test800a(aB.clone(), offset1, vL1); });\n@@ -228,1 +234,2 @@\n-                 \"test700a\"})\n+                 \"test700a\",\n+                 \"test800a\"})\n@@ -415,0 +422,33 @@\n+    \/\/ -------------------------------------------\n+    \/\/ -------      Big-Endian API      ----------\n+    \/\/ -------------------------------------------\n+\n+    \/\/ Store a short BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeShortBE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 8),\n+                                  (byte)(value >> 0));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeIntBE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n+    \/\/ Store an int BE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeLongBE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 56),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 0 ));\n+    }\n+\n@@ -479,1 +519,1 @@\n-        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL);\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL, false \/* bigEndian *\/);\n@@ -579,8 +619,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 32);\n-        a[offset + 5] = (byte)(v >> 40);\n-        a[offset + 6] = (byte)(v >> 48);\n-        a[offset + 7] = (byte)(v >> 56);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 56);\n+            a[offset + 1] = (byte)(v >> 48);\n+            a[offset + 2] = (byte)(v >> 40);\n+            a[offset + 3] = (byte)(v >> 32);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 32);\n+            a[offset + 5] = (byte)(v >> 40);\n+            a[offset + 6] = (byte)(v >> 48);\n+            a[offset + 7] = (byte)(v >> 56);\n+        }\n@@ -594,8 +645,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 32);\n-        a[offset + 5] = (byte)(v >> 40);\n-        a[offset + 6] = (byte)(v >> 48);\n-        a[offset + 7] = (byte)(v >> 56);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 56);\n+            a[offset + 1] = (byte)(v >> 48);\n+            a[offset + 2] = (byte)(v >> 40);\n+            a[offset + 3] = (byte)(v >> 32);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 32);\n+            a[offset + 5] = (byte)(v >> 40);\n+            a[offset + 6] = (byte)(v >> 48);\n+            a[offset + 7] = (byte)(v >> 56);\n+        }\n@@ -619,1 +681,5 @@\n-        storeLongLE(a, offset, v);\n+        if (IS_BIG_ENDIAN) {\n+            storeLongBE(a, offset, v);\n+        } else {\n+            storeLongLE(a, offset, v);\n+        }\n@@ -626,2 +692,7 @@\n-        storeIntLE(a, offset + 0, (int)(v >> 0));\n-        storeIntLE(a, offset + 4, (int)(v >> 32));\n+        if (IS_BIG_ENDIAN) {\n+            storeIntBE(a, offset + 0, (int)(v >> 32));\n+            storeIntBE(a, offset + 4, (int)(v >> 0));\n+        } else {\n+            storeIntLE(a, offset + 0, (int)(v >> 0));\n+            storeIntLE(a, offset + 4, (int)(v >> 32));\n+        }\n@@ -634,4 +705,11 @@\n-        storeShortLE(a, offset + 0, (short)(v >> 0));\n-        storeShortLE(a, offset + 2, (short)(v >> 16));\n-        storeShortLE(a, offset + 4, (short)(v >> 32));\n-        storeShortLE(a, offset + 6, (short)(v >> 48));\n+        if (IS_BIG_ENDIAN) {\n+            storeShortBE(a, offset + 0, (short)(v >> 48));\n+            storeShortBE(a, offset + 2, (short)(v >> 32));\n+            storeShortBE(a, offset + 4, (short)(v >> 16));\n+            storeShortBE(a, offset + 6, (short)(v >> 0));\n+        } else {\n+            storeShortLE(a, offset + 0, (short)(v >> 0));\n+            storeShortLE(a, offset + 2, (short)(v >> 16));\n+            storeShortLE(a, offset + 4, (short)(v >> 32));\n+            storeShortLE(a, offset + 6, (short)(v >> 48));\n+        }\n@@ -643,8 +721,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 0);\n-        a[offset + 5] = (byte)(v >> 8);\n-        a[offset + 6] = (byte)(v >> 16);\n-        a[offset + 7] = (byte)(v >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 24);\n+            a[offset + 1] = (byte)(v >> 16);\n+            a[offset + 2] = (byte)(v >> 8);\n+            a[offset + 3] = (byte)(v >> 0);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 0);\n+            a[offset + 5] = (byte)(v >> 8);\n+            a[offset + 6] = (byte)(v >> 16);\n+            a[offset + 7] = (byte)(v >> 24);\n+        }\n@@ -658,8 +747,19 @@\n-        a[offset + 0] = (byte)(v >> 0);\n-        a[offset + 1] = (byte)(v >> 8);\n-        a[offset + 2] = (byte)(v >> 16);\n-        a[offset + 3] = (byte)(v >> 24);\n-        a[offset + 4] = (byte)(v >> 0);\n-        a[offset + 5] = (byte)(v >> 8);\n-        a[offset + 6] = (byte)(v >> 16);\n-        a[offset + 7] = (byte)(v >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 24);\n+            a[offset + 1] = (byte)(v >> 16);\n+            a[offset + 2] = (byte)(v >> 8);\n+            a[offset + 3] = (byte)(v >> 0);\n+            a[offset + 4] = (byte)(v >> 24);\n+            a[offset + 5] = (byte)(v >> 16);\n+            a[offset + 6] = (byte)(v >> 8);\n+            a[offset + 7] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 0);\n+            a[offset + 5] = (byte)(v >> 8);\n+            a[offset + 6] = (byte)(v >> 16);\n+            a[offset + 7] = (byte)(v >> 24);\n+        }\n@@ -675,2 +775,7 @@\n-        a[offset +  4] = (byte)(v1 >> 0);\n-        a[offset +  5] = (byte)(v1 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (byte)(v1 >> 8);\n+            a[offset +  5] = (byte)(v1 >> 0);\n+        } else {\n+            a[offset +  4] = (byte)(v1 >> 0);\n+            a[offset +  5] = (byte)(v1 >> 8);\n+        }\n@@ -681,6 +786,15 @@\n-        a[offset + 10] = (byte)(v2 >> 0);\n-        a[offset + 11] = (byte)(v2 >> 8);\n-        a[offset + 12] = (byte)(v2 >> 16);\n-        a[offset + 13] = (byte)(v2 >> 24);\n-        a[offset + 14] = (byte)(v3 >> 0);\n-        a[offset + 15] = (byte)(v3 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (byte)(v2 >> 24);\n+            a[offset + 11] = (byte)(v2 >> 16);\n+            a[offset + 12] = (byte)(v2 >> 8);\n+            a[offset + 13] = (byte)(v2 >> 0);\n+            a[offset + 14] = (byte)(v3 >> 8);\n+            a[offset + 15] = (byte)(v3 >> 0);\n+        } else {\n+            a[offset + 10] = (byte)(v2 >> 0);\n+            a[offset + 11] = (byte)(v2 >> 8);\n+            a[offset + 12] = (byte)(v2 >> 16);\n+            a[offset + 13] = (byte)(v2 >> 24);\n+            a[offset + 14] = (byte)(v3 >> 0);\n+            a[offset + 15] = (byte)(v3 >> 8);\n+        }\n@@ -702,2 +816,7 @@\n-        a[offset +  4] = (byte)(v1 >> 0);\n-        a[offset +  5] = (byte)(v1 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (byte)(v1 >> 8);\n+            a[offset +  5] = (byte)(v1 >> 0);\n+        } else {\n+            a[offset +  4] = (byte)(v1 >> 0);\n+            a[offset +  5] = (byte)(v1 >> 8);\n+        }\n@@ -708,6 +827,15 @@\n-        a[offset + 10] = (byte)(v2 >> 0);\n-        a[offset + 11] = (byte)(v2 >> 8);\n-        a[offset + 12] = (byte)(v2 >> 16);\n-        a[offset + 13] = (byte)(v2 >> 24);\n-        a[offset + 14] = (byte)(v3 >> 0);\n-        a[offset + 15] = (byte)(v3 >> 8);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (byte)(v2 >> 24);\n+            a[offset + 11] = (byte)(v2 >> 16);\n+            a[offset + 12] = (byte)(v2 >> 8);\n+            a[offset + 13] = (byte)(v2 >> 0);\n+            a[offset + 14] = (byte)(v3 >> 8);\n+            a[offset + 15] = (byte)(v3 >> 0);\n+        } else {\n+            a[offset + 10] = (byte)(v2 >> 0);\n+            a[offset + 11] = (byte)(v2 >> 8);\n+            a[offset + 12] = (byte)(v2 >> 16);\n+            a[offset + 13] = (byte)(v2 >> 24);\n+            a[offset + 14] = (byte)(v3 >> 0);\n+            a[offset + 15] = (byte)(v3 >> 8);\n+        }\n@@ -795,3 +923,9 @@\n-        a[offset1 +  1] = (byte)(v1 >> 8);\n-        a[offset1 +  2] = (byte)(v1 >> 16);\n-        a[offset1 +  3] = (byte)(v1 >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset1 +  1] = (byte)(v1 >> 24);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 8);\n+        } else {\n+            a[offset1 +  1] = (byte)(v1 >> 8);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 24);\n+        }\n@@ -807,3 +941,9 @@\n-        a[offset1 +  1] = (byte)(v1 >> 8);\n-        a[offset1 +  2] = (byte)(v1 >> 16);\n-        a[offset1 +  3] = (byte)(v1 >> 24);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset1 +  1] = (byte)(v1 >> 24);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 8);\n+        } else {\n+            a[offset1 +  1] = (byte)(v1 >> 8);\n+            a[offset1 +  2] = (byte)(v1 >> 16);\n+            a[offset1 +  3] = (byte)(v1 >> 24);\n+        }\n@@ -907,12 +1047,27 @@\n-        a[offset +  4] = (short)(v1 >>  0);\n-        a[offset +  5] = (short)(v1 >> 16);\n-        a[offset +  6] = (short)0xAB11;\n-        a[offset +  7] = (short)0xCD36;\n-        a[offset +  8] = (short)0xEF89;\n-        a[offset +  9] = (short)0x0156;\n-        a[offset + 10] = (short)(v1 >> 0);\n-        a[offset + 11] = (short)(v1 >> 16);\n-        a[offset + 12] = (short)(v1 >> 32);\n-        a[offset + 13] = (short)(v1 >> 48);\n-        a[offset + 14] = (short)(v2 >> 0);\n-        a[offset + 15] = (short)(v2 >> 16);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (short)(v1 >> 16);\n+            a[offset +  5] = (short)(v1 >>  0);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 48);\n+            a[offset + 11] = (short)(v1 >> 32);\n+            a[offset + 12] = (short)(v1 >> 16);\n+            a[offset + 13] = (short)(v1 >> 0);\n+            a[offset + 14] = (short)(v2 >> 16);\n+            a[offset + 15] = (short)(v2 >> 0);\n+        } else {\n+            a[offset +  4] = (short)(v1 >>  0);\n+            a[offset +  5] = (short)(v1 >> 16);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 0);\n+            a[offset + 11] = (short)(v1 >> 16);\n+            a[offset + 12] = (short)(v1 >> 32);\n+            a[offset + 13] = (short)(v1 >> 48);\n+            a[offset + 14] = (short)(v2 >> 0);\n+            a[offset + 15] = (short)(v2 >> 16);\n+        }\n@@ -934,12 +1089,27 @@\n-        a[offset +  4] = (short)(v1 >>  0);\n-        a[offset +  5] = (short)(v1 >> 16);\n-        a[offset +  6] = (short)0xAB11;\n-        a[offset +  7] = (short)0xCD36;\n-        a[offset +  8] = (short)0xEF89;\n-        a[offset +  9] = (short)0x0156;\n-        a[offset + 10] = (short)(v1 >> 0);\n-        a[offset + 11] = (short)(v1 >> 16);\n-        a[offset + 12] = (short)(v1 >> 32);\n-        a[offset + 13] = (short)(v1 >> 48);\n-        a[offset + 14] = (short)(v2 >> 0);\n-        a[offset + 15] = (short)(v2 >> 16);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (short)(v1 >> 16);\n+            a[offset +  5] = (short)(v1 >>  0);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 48);\n+            a[offset + 11] = (short)(v1 >> 32);\n+            a[offset + 12] = (short)(v1 >> 16);\n+            a[offset + 13] = (short)(v1 >> 0);\n+            a[offset + 14] = (short)(v2 >> 16);\n+            a[offset + 15] = (short)(v2 >> 0);\n+        } else {\n+            a[offset +  4] = (short)(v1 >>  0);\n+            a[offset +  5] = (short)(v1 >> 16);\n+            a[offset +  6] = (short)0xAB11;\n+            a[offset +  7] = (short)0xCD36;\n+            a[offset +  8] = (short)0xEF89;\n+            a[offset +  9] = (short)0x0156;\n+            a[offset + 10] = (short)(v1 >> 0);\n+            a[offset + 11] = (short)(v1 >> 16);\n+            a[offset + 12] = (short)(v1 >> 32);\n+            a[offset + 13] = (short)(v1 >> 48);\n+            a[offset + 14] = (short)(v2 >> 0);\n+            a[offset + 15] = (short)(v2 >> 16);\n+        }\n@@ -1044,2 +1214,7 @@\n-        a[offset +  4] = (int)(v1 >>  0);\n-        a[offset +  5] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (int)(v1 >> 32);\n+            a[offset +  5] = (int)(v1 >>  0);\n+        } else {\n+            a[offset +  4] = (int)(v1 >>  0);\n+            a[offset +  5] = (int)(v1 >> 32);\n+        }\n@@ -1050,4 +1225,11 @@\n-        a[offset + 10] = (int)(v1 >> 0);\n-        a[offset + 11] = (int)(v1 >> 32);\n-        a[offset + 12] = (int)(v1 >> 0);\n-        a[offset + 13] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (int)(v1 >> 32);\n+            a[offset + 11] = (int)(v1 >> 0);\n+            a[offset + 12] = (int)(v1 >> 32);\n+            a[offset + 13] = (int)(v1 >> 0);\n+        } else {\n+            a[offset + 10] = (int)(v1 >> 0);\n+            a[offset + 11] = (int)(v1 >> 32);\n+            a[offset + 12] = (int)(v1 >> 0);\n+            a[offset + 13] = (int)(v1 >> 32);\n+        }\n@@ -1071,2 +1253,7 @@\n-        a[offset +  4] = (int)(v1 >>  0);\n-        a[offset +  5] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset +  4] = (int)(v1 >> 32);\n+            a[offset +  5] = (int)(v1 >>  0);\n+        } else {\n+            a[offset +  4] = (int)(v1 >>  0);\n+            a[offset +  5] = (int)(v1 >> 32);\n+        }\n@@ -1077,4 +1264,11 @@\n-        a[offset + 10] = (int)(v1 >> 0);\n-        a[offset + 11] = (int)(v1 >> 32);\n-        a[offset + 12] = (int)(v1 >> 0);\n-        a[offset + 13] = (int)(v1 >> 32);\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 10] = (int)(v1 >> 32);\n+            a[offset + 11] = (int)(v1 >> 0);\n+            a[offset + 12] = (int)(v1 >> 32);\n+            a[offset + 13] = (int)(v1 >> 0);\n+        } else {\n+            a[offset + 10] = (int)(v1 >> 0);\n+            a[offset + 11] = (int)(v1 >> 32);\n+            a[offset + 12] = (int)(v1 >> 0);\n+            a[offset + 13] = (int)(v1 >> 32);\n+        }\n@@ -1151,20 +1345,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1180,20 +1397,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1206,1 +1446,8 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1208,20 +1455,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n+                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1234,1 +1504,8 @@\n-                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1236,20 +1513,43 @@\n-        int idx = 0;\n-        try {\n-            a[offset + 0] = (byte)(v >> 0);\n-            idx = 1;\n-            a[offset + 1] = (byte)(v >> 8);\n-            idx = 2;\n-            a[offset + 2] = (byte)(v >> 16);\n-            idx = 3;\n-            a[offset + 3] = (byte)(v >> 24);\n-            idx = 4;\n-            a[offset + 4] = (byte)(v >> 32);\n-            idx = 5;\n-            a[offset + 5] = (byte)(v >> 40);\n-            idx = 6;\n-            a[offset + 6] = (byte)(v >> 48);\n-            idx = 7;\n-            a[offset + 7] = (byte)(v >> 56);\n-            idx = 8;\n-        } catch (ArrayIndexOutOfBoundsException _) {}\n-        return new Object[]{ a, new int[]{ idx } };\n+        if (IS_BIG_ENDIAN) {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 56);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 48);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 40);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 32);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 24);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 16);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n+                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n+                a[offset + 7] = (byte)(v >> 0);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        } else {\n+            int idx = 0;\n+            try {\n+                a[offset + 0] = (byte)(v >> 0);\n+                idx = 1;\n+                a[offset + 1] = (byte)(v >> 8);\n+                idx = 2;\n+                a[offset + 2] = (byte)(v >> 16);\n+                idx = 3;\n+                a[offset + 3] = (byte)(v >> 24);\n+                idx = 4;\n+                a[offset + 4] = (byte)(v >> 32);\n+                idx = 5;\n+                a[offset + 5] = (byte)(v >> 40);\n+                idx = 6;\n+                a[offset + 6] = (byte)(v >> 48);\n+                idx = 7;\n+                a[offset + 7] = (byte)(v >> 56);\n+                idx = 8;\n+            } catch (ArrayIndexOutOfBoundsException _) {}\n+            return new Object[]{ a, new int[]{ idx } };\n+        }\n@@ -1322,0 +1622,54 @@\n+\n+    @DontCompile\n+    static Object[] test800R(byte[] a, int offset, long v) {\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 40);\n+            a[offset + 1] = (byte)(v >> 32);\n+            a[offset + 2] = (byte)(v >> 24);\n+            a[offset + 3] = (byte)(v >> 16);\n+            a[offset + 4] = (byte)(v >> 8);\n+            a[offset + 5] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);\n+            a[offset + 1] = (byte)(v >> 8);\n+            a[offset + 2] = (byte)(v >> 16);\n+            a[offset + 3] = (byte)(v >> 24);\n+            a[offset + 4] = (byte)(v >> 32);\n+            a[offset + 5] = (byte)(v >> 40);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test800a(byte[] a, int offset, long v) {\n+        \/\/ Merge attempts begin at the lowest store in the Memory chain.\n+        \/\/ Candidates are found following the chain. The list is trimmed to a\n+        \/\/ power of 2 length by removing higher stores.\n+        if (IS_BIG_ENDIAN) {\n+            a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n+            a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n+            a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n+            a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged.\n+            a[offset + 4] = (byte)(v >> 8);\n+            a[offset + 5] = (byte)(v >> 0);\n+        } else {\n+            a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n+            a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n+            a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n+            a[offset + 3] = (byte)(v >> 24); \/\/ They cannot be merged though because this would require shifting\n+            a[offset + 4] = (byte)(v >> 32); \/\/ The input.\n+            a[offset + 5] = (byte)(v >> 40);\n+        }\n+        return new Object[]{ a };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":538,"deletions":184,"binary":false,"changes":722,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -77,1 +78,4 @@\n-        \"64-bit\"\n+        \"64-bit\",\n+        \/\/ java.nio.ByteOrder\n+        \"little-endian\",\n+        \"big-endian\"\n@@ -359,1 +363,3 @@\n-        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+        String endianess = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)? \"big-endian\" : \"little-endian\";\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\") + \" \" + endianess;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}