{"files":[{"patch":"@@ -57,2 +57,0 @@\n-    private static final boolean IS_BIG_ENDIAN = UNSAFE.isBigEndian();\n-\n@@ -131,0 +129,4 @@\n+        testGroups.put(\"test3BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3BE\").put(\"test3RBE\", (_,_) -> { return test3RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3BE\").put(\"test3aBE\", (_,_) -> { return test3aBE(aB.clone(), offset1, vL1); });\n+\n@@ -135,0 +137,4 @@\n+        testGroups.put(\"test4BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4BE\").put(\"test4RBE\", (_,_) -> { return test4RBE(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4BE\").put(\"test4aBE\", (_,_) -> { return test4aBE(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+\n@@ -147,0 +153,4 @@\n+        testGroups.put(\"test7BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7BE\").put(\"test7RBE\", (_,_) -> { return test7RBE(aB.clone(), offset1, vI1); });\n+        testGroups.get(\"test7BE\").put(\"test7aBE\", (_,_) -> { return test7aBE(aB.clone(), offset1, vI1); });\n+\n@@ -159,0 +169,4 @@\n+        testGroups.put(\"test102BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test102BE\").put(\"test102RBE\", (_,_) -> { return test102RBE(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102BE\").put(\"test102aBE\", (_,_) -> { return test102aBE(aS.clone(), offset1, vL1, vI1, vS1); });\n+\n@@ -171,0 +185,4 @@\n+        testGroups.put(\"test202BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test202BE\").put(\"test202RBE\", (_,_) -> { return test202RBE(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202BE\").put(\"test202aBE\", (_,_) -> { return test202aBE(aI.clone(), offset1, vL1, vI1); });\n+\n@@ -197,0 +215,18 @@\n+        testGroups.put(\"test500BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test500BE\").put(\"test500RBE\", (_,_) -> { return test500RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test500BE\").put(\"test500aBE\", (_,_) -> { return test500aBE(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test501BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test501BE\").put(\"test500RBE\", (_,i) -> { return test500RBE(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test501BE\").put(\"test501aBE\", (_,i) -> { return test501aBE(aB.clone(), RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                               +-------------------+\n+        \/\/ Create offsets that are sometimes going to pass all RangeChecks, and sometimes one, and sometimes none.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n+        testGroups.put(\"test502BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test502BE\").put(\"test500RBE\", (w,i) -> { return test500RBE(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        testGroups.get(\"test502BE\").put(\"test502aBE\", (w,i) -> { return test502aBE(aB.clone(), w ? offset1 : RANGE - 20 + (i % 30), vL1); });\n+        \/\/                                                                                   +-----+   +-------------------+\n+        \/\/ First use something in range, and after warmup randomize going outside the range.\n+        \/\/ Consequence: all RangeChecks stay in the final compilation.\n+\n@@ -208,0 +244,4 @@\n+\n+        testGroups.put(\"test800BE\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test800BE\").put(\"test800RBE\", (_,_) -> { return test800RBE(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test800BE\").put(\"test800aBE\", (_,_) -> { return test800aBE(aB.clone(), offset1, vL1); });\n@@ -231,0 +271,1 @@\n+                 \"test3aBE\",\n@@ -232,0 +273,1 @@\n+                 \"test4aBE\",\n@@ -235,0 +277,1 @@\n+                 \"test7aBE\",\n@@ -238,0 +281,1 @@\n+                 \"test102aBE\",\n@@ -241,0 +285,1 @@\n+                 \"test202aBE\",\n@@ -246,0 +291,3 @@\n+                 \"test500aBE\",\n+                 \"test501aBE\",\n+                 \"test502aBE\",\n@@ -248,1 +296,2 @@\n-                 \"test800a\"})\n+                 \"test800a\",\n+                 \"test800aBE\"})\n@@ -784,19 +833,8 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 24);\n-            a[offset + 1] = (byte)(v >> 16);\n-            a[offset + 2] = (byte)(v >> 8);\n-            a[offset + 3] = (byte)(v >> 0);\n-            a[offset + 4] = (byte)(v >> 24);\n-            a[offset + 5] = (byte)(v >> 16);\n-            a[offset + 6] = (byte)(v >> 8);\n-            a[offset + 7] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);\n-            a[offset + 1] = (byte)(v >> 8);\n-            a[offset + 2] = (byte)(v >> 16);\n-            a[offset + 3] = (byte)(v >> 24);\n-            a[offset + 4] = (byte)(v >> 0);\n-            a[offset + 5] = (byte)(v >> 8);\n-            a[offset + 6] = (byte)(v >> 16);\n-            a[offset + 7] = (byte)(v >> 24);\n-        }\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n@@ -808,1 +846,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -810,19 +854,42 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 24);\n-            a[offset + 1] = (byte)(v >> 16);\n-            a[offset + 2] = (byte)(v >> 8);\n-            a[offset + 3] = (byte)(v >> 0);\n-            a[offset + 4] = (byte)(v >> 24);\n-            a[offset + 5] = (byte)(v >> 16);\n-            a[offset + 6] = (byte)(v >> 8);\n-            a[offset + 7] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);\n-            a[offset + 1] = (byte)(v >> 8);\n-            a[offset + 2] = (byte)(v >> 16);\n-            a[offset + 3] = (byte)(v >> 24);\n-            a[offset + 4] = (byte)(v >> 0);\n-            a[offset + 5] = (byte)(v >> 8);\n-            a[offset + 6] = (byte)(v >> 16);\n-            a[offset + 7] = (byte)(v >> 24);\n-        }\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test3RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 24);\n+        a[offset + 1] = (byte)(v >> 16);\n+        a[offset + 2] = (byte)(v >> 8);\n+        a[offset + 3] = (byte)(v >> 0);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test3aBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 24);\n+        a[offset + 1] = (byte)(v >> 16);\n+        a[offset + 2] = (byte)(v >> 8);\n+        a[offset + 3] = (byte)(v >> 0);\n+        a[offset + 4] = (byte)(v >> 24);\n+        a[offset + 5] = (byte)(v >> 16);\n+        a[offset + 6] = (byte)(v >> 8);\n+        a[offset + 7] = (byte)(v >> 0);\n@@ -838,7 +905,2 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (byte)(v1 >> 8);\n-            a[offset +  5] = (byte)(v1 >> 0);\n-        } else {\n-            a[offset +  4] = (byte)(v1 >> 0);\n-            a[offset +  5] = (byte)(v1 >> 8);\n-        }\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n@@ -849,15 +911,6 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 10] = (byte)(v2 >> 24);\n-            a[offset + 11] = (byte)(v2 >> 16);\n-            a[offset + 12] = (byte)(v2 >> 8);\n-            a[offset + 13] = (byte)(v2 >> 0);\n-            a[offset + 14] = (byte)(v3 >> 8);\n-            a[offset + 15] = (byte)(v3 >> 0);\n-        } else {\n-            a[offset + 10] = (byte)(v2 >> 0);\n-            a[offset + 11] = (byte)(v2 >> 8);\n-            a[offset + 12] = (byte)(v2 >> 16);\n-            a[offset + 13] = (byte)(v2 >> 24);\n-            a[offset + 14] = (byte)(v3 >> 0);\n-            a[offset + 15] = (byte)(v3 >> 8);\n-        }\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n@@ -873,1 +926,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -879,7 +939,2 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (byte)(v1 >> 8);\n-            a[offset +  5] = (byte)(v1 >> 0);\n-        } else {\n-            a[offset +  4] = (byte)(v1 >> 0);\n-            a[offset +  5] = (byte)(v1 >> 8);\n-        }\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n@@ -890,15 +945,62 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 10] = (byte)(v2 >> 24);\n-            a[offset + 11] = (byte)(v2 >> 16);\n-            a[offset + 12] = (byte)(v2 >> 8);\n-            a[offset + 13] = (byte)(v2 >> 0);\n-            a[offset + 14] = (byte)(v3 >> 8);\n-            a[offset + 15] = (byte)(v3 >> 0);\n-        } else {\n-            a[offset + 10] = (byte)(v2 >> 0);\n-            a[offset + 11] = (byte)(v2 >> 8);\n-            a[offset + 12] = (byte)(v2 >> 16);\n-            a[offset + 13] = (byte)(v2 >> 24);\n-            a[offset + 14] = (byte)(v3 >> 0);\n-            a[offset + 15] = (byte)(v3 >> 8);\n-        }\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test4RBE(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00;\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 8);\n+        a[offset +  5] = (byte)(v1 >> 0);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 24);\n+        a[offset + 11] = (byte)(v2 >> 16);\n+        a[offset + 12] = (byte)(v2 >> 8);\n+        a[offset + 13] = (byte)(v2 >> 0);\n+        a[offset + 14] = (byte)(v3 >> 8);\n+        a[offset + 15] = (byte)(v3 >> 0);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+ 1 for uncommon trap)\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test4aBE(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00; \/\/ individual load expected to go into state of RC\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 8);\n+        a[offset +  5] = (byte)(v1 >> 0);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 24);\n+        a[offset + 11] = (byte)(v2 >> 16);\n+        a[offset + 12] = (byte)(v2 >> 8);\n+        a[offset + 13] = (byte)(v2 >> 0);\n+        a[offset + 14] = (byte)(v3 >> 8);\n+        a[offset + 15] = (byte)(v3 >> 0);\n@@ -986,9 +1088,3 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset1 +  1] = (byte)(v1 >> 24);\n-            a[offset1 +  2] = (byte)(v1 >> 16);\n-            a[offset1 +  3] = (byte)(v1 >> 8);\n-        } else {\n-            a[offset1 +  1] = (byte)(v1 >> 8);\n-            a[offset1 +  2] = (byte)(v1 >> 16);\n-            a[offset1 +  3] = (byte)(v1 >> 24);\n-        }\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n@@ -1004,9 +1100,23 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset1 +  1] = (byte)(v1 >> 24);\n-            a[offset1 +  2] = (byte)(v1 >> 16);\n-            a[offset1 +  3] = (byte)(v1 >> 8);\n-        } else {\n-            a[offset1 +  1] = (byte)(v1 >> 8);\n-            a[offset1 +  2] = (byte)(v1 >> 16);\n-            a[offset1 +  3] = (byte)(v1 >> 24);\n-        }\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test7RBE(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 24);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 8);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test7aBE(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 24);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 8);\n@@ -1110,27 +1220,12 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (short)(v1 >> 16);\n-            a[offset +  5] = (short)(v1 >>  0);\n-            a[offset +  6] = (short)0xAB11;\n-            a[offset +  7] = (short)0xCD36;\n-            a[offset +  8] = (short)0xEF89;\n-            a[offset +  9] = (short)0x0156;\n-            a[offset + 10] = (short)(v1 >> 48);\n-            a[offset + 11] = (short)(v1 >> 32);\n-            a[offset + 12] = (short)(v1 >> 16);\n-            a[offset + 13] = (short)(v1 >> 0);\n-            a[offset + 14] = (short)(v2 >> 16);\n-            a[offset + 15] = (short)(v2 >> 0);\n-        } else {\n-            a[offset +  4] = (short)(v1 >>  0);\n-            a[offset +  5] = (short)(v1 >> 16);\n-            a[offset +  6] = (short)0xAB11;\n-            a[offset +  7] = (short)0xCD36;\n-            a[offset +  8] = (short)0xEF89;\n-            a[offset +  9] = (short)0x0156;\n-            a[offset + 10] = (short)(v1 >> 0);\n-            a[offset + 11] = (short)(v1 >> 16);\n-            a[offset + 12] = (short)(v1 >> 32);\n-            a[offset + 13] = (short)(v1 >> 48);\n-            a[offset + 14] = (short)(v2 >> 0);\n-            a[offset + 15] = (short)(v2 >> 16);\n-        }\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n@@ -1146,1 +1241,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1152,27 +1254,68 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (short)(v1 >> 16);\n-            a[offset +  5] = (short)(v1 >>  0);\n-            a[offset +  6] = (short)0xAB11;\n-            a[offset +  7] = (short)0xCD36;\n-            a[offset +  8] = (short)0xEF89;\n-            a[offset +  9] = (short)0x0156;\n-            a[offset + 10] = (short)(v1 >> 48);\n-            a[offset + 11] = (short)(v1 >> 32);\n-            a[offset + 12] = (short)(v1 >> 16);\n-            a[offset + 13] = (short)(v1 >> 0);\n-            a[offset + 14] = (short)(v2 >> 16);\n-            a[offset + 15] = (short)(v2 >> 0);\n-        } else {\n-            a[offset +  4] = (short)(v1 >>  0);\n-            a[offset +  5] = (short)(v1 >> 16);\n-            a[offset +  6] = (short)0xAB11;\n-            a[offset +  7] = (short)0xCD36;\n-            a[offset +  8] = (short)0xEF89;\n-            a[offset +  9] = (short)0x0156;\n-            a[offset + 10] = (short)(v1 >> 0);\n-            a[offset + 11] = (short)(v1 >> 16);\n-            a[offset + 12] = (short)(v1 >> 32);\n-            a[offset + 13] = (short)(v1 >> 48);\n-            a[offset + 14] = (short)(v2 >> 0);\n-            a[offset + 15] = (short)(v2 >> 16);\n-        }\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test102RBE(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000;\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >> 16);\n+        a[offset +  5] = (short)(v1 >>  0);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 48);\n+        a[offset + 11] = (short)(v1 >> 32);\n+        a[offset + 12] = (short)(v1 >> 16);\n+        a[offset + 13] = (short)(v1 >> 0);\n+        a[offset + 14] = (short)(v2 >> 16);\n+        a[offset + 15] = (short)(v2 >> 0);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"12\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",  \/\/ Stores of constants can be merged\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+1 that goes into RC)\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test102aBE(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000; \/\/ store goes into RC\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >> 16);\n+        a[offset +  5] = (short)(v1 >>  0);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 48);\n+        a[offset + 11] = (short)(v1 >> 32);\n+        a[offset + 12] = (short)(v1 >> 16);\n+        a[offset + 13] = (short)(v1 >> 0);\n+        a[offset + 14] = (short)(v2 >> 16);\n+        a[offset + 15] = (short)(v2 >> 0);\n@@ -1277,7 +1420,2 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (int)(v1 >> 32);\n-            a[offset +  5] = (int)(v1 >>  0);\n-        } else {\n-            a[offset +  4] = (int)(v1 >>  0);\n-            a[offset +  5] = (int)(v1 >> 32);\n-        }\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n@@ -1288,11 +1426,4 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 10] = (int)(v1 >> 32);\n-            a[offset + 11] = (int)(v1 >> 0);\n-            a[offset + 12] = (int)(v1 >> 32);\n-            a[offset + 13] = (int)(v1 >> 0);\n-        } else {\n-            a[offset + 10] = (int)(v1 >> 0);\n-            a[offset + 11] = (int)(v1 >> 32);\n-            a[offset + 12] = (int)(v1 >> 0);\n-            a[offset + 13] = (int)(v1 >> 32);\n-        }\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n@@ -1310,1 +1441,8 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"10\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\"}, \/\/ Stores of constants can be merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1316,7 +1454,2 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset +  4] = (int)(v1 >> 32);\n-            a[offset +  5] = (int)(v1 >>  0);\n-        } else {\n-            a[offset +  4] = (int)(v1 >>  0);\n-            a[offset +  5] = (int)(v1 >> 32);\n-        }\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n@@ -1327,11 +1460,60 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 10] = (int)(v1 >> 32);\n-            a[offset + 11] = (int)(v1 >> 0);\n-            a[offset + 12] = (int)(v1 >> 32);\n-            a[offset + 13] = (int)(v1 >> 0);\n-        } else {\n-            a[offset + 10] = (int)(v1 >> 0);\n-            a[offset + 11] = (int)(v1 >> 32);\n-            a[offset + 12] = (int)(v1 >> 0);\n-            a[offset + 13] = (int)(v1 >> 32);\n-        }\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32); \/\/ Stores to +11 and +12 can be merged also on big-endian\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test202RBE(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000;\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >> 32);\n+        a[offset +  5] = (int)(v1 >>  0);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 32);\n+        a[offset + 11] = (int)(v1 >> 0);\n+        a[offset + 12] = (int)(v1 >> 32);\n+        a[offset + 13] = (int)(v1 >> 0);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"10\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\"}, \/\/ Stores of constants can be merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\", \/\/ 5 (+1 that goes into RC)\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test202aBE(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000; \/\/ merged with store below, but also kept unchanged for RC\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >> 32);\n+        a[offset +  5] = (int)(v1 >>  0);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 32);\n+        a[offset + 11] = (int)(v1 >> 0);  \/\/ Stores to +11 and +12 can be merged also on little-endian\n+        a[offset + 12] = (int)(v1 >> 32);\n+        a[offset + 13] = (int)(v1 >> 0);\n@@ -1408,43 +1590,20 @@\n-        if (IS_BIG_ENDIAN) {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 56);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 48);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 40);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 32);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 24);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 16);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 8);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 0);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        } else {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 0);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 8);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 16);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 24);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 32);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 40);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 48);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 56);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        }\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n@@ -1458,1 +1617,7 @@\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n@@ -1460,43 +1625,20 @@\n-        if (IS_BIG_ENDIAN) {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 56);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 48);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 40);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 32);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 24);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 16);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 8);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 0);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        } else {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 0);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 8);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 16);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 24);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 32);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 40);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 48);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 56);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        }\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n@@ -1507,0 +1649,120 @@\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test501a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ No optimization because of too many RangeChecks\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test502a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @DontCompile\n+    \/\/ The 500-series has all the same code, but is executed with different inputs:\n+    \/\/ 500a: never violate a RangeCheck -> expect will always merge stores\n+    \/\/ 501a: randomly violate RangeCheck, also during warmup -> never merge stores\n+    \/\/ 502a: during warmup never violate RangeCheck -> compile once with merged stores\n+    \/\/       but then after warmup violate RangeCheck -> recompile without merged stores\n+    static Object[] test500RBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"},\n+        applyIfPlatform = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"}, \/\/ expect merged\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test500aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n@@ -1517,44 +1779,21 @@\n-    static Object[] test501a(byte[] a, int offset, long v) {\n-        if (IS_BIG_ENDIAN) {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 56);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 48);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 40);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 32);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 24);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 16);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n-                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n-                a[offset + 7] = (byte)(v >> 0);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        } else {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 0);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 8);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 16);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 24);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 32);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 40);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 48);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 56);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        }\n+    static Object[] test501aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n@@ -1564,1 +1803,1 @@\n-    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ No optimization because of too many RangeChecks\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n@@ -1575,44 +1814,21 @@\n-    static Object[] test502a(byte[] a, int offset, long v) {\n-        if (IS_BIG_ENDIAN) {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 56);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 48);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 40);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 32);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 24);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 16);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 8); \/\/ 2 lowest StoreB are merged. 7th StoreB is\n-                idx = 7;                        \/\/ needed if RC for a[offset + 7] fails.\n-                a[offset + 7] = (byte)(v >> 0);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        } else {\n-            int idx = 0;\n-            try {\n-                a[offset + 0] = (byte)(v >> 0);\n-                idx = 1;\n-                a[offset + 1] = (byte)(v >> 8);\n-                idx = 2;\n-                a[offset + 2] = (byte)(v >> 16);\n-                idx = 3;\n-                a[offset + 3] = (byte)(v >> 24);\n-                idx = 4;\n-                a[offset + 4] = (byte)(v >> 32);\n-                idx = 5;\n-                a[offset + 5] = (byte)(v >> 40);\n-                idx = 6;\n-                a[offset + 6] = (byte)(v >> 48);\n-                idx = 7;\n-                a[offset + 7] = (byte)(v >> 56);\n-                idx = 8;\n-            } catch (ArrayIndexOutOfBoundsException _) {}\n-            return new Object[]{ a, new int[]{ idx } };\n-        }\n+    static Object[] test502aBE(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 56);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 48);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 40);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 32);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 24);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 16);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 8);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 0);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n@@ -1688,15 +1904,35 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 40);\n-            a[offset + 1] = (byte)(v >> 32);\n-            a[offset + 2] = (byte)(v >> 24);\n-            a[offset + 3] = (byte)(v >> 16);\n-            a[offset + 4] = (byte)(v >> 8);\n-            a[offset + 5] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);\n-            a[offset + 1] = (byte)(v >> 8);\n-            a[offset + 2] = (byte)(v >> 16);\n-            a[offset + 3] = (byte)(v >> 24);\n-            a[offset + 4] = (byte)(v >> 32);\n-            a[offset + 5] = (byte)(v >> 40);\n-        }\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test800a(byte[] a, int offset, long v) {\n+        \/\/ Merge attempts begin at the lowest store in the Memory chain.\n+        \/\/ Candidates are found following the chain. The list is trimmed to a\n+        \/\/ power of 2 length by removing higher stores.\n+        a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n+        a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n+        a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n+        a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n+        a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n+        a[offset + 5] = (byte)(v >> 40);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test800RBE(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 40);\n+        a[offset + 1] = (byte)(v >> 32);\n+        a[offset + 2] = (byte)(v >> 24);\n+        a[offset + 3] = (byte)(v >> 16);\n+        a[offset + 4] = (byte)(v >> 8);\n+        a[offset + 5] = (byte)(v >> 0);\n@@ -1718,1 +1954,1 @@\n-    static Object[] test800a(byte[] a, int offset, long v) {\n+    static Object[] test800aBE(byte[] a, int offset, long v) {\n@@ -1722,15 +1958,6 @@\n-        if (IS_BIG_ENDIAN) {\n-            a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n-            a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n-            a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n-            a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged.\n-            a[offset + 4] = (byte)(v >> 8);\n-            a[offset + 5] = (byte)(v >> 0);\n-        } else {\n-            a[offset + 0] = (byte)(v >> 0);  \/\/ Removed from candidate list\n-            a[offset + 1] = (byte)(v >> 8);  \/\/ Removed from candidate list\n-            a[offset + 2] = (byte)(v >> 16); \/\/ The 4 following stores are on the candidate list.\n-            a[offset + 3] = (byte)(v >> 24); \/\/ The current logic does not merge them\n-            a[offset + 4] = (byte)(v >> 32); \/\/ since it would require shifting the input.\n-            a[offset + 5] = (byte)(v >> 40);\n-        }\n+        a[offset + 0] = (byte)(v >> 40); \/\/ Removed from candidate list\n+        a[offset + 1] = (byte)(v >> 32); \/\/ Removed from candidate list\n+        a[offset + 2] = (byte)(v >> 24); \/\/ The 4 following stores are on the candidate list\n+        a[offset + 3] = (byte)(v >> 16); \/\/ and they are successfully merged on big endian platforms.\n+        a[offset + 4] = (byte)(v >> 8);\n+        a[offset + 5] = (byte)(v >> 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":631,"deletions":404,"binary":false,"changes":1035,"status":"modified"}]}