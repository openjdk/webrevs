{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -51,0 +54,1 @@\n+PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n@@ -65,0 +69,4 @@\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator\n+    = new PartialArrayStateAllocator(ParallelGCThreads);\n+\n@@ -70,0 +78,1 @@\n+    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -127,0 +136,4 @@\n+  \/\/ All PartialArrayStates have been returned to the allocator, since the\n+  \/\/ claimed_stack_depths are all empty.  Leave them there for use by future\n+  \/\/ collections.\n+\n@@ -175,1 +188,4 @@\n-PSPromotionManager::PSPromotionManager() {\n+\/\/ Most members are initialized either by initialize() or reset().\n+PSPromotionManager::PSPromotionManager()\n+  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+{\n@@ -185,1 +201,3 @@\n-  _array_chunk_size = ParGCArrayScanChunk;\n+  \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n@@ -187,1 +205,1 @@\n-  _min_array_size_for_chunking = 3 * _array_chunk_size \/ 2;\n+  _min_array_size_for_chunking = (3 * ParGCArrayScanChunk \/ 2);\n@@ -280,7 +298,1 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n-  assert(PSChunkLargeArrays, \"invariant\");\n-\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n@@ -289,11 +301,15 @@\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  if (UseCompressedOops) {\n+    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n@@ -301,4 +317,1 @@\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n+    process_array_chunk_work<oop>(state->destination(), start, end);\n@@ -306,0 +319,3 @@\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n@@ -307,0 +323,22 @@\n+void PSPromotionManager::push_objArray(oop old_obj, oop new_obj, size_t obj_size) {\n+  assert(old_obj->is_objArray(), \"precondition\");\n+  assert(old_obj->is_forwarded(), \"precondition\");\n+  assert(old_obj->forwardee() == new_obj, \"precondition\");\n+  assert(new_obj->is_objArray(), \"precondition\");\n+\n+  size_t array_length = objArrayOop(new_obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                               old_obj, new_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n@@ -308,1 +346,1 @@\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n@@ -310,1 +348,1 @@\n-    process_array_chunk_work<oop>(obj, start, end);\n+    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -52,0 +53,2 @@\n+class PartialArrayState;\n+class PartialArrayStateAllocator;\n@@ -88,1 +91,3 @@\n-  uint                                _array_chunk_size;\n+  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+  PartialArrayTaskStepper             _partial_array_stepper;\n+  uint                                _partial_array_state_allocator_index;\n@@ -104,1 +109,2 @@\n-  void process_array_chunk(PartialArrayScanTask task);\n+  void process_array_chunk(PartialArrayState* state);\n+  void push_objArray(oop old_obj, oop new_obj, size_t obj_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,3 +279,1 @@\n-      \/\/ we'll chunk it\n-      push_depth(ScannerTask(PartialArrayScanTask(o)));\n-      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+      push_objArray(o, new_obj, new_obj_size);\n@@ -325,1 +323,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n@@ -327,1 +325,1 @@\n-    process_array_chunk(task.to_partial_array_task());\n+    process_array_chunk(task.to_partial_array_state());\n@@ -344,1 +342,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -112,1 +113,1 @@\n-class PartialArrayStateAllocator {\n+class PartialArrayStateAllocator : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -576,14 +576,0 @@\n-\/\/ Wrapper over an oop that is a partially scanned array.\n-\/\/ Can be converted to a ScannerTask for placement in associated task queues.\n-\/\/ Refers to the partially copied source array oop.\n-\/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-class PartialArrayScanTask {\n-  oop _src;\n-\n-public:\n-  explicit PartialArrayScanTask(oop src_array) : _src(src_array) {}\n-  \/\/ Trivially copyable.\n-\n-  oop to_source_array() const { return _src; }\n-};\n-\n@@ -630,4 +616,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  explicit ScannerTask(PartialArrayScanTask t) :\n-    _p(encode(t.to_source_array(), PartialArrayTag)) {}\n-\n@@ -649,5 +631,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  bool is_partial_array_task() const {\n-    return (raw_value() & PartialArrayTag) != 0;\n-  }\n-\n@@ -666,5 +643,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  PartialArrayScanTask to_partial_array_task() const {\n-    return PartialArrayScanTask(cast_to_oop(decode(PartialArrayTag)));\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"}]}