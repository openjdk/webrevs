{"files":[{"patch":"@@ -151,0 +151,1 @@\n+        java.desktop, \/\/ for ScopedValue\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,660 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.font;\n+\n+import java.awt.geom.Point2D;\n+import sun.font.GlyphLayout.GVData;\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import static java.lang.foreign.MemorySegment.NULL;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.UnionLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import java.util.Optional;\n+import java.util.WeakHashMap;\n+\n+public class HBShaper {\n+\n+    \/*\n+     * union _hb_var_int_t {\n+     *     uint32_t u32;\n+     *     int32_t i32;\n+     *     uint16_t u16[2];\n+     *     int16_t i16[2];\n+     *     uint8_t u8[4];\n+     *     int8_t i8[4];\n+     * };\n+     *\/\n+    private static final UnionLayout VarIntLayout = MemoryLayout.unionLayout(\n+        JAVA_INT.withName(\"u32\"),\n+        JAVA_INT.withName(\"i32\"),\n+        MemoryLayout.sequenceLayout(2, JAVA_SHORT).withName(\"u16\"),\n+        MemoryLayout.sequenceLayout(2, JAVA_SHORT).withName(\"i16\"),\n+        MemoryLayout.sequenceLayout(4, JAVA_BYTE).withName(\"u8\"),\n+        MemoryLayout.sequenceLayout(4, JAVA_BYTE).withName(\"i8\")\n+    ).withName(\"_hb_var_int_t\");\n+\n+    \/*\n+     * struct hb_glyph_position_t {\n+     *     hb_position_t x_advance;\n+     *     hb_position_t y_advance;\n+     *     hb_position_t x_offset;\n+     *     hb_position_t y_offset;\n+     *     hb_var_int_t var;\n+     * };\n+     *\/\n+    private static final StructLayout PositionLayout = MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"x_advance\"),\n+        JAVA_INT.withName(\"y_advance\"),\n+        JAVA_INT.withName(\"x_offset\"),\n+        JAVA_INT.withName(\"y_offset\"),\n+        VarIntLayout.withName(\"var\")\n+     ).withName(\"hb_glyph_position_t\");\n+\n+    \/**\n+     * struct hb_glyph_info_t {\n+     *     hb_codepoint_t codepoint;\n+     *     hb_mask_t mask;\n+     *     uint32_t cluster;\n+     *     hb_var_int_t var1;\n+     *     hb_var_int_t var2;\n+     * };\n+     *\/\n+    private static final StructLayout GlyphInfoLayout = MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"codepoint\"),\n+        JAVA_INT.withName(\"mask\"),\n+        JAVA_INT.withName(\"cluster\"),\n+        VarIntLayout.withName(\"var1\"),\n+        VarIntLayout.withName(\"var2\")\n+    ).withName(\"hb_glyph_info_t\");\n+\n+    private static VarHandle getVarHandle(StructLayout struct, String name) {\n+        VarHandle h = struct.arrayElementVarHandle(PathElement.groupElement(name));\n+        \/* insert 0 offset so don't need to pass arg every time *\/\n+        return MethodHandles.insertCoordinates(h, 1, 0L).withInvokeExactBehavior();\n+    }\n+\n+    private static final VarHandle x_offsetHandle;\n+    private static final VarHandle y_offsetHandle;\n+    private static final VarHandle x_advanceHandle;\n+    private static final VarHandle y_advanceHandle;\n+    private static final VarHandle codePointHandle;\n+    private static final VarHandle clusterHandle;\n+\n+    private static final MethodHandles.Lookup MH_LOOKUP;\n+    private static final Linker LINKER;\n+    private static final SymbolLookup SYM_LOOKUP;\n+    private static final MethodHandle malloc_handle;\n+    private static final MethodHandle create_face_handle;\n+    private static final MethodHandle dispose_face_handle;\n+    private static final MethodHandle jdk_hb_shape_handle;\n+\n+    \/* hb_jdk_font_funcs_struct is a pointer to a harfbuzz font_funcs\n+     * object which references the 5 following upcall stubs.\n+     * The singleton shared font_funcs ptr is passed down in each\n+     * call to shape() and installed on the hb_font.\n+     *\/\n+    private static final MemorySegment hb_jdk_font_funcs_struct;\n+    private static final MemorySegment get_var_glyph_stub;\n+    private static final MemorySegment get_nominal_glyph_stub;\n+    private static final MemorySegment get_h_advance_stub;\n+    private static final MemorySegment get_v_advance_stub;\n+    private static final MemorySegment get_contour_pt_stub;\n+\n+    private static final MemorySegment store_layout_results_stub;\n+\n+    private static FunctionDescriptor\n+       getFunctionDescriptor(MemoryLayout retType,\n+                             MemoryLayout... argTypes) {\n+\n+       return (retType == null) ?\n+               FunctionDescriptor.ofVoid(argTypes) :\n+               FunctionDescriptor.of(retType, argTypes);\n+    }\n+\n+    private static MethodHandle getMethodHandle\n+         (String mName,\n+          FunctionDescriptor fd) {\n+\n+        try {\n+            MethodType mType = fd.toMethodType();\n+            return MH_LOOKUP.findStatic(HBShaper.class, mName, mType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+           return null;\n+       }\n+   }\n+\n+    static {\n+        MH_LOOKUP = MethodHandles.lookup();\n+        LINKER = Linker.nativeLinker();\n+        SYM_LOOKUP = SymbolLookup.loaderLookup().or(LINKER.defaultLookup());\n+        FunctionDescriptor mallocDescriptor =\n+            FunctionDescriptor.of(ADDRESS, JAVA_LONG);\n+        Optional<MemorySegment> malloc_symbol = SYM_LOOKUP.find(\"malloc\");\n+        @SuppressWarnings(\"restricted\")\n+        MethodHandle tmp1 = LINKER.downcallHandle(malloc_symbol.get(), mallocDescriptor);\n+        malloc_handle = tmp1;\n+\n+        FunctionDescriptor createFaceDescriptor =\n+            FunctionDescriptor.of(ADDRESS, ADDRESS);\n+        Optional<MemorySegment> create_face_symbol = SYM_LOOKUP.find(\"HBCreateFace\");\n+        @SuppressWarnings(\"restricted\")\n+        MethodHandle tmp2 = LINKER.downcallHandle(create_face_symbol.get(), createFaceDescriptor);\n+        create_face_handle = tmp2;\n+\n+        FunctionDescriptor disposeFaceDescriptor = FunctionDescriptor.ofVoid(ADDRESS);\n+        Optional<MemorySegment> dispose_face_symbol = SYM_LOOKUP.find(\"HBDisposeFace\");\n+        @SuppressWarnings(\"restricted\")\n+        MethodHandle tmp3 = LINKER.downcallHandle(dispose_face_symbol.get(), disposeFaceDescriptor);\n+        dispose_face_handle = tmp3;\n+\n+        FunctionDescriptor shapeDesc = FunctionDescriptor.ofVoid(\n+            \/\/JAVA_INT,    \/\/ return type\n+            JAVA_FLOAT,  \/\/ ptSize\n+            ADDRESS,     \/\/ matrix\n+            ADDRESS,     \/\/ face\n+            ADDRESS,     \/\/ chars\n+            JAVA_INT,    \/\/ len\n+            JAVA_INT,    \/\/ script\n+            JAVA_INT,    \/\/ offset\n+            JAVA_INT,    \/\/ limit\n+            JAVA_INT,    \/\/ baseIndex\n+            JAVA_FLOAT,  \/\/ startX\n+            JAVA_FLOAT,  \/\/ startY\n+            JAVA_INT,    \/\/ flags,\n+            JAVA_INT,    \/\/ slot,\n+            ADDRESS,     \/\/ ptr to harfbuzz font_funcs object.\n+            ADDRESS);    \/\/ store_results_fn\n+\n+        Optional<MemorySegment> shape_sym = SYM_LOOKUP.find(\"jdk_hb_shape\");\n+        @SuppressWarnings(\"restricted\")\n+        MethodHandle tmp4 = LINKER.downcallHandle(shape_sym.get(), shapeDesc);\n+        jdk_hb_shape_handle = tmp4;\n+\n+        Arena garena = Arena.global(); \/\/ creating stubs that exist until VM exit.\n+        FunctionDescriptor get_var_glyph_fd = getFunctionDescriptor(JAVA_INT,  \/\/ return type\n+              ADDRESS, ADDRESS, JAVA_INT, JAVA_INT, ADDRESS, ADDRESS); \/\/ arg types\n+        MethodHandle get_var_glyph_mh =\n+            getMethodHandle(\"get_variation_glyph\", get_var_glyph_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp5 = LINKER.upcallStub(get_var_glyph_mh, get_var_glyph_fd, garena);\n+        get_var_glyph_stub = tmp5;\n+\n+        FunctionDescriptor get_nominal_glyph_fd = getFunctionDescriptor(JAVA_INT, \/\/ return type\n+                   ADDRESS, ADDRESS, JAVA_INT, ADDRESS, ADDRESS); \/\/ arg types\n+        MethodHandle get_nominal_glyph_mh =\n+            getMethodHandle(\"get_nominal_glyph\", get_nominal_glyph_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp6 = LINKER.upcallStub(get_nominal_glyph_mh, get_nominal_glyph_fd, garena);\n+        get_nominal_glyph_stub = tmp6;\n+\n+        FunctionDescriptor get_h_adv_fd = getFunctionDescriptor(JAVA_INT,  \/\/ return type\n+                   ADDRESS, ADDRESS, JAVA_INT, ADDRESS); \/\/ arg types\n+        MethodHandle get_h_adv_mh =\n+            getMethodHandle(\"get_glyph_h_advance\", get_h_adv_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp7 = LINKER.upcallStub(get_h_adv_mh, get_h_adv_fd, garena);\n+        get_h_advance_stub = tmp7;\n+\n+        FunctionDescriptor get_v_adv_fd = getFunctionDescriptor(JAVA_INT,  \/\/ return type\n+                   ADDRESS, ADDRESS, JAVA_INT, ADDRESS); \/\/ arg types\n+        MethodHandle get_v_adv_mh =\n+            getMethodHandle(\"get_glyph_v_advance\", get_v_adv_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp8 = LINKER.upcallStub(get_v_adv_mh, get_v_adv_fd, garena);\n+        get_v_advance_stub = tmp8;\n+\n+        FunctionDescriptor get_contour_pt_fd = getFunctionDescriptor(JAVA_INT,  \/\/ return type\n+            ADDRESS, ADDRESS, JAVA_INT, JAVA_INT, ADDRESS, ADDRESS, ADDRESS); \/\/ arg types\n+        MethodHandle get_contour_pt_mh =\n+            getMethodHandle(\"get_glyph_contour_point\", get_contour_pt_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp9 = LINKER.upcallStub(get_contour_pt_mh, get_contour_pt_fd, garena);\n+        get_contour_pt_stub = tmp9;\n+\n+       \/* Having now created the font upcall stubs, we can call down to create\n+        * the native harfbuzz object holding these.\n+        *\/\n+        FunctionDescriptor createFontFuncsDescriptor = FunctionDescriptor.of(\n+            ADDRESS,     \/\/ hb_font_funcs* return type\n+            ADDRESS,     \/\/ glyph_fn upcall stub\n+            ADDRESS,     \/\/ variation_fn upcall stub\n+            ADDRESS,     \/\/ h_advance_fn upcall stub\n+            ADDRESS,     \/\/ v_advance_fn upcall stub\n+            ADDRESS);     \/\/ contour_pt_fn upcall stub\n+        Optional<MemorySegment> create_font_funcs_symbol = SYM_LOOKUP.find(\"HBCreateFontFuncs\");\n+        @SuppressWarnings(\"restricted\")\n+        MethodHandle create_font_funcs_handle =\n+            LINKER.downcallHandle(create_font_funcs_symbol.get(), createFontFuncsDescriptor);\n+\n+        MemorySegment s = null;\n+        try {\n+            s = (MemorySegment)create_font_funcs_handle.invokeExact(\n+                get_nominal_glyph_stub,\n+                get_var_glyph_stub,\n+                get_h_advance_stub,\n+                get_v_advance_stub,\n+                get_contour_pt_stub);\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        hb_jdk_font_funcs_struct = s;\n+\n+        FunctionDescriptor store_layout_fd =\n+           FunctionDescriptor.ofVoid(\n+                   JAVA_INT,               \/\/ slot\n+                   JAVA_INT,               \/\/ baseIndex\n+                   JAVA_INT,               \/\/ offset\n+                   JAVA_FLOAT,             \/\/ startX\n+                   JAVA_FLOAT,             \/\/ startX\n+                   JAVA_FLOAT,             \/\/ devScale\n+                   JAVA_INT,               \/\/ charCount\n+                   JAVA_INT,               \/\/ glyphCount\n+                   ADDRESS,                \/\/ glyphInfo\n+                   ADDRESS);               \/\/ glyphPos\n+        MethodHandle store_layout_mh =\n+            getMethodHandle(\"store_layout_results\", store_layout_fd);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment tmp10 = LINKER.upcallStub(store_layout_mh, store_layout_fd, garena);\n+        store_layout_results_stub = tmp10;\n+\n+        x_offsetHandle = getVarHandle(PositionLayout, \"x_offset\");\n+        y_offsetHandle = getVarHandle(PositionLayout, \"y_offset\");\n+        x_advanceHandle = getVarHandle(PositionLayout, \"x_advance\");\n+        y_advanceHandle = getVarHandle(PositionLayout, \"y_advance\");\n+        codePointHandle = getVarHandle(GlyphInfoLayout, \"codepoint\");\n+        clusterHandle = getVarHandle(GlyphInfoLayout, \"cluster\");\n+    }\n+\n+\n+    \/*\n+     * This is expensive but it is done just once per font.\n+     * The unbound stub could be cached but the savings would\n+     * be very low in the only case it is used.\n+     *\/\n+    @SuppressWarnings(\"restricted\")\n+    private static MemorySegment getBoundUpcallStub\n+         (Arena arena, Class<?> clazz, Object bindArg, String mName,\n+          MemoryLayout retType, MemoryLayout... argTypes) {\n+\n+       try {\n+            FunctionDescriptor nativeDescriptor =\n+               (retType == null) ?\n+                   FunctionDescriptor.ofVoid(argTypes) :\n+                   FunctionDescriptor.of(retType, argTypes);\n+           MethodType mType = nativeDescriptor.toMethodType();\n+           mType = mType.insertParameterTypes(0, clazz);\n+           MethodHandle mh = MH_LOOKUP.findStatic(HBShaper.class, mName, mType);\n+           MethodHandle bound_handle = mh.bindTo(bindArg);\n+           return LINKER.upcallStub(bound_handle, nativeDescriptor, arena);\n+       } catch (IllegalAccessException | NoSuchMethodException e) {\n+          return null;\n+       }\n+   }\n+\n+    private static int get_nominal_glyph(\n+        MemorySegment font_ptr,   \/* Not used *\/\n+        MemorySegment font_data,  \/* Not used *\/\n+        int unicode,\n+        MemorySegment glyph,      \/* pointer to location to store glyphID *\/\n+        MemorySegment user_data   \/* Not used *\/\n+    ) {\n+\n+        Font2D font2D = scopedVars.get().font();\n+        int glyphID = font2D.charToGlyph(unicode);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment glyphIDPtr = glyph.reinterpret(4);\n+        glyphIDPtr.setAtIndex(JAVA_INT, 0, glyphID);\n+        return (glyphID != 0) ? 1 : 0;\n+    }\n+\n+    private static int get_variation_glyph(\n+        MemorySegment font_ptr,   \/* Not used *\/\n+        MemorySegment font_data,  \/* Not used *\/\n+        int unicode,\n+        int variation_selector,\n+        MemorySegment glyph,      \/* pointer to location to store glyphID *\/\n+        MemorySegment user_data   \/* Not used *\/\n+    ) {\n+        Font2D font2D = scopedVars.get().font();\n+        int glyphID = font2D.charToVariationGlyph(unicode, variation_selector);\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment glyphIDPtr = glyph.reinterpret(4);\n+        glyphIDPtr.setAtIndex(JAVA_INT, 0, glyphID);\n+        return (glyphID != 0) ? 1 : 0;\n+    }\n+\n+    private static final float HBFloatToFixedScale = ((float)(1 << 16));\n+    private static final int HBFloatToFixed(float f) {\n+        return ((int)((f) * HBFloatToFixedScale));\n+    }\n+\n+    private static int get_glyph_h_advance(\n+        MemorySegment font_ptr,   \/* Not used *\/\n+        MemorySegment font_data,  \/* Not used *\/\n+        int glyph,\n+        MemorySegment user_data  \/* Not used *\/\n+    ) {\n+        FontStrike strike = scopedVars.get().fontStrike();\n+        Point2D.Float pt = strike.getGlyphMetrics(glyph);\n+        return (pt != null) ? HBFloatToFixed(pt.x) : 0;\n+    }\n+\n+    private static int get_glyph_v_advance(\n+        MemorySegment font_ptr,   \/* Not used *\/\n+        MemorySegment font_data,  \/* Not used *\/\n+        int glyph,\n+        MemorySegment user_data  \/* Not used *\/\n+    ) {\n+\n+        FontStrike strike = scopedVars.get().fontStrike();\n+        Point2D.Float pt = strike.getGlyphMetrics(glyph);\n+        return (pt != null) ? HBFloatToFixed(pt.y) : 0;\n+    }\n+\n+    \/*\n+     * This class exists to make the code that uses it less verbose\n+     *\/\n+    private static class IntPtr {\n+        MemorySegment seg;\n+        IntPtr(MemorySegment seg) {\n+        }\n+\n+        void set(int i) {\n+            seg.setAtIndex(JAVA_INT, 0, i);\n+        }\n+    }\n+\n+    private static int get_glyph_contour_point(\n+        MemorySegment font_ptr,   \/* Not used *\/\n+        MemorySegment font_data,  \/* Not used *\/\n+        int glyph,\n+        int point_index,\n+        MemorySegment x_ptr,     \/* ptr to return x *\/\n+        MemorySegment y_ptr,     \/* ptr to return y *\/\n+        MemorySegment user_data  \/* Not used *\/\n+    ) {\n+        IntPtr x = new IntPtr(x_ptr);\n+        IntPtr y = new IntPtr(y_ptr);\n+\n+        if ((glyph & 0xfffe) == 0xfffe) {\n+            x.set(0);\n+            y.set(0);\n+            return 1;\n+        }\n+\n+        FontStrike strike = scopedVars.get().fontStrike();\n+        Point2D.Float pt = ((PhysicalStrike)strike).getGlyphPoint(glyph, point_index);\n+        x.set(HBFloatToFixed(pt.x));\n+        y.set(HBFloatToFixed(pt.y));\n+\n+       return 1;\n+    }\n+\n+    record ScopedVars (\n+        Font2D font,\n+        FontStrike fontStrike,\n+        GVData gvData,\n+        Point2D.Float point) {}\n+\n+    static final ScopedValue<ScopedVars> scopedVars = ScopedValue.newInstance();\n+\n+    static void shape(\n+        Font2D font2D,\n+        FontStrike fontStrike,\n+        float ptSize,\n+        float[] mat,\n+        MemorySegment hbface,\n+        char[] text,\n+        GVData gvData,\n+        int script,\n+        int offset,\n+        int limit,\n+        int baseIndex,\n+        Point2D.Float startPt,\n+        int flags,\n+        int slot) {\n+\n+        \/*\n+         * ScopedValue is needed so that call backs into Java during\n+         * shaping can locate the correct instances of these to query or update.\n+         * The alternative of creating bound method handles is far too slow.\n+         *\/\n+        ScopedVars vars = new ScopedVars(font2D, fontStrike, gvData, startPt);\n+        ScopedValue.where(scopedVars, vars)\n+                   .run(() -> {\n+\n+            try (Arena arena = Arena.ofConfined()) {\n+\n+                float startX = (float)startPt.getX();\n+                float startY = (float)startPt.getY();\n+\n+                MemorySegment matrix = arena.allocateFrom(JAVA_FLOAT, mat);\n+                MemorySegment chars = arena.allocateFrom(JAVA_CHAR, text);\n+\n+                \/*int ret =*\/ jdk_hb_shape_handle.invokeExact(\n+                     ptSize, matrix, hbface, chars, text.length,\n+                     script, offset, limit,\n+                     baseIndex, startX, startY, flags, slot,\n+                     hb_jdk_font_funcs_struct,\n+                     store_layout_results_stub);\n+            } catch (Throwable t) {\n+            }\n+        });\n+    }\n+\n+    private static int getFontTableData(Font2D font2D,\n+                                int tag,\n+                                MemorySegment data_ptr_out) {\n+\n+        \/*\n+         * On return, the data_out_ptr will point to memory allocated by native malloc,\n+         * so it will be freed by the caller using native free - when it is\n+         * done with it.\n+         *\/\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment data_ptr = data_ptr_out.reinterpret(ADDRESS.byteSize());\n+        if (tag == 0) {\n+            data_ptr.setAtIndex(ADDRESS, 0, NULL);\n+            return 0;\n+        }\n+        byte[] data = font2D.getTableBytes(tag);\n+        if (data == null) {\n+            data_ptr.setAtIndex(ADDRESS, 0, NULL);\n+            return 0;\n+        }\n+        int len = data.length;\n+        MemorySegment zero_len = NULL;\n+        try {\n+            zero_len = (MemorySegment)malloc_handle.invokeExact((long)len);\n+        } catch (Throwable t) {\n+        }\n+        if (zero_len.equals(NULL)) {\n+            data_ptr.setAtIndex(ADDRESS, 0, NULL);\n+            return 0;\n+        }\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment mem = zero_len.reinterpret(len);\n+        MemorySegment.copy(data, 0, mem, JAVA_BYTE, 0, len);\n+        data_ptr.setAtIndex(ADDRESS, 0, mem);\n+        return len;\n+    }\n+\n+    \/* WeakHashMap is used so that we do not retain temporary fonts\n+     *\n+     * The value is a class that implements the 2D Disposer, so\n+     * that the native resources for temp. fonts can be freed.\n+     *\n+     * Installed fonts should never be cleared from the map as\n+     * they are permanently referenced.\n+     *\/\n+    private static final WeakHashMap<Font2D, FaceRef>\n+       faceMap = new WeakHashMap<>();\n+\n+    static MemorySegment getFace(Font2D font2D) {\n+        FaceRef ref;\n+        synchronized (faceMap) {\n+            ref = faceMap.computeIfAbsent(font2D, FaceRef::new);\n+        }\n+        return ref.getFace();\n+    }\n+\n+    private static class FaceRef implements DisposerRecord {\n+        private Font2D font2D;\n+        private MemorySegment face;\n+        \/\/ get_table_data_fn uses an Arena managed by GC,\n+        \/\/ so we need to keep a reference to it here until\n+        \/\/ this FaceRef is collected.\n+        private MemorySegment get_table_data_fn;\n+\n+        private FaceRef(Font2D font) {\n+            this.font2D = font;\n+        }\n+\n+        private synchronized MemorySegment getFace() {\n+            if (face == null) {\n+                createFace();\n+                if (face != null) {\n+                    Disposer.addObjectRecord(font2D, this);\n+                }\n+                font2D = null;\n+            }\n+            return face;\n+        }\n+\n+        private void createFace() {\n+            try {\n+                get_table_data_fn = getBoundUpcallStub(Arena.ofAuto(),\n+                        Font2D.class,\n+                        font2D,                      \/\/ bind arg\n+                        \"getFontTableData\",          \/\/ method name\n+                        JAVA_INT,                   \/\/ return type\n+                        JAVA_INT, ADDRESS); \/\/ arg types\n+                if (get_table_data_fn == null) {\n+                    return;\n+                }\n+                face = (MemorySegment)create_face_handle.invokeExact(get_table_data_fn);\n+            } catch (Throwable t) {\n+            }\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            try {\n+                dispose_face_handle.invokeExact(face);\n+            } catch (Throwable t) {\n+            }\n+        }\n+    }\n+\n+\n+    \/* Upcall to receive results of layout *\/\n+    private static void store_layout_results(\n+        int slot,\n+        int baseIndex,\n+        int offset,\n+        float startX,\n+        float startY,\n+        float devScale,\n+        int charCount,\n+        int glyphCount,\n+        MemorySegment \/* hb_glyph_info_t* *\/ glyphInfo,\n+        MemorySegment \/* hb_glyph_position_t* *\/ glyphPos\n+        ) {\n+\n+        GVData gvdata = scopedVars.get().gvData();\n+        Point2D.Float startPt = scopedVars.get().point();\n+        float x=0, y=0;\n+        float advX, advY;\n+        float scale = 1.0f \/ HBFloatToFixedScale \/ devScale;\n+\n+        int initialCount = gvdata._count;\n+\n+        int maxGlyphs = (charCount > glyphCount) ? charCount : glyphCount;\n+        int maxStore = maxGlyphs + initialCount;\n+        boolean needToGrow = (maxStore > gvdata._glyphs.length) ||\n+                             ((maxStore * 2 + 2) > gvdata._positions.length);\n+        if (needToGrow) {\n+            gvdata.grow(maxStore-initialCount);\n+        }\n+\n+        int glyphPosLen = glyphCount * 2 + 2;\n+        long posSize = glyphPosLen * PositionLayout.byteSize();\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment glyphPosArr = glyphPos.reinterpret(posSize);\n+\n+        long glyphInfoSize = glyphCount * GlyphInfoLayout.byteSize();\n+        @SuppressWarnings(\"restricted\")\n+        MemorySegment glyphInfoArr = glyphInfo.reinterpret(glyphInfoSize);\n+\n+         for (int i=0; i<glyphCount; i++) {\n+             int storei = i + initialCount;\n+             int cluster = (int)clusterHandle.get(glyphInfoArr, (long)i) - offset;\n+             gvdata._indices[storei] = baseIndex + cluster;\n+             int codePoint = (int)codePointHandle.get(glyphInfoArr, (long)i);\n+             gvdata._glyphs[storei] = (slot | codePoint);\n+             int x_offset = (int)x_offsetHandle.get(glyphPosArr, (long)i);\n+             int y_offset = (int)y_offsetHandle.get(glyphPosArr, (long)i);\n+             gvdata._positions[(storei*2)]   = startX + x + (x_offset * scale);\n+             gvdata._positions[(storei*2)+1] = startY + y - (y_offset * scale);\n+             int x_advance = (int)x_advanceHandle.get(glyphPosArr, (long)i);\n+             int y_advance = (int)y_advanceHandle.get(glyphPosArr, (long)i);\n+             x += x_advance * scale;\n+             y += y_advance * scale;\n+        }\n+        int storeadv = initialCount + glyphCount;\n+        gvdata._count = storeadv;\n+        \/\/ The final slot in the positions array is important\n+        \/\/ because when the GlyphVector is created from this\n+        \/\/ data it determines the overall advance of the glyphvector\n+        \/\/ and this is used in positioning the next glyphvector\n+        \/\/ during rendering where text is broken into runs.\n+        \/\/ We also need to report it back into \"pt\", so layout can\n+        \/\/ pass it back down for any next run.\n+        advX = startX + x;\n+        advY = startY + y;\n+        gvdata._positions[(storeadv*2)] = advX;\n+        gvdata._positions[(storeadv*2)+1] = advY;\n+        startPt.x = advX;\n+        startPt.y = advY;\n+        startPt.x = advX;\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/HBShaper.java","additions":660,"deletions":0,"binary":false,"changes":660,"status":"added"},{"patch":"@@ -39,0 +39,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -165,0 +167,10 @@\n+    static boolean useFFM = true;\n+    static {\n+        @SuppressWarnings(\"removal\")\n+        String prop = AccessController.doPrivileged(\n+            (PrivilegedAction<String>) () ->\n+               System.getProperty(\"sun.font.layout.ffm\", \"true\"));\n+        useFFM = \"true\".equals(prop);\n+\n+    }\n+\n@@ -168,0 +180,1 @@\n+\n@@ -170,3 +183,12 @@\n-        long pFace = getFacePtr(font);\n-        if (pFace != 0) {\n-            shape(font, strike, ptSize, mat, pFace,\n+        if (useFFM) {\n+            java.lang.foreign.MemorySegment face = HBShaper.getFace(font);\n+            if (face != null) {\n+                HBShaper.shape(font, strike, ptSize, mat, face,\n+                        tr.text, data, key.script(),\n+                        tr.start, tr.limit, baseIndex, pt,\n+                        typo_flags, gmask);\n+            }\n+        } else {\n+            long pFace = getFacePtr(font);\n+            if (pFace != 0) {\n+                shape(font, strike, ptSize, mat, pFace,\n@@ -176,0 +198,1 @@\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunLayoutEngine.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include \"hb.h\"\n+#include \"hb-jdk-p.h\"\n+#include \"hb-ot.h\"\n+#include \"scriptMapping.h\"\n+\n+static float euclidianDistance(float a, float b)\n+{\n+    float root;\n+    if (a < 0) {\n+        a = -a;\n+    }\n+\n+    if (b < 0) {\n+        b = -b;\n+    }\n+\n+    if (a == 0) {\n+        return b;\n+    }\n+\n+    if (b == 0) {\n+        return a;\n+    }\n+\n+    \/* Do an initial approximation, in root *\/\n+    root = a > b ? a + (b \/ 2) : b + (a \/ 2);\n+\n+    \/* An unrolled Newton-Raphson iteration sequence *\/\n+    root = (root + (a * (a \/ root)) + (b * (b \/ root)) + 1) \/ 2;\n+    root = (root + (a * (a \/ root)) + (b * (b \/ root)) + 1) \/ 2;\n+    root = (root + (a * (a \/ root)) + (b * (b \/ root)) + 1) \/ 2;\n+\n+    return root;\n+}\n+\n+#define TYPO_KERN 0x00000001\n+#define TYPO_LIGA 0x00000002\n+#define TYPO_RTL  0x80000000\n+\n+JDKEXPORT int jdk_hb_shape(\n+     float ptSize,\n+     float *matrix,\n+     void* pFace,\n+     unsigned short *chars,\n+     int len,\n+     int script,\n+     int offset,\n+     int limit,\n+     int baseIndex,\n+     float startX,\n+     float startY,\n+     int flags,\n+     int slot,\n+     hb_font_funcs_t* font_funcs,\n+     store_layoutdata_func_t store_layout_results_fn\n+    ) {\n+\n+     hb_buffer_t *buffer;\n+     hb_face_t* hbface;\n+     hb_font_t* hbfont;\n+     int glyphCount;\n+     hb_glyph_info_t *glyphInfo;\n+     hb_glyph_position_t *glyphPos;\n+     hb_direction_t direction = HB_DIRECTION_LTR;\n+     hb_feature_t *features = NULL;\n+     int featureCount = 0;\n+     char* kern = (flags & TYPO_KERN) ? \"kern\" : \"-kern\";\n+     char* liga = (flags & TYPO_LIGA) ? \"liga\" : \"-liga\";\n+     int ret;\n+     unsigned int buflen;\n+\n+     float devScale = 1.0f;\n+     if (getenv(\"HB_NODEVTX\") != NULL) {\n+         float xPtSize = euclidianDistance(matrix[0], matrix[1]);\n+         float yPtSize = euclidianDistance(matrix[2], matrix[3]);\n+         devScale = xPtSize \/ ptSize;\n+     }\n+\n+     hbface = (hb_face_t*)pFace;\n+     hbfont = jdk_font_create_hbp(hbface,\n+                                  ptSize, devScale, NULL,\n+                                  font_funcs);\n+\n+     buffer = hb_buffer_create();\n+     hb_buffer_set_script(buffer, getHBScriptCode(script));\n+     hb_buffer_set_language(buffer,\n+                            hb_ot_tag_to_language(HB_OT_TAG_DEFAULT_LANGUAGE));\n+     if ((flags & TYPO_RTL) != 0) {\n+         direction = HB_DIRECTION_RTL;\n+     }\n+     hb_buffer_set_direction(buffer, direction);\n+     hb_buffer_set_cluster_level(buffer,\n+                                 HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);\n+\n+     int charCount = limit - offset;\n+     hb_buffer_add_utf16(buffer, chars, len, offset, charCount);\n+\n+     features = calloc(2, sizeof(hb_feature_t));\n+     if (features) {\n+         hb_feature_from_string(kern, -1, &features[featureCount++]);\n+         hb_feature_from_string(liga, -1, &features[featureCount++]);\n+     }\n+\n+     hb_shape_full(hbfont, buffer, features, featureCount, 0);\n+     glyphCount = hb_buffer_get_length(buffer);\n+     glyphInfo = hb_buffer_get_glyph_infos(buffer, 0);\n+     glyphPos = hb_buffer_get_glyph_positions(buffer, &buflen);\n+\n+     ret = (*store_layout_results_fn)\n+               (slot, baseIndex, offset, startX, startY, devScale,\n+                charCount, glyphCount, glyphInfo, glyphPos);\n+\n+     hb_buffer_destroy (buffer);\n+     hb_font_destroy(hbfont);\n+     if (features != NULL) free(features);\n+     return ret;\n+}\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/HBShaper_Panama.c","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"hb.h\"\n+#include \"hb-jdk-p.h\"\n+#include <stdlib.h>\n+\n+#if defined(__GNUC__) &&  __GNUC__ >= 4\n+#define HB_UNUSED       __attribute__((unused))\n+#else\n+#define HB_UNUSED\n+#endif\n+\n+static hb_bool_t\n+hb_jdk_get_glyph_h_origin (hb_font_t *font HB_UNUSED,\n+                          void *font_data HB_UNUSED,\n+                          hb_codepoint_t glyph HB_UNUSED,\n+                          hb_position_t *x HB_UNUSED,\n+                          hb_position_t *y HB_UNUSED,\n+                          void *user_data HB_UNUSED)\n+{\n+  \/* We always work in the horizontal coordinates. *\/\n+  return true;\n+}\n+\n+static hb_bool_t\n+hb_jdk_get_glyph_v_origin (hb_font_t *font HB_UNUSED,\n+                          void *font_data,\n+                          hb_codepoint_t glyph,\n+                          hb_position_t *x,\n+                          hb_position_t *y,\n+                          void *user_data HB_UNUSED)\n+{\n+  return false;\n+}\n+\n+static hb_position_t\n+hb_jdk_get_glyph_h_kerning (hb_font_t *font,\n+                           void *font_data,\n+                           hb_codepoint_t lejdk_glyph,\n+                           hb_codepoint_t right_glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  \/* Not implemented. This seems to be in the HB API\n+   * as a way to fall back to Freetype's kerning support\n+   * which could be based on some on-the fly glyph analysis.\n+   * But more likely it reads the kern table. That is easy\n+   * enough code to add if we find a need to fall back\n+   * to that instead of using gpos. It seems like if\n+   * there is a gpos table at all, the practice is to\n+   * use that and ignore kern, no matter that gpos does\n+   * not implement the kern feature.\n+   *\/\n+  return 0;\n+}\n+\n+static hb_position_t\n+hb_jdk_get_glyph_v_kerning (hb_font_t *font HB_UNUSED,\n+                           void *font_data HB_UNUSED,\n+                           hb_codepoint_t top_glyph HB_UNUSED,\n+                           hb_codepoint_t bottom_glyph HB_UNUSED,\n+                           void *user_data HB_UNUSED)\n+{\n+  \/* OpenType doesn't have vertical-kerning other than GPOS. *\/\n+  return 0;\n+}\n+\n+static hb_bool_t\n+hb_jdk_get_glyph_extents (hb_font_t *font HB_UNUSED,\n+                         void *font_data,\n+                         hb_codepoint_t glyph,\n+                         hb_glyph_extents_t *extents,\n+                         void *user_data HB_UNUSED)\n+{\n+  \/* TODO *\/\n+  return false;\n+}\n+\n+static hb_bool_t\n+hb_jdk_get_glyph_name (hb_font_t *font HB_UNUSED,\n+                      void *font_data,\n+                      hb_codepoint_t glyph,\n+                      char *name, unsigned int size,\n+                      void *user_data HB_UNUSED)\n+{\n+  return false;\n+}\n+\n+static hb_bool_t\n+hb_jdk_get_glyph_from_name (hb_font_t *font HB_UNUSED,\n+                           void *font_data,\n+                           const char *name, int len,\n+                           hb_codepoint_t *glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  return false;\n+}\n+\n+extern \"C\" {\n+\/*\n+ * This is called exactly once, from Java code, and the result is\n+ * used by all downcalls to do shaping(), installing the functions\n+ * on the hb_font.\n+ * The parameters are all FFM upcall stubs.\n+ * I was surprised we can cache these native pointers to upcall\n+ * stubs on the native side, but it seems to be fine using the global Arena.\n+ * These stubs don't need to be bound to a particular font or strike\n+ * since they use Scoped Locals to access the data they need to operate on.\n+ * This is how we can cache them.\n+ * Also caching the hb_font_funcs_t on the Java side means we can\n+ * marshall fewer args to the calls to shape().\n+ *\/\n+JDKEXPORT hb_font_funcs_t *\n+HBCreateFontFuncs(hb_font_get_nominal_glyph_func_t nominal_fn,\n+                  hb_font_get_variation_glyph_func_t variation_fn,\n+                  hb_font_get_glyph_h_advance_func_t h_advance_fn,\n+                  hb_font_get_glyph_v_advance_func_t v_advance_fn,\n+                  hb_font_get_glyph_contour_point_func_t contour_pt_fn)\n+{\n+    hb_font_funcs_t *ff = hb_font_funcs_create();\n+\n+    hb_font_funcs_set_nominal_glyph_func(ff, nominal_fn, NULL, NULL);\n+    hb_font_funcs_set_variation_glyph_func(ff, variation_fn, NULL, NULL);\n+    hb_font_funcs_set_glyph_h_advance_func(ff, h_advance_fn, NULL, NULL);\n+    hb_font_funcs_set_glyph_v_advance_func(ff, v_advance_fn, NULL, NULL);\n+    hb_font_funcs_set_glyph_contour_point_func(ff, contour_pt_fn, NULL, NULL);\n+\n+    \/* These are all simple default implementations *\/\n+    hb_font_funcs_set_glyph_h_origin_func(ff,\n+                    hb_jdk_get_glyph_h_origin, NULL, NULL);\n+    hb_font_funcs_set_glyph_v_origin_func(ff,\n+                    hb_jdk_get_glyph_v_origin, NULL, NULL);\n+    hb_font_funcs_set_glyph_h_kerning_func(ff,\n+                    hb_jdk_get_glyph_h_kerning, NULL, NULL);\n+    hb_font_funcs_set_glyph_v_kerning_func(ff,\n+                    hb_jdk_get_glyph_v_kerning, NULL, NULL);\n+    hb_font_funcs_set_glyph_extents_func(ff,\n+                    hb_jdk_get_glyph_extents, NULL, NULL);\n+    hb_font_funcs_set_glyph_name_func(ff,\n+                    hb_jdk_get_glyph_name, NULL, NULL);\n+    hb_font_funcs_set_glyph_from_name_func(ff,\n+                    hb_jdk_get_glyph_from_name, NULL, NULL);\n+    hb_font_funcs_make_immutable(ff); \/\/ done setting functions.\n+\n+  return ff;\n+}\n+\n+} \/* extern \"C\" *\/\n+\n+static void _do_nothing(void) {\n+}\n+\n+typedef int (*GetTableDataFn) (int tag, char **dataPtr);\n+\n+static hb_blob_t *\n+reference_table(hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data) {\n+\n+  \/\/ HB_TAG_NONE is 0 and is used to get the whole font file.\n+  \/\/ It is not expected to be needed for JDK.\n+  if (tag == 0) {\n+      return NULL;\n+  }\n+\n+  \/\/ This has to be a method handle bound to the right Font2D\n+  GetTableDataFn getDataFn = (GetTableDataFn)user_data;\n+\n+  char *tableData = NULL;\n+  int length = (*getDataFn)(tag, &tableData);\n+  if ((length == 0) || (tableData == NULL)) {\n+      return NULL;\n+  }\n+\n+  \/* Can't call this non-exported hb fn from Java so can't have\n+   * a Java version of the reference_table fn, which is why it\n+   * has as a parameter the upcall stub that will be used.\n+   * And the memory is freed by 'free' so the upcall needs to\n+   * call back down to malloc to allocate it.\n+   *\/\n+  return hb_blob_create((const char *)tableData, length,\n+                         HB_MEMORY_MODE_WRITABLE,\n+                         tableData, free);\n+}\n+\n+extern \"C\" {\n+\n+JDKEXPORT hb_face_t* HBCreateFace(GetTableDataFn *get_data_upcall_fn) {\n+\n+    hb_face_t *face = hb_face_create_for_tables(reference_table, get_data_upcall_fn, NULL);\n+    return face;\n+}\n+\n+JDKEXPORT void HBDisposeFace(hb_face_t* face) {\n+    hb_face_destroy(face);\n+}\n+\n+\/\/ Use 16.16 for better precision than 26.6\n+#define HBFloatToFixedScale ((float)(1 << 16))\n+#define HBFloatToFixed(f) ((unsigned int)((f) * HBFloatToFixedScale))\n+\n+hb_font_t* jdk_font_create_hbp(\n+               hb_face_t* face,\n+               float ptSize, float devScale,\n+               hb_destroy_func_t destroy,\n+               hb_font_funcs_t *font_funcs) {\n+\n+    hb_font_t *font;\n+\n+    font = hb_font_create(face);\n+    hb_font_set_funcs(font,\n+                      font_funcs,\n+                      NULL,\n+                      (hb_destroy_func_t)_do_nothing);\n+    hb_font_set_scale(font,\n+                      HBFloatToFixed(ptSize*devScale),\n+                      HBFloatToFixed(ptSize*devScale));\n+  return font;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/hb-jdk-font-p.cc","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef HB_JDK_H\n+#define HB_JDK_H\n+\n+#ifndef JDKEXPORT\n+  #ifdef WIN32\n+    #define JDKEXPORT __declspec(dllexport)\n+  #else\n+    #if (defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4) && (__GNUC_MINOR__ > 2))) || __has_attribute(visibility)\n+      #ifdef ARM\n+        #define JDKEXPORT  __attribute__((externally_visible,visibility(\"default\")))\n+      #else\n+        #define JDKEXPORT  __attribute__((visibility(\"default\")))\n+      #endif\n+    #else\n+      #define JDKEXPORT\n+    #endif\n+  #endif\n+#endif\n+\n+#include \"hb.h\"\n+\n+# ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+hb_font_t* jdk_font_create_hbp(\n+               hb_face_t* face,\n+               float ptSize, float devScale,\n+               hb_destroy_func_t destroy,\n+               hb_font_funcs_t* font_funcs);\n+\n+\n+typedef int (*store_layoutdata_func_t)\n+   (int slot, int baseIndex, int offset,\n+    float startX, float startY, float devScale,\n+    int charCount, int glyphCount,\n+    hb_glyph_info_t *glyphInfo, hb_glyph_position_t *glyphPos);\n+\n+JDKEXPORT int jdk_hb_shape(\n+\n+     float ptSize,\n+     float *matrix,\n+     void* pFace,\n+     unsigned short* chars,\n+     int len,\n+     int script,\n+     int offset,\n+     int limit,\n+     int baseIndex, \/\/ used only to store results.\n+     float startX, \/\/ used only to store results.\n+     float startY, \/\/ used only to store results.\n+     int flags,\n+     int slot, \/\/ used only to store results\n+     \/\/ Provide upcall Method handles that harfbuzz needs\n+     hb_font_funcs_t* font_funcs,\n+     store_layoutdata_func_t store_layout_data_upcall\n+);\n+\n+# ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* HB_JDK_H *\/\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/hb-jdk-p.h","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+   @test\n+   @summary verify JNI and FFM harfbuzz OpenType layout implementations are equivalent.\n+*\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.awt.Font;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+\n+public class LayoutCompatTest {\n+\n+   static String jni = \"jni.txt\";\n+   static String ffm = \"ffm.txt\";\n+   static final AffineTransform tx = new AffineTransform();\n+   static final FontRenderContext frc = new FontRenderContext(tx, false, false);\n+\n+   static final String englishText =\n+       \"OpenType font layout is a critical technology for proper rendering of many of the world's natural languages.\";\n+\n+\n+    static final String arabicText =\n+       \/\/ \" يعد تخطيط خطوط OpenType تقنية مهمة للعرض الصحيح للعديد من اللغات الطبيعية في العالم.יות\";\n+    \"\\u064a\\u0639\\u062f\\u0020\\u062a\\u062e\\u0637\\u064a\\u0637\\u0020\\u062e\\u0637\\u0648\\u0637\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u062a\\u0642\\u0646\\u064a\\u0629\\u0020\\u0645\\u0647\\u0645\\u0629\\u0020\\u0644\\u0644\\u0639\\u0631\\u0636\\u0020\\u0627\\u0644\\u0635\\u062d\\u064a\\u062d\\u0020\\u0644\\u0644\\u0639\\u062f\\u064a\\u062f\\u0020\\u0645\\u0646\\u0020\\u0627\\u0644\\u0644\\u063a\\u0627\\u062a\\u0020\\u0627\\u0644\\u0637\\u0628\\u064a\\u0639\\u064a\\u0629\\u0020\\u0641\\u064a\\u0020\\u0627\\u0644\\u0639\\u0627\\u0644\\u0645\\u002e\\u05d9\\u05d5\\u05ea\";\n+\n+    static final String hebrewText =\n+    \/\/  פריסת גופן OpenType היא טכנולוגיה קריטית לעיבוד נכון של רבות מהשפות הטבעיות בעולם.\n+    \"\\u05e4\\u05e8\\u05d9\\u05e1\\u05ea\\u0020\\u05d2\\u05d5\\u05e4\\u05df\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u05d4\\u05d9\\u05d0\\u0020\\u05d8\\u05db\\u05e0\\u05d5\\u05dc\\u05d5\\u05d2\\u05d9\\u05d4\\u0020\\u05e7\\u05e8\\u05d9\\u05d8\\u05d9\\u05ea\\u0020\\u05dc\\u05e2\\u05d9\\u05d1\\u05d5\\u05d3\\u0020\\u05e0\\u05db\\u05d5\\u05df\\u0020\\u05e9\\u05dc\\u0020\\u05e8\\u05d1\\u05d5\\u05ea\\u0020\\u05de\\u05d4\\u05e9\\u05e4\\u05d5\\u05ea\\u0020\\u05d4\\u05d8\\u05d1\\u05e2\\u05d9\\u05d5\\u05ea\\u0020\\u05d1\\u05e2\\u05d5\\u05dc\\u05dd\\u002e\";\n+\n+    static final String thaiText =\n+    \/\/ เค้าโครงแบบอักษร OpenType เป็นเทคโนโลยีที่สำคัญสำหรับการแสดงผลภาษาธรรมชาติจำนวนมากของโลกอย่างเหมาะสม\n+    \"\\u0e40\\u0e04\\u0e49\\u0e32\\u0e42\\u0e04\\u0e23\\u0e07\\u0e41\\u0e1a\\u0e1a\\u0e2d\\u0e31\\u0e01\\u0e29\\u0e23\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u0e40\\u0e1b\\u0e47\\u0e19\\u0e40\\u0e17\\u0e04\\u0e42\\u0e19\\u0e42\\u0e25\\u0e22\\u0e35\\u0e17\\u0e35\\u0e48\\u0e2a\\u0e33\\u0e04\\u0e31\\u0e0d\\u0e2a\\u0e33\\u0e2b\\u0e23\\u0e31\\u0e1a\\u0e01\\u0e32\\u0e23\\u0e41\\u0e2a\\u0e14\\u0e07\\u0e1c\\u0e25\\u0e20\\u0e32\\u0e29\\u0e32\\u0e18\\u0e23\\u0e23\\u0e21\\u0e0a\\u0e32\\u0e15\\u0e34\\u0e08\\u0e33\\u0e19\\u0e27\\u0e19\\u0e21\\u0e32\\u0e01\\u0e02\\u0e2d\\u0e07\\u0e42\\u0e25\\u0e01\\u0e2d\\u0e22\\u0e48\\u0e32\\u0e07\\u0e40\\u0e2b\\u0e21\\u0e32\\u0e30\\u0e2a\\u0e21\";\n+\n+    static final String khmerText =\n+    \/\/ ប្លង់ពុម្ពអក្សរ OpenType គឺជាបច្ចេកវិជ្ជាសំខាន់មួយសម្រាប់ការបង្ហាញត្រឹមត្រូវនៃភាសាធម្មជាតិជាច្រើនរបស់ពិភពលោក។\n+    \"\\u1794\\u17d2\\u179b\\u1784\\u17cb\\u1796\\u17bb\\u1798\\u17d2\\u1796\\u17a2\\u1780\\u17d2\\u179f\\u179a\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u1782\\u17ba\\u1787\\u17b6\\u1794\\u1785\\u17d2\\u1785\\u17c1\\u1780\\u179c\\u17b7\\u1787\\u17d2\\u1787\\u17b6\\u179f\\u17c6\\u1781\\u17b6\\u1793\\u17cb\\u1798\\u17bd\\u1799\\u179f\\u1798\\u17d2\\u179a\\u17b6\\u1794\\u17cb\\u1780\\u17b6\\u179a\\u1794\\u1784\\u17d2\\u17a0\\u17b6\\u1789\\u178f\\u17d2\\u179a\\u17b9\\u1798\\u178f\\u17d2\\u179a\\u17bc\\u179c\\u1793\\u17c3\\u1797\\u17b6\\u179f\\u17b6\\u1792\\u1798\\u17d2\\u1798\\u1787\\u17b6\\u178f\\u17b7\\u1787\\u17b6\\u1785\\u17d2\\u179a\\u17be\\u1793\\u179a\\u1794\\u179f\\u17cb\\u1796\\u17b7\\u1797\\u1796\\u179b\\u17c4\\u1780\\u17d4\";\n+\n+    static final String laoText =\n+    \/\/ ຮູບແບບຕົວອັກສອນ OpenType ເປັນເທັກໂນໂລຍີສຳຄັນສຳລັບການສະແດງຜົນຂອງພາສາທຳມະຊາດຫຼາຍພາສາຂອງໂລກ.\n+    \"\\u0eae\\u0eb9\\u0e9a\\u0ec1\\u0e9a\\u0e9a\\u0e95\\u0ebb\\u0ea7\\u0ead\\u0eb1\\u0e81\\u0eaa\\u0ead\\u0e99\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u0ec0\\u0e9b\\u0eb1\\u0e99\\u0ec0\\u0e97\\u0eb1\\u0e81\\u0ec2\\u0e99\\u0ec2\\u0ea5\\u0e8d\\u0eb5\\u0eaa\\u0eb3\\u0e84\\u0eb1\\u0e99\\u0eaa\\u0eb3\\u0ea5\\u0eb1\\u0e9a\\u0e81\\u0eb2\\u0e99\\u0eaa\\u0eb0\\u0ec1\\u0e94\\u0e87\\u0e9c\\u0ebb\\u0e99\\u0e82\\u0ead\\u0e87\\u0e9e\\u0eb2\\u0eaa\\u0eb2\\u0e97\\u0eb3\\u0ea1\\u0eb0\\u0e8a\\u0eb2\\u0e94\\u0eab\\u0ebc\\u0eb2\\u0e8d\\u0e9e\\u0eb2\\u0eaa\\u0eb2\\u0e82\\u0ead\\u0e87\\u0ec2\\u0ea5\\u0e81\\u002e\";\n+\n+    static final String hindiText =\n+    \/\/ ओपनटाइप फ़ॉन्ट लेआउट दुनिया की कई प्राकृतिक भाषाओं के उचित प्रतिपादन के लिए एक महत्वपूर्ण तकनीक है।\n+    \"\\u0913\\u092a\\u0928\\u091f\\u093e\\u0907\\u092a\\u0020\\u092b\\u093c\\u0949\\u0928\\u094d\\u091f\\u0020\\u0932\\u0947\\u0906\\u0909\\u091f\\u0020\\u0926\\u0941\\u0928\\u093f\\u092f\\u093e\\u0020\\u0915\\u0940\\u0020\\u0915\\u0908\\u0020\\u092a\\u094d\\u0930\\u093e\\u0915\\u0943\\u0924\\u093f\\u0915\\u0020\\u092d\\u093e\\u0937\\u093e\\u0913\\u0902\\u0020\\u0915\\u0947\\u0020\\u0909\\u091a\\u093f\\u0924\\u0020\\u092a\\u094d\\u0930\\u0924\\u093f\\u092a\\u093e\\u0926\\u0928\\u0020\\u0915\\u0947\\u0020\\u0932\\u093f\\u090f\\u0020\\u090f\\u0915\\u0020\\u092e\\u0939\\u0924\\u094d\\u0935\\u092a\\u0942\\u0930\\u094d\\u0923\\u0020\\u0924\\u0915\\u0928\\u0940\\u0915\\u0020\\u0939\\u0948\\u0964\";\n+\n+    static final String kannadaText =\n+    \/\/ ಓಪನ್‌ಟೈಪ್ ಫಾಂಟ್ ವಿನ್ಯಾಸವು ಪ್ರಪಂಚದ ಅನೇಕ ನೈಸರ್ಗಿಕ ಭಾಷೆಗಳ ಸರಿಯಾದ ರೆಂಡರಿಂಗ್‌ಗೆ ನಿರ್ಣಾಯಕ ತಂತ್ರಜ್ಞಾನವಾಗಿದೆ.\n+    \"\\u0c93\\u0caa\\u0ca8\\u0ccd\\u200c\\u0c9f\\u0cc8\\u0caa\\u0ccd\\u0020\\u0cab\\u0cbe\\u0c82\\u0c9f\\u0ccd\\u0020\\u0cb5\\u0cbf\\u0ca8\\u0ccd\\u0caf\\u0cbe\\u0cb8\\u0cb5\\u0cc1\\u0020\\u0caa\\u0ccd\\u0cb0\\u0caa\\u0c82\\u0c9a\\u0ca6\\u0020\\u0c85\\u0ca8\\u0cc7\\u0c95\\u0020\\u0ca8\\u0cc8\\u0cb8\\u0cb0\\u0ccd\\u0c97\\u0cbf\\u0c95\\u0020\\u0cad\\u0cbe\\u0cb7\\u0cc6\\u0c97\\u0cb3\\u0020\\u0cb8\\u0cb0\\u0cbf\\u0caf\\u0cbe\\u0ca6\\u0020\\u0cb0\\u0cc6\\u0c82\\u0ca1\\u0cb0\\u0cbf\\u0c82\\u0c97\\u0ccd\\u200c\\u0c97\\u0cc6\\u0020\\u0ca8\\u0cbf\\u0cb0\\u0ccd\\u0ca3\\u0cbe\\u0caf\\u0c95\\u0020\\u0ca4\\u0c82\\u0ca4\\u0ccd\\u0cb0\\u0c9c\\u0ccd\\u0c9e\\u0cbe\\u0ca8\\u0cb5\\u0cbe\\u0c97\\u0cbf\\u0ca6\\u0cc6\\u002e\";\n+\n+    static final String tamilText =\n+    \/\/ ஓபன் டைப் எழுத்துரு அமைப்பு என்பது உலகின் பல இயற்கை மொழிகளைச் சரியாக வழங்குவதற்கான ஒரு முக்கியமான தொழில்நுட்பமாகும்.\n+    \"\\u0b93\\u0baa\\u0ba9\\u0bcd\\u0020\\u0b9f\\u0bc8\\u0baa\\u0bcd\\u0020\\u0b8e\\u0bb4\\u0bc1\\u0ba4\\u0bcd\\u0ba4\\u0bc1\\u0bb0\\u0bc1\\u0020\\u0b85\\u0bae\\u0bc8\\u0baa\\u0bcd\\u0baa\\u0bc1\\u0020\\u0b8e\\u0ba9\\u0bcd\\u0baa\\u0ba4\\u0bc1\\u0020\\u0b89\\u0bb2\\u0b95\\u0bbf\\u0ba9\\u0bcd\\u0020\\u0baa\\u0bb2\\u0020\\u0b87\\u0baf\\u0bb1\\u0bcd\\u0b95\\u0bc8\\u0020\\u0bae\\u0bca\\u0bb4\\u0bbf\\u0b95\\u0bb3\\u0bc8\\u0b9a\\u0bcd\\u0020\\u0b9a\\u0bb0\\u0bbf\\u0baf\\u0bbe\\u0b95\\u0020\\u0bb5\\u0bb4\\u0b99\\u0bcd\\u0b95\\u0bc1\\u0bb5\\u0ba4\\u0bb1\\u0bcd\\u0b95\\u0bbe\\u0ba9\\u0020\\u0b92\\u0bb0\\u0bc1\\u0020\\u0bae\\u0bc1\\u0b95\\u0bcd\\u0b95\\u0bbf\\u0baf\\u0bae\\u0bbe\\u0ba9\\u0020\\u0ba4\\u0bca\\u0bb4\\u0bbf\\u0bb2\\u0bcd\\u0ba8\\u0bc1\\u0b9f\\u0bcd\\u0baa\\u0bae\\u0bbe\\u0b95\\u0bc1\\u0bae\\u0bcd\\u002e\";\n+\n+    static final String malayalamText =\n+    \/\/ ഓപ്പൺടൈപ്പ് ഫോണ്ട് ലേഔട്ട് ലോകത്തിലെ പല സ്വാഭാവിക ഭാഷകളുടെയും ശരിയായ റെൻഡറിംഗിനുള്ള ഒരു നിർണായക സാങ്കേതികവിദ്യയാണ്.\n+    \"\\u0d13\\u0d2a\\u0d4d\\u0d2a\\u0d7a\\u0d1f\\u0d48\\u0d2a\\u0d4d\\u0d2a\\u0d4d\\u0020\\u0d2b\\u0d4b\\u0d23\\u0d4d\\u0d1f\\u0d4d\\u0020\\u0d32\\u0d47\\u0d14\\u0d1f\\u0d4d\\u0d1f\\u0d4d\\u0020\\u0d32\\u0d4b\\u0d15\\u0d24\\u0d4d\\u0d24\\u0d3f\\u0d32\\u0d46\\u0020\\u0d2a\\u0d32\\u0020\\u0d38\\u0d4d\\u0d35\\u0d3e\\u0d2d\\u0d3e\\u0d35\\u0d3f\\u0d15\\u0020\\u0d2d\\u0d3e\\u0d37\\u0d15\\u0d33\\u0d41\\u0d1f\\u0d46\\u0d2f\\u0d41\\u0d02\\u0020\\u0d36\\u0d30\\u0d3f\\u0d2f\\u0d3e\\u0d2f\\u0020\\u0d31\\u0d46\\u0d7b\\u0d21\\u0d31\\u0d3f\\u0d02\\u0d17\\u0d3f\\u0d28\\u0d41\\u0d33\\u0d4d\\u0d33\\u0020\\u0d12\\u0d30\\u0d41\\u0020\\u0d28\\u0d3f\\u0d7c\\u0d23\\u0d3e\\u0d2f\\u0d15\\u0020\\u0d38\\u0d3e\\u0d19\\u0d4d\\u0d15\\u0d47\\u0d24\\u0d3f\\u0d15\\u0d35\\u0d3f\\u0d26\\u0d4d\\u0d2f\\u0d2f\\u0d3e\\u0d23\\u0d4d\\u002e\";\n+\n+    static final String gujaratiText =\n+    \/\/ ຮູບແບບຕົວອັກສອນ OpenType ເປັນເທັກໂນໂລຍີສຳຄັນສຳລັບການສະແດງຜົນຂອງພາສາທຳມະຊາດຫຼາຍພາສາຂອງໂລກ.\n+    \"\\u0eae\\u0eb9\\u0e9a\\u0ec1\\u0e9a\\u0e9a\\u0e95\\u0ebb\\u0ea7\\u0ead\\u0eb1\\u0e81\\u0eaa\\u0ead\\u0e99\\u0020\\u004f\\u0070\\u0065\\u006e\\u0054\\u0079\\u0070\\u0065\\u0020\\u0ec0\\u0e9b\\u0eb1\\u0e99\\u0ec0\\u0e97\\u0eb1\\u0e81\\u0ec2\\u0e99\\u0ec2\\u0ea5\\u0e8d\\u0eb5\\u0eaa\\u0eb3\\u0e84\\u0eb1\\u0e99\\u0eaa\\u0eb3\\u0ea5\\u0eb1\\u0e9a\\u0e81\\u0eb2\\u0e99\\u0eaa\\u0eb0\\u0ec1\\u0e94\\u0e87\\u0e9c\\u0ebb\\u0e99\\u0e82\\u0ead\\u0e87\\u0e9e\\u0eb2\\u0eaa\\u0eb2\\u0e97\\u0eb3\\u0ea1\\u0eb0\\u0e8a\\u0eb2\\u0e94\\u0eab\\u0ebc\\u0eb2\\u0e8d\\u0e9e\\u0eb2\\u0eaa\\u0eb2\\u0e82\\u0ead\\u0e87\\u0ec2\\u0ea5\\u0e81\\u002e\";\n+\n+    static final String teluguText =\n+    \/\/ ఓపెన్‌టైప్ ఫాంట్ లేఅవుట్ అనేది ప్రపంచంలోని అనేక సహజ భాషలను సరిగ్గా రెండరింగ్ చేయడానికి కీలకమైన సాంకేతికత.\n+    \"\\u0c13\\u0c2a\\u0c46\\u0c28\\u0c4d\\u200c\\u0c1f\\u0c48\\u0c2a\\u0c4d\\u0020\\u0c2b\\u0c3e\\u0c02\\u0c1f\\u0c4d\\u0020\\u0c32\\u0c47\\u0c05\\u0c35\\u0c41\\u0c1f\\u0c4d\\u0020\\u0c05\\u0c28\\u0c47\\u0c26\\u0c3f\\u0020\\u0c2a\\u0c4d\\u0c30\\u0c2a\\u0c02\\u0c1a\\u0c02\\u0c32\\u0c4b\\u0c28\\u0c3f\\u0020\\u0c05\\u0c28\\u0c47\\u0c15\\u0020\\u0c38\\u0c39\\u0c1c\\u0020\\u0c2d\\u0c3e\\u0c37\\u0c32\\u0c28\\u0c41\\u0020\\u0c38\\u0c30\\u0c3f\\u0c17\\u0c4d\\u0c17\\u0c3e\\u0020\\u0c30\\u0c46\\u0c02\\u0c21\\u0c30\\u0c3f\\u0c02\\u0c17\\u0c4d\\u0020\\u0c1a\\u0c47\\u0c2f\\u0c21\\u0c3e\\u0c28\\u0c3f\\u0c15\\u0c3f\\u0020\\u0c15\\u0c40\\u0c32\\u0c15\\u0c2e\\u0c48\\u0c28\\u0020\\u0c38\\u0c3e\\u0c02\\u0c15\\u0c47\\u0c24\\u0c3f\\u0c15\\u0c24\\u002e\";\n+\n+\n+   static Font[] allFonts;\n+\n+   public static void main(String args[]) throws Exception {\n+       if (args.length > 0) {\n+           writeLayouts(args[0]);\n+           return;\n+       }\n+       String classesDir = System.getProperty(\"test.classes\");\n+       if (classesDir != null) {\n+           String sep = System.getProperty(\"file.separator\");\n+           String fileDir = classesDir + sep;\n+           jni = fileDir + jni;\n+           ffm = fileDir + ffm;\n+       }\n+       forkAndWait(jni, false);\n+       forkAndWait(ffm, true);\n+       compareLayouts(jni, ffm);\n+    }\n+\n+    static void compareLayouts(String file1, String file2) throws Exception {\n+         FileInputStream i1 = new FileInputStream(file1);\n+         FileInputStream i2 = new FileInputStream(file2);\n+         byte[] ba1 = i1.readAllBytes();\n+         byte[] ba2 = i2.readAllBytes();\n+         for (int i = 0; i < ba1.length; i++) {\n+            if (ba1[i] != ba2[i]) {\n+                throw new RuntimeException(\"files differ byte offset=\" + i);\n+            }\n+         }\n+    }\n+\n+    static boolean isLogicalFont(Font f) {\n+        String s = f.getFamily().toLowerCase();\n+        if (s.startsWith(\".\") || \/\/ skip Apple System fonts - not supposed to be used\n+            s.equals(\"serif\") ||\n+            s.equals(\"sansserif\") ||\n+            s.equals(\"dialog\") ||\n+            s.equals(\"dialoginput\") ||\n+            s.equals(\"monospaced\")) {\n+           return true;\n+       }\n+       return false;\n+    }\n+\n+    static Font findFont(char c) {\n+        for (Font f : allFonts) {\n+           if (isLogicalFont(f)) continue;\n+           if (f.canDisplay(c)) { \/\/ not for supplementary chars\n+               return f.deriveFont(24.0f);\n+           }\n+        }\n+        return new Font(Font.DIALOG, 24, Font.PLAIN);\n+    }\n+\n+    static void writeGV(PrintStream out, String title, String text) {\n+        char[] chars = text.toCharArray();\n+        Font font = findFont(chars[0]);\n+        GlyphVector gv = font.layoutGlyphVector(frc, chars, 0, chars.length, 0);\n+        int ng = gv.getNumGlyphs();\n+        int[] codes = gv.getGlyphCodes(0, ng, null);\n+        float[] positions = gv.getGlyphPositions(0, ng, null);\n+        out.println(title);\n+        out.println(font);\n+        out.println(\"num glyphs = \" + ng);\n+        out.print(\"Codes=\");\n+        for (int code : codes) out.print(\" \"+code); out.println();\n+        out.print(\"Positions=\");\n+        for (float pos : positions) out.print(\" \"+pos); out.println();\n+        out.println();\n+    }\n+\n+    static void writeLayouts(String fileName) throws Exception {\n+         allFonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();\n+         PrintStream out = new PrintStream(fileName);\n+         out.println(\"java.home=\"+javaHome);\n+         out.println(\"javaExe=\"+javaExe);\n+         out.println(\"classpath=\"+classpath);\n+         writeGV(out,\"English:\", englishText);\n+         writeGV(out,\"Arabic:\", arabicText);\n+         writeGV(out,\"Hebrew:\", hebrewText);\n+         writeGV(out,\"Thai:\", thaiText);\n+         writeGV(out,\"Khmer:\", khmerText);\n+         writeGV(out,\"Lao:\", laoText);\n+         writeGV(out,\"Hindi:\", hindiText);\n+         writeGV(out,\"Kannada:\", kannadaText);\n+         writeGV(out,\"Tamil:\", tamilText);\n+         writeGV(out,\"Malayalam:\", malayalamText);\n+         writeGV(out,\"Gujarati:\", gujaratiText);\n+         writeGV(out,\"Telugu:\", teluguText);\n+         out.close();\n+    }\n+\n+    static final String javaHome = (System.getProperty(\"test.jdk\") != null)\n+            ? System.getProperty(\"test.jdk\")\n+            : System.getProperty(\"java.home\");\n+\n+    static final String javaExe =\n+            javaHome + File.separator + \"bin\" + File.separator + \"java\";\n+\n+    static final String classpath =\n+            System.getProperty(\"java.class.path\");\n+\n+    static void forkAndWait(String fileName, boolean val) throws Exception {\n+        List<String> args =\n+            Arrays.asList(javaExe,\n+               \"-cp\", classpath,\n+               \"-Dsun.font.layout.ffm=\"+Boolean.toString(val),\n+               \"-Dsun.font.layout.logtime=true\",\n+               \"LayoutCompatTest\",\n+               fileName);\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        Process p = pb.start();\n+        p.waitFor();\n+        p.destroy();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/GlyphVector\/LayoutCompatTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}