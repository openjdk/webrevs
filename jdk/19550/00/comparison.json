{"files":[{"patch":"@@ -186,1 +186,0 @@\n-  unsigned &get_insn() { return insn; }\n@@ -3001,9 +3000,0 @@\n-  void sshll2(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb, int shift) {\n-    assert(Tb == T16B || Tb == T8H || Tb == T4S, \"invalid arrangement\");\n-    _xshll(\/* is_unsigned *\/ false, Vd, Ta, Vn, Tb, shift);\n-  }\n-\n-  void sxtl(FloatRegister Vd, SIMD_Arrangement Ta, FloatRegister Vn,  SIMD_Arrangement Tb) {\n-    sshll(Vd, Ta, Vn, Tb, 0);\n-  }\n-\n@@ -3047,9 +3037,0 @@\n-  void uqxtn(FloatRegister Vd, SIMD_Arrangement Tb, FloatRegister Vn, SIMD_Arrangement Ta) {\n-    starti;\n-    int size_b = (int)Tb >> 1;\n-    int size_a = (int)Ta >> 1;\n-    assert(size_b < 3 && size_b == size_a - 1, \"Invalid size specifier\");\n-    f(0, 31), f(Tb & 1, 30), f(0b101110, 29, 24), f(size_b, 23, 22);\n-    f(0b100001010010, 21, 10), rf(Vn, 5), rf(Vd, 0);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -230,1 +230,0 @@\n-  inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }\n@@ -246,10 +245,0 @@\n-  inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n-    bfmw(Rd, Rn, lsb, (lsb + width - 1));\n-  }\n-  inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n-    bfm(Rd, Rn, lsb , (lsb + width - 1));\n-  }\n-\n-  inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n-    sbfmw(Rd, Rn, ((32 - lsb) & 31), (width - 1));\n-  }\n@@ -260,3 +249,0 @@\n-  inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n-    sbfmw(Rd, Rn, lsb, (lsb + width - 1));\n-  }\n@@ -426,3 +412,0 @@\n-  inline void umnegl(Register Rd, Register Rn, Register Rm) {\n-    umsubl(Rd, Rn, Rm, zr);\n-  }\n@@ -574,5 +557,0 @@\n-  inline void set_fpsr(Register reg)\n-  {\n-    msr(0b011, 0b0100, 0b0100, 0b001, reg);\n-  }\n-\n@@ -597,18 +575,0 @@\n-  \/\/ DCZID_EL0: op1 == 011\n-  \/\/            CRn == 0000\n-  \/\/            CRm == 0000\n-  \/\/            op2 == 111\n-  inline void get_dczid_el0(Register reg)\n-  {\n-    mrs(0b011, 0b0000, 0b0000, 0b111, reg);\n-  }\n-\n-  \/\/ CTR_EL0:   op1 == 011\n-  \/\/            CRn == 0000\n-  \/\/            CRm == 0000\n-  \/\/            op2 == 001\n-  inline void get_ctr_el0(Register reg)\n-  {\n-    mrs(0b011, 0b0000, 0b0000, 0b001, reg);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -151,3 +151,0 @@\n-  static int cpu_model2()                     { return _model2; }\n-  static int cpu_variant()                    { return _variant; }\n-  static int cpu_revision()                   { return _revision; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -320,5 +320,0 @@\n-  void mlas(Register rd, Register rm, Register rs, Register rn, AsmCondition cond = al) {\n-    emit_int32(cond << 28 | 1 << 21 | 1 << 20 | rd->encoding() << 16 |\n-              rn->encoding() << 12 | rs->encoding() << 8 | 0x9 << 4 | rm->encoding());\n-  }\n-\n@@ -587,5 +582,0 @@\n-  void udf(int imm_16) {\n-    assert((imm_16 >> 16) == 0, \"encoding constraint\");\n-    emit_int32(0xe7f000f0 | (imm_16 & 0xfff0) << 8 | (imm_16 & 0xf));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  inline void check_no_cached_stack_top(Register tmp) {}\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -443,9 +443,0 @@\n-  \/\/ Create a walkable frame to help tracking down who called this code.\n-  \/\/ Returns the frame size in words.\n-  int should_not_call_this() {\n-    raw_push(FP, LR);\n-    should_not_reach_here();\n-    flush();\n-    return 2; \/\/ frame_size_in_words (FP+LR)\n-  }\n-\n@@ -759,4 +750,0 @@\n-  void arith_shift_right(Register dst, Register src, int shift) {\n-    mov(dst, AsmOperand(src, asr, shift));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -68,8 +68,0 @@\n-  static int decode_rotated_imm12(int encoding) {\n-    int base = encoding & 0xff;\n-    int right_rotation = (encoding & 0xf00) >> 7;\n-    int left_rotation = 32 - right_rotation;\n-    int val = (base >> right_rotation) | (base << left_rotation);\n-    return val;\n-  }\n-\n@@ -109,1 +101,0 @@\n-  bool is_blx()            const { return (encoding() & 0x0ffffff0) == 0x012fff30; }\n@@ -113,3 +104,0 @@\n-  bool is_ldr_call()       const {\n-    return (is_add_lr() && next_raw()->is_ldr_pc());\n-  }\n@@ -119,1 +107,0 @@\n-  bool is_far_branch()     const { return is_movw() || is_ldr_literal(); }\n@@ -148,1 +135,0 @@\n-  bool is_movt()           const { return (encoding() & 0x0ff00000) == 0x03400000; }\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-  static bool prefer_moves_over_load_literal() { return supports_movw(); }\n-\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1031,5 +1031,0 @@\n-  static void assert_signed_word_disp_range(intptr_t x, int nbits) {\n-    assert((x & 3) == 0, \"not word aligned\");\n-    assert_signed_range(x, nbits + 2);\n-  }\n-\n@@ -1110,14 +1105,0 @@\n-  \/\/ For extended opcodes (prefixed instructions) introduced with Power 10\n-  static long inv_r_eo(   int x)  { return  inv_opp_u_field(x, 11, 11); }\n-  static long inv_type(   int x)  { return  inv_opp_u_field(x,  7,  6); }\n-  static long inv_st_x0(  int x)  { return  inv_opp_u_field(x,  8,  8); }\n-  static long inv_st_x1(  int x)  { return  inv_opp_u_field(x, 11,  8); }\n-\n-  \/\/  - 8LS:D\/MLS:D Formats\n-  static long inv_d0_eo( long x)  { return  inv_opp_u_field(x, 31, 14); }\n-\n-  \/\/  - 8RR:XX4\/8RR:D Formats\n-  static long inv_imm0_eo(int x)  { return  inv_opp_u_field(x, 31, 16); }\n-  static long inv_uimm_eo(int x)  { return  inv_opp_u_field(x, 31, 29); }\n-  static long inv_imm_eo( int x)  { return  inv_opp_u_field(x, 31, 24); }\n-\n@@ -1145,1 +1126,0 @@\n-  static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }\n@@ -1248,2 +1228,0 @@\n-  static long st_x0(    int        x)  { return  opp_u_field(x,              8,  8); }\n-  static long st_x1(    int        x)  { return  opp_u_field(x,             11,  8); }\n@@ -1254,2 +1232,0 @@\n-  static long s0_eo(    long       x)  { return  d0_eo(x); }\n-  static long s1_eo(    long       x)  { return  d1_eo(x); }\n@@ -1258,3 +1234,0 @@\n-  static long imm0_eo(  int        x)  { return  opp_u_field(x >> 16,       31, 16); }\n-  static long imm1_eo(  int        x)  { return  opp_u_field(x & 0xFFFF,    31, 16); }\n-  static long uimm_eo(  int        x)  { return  opp_u_field(x,             31, 29); }\n@@ -1263,8 +1236,0 @@\n-  \/\/static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }\/\/ is contained in our opcodes\n-  \/\/static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }\/\/ is contained in our opcodes\n-  \/\/static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }\/\/ is contained in our opcodes\n-  \/\/static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }\/\/ is contained in our opcodes\n-  \/\/static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }\/\/ is contained in our opcodes\n-  \/\/static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }\/\/ is contained in our opcodes\n-  \/\/static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }\/\/ is contained in our opcodes\n-\n@@ -1303,3 +1268,0 @@\n-  static inline int hi16_signed(  int x) { return (int)(int16_t)(x >> 16); }\n-  static inline int lo16_unsigned(int x) { return x & 0xffff; }\n-\n@@ -1478,3 +1440,0 @@\n-  static bool is_bxx_or_bcxx(int x) {\n-     return is_bxx(x) || is_bcxx(x);\n-  }\n@@ -1511,3 +1470,0 @@\n-  static bool is_stdx(int x) {\n-     return STDX_OPCODE == (x & STDX_OPCODE_MASK);\n-  }\n@@ -1517,6 +1473,0 @@\n-  static bool is_stwx(int x) {\n-     return STWX_OPCODE == (x & STWX_OPCODE_MASK);\n-  }\n-  static bool is_stwux(int x) {\n-     return STWUX_OPCODE == (x & STWUX_OPCODE_MASK);\n-  }\n@@ -1526,3 +1476,0 @@\n-  static bool is_stwu(int x) {\n-     return STWU_OPCODE == (x & STWU_OPCODE_MASK);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -625,87 +625,0 @@\n-\n-  \/\/ Support for void zero_words_aligned8(HeapWord* to, size_t count)\n-  \/\/\n-  \/\/ Arguments:\n-  \/\/   to:\n-  \/\/   count:\n-  \/\/\n-  \/\/ Destroys:\n-  \/\/\n-  address generate_zero_words_aligned8() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"zero_words_aligned8\");\n-\n-    \/\/ Implemented as in ClearArray.\n-    address start = __ function_entry();\n-\n-    Register base_ptr_reg   = R3_ARG1; \/\/ tohw (needs to be 8b aligned)\n-    Register cnt_dwords_reg = R4_ARG2; \/\/ count (in dwords)\n-    Register tmp1_reg       = R5_ARG3;\n-    Register tmp2_reg       = R6_ARG4;\n-    Register zero_reg       = R7_ARG5;\n-\n-    \/\/ Procedure for large arrays (uses data cache block zero instruction).\n-    Label dwloop, fast, fastloop, restloop, lastdword, done;\n-    int cl_size = VM_Version::L1_data_cache_line_size();\n-    int cl_dwords = cl_size >> 3;\n-    int cl_dwordaddr_bits = exact_log2(cl_dwords);\n-    int min_dcbz = 2; \/\/ Needs to be positive, apply dcbz only to at least min_dcbz cache lines.\n-\n-    \/\/ Clear up to 128byte boundary if long enough, dword_cnt=(16-(base>>3))%16.\n-    __ dcbtst(base_ptr_reg);                    \/\/ Indicate write access to first cache line ...\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if number of dwords is even.\n-    __ srdi_(tmp1_reg, cnt_dwords_reg, 1);      \/\/ number of double dwords\n-    __ load_const_optimized(zero_reg, 0L);      \/\/ Use as zero register.\n-\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ cnt_dwords even?\n-    __ beq(CCR0, lastdword);                    \/\/ size <= 1\n-    __ mtctr(tmp1_reg);                         \/\/ Speculatively preload counter for rest loop (>0).\n-    __ cmpdi(CCR0, cnt_dwords_reg, (min_dcbz+1)*cl_dwords-1); \/\/ Big enough to ensure >=min_dcbz cache lines are included?\n-    __ neg(tmp1_reg, base_ptr_reg);             \/\/ bit 0..58: bogus, bit 57..60: (16-(base>>3))%16, bit 61..63: 000\n-\n-    __ blt(CCR0, restloop);                     \/\/ Too small. (<31=(2*cl_dwords)-1 is sufficient, but bigger performs better.)\n-    __ rldicl_(tmp1_reg, tmp1_reg, 64-3, 64-cl_dwordaddr_bits); \/\/ Extract number of dwords to 128byte boundary=(16-(base>>3))%16.\n-\n-    __ beq(CCR0, fast);                         \/\/ already 128byte aligned\n-    __ mtctr(tmp1_reg);                         \/\/ Set ctr to hit 128byte boundary (0<ctr<cnt).\n-    __ subf(cnt_dwords_reg, tmp1_reg, cnt_dwords_reg); \/\/ rest (>0 since size>=256-8)\n-\n-    \/\/ Clear in first cache line dword-by-dword if not already 128byte aligned.\n-    __ bind(dwloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 8);\n-    __ bdnz(dwloop);\n-\n-    \/\/ clear 128byte blocks\n-    __ bind(fast);\n-    __ srdi(tmp1_reg, cnt_dwords_reg, cl_dwordaddr_bits); \/\/ loop count for 128byte loop (>0 since size>=256-8)\n-    __ andi(tmp2_reg, cnt_dwords_reg, 1);       \/\/ to check if rest even\n-\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-    __ cmpdi(CCR1, tmp2_reg, 0);                \/\/ rest even?\n-    __ rldicl_(tmp1_reg, cnt_dwords_reg, 63, 65-cl_dwordaddr_bits); \/\/ rest in double dwords\n-\n-    __ bind(fastloop);\n-      __ dcbz(base_ptr_reg);                    \/\/ Clear 128byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, cl_size);\n-    __ bdnz(fastloop);\n-\n-    \/\/__ dcbtst(base_ptr_reg);                  \/\/ Indicate write access to last cache line.\n-    __ beq(CCR0, lastdword);                    \/\/ rest<=1\n-    __ mtctr(tmp1_reg);                         \/\/ load counter\n-\n-    \/\/ Clear rest.\n-    __ bind(restloop);\n-      __ std(zero_reg, 0, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ std(zero_reg, 8, base_ptr_reg);        \/\/ Clear 8byte aligned block.\n-      __ addi(base_ptr_reg, base_ptr_reg, 16);\n-    __ bdnz(restloop);\n-\n-    __ bind(lastdword);\n-    __ beq(CCR1, done);\n-    __ std(zero_reg, 0, base_ptr_reg);\n-    __ bind(done);\n-    __ blr();                                   \/\/ return\n-\n-    return start;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -3114,1 +3114,0 @@\n-  void c_lhu(Register Rd_Rs2, Register Rs1, const int32_t uimm) {  c_lh_if<true>(Rd_Rs2, Rs1, uimm); }\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -511,8 +511,0 @@\n-  inline void sltz(Register Rd, Register Rs) {\n-    slt(Rd, Rs, x0);\n-  }\n-\n-  inline void sgtz(Register Rd, Register Rs) {\n-    slt(Rd, x0, Rs);\n-  }\n-\n@@ -1416,15 +1408,0 @@\n-  inline void vmsltu_vi(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {\n-    guarantee(imm >= 1 && imm <= 16, \"imm is invalid\");\n-    vmsleu_vi(Vd, Vs2, imm-1, vm);\n-  }\n-\n-  inline void vmsgeu_vi(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {\n-    guarantee(imm >= 1 && imm <= 16, \"imm is invalid\");\n-    vmsgtu_vi(Vd, Vs2, imm-1, vm);\n-  }\n-\n-  \/\/ Copy mask register\n-  inline void vmmv_m(VectorRegister vd, VectorRegister vs) {\n-    vmand_mm(vd, vs, vs);\n-  }\n-\n@@ -1441,4 +1418,0 @@\n-  inline void vnot_v(VectorRegister Vd, VectorRegister Vs, VectorMask vm = unmasked) {\n-    vxor_vi(Vd, Vs, -1, vm);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -404,13 +404,0 @@\n-  \/\/ Locating Floating Point register-based arguments:\n-  bool is_float_register() const { return _number < n_float_register_parameters; }\n-\n-  FloatRegister as_float_register() const {\n-    assert(is_float_register(), \"must be a register argument\");\n-    return as_FloatRegister((number() *2) + 1);\n-  }\n-\n-  FloatRegister as_double_register() const {\n-    assert(is_float_register(), \"must be a register argument\");\n-    return as_FloatRegister((number() *2));\n-  }\n-\n@@ -1537,6 +1524,0 @@\n-  \/\/ Average instruction is 4 bytes on z\/Architecture (just a guess).\n-  static unsigned int instr_avglen() { return 4; }\n-\n-  \/\/ Shortest instructions are 2 bytes on z\/Architecture.\n-  static unsigned int instr_minlen() { return 2; }\n-\n@@ -1642,1 +1623,0 @@\n-  static int64_t rsmaskt_48( int64_t d2, Register b2)             { return uimm12(d2, 20, 48)                    | regt(b2, 16, 48); }\n@@ -1650,4 +1630,0 @@\n-  static int64_t vreg_mask(VectorRegister v, int pos) {\n-    return vreg(v, pos) | v->RXB_mask(pos);\n-  }\n-\n@@ -1662,17 +1638,0 @@\n-  \/\/ Vector Element IndeX. 4-bit field which indexes the target vector element.\n-  static int64_t veix_mask(int64_t ix, int el_size, int pos) {\n-    \/\/ el_size - size of the vector element. This is a VRegElemType enum value.\n-    \/\/ ix      - vector element index.\n-    int max_ix = -1;\n-    switch (el_size) {\n-      case VRET_BYTE: max_ix = 15; break;\n-      case VRET_HW:   max_ix =  7; break;\n-      case VRET_FW:   max_ix =  3; break;\n-      case VRET_DW:   max_ix =  1; break;\n-      case VRET_QW:   max_ix =  0; break;\n-      default:        guarantee(false, \"bad vector element size %d\", el_size); break;\n-    }\n-    assert((0 <= ix) && (ix <= max_ix), \"element size out of range (0 <= %ld <= %d)\", ix, max_ix);\n-    return uimm4(ix, pos, 48);\n-  }\n-\n@@ -1702,8 +1661,0 @@\n-  \/\/ Extract 20-bit signed displacement.\n-  \/\/ Only used in disassembler_s390.cpp for temp enhancements.\n-  static int inv_simm20_xx(address iLoc) {\n-    unsigned long instr = 0;\n-    unsigned long iLen  = get_instruction(iLoc, &instr);\n-    return inv_simm20(instr);\n-  }\n-\n@@ -1789,8 +1740,0 @@\n-  static short get_imm16(address a, int instruction_number) {\n-    short imm;\n-    short *p =((short *)a) + 2 * instruction_number + 1;\n-    imm = *p;\n-    return imm;\n-  }\n-\n-\n@@ -1807,6 +1750,0 @@\n-  static void set_imm16(int* instr, int64_t s) {\n-    assert(Immediate::is_simm16(s) || Immediate::is_uimm16(s), \"to big\");\n-    short* p = ((short *)instr) + 1;\n-    *p = s;\n-  }\n-\n@@ -3126,2 +3063,0 @@\n-  static int z_brul_size() { return 6; }\n-\n@@ -3131,3 +3066,0 @@\n-  static bool is_z_algr(long x) {\n-    return (ALGR_ZOPC == (x & RRE_MASK));\n-  }\n@@ -3137,6 +3069,0 @@\n-  static bool is_z_lb(long x) {\n-    return (LB_ZOPC == (x & LB_MASK));\n-  }\n-  static bool is_z_lh(int x) {\n-    return (LH_ZOPC == (x & LH_MASK));\n-  }\n@@ -3149,3 +3075,0 @@\n-  static bool is_z_ly(long x) {\n-    return (LY_ZOPC == (x & LY_MASK));\n-  }\n@@ -3155,33 +3078,0 @@\n-  static bool is_z_llgh(long x) {\n-    return (LLGH_ZOPC == (x & LLGH_MASK));\n-  }\n-  static bool is_z_llgf(long x) {\n-    return (LLGF_ZOPC == (x & LLGF_MASK));\n-  }\n-  static bool is_z_le(int x) {\n-    return (LE_ZOPC == (x & LE_MASK));\n-  }\n-  static bool is_z_ld(int x) {\n-    return (LD_ZOPC == (x & LD_MASK));\n-  }\n-  static bool is_z_st(int x) {\n-    return (ST_ZOPC == (x & ST_MASK));\n-  }\n-  static bool is_z_stc(int x) {\n-    return (STC_ZOPC == (x & STC_MASK));\n-  }\n-  static bool is_z_stg(long x) {\n-    return (STG_ZOPC == (x & STG_MASK));\n-  }\n-  static bool is_z_sth(int x) {\n-    return (STH_ZOPC == (x & STH_MASK));\n-  }\n-  static bool is_z_ste(int x) {\n-    return (STE_ZOPC == (x & STE_MASK));\n-  }\n-  static bool is_z_std(int x) {\n-    return (STD_ZOPC == (x & STD_MASK));\n-  }\n-  static bool is_z_slag(long x) {\n-    return (SLAG_ZOPC == (x & SLAG_MASK));\n-  }\n@@ -3206,3 +3096,0 @@\n-  static bool is_z_brc(long x, int cond) {\n-    return ((unsigned int)BRC_ZOPC == (x & BRC_MASK)) && ((cond<<20) == (x & 0x00f00000U));\n-  }\n@@ -3237,17 +3124,0 @@\n-\n-  static bool is_z_lghi(unsigned long x) {\n-    return (unsigned int)LGHI_ZOPC == (x & (unsigned int)LGHI_MASK);\n-  }\n-\n-  static bool is_z_llill(unsigned long x) {\n-    return (unsigned int)LLILL_ZOPC == (x & (unsigned int)LLI_MASK);\n-  }\n-  static bool is_z_llilh(unsigned long x) {\n-    return (unsigned int)LLILH_ZOPC == (x & (unsigned int)LLI_MASK);\n-  }\n-  static bool is_z_llihl(unsigned long x) {\n-    return (unsigned int)LLIHL_ZOPC == (x & (unsigned int)LLI_MASK);\n-  }\n-  static bool is_z_llihh(unsigned long x) {\n-    return (unsigned int)LLIHH_ZOPC == (x & (unsigned int)LLI_MASK);\n-  }\n@@ -3257,16 +3127,0 @@\n-  static bool is_z_llihf(unsigned long x) {\n-    return LLIHF_ZOPC == (x & LLIF_MASK);\n-  }\n-\n-  static bool is_z_iill(unsigned long x) {\n-    return (unsigned int)IILL_ZOPC == (x & (unsigned int)II_MASK);\n-  }\n-  static bool is_z_iilh(unsigned long x) {\n-    return (unsigned int)IILH_ZOPC == (x & (unsigned int)II_MASK);\n-  }\n-  static bool is_z_iihl(unsigned long x) {\n-    return (unsigned int)IIHL_ZOPC == (x & (unsigned int)II_MASK);\n-  }\n-  static bool is_z_iihh(unsigned long x) {\n-    return (unsigned int)IIHH_ZOPC == (x & (unsigned int)II_MASK);\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":0,"deletions":146,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -62,4 +62,0 @@\n-void CodeInstaller::pd_relocate_CodeBlob(CodeBlob* cb, NativeInstruction* inst) {\n-  Unimplemented();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/jvmciCodeInstaller_s390.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -394,3 +394,0 @@\n-  static void patch_addr_pcrel(address pc, address con) {\n-    patch_target_addr_pcrel(pc, con); \/\/ Just delegate. This is only for nativeInst_s390.cpp.\n-  }\n@@ -605,2 +602,0 @@\n-  static int jump_pcrelative_size()          { return 4; }\n-  static int jump_far_pcrelative_size()      { return 6; }\n@@ -608,1 +603,0 @@\n-  static int call_pcrelative_size()          { return 4; }\n@@ -610,1 +604,0 @@\n-  static int call_far_pcrelative_size_raw()  { return 6; }     \/\/ Prepend each BRASL with a nop.\n@@ -881,3 +874,0 @@\n-  inline void asm_assert_mem4_is_zero(int64_t mem_offset, Register mem_base, const char* msg, int id) {\n-    asm_assert_mems_zero(true,  true, 4, mem_offset, mem_base, msg, id);\n-  }\n@@ -887,3 +877,0 @@\n-  inline void asm_assert_mem4_isnot_zero(int64_t mem_offset, Register mem_base, const char* msg, int id) {\n-    asm_assert_mems_zero(false, true, 4, mem_offset, mem_base, msg, id);\n-  }\n@@ -893,3 +880,0 @@\n-  inline void asm_assert_mem4_is_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {\n-    asm_assert_mems_zero(true,  false, 4, mem_offset, mem_base, msg, id);\n-  }\n@@ -899,3 +883,0 @@\n-  inline void asm_assert_mem4_isnot_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {\n-    asm_assert_mems_zero(false, false, 4, mem_offset, mem_base, msg, id);\n-  }\n@@ -961,3 +942,0 @@\n-  \/\/ Number of bytes a basic block gets larger due to the tracing code macro (worst case).\n-  \/\/ Currently, worst case is 48 bytes. 64 puts us securely on the safe side.\n-  static int basic_blck_trace_blk_size_incr() { return 64; }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -245,5 +245,0 @@\n-\n-  inline constexpr friend FloatRegister as_SingleFloatRegister(int encoding) {\n-    assert(encoding < number_of_registers, \"bad single float register encoding\");\n-    return as_FloatRegister(encoding);\n-  }\n@@ -256,4 +251,0 @@\n-\n-  inline constexpr friend FloatRegister as_DoubleFloatRegister(int encoding) {\n-    return as_FloatRegister(((encoding & 1) << 5) | (encoding & 0x1e));\n-  }\n@@ -269,5 +260,0 @@\n-\n-  inline constexpr friend FloatRegister as_QuadFloatRegister(int encoding) {\n-    assert(encoding < QuadFloatRegister::number_of_registers && ((encoding & 2) == 0), \"bad quad float register encoding\");\n-    return as_FloatRegister(((encoding & 1) << 5) | (encoding & 0x1c));\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-  \/\/ Address of the lock for atomic_compare_and_exchange.\n-  static int* atomic_memory_operation_lock_addr() { return &_atomic_memory_operation_lock; }\n-\n@@ -93,1 +90,0 @@\n-  static void set_atomic_memory_operation_lock(int value) { _atomic_memory_operation_lock = value; }\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-  static void set_has_GnrlInstrExtensions()       { _features[0] |= GnrlInstrExtFacilityMask; }\n+  static void set_has_ProcessorAssist()           { _features[0] |= ProcessorAssistMask; }\n@@ -542,1 +542,0 @@\n-  static void set_has_ProcessorAssist()           { _features[0] |= ProcessorAssistMask; }\n@@ -545,0 +544,1 @@\n+  static void set_has_ProcessorAssist()           { _features[0] |= ProcessorAssistMask; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3039,3 +3039,0 @@\n-  \/\/ Set the vector len manually\n-  void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  address immediate_address() const { return addr_at(imm_offset); }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5365,4 +5365,0 @@\n-  bool is_indefinite() const           {\n-    return _ex == -1 && _m1 == (int32_t)0xC0000000 && _m0 == 0;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -880,4 +880,0 @@\n-  void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }\n-\n-\n-\n@@ -901,2 +897,0 @@\n-  void leal32(Register dst, Address src) { leal(dst, src); }\n-\n@@ -962,1 +956,0 @@\n-  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n@@ -968,1 +961,0 @@\n-  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n@@ -972,1 +964,0 @@\n-  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n@@ -976,1 +967,0 @@\n-  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n@@ -978,1 +968,0 @@\n-  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n@@ -984,1 +973,0 @@\n-  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n@@ -986,1 +974,0 @@\n-  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n@@ -988,1 +975,0 @@\n-  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n@@ -992,31 +978,0 @@\n-  \/\/ Short versions of the above\n-  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n-  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n-  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::negative, L); }\n-  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::positive, L); }\n-  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n-  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n-  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n-  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n-  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n-  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n-  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n-  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n-  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n-  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n-  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n-  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n-  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n-  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n-  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n-  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n-  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n-  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n-  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n-  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n-  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n-  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n-  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n-  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n-  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n-  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n@@ -1772,3 +1727,0 @@\n-  void vinserti64x4_high(XMMRegister dst, XMMRegister src) {\n-    Assembler::vinserti64x4(dst, dst, src, 1);\n-  }\n@@ -1838,3 +1790,0 @@\n-  void vinserti64x4_low(XMMRegister dst, XMMRegister src) {\n-    Assembler::vinserti64x4(dst, dst, src, 0);\n-  }\n@@ -1844,3 +1793,0 @@\n-  void vextracti64x4_low(XMMRegister dst, XMMRegister src) {\n-    Assembler::vextracti64x4(dst, src, 0);\n-  }\n@@ -1875,9 +1821,0 @@\n-  void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-    \/\/ 0x00 - multiply lower 64 bits [0:63]\n-    Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);\n-  }\n-  void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-    \/\/ 0x11 - multiply upper 64 bits [64:127]\n-    Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -417,9 +417,0 @@\n-\n- private:\n-  friend NativeLoadAddress* nativeLoadAddress_at (address address) {\n-    NativeLoadAddress* test = (NativeLoadAddress*)(address - instruction_offset);\n-    #ifdef ASSERT\n-      test->verify();\n-    #endif\n-    return test;\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-  static int rbxOffset(void) { return rbx_off; }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2316,7 +2316,0 @@\n-  \/\/ aesdec using specified key+offset\n-  \/\/ can optionally specify that the shuffle mask is already in an xmmregister\n-  void aes_dec_key(XMMRegister xmmdst, XMMRegister xmmtmp, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n-    load_key(xmmtmp, key, offset, xmm_shuf_mask);\n-    __ aesdec(xmmdst, xmmtmp);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -666,1 +666,0 @@\n-  static bool supports_cpuid()        { return _features  != 0; }\n@@ -668,1 +667,0 @@\n-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }\n@@ -681,2 +679,0 @@\n-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }\n-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }\n@@ -685,1 +681,0 @@\n-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }\n@@ -695,2 +690,0 @@\n-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }\n-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }\n@@ -701,1 +694,0 @@\n-  static bool supports_avx512bwdq()   { return (supports_evex() && supports_avx512bw() && supports_avx512dq()); }\n@@ -706,3 +698,0 @@\n-  static bool supports_avx512nobw()   { return (supports_evex() && !supports_avx512bw()); }\n-  static bool supports_avx256only()   { return (supports_avx2() && !supports_evex()); }\n-  static bool supports_avxonly()      { return ((supports_avx2() || supports_avx()) && !supports_evex()); }\n@@ -723,4 +712,0 @@\n-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }\n-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }\n-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }\n-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -76,4 +76,0 @@\n-\n-  \/\/ This converts a pointer into the buffer to a file offset.  It only works\n-  \/\/ when the pointer is valid (i.e. just obtained from getline()).\n-  long getoff(const char* s) { return _bufoff + (long)(s - _buf); }\n","filename":"src\/hotspot\/share\/adlc\/filebuff.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-  Form * current2(){ return _cur2; };\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,3 +205,0 @@\n-  virtual bool has_stack_version() {\n-    return _stack_or_reg;\n-  }\n@@ -712,3 +709,0 @@\n-  bool  use_leaf_operand()        { return _inst_num != -1; };\n-  bool  generate_an_instruction() { return _inst_num == -1; }\n-\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2287,6 +2287,0 @@\n-  void emit_reloc_type(const char* type) {\n-    fprintf(_fp, \"%s\", type)\n-      ;\n-  }\n-\n-\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-  int loc_sect() const { return CodeBuffer::locator_sect(loc()); }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -635,1 +635,0 @@\n-  bool insts_contains2(address pc) const { return _insts.contains2(pc); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-  void check_spill_index   (int spill_index)   const { assert(spill_index   >= 0, \"bad index\"); }\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -335,5 +335,0 @@\n-  void restore_inline_cleanup_info() {\n-    _block = inline_cleanup_block();\n-    _last  = inline_cleanup_return_prev();\n-    _state = inline_cleanup_state();\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -523,2 +523,0 @@\n-  virtual StoreField*       as_StoreField()      { return nullptr; }\n-  virtual AccessArray*      as_AccessArray()     { return nullptr; }\n@@ -528,1 +526,0 @@\n-  virtual StoreIndexed*     as_StoreIndexed()    { return nullptr; }\n@@ -543,2 +540,0 @@\n-  virtual NewTypeArray*     as_NewTypeArray()    { return nullptr; }\n-  virtual NewObjectArray*   as_NewObjectArray()  { return nullptr; }\n@@ -546,5 +541,0 @@\n-  virtual TypeCheck*        as_TypeCheck()       { return nullptr; }\n-  virtual CheckCast*        as_CheckCast()       { return nullptr; }\n-  virtual InstanceOf*       as_InstanceOf()      { return nullptr; }\n-  virtual TypeCast*         as_TypeCast()        { return nullptr; }\n-  virtual AccessMonitor*    as_AccessMonitor()   { return nullptr; }\n@@ -554,1 +544,0 @@\n-  virtual BlockBegin*       as_BlockBegin()      { return nullptr; }\n@@ -558,2 +547,0 @@\n-  virtual TableSwitch*      as_TableSwitch()     { return nullptr; }\n-  virtual LookupSwitch*     as_LookupSwitch()    { return nullptr; }\n@@ -565,1 +552,0 @@\n-  virtual UnsafeOp*         as_UnsafeOp()        { return nullptr; }\n@@ -569,4 +555,0 @@\n-#ifdef ASSERT\n-  virtual Assert*           as_Assert()          { return nullptr; }\n-#endif\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -368,6 +368,1 @@\n-  \/\/ checks whether types are same\n-  bool is_same_type(LIR_Opr opr) const     {\n-    assert(type_field() != unknown_type &&\n-           opr->type_field() != unknown_type, \"shouldn't see unknown_type\");\n-    return type_field() == opr->type_field();\n-  }\n+\n@@ -2403,1 +2398,0 @@\n-  void set_index_at(int i, int value)    { _index_and_count.at_put((i << 1),     value); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  void set_current_block(BlockBegin* b) { _current_block = b; }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-  bool is_int_kind() const                       { return tag() == intTag || tag() == longTag; }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -314,4 +314,0 @@\n-  static intx get_buffer_to_requested_delta() {\n-    return current()->buffer_to_requested_delta();\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -614,7 +614,0 @@\n-\n-  static char* copy_attr(u1* value, size_t len) {\n-    char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n-    strncpy(buf, (char*)value, len);\n-    buf[len] = 0;\n-    return buf;\n-  }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -138,3 +138,0 @@\n-  void assert_is_not_heap_region() const {\n-    assert(!_is_heap_region, \"must not be heap region\");\n-  }\n@@ -430,4 +427,0 @@\n-  static void set_current_info(FileMapInfo* info) {\n-    CDS_ONLY(_current_info = info;)\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-  static void disable_optimized_module_handling() { _use_optimized_module_handling = false; }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -108,2 +108,0 @@\n-  bool  does_jsr() const            { return (_flags & DoesJsr) != 0; }\n-  bool  does_ret() const            { return (_flags & DoesRet) != 0; }\n@@ -116,5 +114,0 @@\n-  void  set_does_jsr()              { _flags |= DoesJsr; }\n-  void  clear_does_jsr()            { _flags &= ~DoesJsr; }\n-  void  set_does_ret()              { _flags |= DoesRet; }\n-  void  clear_does_ret()            { _flags &= ~DoesRet; }\n-  void  set_is_ret_target()         { _flags |= RetTarget; }\n","filename":"src\/hotspot\/share\/ci\/ciMethodBlocks.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-  virtual bool is_native_entry_point()const { return false; }\n@@ -169,4 +168,0 @@\n-  ciMethodType* as_method_type() {\n-    assert(is_method_type(), \"bad cast\");\n-    return (ciMethodType*)this;\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -977,5 +977,0 @@\n-  void remove_annotation(ID id) {\n-    assert((int)id >= 0 && (int)id < (int)_annotation_LIMIT, \"oob\");\n-    _annotations_present &= (int)~nth_bit((int)id);\n-  }\n-\n@@ -991,1 +986,0 @@\n-  void set_stable(bool stable) { set_annotation(_field_Stable); }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,4 +102,0 @@\n-  static bool is_boot_classpath(int classpath_index) {\n-    return classpath_index < _app_class_paths_start_index;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -339,6 +339,0 @@\n-  void add_sibling(LoaderTreeNode* info) {\n-    assert(info->_next == nullptr, \"must be\");\n-    info->_next = _next;\n-    _next = info;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,5 +249,0 @@\n-  int get_alignment() {\n-    assert(_alignment != -1, \"Uninitialized\");\n-    return _alignment;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1117,1 +1117,0 @@\n-  static int method_type_offset_in_bytes()           { return _method_type_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-  void               set_superThreadQ(SeenThread* SeenThread) { _superThreadQ = SeenThread; }\n@@ -106,1 +105,0 @@\n-  void               set_loadInstanceThreadQ(SeenThread* SeenThread) { _loadInstanceThreadQ = SeenThread; }\n@@ -109,1 +107,0 @@\n-  void               set_defineThreadQ(SeenThread* SeenThread) { _defineThreadQ = SeenThread; }\n@@ -132,4 +129,0 @@\n-  bool define_class_in_progress() {\n-    return (_defineThreadQ != nullptr);\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-  inline void set_verifier(ClassVerifier* v)  { _verifier = v; }\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,14 +63,0 @@\n-  static verification_type_info* create_object_at(address addr, u2 cp_idx) {\n-    verification_type_info* vti = (verification_type_info*)addr;\n-    vti->set_tag(ITEM_Object);\n-    vti->set_cpool_index(cp_idx);\n-    return vti;\n-  }\n-\n-  static verification_type_info* create_uninit_at(address addr, u2 bci) {\n-    verification_type_info* vti = (verification_type_info*)addr;\n-    vti->set_tag(ITEM_Uninitialized);\n-    vti->set_bci(bci);\n-    return vti;\n-  }\n-\n@@ -924,4 +910,0 @@\n-\n-  void set_number_of_entries(u2 num) {\n-    Bytes::put_Java_u2(number_of_entries_addr(), num);\n-  }\n@@ -961,3 +943,0 @@\n-  void set_attribute_length(u4 len) {\n-    Bytes::put_Java_u4(attribute_length_addr(), len);\n-  }\n","filename":"src\/hotspot\/share\/classfile\/stackMapTableFormat.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -154,2 +154,0 @@\n-  static VerificationType category2_2nd_check()\n-    { return VerificationType(Category2_2ndQuery); }\n@@ -175,1 +173,0 @@\n-  bool is_boolean() const   { return (_u._data == Boolean); }\n@@ -202,4 +199,0 @@\n-  bool is_reference_check() const { return _u._data == ReferenceQuery; }\n-  bool is_category1_check() const { return _u._data == Category1Query; }\n-  bool is_category2_check() const { return _u._data == Category2Query; }\n-  bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,4 +266,0 @@\n-  void set_sig_verif_types(GrowableArray<VerificationType>* sig_verif_types) {\n-    _sig_verif_types = sig_verif_types;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,3 +344,0 @@\n-  void initialize_iteration(T* nm) {\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  jchar    read_char()                 { return (jchar   ) read_int();  }\n@@ -101,2 +100,0 @@\n-  void write_char(jchar value)         { write_int(value); }\n-  void write_short(jshort value)       { write_signed_int(value);  }\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-  void                        set_is_scalar_replaced(bool scd) { _is_scalar_replaced = scd; }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -326,3 +326,0 @@\n-  static void check_ctxk_concrete(ciKlass* ctxk) {\n-    assert(is_concrete_klass(ctxk->as_instance_klass()), \"must be concrete\");\n-  }\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-  bool make_entrant() { Unimplemented(); return false; }\n@@ -596,2 +595,0 @@\n-  \/\/ Containment\n-  bool consts_contains         (address addr) const { return consts_begin       () <= addr && addr < consts_end       (); }\n@@ -604,5 +601,0 @@\n-  bool metadata_contains       (Metadata** addr) const { return metadata_begin  () <= addr && addr < metadata_end     (); }\n-  bool scopes_data_contains    (address addr) const { return scopes_data_begin  () <= addr && addr < scopes_data_end  (); }\n-  bool scopes_pcs_contains     (PcDesc* addr) const { return scopes_pcs_begin   () <= addr && addr < scopes_pcs_end   (); }\n-  bool handler_table_contains  (address addr) const { return handler_table_begin() <= addr && addr < handler_table_end(); }\n-  bool nul_chk_table_contains  (address addr) const { return nul_chk_table_begin() <= addr && addr < nul_chk_table_end(); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -194,10 +194,0 @@\n-  \/\/ Return true if single stack based \"register\" where the slot alignment matches input alignment\n-  bool is_adjacent_on_stack(int alignment) const {\n-    return (_first->is_stack() && (_first->value() + 1 == _second->value()) && ((_first->value() & (alignment-1)) == 0));\n-  }\n-\n-  \/\/ Return true if single stack based \"register\" where the slot alignment matches input alignment\n-  bool is_adjacent_aligned_on_stack(int alignment) const {\n-    return (_first->is_stack() && (_first->value() + 1 == _second->value()) && ((_first->value() & (alignment-1)) == 0));\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -175,1 +175,0 @@\n-  bool is_itable_stub()                          { return !_is_vtable_stub; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -418,1 +418,0 @@\n-  static int get_total_native_compile_count() {     return _total_native_compile_count; }\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-  static void set_high_only_quick_internal() { _mode = Mode::HIGH_ONLY_QUICK_INTERNAL; }\n@@ -86,1 +85,0 @@\n-  static void set_high_only()                { _mode = Mode::HIGH_ONLY;                }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,6 +174,0 @@\n-  void init_matcher(Symbol* class_name, Mode class_mode,\n-                    Symbol* method_name, Mode method_mode,\n-                    Symbol* signature) {\n-    MethodMatcher::init(class_name, class_mode, method_name, method_mode, signature);\n-  }\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,8 +169,0 @@\n-protected:\n-  \/\/ Returns the address of the element the given address maps to\n-  T* address_mapped_to(HeapWord* address) {\n-    idx_t biased_index = ((uintptr_t)address) >> this->shift_by();\n-    this->verify_biased_index_inclusive_end(biased_index);\n-    return biased_base() + biased_index;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-  double wall_time() const {\n-    return _mixed_start_time - _concurrent_start_end_time;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentStartToMixedTimeTracker.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-  PreservedMarksSet*       preserved_mark_set() { return &_preserved_marks_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-\n-  void verify_is_invalid(uint idx) { assert(get_by_index(idx) == Invalid, \"invariant\"); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,4 +373,0 @@\n-  void inc_external_accounted_time_ms(double time_ms) {\n-    _external_accounted_time_ms += time_ms;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -423,1 +423,0 @@\n-  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -180,4 +180,0 @@\n-  static void print_from_card_cache() {\n-    G1FromCardCache::print();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-  const Segment* first_segment() const { return Atomic::load(&_first); }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,2 +225,0 @@\n-  void set_size_policy(AdaptiveSizePolicy* v) { _size_policy = v; }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/gcAdaptivePolicyCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,3 +138,0 @@\n-  const CardValue* byte_after_const(const void* p) const {\n-    return byte_after(p);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  static int* disarmed_value_address() { return &_disarmed_value; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,10 +198,0 @@\n-  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    _capacity[int(which_partition)] = value;\n-  }\n-\n-  inline void set_used_by(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    _used[int(which_partition)] = value;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -292,12 +292,0 @@\n-  \/\/ Convert to jint with sanity checking\n-  inline static jint region_size_bytes_jint() {\n-    assert (ShenandoahHeapRegion::RegionSizeBytes <= (size_t)max_jint, \"sanity\");\n-    return (jint)ShenandoahHeapRegion::RegionSizeBytes;\n-  }\n-\n-  \/\/ Convert to jint with sanity checking\n-  inline static jint region_size_words_jint() {\n-    assert (ShenandoahHeapRegion::RegionSizeWords <= (size_t)max_jint, \"sanity\");\n-    return (jint)ShenandoahHeapRegion::RegionSizeWords;\n-  }\n-\n@@ -310,6 +298,0 @@\n-  \/\/ Convert to jint with sanity checking\n-  inline static jint region_size_words_shift_jint() {\n-    assert (ShenandoahHeapRegion::RegionSizeWordsShift <= (size_t)max_jint, \"sanity\");\n-    return (jint)ShenandoahHeapRegion::RegionSizeWordsShift;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -172,13 +172,0 @@\n-  int claim_at(int* indices, int level) {\n-    const int index = claim_index(indices, level);\n-    const int value = claim(index);\n-#if 0\n-    if      (level == 0) { tty->print_cr(\"Claim at: %d index: %d got: %d\",             indices[0], index, value); }\n-    else if (level == 1) { tty->print_cr(\"Claim at: %d %d index: %d got: %d\",          indices[0], indices[1], index, value); }\n-    else if (level == 2) { tty->print_cr(\"Claim at: %d %d %d index: %d got: %d\",       indices[0], indices[1], indices[2], index, value); }\n-    else if (level == 3) { tty->print_cr(\"Claim at: %d %d %d %d index: %d got: %d\",    indices[0], indices[1], indices[2], indices[3], index, value); }\n-    else if (level == 4) { tty->print_cr(\"Claim at: %d %d %d %d %d index: %d got: %d\", indices[0], indices[1], indices[2], indices[3], indices[4], index, value); }\n-#endif\n-    return value;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -264,26 +264,0 @@\n-  \/\/ access to stacked values according to type:\n-  static oop* oop_addr_in_slot(intptr_t* slot_addr) {\n-    return (oop*) slot_addr;\n-  }\n-  static jint* int_addr_in_slot(intptr_t* slot_addr) {\n-    if ((int) sizeof(jint) < wordSize && !Endian::is_Java_byte_ordering_different())\n-      \/\/ big-endian LP64\n-      return (jint*)(slot_addr + 1) - 1;\n-    else\n-      return (jint*) slot_addr;\n-  }\n-  static jlong long_in_slot(intptr_t* slot_addr) {\n-    if (sizeof(intptr_t) >= sizeof(jlong)) {\n-      return *(jlong*) slot_addr;\n-    } else {\n-      return Bytes::get_native_u8((address)slot_addr);\n-    }\n-  }\n-  static void set_long_in_slot(intptr_t* slot_addr, jlong value) {\n-    if (sizeof(intptr_t) >= sizeof(jlong)) {\n-      *(jlong*) slot_addr = value;\n-    } else {\n-      Bytes::put_native_u8((address)slot_addr, value);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  int     get_Java_u2_at     (int offset)        const     { return Bytes::get_Java_u2(addr_at(offset)); }\n@@ -55,2 +54,0 @@\n-  int     get_native_u2_at   (int offset)        const     { return Bytes::get_native_u2(addr_at(offset)); }\n-  int     get_native_u4_at   (int offset)        const     { return Bytes::get_native_u4(addr_at(offset)); }\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,3 +99,0 @@\n-  \/\/ State changes\n-  void            set_next_bci(int bci)          { assert(0 <= bci && bci <= method()->code_size(), \"illegal bci\"); _next_bci = bci; }\n-\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  int       get_Java_index_u4()      { int   i = Bytes::get_Java_u4  (_next_pc); _next_pc += 4; return i; }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -422,1 +422,0 @@\n-  static bool        is_field_code  (Code code)    { return (_getstatic <= java_code(code) && java_code(code) <= _putfield); }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,3 +81,0 @@\n-  int  cp_entry_to_cp_cache(int i) { assert(has_cp_cache(i), \"oob\"); return _cp_map.at(i); }\n-  bool has_cp_cache(int i) { return (uint) i < (uint) _cp_map.length() && _cp_map.at(i) >= 0; }\n-\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -196,2 +196,0 @@\n-inline void set_osr_buf(address buf) { _result._osr._osr_buf = buf; }\n-inline void set_osr_entry(address entry) { _result._osr._osr_entry = entry; }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-  static bool is_current_epoch_generation(u2 generation) {\n-    return _generation == generation;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,5 +116,0 @@\n-  void write_guard_flush() {\n-    write_guard();\n-    _writer->flush();\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkWriter.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,4 +125,0 @@\n-  static bool is_requestable() {\n-    return T::isRequestable;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  void set_nr_of_frames(u4 nr_of_frames) { _nr_of_frames = nr_of_frames; }\n@@ -93,1 +92,0 @@\n-  void set_reached_root(bool reached_root) { _reached_root = reached_root; }\n@@ -101,1 +99,0 @@\n-  bool full_stacktrace() const { return _reached_root; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -144,4 +144,0 @@\n-  void set_stackframes(JfrStackFrame* frames) {\n-    _stackframes = frames;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -350,2 +350,0 @@\n-  const OopMapSet* oopMapSet() const { return _debug_recorder->_oopmaps; }\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,3 +108,0 @@\n-\n-  bool needs_stubs            () { return false; }\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  jobject as_jweak()   { return (jweak) _object; }\n@@ -82,2 +81,0 @@\n-  jcharArray    as_jcharArray()    { return (jcharArray) as_jobject();    }\n-  jshortArray   as_jshortArray()   { return (jshortArray) as_jobject();   }\n@@ -85,1 +82,0 @@\n-  jfloatArray   as_jfloatArray()   { return (jfloatArray) as_jobject();   }\n@@ -87,1 +83,0 @@\n-  jdoubleArray  as_jdoubleArray()  { return (jdoubleArray) as_jobject();  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciObject.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,10 +175,0 @@\n-  static int col_width(julong n, const char *name) {\n-    int w = julong_width(n);\n-    int min = (int)(strlen(name));\n-    if (w < min) {\n-        w = min;\n-    }\n-    \/\/ add a leading space for separation.\n-    return w + 1;\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-  size_t class_reserved() const   { return _cstats.reserved(); }\n@@ -73,1 +72,0 @@\n-  size_t non_class_reserved() const   { return _ncstats.reserved(); }\n","filename":"src\/hotspot\/share\/memory\/metaspaceStats.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-  void set_shrink_factor(uint v) { _shrink_factor = v; }\n","filename":"src\/hotspot\/share\/memory\/metaspaceUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,5 +136,0 @@\n-  size_t total_arena_memory() const {\n-    assert(baseline_type() != Not_baselined, \"Not yet baselined\");\n-    return _malloc_memory_snapshot.total_arena();\n-  }\n-\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -221,1 +221,0 @@\n-  InstanceKlass** pool_holder_addr()      { return &_pool_holder; }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -202,6 +202,0 @@\n- private:\n-\n-  \/\/ Helpers\n-  ConstantPool**        constant_pool_addr()     { return &_constant_pool; }\n-\n- public:\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,4 +194,0 @@\n-  bool is_offset_set() const {\n-    return _offset != 0;\n-  }\n-\n@@ -218,1 +214,0 @@\n-  void set_next_index(int next_index) { _next_index = next_index; }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -450,1 +450,0 @@\n-  int  binsToHold                           (int no)                      { return  ((no+(BitsPerWord-1))\/BitsPerWord); }\n@@ -472,1 +471,0 @@\n-  methodHandle method_as_handle() const            { return _method; }\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-  void set_static_field_size(int size)     { _static_field_size = size; }\n@@ -344,1 +343,0 @@\n-  void set_itable_length(int len)          { _itable_len = len; }\n@@ -682,3 +680,0 @@\n-  void set_nonstatic_oop_map_size(int words) {\n-    _nonstatic_oop_map_size = words;\n-  }\n@@ -720,4 +715,0 @@\n-  void init_previous_versions() {\n-    _previous_versions = nullptr;\n-  }\n-\n@@ -836,1 +827,0 @@\n-  void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -345,3 +345,0 @@\n-  void clear_has_value_based_class_annotation() {\n-    CDS_ONLY(_shared_class_flags &= (u2)(~_has_value_based_class_annotation);)\n-  }\n@@ -674,1 +671,0 @@\n-  bool is_other_instance_klass()        const { return _kind == InstanceKlassKind; }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-  markWord set_unmarked() { return markWord((value() & ~lock_mask_in_place) | unlocked_value); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -380,3 +380,0 @@\n-  void set_from_compiled_entry(address entry) {\n-    _from_compiled_entry =  entry;\n-  }\n@@ -500,1 +497,0 @@\n-  bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }\n@@ -778,4 +774,0 @@\n-  bool has_osr_nmethod(int level, bool match_level) {\n-   return method_holder()->lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != nullptr;\n-  }\n-\n@@ -823,1 +815,0 @@\n-  void clear_is_not_c1_osr_compilable()       { clear_is_not_c1_compilable(); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -220,15 +220,0 @@\n-  bool clear_flag_at(u1 flag_number) {\n-    const u1 bit = 1 << flag_number;\n-    u1 compare_value;\n-    u1 exchange_value;\n-    do {\n-      compare_value = _header._struct._flags;\n-      if ((compare_value & bit) == 0) {\n-        \/\/ already cleaed.\n-        return false;\n-      }\n-      exchange_value = compare_value & ~bit;\n-    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, exchange_value));\n-    return true;\n-  }\n-\n@@ -444,4 +429,0 @@\n-  VirtualCallData* as_VirtualCallData() const {\n-    assert(is_VirtualCallData(), \"wrong type\");\n-    return is_VirtualCallData() ? (VirtualCallData*)this : nullptr;\n-  }\n@@ -456,12 +437,0 @@\n-  ArrayData* as_ArrayData() const {\n-    assert(is_ArrayData(), \"wrong type\");\n-    return is_ArrayData()       ? (ArrayData*)      this : nullptr;\n-  }\n-  MultiBranchData* as_MultiBranchData() const {\n-    assert(is_MultiBranchData(), \"wrong type\");\n-    return is_MultiBranchData() ? (MultiBranchData*)this : nullptr;\n-  }\n-  ArgInfoData* as_ArgInfoData() const {\n-    assert(is_ArgInfoData(), \"wrong type\");\n-    return is_ArgInfoData() ? (ArgInfoData*)this : nullptr;\n-  }\n@@ -547,1 +516,0 @@\n-  void set_null_seen()    { set_flag_at(null_seen_flag); }\n@@ -550,1 +518,0 @@\n-  bool clear_deprecated_method_call_site() { return data()->clear_flag_at(deprecated_method_callsite_flag); }\n@@ -665,13 +632,0 @@\n-  void set_taken(uint cnt) {\n-    set_uint_at(taken_off_set, cnt);\n-  }\n-\n-  \/\/ Saturating counter\n-  uint inc_taken() {\n-    uint cnt = taken() + 1;\n-    \/\/ Did we wrap? Will compiler screw us??\n-    if (cnt == 0) cnt--;\n-    set_uint_at(taken_off_set, cnt);\n-    return cnt;\n-  }\n-\n@@ -1215,3 +1169,0 @@\n-  static ByteSize receiver_type_data_size() {\n-    return cell_offset(static_cell_count());\n-  }\n@@ -1520,12 +1471,0 @@\n-  void set_not_taken(uint cnt) {\n-    set_uint_at(not_taken_off_set, cnt);\n-  }\n-\n-  uint inc_not_taken() {\n-    uint cnt = not_taken() + 1;\n-    \/\/ Did we wrap? Will compiler screw us??\n-    if (cnt == 0) cnt--;\n-    set_uint_at(not_taken_off_set, cnt);\n-    return cnt;\n-  }\n-\n@@ -1570,4 +1509,0 @@\n-  oop array_oop_at(int index) const {\n-    int aindex = index + array_start_off_set;\n-    return oop_at(aindex);\n-  }\n@@ -1605,3 +1540,0 @@\n-  static ByteSize array_start_offset() {\n-    return cell_offset(array_start_off_set);\n-  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  Klass** element_klass_addr()      { return &_element_klass; }\n@@ -62,1 +61,0 @@\n-  Klass** bottom_klass_addr()       { return &_bottom_klass; }\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-  static ByteSize field_index_offset()  { return byte_offset_of(ResolvedFieldEntry, _field_index);  }\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -274,4 +274,0 @@\n-  static Node* unsigned_max(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n-    return build_min_max(a, b, true, true, t, gvn);\n-  }\n-\n@@ -295,5 +291,0 @@\n-  \/\/ min(a-b, 0)\n-  static Node* min_diff_with_zero(Node* a, Node* b, const Type* t, PhaseGVN& gvn) {\n-    return build_min_max_diff_with_zero(a, b, false, t, gvn);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-  bool        is_scl(uint i) const { return scloff() <= i && i < endoff(); }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -657,1 +657,0 @@\n-  bool is_handler_proj() const    { return _handler_bci >= 0; }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-  ArraycopyNode*  as_Arraycopy()  { assert(is_Arraycopy(),\"\");  return (ArraycopyNode*)this; }\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -606,1 +606,0 @@\n-  void set_out_RegMask(const RegMask &out) { _out = &out; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -263,4 +263,0 @@\n-  Node* pop_projection() {\n-    return _projection_list.pop();\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1543,4 +1543,0 @@\n-  const MergeMemNode* all_memory2() const {\n-    assert(_mm2 != nullptr, \"\");\n-    return _mm2;\n-  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,8 +211,0 @@\n-  static void increment_instructions_per_bundle(uint i) {\n-    _total_instructions_per_bundle[i]++;\n-  }\n-\n-  static void increment_nop_size(uint s) {\n-    _total_nop_size += s;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  int               scratch_buffer_code_size()  { return (address)scratch_locs_memory() - _scratch_buffer_blob->content_begin(); }\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -157,2 +157,0 @@\n-\n-  Unique_Node_List *get_useful() { return &_useful; }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-  static address vtable_must_compile_stub()              { return _vtable_must_compile_Java; }\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -721,4 +721,0 @@\n-  void set_field_at(uint i, const Type* t) {\n-    assert(i < _cnt, \"oob\");\n-    _fields[i] = t;\n-  }\n@@ -1382,5 +1378,0 @@\n-\n-  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n-    return _klass->equals(other->is_instptr()->_klass) && _interfaces->eq(other->is_instptr()->_interfaces);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -877,5 +877,0 @@\n-  int count_size(int size) {\n-    assert(1 <= size && size <= 8 && is_power_of_2(size), \"Illegal size\");\n-    return _stats[exact_log2(size)];\n-  }\n-\n@@ -888,13 +883,0 @@\n-\n-  int largest_size() {\n-    for (int i = 3; i >= 0; i--) {\n-      if (_stats[i] > 0) return (1 << i);\n-    }\n-    return NO_SIZE;\n-  }\n-\n-  int unique_size() {\n-    int small = smallest_size();\n-    int large = largest_size();\n-    return (small == large) ? small : MIXED_SIZE;\n-  }\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1140,1 +1140,0 @@\n-  int get_mask_Opcode() const { return _mopc;}\n@@ -1475,1 +1474,0 @@\n-  Node* vector_val() const { return in(1); }\n@@ -1511,1 +1509,0 @@\n-  Node* vec_mask() const { return in(3); }\n@@ -1523,1 +1520,0 @@\n-  Node* vec_shuffle() const { return in(2); }\n@@ -1533,1 +1529,0 @@\n-  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -439,5 +439,0 @@\n- public:\n-  \/\/ Should the thread be enumerated by jvmtiInternal::GetAllThreads?\n-  bool is_debuggable()                 { return _debuggable; }\n-  \/\/ If a thread cannot be suspended (has no valid last_java_frame) then it gets marked !debuggable\n-  void set_debuggable(bool debuggable) { _debuggable = debuggable; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -789,1 +789,0 @@\n-  static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }\n@@ -939,1 +938,0 @@\n-  javaVFrame* vthread_last_java_vframe(RegisterMap* reg_map) { return last_java_vframe(vthread_last_frame(), reg_map); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,2 +144,0 @@\n-  void set_walk_cont(bool value) { _walk_cont = value; }\n-\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -258,4 +258,0 @@\n-  static jlong time_since_last_safepoint_ms() {\n-    return nanos_to_millis(os::javaTimeNanos() - _last_safepoint_end_time_ns);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,3 +255,0 @@\n-  void set_missed_ic_stub_refill_verifier(ICRefillVerifier* verifier) {\n-    _missed_ic_stub_refill_verifier = verifier;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,5 +102,0 @@\n-  bool set_available_for_allocation(bool value) {\n-    bool prev = _available_for_allocation;\n-    _available_for_allocation = value;\n-    return prev;\n-  }\n","filename":"src\/hotspot\/share\/services\/memoryPool.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,6 +92,1 @@\n-  static void track_metaspace_memory_usage() {\n-    track_memory_pool_usage(_metaspace_pool);\n-  }\n-  static void track_compressed_class_memory_usage() {\n-    track_memory_pool_usage(_compressed_class_pool);\n-  }\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,5 +89,0 @@\n-  \/\/ Initialization\n-  void set_field_flags(jint flags)      {\n-    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n-  }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-  void clear_word(idx_t word)            { _map[word] = 0; }\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -921,1 +921,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -301,5 +301,0 @@\n-  \/\/ Copy the current line to the given output stream, and also call cr().\n-  void print_cr_on(outputStream* out) {\n-    print_on(out); out->cr();\n-  }\n-\n","filename":"src\/hotspot\/share\/utilities\/istream.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-   void set_indentation(int i) { _indentation = i;    }\n@@ -131,1 +130,0 @@\n-   virtual void rotate_log(bool force, outputStream* out = nullptr) {} \/\/ GC log rotation\n@@ -137,3 +135,0 @@\n-\n-   void dec_cr() { dec(); cr(); }\n-   void inc_cr() { inc(); cr(); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -188,17 +188,0 @@\n-  \/\/ reports the largest uint32_t value that can be encoded using len bytes\n-  \/\/ len must be in the range [1..5]\n-  static constexpr uint32_t max_encoded_in_length(uint32_t len) {\n-    assert(len >= 1 && len <= MAX_LENGTH, \"invalid length\");\n-    if (len >= MAX_LENGTH)  return MAX_VALUE;  \/\/ largest non-overflow value\n-    \/\/ Be careful:  the constexpr magic evaporates if undefined behavior\n-    \/\/ results from any of these expressions.  Beware of signed overflow!\n-    uint32_t all_combinations = 0;\n-    uint32_t combinations_i = L;  \/\/ L * H^i\n-    for (uint32_t i = 0; i < len; i++) {\n-      \/\/ count combinations of <H*L> that end at byte i\n-      all_combinations += combinations_i;\n-      combinations_i <<= lg_H;\n-    }\n-    return all_combinations - 1;\n-  }\n-\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  int unflushed_count() { return (int)(out()->count() - _last_flush); }\n","filename":"src\/hotspot\/share\/utilities\/xmlstream.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,9 +28,9 @@\n-class TestMappedArray : public G1BiasedMappedArray<int> {\n-public:\n-  virtual int default_value() const {\n-    return 0xBAADBABE;\n-  }\n-  int* my_address_mapped_to(HeapWord* address) {\n-    return address_mapped_to(address);\n-  }\n-};\n+\/\/class TestMappedArray : public G1BiasedMappedArray<int> {\n+\/\/public:\n+\/\/  virtual int default_value() const {\n+\/\/    return 0xBAADBABE;\n+\/\/  }\n+\/\/  int* my_address_mapped_to(HeapWord* address) {\n+\/\/    return address_mapped_to(address);\n+\/\/  }\n+\/\/};\n@@ -41,94 +41,94 @@\n-  \/\/ Any value that is non-zero\n-  HeapWord* fake_heap =\n-          (HeapWord*) LP64_ONLY(0xBAAA00000) NOT_LP64(0xBA000000);\n-\n-  TestMappedArray array;\n-  MemRegion range(fake_heap, fake_heap + REGION_SIZE_IN_WORDS * NUM_REGIONS);\n-  array.initialize(range, REGION_SIZE_IN_WORDS * HeapWordSize);\n-  const int DEFAULT_VALUE = array.default_value();\n-\n-  \/\/ Check address calculation (bounds)\n-  ASSERT_EQ(fake_heap, array.bottom_address_mapped())\n-          << \"bottom mapped address should be \"\n-          << p2i(array.bottom_address_mapped())\n-          << \", but is \"\n-          << p2i(fake_heap);\n-  ASSERT_EQ(fake_heap + REGION_SIZE_IN_WORDS * NUM_REGIONS,\n-          array.end_address_mapped());\n-\n-  int* bottom = array.my_address_mapped_to(fake_heap);\n-  ASSERT_EQ((void*) bottom, (void*) array.base());\n-  int* end = array.my_address_mapped_to(fake_heap +\n-          REGION_SIZE_IN_WORDS * NUM_REGIONS);\n-  ASSERT_EQ((void*) end, (void*) (array.base() + array.length()));\n-  \/\/ The entire array should contain default value elements\n-  for (int* current = bottom; current < end; current++) {\n-    ASSERT_EQ(DEFAULT_VALUE, *current);\n-  }\n-\n-  \/\/ Test setting values in the table\n-  HeapWord* region_start_address =\n-          fake_heap + REGION_SIZE_IN_WORDS * (NUM_REGIONS \/ 2);\n-  HeapWord* region_end_address =\n-          fake_heap + (REGION_SIZE_IN_WORDS * (NUM_REGIONS \/ 2) +\n-          REGION_SIZE_IN_WORDS - 1);\n-\n-  \/\/ Set\/get by address tests: invert some value; first retrieve one\n-  int actual_value = array.get_by_index(NUM_REGIONS \/ 2);\n-  array.set_by_index(NUM_REGIONS \/ 2, ~actual_value);\n-  \/\/ Get the same value by address, should correspond to the start of the \"region\"\n-  int value = array.get_by_address(region_start_address);\n-  ASSERT_EQ(value, ~actual_value);\n-  \/\/ Get the same value by address, at one HeapWord before the start\n-  value = array.get_by_address(region_start_address - 1);\n-  ASSERT_EQ(DEFAULT_VALUE, value);\n-  \/\/ Get the same value by address, at the end of the \"region\"\n-  value = array.get_by_address(region_end_address);\n-  ASSERT_EQ(value, ~actual_value);\n-  \/\/ Make sure the next value maps to another index\n-  value = array.get_by_address(region_end_address + 1);\n-  ASSERT_EQ(DEFAULT_VALUE, value);\n-\n-  \/\/ Reset the value in the array\n-  array.set_by_address(region_start_address +\n-          (region_end_address - region_start_address) \/ 2,\n-          actual_value);\n-\n-  \/\/ The entire array should have the default value again\n-  for (int* current = bottom; current < end; current++) {\n-    ASSERT_EQ(DEFAULT_VALUE, *current);\n-  }\n-\n-  \/\/ Set\/get by index tests: invert some value\n-  size_t index = NUM_REGIONS \/ 2;\n-  actual_value = array.get_by_index(index);\n-  array.set_by_index(index, ~actual_value);\n-\n-  value = array.get_by_index(index);\n-  ASSERT_EQ(~actual_value, value);\n-\n-  value = array.get_by_index(index - 1);\n-  ASSERT_EQ(DEFAULT_VALUE, value);\n-\n-  value = array.get_by_index(index + 1);\n-  ASSERT_EQ(DEFAULT_VALUE, value);\n-\n-  array.set_by_index(0, 0);\n-  value = array.get_by_index(0);\n-  ASSERT_EQ(0, value);\n-\n-  array.set_by_index(array.length() - 1, 0);\n-  value = array.get_by_index(array.length() - 1);\n-  ASSERT_EQ(0, value);\n-\n-  array.set_by_index(index, 0);\n-\n-  \/\/ The array should have three zeros, and default values otherwise\n-  size_t num_zeros = 0;\n-  for (int* current = bottom; current < end; current++) {\n-    ASSERT_TRUE(*current == DEFAULT_VALUE || *current == 0);\n-    if (*current == 0) {\n-      num_zeros++;\n-    }\n-  }\n-  ASSERT_EQ((size_t) 3, num_zeros);\n+\/\/  \/\/ Any value that is non-zero\n+\/\/  HeapWord* fake_heap =\n+\/\/          (HeapWord*) LP64_ONLY(0xBAAA00000) NOT_LP64(0xBA000000);\n+\/\/\n+\/\/  TestMappedArray array;\n+\/\/  MemRegion range(fake_heap, fake_heap + REGION_SIZE_IN_WORDS * NUM_REGIONS);\n+\/\/  array.initialize(range, REGION_SIZE_IN_WORDS * HeapWordSize);\n+\/\/  const int DEFAULT_VALUE = array.default_value();\n+\/\/\n+\/\/  \/\/ Check address calculation (bounds)\n+\/\/  ASSERT_EQ(fake_heap, array.bottom_address_mapped())\n+\/\/          << \"bottom mapped address should be \"\n+\/\/          << p2i(array.bottom_address_mapped())\n+\/\/          << \", but is \"\n+\/\/          << p2i(fake_heap);\n+\/\/  ASSERT_EQ(fake_heap + REGION_SIZE_IN_WORDS * NUM_REGIONS,\n+\/\/          array.end_address_mapped());\n+\/\/\n+\/\/  int* bottom = array.my_address_mapped_to(fake_heap);\n+\/\/  ASSERT_EQ((void*) bottom, (void*) array.base());\n+\/\/  int* end = array.my_address_mapped_to(fake_heap +\n+\/\/          REGION_SIZE_IN_WORDS * NUM_REGIONS);\n+\/\/  ASSERT_EQ((void*) end, (void*) (array.base() + array.length()));\n+\/\/  \/\/ The entire array should contain default value elements\n+\/\/  for (int* current = bottom; current < end; current++) {\n+\/\/    ASSERT_EQ(DEFAULT_VALUE, *current);\n+\/\/  }\n+\/\/\n+\/\/  \/\/ Test setting values in the table\n+\/\/  HeapWord* region_start_address =\n+\/\/          fake_heap + REGION_SIZE_IN_WORDS * (NUM_REGIONS \/ 2);\n+\/\/  HeapWord* region_end_address =\n+\/\/          fake_heap + (REGION_SIZE_IN_WORDS * (NUM_REGIONS \/ 2) +\n+\/\/          REGION_SIZE_IN_WORDS - 1);\n+\/\/\n+\/\/  \/\/ Set\/get by address tests: invert some value; first retrieve one\n+\/\/  int actual_value = array.get_by_index(NUM_REGIONS \/ 2);\n+\/\/  array.set_by_index(NUM_REGIONS \/ 2, ~actual_value);\n+\/\/  \/\/ Get the same value by address, should correspond to the start of the \"region\"\n+\/\/  int value = array.get_by_address(region_start_address);\n+\/\/  ASSERT_EQ(value, ~actual_value);\n+\/\/  \/\/ Get the same value by address, at one HeapWord before the start\n+\/\/  value = array.get_by_address(region_start_address - 1);\n+\/\/  ASSERT_EQ(DEFAULT_VALUE, value);\n+\/\/  \/\/ Get the same value by address, at the end of the \"region\"\n+\/\/  value = array.get_by_address(region_end_address);\n+\/\/  ASSERT_EQ(value, ~actual_value);\n+\/\/  \/\/ Make sure the next value maps to another index\n+\/\/  value = array.get_by_address(region_end_address + 1);\n+\/\/  ASSERT_EQ(DEFAULT_VALUE, value);\n+\/\/\n+\/\/  \/\/ Reset the value in the array\n+\/\/  array.set_by_address(region_start_address +\n+\/\/          (region_end_address - region_start_address) \/ 2,\n+\/\/          actual_value);\n+\/\/\n+\/\/  \/\/ The entire array should have the default value again\n+\/\/  for (int* current = bottom; current < end; current++) {\n+\/\/    ASSERT_EQ(DEFAULT_VALUE, *current);\n+\/\/  }\n+\/\/\n+\/\/  \/\/ Set\/get by index tests: invert some value\n+\/\/  size_t index = NUM_REGIONS \/ 2;\n+\/\/  actual_value = array.get_by_index(index);\n+\/\/  array.set_by_index(index, ~actual_value);\n+\/\/\n+\/\/  value = array.get_by_index(index);\n+\/\/  ASSERT_EQ(~actual_value, value);\n+\/\/\n+\/\/  value = array.get_by_index(index - 1);\n+\/\/  ASSERT_EQ(DEFAULT_VALUE, value);\n+\/\/\n+\/\/  value = array.get_by_index(index + 1);\n+\/\/  ASSERT_EQ(DEFAULT_VALUE, value);\n+\/\/\n+\/\/  array.set_by_index(0, 0);\n+\/\/  value = array.get_by_index(0);\n+\/\/  ASSERT_EQ(0, value);\n+\/\/\n+\/\/  array.set_by_index(array.length() - 1, 0);\n+\/\/  value = array.get_by_index(array.length() - 1);\n+\/\/  ASSERT_EQ(0, value);\n+\/\/\n+\/\/  array.set_by_index(index, 0);\n+\/\/\n+\/\/  \/\/ The array should have three zeros, and default values otherwise\n+\/\/  size_t num_zeros = 0;\n+\/\/  for (int* current = bottom; current < end; current++) {\n+\/\/    ASSERT_TRUE(*current == DEFAULT_VALUE || *current == 0);\n+\/\/    if (*current == 0) {\n+\/\/      num_zeros++;\n+\/\/    }\n+\/\/  }\n+\/\/  ASSERT_EQ((size_t) 3, num_zeros);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1BiasedArray.cpp","additions":103,"deletions":103,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -30,146 +30,0 @@\n-TEST_VM(unsigned5, max_encoded_in_length) {\n-  int maxlen = UNSIGNED5::MAX_LENGTH;\n-  EXPECT_EQ(maxlen, 5);\n-  for (int i = 0; i <= 190; i++) {\n-    uint32_t interesting = i;\n-    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), 1);\n-    EXPECT_EQ(UNSIGNED5::encoded_length(~interesting), maxlen);\n-  }\n-  for (int len = 1; len <= maxlen; len++) {\n-    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n-    EXPECT_EQ(UNSIGNED5::encoded_length(interesting-1), len);\n-    EXPECT_EQ(UNSIGNED5::encoded_length(interesting), len);\n-    if (len < 5) {\n-      EXPECT_EQ(UNSIGNED5::encoded_length(interesting+1), len+1);\n-      EXPECT_EQ(UNSIGNED5::encoded_length(interesting*2), len+1);\n-    }\n-    const int offset = -123;\n-    const int good_limit = offset + len;\n-    const int bad_limit  = good_limit - 1;\n-    EXPECT_TRUE(UNSIGNED5::fits_in_limit(interesting, offset, good_limit));\n-    EXPECT_TRUE(!UNSIGNED5::fits_in_limit(interesting, offset, bad_limit));\n-  }\n-}\n-\n-\/\/ Call FN on a nice list of \"interesting\" uint32_t values to encode\/decode.\n-\/\/ For each length in [1..5], the maximum encodable value of that\n-\/\/ length is \"interesting\", as are one more and one less than that\n-\/\/ value.  For each nybble (aligned 4-bit field) of a uint32_t, each\n-\/\/ possible value (in [0..15]) stored in that nybble is \"interesting\".\n-\/\/ Also \"interesting\" are some other values created by perturbing\n-\/\/ lower bits of that nybble-bearing number, by subtracting a power\n-\/\/ of -7 (up to -7^7).  That makes just over 1000 distinct numbers.\n-\/\/\n-\/\/ Calls to this function are repeatable, so you can call it to pack\n-\/\/ an output array, and then call it again to read an input array\n-\/\/ verifying that the retrieved values match the stored ones.\n-template<typename FN>\n-inline int enumerate_cases(FN fn) {\n-  \/\/ boundary values around the maximum encoded in each byte-length\n-  for (int len = 1; len <= 5; len++) {\n-    uint32_t interesting = UNSIGNED5::max_encoded_in_length(len);\n-    int res = fn(interesting-1);\n-    if (res)  return res;\n-    res = fn(interesting);\n-    if (res)  return res;\n-    if (interesting < (uint32_t)-1) {\n-      res = fn(interesting+1);\n-      if (res)  return res;\n-    }\n-  }\n-  \/\/ for each nybble, for each value in the nybble\n-  for (uint32_t npos = 0; npos < 32; npos += 4) {\n-    for (uint32_t nval = 0; nval <= 15; nval++) {\n-      uint32_t interesting = nval << npos;\n-      int res = fn(interesting);\n-      if (res)  return res;\n-      \/\/ mix in some crazy-looking values: powers of -7 to -7^7\n-      for (int pon7 = 1; pon7 < 1000000; pon7 *= -7) {\n-        uint32_t interesting2 = interesting - pon7;\n-        res = fn(interesting2);\n-        if (res)  return res;\n-      }\n-    }\n-  }\n-  return 0;\n-}\n-\n-TEST_VM(unsigned5, transcode_single) {\n-  const int limit = UNSIGNED5::MAX_LENGTH;\n-  u_char buffer[limit + 1];\n-  auto each_case = [&](uint32_t value) -> uint32_t {\n-    \/\/printf(\"case %08X len=%d\\n\", value, UNSIGNED5::encoded_length(value));\n-    int offset = 0;\n-    UNSIGNED5::write_uint(value, buffer, offset, limit);\n-    int length = offset;\n-    EXPECT_TRUE(length <= UNSIGNED5::MAX_LENGTH);\n-    EXPECT_EQ(length, UNSIGNED5::encoded_length(value)) << \"for value=\" << value;\n-    buffer[length] = 0;\n-    offset = 0;\n-    uint32_t check = UNSIGNED5::read_uint(buffer, offset, limit);\n-    EXPECT_EQ(offset, length) << \"for value=\" << value;\n-    EXPECT_EQ(value, check);\n-    return 0;\n-  };\n-  auto z = enumerate_cases(each_case);\n-  EXPECT_TRUE(!z);\n-}\n-\n-static int count_cases() {\n-  int case_count = 0;\n-  auto inc_case_count = [&](uint32_t){ ++case_count; return 0; };\n-  enumerate_cases(inc_case_count);\n-  return case_count;\n-}\n-\n-TEST_VM(unsigned5, transcode_multiple) {\n-  int case_count = count_cases();\n-  const int limit = 200;\n-  ASSERT_TRUE(limit < case_count*UNSIGNED5::MAX_LENGTH);\n-  u_char buffer[limit + 1];\n-  \/\/printf(\"%d cases total\\n\", case_count);  \/\/1166 cases total\n-  for (int sublimit = limit - 20; sublimit < limit; sublimit++) {\n-    int offset = 0;\n-    int count = 0;\n-    \/\/ write each number into an array\n-    auto write_case = [&](uint32_t value) -> uint32_t {\n-      if (!UNSIGNED5::fits_in_limit(value, offset, sublimit))\n-        return value|1;\n-      UNSIGNED5::write_uint(value, buffer, offset, sublimit);\n-      count++;\n-      return 0;\n-    };\n-    auto done = enumerate_cases(write_case);\n-    EXPECT_TRUE(done) << \"must have hit the sublimit\";\n-    EXPECT_TRUE(count < case_count);\n-    int length = offset;\n-    EXPECT_TRUE(length <= sublimit && length + UNSIGNED5::MAX_LENGTH > sublimit)\n-           << \"length=\" << length << \" sublimit=\" << sublimit;\n-    for (int i = length; i <= sublimit; i++) {\n-      buffer[i] = 0;\n-    }\n-    if (sublimit == limit-1) {\n-      UNSIGNED5::print_count(case_count + 1, &buffer[0], sublimit);\n-    }\n-    \/\/printf(\"encoded %d values in %d bytes: [[%s]]\\n\", count, length, buffer);\n-    \/\/ now read it all back\n-    offset = 0;\n-    int count2 = 0;\n-    auto read_back_case = [&](uint32_t value) -> uint32_t {\n-      int clen = UNSIGNED5::check_length(buffer, offset, sublimit);\n-      if (clen == 0)  return value|1;\n-      EXPECT_EQ(clen, UNSIGNED5::encoded_length(value));\n-      int begin = offset;\n-      uint32_t check = UNSIGNED5::read_uint(buffer, offset, sublimit);\n-      EXPECT_EQ(offset, begin + clen);\n-      EXPECT_EQ(value, check);\n-      count2++;\n-      return 0;\n-    };\n-    auto done2 = enumerate_cases(read_back_case);\n-    EXPECT_EQ(done, done2);\n-    EXPECT_EQ(count, count2);\n-    EXPECT_EQ(offset, length);\n-  }\n-}\n-\n@@ -275,4 +129,0 @@\n-uint32_t code_quality_max_encoded_in_length(int i) {\n-  return UNSIGNED5::max_encoded_in_length(i);  \/\/ should compile like 5-switch\n-}\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_unsigned5.cpp","additions":0,"deletions":150,"binary":false,"changes":150,"status":"modified"}]}