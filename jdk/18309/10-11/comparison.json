{"files":[{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(1)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheHits {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on a happy path, when we can actually cache\n+    \/\/ the last super and use it effectively.\n+\n+    interface I01 {}\n+    interface I02 {}\n+    interface I03 {}\n+    interface I04 {}\n+    interface I05 {}\n+    interface I06 {}\n+    interface I07 {}\n+    interface I08 {}\n+    interface I09 {}\n+    interface I10 {}\n+    interface I11 {}\n+    interface I12 {}\n+    interface I13 {}\n+    interface I14 {}\n+    interface I15 {}\n+    interface I16 {}\n+    interface I17 {}\n+    interface I18 {}\n+    interface I19 {}\n+    interface I20 {}\n+\n+    class B {}\n+    class C1 extends B implements I01, I02, I03, I04, I05, I06, I07, I08, I09, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20 {}\n+\n+    volatile B o;\n+\n+    @Setup\n+    public void setup() {\n+        o = new C1();\n+    }\n+\n+    static final int ITERS = 10000;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(20*ITERS)\n+    public void test(Blackhole bh) {\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I01);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I02);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I03);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I04);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I05);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I06);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I07);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I08);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I09);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I10);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I11);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I12);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I13);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I14);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I15);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I16);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I17);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I18);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I19);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I20);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheHits.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheInterContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In tihs test, every thread comes with its own stable\n+    \/\/ cached value. Meaning, this tests the INTER-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t1(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t2(Blackhole bh) {\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheInterContention.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheIntraContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In this test, every thread comes with its own contending\n+    \/\/ value. Meaning, this tests the INTRA-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(4)\n+    public void test(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheIntraContention.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,331 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.lang;\n-\n-import org.openjdk.jmh.annotations.*;\n-import java.util.Random;\n-\n-@State(Scope.Thread)\n-public class IntfSubtype {\n-    interface J {}\n-    interface I01 {}\n-    interface I02 extends I01 {}\n-    interface I03 extends I02 {}\n-    interface I04 extends I03 {}\n-    interface I05 extends I04 {}\n-    interface I06 extends I05 {}\n-    interface I07 extends I06 {}\n-    interface I08 extends I07 {}\n-    interface I09 extends I08 {}\n-    interface I10 extends I09 {}\n-    interface I11 extends I10 {}\n-    interface I12 extends I11 {}\n-    interface I13 extends I12 {}\n-    interface I14 extends I13 {}\n-    interface I15 extends I14 {}\n-    interface I16 extends I15 {}\n-    interface I17 extends I16 {}\n-    interface I18 extends I17 {}\n-    interface I19 extends I18 {}\n-    interface I20 extends I19 {}\n-    interface I21 extends I20 {}\n-    interface I22 extends I21 {}\n-    interface I23 extends I22 {}\n-    interface I24 extends I23 {}\n-    interface I25 extends I24 {}\n-    interface I26 extends I25 {}\n-    interface I27 extends I26 {}\n-    interface I28 extends I27 {}\n-    interface I29 extends I28 {}\n-    interface I30 extends I29 {}\n-    interface I31 extends I30 {}\n-    interface I32 extends I31 {}\n-    interface I33 extends I32 {}\n-    interface I34 extends I33 {}\n-    interface I35 extends I34 {}\n-    interface I36 extends I35 {}\n-    interface I37 extends I36 {}\n-    interface I38 extends I37 {}\n-    interface I39 extends I38 {}\n-    interface I40 extends I39 {}\n-    interface I41 extends I40 {}\n-    interface I42 extends I41 {}\n-    interface I43 extends I42 {}\n-    interface I44 extends I43 {}\n-    interface I45 extends I44 {}\n-    interface I46 extends I45 {}\n-    interface I47 extends I46 {}\n-    interface I48 extends I47 {}\n-    interface I49 extends I48 {}\n-    interface I50 extends I49 {}\n-    interface I51 extends I50 {}\n-    interface I52 extends I51 {}\n-    interface I53 extends I52 {}\n-    interface I54 extends I53 {}\n-    interface I55 extends I54 {}\n-    interface I56 extends I55 {}\n-    interface I57 extends I56 {}\n-    interface I58 extends I57 {}\n-    interface I59 extends I58 {}\n-    interface I60 extends I59 {}\n-    interface I61 extends I60 {}\n-    interface I62 extends I61 {}\n-    interface I63 extends I62 {}\n-    interface I64 extends I63 {}\n-\n-    static class A0 {}\n-    static class A1 implements I01 {}\n-    static class A2 implements I02 {}\n-    static class A3 implements I03 {}\n-    static class A4 implements I04 {}\n-    static class A5 implements I05 {}\n-    static class A6 implements I06 {}\n-    static class A7 implements I07 {}\n-    static class A8 implements I08 {}\n-    static class A9 implements I09 {}\n-\n-    static class A10 implements I10 {}\n-    static class A16 implements I16 {}\n-    static class A20 implements I20 {}\n-    static class A30 implements I30 {}\n-    static class A32 implements I32 {}\n-    static class A40 implements I40 {}\n-    static class A50 implements I50 {}\n-    static class A60 implements I60 {}\n-    static class A64 implements I64 {}\n-\n-    final Object obj00 = new A0();\n-    final Object obj01 = new A1();\n-    final Object obj02 = new A2();\n-    final Object obj03 = new A3();\n-    final Object obj04 = new A4();\n-    final Object obj05 = new A5();\n-    final Object obj06 = new A6();\n-    final Object obj07 = new A7();\n-    final Object obj08 = new A8();\n-    final Object obj09 = new A9();\n-    final Object obj10 = new A10();\n-    final Object obj16 = new A16();\n-    final Object obj20 = new A20();\n-    final Object obj30 = new A30();\n-    final Object obj32 = new A32();\n-    final Object obj40 = new A40();\n-    final Object obj50 = new A50();\n-    final Object obj60 = new A60();\n-    final Object obj64 = new A64();\n-\n-    static Class<?> getSuper(int idx) {\n-        int i = Math.abs(idx) % 10;\n-        switch (i) {\n-            case 0: return I01.class;\n-            case 1: return I02.class;\n-            case 2: return I03.class;\n-            case 3: return I04.class;\n-            case 4: return I05.class;\n-            case 5: return I06.class;\n-            case 6: return I07.class;\n-            case 7: return I08.class;\n-            case 8: return I09.class;\n-            case 9: return I10.class;\n-        }\n-        throw new InternalError(\"\" + i);\n-    }\n-\n-    @Setup\n-    public void warmup() {\n-        for (int i = 0; i < 20_000; i++) {\n-            Class<?> s = getSuper(i);\n-            test(obj01, s, s.isInstance(obj01));\n-            test(obj02, s, s.isInstance(obj02));\n-            test(obj03, s, s.isInstance(obj03));\n-            test(obj04, s, s.isInstance(obj04));\n-            test(obj05, s, s.isInstance(obj05));\n-            test(obj06, s, s.isInstance(obj06));\n-            test(obj07, s, s.isInstance(obj07));\n-            test(obj08, s, s.isInstance(obj08));\n-            test(obj09, s, s.isInstance(obj09));\n-        }\n-    }\n-\n-    private static void test(Object obj, Class<?> cls, boolean expected) {\n-        if (cls.isInstance(obj) != expected) {\n-            throw new InternalError(obj.getClass() + \" \" + cls + \" \" + expected);\n-        }\n-    }\n-    @Benchmark\n-    public void testPositive01() {\n-        test(obj01, I01.class, true);\n-    }\n-    @Benchmark public void testPositive02() {\n-        test(obj02, I02.class, true);\n-    }\n-    @Benchmark public void testPositive03() {\n-        test(obj03, I03.class, true);\n-    }\n-    @Benchmark public void testPositive04() {\n-        test(obj04, I04.class, true);\n-    }\n-    @Benchmark public void testPositive05() {\n-        test(obj05, I05.class, true);\n-    }\n-    @Benchmark public void testPositive06() {\n-        test(obj06, I06.class, true);\n-    }\n-    @Benchmark public void testPositive07() {\n-        test(obj07, I07.class, true);\n-    }\n-    @Benchmark public void testPositive08() {\n-        test(obj08, I08.class, true);\n-    }\n-    @Benchmark public void testPositive09() {\n-        test(obj09, I09.class, true);\n-    }\n-    @Benchmark public void testPositive10() {\n-        test(obj10, I10.class, true);\n-    }\n-    @Benchmark public void testPositive16() {\n-        test(obj16, I16.class, true);\n-    }\n-    @Benchmark public void testPositive20() {\n-        test(obj20, I20.class, true);\n-    }\n-    @Benchmark public void testPositive30() {\n-        test(obj30, I30.class, true);\n-    }\n-    @Benchmark public void testPositive32() {\n-        test(obj32, I32.class, true);\n-    }\n-    @Benchmark public void testPositive50() {\n-        test(obj50, I50.class, true);\n-    }\n-    @Benchmark public void testPositive40() {\n-        test(obj40, I40.class, true);\n-    }\n-    @Benchmark public void testPositive60() {\n-        test(obj60, I60.class, true);\n-    }\n-    @Benchmark public void testPositive64() {\n-        test(obj64, I64.class, true);\n-    }\n-\n-    @Benchmark public void testNegative00() {\n-        test(obj00, J.class, false);\n-    }\n-    @Benchmark public void testNegative01() {\n-        test(obj01, J.class, false);\n-    }\n-    @Benchmark public void testNegative02() {\n-        test(obj02, J.class, false);\n-    }\n-    @Benchmark public void testNegative03() {\n-        test(obj03, J.class, false);\n-    }\n-    @Benchmark public void testNegative04() {\n-        test(obj04, J.class, false);\n-    }\n-    @Benchmark public void testNegative05() {\n-        test(obj05, J.class, false);\n-    }\n-    @Benchmark public void testNegative06() {\n-        test(obj06, J.class, false);\n-    }\n-    @Benchmark public void testNegative07() {\n-        test(obj07, J.class, false);\n-    }\n-    @Benchmark public void testNegative08() {\n-        test(obj08, J.class, false);\n-    }\n-    @Benchmark public void testNegative09() {\n-        test(obj09, J.class, false);\n-    }\n-    @Benchmark public void testNegative10() {\n-        test(obj10, J.class, false);\n-    }\n-    @Benchmark public void testNegative16() {\n-        test(obj16, J.class, false);\n-    }\n-    @Benchmark public void testNegative20() {\n-        test(obj20, J.class, false);\n-    }\n-    @Benchmark public void testNegative30() {\n-        test(obj30, J.class, false);\n-    }\n-    @Benchmark public void testNegative32() {\n-        test(obj32, J.class, false);\n-    }\n-    @Benchmark public void testNegative40() {\n-        test(obj40, J.class, false);\n-    }\n-    @Benchmark public void testNegative50() {\n-        test(obj50, J.class, false);\n-    }\n-    @Benchmark public void testNegative60() {\n-        test(obj60, J.class, false);\n-    }\n-\n-    @Benchmark public void testNegative64() {\n-        test(obj64, J.class, false);\n-    }\n-\n-    private static final Random RANDOM = new Random();\n-    Class<?> perThreadSuper = null;\n-    @Setup\n-    public void initSuper() {\n-        perThreadSuper = getSuper(RANDOM.nextInt());\n-    }\n-\n-    @Benchmark public void testParallel() {\n-        test(obj40, perThreadSuper, true);\n-    }\n-\n-    public static void main(String[] args) {\n-        new Startup().testAll();\n-    }\n-\n-    public static class Startup {\n-        @Benchmark public Object testA00() {\n-            return new A0();\n-        }\n-        @Benchmark public Object testA04() {\n-            return new A4();\n-        }\n-        @Benchmark public Object testA08() {\n-            return new A8();\n-        }\n-        @Benchmark public Object testA16() {\n-            return new A16();\n-        }\n-        @Benchmark public Object testA32() {\n-            return new A32();\n-        }\n-\n-        @Benchmark public Object testA64() {\n-            return new A64();\n-        }\n-\n-        @Benchmark public Object testAll() {\n-            return new IntfSubtype();\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/IntfSubtype.java","additions":0,"deletions":331,"binary":false,"changes":331,"status":"deleted"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(value = 5)\n+public class SecondarySupersLookup {\n+    interface J  {}\n+    interface I01 {}\n+    interface I02 extends I01 {}\n+    interface I03 extends I02 {}\n+    interface I04 extends I03 {}\n+    interface I05 extends I04 {}\n+    interface I06 extends I05 {}\n+    interface I07 extends I06 {}\n+    interface I08 extends I07 {}\n+    interface I09 extends I08 {}\n+    interface I10 extends I09 {}\n+    interface I11 extends I10 {}\n+    interface I12 extends I11 {}\n+    interface I13 extends I12 {}\n+    interface I14 extends I13 {}\n+    interface I15 extends I14 {}\n+    interface I16 extends I15 {}\n+    interface I17 extends I16 {}\n+    interface I18 extends I17 {}\n+    interface I19 extends I18 {}\n+    interface I20 extends I19 {}\n+    interface I21 extends I20 {}\n+    interface I22 extends I21 {}\n+    interface I23 extends I22 {}\n+    interface I24 extends I23 {}\n+    interface I25 extends I24 {}\n+    interface I26 extends I25 {}\n+    interface I27 extends I26 {}\n+    interface I28 extends I27 {}\n+    interface I29 extends I28 {}\n+    interface I30 extends I29 {}\n+    interface I31 extends I30 {}\n+    interface I32 extends I31 {}\n+    interface I33 extends I32 {}\n+    interface I34 extends I33 {}\n+    interface I35 extends I34 {}\n+    interface I36 extends I35 {}\n+    interface I37 extends I36 {}\n+    interface I38 extends I37 {}\n+    interface I39 extends I38 {}\n+    interface I40 extends I39 {}\n+    interface I41 extends I40 {}\n+    interface I42 extends I41 {}\n+    interface I43 extends I42 {}\n+    interface I44 extends I43 {}\n+    interface I45 extends I44 {}\n+    interface I46 extends I45 {}\n+    interface I47 extends I46 {}\n+    interface I48 extends I47 {}\n+    interface I49 extends I48 {}\n+    interface I50 extends I49 {}\n+    interface I51 extends I50 {}\n+    interface I52 extends I51 {}\n+    interface I53 extends I52 {}\n+    interface I54 extends I53 {}\n+    interface I55 extends I54 {}\n+    interface I56 extends I55 {}\n+    interface I57 extends I56 {}\n+    interface I58 extends I57 {}\n+    interface I59 extends I58 {}\n+    interface I60 extends I59 {}\n+    interface I61 extends I60 {}\n+    interface I62 extends I61 {}\n+    interface I63 extends I62 {}\n+    interface I64 extends I63 {}\n+\n+    final Object obj00 = new Object();\n+    final Object obj01 = new I01() {};\n+    final Object obj02 = new I02() {};\n+    final Object obj03 = new I03() {};\n+    final Object obj04 = new I04() {};\n+    final Object obj05 = new I05() {};\n+    final Object obj06 = new I06() {};\n+    final Object obj07 = new I07() {};\n+    final Object obj08 = new I08() {};\n+    final Object obj09 = new I09() {};\n+    final Object obj10 = new I10() {};\n+    final Object obj16 = new I16() {};\n+    final Object obj20 = new I20() {};\n+    final Object obj30 = new I30() {};\n+    final Object obj32 = new I32() {};\n+    final Object obj40 = new I40() {};\n+    final Object obj50 = new I50() {};\n+    final Object obj55 = new I55() {};\n+    final Object obj56 = new I56() {};\n+    final Object obj57 = new I57() {};\n+    final Object obj58 = new I58() {};\n+    final Object obj59 = new I59() {};\n+    final Object obj60 = new I60() {};\n+    final Object obj61 = new I61() {};\n+    final Object obj62 = new I62() {};\n+    final Object obj63 = new I63() {};\n+    final Object obj64 = new I64() {};\n+\n+    static Class<?> getSuper(int idx) {\n+        int i = Math.abs(idx) % 10;\n+        switch (i) {\n+            case 0: return I01.class;\n+            case 1: return I02.class;\n+            case 2: return I03.class;\n+            case 3: return I04.class;\n+            case 4: return I05.class;\n+            case 5: return I06.class;\n+            case 6: return I07.class;\n+            case 7: return I08.class;\n+            case 8: return I09.class;\n+            case 9: return I10.class;\n+        }\n+        throw new InternalError(\"\" + i);\n+    }\n+\n+    @Setup\n+    public void warmup() {\n+        for (int i = 0; i < 20_000; i++) {\n+            Class<?> s = getSuper(i);\n+            test(obj01, s, s.isInstance(obj01));\n+            test(obj02, s, s.isInstance(obj02));\n+            test(obj03, s, s.isInstance(obj03));\n+            test(obj04, s, s.isInstance(obj04));\n+            test(obj05, s, s.isInstance(obj05));\n+            test(obj06, s, s.isInstance(obj06));\n+            test(obj07, s, s.isInstance(obj07));\n+            test(obj08, s, s.isInstance(obj08));\n+            test(obj09, s, s.isInstance(obj09));\n+        }\n+    }\n+\n+    private static void test(Object obj, Class<?> cls, boolean expected) {\n+        if (cls.isInstance(obj) != expected) {\n+            throw new InternalError(obj.getClass() + \" \" + cls + \" \" + expected);\n+        }\n+    }\n+    @Benchmark\n+    public void testPositive01() {\n+        test(obj01, I01.class, true);\n+    }\n+    @Benchmark public void testPositive02() {\n+        test(obj02, I02.class, true);\n+    }\n+    @Benchmark public void testPositive03() {\n+        test(obj03, I03.class, true);\n+    }\n+    @Benchmark public void testPositive04() {\n+        test(obj04, I04.class, true);\n+    }\n+    @Benchmark public void testPositive05() {\n+        test(obj05, I05.class, true);\n+    }\n+    @Benchmark public void testPositive06() {\n+        test(obj06, I06.class, true);\n+    }\n+    @Benchmark public void testPositive07() {\n+        test(obj07, I07.class, true);\n+    }\n+    @Benchmark public void testPositive08() {\n+        test(obj08, I08.class, true);\n+    }\n+    @Benchmark public void testPositive09() {\n+        test(obj09, I09.class, true);\n+    }\n+    @Benchmark public void testPositive10() {\n+        test(obj10, I10.class, true);\n+    }\n+    @Benchmark public void testPositive16() {\n+        test(obj16, I16.class, true);\n+    }\n+    @Benchmark public void testPositive20() {\n+        test(obj20, I20.class, true);\n+    }\n+    @Benchmark public void testPositive30() {\n+        test(obj30, I30.class, true);\n+    }\n+    @Benchmark public void testPositive32() {\n+        test(obj32, I32.class, true);\n+    }\n+    @Benchmark public void testPositive40() {\n+        test(obj40, I40.class, true);\n+    }\n+    @Benchmark public void testPositive50() {\n+        test(obj50, I50.class, true);\n+    }\n+    @Benchmark public void testPositive60() {\n+        test(obj60, I60.class, true);\n+    }\n+    @Benchmark public void testPositive63() {\n+        test(obj63, I63.class, true);\n+    }\n+    @Benchmark public void testPositive64() {\n+        test(obj64, I64.class, true);\n+    }\n+\n+    @Benchmark public void testNegative00() {\n+        test(obj00, J.class, false);\n+    }\n+    @Benchmark public void testNegative01() {\n+        test(obj01, J.class, false);\n+    }\n+    @Benchmark public void testNegative02() {\n+        test(obj02, J.class, false);\n+    }\n+    @Benchmark public void testNegative03() {\n+        test(obj03, J.class, false);\n+    }\n+    @Benchmark public void testNegative04() {\n+        test(obj04, J.class, false);\n+    }\n+    @Benchmark public void testNegative05() {\n+        test(obj05, J.class, false);\n+    }\n+    @Benchmark public void testNegative06() {\n+        test(obj06, J.class, false);\n+    }\n+    @Benchmark public void testNegative07() {\n+        test(obj07, J.class, false);\n+    }\n+    @Benchmark public void testNegative08() {\n+        test(obj08, J.class, false);\n+    }\n+    @Benchmark public void testNegative09() {\n+        test(obj09, J.class, false);\n+    }\n+    @Benchmark public void testNegative10() {\n+        test(obj10, J.class, false);\n+    }\n+    @Benchmark public void testNegative16() {\n+        test(obj16, J.class, false);\n+    }\n+    @Benchmark public void testNegative20() {\n+        test(obj20, J.class, false);\n+    }\n+    @Benchmark public void testNegative30() {\n+        test(obj30, J.class, false);\n+    }\n+    @Benchmark public void testNegative32() {\n+        test(obj32, J.class, false);\n+    }\n+    @Benchmark public void testNegative40() {\n+        test(obj40, J.class, false);\n+    }\n+    @Benchmark public void testNegative50() {\n+        test(obj50, J.class, false);\n+    }\n+    @Benchmark public void testNegative55() {\n+        test(obj55, J.class, false);\n+    }\n+    @Benchmark public void testNegative56() {\n+        test(obj56, J.class, false);\n+    }\n+    @Benchmark public void testNegative57() {\n+        test(obj57, J.class, false);\n+    }\n+    @Benchmark public void testNegative58() {\n+        test(obj58, J.class, false);\n+    }\n+    @Benchmark public void testNegative59() {\n+        test(obj59, J.class, false);\n+    }\n+    @Benchmark public void testNegative60() {\n+        test(obj60, J.class, false);\n+    }\n+    @Benchmark public void testNegative61() {\n+        test(obj61, J.class, false);\n+    }\n+    @Benchmark public void testNegative62() {\n+        test(obj62, J.class, false);\n+    }\n+    @Benchmark public void testNegative63() {\n+        test(obj63, J.class, false);\n+    }\n+\n+    @Benchmark public void testNegative64() {\n+        test(obj64, J.class, false);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/SecondarySupersLookup.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -34,4 +34,2 @@\n-\/* A test to demonstrate type pollution. Run it with and without\n- * -XX:-HashSecondarySupers -XX:-UseSecondarySuperCache to see the\n- * effect.\n- *\n+\/*\n+ * A test to demonstrate type pollution.\n@@ -75,1 +73,0 @@\n-    interface I21 {}\n@@ -80,3 +77,4 @@\n-        classes = new Class<?>[] { I01.class, I02.class, I03.class, I04.class, I05.class, I06.class, I07.class, I08.class, I09.class, I10.class,\n-                I11.class, I12.class, I13.class, I14.class, I15.class, I16.class, I17.class, I18.class, I19.class, I20.class };\n-\n+        classes = new Class<?>[] { I01.class, I02.class, I03.class, I04.class, I05.class,\n+                                   I06.class, I07.class, I08.class, I09.class, I10.class,\n+                                   I11.class, I12.class, I13.class, I14.class, I15.class,\n+                                   I16.class, I17.class, I18.class, I19.class, I20.class };\n@@ -84,0 +82,1 @@\n+\n@@ -108,1 +107,0 @@\n-    \/\/ Try this with and without -XX:-HashSecondarySupers\n@@ -110,0 +108,8 @@\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchLinearNoSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n@@ -111,1 +117,19 @@\n-    public long parallelInstanceOfInterfaceSwitch() {\n+    public long parallelInstanceOfInterfaceSwitchLinearSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchTableNoSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitchTableSCC() {\n+        return parallelInstanceOfInterfaceSwitch();\n+    }\n+\n+    long parallelInstanceOfInterfaceSwitch() {\n@@ -127,1 +151,0 @@\n-    \/\/ Try this with and without -XX:-HashSecondarySupers\n@@ -129,1 +152,24 @@\n-    public int instanceOfInterfaceSwitch() {\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchLinearNoSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchLinearSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchTableNoSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    public int instanceOfInterfaceSwitchTableSCC() {\n+        return instanceOfInterfaceSwitch();\n+    }\n+\n+    int instanceOfInterfaceSwitch() {\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/TypePollution.java","additions":58,"deletions":12,"binary":false,"changes":70,"status":"modified"}]}