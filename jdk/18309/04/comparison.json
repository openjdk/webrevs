{"files":[{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2014, 2024, Red Hat, Inc. All rights reserved.\n@@ -3666,0 +3666,1 @@\n+     __ mov(result_reg, 1);\n@@ -16280,0 +16281,22 @@\n+instruct partialSubtypeCheckI(iRegP_R4 sub, immP super, vRegD vtemp, iRegP_R5 result,\n+                              iRegP_R1 temp3, iRegP_R0 temp2, iRegP_R2 temp, iRegP_R3 temp4,\n+                              rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(HashSecondarySupers);\n+  effect(KILL cr, TEMP temp, TEMP temp2, TEMP temp3, TEMP temp4, TEMP vtemp);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    __ check_klass_subtype_slow_path($sub$$Register, (Klass*)$super$$constant, $temp$$Register, $temp2$$Register,\n+                                     $temp3$$Register, $temp4$$Register, as_FloatRegister($vtemp$$reg),\n+                                     $result$$Register);\n+  %}\n+\n+  opcode(0x1); \/\/ Force zero of result reg on hit\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -2598,0 +2598,1 @@\n+  \/\/ Advanced SIMD across lanes\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1596,0 +1596,243 @@\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define CHECK_KLASS_SUBTYPE_SLOW_REGISTERS                              \\\n+do {                                                                    \\\n+  assert(r_super_klass == r0 && r_array_base == r1 &&                   \\\n+         r_array_length == r2 && r_array_index == r3 &&                 \\\n+         r_sub_klass == r4 && result == r5, \"registers must match aarch64.ad\"); \\\n+} while(0)\n+\n+static void debug_helper(Klass* sub, Klass* super, bool expected, bool result, const char* msg) {\n+  super->print();\n+  sub->print();\n+  printf(\"%s: sub %p implements %p, expected %d actual %d\\n\", msg,\n+        sub, super, expected, result);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register r_sub_klass,\n+                                                   Klass *super_klass,\n+                                                   Register temp,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   FloatRegister vtemp,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, temp, temp2, temp3, temp4, rscratch1, rscratch2);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  \/\/ a couple of useful fields in r_sub_klass:\n+  int ss_offset = in_bytes(Klass::secondary_supers_offset());\n+  int sc_offset = in_bytes(Klass::secondary_super_cache_offset());\n+  Address secondary_supers_addr(r_sub_klass, ss_offset);\n+  Address super_cache_addr(     r_sub_klass, sc_offset);\n+\n+  BLOCK_COMMENT(\"Hashed check_klass_subtype_slow_path {\");\n+\n+  const Register\n+    r_bitmap = rscratch2,\n+    r_array_length = temp,\n+    r_super_klass = temp2,\n+    r_array_base = temp3,\n+    r_array_index = temp4;\n+\n+  CHECK_KLASS_SUBTYPE_SLOW_REGISTERS;\n+\n+  \/\/ We're going to need the bitmap in a vector reg and in a core reg,\n+  \/\/ so load both now.\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  if (super_klass->hash() != 0) {\n+    ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+  }\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass->hash_slot();\n+  tbz(r_bitmap, bit, L_failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    shld(vtemp, vtemp, Klass::SEC_HASH_MASK - bit);\n+    cnt(vtemp, T8B, vtemp);\n+    addv(vtemp, T8B, vtemp);\n+    fmovd(r_array_index, vtemp);\n+  } else {\n+    mov(r_array_index, (u1)1);\n+  }\n+\n+  mov_metadata(r_super_klass, super_klass);\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  tbz(r_bitmap, (bit+1) & Klass::SEC_HASH_MASK, L_failure);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror(r_bitmap, r_bitmap, bit);\n+  }\n+  adr(result, L_success);\n+  trampoline_call(RuntimeAddress(StubRoutines::_klass_subtype_fallback_stub));\n+\n+  bind(L_failure);\n+  mov(result, (u1)1);\n+  b(L_fallthrough);\n+\n+  bind(L_success);\n+  mov(result, (u1)0);\n+\n+  BLOCK_COMMENT(\"} hashed check_klass_subtype_slow_path\");\n+\n+  bind(L_fallthrough);\n+\n+  verify_klass_subtype_slow_path(r_sub_klass, super_klass, r_super_klass,\n+                                 temp, temp2, temp3, temp4, vtemp, result);\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::klass_subtype_fallback() {\n+  const Register\n+    r_super_klass = r0,\n+    r_array_base = r1,\n+    r_array_length = r2,\n+    r_array_index = r3,\n+    r_sub_klass = r4,\n+    result = r5,\n+    bitmap = rscratch2;\n+\n+  CHECK_KLASS_SUBTYPE_SLOW_REGISTERS;\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label LOOPY, L_failure, L_success, huge;\n+\n+  \/\/ The bitmap is full to bursting: >= 64 entries.\n+  cmn(bitmap, (u1)1);\n+  br(EQ, huge);\n+\n+  {\n+    \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    bind(LOOPY);\n+\n+    cmp(r_array_index, r_array_length);\n+    csel(r_array_index, zr, r_array_index, GE);\n+\n+    ldr(rscratch1, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+    cmp(rscratch1, r_super_klass);\n+    br(EQ, L_success);\n+\n+    tbz(bitmap, 1, L_failure); \/\/ End of run\n+\n+    ror(bitmap, bitmap, 1);\n+    add(r_array_index, r_array_index, 1);\n+    b(LOOPY);\n+  }\n+\n+  bind(L_failure);\n+  ret(lr);\n+\n+  \/\/ Degenerate case: more than 64 secondary supers\n+  bind(huge);\n+  mov(r_array_index, 0);\n+  {\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    Label again;\n+    bind(again);\n+    ldr(rscratch1, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+    cmp(rscratch1, r_super_klass);\n+    br(EQ, L_success);\n+    add(r_array_index, r_array_index, 1);\n+    cmp(r_array_index, r_array_length);\n+    br(LT, again);\n+\n+    ret(lr); \/\/ We failed\n+  }\n+\n+  bind(L_success);\n+  br(result);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_klass_subtype_slow_path(Register r_sub_klass,\n+                                                    Klass *super_klass,\n+                                                    Register r_super_klass,\n+                                                    Register temp,\n+                                                    Register temp2,\n+                                                    Register temp3,\n+                                                    Register temp4,\n+                                                    FloatRegister vtemp,\n+                                                    Register result) {\n+  if (VerifySecondarySupers) {\n+    const Register\n+      r_bitmap = rscratch2,\n+      r_array_length = temp,\n+      r_super_klass = temp2,\n+      r_array_base = temp3,\n+      r_array_index = temp4;\n+\n+    CHECK_KLASS_SUBTYPE_SLOW_REGISTERS;\n+\n+    auto pushed_regs = RegSet::of(result, r_super_klass, r0, r2);\n+    push(pushed_regs, sp);\n+\n+    \/\/ We will consult the secondary-super array.\n+    ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+    \/\/ Load the array length.\n+    ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+    \/\/ And adjust the array base to point to the data.\n+    add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+    mov_metadata(r_super_klass, super_klass);\n+\n+    cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+    \/\/ Scan R2 words at [R5] for an occurrence of R0.\n+    \/\/ Set NZ\/Z based on last compare.\n+    repne_scan(\/*addr*\/r_array_base, \/*value*\/r_super_klass, \/*count*\/r_array_length, rscratch2);\n+    \/\/ rscratch1 == 0 iff we got a match.\n+    cset(rscratch1, NE);\n+\n+    pop(pushed_regs, sp);\n+\n+    {\n+      Label passed;\n+      cmp(rscratch1, result);\n+      br(EQ, passed);\n+      mov(r7, \/*expected*\/rscratch1);\n+      push_call_clobbered_registers();\n+      mov(r0, r_sub_klass \/*r4*\/);\n+      mov_metadata(r1, super_klass);\n+      mov(r2, \/*expected*\/r7);\n+      mov(r3, result);\n+      mov(r4, (address)(\"mismatch\"));\n+      rt_call(CAST_FROM_FN_PTR(address, debug_helper), rscratch2);\n+      pop_call_clobbered_registers();\n+\n+      stop(\"mismatch\");\n+\n+      bind(passed);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":244,"deletions":1,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1002,0 +1002,23 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  void check_klass_subtype_slow_path(Register sub_klass,\n+                                     Klass *super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     FloatRegister vtemp,\n+                                     Register result);\n+\n+  void verify_klass_subtype_slow_path(Register sub_klass,\n+                                      Klass *super_klass,\n+                                      Register r_super_klass,\n+                                      Register temp1,\n+                                      Register temp2,\n+                                      Register temp3,\n+                                      Register temp4,\n+                                      FloatRegister vtemp,\n+                                      Register result);\n+\n+  void klass_subtype_fallback();\n+\n@@ -1216,0 +1239,1 @@\n+  \/\/ Clobbers: rscratch1\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2022, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -6775,0 +6775,10 @@\n+  \/\/ Used by HashSecondarySupers.\n+  address generate_klass_subtype_fallback_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"klass_subtype_fallback\");\n+\n+    address start = __ pc();\n+    __ klass_subtype_fallback();\n+\n+    return start;\n+  }\n+\n@@ -8425,0 +8435,2 @@\n+    StubRoutines::_klass_subtype_fallback_stub = generate_klass_subtype_fallback_stub();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2015, 2024, Red Hat Inc. All rights reserved.\n@@ -451,0 +451,4 @@\n+  if (FLAG_IS_DEFAULT(HashSecondarySupers)) {\n+    HashSecondarySupers = true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -13642,0 +13642,9 @@\n+void Assembler::btq(Register src, int imm8) {\n+  assert(isByte(imm8), \"not a byte\");\n+  InstructionMark im(this);\n+  int encode = prefixq_and_encode(src->encoding());\n+  emit_int16(0x0f, 0xba);\n+  emit_int8(0xe0|encode);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1737,0 +1737,1 @@\n+  void btq(Register src, int imm8);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4729,0 +4729,285 @@\n+#ifdef _LP64\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define CHECK_KLASS_SUBTYPE_SLOW_REGISTERS                              \\\n+do {                                                                    \\\n+  assert(r_super_klass == rax && r_array_base == rbx &&                 \\\n+         r_array_length == rcx && r_array_index == rdx &&               \\\n+         r_sub_klass == rsi && r_bitmap == r11 && result == rdi,        \\\n+         \"registers must match aarch64.ad\");                            \\\n+} while(0)\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register r_sub_klass,\n+                                                   Klass *super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register temp5,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, temp4, temp5,\n+                             result);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  \/\/ a couple of useful fields in r_sub_klass:\n+  int ss_offset = in_bytes(Klass::secondary_supers_offset());\n+  int sc_offset = in_bytes(Klass::secondary_super_cache_offset());\n+  Address secondary_supers_addr(r_sub_klass, ss_offset);\n+  Address super_cache_addr(     r_sub_klass, sc_offset);\n+\n+  BLOCK_COMMENT(\"Hashed check_klass_subtype_slow_path {\");\n+\n+  const Register\n+    r_array_index = temp1,  \/\/ rdx\n+    r_array_length = temp2, \/\/ rcx\n+    r_array_base = temp3,   \/\/ rbx\n+    r_super_klass = temp4,  \/\/ rax\n+    r_bitmap = temp5;       \/\/ r11\n+\n+  CHECK_KLASS_SUBTYPE_SLOW_REGISTERS;\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass->hash_slot();\n+  {\n+    \/\/ NB: If the count in a x86 shift instruction is 0, the flags are\n+    \/\/ not affected, so we do a testq instead.\n+    int shift_count = Klass::SEC_HASH_MASK - bit;\n+    if (shift_count != 0) {\n+      salq(r_array_index, shift_count);\n+    } else {\n+      testq(r_array_index, r_array_index);\n+    }\n+  }  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    popcntq(r_array_index, r_array_index);\n+  } else {\n+    movl(r_array_index, (u1)1);\n+  }\n+\n+  mov_metadata(r_super_klass, super_klass);\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jcc(Assembler::equal, L_success);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, (bit+1) & Klass::SEC_HASH_MASK);\n+  jcc(Assembler::carryClear, L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 0.\n+  if (bit != 0) {\n+    rorq(r_bitmap, bit);\n+  }\n+\n+  call(RuntimeAddress(StubRoutines::_klass_subtype_fallback_stub));\n+  \/\/ Result is in the Z flag\n+  jcc(Assembler::equal, L_success);\n+\n+  bind(L_failure);\n+  cmpptr(rsp, 0);\n+  movl(result, (u1)1);\n+  jmp(L_fallthrough);\n+\n+  bind(L_success);\n+  movl(result, (u1)0);\n+\n+  BLOCK_COMMENT(\"} hashed check_klass_subtype_slow_path\");\n+\n+  bind(L_fallthrough);\n+\n+  verify_klass_subtype_slow_path(r_sub_klass, super_klass, r_super_klass,\n+                                 temp1, temp2, temp3, temp4, temp5, result);\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::klass_subtype_fallback() {\n+  const Register\n+    r_super_klass = rax,\n+    r_array_base = rbx,\n+    r_array_length = rcx,\n+    r_array_index = rdx,\n+    r_sub_klass = rsi,\n+    result = rdi,\n+    r_bitmap = r11;\n+\n+  CHECK_KLASS_SUBTYPE_SLOW_REGISTERS;\n+\n+  \/\/ Load the array length.\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label L_failure, L_success, huge;\n+\n+  \/\/ The bitmap is full to bursting: >= 64 entries.\n+  cmpq(r_bitmap, ~0);\n+  jcc(Assembler::equal, huge);\n+\n+  {\n+    \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    movl(result, 0);\n+\n+    Label again;\n+    bind(again);\n+\n+    \/\/ Check for array wraparound.\n+    cmpl(r_array_index, r_array_length);\n+    cmovl(Assembler::greaterEqual, r_array_index, result);\n+\n+    cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+    jcc(Assembler::equal, L_success);\n+\n+    \/\/ If the next bit in bitmap is zero, we're done.\n+    btq(r_bitmap, 1);\n+    jcc(Assembler::carryClear, L_failure);\n+\n+    rorq(r_bitmap, 1);\n+    addl(r_array_index, 1);\n+\n+    jmp(again);\n+  }\n+\n+  \/\/ Degenerate case: more than 64 secondary supers\n+  bind(huge);\n+  movl(r_array_index, 0);\n+  {\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    Label again;\n+    bind(again);\n+    cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+    jcc(Assembler::equal, L_success);\n+    addl(r_array_index, 1);\n+    cmpl(r_array_index, r_array_length);\n+    jcc(Assembler::less, again);\n+  }\n+\n+  bind(L_failure);\n+  cmpptr(rsp, 0);\n+  ret(0);\n+\n+  bind(L_success);\n+  ret(0);\n+}\n+\n+#ifdef ASSERT\n+static void debug_helper(Klass* sub, Klass* super, bool expected, bool result, const char* msg) {\n+  super->print();\n+  sub->print();\n+  printf(\"%s: sub %p implements %p, expected %d actual %d\\n\", msg,\n+        sub, super, expected, result);\n+}\n+#endif\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_klass_subtype_slow_path(Register r_sub_klass,\n+                                                    Klass *super_klass,\n+                                                    Register r_super_klass,\n+                                                    Register temp,\n+                                                    Register temp2,\n+                                                    Register temp3,\n+                                                    Register temp4,\n+                                                    Register temp5,\n+                                                    Register result) {\n+  if (VerifySecondarySupers) {\n+\n+    push(rax);\n+    push(rax);\n+    push(rcx);\n+    push(rdi);\n+\n+    \/\/ We will consult the secondary-super array.\n+    movptr(rdi, Address(r_sub_klass, Klass::secondary_supers_offset()));\n+    \/\/ Load the array length.  (Positive movl does right thing on LP64.)\n+    movl(rcx, Address(rdi, Array<Klass*>::length_offset_in_bytes()));\n+    \/\/ Skip to start of data.\n+    addptr(rdi, Array<Klass*>::base_offset_in_bytes());\n+\n+    mov_metadata(rax, super_klass);\n+\n+    \/\/ Scan RCX words at [RDI] for an occurrence of RAX.\n+    \/\/ Set NZ\/Z based on last compare.\n+    \/\/ Z flag value will not be set by 'repne' if RCX == 0 since 'repne' does\n+    \/\/ not change flags (only scas instruction which is repeated sets flags).\n+    \/\/ Set Z = 0 (not equal) before 'repne' to indicate that class was not found.\n+    testptr(rax,rax); \/\/ Set Z = 0\n+    repne_scan();\n+\n+    pop(rdi);\n+    pop(rcx);\n+    pop(rax);\n+    pop(rax);\n+\n+    Label hit, fail, done;\n+\n+    jcc(Assembler::equal, hit);\n+\n+    \/\/ Not present\n+    cmpl(result, 0);\n+    jcc(Assembler::notEqual, done);  \/\/ Agree.\n+\n+#ifdef ASSERT\n+    push(r_sub_klass);\n+    push(result);\n+\n+    movptr(c_rarg4, (uintptr_t)\"VerifySecondarySupers 1 failed\");\n+    pop(c_rarg3); \/\/ result\n+    movptr(c_rarg2, 0);  \/\/ expected;\n+    mov_metadata(c_rarg1, super_klass);\n+    pop(c_rarg0);  \/\/ r_sub_klass\n+\n+    call(RuntimeAddress(CAST_FROM_FN_PTR(address, debug_helper)));\n+#endif\n+\n+    STOP(\"VerifySecondarySupers 1 failed\");\n+\n+    \/\/ Present\n+    bind(hit);\n+    cmpl(result, 0);\n+    jcc(Assembler::equal, done); \/\/ Agree.\n+\n+#ifdef ASSERT\n+    push(r_sub_klass);\n+    push(result);\n+\n+    movptr(c_rarg4, (uintptr_t)\"VerifySecondarySupers 2 failed\");\n+    pop(c_rarg3); \/\/ result\n+    movptr(c_rarg2, 0);  \/\/ expected;\n+    mov_metadata(c_rarg1, super_klass);\n+    pop(c_rarg0);  \/\/ r_sub_klass\n+\n+    call(RuntimeAddress(CAST_FROM_FN_PTR(address, debug_helper)));\n+#endif\n+\n+    STOP(\"VerifySecondarySupers 2 failed\");\n+\n+    bind(done);\n+  }\n+}\n+\n+#endif \/\/ LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -649,0 +649,22 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  void check_klass_subtype_slow_path(Register sub_klass,\n+                                     Klass *super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register temp5,\n+                                     Register result);\n+\n+  void verify_klass_subtype_slow_path(Register sub_klass,\n+                                      Klass *super_klass,\n+                                      Register r_super_klass,\n+                                      Register temp1,\n+                                      Register temp2,\n+                                      Register temp3,\n+                                      Register temp4,\n+                                      Register temp5,\n+                                      Register result);\n+  void klass_subtype_fallback();\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3997,0 +3997,10 @@\n+\/\/ Used by HashSecondarySupers.\n+address StubGenerator::generate_klass_subtype_fallback_stub() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"klass_subtype_fallback\");\n+\n+  address start = __ pc();\n+  __ klass_subtype_fallback();\n+\n+  return start;\n+}\n+\n@@ -4150,0 +4160,2 @@\n+  StubRoutines::_klass_subtype_fallback_stub = generate_klass_subtype_fallback_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -608,0 +608,3 @@\n+  \/\/ Used by HashSecondarySupers.\n+  address generate_klass_subtype_fallback_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1776,3 +1776,20 @@\n-  } else if (UsePopCountInstruction) {\n-    warning(\"POPCNT instruction is not available on this CPU\");\n-    FLAG_SET_DEFAULT(UsePopCountInstruction, false);\n+#ifdef _LP64\n+    if (FLAG_IS_DEFAULT(HashSecondarySupers)) {\n+      HashSecondarySupers = true;\n+    }\n+#endif \/\/ LP64\n+  } else {\n+    if (UsePopCountInstruction) {\n+      warning(\"POPCNT instruction is not available on this CPU\");\n+      FLAG_SET_DEFAULT(UsePopCountInstruction, false);\n+    }\n+    if (HashSecondarySupers) {\n+      warning(\"HashSecondarySupers is not available on this CPU\");\n+      FLAG_SET_DEFAULT(HashSecondarySupers, false);\n+    }\n+  }\n+\n+#ifndef _LP64\n+  if (HashSecondarySupers) {\n+    warning(\"HashSecondarySupers is not available on this CPU\");\n+    FLAG_SET_DEFAULT(HashSecondarySupers, false);\n@@ -1780,0 +1797,1 @@\n+#endif \/\/ ! LP64\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+\/\/ Singleton class for R11 long register\n+reg_class long_r11_reg(R11, R11_H);\n+\n@@ -2706,0 +2709,10 @@\n+operand r11_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_r11_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -12094,0 +12107,22 @@\n+instruct partialSubtypeCheckI(rsi_RegP sub, immP super, rdi_RegP result,\n+                              r11_RegL temp5, rax_RegP temp4, rbx_RegP temp3, rcx_RegL temp2, rdx_RegL temp1,\n+                              rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(HashSecondarySupers);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4, TEMP temp5);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    __ check_klass_subtype_slow_path($sub$$Register, (Klass*)$super$$constant, $temp1$$Register, $temp2$$Register,\n+                                     $temp3$$Register, $temp4$$Register, $temp5$$Register,\n+                                     $result$$Register);\n+  %}\n+\n+  opcode(0x1); \/\/ Force zero of result reg on hit\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5997,0 +5997,8 @@\n+  \/\/ This would be very convenient, and it would allow us to save the\n+  \/\/ secondary supers in hashed order, but some SA tests know the\n+  \/\/ order of secondary supers.\n+  \/\/ if (HashSecondarySupers) {\n+  \/\/   \/\/ Put the transitive interfaces into hash order\n+  \/\/   Klass::hash_secondary_supers(_transitive_interfaces, \/*rewrite*\/true);\n+  \/\/ }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+PerfCounter*    ClassLoader::_perf_secondary_hash_time = nullptr;\n@@ -1349,0 +1350,1 @@\n+    NEWPERFTICKCOUNTER(_perf_secondary_hash_time, SUN_CLS, \"secondarySuperHashTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,0 +172,3 @@\n+  \/\/ Count the time taken to hash the scondary superclass arrays.\n+  static PerfCounter* _perf_secondary_hash_time;\n+\n@@ -272,0 +275,3 @@\n+  static PerfCounter* perf_secondary_hash_time() {\n+    return _perf_secondary_hash_time;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+uint64_t Universe::_the_array_interfaces_bitmap = 0;\n@@ -382,0 +383,5 @@\n+    if (HashSecondarySupers) {\n+      Universe::_the_array_interfaces_bitmap\n+        = Klass::hash_secondary_supers(_the_array_interfaces_array, \/*rewrite*\/false);\n+    }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  static uint64_t _the_array_interfaces_bitmap;\n@@ -269,0 +270,1 @@\n+  static uint64_t     the_array_interfaces_bitmap()   { return _the_array_interfaces_bitmap;   }\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-  set_secondary_supers(Universe::the_array_interfaces_array());\n+  set_secondary_supers(Universe::the_array_interfaces_array(),\n+                       Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1442,8 +1442,9 @@\n-    set_secondary_supers((Array<Klass*>*)(address)interfaces);\n-    return nullptr;\n-  } else {\n-    \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n-    \/\/ into the secondary super list with extra slots.\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      secondaries->push(interfaces->at(i));\n+    if (! HashSecondarySupers) {\n+      set_secondary_supers((Array<Klass*>*)(address)interfaces);\n+      return nullptr;\n+    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+      \/\/ We will reuse the transitive interfaces list if we're certain\n+      \/\/ it's in hash order.\n+      uint64_t bitmap = hash_secondary_supers(interfaces, \/*rewrite*\/false);\n+      set_secondary_supers((Array<Klass*>*)(address)interfaces, bitmap);\n+      return nullptr;\n@@ -1451,1 +1452,7 @@\n-    return secondaries;\n+    \/\/ ... fall through if that didn't work.\n+  }\n+  \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n+  \/\/ into the secondary super list with extra slots.\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    secondaries->push(interfaces->at(i));\n@@ -1453,0 +1460,1 @@\n+  return secondaries;\n@@ -3623,0 +3631,5 @@\n+  if (HashSecondarySupers) {\n+    st->print(BULLET\"hash:              0x%x (slot=%d)\", hash(), hash_slot()); st->cr();\n+    st->print(BULLET\"bitmap:            0x%\" PRIx64, _bitmap);\n+    st->cr();\n+  }\n@@ -3624,1 +3637,1 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);                  st->cr();\n+  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);               st->cr();\n@@ -3701,0 +3714,16 @@\n+  if ((Verbose || WizardMode) && _secondary_supers != nullptr) {\n+    st->print_cr(BULLET\"---- secondary supers (%d words):\", _secondary_supers->length());\n+    int longest_distance = 0;\n+    for (int i = 0; i < _secondary_supers->length(); i++) {\n+      unsigned home_slot = _secondary_supers->at(i)->hash_slot();\n+      if (home_slot > 0) {\n+        home_slot = population_count(_bitmap << (SEC_HASH_ENTRIES - home_slot));\n+      }\n+      int distance = (i - home_slot) & SEC_HASH_MASK;\n+      longest_distance = MAX2(longest_distance, distance);\n+      st->print_cr(\"  %d:  %p (home slot=%d, distance = %d)\", i, _secondary_supers->at(i),\n+                   home_slot, distance);\n+    }\n+    st->print_cr(\"  longest probe distance = %d\", longest_distance);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -82,1 +84,39 @@\n-  if (_name != nullptr) _name->increment_refcount();\n+\n+  if (_name != nullptr) {\n+    _name->increment_refcount();\n+  }\n+\n+  if (HashSecondarySupers) {\n+    elapsedTimer selftime;\n+    selftime.start();\n+\n+    \/\/ Special cases for the two superclasses of all Array instances.\n+    if (n == vmSymbols::java_lang_Cloneable()) {\n+      _hash = 0;\n+    } else if (n == vmSymbols::java_io_Serializable()) {\n+      _hash = 1 << secondary_shift();\n+    } else {\n+      const jbyte *s = (const jbyte*)n->bytes();\n+      unsigned int hash_code = java_lang_String::hash_code(s, n->utf8_length());\n+      \/\/ We use String::hash_code here (rather than e.g.\n+      \/\/ Symbol::identity_hash()) in order to have a hash code that\n+      \/\/ does not change from run to run. We want that because the\n+      \/\/ hash value for a secondary superclass appears in generated\n+      \/\/ code as a constant.\n+\n+      \/\/ This constant is magic: see Knuth, \"Fibonacci Hashing\".\n+      _hash = hash_code * 2654435769;\n+      if (StressSecondarySuperHash) {\n+        \/\/ Generate many hash collisions in order to stress-test the\n+        \/\/ linear search fallback.\n+        hash_code = _hash % 3;\n+        hash_code = hash_code * (SEC_HASH_ENTRIES \/ 3);\n+        _hash = hash_code << secondary_shift();\n+      }\n+    }\n+\n+    selftime.stop();\n+    if (UsePerfData) {\n+      ClassLoader::perf_secondary_hash_time()->inc(selftime.ticks());\n+    }\n+  }\n@@ -239,0 +279,124 @@\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries, uint64_t bitmap) {\n+  _bitmap = bitmap;\n+  set_secondary_supers(secondaries);\n+}\n+\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries) {\n+#ifdef ASSERT\n+  if (HashSecondarySupers && secondaries != nullptr) {\n+    uint64_t real_bitmap = hash_secondary_supers(secondaries, \/*rewrite*\/false);\n+    assert(_bitmap == real_bitmap, \"must be\");\n+  }\n+#endif\n+  _secondary_supers = secondaries;\n+}\n+\n+template<typename T>\n+void Klass::hash_insert(T *sec, GrowableArray<T*>* secondaries,\n+                        uint64_t &bitmap, bool use_robin_hood) {\n+  int longest_probe = 0;\n+  int dist = 0;\n+  for (int slot = sec->hash_slot(); true; slot = (slot + 1) & SEC_HASH_MASK) {\n+    if (secondaries->at(slot) == nullptr) {\n+      secondaries->at_put(slot, sec);\n+      bitmap |= uint64_t(1) << slot;\n+      return;\n+    }\n+    if (use_robin_hood) {\n+      \/\/ Use Robin Hood hashing to minimize the worst case search.\n+      \/\/ Also, every permutation of the insertion sequence produces\n+      \/\/ the same final Robin Hood hash table, provided that a\n+      \/\/ consistent tie breaker is used\n+      T* existing = secondaries->at(slot);\n+      int existing_dist = (slot - existing->hash_slot()) & SEC_HASH_MASK;\n+      if (existing_dist < dist\n+          \/\/ This tie breaker ensures that the hash order is\n+          \/\/ maintained.\n+          || ((existing_dist == dist)\n+              && (uintptr_t(existing) < uintptr_t(sec)))) {\n+        T* tmp = secondaries->at(slot);\n+        secondaries->at_put(slot, sec);\n+        sec = tmp;\n+        dist = existing_dist;\n+      }\n+      ++dist;\n+    }\n+  }\n+}\n+\n+\/\/ Hashed secondary superclasses\n+\/\/\n+\/\/ We use a compressed 64-entry hash table with linear probing. We\n+\/\/ start by creating a hash table in the usual way, followed by a pass\n+\/\/ that removes all the null entries. To indicate which entries would\n+\/\/ have been null we use a bitmap that contains a 1 in each position\n+\/\/ where an entry is present, 0 otherwise. This bitmap also serves as\n+\/\/ a kind of Bloom filter, which in many cases allows us quickly to\n+\/\/ eliminate the possibility that something is a member of a set of\n+\/\/ secondaries.\n+template<typename T>\n+uint64_t Klass::hash_secondary_supers(Array<T*>* secondaries, bool rewrite) {\n+  const int length = secondaries->length();\n+\n+  if (length == 0) {\n+    return 0;\n+  }\n+\n+  if (length == 1) {\n+    int hash_slot = secondaries->at(0)->hash_slot();\n+    return uint64_t(1) << hash_slot;\n+  }\n+\n+  if (length >= SEC_HASH_ENTRIES) {\n+    return ~(uint64_t)0;\n+  }\n+\n+  elapsedTimer selftime;\n+  selftime.start();\n+\n+  ResourceMark rm;\n+  uint64_t bitmap = 0;\n+  GrowableArray<T*>* hashed_secondaries\n+    = new GrowableArray<T*>(SEC_HASH_ENTRIES, SEC_HASH_ENTRIES, nullptr);\n+\n+  for (int j = 0; j < length; j++) {\n+    T *k = secondaries->at(j);\n+    hash_insert(k, hashed_secondaries, bitmap, \/*use_robin_hood*\/true);\n+  }\n+\n+  if (rewrite) {\n+    \/\/ Pack the hashed secondaries array by copying it into the\n+    \/\/ secondaries array, sans nulls.\n+    int i = 0;\n+    int maxprobe = 0;\n+    for (int slot = 0; slot < SEC_HASH_ENTRIES; slot++) {\n+      if (((bitmap >> slot) & 1) != 0) {\n+        secondaries->at_put(i, hashed_secondaries->at(slot));\n+        i++;\n+      }\n+    }\n+  } else {\n+#ifdef ASSERT\n+    \/\/ Check that the secondary_supers array is sorted by hash order\n+    int i = 0;\n+    for (int slot = 0; slot < SEC_HASH_ENTRIES; slot++) {\n+      if (hashed_secondaries->at(slot) != nullptr) {\n+        assert(secondaries->at(i) == hashed_secondaries->at(slot),\n+               \"broken secondary supers hash table\");\n+        i++;\n+      }\n+    }\n+#endif\n+  }\n+\n+  selftime.stop();\n+  if (UsePerfData) {\n+    ClassLoader::perf_secondary_hash_time()->inc(selftime.ticks());\n+  }\n+\n+  return bitmap;\n+}\n+\n+template uint64_t Klass::hash_secondary_supers(Array<Klass*>* secondaries, bool);\n+template uint64_t Klass::hash_secondary_supers(Array<InstanceKlass*>* secondaries, bool);\n+\n@@ -341,0 +505,4 @@\n+    if (HashSecondarySupers) {\n+      _bitmap = hash_secondary_supers(s2, \/*rewrite*\/true);\n+    }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":170,"deletions":2,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -162,0 +162,4 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uint64_t _bitmap;\n+  juint _hash;\n+\n@@ -234,1 +238,16 @@\n-  void set_secondary_supers(Array<Klass*>* k) { _secondary_supers = k; }\n+  void set_secondary_supers(Array<Klass*>* k);\n+  void set_secondary_supers(Array<Klass*>* k, uint64_t bitmap);\n+  template<typename T>\n+  inline static void hash_insert(T *sec, GrowableArray<T*>* secondaries,\n+                                 uint64_t &bitmap, bool use_robin_hood);\n+  template<typename T>\n+  static uint64_t hash_secondary_supers(Array<T*>* secondaries, bool rewrite);\n+\n+  \/\/ Hash coding used by HashSecondarySupers.\n+  static constexpr int SEC_HASH_ENTRIES = 64;\n+  static constexpr int SEC_HASH_MASK = 64 - 1;\n+\n+  static constexpr size_t hash_size_in_bits() { return (sizeof _hash) * 8; }\n+  static constexpr int secondary_shift() { return hash_size_in_bits() - 6; }\n+  juint hash() const { return _hash; }\n+  int hash_slot() const { return hash() >> secondary_shift(); }\n@@ -402,0 +421,2 @@\n+  static ByteSize hash_offset()                  { return byte_offset_of(Klass, _hash); }\n+  static ByteSize bitmap_offset()                { return byte_offset_of(Klass, _bitmap); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -311,1 +311,2 @@\n-    set_secondary_supers(Universe::the_array_interfaces_array());\n+    set_secondary_supers(Universe::the_array_interfaces_array(),\n+                         Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2451,0 +2451,6 @@\n+  if (tkls != nullptr && !UseSecondarySuperCache\n+      && tkls->offset() == in_bytes(Klass::secondary_super_cache_offset()))  {\n+    \/\/ Treat Klass::_secondary_super_cache as a constant when the cache is disabled.\n+    return TypePtr::NULL_PTR;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1997,0 +1997,13 @@\n+                                                                            \\\n+  product(bool, UseSecondarySuperCache, true, DIAGNOSTIC,                   \\\n+          \"Use secondary super cache during subtype checks\")                \\\n+                                                                            \\\n+  product(bool, HashSecondarySupers,  false, DIAGNOSTIC,                    \\\n+                \"Use hash table to scan secondary supers.\")                 \\\n+                                                                            \\\n+  product(bool, VerifySecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Use secondary super cache during subtype checks\")                \\\n+                                                                            \\\n+  product(bool, StressSecondarySuperHash, false, DIAGNOSTIC,                \\\n+          \"Use a terrible hash function in order to generate many collisions\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,1 @@\n+address StubRoutines::_klass_subtype_fallback_stub = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -276,0 +276,1 @@\n+  static address _klass_subtype_fallback_stub;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.Random;\n+\n+@State(Scope.Thread)\n+public class IntfSubtype {\n+    interface J  {}\n+    interface I01 {}\n+    interface I02 extends I01 {}\n+    interface I03 extends I02 {}\n+    interface I04 extends I03 {}\n+    interface I05 extends I04 {}\n+    interface I06 extends I05 {}\n+    interface I07 extends I06 {}\n+    interface I08 extends I07 {}\n+    interface I09 extends I08 {}\n+    interface I10 extends I09 {}\n+    interface I11 extends I10 {}\n+    interface I12 extends I11 {}\n+    interface I13 extends I12 {}\n+    interface I14 extends I13 {}\n+    interface I15 extends I14 {}\n+    interface I16 extends I15 {}\n+    interface I17 extends I16 {}\n+    interface I18 extends I17 {}\n+    interface I19 extends I18 {}\n+    interface I20 extends I19 {}\n+    interface I21 extends I20 {}\n+    interface I22 extends I21 {}\n+    interface I23 extends I22 {}\n+    interface I24 extends I23 {}\n+    interface I25 extends I24 {}\n+    interface I26 extends I25 {}\n+    interface I27 extends I26 {}\n+    interface I28 extends I27 {}\n+    interface I29 extends I28 {}\n+    interface I30 extends I29 {}\n+    interface I31 extends I30 {}\n+    interface I32 extends I31 {}\n+    interface I33 extends I32 {}\n+    interface I34 extends I33 {}\n+    interface I35 extends I34 {}\n+    interface I36 extends I35 {}\n+    interface I37 extends I36 {}\n+    interface I38 extends I37 {}\n+    interface I39 extends I38 {}\n+    interface I40 extends I39 {}\n+    interface I41 extends I40 {}\n+    interface I42 extends I41 {}\n+    interface I43 extends I42 {}\n+    interface I44 extends I43 {}\n+    interface I45 extends I44 {}\n+    interface I46 extends I45 {}\n+    interface I47 extends I46 {}\n+    interface I48 extends I47 {}\n+    interface I49 extends I48 {}\n+    interface I50 extends I49 {}\n+    interface I51 extends I50 {}\n+    interface I52 extends I51 {}\n+    interface I53 extends I52 {}\n+    interface I54 extends I53 {}\n+    interface I55 extends I54 {}\n+    interface I56 extends I55 {}\n+    interface I57 extends I56 {}\n+    interface I58 extends I57 {}\n+    interface I59 extends I58 {}\n+    interface I60 extends I59 {}\n+    interface I61 extends I60 {}\n+    interface I62 extends I61 {}\n+    interface I63 extends I62 {}\n+    interface I64 extends I63 {}\n+\n+    static class A0 {}\n+    static class A1 implements I01 {}\n+    static class A2 implements I02 {}\n+    static class A3 implements I03 {}\n+    static class A4 implements I04 {}\n+    static class A5 implements I05 {}\n+    static class A6 implements I06 {}\n+    static class A7 implements I07 {}\n+    static class A8 implements I08 {}\n+    static class A9 implements I09 {}\n+\n+    static class A10 implements I10 {}\n+    static class A16 implements I16 {}\n+    static class A20 implements I20 {}\n+    static class A30 implements I30 {}\n+    static class A32 implements I32 {}\n+    static class A40 implements I40 {}\n+    static class A50 implements I50 {}\n+    static class A60 implements I60 {}\n+    static class A64 implements I64 {}\n+\n+    final Object obj00 = new A0();\n+    final Object obj01 = new A1();\n+    final Object obj02 = new A2();\n+    final Object obj03 = new A3();\n+    final Object obj04 = new A4();\n+    final Object obj05 = new A5();\n+    final Object obj06 = new A6();\n+    final Object obj07 = new A7();\n+    final Object obj08 = new A8();\n+    final Object obj09 = new A9();\n+    final Object obj10 = new A10();\n+    final Object obj16 = new A16();\n+    final Object obj20 = new A20();\n+    final Object obj30 = new A30();\n+    final Object obj32 = new A32();\n+    final Object obj40 = new A40();\n+    final Object obj50 = new A50();\n+    final Object obj60 = new A60();\n+    final Object obj64 = new A64();\n+\n+    static Class<?> getSuper(int idx) {\n+        int i = Math.abs(idx) % 10;\n+        switch (i) {\n+            case 0: return I01.class;\n+            case 1: return I02.class;\n+            case 2: return I03.class;\n+            case 3: return I04.class;\n+            case 4: return I05.class;\n+            case 5: return I06.class;\n+            case 6: return I07.class;\n+            case 7: return I08.class;\n+            case 8: return I09.class;\n+            case 9: return I10.class;\n+        }\n+        throw new InternalError(\"\" + i);\n+    }\n+\n+    @Setup\n+    public void warmup() {\n+        for (int i = 0; i < 20_000; i++) {\n+            Class<?> s = getSuper(i);\n+            test(obj01, s, s.isInstance(obj01));\n+            test(obj02, s, s.isInstance(obj02));\n+            test(obj03, s, s.isInstance(obj03));\n+            test(obj04, s, s.isInstance(obj04));\n+            test(obj05, s, s.isInstance(obj05));\n+            test(obj06, s, s.isInstance(obj06));\n+            test(obj07, s, s.isInstance(obj07));\n+            test(obj08, s, s.isInstance(obj08));\n+            test(obj09, s, s.isInstance(obj09));\n+        }\n+    }\n+\n+    private static void test(Object obj, Class<?> cls, boolean expected) {\n+        if (cls.isInstance(obj) != expected) {\n+            throw new InternalError(obj.getClass() + \" \" + cls + \" \" + expected);\n+        }\n+    }\n+    @Benchmark\n+    public void testPositive01() {\n+        test(obj01, I01.class, true);\n+    }\n+    @Benchmark public void testPositive02() {\n+        test(obj02, I02.class, true);\n+    }\n+    @Benchmark public void testPositive03() {\n+        test(obj03, I03.class, true);\n+    }\n+    @Benchmark public void testPositive04() {\n+        test(obj04, I04.class, true);\n+    }\n+    @Benchmark public void testPositive05() {\n+        test(obj05, I05.class, true);\n+    }\n+    @Benchmark public void testPositive06() {\n+        test(obj06, I06.class, true);\n+    }\n+    @Benchmark public void testPositive07() {\n+        test(obj07, I07.class, true);\n+    }\n+    @Benchmark public void testPositive08() {\n+        test(obj08, I08.class, true);\n+    }\n+    @Benchmark public void testPositive09() {\n+        test(obj09, I09.class, true);\n+    }\n+    @Benchmark public void testPositive10() {\n+        test(obj10, I10.class, true);\n+    }\n+    @Benchmark public void testPositive16() {\n+        test(obj16, I16.class, true);\n+    }\n+    @Benchmark public void testPositive20() {\n+        test(obj20, I20.class, true);\n+    }\n+    @Benchmark public void testPositive30() {\n+        test(obj30, I30.class, true);\n+    }\n+    @Benchmark public void testPositive32() {\n+        test(obj32, I32.class, true);\n+    }\n+    @Benchmark public void testPositive50() {\n+        test(obj50, I50.class, true);\n+    }\n+    @Benchmark public void testPositive40() {\n+        test(obj40, I40.class, true);\n+    }\n+    @Benchmark public void testPositive60() {\n+        test(obj60, I60.class, true);\n+    }\n+    @Benchmark public void testPositive64() {\n+        test(obj64, I64.class, true);\n+    }\n+\n+    @Benchmark public void testNegative00() {\n+        test(obj00, J.class, false);\n+    }\n+    @Benchmark public void testNegative01() {\n+        test(obj01, J.class, false);\n+    }\n+    @Benchmark public void testNegative02() {\n+        test(obj02, J.class, false);\n+    }\n+    @Benchmark public void testNegative03() {\n+        test(obj03, J.class, false);\n+    }\n+    @Benchmark public void testNegative04() {\n+        test(obj04, J.class, false);\n+    }\n+    @Benchmark public void testNegative05() {\n+        test(obj05, J.class, false);\n+    }\n+    @Benchmark public void testNegative06() {\n+        test(obj06, J.class, false);\n+    }\n+    @Benchmark public void testNegative07() {\n+        test(obj07, J.class, false);\n+    }\n+    @Benchmark public void testNegative08() {\n+        test(obj08, J.class, false);\n+    }\n+    @Benchmark public void testNegative09() {\n+        test(obj09, J.class, false);\n+    }\n+    @Benchmark public void testNegative10() {\n+        test(obj10, J.class, false);\n+    }\n+    @Benchmark public void testNegative16() {\n+        test(obj16, J.class, false);\n+    }\n+    @Benchmark public void testNegative20() {\n+        test(obj20, J.class, false);\n+    }\n+    @Benchmark public void testNegative30() {\n+        test(obj30, J.class, false);\n+    }\n+    @Benchmark public void testNegative32() {\n+        test(obj32, J.class, false);\n+    }\n+    @Benchmark public void testNegative40() {\n+        test(obj40, J.class, false);\n+    }\n+    @Benchmark public void testNegative50() {\n+        test(obj50, J.class, false);\n+    }\n+    @Benchmark public void testNegative60() {\n+        test(obj60, J.class, false);\n+    }\n+\n+    @Benchmark public void testNegative64() {\n+        test(obj64, J.class, false);\n+    }\n+\n+    private static final Random RANDOM = new Random();\n+    Class<?> perThreadSuper = null;\n+    @Setup\n+    public void initSuper() {\n+        perThreadSuper = getSuper(RANDOM.nextInt());\n+    }\n+\n+    @Benchmark public void testParallel() {\n+        test(obj40, perThreadSuper, true);\n+    }\n+\n+    public static void main(String[] args) {\n+        new Startup().testAll();\n+    }\n+\n+    public static class Startup {\n+        @Benchmark public Object testA00() {\n+            return new A0();\n+        }\n+        @Benchmark public Object testA04() {\n+            return new A4();\n+        }\n+        @Benchmark public Object testA08() {\n+            return new A8();\n+        }\n+        @Benchmark public Object testA16() {\n+            return new A16();\n+        }\n+        @Benchmark public Object testA32() {\n+            return new A32();\n+        }\n+\n+        @Benchmark public Object testA64() {\n+            return new A64();\n+        }\n+\n+        @Benchmark public Object testAll() {\n+            return new IntfSubtype();\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/IntfSubtype.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.*;\n+\n+\/* A test to demonstrate type pollution. Run it with and without\n+ * -XX:-HashSecondarySupers -XX:-UseSecondarySuperCache to see the\n+ * effect.\n+ *\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 3)\n+public class TypePollution {\n+\n+    static class DynamicInvocationHandler implements InvocationHandler {\n+\n+        @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) {\n+            return null;\n+        }\n+    }\n+\n+    interface I01 {}\n+    interface I02 {}\n+    interface I03 {}\n+    interface I04 {}\n+    interface I05 {}\n+    interface I06 {}\n+    interface I07 {}\n+    interface I08 {}\n+    interface I09 {}\n+    interface I10 {}\n+    interface I11 {}\n+    interface I12 {}\n+    interface I13 {}\n+    interface I14 {}\n+    interface I15 {}\n+    interface I16 {}\n+    interface I17 {}\n+    interface I18 {}\n+    interface I19 {}\n+    interface I20 {}\n+    interface I21 {}\n+\n+    static Class<?>[] classes;\n+\n+    static {\n+        classes = new Class<?>[] { I01.class, I02.class, I03.class, I04.class, I05.class, I06.class, I07.class, I08.class, I09.class, I10.class,\n+                I11.class, I12.class, I13.class, I14.class, I15.class, I16.class, I17.class, I18.class, I19.class, I20.class };\n+\n+    }\n+    private static final int NOOFOBJECTS = 100;\n+\n+    public Object[] objectArray;\n+\n+    public Random rand = new Random(0);\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        objectArray = new Object[1000];\n+        var loader = getClass().getClassLoader();\n+        Class<?>[] someInterfaces = new Class<?>[0];\n+        for (int i = 0; i < objectArray.length; i++) {\n+            Set<Class<?>> aSet = new HashSet<Class<?>>();\n+            for (int j  = 0; j < 6; j++) {\n+                aSet.add(classes[rand.nextInt(classes.length)]);\n+            }\n+            Class<?>[] interfaceArray = new Class[aSet.size()];\n+            interfaceArray = aSet.toArray(interfaceArray);\n+            objectArray[i] = Proxy.newProxyInstance(loader, interfaceArray, new DynamicInvocationHandler());\n+        }\n+    }\n+\n+    int probe = 99;\n+\n+    \/\/ Try this with and without -XX:-HashSecondarySupers\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long parallelInstanceOfInterfaceSwitch() {\n+        Supplier<Long> s = () -> {\n+            long sum = 0;\n+            for (int i = 0; i < 10000; i++) {\n+                sum += instanceOfInterfaceSwitch();\n+            }\n+            return sum;\n+        };\n+        try {\n+            CompletableFuture<Long> future = CompletableFuture.supplyAsync(s);\n+            return s.get() + future.get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ Try this with and without -XX:-HashSecondarySupers\n+    @Benchmark\n+    public int instanceOfInterfaceSwitch() {\n+        int dummy = 0;\n+        for (int i = 0; i < 100; i++) {\n+            probe ^= probe << 13;   \/\/ xorshift\n+            probe ^= probe >>> 17;\n+            probe ^= probe << 5;\n+            dummy += switch(objectArray[Math.abs(probe) % objectArray.length]) {\n+            case I01 inst -> 1;\n+            case I02 inst -> 2;\n+            case I03 inst -> 3;\n+            case I04 inst -> 4;\n+            case I05 inst -> 5;\n+            case I06 inst -> 6;\n+            case I07 inst -> 7;\n+            case I08 inst -> 8;\n+            default -> 10;\n+            };\n+            probe ^= probe << 13;   \/\/ xorshift\n+            probe ^= probe >>> 17;\n+            probe ^= probe << 5;\n+            dummy += switch(objectArray[Math.abs(probe) % objectArray.length]) {\n+            case I18 inst -> 8;\n+            case I17 inst -> 7;\n+            case I16 inst -> 6;\n+            case I15 inst -> 5;\n+            case I14 inst -> 4;\n+            case I13 inst -> 3;\n+            case I12 inst -> 2;\n+            case I11 inst -> 1;\n+            default -> 0;\n+            };\n+        }\n+        return dummy;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/TypePollution.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}