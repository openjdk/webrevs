{"files":[{"patch":"@@ -544,0 +544,17 @@\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ Consider the following expression:\n+  \/\/  x \/ 100_000 >= 21_475, x in TypeInt::INT\n+  \/\/ This will always be false since max_jint \/ 100_000 == 21_474.\n+  \/\/ After transform_int_divide, we have a Sub node to round towards 0.\n+  \/\/ That means we subtract -1 if the dividend is negative, and 0 otherwise.\n+  \/\/ As the Sub node is not aware of representing a division, it overapproximates\n+  \/\/ [-21_475, 21_474] - [-1, 0] = [-21_475, 21_475], which prevents constant folding.\n+  \/\/\n+  \/\/ Less precise comparisons still work after transform_int_divide, e.g.,\n+  \/\/ comparing with >= 21_476 does not conflict with the off-by-one overapproximation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n@@ -650,0 +667,8 @@\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ See DivINode::Ideal for an explanation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n@@ -1097,0 +1122,1 @@\n+\n@@ -1098,1 +1124,15 @@\n-  if( !ti->is_con() ) return nullptr;\n+  if (!ti->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ Consider the following expression:\n+  \/\/  x % 2, x in TypeInt::INT\n+  \/\/ With ModINode::Value, we can trivially tell the resulting range is [-1,1].\n+  \/\/ After idealizing, we have a subtraction from x, which means without\n+  \/\/ recognizing that as a modulo operation, we end up with a range of TypeInt::INT.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n@@ -1393,1 +1433,12 @@\n-  if( !tl->is_con() ) return nullptr;\n+  if (!tl->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ See ModINode::Ideal for an explanation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8356813\n+ * @bug 8356813 8366815\n@@ -57,0 +57,2 @@\n+        \"positiveDivisor\", \"positiveDivisor2\",\n+        \"negativeDivisor\", \"negativeDivisor2\",\n@@ -82,0 +84,4 @@\n+        Asserts.assertEQ(x % POS_INT >= POS_INT, positiveDivisor(x));\n+        Asserts.assertEQ(x % POS_INT <= -POS_INT, positiveDivisor2(x));\n+        Asserts.assertEQ(x % NEG_INT <= NEG_INT, negativeDivisor(x));\n+        Asserts.assertEQ(x % NEG_INT > -(NEG_INT + 1), negativeDivisor2(x));\n@@ -140,0 +146,33 @@\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always smaller than the positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor(int x) {\n+        return x % POS_INT >= POS_INT;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always bigger than the negated positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor2(int x) {\n+        return x % POS_INT <= -POS_INT;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always smaller than the negated negative divisor with exception if MIN_VALUE.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor(int x) {\n+        \/\/ > with + 1 to avoid -MIN_VALUE == MIN_VALUE\n+        return x % NEG_INT > -(NEG_INT + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always bigger than the negative divisor.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor2(int x) {\n+        return x % NEG_INT <= NEG_INT;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModINodeValueTests.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @bug 8356813\n+ * @bug 8356813 8366815\n@@ -56,0 +56,2 @@\n+        \"positiveDivisor\", \"positiveDivisor2\",\n+        \"negativeDivisor\", \"negativeDivisor2\",\n@@ -81,0 +83,4 @@\n+        Asserts.assertEQ(x % POS_LONG >= POS_LONG, positiveDivisor(x));\n+        Asserts.assertEQ(x % POS_LONG <= -POS_LONG, positiveDivisor2(x));\n+        Asserts.assertEQ(x % NEG_LONG <= NEG_LONG, negativeDivisor(x));\n+        Asserts.assertEQ(x % NEG_LONG > -(NEG_LONG + 1), negativeDivisor2(x));\n@@ -139,0 +145,33 @@\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always smaller than the positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor(long x) {\n+        return x % POS_LONG >= POS_LONG;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always bigger than the negated positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor2(long x) {\n+        return x % POS_LONG <= -POS_LONG;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always smaller than the negated negative divisor with exception if MIN_VALUE.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor(long x) {\n+        \/\/ > with + 1 to avoid -MIN_VALUE == MIN_VALUE\n+        return x % NEG_LONG > -(NEG_LONG + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always bigger than the negative divisor.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor2(long x) {\n+        return x % NEG_LONG <= NEG_LONG;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModLNodeValueTests.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}