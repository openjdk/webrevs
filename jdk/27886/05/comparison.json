{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,0 +640,17 @@\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ Consider the following expression:\n+  \/\/  x \/ 100_000 >= 21_475, x in TypeInt::INT\n+  \/\/ This will always be false since max_jint \/ 100_000 == 21_474.\n+  \/\/ After transform_int_divide, we have a Sub node to round towards 0.\n+  \/\/ That means we subtract -1 if the dividend is negative, and 0 otherwise.\n+  \/\/ As the Sub node is not aware of representing a division, it overapproximates\n+  \/\/ [-21_475, 21_474] - [-1, 0] = [-21_475, 21_475], which prevents constant folding.\n+  \/\/\n+  \/\/ Less precise comparisons still work after transform_int_divide, e.g.,\n+  \/\/ comparing with >= 21_476 does not conflict with the off-by-one overapproximation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n@@ -707,0 +724,8 @@\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ See DivINode::Ideal for an explanation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n@@ -1111,0 +1136,1 @@\n+\n@@ -1112,1 +1138,15 @@\n-  if( !ti->is_con() ) return nullptr;\n+  if (!ti->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ Consider the following expression:\n+  \/\/  x % 2, x in TypeInt::INT\n+  \/\/ With ModINode::Value, we can trivially tell the resulting range is [-1,1].\n+  \/\/ After idealizing, we have a subtraction from x, which means without\n+  \/\/ recognizing that as a modulo operation, we end up with a range of TypeInt::INT.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n@@ -1407,1 +1447,12 @@\n-  if( !tl->is_con() ) return nullptr;\n+  if (!tl->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Keep this node as-is initially; we want Value() and\n+  \/\/ other optimizations checking for this node type to work.\n+  \/\/ See ModINode::Ideal for an explanation.\n+  if (!can_reshape) {\n+    phase->C->record_for_igvn(this);\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @bug 8356813\n+ * @bug 8356813 8366815\n@@ -57,0 +57,2 @@\n+        \"positiveDivisor\", \"positiveDivisor2\",\n+        \"negativeDivisor\", \"negativeDivisor2\",\n@@ -82,0 +84,4 @@\n+        Asserts.assertEQ(x % POS_INT >= POS_INT, positiveDivisor(x));\n+        Asserts.assertEQ(x % POS_INT <= -POS_INT, positiveDivisor2(x));\n+        Asserts.assertEQ(x % NEG_INT <= NEG_INT, negativeDivisor(x));\n+        Asserts.assertEQ(x % NEG_INT > -(NEG_INT + 1), negativeDivisor2(x));\n@@ -140,0 +146,33 @@\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always smaller than the positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor(int x) {\n+        return x % POS_INT >= POS_INT;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always bigger than the negated positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor2(int x) {\n+        return x % POS_INT <= -POS_INT;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always smaller than the negated negative divisor with exception if MIN_VALUE.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor(int x) {\n+        \/\/ > with + 1 to avoid -MIN_VALUE == MIN_VALUE\n+        return x % NEG_INT > -(NEG_INT + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I, IRNode.AND_I, IRNode.RSHIFT_I})\n+    \/\/ The result is always bigger than the negative divisor.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor2(int x) {\n+        return x % NEG_INT <= NEG_INT;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModINodeValueTests.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @bug 8356813\n+ * @bug 8356813 8366815\n@@ -56,0 +56,2 @@\n+        \"positiveDivisor\", \"positiveDivisor2\",\n+        \"negativeDivisor\", \"negativeDivisor2\",\n@@ -81,0 +83,4 @@\n+        Asserts.assertEQ(x % POS_LONG >= POS_LONG, positiveDivisor(x));\n+        Asserts.assertEQ(x % POS_LONG <= -POS_LONG, positiveDivisor2(x));\n+        Asserts.assertEQ(x % NEG_LONG <= NEG_LONG, negativeDivisor(x));\n+        Asserts.assertEQ(x % NEG_LONG > -(NEG_LONG + 1), negativeDivisor2(x));\n@@ -139,0 +145,33 @@\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always smaller than the positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor(long x) {\n+        return x % POS_LONG >= POS_LONG;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always bigger than the negated positive divisor.\n+    \/\/ Constant fold to false.\n+    public boolean positiveDivisor2(long x) {\n+        return x % POS_LONG <= -POS_LONG;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always smaller than the negated negative divisor with exception if MIN_VALUE.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor(long x) {\n+        \/\/ > with + 1 to avoid -MIN_VALUE == MIN_VALUE\n+        return x % NEG_LONG > -(NEG_LONG + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L, IRNode.AND_L, IRNode.RSHIFT_L})\n+    \/\/ The result is always bigger than the negative divisor.\n+    \/\/ Constant fold to false.\n+    public boolean negativeDivisor2(long x) {\n+        return x % NEG_LONG <= NEG_LONG;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModLNodeValueTests.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @bug 8364766\n+ * @bug 8364766 8366815\n@@ -281,5 +281,1 @@\n-    \/\/@IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n-    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n-    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n-    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n-    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n@@ -299,6 +295,1 @@\n-    \/\/@IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n-    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n-    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n-    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n-    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n-    @IR(counts = {IRNode.RSHIFT_L, \"> 0\", IRNode.ADD_L, \"> 0\", IRNode.AND_L, \"> 0\"}, failOn = {IRNode.DIV})\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/IntegerDivValueTests.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"}]}