{"files":[{"patch":"@@ -517,1 +517,33 @@\n-    return 0;\n+    \/\/ We don't use StubRoutines::aarch64::spin_wait stub in order to\n+    \/\/ avoid a costly call to os::current_thread_enable_wx() on MacOS.\n+    \/\/ We should return 1 if SpinPause is implemented, and since there\n+    \/\/ will be a sequence of 11 instructions for NONE and YIELD and 12\n+    \/\/ instructions for NOP and ISB, SpinPause will always return 1.\n+    uint64_t br_dst;\n+    const int instructions_per_case = 2;\n+    int64_t off = VM_Version::spin_wait_desc().inst() * instructions_per_case * Assembler::instruction_size;\n+\n+    assert(VM_Version::spin_wait_desc().inst() >= SpinWait::NONE &&\n+           VM_Version::spin_wait_desc().inst() <= SpinWait::YIELD, \"should be\");\n+    assert(-1 == SpinWait::NONE,  \"should be\");\n+    assert( 0 == SpinWait::NOP,   \"should be\");\n+    assert( 1 == SpinWait::ISB,   \"should be\");\n+    assert( 2 == SpinWait::YIELD, \"should be\");\n+\n+    asm volatile(\n+        \"  adr  %[d], 20          \\n\" \/\/ 20 == PC here + 5 instructions => adress\n+                                      \/\/ to entry for case SpinWait::NOP\n+        \"  add  %[d], %[d], %[o]  \\n\"\n+        \"  br   %[d]              \\n\"\n+        \"  b    SpinPause_return  \\n\" \/\/ case SpinWait::NONE  (-1)\n+        \"  nop                    \\n\" \/\/ padding\n+        \"  nop                    \\n\" \/\/ case SpinWait::NOP   ( 0)\n+        \"  b    SpinPause_return  \\n\"\n+        \"  isb                    \\n\" \/\/ case SpinWait::ISB   ( 1)\n+        \"  b    SpinPause_return  \\n\"\n+        \"  yield                  \\n\" \/\/ case SpinWait::YIELD ( 2)\n+        \"SpinPause_return:        \\n\"\n+        : [d]\"=&r\"(br_dst)\n+        : [o]\"r\"(off)\n+        : \"memory\");\n+    return 1;\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}