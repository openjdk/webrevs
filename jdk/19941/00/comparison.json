{"files":[{"patch":"@@ -809,0 +809,3 @@\n+    \/**\n+     * Receives a datagram into a direct buffer.\n+     *\/\n@@ -815,0 +818,1 @@\n+            long bufAddress = NIO_ACCESS.getBufferAddress(bb);\n@@ -816,1 +820,2 @@\n-                             ((DirectBuffer)bb).address() + pos, rem,\n+                             bufAddress + pos,\n+                             rem,\n@@ -994,0 +999,3 @@\n+    \/**\n+     * Send a datagram contained in a direct buffer.\n+     *\/\n@@ -1006,0 +1014,1 @@\n+            long bufAddress = NIO_ACCESS.getBufferAddress(bb);\n@@ -1007,2 +1016,5 @@\n-            written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,\n-                            targetSockAddr.address(), addressLen);\n+            written = send0(fd,\n+                            bufAddress + pos,\n+                            rem,\n+                            targetSockAddr.address(),\n+                            addressLen);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,494 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333849\n+ * @summary Test ByteChannel implementations of read and write with ByteBuffers that are\n+ *    backed by MemorySegments allocated from an Arena\n+ * @run junit MemorySegments\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Random;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MemorySegments {\n+    private static final int SIZE = 100;   \/\/ buffer size used by tests\n+\n+    \/**\n+     * Return a stream of suppliers for each Arena type. A supplier is used to avoid JUnit\n+     * closing the Arena and failing (as some Arenas are not closable).\n+     *\/\n+    static Stream<Supplier<Arena>> arenaSuppliers() {\n+        return Stream.of(Arena::global, Arena::ofAuto, Arena::ofConfined, Arena::ofShared);\n+    }\n+\n+    \/**\n+     * SocketChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ write\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+                int nwritten = sc1.write(src);\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ read\n+                ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+                int nread = sc2.read(dst);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * SocketChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ gathering write\n+                ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+                fillRandom(src);\n+                ByteBuffer src1 = src.slice(0, SIZE);\n+                ByteBuffer src2 = src.slice(SIZE, SIZE);\n+                var srcs = new ByteBuffer[] { src1, src2 };\n+                int nwritten = (int) sc1.write(srcs);\n+                assertTrue(nwritten > 0);\n+                assertEquals(Math.min(nwritten, SIZE), src1.position());\n+                assertEquals(nwritten, src1.position() + src2.position());\n+\n+                \/\/ read\n+                ByteBuffer dst = arena.allocate(SIZE * 2 + 50).asByteBuffer();\n+                int nread = sc2.read(dst);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * SocketChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ write\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+                int nwritten = sc1.write(src);\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ scattering read\n+                ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+                ByteBuffer dst1 = dst.slice(0, 50);\n+                ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+                var dsts = new ByteBuffer[]{ dst1, dst2 };\n+                int nread = (int) sc2.read(dsts);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertTrue(dst1.position() > 0);\n+                assertEquals(nread, dst1.position() + dst2.position());\n+\n+                \/\/ check contents\n+                src.flip();\n+                assertEquals(src, dst.slice(0, nread));\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel send\/receive(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelSendReceive(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+\n+            \/\/ send\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int n = dc.send(src, target);\n+            assertEquals(SIZE, n);\n+            assertFalse(src.hasRemaining());\n+\n+            \/\/ receive\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            SocketAddress remote = dc.receive(dst);\n+            assertEquals(remote, target);\n+            assertEquals(SIZE, dst.position());\n+\n+            \/\/ check contents\n+            src.clear();\n+            dst.flip();\n+            assertEquals(src, dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int n = dc.write(src);\n+            assertEquals(SIZE, n);\n+            assertFalse(src.hasRemaining());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            n = dc.read(dst);\n+            assertEquals(SIZE, n);\n+            assertEquals(SIZE, dst.position());\n+\n+            \/\/ check contents\n+            src.clear();\n+            dst.flip();\n+            assertEquals(src, dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ gathering write\n+            ByteBuffer src1 = arena.allocate(SIZE).asByteBuffer();\n+            ByteBuffer src2 = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src1);\n+            fillRandom(src2);\n+            var srcs = new ByteBuffer[] { src1, src2 };\n+            int nwritten = (int) dc.write(srcs);\n+            assertEquals(SIZE*2, nwritten);\n+            assertFalse(src1.hasRemaining());\n+            assertFalse(src2.hasRemaining());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE*2 + 50).asByteBuffer();\n+            int nread = dc.read(dst);\n+            assertEquals(SIZE*2, nread);\n+            assertEquals(SIZE*2, dst.position());\n+\n+            \/\/ check contents\n+            src1.flip();\n+            src2.flip();\n+            assertEquals(src1, dst.slice(0, SIZE));\n+            assertEquals(src2, dst.slice(SIZE, SIZE));\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE*2).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = dc.write(src);\n+            assertEquals(SIZE*2, nwritten);\n+            assertEquals(nwritten, src.position());\n+\n+            \/\/ scattering read\n+            ByteBuffer dst1 = arena.allocate(SIZE).asByteBuffer();\n+            ByteBuffer dst2 = arena.allocate(SIZE + 50).asByteBuffer();\n+            var dsts = new ByteBuffer[] { dst1, dst2 };\n+            int nread = (int) dc.read(dsts);\n+            assertEquals(SIZE*2, nread);\n+            assertEquals(nread, dst1.position() + dst2.position());\n+\n+            \/\/ check contents\n+            dst1.flip();\n+            assertEquals(src.slice(0, SIZE), dst1);\n+            dst2.flip();\n+            assertEquals(src.slice(SIZE, SIZE), dst2);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\".\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = fc.write(src);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            fc.position(0);\n+            int nread = fc.read(dst);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+\n+            \/\/ reset\n+            fc.truncate(0L);\n+            src.clear();\n+            dst.clear();\n+\n+            \/\/ write with position\n+            nwritten = fc.write(src, 10L);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(0, (int) fc.position());\n+            assertEquals(nwritten + 10, (int) fc.size());\n+\n+            \/\/ read with position\n+            nread = fc.read(dst, 10L);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(0, (int)fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\"\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ gathering write\n+            ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+            fillRandom(src);\n+            ByteBuffer src1 = src.slice(0, SIZE);\n+            ByteBuffer src2 = src.slice(SIZE, SIZE);\n+            var srcs = new ByteBuffer[] { src1, src2 };\n+            int nwritten = (int) fc.write(srcs);\n+            assertTrue(nwritten > 0);\n+            assertEquals(Math.min(nwritten, SIZE), src1.position());\n+            assertEquals(nwritten, src1.position() + src2.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE*2 + 50).asByteBuffer();\n+            fc.position(0);\n+            int nread = fc.read(dst);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\"\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = fc.write(src);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ scattering read\n+            ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+            ByteBuffer dst1 = dst.slice(0, 50);\n+            ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+            var dsts = new ByteBuffer[] { dst1, dst2 };\n+            fc.position(0);\n+            int nread = (int) fc.read(dsts);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertTrue(dst1.position() > 0);\n+            assertEquals(nread, dst1.position() + dst2.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.limit(nread);\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * Fill the buffer with random bytes.\n+     *\/\n+    private void fillRandom(ByteBuffer bb) {\n+        Random r = new Random();\n+        int pos = bb.position();\n+        while (bb.hasRemaining()) {\n+            bb.put((byte) r.nextInt(256));\n+        }\n+        bb.position(pos);\n+    }\n+\n+    \/**\n+     * Attempt to close the given Arena.\n+     *\/\n+    private boolean tryClose(Arena arena) {\n+        try {\n+            arena.close();\n+            return true;\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/MemorySegments.java","additions":494,"deletions":0,"binary":false,"changes":494,"status":"added"}]}