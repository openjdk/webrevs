{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,119 @@\n+    \/**\n+     * Returns a {@code Reader} that reads characters from a\n+     * {@code CharSequence}, starting at the first character in the sequence.\n+     *\n+     * <p> The resulting reader is not safe for use by multiple\n+     * concurrent threads. If the reader is to be used by more than one\n+     * thread it should be controlled by appropriate synchronization.\n+     *\n+     * <p> The returned reader is initially open. The reader is closed by\n+     * calling the {@code close()} method. Subsequent calls to {@code close()}\n+     * have no effect.\n+     *\n+     * <p> After the reader has been closed, the {@code read()},\n+     * {@code read(char[])}, {@code read(char[], int, int)},\n+     * {@code read(CharBuffer)}, {@code ready()}, {@code skip(long)}, and\n+     * {@code transferTo()} methods all throw {@code IOException}.\n+     *\n+     * <p> The returned reader supports the {@link #mark mark()} operation.\n+     *\n+     * @param cs {@code CharSequence} providing the character stream.\n+     *\n+     * @return a {@code Reader} which reads characters from {@code cs}\n+     *\n+     * @throws NullPointerException if {@code cs} is {@code null}\n+     *\n+     * @since 24\n+     *\/\n+    public static Reader of(final CharSequence cs) {\n+        Objects.requireNonNull(cs);\n+\n+        return new Reader() {\n+            private final int length = cs.length();\n+            private boolean isClosed;\n+            private int next = 0;\n+            private int mark = 0;\n+\n+            \/** Check to make sure that the stream has not been closed *\/\n+            private void ensureOpen() throws IOException {\n+                if (isClosed)\n+                    throw new IOException(\"Stream closed\");\n+            }\n+\n+            @Override\n+            public int read() throws IOException {\n+                ensureOpen();\n+                if (next >= length)\n+                    return -1;\n+                return cs.charAt(next++);\n+            }\n+\n+            @Override\n+            public int read(char[] cbuf, int off, int len) throws IOException {\n+                ensureOpen();\n+                Objects.checkFromIndexSize(off, len, cbuf.length);\n+                if (len == 0) {\n+                    return 0;\n+                }\n+                if (next >= length)\n+                    return -1;\n+                int n = Math.min(length - next, len);\n+                switch (cs) {\n+                    case String s -> s.getChars(next, next + n, cbuf, off);\n+                    case StringBuilder sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case StringBuffer sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case CharBuffer cb -> cb.get(next, cbuf, off, n);\n+                    default -> {\n+                        for (int i = 0; i < n; i++)\n+                            cbuf[off + i] = cs.charAt(next + i);\n+                    }\n+                }\n+                next += n;\n+                return n;\n+            }\n+\n+            @Override\n+            public long skip(long n) throws IOException {\n+                ensureOpen();\n+                if (next >= length)\n+                    return 0;\n+                \/\/ Bound skip by beginning and end of the source\n+                long r = Math.min(length - next, n);\n+                r = Math.max(-next, r);\n+                next += (int)r;\n+                return r;\n+            }\n+\n+            @Override\n+            public boolean ready() throws IOException {\n+                ensureOpen();\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean markSupported() {\n+                return true;\n+            }\n+\n+            @Override\n+            public void mark(int readAheadLimit) throws IOException {\n+                if (readAheadLimit < 0){\n+                    throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n+                }\n+                ensureOpen();\n+                mark = next;\n+            }\n+\n+            @Override\n+            public void reset() throws IOException {\n+                ensureOpen();\n+                next = mark;\n+            }\n+\n+            @Override\n+            public void close() {\n+                isClosed = true;\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":120,"deletions":1,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,7 @@\n+ * @apiNote\n+ * As of release JDK 24, this class has been supplemented with an equivalent\n+ * API designed for use by a single thread, {@link Reader#of(CharSequence)}.\n+ * {@code Reader.of(String)} should generally be used in preference to this one,\n+ * as it supports all of the same operations but it is faster, as it performs no\n+ * synchronization.\n+ *\n@@ -39,4 +46,1 @@\n-    private final int length;\n-    private String str;\n-    private int next = 0;\n-    private int mark = 0;\n+    private final Reader r;\n@@ -50,8 +54,1 @@\n-        this.length = s.length();\n-        this.str = s;\n-    }\n-\n-    \/** Check to make sure that the stream has not been closed *\/\n-    private void ensureOpen() throws IOException {\n-        if (str == null)\n-            throw new IOException(\"Stream closed\");\n+        r = Reader.of(s);\n@@ -70,4 +67,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return -1;\n-            return str.charAt(next++);\n+            return r.read();\n@@ -97,11 +91,1 @@\n-            ensureOpen();\n-            Objects.checkFromIndexSize(off, len, cbuf.length);\n-            if (len == 0) {\n-                return 0;\n-            }\n-            if (next >= length)\n-                return -1;\n-            int n = Math.min(length - next, len);\n-            str.getChars(next, next + n, cbuf, off);\n-            next += n;\n-            return n;\n+            return r.read(cbuf, off, len);\n@@ -133,8 +117,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return 0;\n-            \/\/ Bound skip by beginning and end of the source\n-            long r = Math.min(length - next, n);\n-            r = Math.max(-next, r);\n-            next += (int)r;\n-            return r;\n+            return r.skip(n);\n@@ -153,2 +130,1 @@\n-            ensureOpen();\n-            return true;\n+            return r.ready();\n@@ -179,3 +155,0 @@\n-        if (readAheadLimit < 0){\n-            throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n-        }\n@@ -183,2 +156,1 @@\n-            ensureOpen();\n-            mark = next;\n+            r.mark(readAheadLimit);\n@@ -196,2 +168,1 @@\n-            ensureOpen();\n-            next = mark;\n+            r.reset();\n@@ -210,1 +181,5 @@\n-            str = null;\n+            try {\n+                r.close();\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/io\/StringReader.java","additions":21,"deletions":46,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.ReadOnlyBufferException;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8341566\n+ * @run testng Of\n+ * @summary Check for expected behavior of Reader.of().\n+ *\/\n+public class Of {\n+    final static String CONTENT = \"Some Reader Test\";\n+\n+    \/*\n+     * Readers to be tested.\n+     *\/\n+    @DataProvider\n+    public static Reader[] readers() {\n+        return new Reader[] {\n+            new StringReader(CONTENT),\n+            Reader.of(CONTENT),\n+            Reader.of(new StringBuffer(CONTENT)),\n+            Reader.of(new StringBuilder(CONTENT)),\n+            Reader.of(ByteBuffer.allocateDirect(CONTENT.length() * 2)\n+                    .asCharBuffer().put(CONTENT).flip()),\n+            Reader.of(CharBuffer.wrap(CONTENT.toCharArray())),\n+            Reader.of(new CharSequence() {\n+                @Override\n+                public char charAt(int index) {\n+                    return CONTENT.charAt(index);\n+                }\n+\n+                @Override\n+                public int length() {\n+                    return CONTENT.length();\n+                }\n+\n+                @Override\n+                public CharSequence subSequence(int start, int end) {\n+                    \/\/ unused by Reader.Of's result\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    \/\/ Reader.Of's result SHALL NOT convert to String\n+                    throw new UnsupportedOperationException();\n+                }\n+            })\n+        };\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testRead(Reader reader) throws IOException {\n+        String s = \"\";\n+        for (int c; (c = reader.read()) != -1; s += (char) c);\n+        assertEquals(s, CONTENT, \"read() returned wrong value\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBII(Reader reader) throws IOException {\n+        char[] c = new char[16];\n+        assertEquals(reader.read(c, 8, 8), 8,\n+                \"read(char[],int,int) does not respect given start or end\");\n+        assertEquals(reader.read(c, 0, 16), 8,\n+                \"read(char[],int,int) does not respect end of stream\");\n+        assertEquals(new String(c),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(char[],int,int) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBIILenZero(Reader reader) throws IOException {\n+        assertEquals(reader.read(new char[1], 0, 0), 0,\n+                \"read(char[],int,int) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = ByteBuffer.allocateDirect(32).asCharBuffer();\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                \/\/ last part first proofs that copy loops correctly stopped\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadNonDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(16);\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadCharBufferZeroRemaining(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        assertEquals(reader.read(charBuffer), 0, \"read(CharBuffer) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReady(Reader reader) throws IOException {\n+        assertTrue(reader.ready());\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testSkip(Reader reader) throws IOException {\n+        assertEquals(reader.skip(8), 8, \"skip() does not respect limit\");\n+        assertEquals(reader.skip(9), 8, \"skip() does not respect end of stream\");\n+        assertEquals(reader.skip(1), 0, \"skip() does not respect empty stream\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testTransferTo(Reader reader) throws IOException {\n+        StringWriter sw = new StringWriter(16);\n+        assertEquals(reader.transferTo(sw), 16, \"transferTo() != 16\");\n+        assertEquals(reader.transferTo(sw), 0,\n+                \"transferTo() does not respect empty stream\");\n+        assertEquals(sw.toString(), CONTENT,\n+                \"transferTo() provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.read();\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadBIIClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.read(new char[1], 0, 1);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadCharBufferClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(1);\n+        reader.close();\n+        reader.read(charBuffer);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadCharBufferZeroRemainingClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        reader.close();\n+        reader.read(charBuffer);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadyClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.ready();\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testSkipClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.skip(1);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testTransferToClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.transferTo(new StringWriter(1));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testCloseClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/Of.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"}]}