{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,202 @@\n+    \/**\n+     * Returns a new {@code Reader} whose source is a {@link CharSequence}.\n+     *\n+     * <p> The returned reader's class provides an API compatible with\n+     * {@link StringReader}, but with no guarantee of synchronization, and\n+     * without limitation to {@code String} sources. This class is designed for\n+     * use as a drop-in replacement for {@code StringReader} in places where the\n+     * reader was being used by a single thread (as is generally the case).\n+     * Where possible, it is recommended that this class be used in preference\n+     * to {@code StringReader} as it will be faster under most implementations.\n+     *\n+     * <p> The returned stream is initially open. The stream is closed by\n+     * calling the {@code close()} method. Subsequent calls to {@code close()}\n+     * have no effect.\n+     *\n+     * <p> After the stream has been closed, the {@code read()},\n+     * {@code read(char[])}, {@code read(char[], int, int)},\n+     * {@code read(CharBuffer)}, {@code ready()}, {@code skip(long)}, and\n+     * {@code transferTo()} methods all throw {@code IOException}.\n+     *\n+     * <p> The {@code markSupported()} method returns {@code true}.\n+     *\n+     * <p> The {@link #lock object} used to synchronize operations on the\n+     * returned {@code Reader} is not specified.\n+     *\n+     * @param c {@code CharSequence} providing the character stream.\n+     *\n+     * @return a {@code Reader} which reads characters from {@code c}\n+     *\n+     * @since 24\n+     *\/\n+    public static Reader of(CharSequence c) {\n+        return new Reader() {\n+            private final int length = c.length();\n+            private CharSequence cs = c;\n+            private int next = 0;\n+            private int mark = 0;\n+\n+            \/** Check to make sure that the stream has not been closed *\/\n+            private void ensureOpen() throws IOException {\n+                if (cs == null)\n+                    throw new IOException(\"Stream closed\");\n+            }\n+\n+            \/**\n+             * Reads a single character.\n+             *\n+             * @return     The character read, or -1 if the end of the stream has been\n+             *             reached\n+             *\n+             * @throws     IOException  If an I\/O error occurs\n+             *\/\n+            @Override\n+            public int read() throws IOException {\n+                ensureOpen();\n+                if (next >= length)\n+                    return -1;\n+                return cs.charAt(next++);\n+            }\n+\n+            \/**\n+             * Reads characters into a portion of an array.\n+             *\n+             * <p> If {@code len} is zero, then no characters are read and {@code 0} is\n+             * returned; otherwise, there is an attempt to read at least one character.\n+             * If no character is available because the stream is at its end, the value\n+             * {@code -1} is returned; otherwise, at least one character is read and\n+             * stored into {@code cbuf}.\n+             *\n+             * @param      cbuf  {@inheritDoc}\n+             * @param      off   {@inheritDoc}\n+             * @param      len   {@inheritDoc}\n+             *\n+             * @return     {@inheritDoc}\n+             *\n+             * @throws     IndexOutOfBoundsException  {@inheritDoc}\n+             * @throws     IOException  {@inheritDoc}\n+             *\/\n+            @Override\n+            public int read(char[] cbuf, int off, int len) throws IOException {\n+                ensureOpen();\n+                Objects.checkFromIndexSize(off, len, cbuf.length);\n+                if (len == 0) {\n+                    return 0;\n+                }\n+                if (next >= length)\n+                    return -1;\n+                int n = Math.min(length - next, len);\n+                switch (cs) {\n+                    case String s -> s.getChars(next, next + n, cbuf, off);\n+                    case StringBuilder sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case StringBuffer sb -> sb.getChars(next, next + n, cbuf, off);\n+                    case CharBuffer cb -> cb.get(next, cbuf, off, n);\n+                    default -> {\n+                        for (int i = 0; i < n; i++)\n+                            cbuf[off + i] = cs.charAt(next + i);\n+                    }\n+                }\n+                next += n;\n+                return n;\n+            }\n+\n+            \/**\n+             * Skips characters. If the stream is already at its end before this method\n+             * is invoked, then no characters are skipped and zero is returned.\n+             *\n+             * <p>The {@code n} parameter may be negative, even though the\n+             * {@code skip} method of the {@link Reader} superclass throws\n+             * an exception in this case. Negative values of {@code n} cause the\n+             * stream to skip backwards. Negative return values indicate a skip\n+             * backwards. It is not possible to skip backwards past the beginning of\n+             * the string.\n+             *\n+             * <p>If the entire string has been read or skipped, then this method has\n+             * no effect and always returns {@code 0}.\n+             *\n+             * @param n {@inheritDoc}\n+             *\n+             * @return {@inheritDoc}\n+             *\n+             * @throws IOException {@inheritDoc}\n+             *\/\n+            @Override\n+            public long skip(long n) throws IOException {\n+                ensureOpen();\n+                if (next >= length)\n+                    return 0;\n+                \/\/ Bound skip by beginning and end of the source\n+                long r = Math.min(length - next, n);\n+                r = Math.max(-next, r);\n+                next += (int)r;\n+                return r;\n+            }\n+\n+            \/**\n+             * Tells whether this stream is ready to be read.\n+             *\n+             * @return True if the next read() is guaranteed not to block for input\n+             *\n+             * @throws     IOException  If the stream is closed\n+             *\/\n+            @Override\n+            public boolean ready() throws IOException {\n+                ensureOpen();\n+                return true;\n+            }\n+\n+            \/**\n+             * Tells whether this stream supports the mark() operation, which it does.\n+             *\/\n+            @Override\n+            public boolean markSupported() {\n+                return true;\n+            }\n+\n+            \/**\n+             * Marks the present position in the stream.  Subsequent calls to reset()\n+             * will reposition the stream to this point.\n+             *\n+             * @param  readAheadLimit  Limit on the number of characters that may be\n+             *                         read while still preserving the mark.  Because\n+             *                         the stream's input comes from a string, there\n+             *                         is no actual limit, so this argument must not\n+             *                         be negative, but is otherwise ignored.\n+             *\n+             * @throws     IllegalArgumentException  If {@code readAheadLimit < 0}\n+             * @throws     IOException  If an I\/O error occurs\n+             *\/\n+            @Override\n+            public void mark(int readAheadLimit) throws IOException {\n+                if (readAheadLimit < 0){\n+                    throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n+                }\n+                ensureOpen();\n+                mark = next;\n+            }\n+\n+            \/**\n+             * Resets the stream to the most recent mark, or to the beginning of the\n+             * string if it has never been marked.\n+             *\n+             * @throws     IOException  If an I\/O error occurs\n+             *\/\n+            @Override\n+            public void reset() throws IOException {\n+                ensureOpen();\n+                next = mark;\n+            }\n+\n+            \/**\n+             * Closes the stream and releases any system resources associated with\n+             * it. Once the stream has been closed, further read(),\n+             * ready(), mark(), or reset() invocations will throw an IOException.\n+             * Closing a previously closed stream has no effect.\n+             *\/\n+            @Override\n+            public void close() {\n+                cs = null;\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":203,"deletions":1,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,6 @@\n+ * As of release JDK 24, this class has been supplemented with an equivalent\n+ * API designed for use by a single thread, {@link Reader#of(CharSequence)}.\n+ * {@code Reader.of(String)} should generally be used in preference to this one,\n+ * as it supports all of the same operations but it is faster, as it performs no\n+ * synchronization.\n+ *\n@@ -39,4 +45,1 @@\n-    private final int length;\n-    private String str;\n-    private int next = 0;\n-    private int mark = 0;\n+    private final Reader r;\n@@ -50,8 +53,1 @@\n-        this.length = s.length();\n-        this.str = s;\n-    }\n-\n-    \/** Check to make sure that the stream has not been closed *\/\n-    private void ensureOpen() throws IOException {\n-        if (str == null)\n-            throw new IOException(\"Stream closed\");\n+        r = Reader.of(s);\n@@ -70,4 +66,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return -1;\n-            return str.charAt(next++);\n+            return r.read();\n@@ -97,11 +90,1 @@\n-            ensureOpen();\n-            Objects.checkFromIndexSize(off, len, cbuf.length);\n-            if (len == 0) {\n-                return 0;\n-            }\n-            if (next >= length)\n-                return -1;\n-            int n = Math.min(length - next, len);\n-            str.getChars(next, next + n, cbuf, off);\n-            next += n;\n-            return n;\n+            return r.read(cbuf, off, len);\n@@ -133,8 +116,1 @@\n-            ensureOpen();\n-            if (next >= length)\n-                return 0;\n-            \/\/ Bound skip by beginning and end of the source\n-            long r = Math.min(length - next, n);\n-            r = Math.max(-next, r);\n-            next += (int)r;\n-            return r;\n+            return r.skip(n);\n@@ -153,2 +129,1 @@\n-            ensureOpen();\n-            return true;\n+            return r.ready();\n@@ -179,3 +154,0 @@\n-        if (readAheadLimit < 0){\n-            throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n-        }\n@@ -183,2 +155,1 @@\n-            ensureOpen();\n-            mark = next;\n+            r.mark(readAheadLimit);\n@@ -196,2 +167,1 @@\n-            ensureOpen();\n-            next = mark;\n+            r.reset();\n@@ -210,1 +180,5 @@\n-            str = null;\n+            try {\n+                r.close();\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/io\/StringReader.java","additions":20,"deletions":46,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.ReadOnlyBufferException;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8341566\n+ * @run testng Of\n+ * @summary Check for expected behavior of Reader.of().\n+ *\/\n+public class Of {\n+    final static String CONTENT = \"Some Reader Test\";\n+\n+    \/*\n+     * Readers to be tested.\n+     *\/\n+    @DataProvider\n+    public static Reader[] readers() {\n+        return new Reader[] {\n+            new StringReader(CONTENT),\n+            Reader.of(CONTENT),\n+            Reader.of(new StringBuffer(CONTENT)),\n+            Reader.of(new StringBuilder(CONTENT)),\n+            Reader.of(ByteBuffer.allocateDirect(CONTENT.length() * 2)\n+                    .asCharBuffer().put(CONTENT).flip()),\n+            Reader.of(CharBuffer.wrap(CONTENT.toCharArray()))\n+        };\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testOpen(Reader reader) {\n+        assertNotNull(reader, \"Reader.of(String) returned null\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testRead(Reader reader) throws IOException {\n+        String s = \"\";\n+        for (int c; (c = reader.read()) != -1; s += (char) c);\n+        assertEquals(s, CONTENT, \"read() returned wrong value\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBII(Reader reader) throws IOException {\n+        char[] c = new char[16];\n+        assertEquals(reader.read(c, 8, 8), 8,\n+                \"read(char[],int,int) does not respect given start or end\");\n+        assertEquals(reader.read(c, 0, 16), 8,\n+                \"read(char[],int,int) does not respect end of stream\");\n+        assertEquals(new String(c),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(char[],int,int) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadBIILenZero(Reader reader) throws IOException {\n+        assertEquals(reader.read(new char[1], 0, 0), 0,\n+                \"read(char[],int,int) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = ByteBuffer.allocateDirect(32).asCharBuffer();\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                \/\/ last part first proofs that copy loops correctly stopped\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadNonDirectCharBuffer(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(16);\n+        charBuffer.position(8);\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect position or limit\");\n+        charBuffer.rewind();\n+        assertEquals(reader.read(charBuffer), 8,\n+                \"read(CharBuffer) does not respect end of stream\");\n+        charBuffer.rewind();\n+        assertEquals(charBuffer.toString(),\n+                CONTENT.substring(8, 16) + CONTENT.substring(0, 8),\n+                \"read(CharBuffer) provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReadCharBufferZeroRemaining(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        assertEquals(reader.read(charBuffer), 0, \"read(CharBuffer) != 0\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testReady(Reader reader) throws IOException {\n+        assertTrue(reader.ready());\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testSkip(Reader reader) throws IOException {\n+        assertEquals(reader.skip(8), 8, \"skip() does not respect limit\");\n+        assertEquals(reader.skip(9), 8, \"skip() does not respect end of stream\");\n+        assertEquals(reader.skip(1), 0, \"skip() does not respect empty stream\");\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testTransferTo(Reader reader) throws IOException {\n+        StringWriter sw = new StringWriter(16);\n+        assertEquals(reader.transferTo(sw), 16, \"transferTo() != 16\");\n+        assertEquals(reader.transferTo(sw), 0,\n+                \"transferTo() does not resect empty stream\");\n+        assertEquals(sw.toString(), CONTENT,\n+                \"transferTo() provides wrong content\");\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.read();\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadBIIClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.read(new char[1], 0, 1);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadCharBufferClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(1);\n+        reader.close();\n+        reader.read(charBuffer);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadCharBufferZeroRemainingClosed(Reader reader) throws IOException {\n+        CharBuffer charBuffer = CharBuffer.allocate(0);\n+        reader.close();\n+        reader.read(charBuffer);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testReadyClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.ready();\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testSkipClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.skip(1);\n+    }\n+\n+    @Test(dataProvider = \"readers\", expectedExceptions = IOException.class)\n+    public void testTransferToClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.transferTo(new StringWriter(1));\n+    }\n+\n+    @Test(dataProvider = \"readers\")\n+    public void testCloseClosed(Reader reader) throws IOException {\n+        reader.close();\n+        reader.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Reader\/Of.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}