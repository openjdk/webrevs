{"files":[{"patch":"@@ -1618,1 +1618,99 @@\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n+bool PhaseIdealLoop::try_convert_to_counted_loop(Node* loop_head, IdealLoopTree*&loop, BasicType iv_bt) {\n+  return convert_to_counted_loop(loop_head, loop, iv_bt)\n+         || convert_to_counted_loop_with_speculative_long_limit(loop_head, loop, iv_bt);\n+}\n+\n+\/\/ When comparing an int incrementor with long limit, check if the limit is within int range. If so, treat it as an int\n+\/\/ counted loop but deoptimize if the limit is out of int range.\n+\/\/ This is common pattern with \"for (int i =...; i < long_limit; ...)\" where int \"i\" is implicitly promoted to long,\n+\/\/ i.e., \"(long) i < long_limit\", and therefore making it not an int counted loop without this transformation.\n+\/\/\n+\/\/ In summary, we transform\n+\/\/\n+\/\/  for (int i = 0; (long) i < long_limit; i++) {...}\n+\/\/\n+\/\/ to\n+\/\/\n+\/\/  if (int_min <= long_limit && long_limit <= int_max) {\n+\/\/    for (int i = 0; i < (int) long_limit; i++) {...}\n+\/\/  } else {\n+\/\/    trap: loop_limit_check\n+\/\/  }\n+bool PhaseIdealLoop::convert_to_counted_loop_with_speculative_long_limit(Node* loop_head, IdealLoopTree*&loop,\n+                                                                         BasicType iv_bt) {\n+  if (iv_bt != T_INT) {\n+    return false;\n+  }\n+\n+  Node* back_control = loop_exit_control(loop_head, loop);\n+  if (back_control == nullptr) {\n+    return false;\n+  }\n+\n+  Node* init_control = loop_head->in(LoopNode::EntryControl);\n+\n+  \/\/ Make sure there is a Loop Limit Check Parse Predicate for us to insert the Loop Limit Check Predicate above it.\n+  const Predicates predicates(init_control);\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+  if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n+#ifdef ASSERT\n+    if (TraceLoopLimitCheck) {\n+      tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n+      loop->dump_head();\n+      loop_head->dump(1);\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  BoolTest::mask bt = BoolTest::illegal;\n+  float cl_prob = 0;\n+  Node* incr = nullptr;\n+  Node* limit = nullptr;\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+  \/\/ Check exit test is a \"(long) i < long_limit\" pattern.\n+  if (cmp == nullptr || cmp->Opcode() != Op_CmpL || incr == nullptr || incr->Opcode() != Op_ConvI2L) {\n+    return false;\n+  }\n+\n+  ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n+  if (!is_dominator(get_ctrl(limit), loop_limit_check_parse_predicate->in(0))) {\n+    return false;\n+  }\n+\n+  \/\/ Replace exit test nodes. Need to revert changes if this still doesn't make it a counted loop.\n+  Node* new_incr = incr->in(1);\n+\n+  \/\/ Optimistically transform \"(long) i < long_limit\" to \"i < (int) long_limit\".\n+  Node* new_limit = _igvn.register_new_node_with_optimizer(new ConvL2INode(limit), limit);\n+  set_early_ctrl(new_limit, get_ctrl(limit));\n+\n+  Node* new_cmp = cmp->in(1) == incr ? new CmpINode(new_incr, new_limit) : new CmpINode(new_limit, new_incr);\n+  _igvn.register_new_node_with_optimizer(new_cmp, cmp);\n+  set_early_ctrl(new_cmp, get_ctrl(cmp));\n+\n+  \/\/ back_control[0] -> iff[1] -> bool[1] -> cmp\n+  Node* bol = back_control->in(0)->in(1);\n+  _igvn.rehash_node_delayed(bol);\n+  bol->replace_edge(cmp, new_cmp, &_igvn);\n+\n+  \/\/ Check if it's a counted loop after type conversion for the limit.\n+  if (!convert_to_counted_loop(loop_head, loop, iv_bt)) {\n+    \/\/ Revert back to the original cmp (and its associated incr and limit) node.\n+    _igvn.rehash_node_delayed(bol);\n+    bol->replace_edge(new_cmp, cmp, &_igvn);\n+    return false;\n+  }\n+\n+  assert(loop->is_invariant(new_limit), \"limit must be a loop invariant\");\n+\n+  \/\/ Optimistically assume limit in within int range, but add guards and traps to loop_limit_check.\n+  \/\/ i.e., deoptimize if \"(long) (int) long_limit == long_limit\" is false.\n+  Node* i2l_limit = _igvn.register_new_node_with_optimizer(new ConvI2LNode(new_limit));\n+  Node* cmp_limit = new CmpLNode(i2l_limit, limit);\n+  Node* bol_limit = new BoolNode(cmp_limit, BoolTest::eq);\n+  insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol_limit);\n+  return true;\n+}\n+\n+bool PhaseIdealLoop::convert_to_counted_loop(Node* loop_head, IdealLoopTree*&loop, BasicType iv_bt) {\n@@ -1621,1 +1719,1 @@\n-  Node* back_control = loop_exit_control(x, loop);\n+  Node* back_control = loop_exit_control(loop_head, loop);\n@@ -1631,0 +1729,1 @@\n+\n@@ -1641,1 +1740,1 @@\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n+  incr = loop_iv_incr(incr, loop_head, loop, phi_incr);\n@@ -1670,1 +1769,1 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+  PhiNode* phi = loop_iv_phi(xphi, phi_incr, loop_head, loop);\n@@ -1779,2 +1878,2 @@\n-  if (x->Opcode() == Op_Region) {\n-    \/\/ x has not yet been transformed to Loop or LongCountedLoop.\n+  if (loop_head->Opcode() == Op_Region) {\n+    \/\/ loop_head has not yet been transformed to Loop or LongCountedLoop.\n@@ -1787,2 +1886,2 @@\n-    assert(x->as_Region()->is_in_infinite_subgraph(),\n-           \"x can only be a Region and not Loop if inside infinite loop\");\n+    assert(loop_head->as_Region()->is_in_infinite_subgraph(),\n+           \"loop_head can only be a Region and not Loop if inside infinite loop\");\n@@ -1793,2 +1892,2 @@\n-  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n-  C->print_method(PHASE_BEFORE_CLOOPS, 3, x);\n+  assert(loop_head->Opcode() == Op_Loop || loop_head->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n+  C->print_method(PHASE_BEFORE_CLOOPS, 3, loop_head);\n@@ -2000,1 +2099,1 @@\n-  Node* init_control = x->in(LoopNode::EntryControl);\n+  Node* init_control = loop_head->in(LoopNode::EntryControl);\n@@ -2010,1 +2109,1 @@\n-    assert(!x->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n+    assert(!loop_head->as_Loop()->is_loop_nest_inner_loop(), \"loop was transformed\");\n@@ -2019,1 +2118,1 @@\n-        x->dump(1);\n+        loop_head->dump(1);\n@@ -2072,1 +2171,1 @@\n-        x->dump(1);\n+        loop_head->dump(1);\n@@ -2114,1 +2213,1 @@\n-    sfpt = find_safepoint(back_control, x, loop);\n+    sfpt = find_safepoint(back_control, loop_head, loop);\n@@ -2122,2 +2221,2 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    Node* backedge_sfpt = x->in(LoopNode::LoopBackControl);\n+  if (loop_head->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node* backedge_sfpt = loop_head->in(LoopNode::LoopBackControl);\n@@ -2145,1 +2244,1 @@\n-      !x->as_Loop()->is_loop_nest_inner_loop() &&\n+      !loop_head->as_Loop()->is_loop_nest_inner_loop() &&\n@@ -2268,1 +2367,1 @@\n-  l->set_unswitch_count(x->as_Loop()->unswitch_count()); \/\/ Preserve\n+  l->set_unswitch_count(loop_head->as_Loop()->unswitch_count()); \/\/ Preserve\n@@ -2278,1 +2377,1 @@\n-  lazy_replace( x, l );\n+  lazy_replace(loop_head, l );\n@@ -2337,1 +2436,1 @@\n-  if (x->as_Loop()->is_loop_nest_inner_loop() && iv_bt == T_LONG) {\n+  if (loop_head->as_Loop()->is_loop_nest_inner_loop() && iv_bt == T_LONG) {\n@@ -2341,1 +2440,1 @@\n-  if (iv_bt == T_LONG && x->as_Loop()->is_loop_nest_outer_loop()) {\n+  if (iv_bt == T_LONG && loop_head->as_Loop()->is_loop_nest_outer_loop()) {\n@@ -4156,1 +4255,1 @@\n-      phase->is_counted_loop(_head, loop, T_INT)) {\n+      phase->try_convert_to_counted_loop(_head, loop, T_INT)) {\n@@ -4170,1 +4269,1 @@\n-             phase->is_counted_loop(_head, loop, T_LONG)) {\n+             phase->try_convert_to_counted_loop(_head, loop, T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":123,"deletions":24,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -1226,1 +1226,4 @@\n-  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+  bool try_convert_to_counted_loop(Node* loop_head, IdealLoopTree*& loop, BasicType iv_bt);\n+ private:\n+  bool convert_to_counted_loop(Node* loop_head, IdealLoopTree*& loop, BasicType iv_bt);\n+  bool convert_to_counted_loop_with_speculative_long_limit(Node* loop_head, IdealLoopTree*& loop, BasicType iv_bt);\n@@ -1228,0 +1231,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8336759\n+ * @summary test long limits in int counted loops are speculatively converted to int for counted loop\n+ *         optimizations\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.TestIntCountedLoopLongLimit\n+ *\/\n+public class TestIntCountedLoopLongLimit {\n+    private static final Random RNG = Utils.getRandomInstance();\n+\n+    \/\/ Use a larger stride to avoid tests taking too long\n+    private static final int LARGE_STRIDE = Integer.MAX_VALUE \/ 1024;\n+    private static volatile long SOME_LONG = 42;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                \/\/ StressLongCountedLoop is only available in debug builds\n+                \"-XX:StressLongCountedLoop=0\", \/\/ Don't convert int counted loops to long ones\n+                \"-XX:PerMethodTrapLimit=100\" \/\/ allow slow-path loop limit checks\n+        );\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\" }) \/\/ Make sure IR tests can pick up counted loops.\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testControlledCountedLoop(int limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) {\n+            sum += i;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testCountedLoopWithLongLimit(long limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) {\n+            sum += i;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testCountedLoopWithSwappedComparisonOperand(long limit) {\n+        int sum = 0;\n+        for (int i = 0; limit > i; i++) {\n+            sum += i;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Test counted loops, regardless of limit types, are correctly constructed.\n+    @Run(test = { \"testControlledCountedLoop\", \"testCountedLoopWithLongLimit\",\n+            \"testCountedLoopWithSwappedComparisonOperand\" })\n+    public static void runTestSimpleCountedLoops(RunInfo info) {\n+        long limit = RNG.nextLong(0, 1024 * 1024); \/\/ Choose a small number to avoid tests taking too long\n+        int expected = testControlledCountedLoop((int) limit);\n+        int observed1 = testCountedLoopWithLongLimit(limit);\n+        int observed2 = testCountedLoopWithSwappedComparisonOperand(limit);\n+\n+        Asserts.assertEQ(expected, observed1);\n+        Asserts.assertEQ(expected, observed2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP }) \/\/ Eliminated by IR replacement\n+    public static int testIvReplacedCountedLoop(long limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) {\n+            sum += 1;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP }) \/\/ Eliminated by IR replacement\n+    public static long testLongIvReplacedCountedLoop(long limit) {\n+        long sum = 0;\n+        for (int i = 0; i < limit; i++) {\n+            sum += 1;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Test counted loops with int and long IV types, are corrected constructed, IV replaced, and eliminated.\n+    @Run(test = { \"testIvReplacedCountedLoop\", \"testLongIvReplacedCountedLoop\" })\n+    public static void runTestIvReplacedCountedLoop(RunInfo info) {\n+        long limit = RNG.nextLong(0, 1024 * 1024);\n+\n+        Asserts.assertEQ(limit, (long) testIvReplacedCountedLoop(limit));\n+        Asserts.assertEQ(limit, testLongIvReplacedCountedLoop(limit));\n+    }\n+\n+    \/\/ Test counted loop deoptimizes if the long limit falls outside int range.\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    public static int testCountedLoopWithOverflow(long limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i += LARGE_STRIDE) {\n+            sum += LARGE_STRIDE;\n+\n+            if (i < 0) {\n+                return -1; \/\/ overflow detected!\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    public static int testCountedLoopWithUnderflow(long limit) {\n+        int sum = 0;\n+        for (int i = 0; i > limit; i -= LARGE_STRIDE) {\n+            sum -= LARGE_STRIDE;\n+\n+            if (i > 0) {\n+                return 1; \/\/ underflow detected!\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Run(test = { \"testCountedLoopWithOverflow\", \"testCountedLoopWithUnderflow\" })\n+    public static void runTestCountedLoopWithOverflow(RunInfo info) {\n+        long limit = RNG.nextLong(0, 1024) * LARGE_STRIDE;\n+\n+        Asserts.assertEQ((int) limit, testCountedLoopWithOverflow(limit));\n+        Asserts.assertEQ((int) -limit, testCountedLoopWithUnderflow(-limit));\n+\n+        if (info.isTestC2Compiled(\"testCountedLoopWithOverflow\")) {\n+            Asserts.assertEQ(-1, testCountedLoopWithOverflow(Integer.MAX_VALUE));\n+            Asserts.assertEQ(-1, testCountedLoopWithOverflow(Integer.MAX_VALUE + 1L));\n+            Asserts.assertEQ(-1, testCountedLoopWithOverflow(Integer.MAX_VALUE + limit));\n+        }\n+\n+        if (info.isTestC2Compiled(\"testCountedLoopWithUnderflow\")) {\n+            Asserts.assertEQ(1, testCountedLoopWithUnderflow(Integer.MIN_VALUE));\n+            Asserts.assertEQ(1, testCountedLoopWithUnderflow(Integer.MIN_VALUE - 1L));\n+            System.out.println(Integer.MIN_VALUE - limit);\n+            Asserts.assertEQ(1, testCountedLoopWithUnderflow(Integer.MIN_VALUE - limit));\n+        }\n+    }\n+\n+    \/\/ Test optimization is not applied if the limit is not invariant.\n+    \/\/ This is handled by the existing counted loop detection, but we might as well test it here, too.\n+    @Test\n+    @IR(counts = { IRNode.CONV_I2L, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.CONV_L2I })\n+    @Arguments(values = { Argument.NUMBER_42 })\n+    public static int testLimitNotInvariant(long limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) {\n+            sum += 1;\n+            limit = SOME_LONG;\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIntCountedLoopLongLimit.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -197,1 +197,1 @@\n-        tests.put(\"testMemorySegmentBadExitCheck\",                 () -> testMemorySegmentBadExitCheck(copy(a)));\n+        tests.put(\"testIntLoop_iv_byte_long_limit\",                () -> testIntLoop_iv_byte_long_limit(copy(a)));\n@@ -356,1 +356,1 @@\n-    @Run(test = {\"testMemorySegmentBadExitCheck\",\n+    @Run(test = {\"testIntLoop_iv_byte_long_limit\",\n@@ -395,3 +395,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-                  IRNode.ADD_VB,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -400,1 +400,0 @@\n-    \/\/ FAILS\n@@ -402,3 +401,4 @@\n-    \/\/ Thus, we have an int-iv, but a long-exit-check.\n-    \/\/ Is not properly recognized by either CountedLoop or LongCountedLoop\n-    static Object[] testMemorySegmentBadExitCheck(MemorySegment a) {\n+    \/\/ Syntactically, we have an int-iv, but a long-exit-check.\n+    \/\/ With JDK-8336759, the exit condition is optimistically and speculatively converted to: iv < (int) long_limit\n+    \/\/ Making this case similar to the next one where counted loop optimizations are possible.\n+    static Object[] testIntLoop_iv_byte_long_limit(MemorySegment a) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}