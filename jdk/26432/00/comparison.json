{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.awt.Graphics2D;\n@@ -37,14 +36,0 @@\n-\n-import java.awt.print.PageFormat;\n-import java.awt.print.Paper;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-import java.awt.print.PrinterJob;\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-\n-import java.util.ArrayList;\n@@ -52,20 +37,2 @@\n-\n-import javax.print.PrintService;\n-import javax.print.attribute.HashPrintRequestAttributeSet;\n-import javax.print.attribute.PrintRequestAttributeSet;\n-import javax.print.attribute.Size2DSyntax;\n-import javax.print.attribute.standard.Chromaticity;\n-import javax.print.attribute.standard.Copies;\n-import javax.print.attribute.standard.Destination;\n-import javax.print.attribute.standard.DialogTypeSelection;\n-import javax.print.attribute.standard.DialogOwner;\n-import javax.print.attribute.standard.JobName;\n-import javax.print.attribute.standard.MediaSize;\n-import javax.print.attribute.standard.PrintQuality;\n-import javax.print.attribute.standard.SheetCollate;\n-import javax.print.attribute.standard.Sides;\n-import javax.print.attribute.standard.Media;\n-import javax.print.attribute.standard.OrientationRequested;\n-import javax.print.attribute.standard.MediaSizeName;\n-import javax.print.attribute.standard.PageRanges;\n-\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -80,69 +47,1 @@\n-public class PrintJob2D extends PrintJob implements Printable, Runnable {\n-\n-    private static final MediaType[] SIZES = {\n-        MediaType.ISO_4A0, MediaType.ISO_2A0, MediaType.ISO_A0,\n-        MediaType.ISO_A1, MediaType.ISO_A2, MediaType.ISO_A3,\n-        MediaType.ISO_A4, MediaType.ISO_A5, MediaType.ISO_A6,\n-        MediaType.ISO_A7, MediaType.ISO_A8, MediaType.ISO_A9,\n-        MediaType.ISO_A10, MediaType.ISO_B0, MediaType.ISO_B1,\n-        MediaType.ISO_B2, MediaType.ISO_B3, MediaType.ISO_B4,\n-        MediaType.ISO_B5, MediaType.ISO_B6, MediaType.ISO_B7,\n-        MediaType.ISO_B8, MediaType.ISO_B9, MediaType.ISO_B10,\n-        MediaType.JIS_B0, MediaType.JIS_B1, MediaType.JIS_B2,\n-        MediaType.JIS_B3, MediaType.JIS_B4, MediaType.JIS_B5,\n-        MediaType.JIS_B6, MediaType.JIS_B7, MediaType.JIS_B8,\n-        MediaType.JIS_B9, MediaType.JIS_B10, MediaType.ISO_C0,\n-        MediaType.ISO_C1, MediaType.ISO_C2, MediaType.ISO_C3,\n-        MediaType.ISO_C4, MediaType.ISO_C5, MediaType.ISO_C6,\n-        MediaType.ISO_C7, MediaType.ISO_C8, MediaType.ISO_C9,\n-        MediaType.ISO_C10, MediaType.ISO_DESIGNATED_LONG,\n-        MediaType.EXECUTIVE, MediaType.FOLIO, MediaType.INVOICE,\n-        MediaType.LEDGER, MediaType.NA_LETTER, MediaType.NA_LEGAL,\n-        MediaType.QUARTO, MediaType.A, MediaType.B,\n-        MediaType.C, MediaType.D, MediaType.E,\n-        MediaType.NA_10X15_ENVELOPE, MediaType.NA_10X14_ENVELOPE,\n-        MediaType.NA_10X13_ENVELOPE, MediaType.NA_9X12_ENVELOPE,\n-        MediaType.NA_9X11_ENVELOPE, MediaType.NA_7X9_ENVELOPE,\n-        MediaType.NA_6X9_ENVELOPE, MediaType.NA_NUMBER_9_ENVELOPE,\n-        MediaType.NA_NUMBER_10_ENVELOPE, MediaType.NA_NUMBER_11_ENVELOPE,\n-        MediaType.NA_NUMBER_12_ENVELOPE, MediaType.NA_NUMBER_14_ENVELOPE,\n-        MediaType.INVITE_ENVELOPE, MediaType.ITALY_ENVELOPE,\n-        MediaType.MONARCH_ENVELOPE, MediaType.PERSONAL_ENVELOPE\n-    };\n-\n-    \/* This array maps the above array to the objects used by the\n-     * javax.print APIs\n-         *\/\n-    private static final MediaSizeName[] JAVAXSIZES = {\n-        null, null, MediaSizeName.ISO_A0,\n-        MediaSizeName.ISO_A1, MediaSizeName.ISO_A2, MediaSizeName.ISO_A3,\n-        MediaSizeName.ISO_A4, MediaSizeName.ISO_A5, MediaSizeName.ISO_A6,\n-        MediaSizeName.ISO_A7, MediaSizeName.ISO_A8, MediaSizeName.ISO_A9,\n-        MediaSizeName.ISO_A10, MediaSizeName.ISO_B0, MediaSizeName.ISO_B1,\n-        MediaSizeName.ISO_B2, MediaSizeName.ISO_B3, MediaSizeName.ISO_B4,\n-        MediaSizeName.ISO_B5,  MediaSizeName.ISO_B6, MediaSizeName.ISO_B7,\n-        MediaSizeName.ISO_B8, MediaSizeName.ISO_B9, MediaSizeName.ISO_B10,\n-        MediaSizeName.JIS_B0, MediaSizeName.JIS_B1, MediaSizeName.JIS_B2,\n-        MediaSizeName.JIS_B3, MediaSizeName.JIS_B4, MediaSizeName.JIS_B5,\n-        MediaSizeName.JIS_B6, MediaSizeName.JIS_B7, MediaSizeName.JIS_B8,\n-        MediaSizeName.JIS_B9, MediaSizeName.JIS_B10, MediaSizeName.ISO_C0,\n-        MediaSizeName.ISO_C1, MediaSizeName.ISO_C2, MediaSizeName.ISO_C3,\n-        MediaSizeName.ISO_C4, MediaSizeName.ISO_C5, MediaSizeName.ISO_C6,\n-        null, null, null, null,\n-        MediaSizeName.ISO_DESIGNATED_LONG, MediaSizeName.EXECUTIVE,\n-        MediaSizeName.FOLIO, MediaSizeName.INVOICE, MediaSizeName.LEDGER,\n-        MediaSizeName.NA_LETTER, MediaSizeName.NA_LEGAL,\n-        MediaSizeName.QUARTO, MediaSizeName.A, MediaSizeName.B,\n-        MediaSizeName.C, MediaSizeName.D, MediaSizeName.E,\n-        MediaSizeName.NA_10X15_ENVELOPE, MediaSizeName.NA_10X14_ENVELOPE,\n-        MediaSizeName.NA_10X13_ENVELOPE, MediaSizeName.NA_9X12_ENVELOPE,\n-        MediaSizeName.NA_9X11_ENVELOPE, MediaSizeName.NA_7X9_ENVELOPE,\n-        MediaSizeName.NA_6X9_ENVELOPE,\n-        MediaSizeName.NA_NUMBER_9_ENVELOPE,\n-        MediaSizeName.NA_NUMBER_10_ENVELOPE,\n-        MediaSizeName.NA_NUMBER_11_ENVELOPE,\n-        MediaSizeName.NA_NUMBER_12_ENVELOPE,\n-        MediaSizeName.NA_NUMBER_14_ENVELOPE,\n-        null, MediaSizeName.ITALY_ENVELOPE,\n-        MediaSizeName.MONARCH_ENVELOPE, MediaSizeName.PERSONAL_ENVELOPE,\n-    };\n+public class PrintJob2D extends PrintJob {\n@@ -150,142 +49,1 @@\n-\n-    \/\/ widths and lengths in PostScript points (1\/72 in.)\n-    private static final int[] WIDTHS = {\n-        \/*iso-4a0*\/ 4768, \/*iso-2a0*\/ 3370, \/*iso-a0*\/ 2384, \/*iso-a1*\/ 1684,\n-        \/*iso-a2*\/ 1191, \/*iso-a3*\/ 842, \/*iso-a4*\/ 595, \/*iso-a5*\/ 420,\n-        \/*iso-a6*\/ 298, \/*iso-a7*\/ 210, \/*iso-a8*\/ 147, \/*iso-a9*\/ 105,\n-        \/*iso-a10*\/ 74, \/*iso-b0*\/ 2835, \/*iso-b1*\/ 2004, \/*iso-b2*\/ 1417,\n-        \/*iso-b3*\/ 1001, \/*iso-b4*\/ 709, \/*iso-b5*\/ 499, \/*iso-b6*\/ 354,\n-        \/*iso-b7*\/ 249, \/*iso-b8*\/ 176, \/*iso-b9*\/ 125, \/*iso-b10*\/ 88,\n-        \/*jis-b0*\/ 2920, \/*jis-b1*\/ 2064, \/*jis-b2*\/ 1460, \/*jis-b3*\/ 1032,\n-        \/*jis-b4*\/ 729, \/*jis-b5*\/ 516, \/*jis-b6*\/ 363, \/*jis-b7*\/ 258,\n-        \/*jis-b8*\/ 181, \/*jis-b9*\/ 128, \/*jis-b10*\/ 91, \/*iso-c0*\/ 2599,\n-        \/*iso-c1*\/ 1837, \/*iso-c2*\/ 1298, \/*iso-c3*\/ 918, \/*iso-c4*\/ 649,\n-        \/*iso-c5*\/ 459, \/*iso-c6*\/ 323, \/*iso-c7*\/ 230, \/*iso-c8*\/ 162,\n-        \/*iso-c9*\/ 113, \/*iso-c10*\/ 79, \/*iso-designated-long*\/ 312,\n-        \/*executive*\/ 522, \/*folio*\/ 612, \/*invoice*\/ 396, \/*ledger*\/ 792,\n-        \/*na-letter*\/ 612, \/*na-legal*\/ 612, \/*quarto*\/ 609, \/*a*\/ 612,\n-        \/*b*\/ 792, \/*c*\/ 1224, \/*d*\/ 1584, \/*e*\/ 2448,\n-        \/*na-10x15-envelope*\/ 720, \/*na-10x14-envelope*\/ 720,\n-        \/*na-10x13-envelope*\/ 720, \/*na-9x12-envelope*\/ 648,\n-        \/*na-9x11-envelope*\/ 648, \/*na-7x9-envelope*\/ 504,\n-        \/*na-6x9-envelope*\/ 432, \/*na-number-9-envelope*\/ 279,\n-        \/*na-number-10-envelope*\/ 297, \/*na-number-11-envelope*\/ 324,\n-        \/*na-number-12-envelope*\/ 342, \/*na-number-14-envelope*\/ 360,\n-        \/*invite-envelope*\/ 624, \/*italy-envelope*\/ 312,\n-        \/*monarch-envelope*\/ 279, \/*personal-envelope*\/ 261\n-    };\n-    private static final int[] LENGTHS = {\n-        \/*iso-4a0*\/ 6741, \/*iso-2a0*\/ 4768, \/*iso-a0*\/ 3370, \/*iso-a1*\/ 2384,\n-        \/*iso-a2*\/ 1684, \/*iso-a3*\/ 1191, \/*iso-a4*\/ 842, \/*iso-a5*\/ 595,\n-        \/*iso-a6*\/ 420, \/*iso-a7*\/ 298, \/*iso-a8*\/ 210, \/*iso-a9*\/ 147,\n-        \/*iso-a10*\/ 105, \/*iso-b0*\/ 4008, \/*iso-b1*\/ 2835, \/*iso-b2*\/ 2004,\n-        \/*iso-b3*\/ 1417, \/*iso-b4*\/ 1001, \/*iso-b5*\/ 729, \/*iso-b6*\/ 499,\n-        \/*iso-b7*\/ 354, \/*iso-b8*\/ 249, \/*iso-b9*\/ 176, \/*iso-b10*\/ 125,\n-        \/*jis-b0*\/ 4127, \/*jis-b1*\/ 2920, \/*jis-b2*\/ 2064, \/*jis-b3*\/ 1460,\n-        \/*jis-b4*\/ 1032, \/*jis-b5*\/ 729, \/*jis-b6*\/ 516, \/*jis-b7*\/ 363,\n-        \/*jis-b8*\/ 258, \/*jis-b9*\/ 181, \/*jis-b10*\/ 128, \/*iso-c0*\/ 3677,\n-        \/*iso-c1*\/ 2599, \/*iso-c2*\/ 1837, \/*iso-c3*\/ 1298, \/*iso-c4*\/ 918,\n-        \/*iso-c5*\/ 649, \/*iso-c6*\/ 459, \/*iso-c7*\/ 323, \/*iso-c8*\/ 230,\n-        \/*iso-c9*\/ 162, \/*iso-c10*\/ 113, \/*iso-designated-long*\/ 624,\n-        \/*executive*\/ 756, \/*folio*\/ 936, \/*invoice*\/ 612, \/*ledger*\/ 1224,\n-        \/*na-letter*\/ 792, \/*na-legal*\/ 1008, \/*quarto*\/ 780, \/*a*\/ 792,\n-        \/*b*\/ 1224, \/*c*\/ 1584, \/*d*\/ 2448, \/*e*\/ 3168,\n-        \/*na-10x15-envelope*\/ 1080, \/*na-10x14-envelope*\/ 1008,\n-        \/*na-10x13-envelope*\/ 936, \/*na-9x12-envelope*\/ 864,\n-        \/*na-9x11-envelope*\/ 792, \/*na-7x9-envelope*\/ 648,\n-        \/*na-6x9-envelope*\/ 648, \/*na-number-9-envelope*\/ 639,\n-        \/*na-number-10-envelope*\/ 684, \/*na-number-11-envelope*\/ 747,\n-        \/*na-number-12-envelope*\/ 792, \/*na-number-14-envelope*\/ 828,\n-        \/*invite-envelope*\/ 624, \/*italy-envelope*\/ 652,\n-        \/*monarch-envelope*\/ 540, \/*personal-envelope*\/ 468\n-    };\n-\n-\n-    private Frame frame;\n-    private String docTitle = \"\";\n-    private JobAttributes jobAttributes;\n-    private PageAttributes pageAttributes;\n-    private PrintRequestAttributeSet attributes;\n-\n-    \/*\n-     * Displays the native or cross-platform dialog and allows the\n-     * user to update job & page attributes\n-     *\/\n-\n-    \/**\n-     * The PrinterJob being uses to implement the PrintJob.\n-     *\/\n-    private PrinterJob printerJob;\n-\n-    \/**\n-     * The size of the page being used for the PrintJob.\n-     *\/\n-    private PageFormat pageFormat;\n-\n-    \/**\n-     * The PrinterJob and the application run on different\n-     * threads and communicate through a pair of message\n-     * queues. This queue is the list of Graphics that\n-     * the PrinterJob has requested rendering for, but\n-     * for which the application has not yet called getGraphics().\n-     * In practice the length of this message queue is always\n-     * 0 or 1.\n-     *\/\n-    private MessageQ graphicsToBeDrawn = new MessageQ(\"tobedrawn\");\n-\n-    \/**\n-     * Used to communicate between the application's thread\n-     * and the PrinterJob's thread this message queue holds\n-     * the list of Graphics into which the application has\n-     * finished drawing, but that have not yet been returned\n-     * to the PrinterJob thread. Again, in practice, the\n-     * length of this message queue is always 0 or 1.\n-     *\/\n-    private MessageQ graphicsDrawn = new MessageQ(\"drawn\");\n-\n-    \/**\n-     * The last Graphics returned to the application via\n-     * getGraphics. This is the Graphics into which the\n-     * application is currently drawing.\n-     *\/\n-    private Graphics2D currentGraphics;\n-\n-    \/**\n-     * The zero based index of the page currently being rendered\n-     * by the application.\n-     *\/\n-    private int pageIndex = -1;\n-\n-    \/\/ The following Strings are maintained for backward-compatibility with\n-    \/\/ Properties based print control.\n-    private static final String DEST_PROP = \"awt.print.destination\";\n-    private static final String PRINTER = \"printer\";\n-    private static final String FILE = \"file\";\n-\n-    private static final String PRINTER_PROP = \"awt.print.printer\";\n-\n-    private static final String FILENAME_PROP = \"awt.print.fileName\";\n-\n-    private static final String NUMCOPIES_PROP = \"awt.print.numCopies\";\n-\n-    private static final String OPTIONS_PROP = \"awt.print.options\";\n-\n-    private static final String ORIENT_PROP = \"awt.print.orientation\";\n-    private static final String PORTRAIT = \"portrait\";\n-    private static final String LANDSCAPE = \"landscape\";\n-\n-    private static final String PAPERSIZE_PROP = \"awt.print.paperSize\";\n-    private static final String LETTER = \"letter\";\n-    private static final String LEGAL = \"legal\";\n-    private static final String EXECUTIVE = \"executive\";\n-    private static final String A4 = \"a4\";\n-\n-    private Properties props;\n-\n-    private String options = \"\"; \/\/ REMIND: needs implementation\n-\n-    \/**\n-     * The thread on which PrinterJob is running.\n-     * This is different than the applications thread.\n-     *\/\n-    private Thread printerJobThread;\n+    private final PrintJobDelegate printJobDelegate;\n@@ -295,6 +53,1 @@\n-        this.props = props;\n-        this.jobAttributes = new JobAttributes();\n-        this.pageAttributes = new PageAttributes();\n-        translateInputProps();\n-        initPrintJob2D(frame, doctitle,\n-                       this.jobAttributes, this.pageAttributes);\n+        printJobDelegate = new PrintJobDelegate(frame, doctitle, props);\n@@ -306,1 +59,2 @@\n-        initPrintJob2D(frame, doctitle, jobAttributes, pageAttributes);\n+        printJobDelegate = new PrintJobDelegate(frame, doctitle, jobAttributes, pageAttributes);\n+        Disposer.addRecord(this, new PrintJobDisposerRecord(printJobDelegate));\n@@ -309,67 +63,0 @@\n-    private void initPrintJob2D(Frame frame,  String doctitle,\n-                                JobAttributes jobAttributes,\n-                                PageAttributes pageAttributes) {\n-\n-        if (frame == null &&\n-            (jobAttributes == null ||\n-             jobAttributes.getDialog() == DialogType.NATIVE)) {\n-            throw new NullPointerException(\"Frame must not be null\");\n-        }\n-        this.frame = frame;\n-\n-        this.docTitle = (doctitle == null) ? \"\" : doctitle;\n-        this.jobAttributes = (jobAttributes != null)\n-            ? jobAttributes : new JobAttributes();\n-        this.pageAttributes = (pageAttributes != null)\n-            ? pageAttributes : new PageAttributes();\n-\n-        \/\/ Currently, we always reduce page ranges to xxx or xxx-xxx\n-        int[][] pageRanges = this.jobAttributes.getPageRanges();\n-        int first = pageRanges[0][0];\n-        int last = pageRanges[pageRanges.length - 1][1];\n-        this.jobAttributes.setPageRanges(new int[][] {\n-            new int[] { first, last }\n-        });\n-        this.jobAttributes.setToPage(last);\n-        this.jobAttributes.setFromPage(first);\n-\n-\n-        \/\/ Verify that the cross feed and feed resolutions are the same\n-        int[] res = this.pageAttributes.getPrinterResolution();\n-        if (res[0] != res[1]) {\n-            throw new IllegalArgumentException(\"Differing cross feed and feed\"+\n-                                               \" resolutions not supported.\");\n-        }\n-\n-        \/\/ Verify that the app has access to the file system\n-        DestinationType dest= this.jobAttributes.getDestination();\n-        if (dest == DestinationType.FILE) {\n-\n-            \/\/ check if given filename is valid\n-            String destStr = jobAttributes.getFileName();\n-            if ((destStr != null) &&\n-                (jobAttributes.getDialog() == JobAttributes.DialogType.NONE)) {\n-\n-                File f = new File(destStr);\n-                try {\n-                    \/\/ check if this is a new file and if filename chars are valid\n-                    \/\/ createNewFile returns false if file exists\n-                    if (f.createNewFile()) {\n-                        f.delete();\n-                    }\n-                } catch (IOException ioe) {\n-                    throw new IllegalArgumentException(\"Cannot write to file:\"+\n-                                                       destStr);\n-                }\n-\n-                 File pFile = f.getParentFile();\n-                 if ((f.exists() &&\n-                      (!f.isFile() || !f.canWrite())) ||\n-                     ((pFile != null) &&\n-                      (!pFile.exists() || (pFile.exists() && !pFile.canWrite())))) {\n-                     throw new IllegalArgumentException(\"Cannot write to file:\"+\n-                                                        destStr);\n-                 }\n-            }\n-        }\n-    }\n@@ -377,0 +64,1 @@\n+    \/\/ PrintJob2D API, not PrintJob\n@@ -378,363 +66,1 @@\n-\n-        boolean proceedWithPrint = false;\n-\n-        printerJob = PrinterJob.getPrinterJob();\n-        if (printerJob == null) {\n-            return false;\n-        }\n-        DialogType d = this.jobAttributes.getDialog();\n-        PrintService pServ = printerJob.getPrintService();\n-        if ((pServ == null) &&  (d == DialogType.NONE)){\n-            return false;\n-        }\n-        copyAttributes(pServ);\n-\n-        DefaultSelectionType select =\n-            this.jobAttributes.getDefaultSelection();\n-        if (select == DefaultSelectionType.RANGE) {\n-            attributes.add(SunPageSelection.RANGE);\n-        } else if (select == DefaultSelectionType.SELECTION) {\n-            attributes.add(SunPageSelection.SELECTION);\n-        } else {\n-            attributes.add(SunPageSelection.ALL);\n-        }\n-\n-        if (frame != null) {\n-             attributes.add(new DialogOwner(frame));\n-         }\n-\n-        if ( d == DialogType.NONE) {\n-            proceedWithPrint = true;\n-        } else {\n-            if (d == DialogType.NATIVE) {\n-                attributes.add(DialogTypeSelection.NATIVE);\n-            }  else { \/\/  (d == DialogType.COMMON)\n-                attributes.add(DialogTypeSelection.COMMON);\n-            }\n-            if (proceedWithPrint = printerJob.printDialog(attributes)) {\n-                if (pServ == null) {\n-                    \/\/ Windows gives an option to install a service\n-                    \/\/ when it detects there are no printers so\n-                    \/\/ we make sure we get the updated print service.\n-                    pServ = printerJob.getPrintService();\n-                    if (pServ == null) {\n-                        return false;\n-                    }\n-                }\n-                updateAttributes();\n-                translateOutputProps();\n-            }\n-        }\n-\n-        if (proceedWithPrint) {\n-\n-            JobName jname = (JobName)attributes.get(JobName.class);\n-            if (jname != null) {\n-                printerJob.setJobName(jname.toString());\n-            }\n-\n-            pageFormat = new PageFormat();\n-\n-            Media media = (Media)attributes.get(Media.class);\n-            MediaSize mediaSize =  null;\n-            if (media instanceof MediaSizeName msn) {\n-                mediaSize = MediaSize.getMediaSizeForName(msn);\n-            }\n-\n-            Paper p = pageFormat.getPaper();\n-            if (mediaSize != null) {\n-                p.setSize(mediaSize.getX(MediaSize.INCH)*72.0,\n-                          mediaSize.getY(MediaSize.INCH)*72.0);\n-            }\n-\n-            if (pageAttributes.getOrigin()==OriginType.PRINTABLE) {\n-                \/\/ AWT uses 1\/4\" borders by default\n-                p.setImageableArea(18.0, 18.0,\n-                                   p.getWidth()-36.0,\n-                                   p.getHeight()-36.0);\n-            } else {\n-                p.setImageableArea(0.0,0.0,p.getWidth(),p.getHeight());\n-            }\n-\n-            pageFormat.setPaper(p);\n-\n-            OrientationRequested orient =\n-               (OrientationRequested)attributes.get(OrientationRequested.class);\n-            if (orient!= null &&\n-                orient == OrientationRequested.REVERSE_LANDSCAPE) {\n-                pageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n-            } else if (orient == OrientationRequested.LANDSCAPE) {\n-                pageFormat.setOrientation(PageFormat.LANDSCAPE);\n-            } else {\n-                pageFormat.setOrientation(PageFormat.PORTRAIT);\n-            }\n-\n-            PageRanges pageRangesAttr\n-                    = (PageRanges) attributes.get(PageRanges.class);\n-            if (pageRangesAttr != null) {\n-                \/\/ Get the PageRanges from print dialog.\n-                int[][] range = pageRangesAttr.getMembers();\n-\n-                int prevFromPage = this.jobAttributes.getFromPage();\n-                int prevToPage = this.jobAttributes.getToPage();\n-\n-                int currFromPage = range[0][0];\n-                int currToPage = range[range.length - 1][1];\n-\n-                \/\/ if from < to update fromPage first followed by toPage\n-                \/\/ else update toPage first followed by fromPage\n-                if (currFromPage < prevToPage) {\n-                    this.jobAttributes.setFromPage(currFromPage);\n-                    this.jobAttributes.setToPage(currToPage);\n-                } else {\n-                    this.jobAttributes.setToPage(currToPage);\n-                    this.jobAttributes.setFromPage(currFromPage);\n-                }\n-            }\n-            printerJob.setPrintable(this, pageFormat);\n-\n-        }\n-\n-        return proceedWithPrint;\n-    }\n-\n-    private void updateAttributes() {\n-        Copies c = (Copies)attributes.get(Copies.class);\n-        jobAttributes.setCopies(c.getValue());\n-\n-        SunPageSelection sel =\n-            (SunPageSelection)attributes.get(SunPageSelection.class);\n-        if (sel == SunPageSelection.RANGE) {\n-            jobAttributes.setDefaultSelection(DefaultSelectionType.RANGE);\n-        } else if (sel == SunPageSelection.SELECTION) {\n-            jobAttributes.setDefaultSelection(DefaultSelectionType.SELECTION);\n-        } else {\n-            jobAttributes.setDefaultSelection(DefaultSelectionType.ALL);\n-        }\n-\n-        Destination dest = (Destination)attributes.get(Destination.class);\n-        if (dest != null) {\n-            jobAttributes.setDestination(DestinationType.FILE);\n-            jobAttributes.setFileName(dest.getURI().getPath());\n-        } else {\n-            jobAttributes.setDestination(DestinationType.PRINTER);\n-        }\n-\n-        PrintService serv = printerJob.getPrintService();\n-        if (serv != null) {\n-            jobAttributes.setPrinter(serv.getName());\n-        }\n-\n-        PageRanges range = (PageRanges)attributes.get(PageRanges.class);\n-        int[][] members = range.getMembers();\n-        jobAttributes.setPageRanges(members);\n-\n-        SheetCollate collation =\n-            (SheetCollate)attributes.get(SheetCollate.class);\n-        if (collation == SheetCollate.COLLATED) {\n-            jobAttributes.setMultipleDocumentHandling(\n-            MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES);\n-        } else {\n-            jobAttributes.setMultipleDocumentHandling(\n-            MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES);\n-        }\n-\n-        Sides sides = (Sides)attributes.get(Sides.class);\n-        if (sides == Sides.TWO_SIDED_LONG_EDGE) {\n-            jobAttributes.setSides(SidesType.TWO_SIDED_LONG_EDGE);\n-        } else if (sides == Sides.TWO_SIDED_SHORT_EDGE) {\n-            jobAttributes.setSides(SidesType.TWO_SIDED_SHORT_EDGE);\n-        } else {\n-            jobAttributes.setSides(SidesType.ONE_SIDED);\n-        }\n-\n-        \/\/ PageAttributes\n-\n-        Chromaticity color =\n-            (Chromaticity)attributes.get(Chromaticity.class);\n-        if (color == Chromaticity.COLOR) {\n-            pageAttributes.setColor(ColorType.COLOR);\n-        } else {\n-            pageAttributes.setColor(ColorType.MONOCHROME);\n-        }\n-\n-        OrientationRequested orient =\n-            (OrientationRequested)attributes.get(OrientationRequested.class);\n-        if (orient == OrientationRequested.LANDSCAPE) {\n-            pageAttributes.setOrientationRequested(\n-                                       OrientationRequestedType.LANDSCAPE);\n-        } else {\n-            pageAttributes.setOrientationRequested(\n-                                       OrientationRequestedType.PORTRAIT);\n-        }\n-\n-        PrintQuality qual = (PrintQuality)attributes.get(PrintQuality.class);\n-        if (qual == PrintQuality.DRAFT) {\n-            pageAttributes.setPrintQuality(PrintQualityType.DRAFT);\n-        } else if (qual == PrintQuality.HIGH) {\n-            pageAttributes.setPrintQuality(PrintQualityType.HIGH);\n-        } else { \/\/ NORMAL\n-            pageAttributes.setPrintQuality(PrintQualityType.NORMAL);\n-        }\n-\n-        Media media = (Media)attributes.get(Media.class);\n-        if (media instanceof MediaSizeName msn) {\n-            MediaType mType = unMapMedia(msn);\n-\n-            if (mType != null) {\n-                pageAttributes.setMedia(mType);\n-            }\n-        }\n-        debugPrintAttributes(false, false);\n-    }\n-\n-    private void debugPrintAttributes(boolean ja, boolean pa ) {\n-        if (ja) {\n-            System.out.println(\"new Attributes\\ncopies = \"+\n-                               jobAttributes.getCopies()+\n-                               \"\\nselection = \"+\n-                               jobAttributes.getDefaultSelection()+\n-                               \"\\ndest \"+jobAttributes.getDestination()+\n-                               \"\\nfile \"+jobAttributes.getFileName()+\n-                               \"\\nfromPage \"+jobAttributes.getFromPage()+\n-                               \"\\ntoPage \"+jobAttributes.getToPage()+\n-                               \"\\ncollation \"+\n-                               jobAttributes.getMultipleDocumentHandling()+\n-                               \"\\nPrinter \"+jobAttributes.getPrinter()+\n-                               \"\\nSides2 \"+jobAttributes.getSides()\n-                               );\n-        }\n-\n-        if (pa) {\n-            System.out.println(\"new Attributes\\ncolor = \"+\n-                               pageAttributes.getColor()+\n-                               \"\\norientation = \"+\n-                               pageAttributes.getOrientationRequested()+\n-                               \"\\nquality \"+pageAttributes.getPrintQuality()+\n-                               \"\\nMedia2 \"+pageAttributes.getMedia()\n-                               );\n-        }\n-    }\n-\n-\n-    \/* From JobAttributes we will copy job name and duplex printing\n-     * and destination.\n-     * The majority of the rest of the attributes are reflected\n-     * attributes.\n-     *\n-     * From PageAttributes we copy color, media size, orientation,\n-     * origin type, resolution and print quality.\n-     * We use the media, orientation in creating the page format, and\n-     * the origin type to set its imageable area.\n-     *\n-     * REMIND: Interpretation of resolution, additional media sizes.\n-     *\/\n-    private void copyAttributes(PrintService printServ) {\n-\n-        attributes = new HashPrintRequestAttributeSet();\n-        attributes.add(new JobName(docTitle, null));\n-        PrintService pServ = printServ;\n-\n-        String printerName = jobAttributes.getPrinter();\n-        if (printerName != null && printerName != \"\"\n-            && pServ != null && !printerName.equals(pServ.getName())) {\n-\n-            \/\/ Search for the given printerName in the list of PrintServices\n-            PrintService []services = PrinterJob.lookupPrintServices();\n-            try {\n-                for (int i=0; i<services.length; i++) {\n-                    if (printerName.equals(services[i].getName())) {\n-                        printerJob.setPrintService(services[i]);\n-                        pServ = services[i];\n-                        break;\n-                    }\n-                }\n-            } catch (PrinterException pe) {\n-            }\n-        }\n-\n-        DestinationType dest = jobAttributes.getDestination();\n-        if (dest == DestinationType.FILE && pServ != null &&\n-            pServ.isAttributeCategorySupported(Destination.class)) {\n-\n-            String fileName = jobAttributes.getFileName();\n-\n-            Destination defaultDest;\n-            if (fileName == null && (defaultDest = (Destination)pServ.\n-                    getDefaultAttributeValue(Destination.class)) != null) {\n-                attributes.add(defaultDest);\n-            } else {\n-                URI uri = null;\n-                if (fileName != null) {\n-                    if (fileName.isEmpty()) {\n-                        fileName = \".\";\n-                    }\n-                } else {\n-                    \/\/ defaultDest should not be null.  The following code\n-                    \/\/ is only added to safeguard against a possible\n-                    \/\/ buggy implementation of a PrintService having a\n-                    \/\/ null default Destination.\n-                    fileName = \"out.prn\";\n-                }\n-                uri = (new File(fileName)).toURI();\n-                if (uri != null) {\n-                    attributes.add(new Destination(uri));\n-                }\n-            }\n-        }\n-        attributes.add(new SunMinMaxPage(jobAttributes.getMinPage(),\n-                                         jobAttributes.getMaxPage()));\n-        SidesType sType = jobAttributes.getSides();\n-        if (sType == SidesType.TWO_SIDED_LONG_EDGE) {\n-            attributes.add(Sides.TWO_SIDED_LONG_EDGE);\n-        } else if (sType == SidesType.TWO_SIDED_SHORT_EDGE) {\n-            attributes.add(Sides.TWO_SIDED_SHORT_EDGE);\n-        } else if (sType == SidesType.ONE_SIDED) {\n-            attributes.add(Sides.ONE_SIDED);\n-        }\n-\n-        MultipleDocumentHandlingType hType =\n-          jobAttributes.getMultipleDocumentHandling();\n-        if (hType ==\n-            MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES) {\n-          attributes.add(SheetCollate.COLLATED);\n-        } else {\n-          attributes.add(SheetCollate.UNCOLLATED);\n-        }\n-\n-        attributes.add(new Copies(jobAttributes.getCopies()));\n-\n-        attributes.add(new PageRanges(jobAttributes.getFromPage(),\n-                                      jobAttributes.getToPage()));\n-\n-        if (pageAttributes.getColor() == ColorType.COLOR) {\n-            attributes.add(Chromaticity.COLOR);\n-        } else {\n-            attributes.add(Chromaticity.MONOCHROME);\n-        }\n-\n-        pageFormat = printerJob.defaultPage();\n-        if (pageAttributes.getOrientationRequested() ==\n-            OrientationRequestedType.LANDSCAPE) {\n-            pageFormat.setOrientation(PageFormat.LANDSCAPE);\n-                attributes.add(OrientationRequested.LANDSCAPE);\n-        } else {\n-                pageFormat.setOrientation(PageFormat.PORTRAIT);\n-                attributes.add(OrientationRequested.PORTRAIT);\n-        }\n-\n-        MediaType media = pageAttributes.getMedia();\n-        MediaSizeName msn = mapMedia(media);\n-        if (msn != null) {\n-            attributes.add(msn);\n-        }\n-\n-        PrintQualityType qType =\n-            pageAttributes.getPrintQuality();\n-        if (qType == PrintQualityType.DRAFT) {\n-            attributes.add(PrintQuality.DRAFT);\n-        } else if (qType == PrintQualityType.NORMAL) {\n-            attributes.add(PrintQuality.NORMAL);\n-        } else if (qType == PrintQualityType.HIGH) {\n-            attributes.add(PrintQuality.HIGH);\n-        }\n+        return printJobDelegate.printDialog();\n@@ -751,78 +77,1 @@\n-\n-        Graphics printGraphics = null;\n-\n-        synchronized (this) {\n-            ++pageIndex;\n-\n-            \/\/ Thread should not be created after end has been called.\n-            \/\/ One way to detect this is if any of the graphics queue\n-            \/\/  has been closed.\n-            if (pageIndex == 0 && !graphicsToBeDrawn.isClosed()) {\n-\n-            \/* We start a thread on which the PrinterJob will run.\n-             * The PrinterJob will ask for pages on that thread\n-             * and will use a message queue to fulfill the application's\n-             * requests for a Graphics on the application's\n-             * thread.\n-             *\/\n-\n-                startPrinterJobThread();\n-\n-            }\n-            notify();\n-        }\n-\n-        \/* If the application has already been handed back\n-         * a graphics then we need to put that graphics into\n-         * the drawn queue so that the PrinterJob thread can\n-         * return to the print system.\n-         *\/\n-        if (currentGraphics != null) {\n-            graphicsDrawn.append(currentGraphics);\n-            currentGraphics = null;\n-        }\n-\n-        \/* We'll block here until a new graphics becomes\n-         * available.\n-         *\/\n-\n-        currentGraphics = graphicsToBeDrawn.pop();\n-\n-        if (currentGraphics instanceof PeekGraphics) {\n-            ( (PeekGraphics) currentGraphics).setAWTDrawingOnly();\n-            graphicsDrawn.append(currentGraphics);\n-            currentGraphics = graphicsToBeDrawn.pop();\n-        }\n-\n-\n-        if (currentGraphics != null) {\n-\n-            \/* In the PrintJob API, the origin is at the upper-\n-             * left of the imageable area when using the new \"printable\"\n-             * origin attribute, otherwise its the physical origin (for\n-             * backwards compatibility. We emulate this by creating\n-             * a PageFormat which matches and then performing the\n-             * translate to the origin. This is a no-op if physical\n-             * origin is specified.\n-             *\/\n-            currentGraphics.translate(pageFormat.getImageableX(),\n-                                      pageFormat.getImageableY());\n-\n-            \/* Scale to accommodate AWT's notion of printer resolution *\/\n-            double awtScale = 72.0\/getPageResolutionInternal();\n-            currentGraphics.scale(awtScale, awtScale);\n-\n-            \/* The caller wants a Graphics instance but we do\n-             * not want them to make 2D calls. We can't hand\n-             * back a Graphics2D. The returned Graphics also\n-             * needs to implement PrintGraphics, so we wrap\n-             * the Graphics2D instance. The PrintJob API has\n-             * the application dispose of the Graphics so\n-             * we create a copy of the one returned by PrinterJob.\n-             *\/\n-            printGraphics = new ProxyPrintGraphics(currentGraphics.create(),\n-                                                   this);\n-\n-        }\n-\n-        return printGraphics;\n+        return new ProxyPrintGraphics(printJobDelegate.getGraphics(), this);\n@@ -839,24 +88,1 @@\n-        double wid, hgt, scale;\n-        if (pageAttributes != null &&\n-            pageAttributes.getOrigin()==OriginType.PRINTABLE) {\n-            wid = pageFormat.getImageableWidth();\n-            hgt = pageFormat.getImageableHeight();\n-        } else {\n-            wid = pageFormat.getWidth();\n-            hgt = pageFormat.getHeight();\n-        }\n-        scale = getPageResolutionInternal() \/ 72.0;\n-        return new Dimension((int)(wid * scale), (int)(hgt * scale));\n-    }\n-\n-     private double getPageResolutionInternal() {\n-        if (pageAttributes != null) {\n-            int []res = pageAttributes.getPrinterResolution();\n-            if (res[2] == 3) {\n-                return res[0];\n-            } else \/* if (res[2] == 4) *\/ {\n-                return (res[0] * 2.54);\n-            }\n-        } else {\n-            return 72.0;\n-        }\n+        return printJobDelegate.getPageDimension();\n@@ -871,1 +97,1 @@\n-        return (int)getPageResolutionInternal();\n+        return printJobDelegate.getPageResolution();\n@@ -885,28 +111,1 @@\n-\n-        \/* Prevent the PrinterJob thread from appending any more\n-         * graphics to the to-be-drawn queue\n-         *\/\n-        graphicsToBeDrawn.close();\n-\n-        \/* If we have a currentGraphics it was the last one returned to the\n-         * PrintJob client. Append it to the drawn queue so that print()\n-         * will return allowing the page to be flushed.\n-         * This really ought to happen in dispose() but for whatever reason\n-         * that isn't how the old PrintJob worked even though its spec\n-         * said dispose() flushed the page.\n-         *\/\n-        if (currentGraphics != null) {\n-            graphicsDrawn.append(currentGraphics);\n-        }\n-        graphicsDrawn.closeWhenEmpty();\n-\n-        \/* Wait for the PrinterJob.print() thread to terminate, ensuring\n-         * that RasterPrinterJob has made its end doc call, and resources\n-         * are released, files closed etc.\n-         *\/\n-        if( printerJobThread != null && printerJobThread.isAlive() ){\n-            try {\n-                printerJobThread.join();\n-            } catch (InterruptedException e) {\n-            }\n-        }\n+        printJobDelegate.end();\n@@ -915,44 +114,2 @@\n-    \/**\n-     * Prints the page at the specified index into the specified\n-     * {@link Graphics} context in the specified\n-     * format.  A {@code PrinterJob} calls the\n-     * {@code Printable} interface to request that a page be\n-     * rendered into the context specified by\n-     * {@code graphics}.  The format of the page to be drawn is\n-     * specified by {@code pageFormat}.  The zero based index\n-     * of the requested page is specified by {@code pageIndex}.\n-     * If the requested page does not exist then this method returns\n-     * NO_SUCH_PAGE; otherwise PAGE_EXISTS is returned.\n-     * The {@code Graphics} class or subclass implements the\n-     * {@link java.awt.PrintGraphics} interface to provide additional\n-     * information.  If the {@code Printable} object\n-     * aborts the print job then it throws a {@link PrinterException}.\n-     * @param graphics the context into which the page is drawn\n-     * @param pageFormat the size and orientation of the page being drawn\n-     * @param pageIndex the zero based index of the page to be drawn\n-     * @return PAGE_EXISTS if the page is rendered successfully\n-     *         or NO_SUCH_PAGE if {@code pageIndex} specifies a\n-     *         non-existent page.\n-     * @throws java.awt.print.PrinterException\n-     *         thrown when the print job is terminated.\n-     *\/\n-    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex)\n-                 throws PrinterException {\n-\n-        int result;\n-\n-        \/* This method will be called by the PrinterJob on a thread other\n-         * that the application's thread. We hold on to the graphics\n-         * until we can rendezvous with the application's thread and\n-         * hand over the graphics. The application then does all the\n-         * drawing. When the application is done drawing we rendezvous\n-         * again with the PrinterJob thread and release the Graphics\n-         * so that it knows we are done.\n-         *\/\n-\n-        \/* Add the graphics to the message queue of graphics to\n-         * be rendered. This is really a one slot queue. The\n-         * application's thread will come along and remove the\n-         * graphics from the queue when the app asks for a graphics.\n-         *\/\n-        graphicsToBeDrawn.append( (Graphics2D) graphics);\n+    private static class PrintJobDisposerRecord implements DisposerRecord {\n+        private final PrintJobDelegate printJobDelegate;\n@@ -960,11 +117,2 @@\n-        \/* We now wait for the app's thread to finish drawing on\n-         * the Graphics. This thread will sleep until the application\n-         * release the graphics by placing it in the graphics drawn\n-         * message queue. If the application signals that it is\n-         * finished drawing the entire document then we'll get null\n-         * returned when we try and pop a finished graphic.\n-         *\/\n-        if (graphicsDrawn.pop() != null) {\n-            result = PAGE_EXISTS;\n-        } else {\n-            result = NO_SUCH_PAGE;\n+        PrintJobDisposerRecord(PrintJobDelegate delegate) {\n+            printJobDelegate = delegate;\n@@ -973,17 +121,2 @@\n-        return result;\n-    }\n-\n-    private void startPrinterJobThread() {\n-        printerJobThread =\n-            new Thread(null, this, \"printerJobThread\", 0, false);\n-        printerJobThread.start();\n-    }\n-\n-\n-    public void run() {\n-\n-        try {\n-            attributes.remove(PageRanges.class);\n-            printerJob.print(attributes);\n-        } catch (PrinterException e) {\n-            \/\/REMIND: need to store this away and not rethrow it.\n+        public void dispose() {\n+            printJobDelegate.end();\n@@ -991,6 +124,0 @@\n-\n-        \/* Close the message queues so that nobody is stuck\n-         * waiting for one.\n-         *\/\n-        graphicsToBeDrawn.closeWhenEmpty();\n-        graphicsDrawn.close();\n@@ -998,236 +125,0 @@\n-\n-    private static class MessageQ {\n-\n-        private String qid=\"noname\";\n-\n-        private ArrayList<Graphics2D> queue = new ArrayList<>();\n-\n-        MessageQ(String id) {\n-          qid = id;\n-        }\n-\n-        synchronized void closeWhenEmpty() {\n-\n-            while (queue != null && queue.size() > 0) {\n-                try {\n-                    wait(1000);\n-                } catch (InterruptedException e) {\n-                    \/\/ do nothing.\n-                }\n-            }\n-\n-            queue = null;\n-            notifyAll();\n-        }\n-\n-        synchronized void close() {\n-            queue = null;\n-            notifyAll();\n-        }\n-\n-        synchronized boolean append(Graphics2D g) {\n-\n-            boolean queued = false;\n-\n-            if (queue != null) {\n-                queue.add(g);\n-                queued = true;\n-                notify();\n-            }\n-\n-            return queued;\n-        }\n-\n-        synchronized Graphics2D pop() {\n-            Graphics2D g = null;\n-\n-            while (g == null && queue != null) {\n-\n-                if (queue.size() > 0) {\n-                    g = queue.remove(0);\n-                    notify();\n-\n-                } else {\n-                    try {\n-                        wait(2000);\n-                    } catch (InterruptedException e) {\n-                        \/\/ do nothing.\n-                    }\n-                }\n-            }\n-\n-            return g;\n-        }\n-\n-        synchronized boolean isClosed() {\n-            return queue == null;\n-        }\n-\n-    }\n-\n-\n-    private static int[] getSize(MediaType mType) {\n-        int []dim = new int[2];\n-        dim[0] = 612;\n-        dim[1] = 792;\n-\n-        for (int i=0; i < SIZES.length; i++) {\n-            if (SIZES[i] == mType) {\n-                dim[0] = WIDTHS[i];\n-                dim[1] = LENGTHS[i];\n-                break;\n-            }\n-        }\n-        return dim;\n-    }\n-\n-    public static MediaSizeName mapMedia(MediaType mType) {\n-        MediaSizeName media = null;\n-\n-        \/\/ JAVAXSIZES.length and SIZES.length must be equal!\n-        \/\/ Attempt to recover by getting the smaller size.\n-        int length = Math.min(SIZES.length, JAVAXSIZES.length);\n-\n-        for (int i=0; i < length; i++) {\n-            if (SIZES[i] == mType) {\n-                if ((JAVAXSIZES[i] != null) &&\n-                    MediaSize.getMediaSizeForName(JAVAXSIZES[i]) != null) {\n-                    media = JAVAXSIZES[i];\n-                    break;\n-                } else {\n-                    \/* create Custom Media *\/\n-                    media = new CustomMediaSizeName(SIZES[i].toString());\n-\n-                    float w = (float)Math.rint(WIDTHS[i]  \/ 72.0);\n-                    float h = (float)Math.rint(LENGTHS[i] \/ 72.0);\n-                    if (w > 0.0 && h > 0.0) {\n-                        \/\/ add new created MediaSize to our static map\n-                        \/\/ so it will be found when we call findMedia\n-                        new MediaSize(w, h, Size2DSyntax.INCH, media);\n-                    }\n-\n-                    break;\n-                }\n-            }\n-        }\n-        return media;\n-    }\n-\n-\n-    public static MediaType unMapMedia(MediaSizeName mSize) {\n-        MediaType media = null;\n-\n-        \/\/ JAVAXSIZES.length and SIZES.length must be equal!\n-        \/\/ Attempt to recover by getting the smaller size.\n-        int length = Math.min(SIZES.length, JAVAXSIZES.length);\n-\n-        for (int i=0; i < length; i++) {\n-            if (JAVAXSIZES[i] == mSize) {\n-                if (SIZES[i] != null) {\n-                    media = SIZES[i];\n-                    break;\n-                }\n-            }\n-        }\n-        return media;\n-    }\n-\n-    private void translateInputProps() {\n-        if (props == null) {\n-            return;\n-        }\n-\n-        String str;\n-\n-        str = props.getProperty(DEST_PROP);\n-        if (str != null) {\n-            if (str.equals(PRINTER)) {\n-                jobAttributes.setDestination(DestinationType.PRINTER);\n-            } else if (str.equals(FILE)) {\n-                jobAttributes.setDestination(DestinationType.FILE);\n-            }\n-        }\n-        str = props.getProperty(PRINTER_PROP);\n-        if (str != null) {\n-            jobAttributes.setPrinter(str);\n-        }\n-        str = props.getProperty(FILENAME_PROP);\n-        if (str != null) {\n-            jobAttributes.setFileName(str);\n-        }\n-        str = props.getProperty(NUMCOPIES_PROP);\n-        if (str != null) {\n-            jobAttributes.setCopies(Integer.parseInt(str));\n-        }\n-\n-        this.options = props.getProperty(OPTIONS_PROP, \"\");\n-\n-        str = props.getProperty(ORIENT_PROP);\n-        if (str != null) {\n-            if (str.equals(PORTRAIT)) {\n-                pageAttributes.setOrientationRequested(\n-                                        OrientationRequestedType.PORTRAIT);\n-            } else if (str.equals(LANDSCAPE)) {\n-                pageAttributes.setOrientationRequested(\n-                                        OrientationRequestedType.LANDSCAPE);\n-            }\n-        }\n-        str = props.getProperty(PAPERSIZE_PROP);\n-        if (str != null) {\n-            if (str.equals(LETTER)) {\n-                pageAttributes.setMedia(SIZES[MediaType.LETTER.hashCode()]);\n-            } else if (str.equals(LEGAL)) {\n-                pageAttributes.setMedia(SIZES[MediaType.LEGAL.hashCode()]);\n-            } else if (str.equals(EXECUTIVE)) {\n-                pageAttributes.setMedia(SIZES[MediaType.EXECUTIVE.hashCode()]);\n-            } else if (str.equals(A4)) {\n-                pageAttributes.setMedia(SIZES[MediaType.A4.hashCode()]);\n-            }\n-        }\n-    }\n-\n-    private void translateOutputProps() {\n-        if (props == null) {\n-            return;\n-        }\n-\n-        String str;\n-\n-        props.setProperty(DEST_PROP,\n-            (jobAttributes.getDestination() == DestinationType.PRINTER) ?\n-                          PRINTER : FILE);\n-        str = jobAttributes.getPrinter();\n-        if (str != null && !str.isEmpty()) {\n-            props.setProperty(PRINTER_PROP, str);\n-        }\n-        str = jobAttributes.getFileName();\n-        if (str != null && !str.isEmpty()) {\n-            props.setProperty(FILENAME_PROP, str);\n-        }\n-        int copies = jobAttributes.getCopies();\n-        if (copies > 0) {\n-            props.setProperty(NUMCOPIES_PROP, \"\" + copies);\n-        }\n-        str = this.options;\n-        if (str != null && !str.isEmpty()) {\n-            props.setProperty(OPTIONS_PROP, str);\n-        }\n-        props.setProperty(ORIENT_PROP,\n-            (pageAttributes.getOrientationRequested() ==\n-             OrientationRequestedType.PORTRAIT)\n-                          ? PORTRAIT : LANDSCAPE);\n-        MediaType media = SIZES[pageAttributes.getMedia().hashCode()];\n-        if (media == MediaType.LETTER) {\n-            str = LETTER;\n-        } else if (media == MediaType.LEGAL) {\n-            str = LEGAL;\n-        } else if (media == MediaType.EXECUTIVE) {\n-            str = EXECUTIVE;\n-        } else if (media == MediaType.A4) {\n-            str = A4;\n-        } else {\n-            str = media.toString();\n-        }\n-        props.setProperty(PAPERSIZE_PROP, str);\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","additions":20,"deletions":1129,"binary":false,"changes":1149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-public class PrintJob2D extends PrintJob implements Printable, Runnable {\n+public class PrintJobDelegate implements Printable, Runnable {\n@@ -293,1 +293,1 @@\n-    public PrintJob2D(Frame frame,  String doctitle,\n+    public PrintJobDelegate(Frame frame,  String doctitle,\n@@ -303,1 +303,1 @@\n-    public PrintJob2D(Frame frame,  String doctitle,\n+    public PrintJobDelegate(Frame frame,  String doctitle,\n@@ -823,3 +823,2 @@\n-            printGraphics = new ProxyPrintGraphics(currentGraphics.create(),\n-                                                   this);\n-\n+            \/\/printGraphics = new ProxyPrintGraphics(currentGraphics.create(), this);\n+            printGraphics =  currentGraphics.create();\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJobDelegate.java","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","status":"copied"}]}