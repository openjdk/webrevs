{"files":[{"patch":"@@ -103,1 +103,1 @@\n-     * @return an address layout with same characteristics as this layout, but with the provided target layout.\n+     * @return an address layout with the same characteristics as this layout, but with the provided target layout.\n@@ -117,1 +117,1 @@\n-     * @return an address layout with same characteristics as this layout, but with no target layout.\n+     * @return an address layout with the same characteristics as this layout, but with no target layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-     * aligned according the provided alignment constraint.\n+     * aligned according to the provided alignment constraint.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-     * @param addedLayouts the argument layouts to insert at given index.\n+     * @param addedLayouts the argument layouts to insert at the given index.\n@@ -103,1 +103,1 @@\n-     * necessary to specify how padding layout should be mapped to carrier types.\n+     * necessary to specify how padding layouts should be mapped to carrier types.\n@@ -124,1 +124,1 @@\n-     * Creates a function descriptor with the given argument layouts and no return layout.  This is useful to model functions\n+     * Creates a function descriptor with the given argument layouts and no return layout.  This is useful for modeling functions\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n+     * @apiNote the order in which member layouts are returned in the same order in which member layouts have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * Foreign functions typically reside in libraries that can be loaded on-demand. Each library conforms to\n+ * Foreign functions typically reside in libraries that can be loaded on demand. Each library conforms to\n@@ -52,1 +52,1 @@\n- * For any library which conforms to that ABI, the linker can mediate between Java code running\n+ * For any library that conforms to that ABI, the linker can mediate between Java code running\n@@ -109,1 +109,1 @@\n- * Scalar C types such as {@code bool}, {@code int} are modelled as {@linkplain ValueLayout value layouts}\n+ * Scalar C types such as {@code bool}, {@code int} are modeled as {@linkplain ValueLayout value layouts}\n@@ -113,1 +113,1 @@\n- * Composite types are modelled as {@linkplain GroupLayout group layouts}. More specifically, a C {@code struct} type\n+ * Composite types are modeled as {@linkplain GroupLayout group layouts}. More specifically, a C {@code struct} type\n@@ -117,1 +117,1 @@\n- * must be modelled explicitly, by adding an adequately sized {@linkplain PaddingLayout padding layout} member\n+ * must be modeled explicitly, by adding an adequately sized {@linkplain PaddingLayout padding layout} member\n@@ -120,1 +120,1 @@\n- * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are modelled as\n+ * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are modeled as\n@@ -123,1 +123,1 @@\n- * a pointer that is known to point to a C {@code int[2]} array can be modelled as an address layout whose\n+ * a pointer that is known to point to a C {@code int[2]} array can be modeled as an address layout whose\n@@ -147,1 +147,1 @@\n- * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * modeled using the canonical layouts associated with their corresponding signed integral types. For instance,\n@@ -151,1 +151,1 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64 according to the\n+ * The following table shows some examples of how C types are modeled in Linux\/x64 according to the\n@@ -249,1 +249,1 @@\n- * constraint less strict than its natural alignment. This allows avoiding padding between member layouts,\n+ * constraint less strict than its natural alignment. This allows for avoiding padding between member layouts,\n@@ -320,1 +320,1 @@\n- * the comparator method handle. We can now create an upcall stub which points to that method, and pass it, as a function\n+ * the comparator method handle. We can now create an upcall stub that points to that method, and pass it, as a function\n@@ -346,1 +346,1 @@\n- * The {@code malloc} function allocates a region of memory of given size,\n+ * The {@code malloc} function allocates a region of memory of a given size,\n@@ -418,1 +418,1 @@\n- * specifically, the obtained segment has the desired size, can only be accessed by a single thread (the thread which created\n+ * specifically, the obtained segment has the desired size, can only be accessed by a single thread (the thread that created\n@@ -423,1 +423,1 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * Variadic functions are C functions that can accept a variable number and type of arguments. They are declared with a\n@@ -438,1 +438,1 @@\n- * of default argument promotion is described in the C specification. In effect these promotions place limits on the\n+ * of default argument promotion is described in the C specification. In effect, these promotions place limits on the\n@@ -506,1 +506,1 @@\n- * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * that this address cannot become invalid after the upcall is completed. This can lead to unspecified behavior,\n@@ -532,1 +532,1 @@\n-     * Creates a method handle which is used to call a foreign function with the given signature and address.\n+     * Creates a method handle that is used to call a foreign function with the given signature and address.\n@@ -556,1 +556,1 @@\n-     * Creates a method handle which is used to call a foreign function with the given signature.\n+     * Creates a method handle that is used to call a foreign function with the given signature.\n@@ -663,1 +663,1 @@\n-     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * and canonical layouts exposed by the linker are unspecified; they vary from one {@link Linker} to another.\n@@ -790,1 +790,1 @@\n-         * Using this linker option is a hint which some implementations may use to apply\n+         * Using this linker option is a hint that some implementations may use to apply\n@@ -794,1 +794,1 @@\n-         * such as loss of performance, or JVM crashes.\n+         * such as loss of performance or JVM crashes.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n- * The above declaration can be modelled using a layout object, as follows:\n+ * The above declaration can be modeled using a layout object, as follows:\n@@ -91,1 +91,1 @@\n- *     has size of 8 bytes on a 64-bit platform;<\/li>\n+ *     has a size of 8 bytes on a 64-bit platform;<\/li>\n@@ -158,1 +158,1 @@\n- * Open path elements also affects the creation of\n+ * Open path elements also affect the creation of\n@@ -188,1 +188,1 @@\n- * This layout is a struct layout which describe a rectangle. It contains a single field, namely {@code points},\n+ * This layout is a struct layout that describe a rectangle. It contains a single field, namely {@code points},\n@@ -193,1 +193,1 @@\n- * With dereference path elements, we can obtain a var handle which accesses the {@code y} coordinate of one of the\n+ * With dereference path elements, we can obtain a var handle that accesses the {@code y} coordinate of one of the\n@@ -214,1 +214,1 @@\n- * layout path can be thought of as a function which updates the current layout {@code C_i-1} to some other layout\n+ * layout path can be thought of as a function that updates the current layout {@code C_i-1} to some other layout\n@@ -281,1 +281,1 @@\n- * While variable-length arrays cannot be modelled directly using sequence layouts, clients can still enjoy structured\n+ * While variable-length arrays cannot be modeled directly using sequence layouts, clients can still enjoy structured\n@@ -295,1 +295,1 @@\n- * In the above code, a point is modelled as two coordinates ({@code x} and {@code y} respectively). Now consider\n+ * In the above code, a point is modeled as two coordinates ({@code x} and {@code y} respectively). Now consider\n@@ -306,1 +306,1 @@\n- * Here, we allocate an array of point ({@code points}). Crucially, the size of the array is dynamically bound to the value\n+ * Here, we allocate an array of points ({@code points}). Crucially, the size of the array is dynamically bound to the value\n@@ -356,1 +356,1 @@\n- * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n+ * In the above code, a polygon is modeled as a size (the number of edges in the polygon) and an array of points\n@@ -561,1 +561,1 @@\n-     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     <li>Otherwise, the address layout has no target layout and the size of the returned segment\n@@ -651,1 +651,1 @@\n-     * Creates a method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long,long) slice}\n+     * Creates a method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long, long) slice}\n@@ -673,1 +673,1 @@\n-     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     *     <li>The start offset of the slicing operation (computed as above) must fall inside the spatial bounds of the\n@@ -683,1 +683,1 @@\n-     * @return a method handle which is used to slice a memory segment at the offset selected by the given layout path.\n+     * @return a method handle that is used to slice a memory segment at the offset selected by the given layout path.\n@@ -721,1 +721,1 @@\n-         * Returns a path element which selects a member layout with the given name in a group layout.\n+         * Returns a path element that selects a member layout with the given name in a group layout.\n@@ -724,1 +724,1 @@\n-         * method will select the first one; that is, the group element with the lowest offset from current path is selected.\n+         * method will select the first one; that is, the group element with the lowest offset from the current path is selected.\n@@ -728,1 +728,1 @@\n-         * @return a path element which selects the group member layout with the given name.\n+         * @return a path element that selects the group member layout with the given name.\n@@ -737,1 +737,1 @@\n-         * Returns a path element which selects a member layout with the given index in a group layout.\n+         * Returns a path element that selects a member layout with the given index in a group layout.\n@@ -752,1 +752,1 @@\n-         * Returns a path element which selects the element layout at the specified position in a sequence layout.\n+         * Returns a path element that selects the element layout at the specified position in a sequence layout.\n@@ -755,1 +755,1 @@\n-         * @return a path element which selects the sequence element layout with the given index.\n+         * @return a path element that selects the sequence element layout with the given index.\n@@ -767,1 +767,1 @@\n-         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects the element\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> that selects the element\n@@ -780,1 +780,1 @@\n-         * @return a path element which selects the sequence element layout with the given index.\n+         * @return a path element that selects the sequence element layout with the given index.\n@@ -795,1 +795,1 @@\n-         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects an unspecified\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> that selects an unspecified\n@@ -809,1 +809,1 @@\n-         * Returns a path element which dereferences an address layout as its\n+         * Returns a path element that dereferences an address layout as its\n@@ -812,1 +812,1 @@\n-         * @return a path element which dereferences an address layout.\n+         * @return a path element that dereferences an address layout.\n@@ -906,1 +906,1 @@\n-     * Or, alternatively, they can use a member layout which features a smaller alignment constraint. This will result\n+     * Or, alternatively, they can use a member layout that features a smaller alignment constraint. This will result\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- * <em>outside<\/em> the boundaries of the region of memory which backs the segment.\n+ * <em>outside<\/em> the boundaries of the region of memory that backs the segment.\n@@ -99,1 +99,1 @@\n- * on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available\n+ * on a memory segment cannot occur when the region of memory that backs the memory segment is no longer available\n@@ -175,1 +175,1 @@\n- * {@code slice} will also be become inaccessible.\n+ * {@code slice} will also become inaccessible.\n@@ -196,1 +196,1 @@\n- * access only those offsets in the segment that denote addresses in physical memory which are <em>aligned<\/em> according\n+ * access only those offsets in the segment that denote addresses in physical memory that are <em>aligned<\/em> according\n@@ -242,1 +242,1 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link Arena#allocate(long, long)}\n+ * the segment should be allocated by specifying an 8-byte alignment constraint, either via {@link Arena#allocate(long, long)}\n@@ -248,1 +248,1 @@\n- * The address of the segment in physical memory is not known, and is not even fixed (it may change when the segment\n+ * The address of the segment in physical memory is not known and is not even fixed (it may change when the segment\n@@ -252,1 +252,1 @@\n- * For example, suppose the programmer chooses a 8-byte alignment constraint and tries\n+ * For example, suppose the programmer chooses an 8-byte alignment constraint and tries\n@@ -271,1 +271,1 @@\n- * because because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond\n+ * because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond\n@@ -380,1 +380,1 @@\n- * to be read. For instance on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n+ * to be read. For instance, on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n@@ -424,1 +424,1 @@\n- * All the methods which can be used to manipulate zero-length memory segments\n+ * All the methods that can be used to manipulate zero-length memory segments\n@@ -621,1 +621,1 @@\n-     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n+     * clients that might access the segment after its backing region of memory is no longer available. Furthermore,\n@@ -656,1 +656,1 @@\n-     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n+     * clients that might access the segment after its backing region of memory is no longer available. Furthermore,\n@@ -664,1 +664,1 @@\n-     * @return a new segment that has the same address as this segment, but with new size and its scope set to\n+     * @return a new segment that has the same address as this segment, but with the new size and its scope set to\n@@ -693,1 +693,1 @@\n-     * @return {@code true} if this segment is native segment.\n+     * @return {@code true} if this segment is a native segment.\n@@ -748,1 +748,1 @@\n-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at\n+     * Performs a bulk copy from the given source segment to this segment. More specifically, the bytes at\n@@ -801,1 +801,1 @@\n-     * Determines whether the contents of this mapped segment is resident in physical\n+     * Determines whether all the contents of this mapped segment are resident in physical\n@@ -808,1 +808,1 @@\n-     * necessarily imply that this segment's content is not resident in physical\n+     * necessarily imply that this segment's contents are not resident in physical\n@@ -816,1 +816,1 @@\n-     *          is resident in physical memory\n+     *          are resident in physical memory\n@@ -831,1 +831,1 @@\n-     * this contents of this segment is resident in physical memory.  Invoking this\n+     * the contents of this segment are resident in physical memory.  Invoking this\n@@ -848,1 +848,1 @@\n-     * are no longer resident in physical memory. Accessing this segment's contents\n+     * no longer resident in physical memory. Accessing this segment's contents\n@@ -1032,1 +1032,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1085,1 +1085,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1138,1 +1138,1 @@\n-     * the returned segment is a native segment; otherwise the returned memory segment is a heap segment.\n+     * the returned segment is a native segment; otherwise, the returned memory segment is a heap segment.\n@@ -1144,1 +1144,1 @@\n-     * deallocated as long as the returned segment (or any of its slices) are kept reachable.\n+     * deallocated as long as the returned segment, or any of its slices, are kept reachable.\n@@ -1247,1 +1247,1 @@\n-     * The returned segment is associated with the global scope, and is accessible from any thread.\n+     * The returned segment is associated with the global scope and is accessible from any thread.\n@@ -1310,2 +1310,2 @@\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n-     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have the same size {@code S}.\n+     * If the byte order of the two provided element layouts differs, the bytes corresponding to each element to be copied\n@@ -1364,1 +1364,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1380,1 +1380,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1397,1 +1397,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1413,1 +1413,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1430,1 +1430,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1446,1 +1446,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1463,1 +1463,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1479,1 +1479,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1496,1 +1496,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1512,1 +1512,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1529,1 +1529,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1545,1 +1545,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1562,1 +1562,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1578,1 +1578,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1595,1 +1595,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1611,1 +1611,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1631,1 +1631,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1650,1 +1650,1 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param offset the offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -2180,2 +2180,2 @@\n-     * is modelled with the <em>global scope<\/em>. The global scope is always {@link #isAlive() alive}. As such, a segment\n-     * associated with the global scope features trivial temporal bounds, and is always accessible.\n+     * is modeled with the <em>global scope<\/em>. The global scope is always {@link #isAlive() alive}. As such, a segment\n+     * associated with the global scope features trivial temporal bounds and is always accessible.\n@@ -2189,1 +2189,1 @@\n-     * Conversely, a bounded lifetime is modelled with a segment scope that can be invalidated, either {@link Arena#close() explicitly},\n+     * Conversely, a bounded lifetime is modeled with a segment scope that can be invalidated, either {@link Arena#close() explicitly},\n@@ -2218,1 +2218,1 @@\n-         * modelled by this scope}. In that case, it is always the case that\n+         * modeled by this scope}. In that case, it is always the case that\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -392,1 +392,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -411,1 +411,1 @@\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n+     * The contents of the source array are copied into the result segment element by element, according to the byte\n@@ -414,1 +414,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -436,1 +436,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -458,1 +458,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -480,1 +480,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -502,1 +502,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -524,1 +524,1 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec The default implementation for this method is equivalent to the following code:\n@@ -595,1 +595,1 @@\n-     * Returns a segment allocator which responds to allocation requests by returning consecutive slices\n+     * Returns a segment allocator that responds to allocation requests by returning consecutive slices\n@@ -604,1 +604,1 @@\n-     * @param segment the segment which the returned allocator should slice from.\n+     * @param segment the segment from which the returned allocator should slice from.\n@@ -613,1 +613,1 @@\n-     * Returns a segment allocator which responds to allocation requests by recycling a single segment. Each\n+     * Returns a segment allocator that responds to allocation requests by recycling a single segment. Each\n@@ -631,1 +631,1 @@\n-     * @return an allocator which recycles an existing segment upon each new allocation request.\n+     * @return an allocator that recycles an existing segment upon each new allocation request.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-     * If one of the provided element count is the special value {@code -1}, then the element\n+     * If one of the provided element counts is the special value {@code -1}, then the element\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * The address of a symbol is modelled as a zero-length {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n+ * The address of a symbol is modeled as a zero-length {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n@@ -135,1 +135,1 @@\n-     * {@return a composed symbol lookup that returns result of finding the symbol with this lookup if found,\n+     * {@return a composed symbol lookup that returns the result of finding the symbol with this lookup if found,\n@@ -146,1 +146,1 @@\n-     * in \"foo\" then \"bar\" is searched. Finally, if a symbol is not found in neither \"foo\" nor \"bar\", the {@linkplain\n+     * in \"foo\" then \"bar\" is searched. Finally, if a symbol is neither found in \"foo\" nor in \"bar\", the {@linkplain\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * A layout that models values of basic data types. Examples of values modelled by a value layout are\n+ * A layout that models values of basic data types. Examples of values modeled by a value layout are\n@@ -45,1 +45,1 @@\n- * {@link ValueLayout#JAVA_LONG} and {@link ValueLayout#JAVA_DOUBLE} is set to 8 bytes on 64-bit platforms, but only to\n+ * {@link ValueLayout#JAVA_LONG} and {@link ValueLayout#JAVA_DOUBLE} are set to 8 bytes on 64-bit platforms, but only to\n@@ -105,1 +105,1 @@\n-     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * @apiNote This method is similar, but more efficient than calling {@code MemoryLayout#varHandle(PathElement...)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * {@link java.lang.foreign.MemoryLayout memory layout}, which provides basic operations to query sizes, offsets and\n+ * {@link java.lang.foreign.MemoryLayout memory layout}, which provides basic operations to query sizes, offsets, and\n@@ -64,1 +64,1 @@\n- * the access coordinates are validated (upon access), to make sure that access does not occur at any address which resides\n+ * the access coordinates are validated (upon access), to make sure that access does not occur at any address that resides\n@@ -124,1 +124,1 @@\n- * memory sgement using {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or, worse,\n+ * memory segment using {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or, worse,\n@@ -131,1 +131,1 @@\n- * to selected modules. This can be done either via implementation-specific command line options, or programmatically, e.g. by calling\n+ * to selected modules. This can be done either via implementation-specific command line options or programmatically, e.g. by calling\n@@ -145,1 +145,1 @@\n- * restricted methods is only granted to the modules listed by that option. If this option is not specified,\n+ * restricted methods are only granted to the modules listed by that option. If this option is not specified,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}