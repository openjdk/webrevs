{"files":[{"patch":"@@ -44,1 +44,0 @@\n-import java.lang.reflect.GenericArrayType;\n@@ -50,1 +49,0 @@\n-import java.lang.reflect.Proxy;\n@@ -85,0 +83,1 @@\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -86,6 +85,2 @@\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.repository.ClassRepository;\n-import sun.reflect.generics.repository.MethodRepository;\n-import sun.reflect.generics.repository.ConstructorRepository;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.reflect.generics.info.ClassGenericInfo;\n+import sun.reflect.generics.info.GenericInfo;\n@@ -1033,1 +1028,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -1035,1 +1029,1 @@\n-        ClassRepository info = getGenericInfo();\n+        var info = getGenericInfo();\n@@ -1037,1 +1031,1 @@\n-            return (TypeVariable<Class<T>>[])info.getTypeParameters();\n+            return info.getTypeVariables();\n@@ -1039,1 +1033,1 @@\n-            return (TypeVariable<Class<T>>[])new TypeVariable<?>[0];\n+            return GenericInfo.emptyTypeVars();\n@@ -1089,1 +1083,1 @@\n-        ClassRepository info = getGenericInfo();\n+        var info = getGenericInfo();\n@@ -1277,1 +1271,1 @@\n-        ClassRepository info = getGenericInfo();\n+        var info = getGenericInfo();\n@@ -1440,11 +1434,4 @@\n-            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),\n-                                                              getFactory());\n-            Class<?>   returnType       = toClass(typeInfo.getReturnType());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for(int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            Class<?>   returnType       = types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(GenericInfo.EMPTY_CLASS_ARRAY);\n@@ -1539,6 +1526,0 @@\n-    private static Class<?> toClass(Type o) {\n-        if (o instanceof GenericArrayType gat)\n-            return toClass(gat.getGenericComponentType()).arrayType();\n-        return (Class<?>)o;\n-     }\n-\n@@ -1569,11 +1550,4 @@\n-            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),\n-                                                                        getFactory());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for (int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n-\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(GenericInfo.EMPTY_CLASS_ARRAY);\n@@ -2870,7 +2844,1 @@\n-    private transient volatile ClassRepository genericInfo;\n-\n-    \/\/ accessor for factory\n-    private GenericsFactory getFactory() {\n-        \/\/ create scope and factory\n-        return CoreReflectionFactory.make(this, ClassScope.make(this));\n-    }\n+    private transient volatile @Stable ClassGenericInfo<T> genericInfo;\n@@ -2880,2 +2848,2 @@\n-    private ClassRepository getGenericInfo() {\n-        ClassRepository genericInfo = this.genericInfo;\n+    private ClassGenericInfo<T> getGenericInfo() {\n+        var genericInfo = this.genericInfo;\n@@ -2885,1 +2853,1 @@\n-                genericInfo = ClassRepository.NONE;\n+                genericInfo = ClassGenericInfo.dummy();\n@@ -2887,1 +2855,1 @@\n-                genericInfo = ClassRepository.make(signature, getFactory());\n+                genericInfo = new ClassGenericInfo<>(this, signature);\n@@ -2891,1 +2859,1 @@\n-        return (genericInfo != ClassRepository.NONE) ? genericInfo : null;\n+        return (genericInfo != ClassGenericInfo.dummy()) ? genericInfo : null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":22,"deletions":54,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,3 @@\n-import sun.reflect.generics.repository.ConstructorRepository;\n-import sun.reflect.generics.repository.GenericDeclRepository;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.scope.ConstructorScope;\n+import sun.reflect.generics.info.ExecutableGenericInfo;\n+import sun.reflect.generics.info.GenericInfo;\n+\n@@ -79,6 +77,0 @@\n-    \/\/ Accessor for factory\n-    private GenericsFactory getFactory() {\n-        \/\/ create scope and factory\n-        return CoreReflectionFactory.make(this, ConstructorScope.make(this));\n-    }\n-\n@@ -87,1 +79,2 @@\n-    ConstructorRepository getGenericInfo() {\n+    ExecutableGenericInfo<Constructor<T>> getGenericInfo() {\n+        assert hasGenericInformation();\n@@ -94,1 +87,1 @@\n-                genericInfo = ConstructorRepository.make(getSignature(), getFactory());\n+                genericInfo = new ExecutableGenericInfo<>(this, signature);\n@@ -107,1 +100,1 @@\n-    private transient volatile ConstructorRepository genericInfo;\n+    private transient volatile ExecutableGenericInfo<Constructor<T>> genericInfo;\n@@ -202,1 +195,1 @@\n-        return (getSignature() != null);\n+        return signature != null;\n@@ -243,1 +236,0 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -245,4 +237,4 @@\n-      if (getSignature() != null) {\n-        return (TypeVariable<Constructor<T>>[])getGenericInfo().getTypeParameters();\n-      } else\n-          return (TypeVariable<Constructor<T>>[])GenericDeclRepository.EMPTY_TYPE_VARS;\n+        if (hasGenericInformation()) {\n+            return getGenericInfo().getTypeVariables();\n+        } else\n+            return GenericInfo.emptyTypeVars();\n@@ -572,17 +564,0 @@\n-    int getSlot() {\n-        return slot;\n-    }\n-\n-    String getSignature() {\n-        return signature;\n-    }\n-\n-    byte[] getRawAnnotations() {\n-        return annotations;\n-    }\n-\n-    byte[] getRawParameterAnnotations() {\n-        return parameterAnnotations;\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":13,"deletions":38,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import sun.reflect.generics.info.ExecutableGenericInfo;\n@@ -43,1 +44,0 @@\n-import sun.reflect.generics.repository.ConstructorRepository;\n@@ -70,1 +70,1 @@\n-    abstract ConstructorRepository getGenericInfo();\n+    abstract ExecutableGenericInfo<?> getGenericInfo();\n@@ -334,1 +334,1 @@\n-            return getGenericInfo().getParameterTypes();\n+            return getGenericInfo().getParameters();\n@@ -536,1 +536,1 @@\n-            ((result = getGenericInfo().getExceptionTypes()).length > 0))\n+            ((result = getGenericInfo().getExceptions()).length > 0))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,1 @@\n-import sun.reflect.generics.repository.FieldRepository;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.reflect.generics.info.FieldGenericInfo;\n@@ -87,1 +84,1 @@\n-    private transient volatile FieldRepository genericInfo;\n+    private transient volatile FieldGenericInfo genericInfo;\n@@ -93,10 +90,0 @@\n-\n-    private String getGenericSignature() {return signature;}\n-\n-    \/\/ Accessor for factory\n-    private GenericsFactory getFactory() {\n-        Class<?> c = getDeclaringClass();\n-        \/\/ create scope and factory\n-        return CoreReflectionFactory.make(c, ClassScope.make(c));\n-    }\n-\n@@ -104,1 +91,2 @@\n-    private FieldRepository getGenericInfo() {\n+    private FieldGenericInfo getGenericInfo() {\n+        assert signature != null;\n@@ -111,1 +99,1 @@\n-                genericInfo = FieldRepository.make(getGenericSignature(), getFactory());\n+                genericInfo = new FieldGenericInfo(getDeclaringClass(), signature);\n@@ -289,2 +277,2 @@\n-        if (getGenericSignature() != null)\n-            return getGenericInfo().getGenericType();\n+        if (signature != null)\n+            return getGenericInfo().getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,5 +39,2 @@\n-import sun.reflect.generics.repository.GenericDeclRepository;\n-import sun.reflect.generics.repository.MethodRepository;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.scope.MethodScope;\n+import sun.reflect.generics.info.ExecutableGenericInfo;\n+import sun.reflect.generics.info.GenericInfo;\n@@ -94,1 +91,1 @@\n-    private transient volatile MethodRepository genericInfo;\n+    private transient volatile ExecutableGenericInfo<Method> genericInfo;\n@@ -100,8 +97,0 @@\n-    private String getGenericSignature() {return signature;}\n-\n-    \/\/ Accessor for factory\n-    private GenericsFactory getFactory() {\n-        \/\/ create scope and factory\n-        return CoreReflectionFactory.make(this, MethodScope.make(this));\n-    }\n-\n@@ -110,1 +99,2 @@\n-    MethodRepository getGenericInfo() {\n+    ExecutableGenericInfo<Method> getGenericInfo() {\n+        assert hasGenericInformation();\n@@ -117,1 +107,1 @@\n-                genericInfo = MethodRepository.make(getGenericSignature(), getFactory());\n+                genericInfo = new ExecutableGenericInfo<>(this, signature);\n@@ -192,1 +182,1 @@\n-        return (getGenericSignature() != null);\n+        return signature != null;\n@@ -234,1 +224,0 @@\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -236,2 +225,2 @@\n-        if (getGenericSignature() != null)\n-            return (TypeVariable<Method>[])getGenericInfo().getTypeParameters();\n+        if (hasGenericInformation())\n+            return getGenericInfo().getTypeVariables();\n@@ -239,1 +228,1 @@\n-            return (TypeVariable<Method>[])GenericDeclRepository.EMPTY_TYPE_VARS;\n+            return GenericInfo.emptyTypeVars();\n@@ -277,3 +266,4 @@\n-      if (getGenericSignature() != null) {\n-        return getGenericInfo().getReturnType();\n-      } else { return getReturnType();}\n+        if (hasGenericInformation()) {\n+            return getGenericInfo().getResult();\n+        }\n+        return getReturnType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.repository.FieldRepository;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.reflect.generics.info.FieldGenericInfo;\n@@ -57,1 +54,1 @@\n-    private transient volatile FieldRepository genericInfo;\n+    private transient volatile FieldGenericInfo genericInfo;\n@@ -123,1 +120,1 @@\n-            return getGenericInfo().getGenericType();\n+            return getGenericInfo().getType();\n@@ -129,1 +126,1 @@\n-    private FieldRepository getGenericInfo() {\n+    private FieldGenericInfo getGenericInfo() {\n@@ -134,1 +131,1 @@\n-            genericInfo = FieldRepository.make(getGenericSignature(), getFactory());\n+            genericInfo = new FieldGenericInfo(getDeclaringRecord(), getGenericSignature());\n@@ -140,7 +137,0 @@\n-    \/\/ Accessor for factory\n-    private GenericsFactory getFactory() {\n-        Class<?> c = getDeclaringRecord();\n-        \/\/ create scope and factory\n-        return CoreReflectionFactory.make(c, ClassScope.make(c));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RecordComponent.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,14 @@\n+    \/**\n+     * @throws IllegalArgumentException if the descriptor is invalid\n+     * @throws TypeNotPresentException if the descriptor is valid, but\n+     * the class cannot be found by the loader\n+     *\/\n+    public static Class<?> parseClass(String descriptor, ClassLoader loader) {\n+        int[] i = {0};\n+        var ret = parseSig(descriptor, i, descriptor.length(), loader);\n+        if (i[0] != descriptor.length() || ret == null) {\n+            parseError(\"not a class descriptor\", descriptor);\n+        }\n+        return ret;\n+    }\n+\n@@ -43,0 +57,3 @@\n+     * @throws IllegalArgumentException if the descriptor is invalid\n+     * @throws TypeNotPresentException if the descriptor is valid, but\n+     * a reference type cannot be found by the loader\n@@ -81,0 +98,7 @@\n+     * Parse a single type in a descriptor. Results can be:\n+     * <ul>\n+     *     <li>A {@code Class} for successful parsing\n+     *     <li>{@code null} for malformed descriptor format\n+     *     <li>Throwing a {@link TypeNotPresentException} for valid class name,\n+     *     but class cannot be discovered\n+     * <\/ul>\n@@ -103,1 +127,2 @@\n-            return Wrapper.forBasicType(c).primitiveType();\n+            var w = Wrapper.forPrimitiveTypeOrNull(c);\n+            return w == null ? null : w.primitiveType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,0 +355,13 @@\n+    \/**\n+     * Return the primitive wrapper for the given char.  Does not return\n+     * {@code OBJECT}. Returns {@code null} to allow flexible error messages.\n+     * Dedicated for {@link BytecodeDescriptor}.\n+     *\/\n+    static Wrapper forPrimitiveTypeOrNull(char type) {\n+        Wrapper w = FROM_CHAR[(type + (type >> 1)) & 0xf];\n+        if (w != null && w != OBJECT && w.basicTypeChar == type) {\n+            return w;\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,6 +37,1 @@\n-import sun.reflect.generics.parser.SignatureParser;\n-import sun.reflect.generics.tree.TypeSignature;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.visitor.Reifier;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -432,13 +427,5 @@\n-        if (sig.equals(\"V\")) return void.class;\n-        SignatureParser parser = SignatureParser.make();\n-        TypeSignature typeSig = parser.parseTypeSig(sig);\n-        GenericsFactory factory = CoreReflectionFactory.make(container, ClassScope.make(container));\n-        Reifier reify = Reifier.make(factory);\n-        typeSig.accept(reify);\n-        Type result = reify.getResult();\n-        return toClass(result);\n-    }\n-    static Class<?> toClass(Type o) {\n-        if (o instanceof GenericArrayType gat)\n-            return toClass(gat.getGenericComponentType()).arrayType();\n-        return (Class<?>) o;\n+        try {\n+            return BytecodeDescriptor.parseClass(sig, container.getClassLoader());\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.factory;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.GenericDeclaration;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n-\n-\n-import sun.reflect.generics.reflectiveObjects.*;\n-import sun.reflect.generics.scope.Scope;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n-\n-\n-\/**\n- * Factory for reflective generic type objects for use by\n- * core reflection (java.lang.reflect).\n- *\/\n-public class CoreReflectionFactory implements GenericsFactory {\n-    private final GenericDeclaration decl;\n-    private final Scope scope;\n-\n-    private CoreReflectionFactory(GenericDeclaration d, Scope s) {\n-        decl = d;\n-        scope = s;\n-    }\n-\n-    private GenericDeclaration getDecl(){ return decl;}\n-\n-    private Scope getScope(){ return scope;}\n-\n-\n-    private ClassLoader getDeclsLoader() {\n-        if (decl instanceof Class<?> c) {return c.getClassLoader();}\n-        if (decl instanceof Method m) {\n-            return m.getDeclaringClass().getClassLoader();\n-        }\n-        assert decl instanceof Constructor : \"Constructor expected\";\n-        return ((Constructor<?>) decl).getDeclaringClass().getClassLoader();\n-\n-    }\n-\n-    \/**\n-     * Factory for this class. Returns an instance of\n-     * {@code CoreReflectionFactory} for the declaration and scope\n-     * provided.\n-     * This factory will produce reflective objects of the appropriate\n-     * kind. Classes produced will be those that would be loaded by the\n-     * defining class loader of the declaration {@code d} (if {@code d}\n-     * is a type declaration, or by the defining loader of the declaring\n-     * class of {@code d} otherwise.\n-     * <p> Type variables will be created or lookup as necessary in the\n-     * scope {@code s}.\n-     * @param d - the generic declaration (class, interface, method or\n-     * constructor) that this factory services\n-     * @param s  the scope in which the factory will allocate and search for\n-     * type variables\n-     * @return an instance of {@code CoreReflectionFactory}\n-     *\/\n-    public static CoreReflectionFactory make(GenericDeclaration d, Scope s) {\n-        return new CoreReflectionFactory(d, s);\n-    }\n-\n-    public TypeVariable<?> makeTypeVariable(String name,\n-                                            FieldTypeSignature[] bounds){\n-        return TypeVariableImpl.make(getDecl(), name, bounds, this);\n-    }\n-\n-    public WildcardType makeWildcard(FieldTypeSignature[] ubs,\n-                                     FieldTypeSignature[] lbs) {\n-        return WildcardTypeImpl.make(ubs, lbs, this);\n-    }\n-\n-    public ParameterizedType makeParameterizedType(Type declaration,\n-                                                   Type[] typeArgs,\n-                                                   Type owner) {\n-        return ParameterizedTypeImpl.make((Class<?>) declaration,\n-                                          typeArgs, owner);\n-    }\n-\n-    public TypeVariable<?> findTypeVariable(String name){\n-        TypeVariable<?> variable = getScope().lookup(name);\n-        if (variable == null) {\n-            throw new TypeNotPresentException(name, null);\n-        }\n-        return variable;\n-    }\n-\n-    public Type makeNamedType(String name){\n-        try {return Class.forName(name, false, \/\/ don't initialize\n-                                  getDeclsLoader());}\n-        catch (ClassNotFoundException c) {\n-            throw new TypeNotPresentException(name, c);\n-        }\n-    }\n-\n-    public Type makeArrayType(Type componentType){\n-        if (componentType instanceof Class<?> ct)\n-            return ct.arrayType();\n-        else\n-            return GenericArrayTypeImpl.make(componentType);\n-    }\n-\n-    public Type makeByte(){return byte.class;}\n-    public Type makeBool(){return boolean.class;}\n-    public Type makeShort(){return short.class;}\n-    public Type makeChar(){return char.class;}\n-    public Type makeInt(){return int.class;}\n-    public Type makeLong(){return long.class;}\n-    public Type makeFloat(){return float.class;}\n-    public Type makeDouble(){return double.class;}\n-\n-    public Type makeVoid(){return void.class;}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/CoreReflectionFactory.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.factory;\n-\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n-\n-\/**\n- * A factory interface for reflective objects representing generic types.\n- * Implementors (such as core reflection or JDI, or possibly javadoc\n- * will manufacture instances of (potentially) different classes\n- * in response to invocations of the methods described here.\n- * <p> The intent is that reflective systems use these factories to\n- * produce generic type information on demand.\n- * Certain components of such reflective systems can be independent\n- * of a specific implementation by using this interface. For example,\n- * repositories of generic type information are initialized with a\n- * factory conforming to this interface, and use it to generate the\n- * type information they are required to provide. As a result, such\n- * repository code can be shared across different reflective systems.\n- *\/\n-public interface GenericsFactory {\n-    \/**\n-     * Returns a new type variable declaration. Note that {@code name}\n-     * may be empty (but not {@code null}). If {@code bounds} is\n-     * empty, a bound of {@code java.lang.Object} is used.\n-     * @param name The name of the type variable\n-     * @param bounds An array of abstract syntax trees representing\n-     * the upper bound(s) on the type variable being declared\n-     * @return a new type variable declaration\n-     * @throws NullPointerException if any of the actual parameters\n-     * or any of the elements of {@code bounds} are {@code null}.\n-     *\/\n-    TypeVariable<?> makeTypeVariable(String name,\n-                                     FieldTypeSignature[] bounds);\n-    \/**\n-     * Returns an instance of the {@code ParameterizedType} interface\n-     * that corresponds to a generic type instantiation of the\n-     * generic declaration {@code declaration} with actual type arguments\n-     * {@code typeArgs}.\n-     * If {@code owner} is {@code null}, the declaring class of\n-     * {@code declaration} is used as the owner of this parameterized\n-     * type.\n-     * <p> This method throws a MalformedParameterizedTypeException\n-     * under the following circumstances:\n-     * If the type declaration does not represent a generic declaration\n-     * (i.e., it is not an instance of {@code GenericDeclaration}).\n-     * If the number of actual type arguments (i.e., the size of the\n-     * array {@code typeArgs}) does not correspond to the number of\n-     * formal type arguments.\n-     * If any of the actual type arguments is not an instance of the\n-     * bounds on the corresponding formal.\n-     * @param declaration - the generic type declaration that is to be\n-     * instantiated\n-     * @param typeArgs - the list of actual type arguments\n-     * @return - a parameterized type representing the instantiation\n-     * of the declaration with the actual type arguments\n-     * @throws MalformedParameterizedTypeException if the instantiation\n-     * is invalid\n-     * @throws NullPointerException if any of {@code declaration},\n-     * {@code typeArgs}\n-     * or any of the elements of {@code typeArgs} are {@code null}\n-     *\/\n-    ParameterizedType makeParameterizedType(Type declaration,\n-                                            Type[] typeArgs,\n-                                            Type owner);\n-\n-    \/**\n-     * Returns the type variable with name {@code name}, if such\n-     * a type variable is declared in the\n-     * scope used to create this factory.\n-     * Returns {@code null} otherwise.\n-     * @param name - the name of the type variable to search for\n-     * @return - the type variable with name {@code name}, or {@code null}\n-     * @throws  NullPointerException if any of actual parameters are\n-     * {@code null}\n-     *\/\n-    TypeVariable<?> findTypeVariable(String name);\n-\n-    \/**\n-     * Returns a new wildcard type variable. If\n-     * {@code ubs} is empty, a bound of {@code java.lang.Object} is used.\n-     * @param ubs An array of abstract syntax trees representing\n-     * the upper bound(s) on the type variable being declared\n-     * @param lbs An array of abstract syntax trees representing\n-     * the lower bound(s) on the type variable being declared\n-     * @return a new wildcard type variable\n-     * @throws NullPointerException if any of the actual parameters\n-     * or any of the elements of {@code ubs} or {@code lbs} are\n-     * {@code null}\n-     *\/\n-    WildcardType makeWildcard(FieldTypeSignature[] ubs,\n-                              FieldTypeSignature[] lbs);\n-\n-    Type makeNamedType(String name);\n-\n-    \/**\n-     * Returns a (possibly generic) array type.\n-     * If the component type is a parameterized type, it must\n-     * only have unbounded wildcard arguments, otherwise\n-     * a MalformedParameterizedTypeException is thrown.\n-     * @param componentType - the component type of the array\n-     * @return a (possibly generic) array type.\n-     * @throws MalformedParameterizedTypeException if {@code componentType}\n-     * is a parameterized type with non-wildcard type arguments\n-     * @throws NullPointerException if any of the actual parameters\n-     * are {@code null}\n-     *\/\n-    Type makeArrayType(Type componentType);\n-\n-    \/**\n-     * Returns the reflective representation of type {@code byte}.\n-     * @return the reflective representation of type {@code byte}.\n-     *\/\n-    Type makeByte();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code boolean}.\n-     * @return the reflective representation of type {@code boolean}.\n-     *\/\n-    Type makeBool();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code short}.\n-     * @return the reflective representation of type {@code short}.\n-     *\/\n-    Type makeShort();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code char}.\n-     * @return the reflective representation of type {@code char}.\n-     *\/\n-    Type makeChar();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code int}.\n-     * @return the reflective representation of type {@code int}.\n-     *\/\n-    Type makeInt();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code long}.\n-     * @return the reflective representation of type {@code long}.\n-     *\/\n-    Type makeLong();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code float}.\n-     * @return the reflective representation of type {@code float}.\n-     *\/\n-    Type makeFloat();\n-\n-    \/**\n-     * Returns the reflective representation of type {@code double}.\n-     * @return the reflective representation of type {@code double}.\n-     *\/\n-    Type makeDouble();\n-\n-    \/**\n-     * Returns the reflective representation of {@code void}.\n-     * @return the reflective representation of {@code void}.\n-     *\/\n-    Type makeVoid();\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/GenericsFactory.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.info;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.classfile.ClassSignature;\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+\n+public final class ClassGenericInfo<T> extends GenericDeclInfo<Class<T>> {\n+    private static final ClassGenericInfo<Object> DUMMY = new ClassGenericInfo<>(Object.class,\n+            CD_Object.descriptorString());\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> ClassGenericInfo<T> dummy() {\n+        return (ClassGenericInfo<T>) DUMMY;\n+    }\n+\n+    private final ClassSignature signature;\n+    private volatile @Stable Type superclass;\n+    private volatile @Stable Type[] superInterfaces;\n+\n+    public ClassGenericInfo(Class<T> owner, String signatureString) {\n+        super(owner);\n+        ClassSignature classSignature;\n+        try {\n+            classSignature = ClassSignature.parseFrom(signatureString);\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n+        this.signature = classSignature;\n+    }\n+\n+    @Override\n+    List<Signature.TypeParam> typeParams() {\n+        return signature.typeParameters();\n+    }\n+\n+    Type[] superInterfaces() {\n+        var superInterfaces = this.superInterfaces;\n+        if (superInterfaces != null)\n+            return superInterfaces;\n+        return this.superInterfaces = resolve(signature.superinterfaceSignatures());\n+    }\n+\n+    public Type[] getSuperInterfaces() {\n+        return superInterfaces().clone();\n+    }\n+\n+    public Type getSuperclass() {\n+        var superclass = this.superclass;\n+        if (superclass != null)\n+            return superclass;\n+        return this.superclass = resolve(signature.superclassSignature());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/ClassGenericInfo.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.info;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.classfile.MethodSignature;\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+public final class ExecutableGenericInfo<T extends Executable> extends GenericDeclInfo<T> {\n+    private final MethodSignature signature;\n+    private volatile @Stable Type[] parameters;\n+    private volatile @Stable Type result;\n+    private volatile @Stable Type[] exceptions;\n+\n+    public ExecutableGenericInfo(T owner, String signatureString) {\n+        super(owner);\n+        MethodSignature signature;\n+        try {\n+            signature = MethodSignature.parseFrom(signatureString);\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n+        this.signature = signature;\n+    }\n+\n+    public Type[] getExceptions() {\n+        return exceptions().clone();\n+    }\n+\n+    Type[] exceptions() {\n+        var exceptions = this.exceptions;\n+        if (exceptions != null)\n+            return exceptions;\n+        return this.exceptions = resolve(signature.throwableSignatures());\n+    }\n+\n+    public Type getResult() {\n+        var result = this.result;\n+        if (result != null)\n+            return result;\n+        return this.result = resolve(signature.result());\n+    }\n+\n+    public Type[] getParameters() {\n+        return parameters().clone();\n+    }\n+\n+    Type[] parameters() {\n+        var parameters = this.parameters;\n+        if (parameters != null)\n+            return parameters;\n+        return this.parameters = resolve(signature.arguments());\n+    }\n+\n+    @Override\n+    List<Signature.TypeParam> typeParams() {\n+        return signature.typeParameters();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/ExecutableGenericInfo.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.info;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.lang.reflect.Type;\n+\n+public final class FieldGenericInfo extends GenericInfo<Class<?>> {\n+    private final Signature signature;\n+    private volatile @Stable Type type;\n+\n+    public FieldGenericInfo(Class<?> closestDecl, String signatureString) {\n+        super(closestDecl);\n+        Signature signature;\n+        try {\n+            signature = Signature.parseFrom(signatureString);\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n+        this.signature = signature;\n+    }\n+\n+    public Type getType() {\n+        var type = this.type;\n+        if (type != null)\n+            return type;\n+        return this.type = resolve(signature);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/FieldGenericInfo.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.info;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import sun.reflect.generics.reflectiveObjects.TypeVariableImpl;\n+\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.TypeVariable;\n+import java.util.List;\n+\n+\/**\n+ * A generic declaration info is a generic info that itself\n+ * declares type variables.\n+ *\n+ * @param <T> the owner type\n+ *\/\n+public abstract sealed class GenericDeclInfo<T extends GenericDeclaration> extends GenericInfo<T>\n+        permits ClassGenericInfo, ExecutableGenericInfo {\n+    private volatile @Stable TypeVariable<T>[] typeVars;\n+\n+    GenericDeclInfo(T owner) {\n+        super(owner);\n+    }\n+\n+    public TypeVariable<T>[] getTypeVariables() {\n+        return typeVars().clone();\n+    }\n+\n+    TypeVariable<T>[] typeVars() {\n+        var ret = typeVars;\n+        if (ret != null)\n+            return ret;\n+\n+        var params = typeParams();\n+        @SuppressWarnings(\"unchecked\")\n+        TypeVariable<T>[] array = (TypeVariable<T>[])\n+                new TypeVariable<?>[params.size()];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = resolve(params.get(i));\n+        }\n+\n+        return typeVars = array;\n+    }\n+\n+    abstract List<Signature.TypeParam> typeParams();\n+\n+    public final TypeVariable<T> resolve(Signature.TypeParam typeParam) {\n+        var classBound = typeParam.classBound();\n+        var interfaceBounds = typeParam.interfaceBounds();\n+        Signature[] signatures = new Signature[(classBound.isPresent() ? 1 : 0)\n+                + interfaceBounds.size()];\n+        int i = 0;\n+        if (classBound.isPresent()) {\n+            signatures[i++] = classBound.get();\n+        }\n+\n+        for (var sig : interfaceBounds) {\n+            signatures[i++] = sig;\n+        }\n+\n+        return TypeVariableImpl.make(closestDeclaration, typeParam.identifier(),\n+                signatures, this);\n+    }\n+\n+    \/\/ Prevents recursive initialization\n+    @Override\n+    TypeVariable<?> findTypeVariable(String name) {\n+        for (var tv : typeVars()) {\n+            if (tv.getName().equals(name)) {\n+                return tv;\n+            }\n+        }\n+        for (var decl = findParent(closestDeclaration);\n+                decl != null; decl = findParent(decl)) {\n+            var tv = findDeclaredTypeVariable(decl, name);\n+            if (tv != null)\n+                return tv;\n+        }\n+        throw new TypeNotPresentException(name, null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/GenericDeclInfo.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.info;\n+\n+import sun.invoke.util.Wrapper;\n+import sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl;\n+import sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;\n+import sun.reflect.generics.reflectiveObjects.WildcardTypeImpl;\n+\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+\n+\/**\n+ * A generic info is a context for signature resolution.\n+ * Its subclasses resolve different signatures on demand.\n+ *\n+ * @param <T> the enclosing generic declaration type\n+ *\/\n+public abstract sealed class GenericInfo<T extends GenericDeclaration>\n+        permits FieldGenericInfo, GenericDeclInfo {\n+    final T closestDeclaration;\n+\n+    GenericInfo(T closestDecl) {\n+        this.closestDeclaration = Objects.requireNonNull(closestDecl);\n+    }\n+\n+    public final Type resolve(Signature signature) {\n+        return switch (signature) {\n+            case Signature.BaseTypeSig baseTypeSig -> Wrapper\n+                    .forBasicType(baseTypeSig.baseType())\n+                    .primitiveType();\n+            case Signature.ArrayTypeSig arrayTypeSig -> {\n+                var component = resolve(arrayTypeSig.componentSignature());\n+                yield component instanceof Class<?> cl\n+                        ? cl.arrayType()\n+                        : GenericArrayTypeImpl.make(component);\n+            }\n+            case Signature.TypeVarSig typeVarSig -> findTypeVariable(typeVarSig.identifier());\n+            case Signature.ClassTypeSig classTypeSig -> resolve(classTypeSig);\n+        };\n+    }\n+\n+    public final Type[] resolve(List<? extends Signature> signatures) {\n+        Type[] ret = new Type[signatures.size()];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = resolve(signatures.get(i));\n+        }\n+        return ret;\n+    }\n+\n+    private Type resolve(Signature.ClassTypeSig classTypeSig) {\n+        var outerSig = classTypeSig.outerType().orElse(null);\n+        Type owner;\n+        String rawName;\n+        if (outerSig != null) {\n+            owner = resolve(outerSig);\n+            rawName = (owner instanceof Class<?> cl ? cl.getName()\n+                    : ((Class<?>) ((ParameterizedType) owner).getRawType()).getName())\n+                    + \"$\" + classTypeSig.className();\n+        } else {\n+            owner = null;\n+            rawName = classTypeSig.className().replace('\/', '.');\n+        }\n+\n+        Class<?> raw;\n+        try {\n+            raw = Class.forName(rawName, false, loader());\n+        } catch (ClassNotFoundException ex) {\n+            throw new TypeNotPresentException(rawName, ex);\n+        }\n+\n+        var typeArgs = classTypeSig.typeArgs();\n+        if (typeArgs.isEmpty() && !(owner instanceof ParameterizedType)) {\n+            return raw;\n+        }\n+        return ParameterizedTypeImpl.make(raw, resolveTypeArgs(typeArgs), owner);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends GenericDeclaration> TypeVariable<T>[] emptyTypeVars() {\n+        return (TypeVariable<T>[]) EMPTY_TYPE_VARS;\n+    }\n+\n+    private static final TypeVariable<?>[] EMPTY_TYPE_VARS = new TypeVariable<?>[0];\n+    public static final Type[] EMPTY_TYPE_ARRAY = new Type[0];\n+    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n+    private static final Signature[] SIG_OBJECT_ARRAY = new Signature[] { Signature.of(CD_Object) };\n+    private static final Signature[] EMPTY_SIG_ARRAY = new Signature[0];\n+\n+    private Type[] resolveTypeArgs(List<Signature.TypeArg> typeArgs) {\n+        if (typeArgs.isEmpty()) {\n+            return EMPTY_TYPE_ARRAY;\n+        }\n+        int n = typeArgs.size();\n+        Type[] ret = new Type[n];\n+        for (int i = 0; i < n; i++) {\n+            ret[i] = resolve(typeArgs.get(i));\n+        }\n+        return ret;\n+    }\n+\n+    private Type resolve(Signature.TypeArg typeArg) {\n+        return switch (typeArg) {\n+            case Signature.TypeArg.Bounded b -> switch (b.wildcardIndicator()) {\n+                case NONE -> resolve(b.boundType());\n+                case SUPER -> WildcardTypeImpl.make(SIG_OBJECT_ARRAY, new Signature[]{b.boundType()}, this);\n+                case EXTENDS -> WildcardTypeImpl.make(new Signature[]{b.boundType()}, EMPTY_SIG_ARRAY, this);\n+            };\n+            case Signature.TypeArg.Unbounded _ -> WildcardTypeImpl.make(SIG_OBJECT_ARRAY, EMPTY_SIG_ARRAY, this);\n+        };\n+    }\n+\n+    ClassLoader loader() {\n+        if (closestDeclaration instanceof Executable exec) {\n+            return exec.getDeclaringClass().getClassLoader();\n+        }\n+        return ((Class<?>) closestDeclaration).getClassLoader();\n+    }\n+\n+    TypeVariable<?> findTypeVariable(String name) {\n+        for (GenericDeclaration decl = closestDeclaration; decl != null; decl = findParent(decl)) {\n+            var tv = findDeclaredTypeVariable(decl, name);\n+            if (tv != null) {\n+                return tv;\n+            }\n+        }\n+        throw new TypeNotPresentException(name, null);\n+    }\n+\n+    static GenericDeclaration findParent(GenericDeclaration decl) {\n+        if (decl instanceof Class<?> cl) {\n+            Method m = cl.getEnclosingMethod();\n+            if (m != null)\n+                return m;\n+\n+            Constructor<?> ctor = cl.getEnclosingConstructor();\n+            if (ctor != null)\n+                return ctor;\n+\n+            return cl.getEnclosingClass(); \/\/ may return null\n+        }\n+        return ((Executable) decl).getDeclaringClass();\n+    }\n+\n+    static TypeVariable<?> findDeclaredTypeVariable(GenericDeclaration decl, String name) {\n+        for (var tv : decl.getTypeParameters()) {\n+            if (tv.getName().equals(name)) {\n+                return tv;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/GenericInfo.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -1,634 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.parser;\n-\n-import java.lang.reflect.GenericSignatureFormatError;\n-import java.util.*;\n-import sun.reflect.generics.tree.*;\n-\n-\/**\n- * Parser for type signatures, as defined in the Java Virtual\n- * Machine Specification (JVMS) chapter 4.\n- * Converts the signatures into an abstract syntax tree (AST) representation.\n- * See the package sun.reflect.generics.tree for details of the AST.\n- *\/\n-public class SignatureParser {\n-    \/\/ The input is conceptually a character stream (though currently it's\n-    \/\/ a string). This is slightly different than traditional parsers,\n-    \/\/ because there is no lexical scanner performing tokenization.\n-    \/\/ Having a separate tokenizer does not fit with the nature of the\n-    \/\/ input format.\n-    \/\/ Other than the absence of a tokenizer, this parser is a classic\n-    \/\/ recursive descent parser. Its structure corresponds as closely\n-    \/\/ as possible to the grammar in the JVMS.\n-    \/\/\n-    \/\/ A note on asserts vs. errors: The code contains assertions\n-    \/\/ in situations that should never occur. An assertion failure\n-    \/\/ indicates a failure of the parser logic. A common pattern\n-    \/\/ is an assertion that the current input is a particular\n-    \/\/ character. This is often paired with a separate check\n-    \/\/ that this is the case, which seems redundant. For example:\n-    \/\/\n-    \/\/ assert(current() != x);\n-    \/\/ if (current != x {error(\"expected an x\");\n-    \/\/\n-    \/\/ where x is some character constant.\n-    \/\/ The assertion indicates, that, as currently written,\n-    \/\/ the code should never reach this point unless the input is an\n-    \/\/ x. On the other hand, the test is there to check the legality\n-    \/\/ of the input wrt to a given production. It may be that at a later\n-    \/\/ time the code might be called directly, and if the input is\n-    \/\/ invalid, the parser should flag an error in accordance\n-    \/\/ with its logic.\n-\n-    private String input; \/\/ the input signature\n-    private int index;    \/\/ index into the input\n-    private int mark;     \/\/ index of mark\n-    \/\/ used to mark end of input\n-    private static final char EOI = ':';\n-    private static final boolean DEBUG = false;\n-\n-    \/\/ private constructor - enforces use of static factory\n-    private SignatureParser(){}\n-\n-    \/\/ prepares parser for new parsing session\n-    private void init(String s) {\n-        input = s;\n-        mark = index = 0;\n-    }\n-\n-    \/\/ Utility methods.\n-\n-    \/\/ Most parsing routines use the following routines to access the\n-    \/\/ input stream, and advance it as necessary.\n-    \/\/ This makes it easy to adapt the parser to operate on streams\n-    \/\/ of various kinds as well as strings.\n-\n-    \/\/ returns current element of the input\n-    private char current(){\n-        assert(index <= input.length());\n-        return index < input.length() ? input.charAt(index) : EOI;\n-    }\n-\n-    \/\/ advance the input\n-    private void advance(){\n-        assert(index <= input.length());\n-        if (index < input.length()) index++;\n-    }\n-\n-    \/\/ mark current position\n-    private void mark() {\n-        mark = index;\n-    }\n-\n-    \/\/ For debugging, prints current character to the end of the input.\n-    private String remainder() {\n-        return input.substring(index);\n-    }\n-\n-    \/\/ returns a substring of input from mark (inclusive)\n-    \/\/ to current position (exclusive)\n-    private String markToCurrent() {\n-        return input.substring(mark, index);\n-    }\n-\n-    \/\/ Error handling routine. Encapsulates error handling.\n-    \/\/ Takes a string error message as argument.\n-    \/\/ Currently throws a GenericSignatureFormatError.\n-\n-    private Error error(String errorMsg) {\n-        return new GenericSignatureFormatError(\"Signature Parse error: \" + errorMsg +\n-                                               \"\\n\\tRemaining input: \" + remainder());\n-    }\n-\n-    \/**\n-     * Verify the parse has made forward progress; throw an exception\n-     * if no progress.\n-     *\/\n-    private void progress(int startingPosition) {\n-        if (index <= startingPosition)\n-            throw error(\"Failure to make progress!\");\n-    }\n-\n-    \/**\n-     * Static factory method. Produces a parser instance.\n-     * @return an instance of {@code SignatureParser}\n-     *\/\n-    public static SignatureParser make() {\n-        return new SignatureParser();\n-    }\n-\n-    \/**\n-     * Parses a class signature (as defined in the JVMS, chapter 4)\n-     * and produces an abstract syntax tree representing it.\n-     * @param s a string representing the input class signature\n-     * @return An abstract syntax tree for a class signature\n-     * corresponding to the input string\n-     * @throws GenericSignatureFormatError if the input is not a valid\n-     * class signature\n-     *\/\n-    public ClassSignature parseClassSig(String s) {\n-        if (DEBUG) System.out.println(\"Parsing class sig:\" + s);\n-        init(s);\n-        return parseClassSignature();\n-    }\n-\n-    \/**\n-     * Parses a method signature (as defined in the JVMS, chapter 4)\n-     * and produces an abstract syntax tree representing it.\n-     * @param s a string representing the input method signature\n-     * @return An abstract syntax tree for a method signature\n-     * corresponding to the input string\n-     * @throws GenericSignatureFormatError if the input is not a valid\n-     * method signature\n-     *\/\n-    public MethodTypeSignature parseMethodSig(String s) {\n-        if (DEBUG) System.out.println(\"Parsing method sig:\" + s);\n-        init(s);\n-        return parseMethodTypeSignature();\n-    }\n-\n-\n-    \/**\n-     * Parses a type signature\n-     * and produces an abstract syntax tree representing it.\n-     *\n-     * @param s a string representing the input type signature\n-     * @return An abstract syntax tree for a type signature\n-     * corresponding to the input string\n-     * @throws GenericSignatureFormatError if the input is not a valid\n-     * type signature\n-     *\/\n-    public TypeSignature parseTypeSig(String s) {\n-        if (DEBUG) System.out.println(\"Parsing type sig:\" + s);\n-        init(s);\n-        return parseTypeSignature();\n-    }\n-\n-    \/\/ Parsing routines.\n-    \/\/ As a rule, the parsing routines access the input using the\n-    \/\/ utilities current() and advance().\n-    \/\/ The convention is that when a parsing routine is invoked\n-    \/\/ it expects the current input to be the first character it should parse\n-    \/\/ and when it completes parsing, it leaves the input at the first\n-    \/\/ character after the input parses.\n-\n-    \/*\n-     * Note on grammar conventions: a trailing \"*\" matches zero or\n-     * more occurrences, a trailing \"+\" matches one or more occurrences,\n-     * \"_opt\" indicates an optional component.\n-     *\/\n-\n-    \/**\n-     * ClassSignature:\n-     *     FormalTypeParameters_opt SuperclassSignature SuperinterfaceSignature*\n-     *\/\n-    private ClassSignature parseClassSignature() {\n-        \/\/ parse a class signature based on the implicit input.\n-        assert(index == 0);\n-        return ClassSignature.make(parseZeroOrMoreFormalTypeParameters(),\n-                                   parseClassTypeSignature(), \/\/ Only rule for SuperclassSignature\n-                                   parseSuperInterfaces());\n-    }\n-\n-    private FormalTypeParameter[] parseZeroOrMoreFormalTypeParameters(){\n-        if (current() == '<') {\n-            return parseFormalTypeParameters();\n-        } else {\n-            return new FormalTypeParameter[0];\n-        }\n-    }\n-\n-    \/**\n-     * FormalTypeParameters:\n-     *     \"<\" FormalTypeParameter+ \">\"\n-     *\/\n-    private FormalTypeParameter[] parseFormalTypeParameters(){\n-        List<FormalTypeParameter> ftps = new ArrayList<>(3);\n-        assert(current() == '<'); \/\/ should not have been called at all\n-        if (current() != '<') { throw error(\"expected '<'\");}\n-        advance();\n-        ftps.add(parseFormalTypeParameter());\n-        while (current() != '>') {\n-            int startingPosition = index;\n-            ftps.add(parseFormalTypeParameter());\n-            progress(startingPosition);\n-        }\n-        advance();\n-        return ftps.toArray(new FormalTypeParameter[ftps.size()]);\n-    }\n-\n-    \/**\n-     * FormalTypeParameter:\n-     *     Identifier ClassBound InterfaceBound*\n-     *\/\n-    private FormalTypeParameter parseFormalTypeParameter(){\n-        String id = parseIdentifier();\n-        FieldTypeSignature[] bs = parseBounds();\n-        return FormalTypeParameter.make(id, bs);\n-    }\n-\n-    private String parseIdentifier() {\n-        mark();\n-        skipIdentifier();\n-        return markToCurrent();\n-    }\n-\n-    private void skipIdentifier() {\n-        char c = current();\n-        while (c != ';' && c != '.' && c != '\/' &&\n-               c != '[' && c != ':' && c != '>' &&\n-               c != '<' && !Character.isWhitespace(c)) {\n-            advance();\n-            c = current();\n-        }\n-    }\n-\n-    \/**\n-     * FieldTypeSignature:\n-     *     ClassTypeSignature\n-     *     ArrayTypeSignature\n-     *     TypeVariableSignature\n-     *\/\n-    private FieldTypeSignature parseFieldTypeSignature() {\n-        return parseFieldTypeSignature(true);\n-    }\n-\n-    private FieldTypeSignature parseFieldTypeSignature(boolean allowArrays) {\n-        switch(current()) {\n-        case 'L':\n-           return parseClassTypeSignature();\n-        case 'T':\n-            return parseTypeVariableSignature();\n-        case '[':\n-            if (allowArrays)\n-                return parseArrayTypeSignature();\n-            else\n-                throw error(\"Array signature not allowed here.\");\n-        default: throw error(\"Expected Field Type Signature\");\n-        }\n-    }\n-\n-    \/**\n-     * ClassTypeSignature:\n-     *     \"L\" PackageSpecifier_opt SimpleClassTypeSignature ClassTypeSignatureSuffix* \";\"\n-     *\/\n-    private ClassTypeSignature parseClassTypeSignature(){\n-        assert(current() == 'L');\n-        if (current() != 'L') { throw error(\"expected a class type\");}\n-        advance();\n-        List<SimpleClassTypeSignature> scts = new ArrayList<>(5);\n-        scts.add(parsePackageNameAndSimpleClassTypeSignature());\n-\n-        parseClassTypeSignatureSuffix(scts);\n-        if (current() != ';')\n-            throw error(\"expected ';' got '\" + current() + \"'\");\n-\n-        advance();\n-        return ClassTypeSignature.make(scts);\n-    }\n-\n-    \/**\n-     * PackageSpecifier:\n-     *     Identifier \"\/\" PackageSpecifier*\n-     *\/\n-    private SimpleClassTypeSignature parsePackageNameAndSimpleClassTypeSignature() {\n-        \/\/ Parse both any optional leading PackageSpecifier as well as\n-        \/\/ the following SimpleClassTypeSignature.\n-\n-        mark();\n-        skipIdentifier();\n-        while (current() == '\/') {\n-            advance();\n-            skipIdentifier();\n-        }\n-        String id = markToCurrent().replace('\/', '.');\n-\n-        switch (current()) {\n-        case ';':\n-            return SimpleClassTypeSignature.make(id, false, new TypeArgument[0]); \/\/ all done!\n-        case '<':\n-            if (DEBUG) System.out.println(\"\\t remainder: \" + remainder());\n-            return SimpleClassTypeSignature.make(id, false, parseTypeArguments());\n-        default:\n-            throw error(\"expected '<' or ';' but got \" + current());\n-        }\n-    }\n-\n-    \/**\n-     * SimpleClassTypeSignature:\n-     *     Identifier TypeArguments_opt\n-     *\/\n-    private SimpleClassTypeSignature parseSimpleClassTypeSignature(boolean dollar){\n-        String id = parseIdentifier();\n-        char c = current();\n-\n-        switch (c) {\n-        case ';':\n-        case '.':\n-            return SimpleClassTypeSignature.make(id, dollar, new TypeArgument[0]) ;\n-        case '<':\n-            return SimpleClassTypeSignature.make(id, dollar, parseTypeArguments());\n-        default:\n-            throw error(\"expected '<' or ';' or '.', got '\" + c + \"'.\");\n-        }\n-    }\n-\n-    \/**\n-     * ClassTypeSignatureSuffix:\n-     *     \".\" SimpleClassTypeSignature\n-     *\/\n-    private void parseClassTypeSignatureSuffix(List<SimpleClassTypeSignature> scts) {\n-        while (current() == '.') {\n-            advance();\n-            scts.add(parseSimpleClassTypeSignature(true));\n-        }\n-    }\n-\n-    \/**\n-     * TypeArguments:\n-     *     \"<\" TypeArgument+ \">\"\n-     *\/\n-    private TypeArgument[] parseTypeArguments() {\n-        List<TypeArgument> tas = new ArrayList<>(3);\n-        assert(current() == '<');\n-        if (current() != '<') { throw error(\"expected '<'\");}\n-        advance();\n-        tas.add(parseTypeArgument());\n-        while (current() != '>') {\n-                \/\/(matches(current(),  '+', '-', 'L', '[', 'T', '*')) {\n-            tas.add(parseTypeArgument());\n-        }\n-        advance();\n-        return tas.toArray(new TypeArgument[tas.size()]);\n-    }\n-\n-    \/**\n-     * TypeArgument:\n-     *     WildcardIndicator_opt FieldTypeSignature\n-     *     \"*\"\n-     *\/\n-    private TypeArgument parseTypeArgument() {\n-        FieldTypeSignature[] ub, lb;\n-        ub = new FieldTypeSignature[1];\n-        lb = new FieldTypeSignature[1];\n-        TypeArgument[] ta = new TypeArgument[0];\n-        char c = current();\n-        switch (c) {\n-        case '+': {\n-            advance();\n-            ub[0] = parseFieldTypeSignature();\n-            lb[0] = BottomSignature.make(); \/\/ bottom\n-            return Wildcard.make(ub, lb);\n-        }\n-        case '*':{\n-            advance();\n-            ub[0] = SimpleClassTypeSignature.make(\"java.lang.Object\", false, ta);\n-            lb[0] = BottomSignature.make(); \/\/ bottom\n-            return Wildcard.make(ub, lb);\n-        }\n-        case '-': {\n-            advance();\n-            lb[0] = parseFieldTypeSignature();\n-            ub[0] = SimpleClassTypeSignature.make(\"java.lang.Object\", false, ta);\n-            return Wildcard.make(ub, lb);\n-        }\n-        default:\n-            return parseFieldTypeSignature();\n-        }\n-    }\n-\n-    \/**\n-     * TypeVariableSignature:\n-     *     \"T\" Identifier \";\"\n-     *\/\n-    private TypeVariableSignature parseTypeVariableSignature() {\n-        assert(current() == 'T');\n-        if (current() != 'T') { throw error(\"expected a type variable usage\");}\n-        advance();\n-        TypeVariableSignature ts = TypeVariableSignature.make(parseIdentifier());\n-        if (current() != ';') {\n-            throw error(\"; expected in signature of type variable named\" +\n-                  ts.getIdentifier());\n-        }\n-        advance();\n-        return ts;\n-    }\n-\n-    \/**\n-     * ArrayTypeSignature:\n-     *     \"[\" TypeSignature\n-     *\/\n-    private ArrayTypeSignature parseArrayTypeSignature() {\n-        if (current() != '[') {throw error(\"expected array type signature\");}\n-        advance();\n-        return ArrayTypeSignature.make(parseTypeSignature());\n-    }\n-\n-    \/**\n-     * TypeSignature:\n-     *     FieldTypeSignature\n-     *     BaseType\n-     *\/\n-    private TypeSignature parseTypeSignature() {\n-        switch (current()) {\n-        case 'B':\n-        case 'C':\n-        case 'D':\n-        case 'F':\n-        case 'I':\n-        case 'J':\n-        case 'S':\n-        case 'Z':\n-            return parseBaseType();\n-\n-        default:\n-            return parseFieldTypeSignature();\n-        }\n-    }\n-\n-    private BaseType parseBaseType() {\n-        switch(current()) {\n-        case 'B':\n-            advance();\n-            return ByteSignature.make();\n-        case 'C':\n-            advance();\n-            return CharSignature.make();\n-        case 'D':\n-            advance();\n-            return DoubleSignature.make();\n-        case 'F':\n-            advance();\n-            return FloatSignature.make();\n-        case 'I':\n-            advance();\n-            return IntSignature.make();\n-        case 'J':\n-            advance();\n-            return LongSignature.make();\n-        case 'S':\n-            advance();\n-            return ShortSignature.make();\n-        case 'Z':\n-            advance();\n-            return BooleanSignature.make();\n-        default: {\n-            assert(false);\n-            throw error(\"expected primitive type\");\n-        }\n-        }\n-    }\n-\n-    \/**\n-     * ClassBound:\n-     *     \":\" FieldTypeSignature_opt\n-     *\n-     * InterfaceBound:\n-     *     \":\" FieldTypeSignature\n-     *\/\n-    private FieldTypeSignature[] parseBounds() {\n-        List<FieldTypeSignature> fts = new ArrayList<>(3);\n-\n-        if (current() == ':') {\n-            advance();\n-            switch(current()) {\n-            case ':': \/\/ empty class bound\n-                break;\n-\n-            default: \/\/ parse class bound\n-                fts.add(parseFieldTypeSignature());\n-            }\n-\n-            \/\/ zero or more interface bounds\n-            while (current() == ':') {\n-                advance();\n-                fts.add(parseFieldTypeSignature());\n-            }\n-        } else\n-            error(\"Bound expected\");\n-\n-        return fts.toArray(new FieldTypeSignature[fts.size()]);\n-    }\n-\n-    \/**\n-     * SuperclassSignature:\n-     *     ClassTypeSignature\n-     *\/\n-    private ClassTypeSignature[] parseSuperInterfaces() {\n-        List<ClassTypeSignature> cts = new ArrayList<>(5);\n-        while(current() == 'L') {\n-            cts.add(parseClassTypeSignature());\n-        }\n-        return cts.toArray(new ClassTypeSignature[cts.size()]);\n-    }\n-\n-\n-    \/**\n-     * MethodTypeSignature:\n-     *     FormalTypeParameters_opt \"(\" TypeSignature* \")\" ReturnType ThrowsSignature*\n-     *\/\n-    private MethodTypeSignature parseMethodTypeSignature() {\n-        \/\/ Parse a method signature based on the implicit input.\n-        FieldTypeSignature[] ets;\n-\n-        assert(index == 0);\n-        return MethodTypeSignature.make(parseZeroOrMoreFormalTypeParameters(),\n-                                        parseFormalParameters(),\n-                                        parseReturnType(),\n-                                        parseZeroOrMoreThrowsSignatures());\n-    }\n-\n-    \/\/ \"(\" TypeSignature* \")\"\n-    private TypeSignature[] parseFormalParameters() {\n-        if (current() != '(') {throw error(\"expected '('\");}\n-        advance();\n-        TypeSignature[] pts = parseZeroOrMoreTypeSignatures();\n-        if (current() != ')') {throw error(\"expected ')'\");}\n-        advance();\n-        return pts;\n-    }\n-\n-    \/\/ TypeSignature*\n-    private TypeSignature[] parseZeroOrMoreTypeSignatures() {\n-        List<TypeSignature> ts = new ArrayList<>();\n-        boolean stop = false;\n-        while (!stop) {\n-            switch(current()) {\n-            case 'B':\n-            case 'C':\n-            case 'D':\n-            case 'F':\n-            case 'I':\n-            case 'J':\n-            case 'S':\n-            case 'Z':\n-            case 'L':\n-            case 'T':\n-            case '[': {\n-                ts.add(parseTypeSignature());\n-                break;\n-            }\n-            default: stop = true;\n-            }\n-        }\n-        return ts.toArray(new TypeSignature[ts.size()]);\n-    }\n-\n-    \/**\n-     * ReturnType:\n-     *     TypeSignature\n-     *     VoidDescriptor\n-     *\/\n-    private ReturnType parseReturnType(){\n-        if (current() == 'V') {\n-            advance();\n-            return VoidDescriptor.make();\n-        } else\n-            return parseTypeSignature();\n-    }\n-\n-    \/\/ ThrowSignature*\n-    private FieldTypeSignature[] parseZeroOrMoreThrowsSignatures(){\n-        List<FieldTypeSignature> ets = new ArrayList<>(3);\n-        while( current() == '^') {\n-            ets.add(parseThrowsSignature());\n-        }\n-        return ets.toArray(new FieldTypeSignature[ets.size()]);\n-    }\n-\n-    \/**\n-     * ThrowsSignature:\n-     *     \"^\" ClassTypeSignature\n-     *     \"^\" TypeVariableSignature\n-     *\/\n-    private FieldTypeSignature parseThrowsSignature() {\n-        assert(current() == '^');\n-        if (current() != '^') { throw error(\"expected throws signature\");}\n-        advance();\n-        return parseFieldTypeSignature(false);\n-    }\n- }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/parser\/SignatureParser.java","additions":0,"deletions":634,"binary":false,"changes":634,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.classfile.Signature;\n@@ -29,3 +30,1 @@\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n-import sun.reflect.generics.visitor.Reifier;\n+import sun.reflect.generics.info.GenericInfo;\n@@ -45,1 +44,1 @@\n-    private final GenericsFactory factory; \/\/ cached factory\n+    private final GenericInfo<?> factory; \/\/ cached factory\n@@ -47,1 +46,1 @@\n-    protected LazyReflectiveObjectGenerator(GenericsFactory f) {\n+    protected LazyReflectiveObjectGenerator(GenericInfo<?> f) {\n@@ -51,9 +50,1 @@\n-    \/\/ accessor for factory\n-    private GenericsFactory getFactory() {\n-        return factory;\n-    }\n-\n-    \/\/ produce a reifying visitor (could this be typed as a TypeTreeVisitor?\n-    protected Reifier getReifier(){return Reifier.make(getFactory());}\n-\n-    Type[] reifyBounds(FieldTypeSignature[] boundASTs) {\n+    Type[] reifyBounds(Signature[] boundASTs) {\n@@ -64,3 +55,1 @@\n-            Reifier r = getReifier();\n-            boundASTs[i].accept(r);\n-            bounds[i] = r.getResult();\n+            bounds[i] = factory.resolve(boundASTs[i]);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/LazyReflectiveObjectGenerator.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.Signature;\n@@ -41,2 +42,1 @@\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n+import sun.reflect.generics.info.GenericInfo;\n@@ -62,2 +62,2 @@\n-    private TypeVariableImpl(D decl, String n, FieldTypeSignature[] bs,\n-                             GenericsFactory f) {\n+    private TypeVariableImpl(D decl, String n, Signature[] bs,\n+                             GenericInfo<D> f) {\n@@ -84,2 +84,2 @@\n-                                                      FieldTypeSignature[] bs,\n-                                                      GenericsFactory f) {\n+                                                      Signature[] bs,\n+                                                      GenericInfo<T> f) {\n@@ -105,1 +105,1 @@\n-     *  (see {@link #ParameterizedType} for the details of the creation\n+     *  (see {@link ParameterizedType} for the details of the creation\n@@ -110,1 +110,1 @@\n-     * @throws {@code TypeNotPresentException} if any of the\n+     * @throws TypeNotPresentException if any of the\n@@ -112,1 +112,1 @@\n-     * @throws {@code MalformedParameterizedTypeException} if any of the\n+     * @throws MalformedParameterizedTypeException if any of the\n@@ -120,1 +120,1 @@\n-        if (value instanceof FieldTypeSignature[] sigs) {\n+        if (value instanceof Signature[] sigs) {\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/TypeVariableImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.lang.classfile.Signature;\n+import java.lang.reflect.MalformedParameterizedTypeException;\n+import java.lang.reflect.ParameterizedType;\n@@ -31,2 +34,2 @@\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n+import sun.reflect.generics.info.GenericInfo;\n+\n@@ -56,3 +59,3 @@\n-    private WildcardTypeImpl(FieldTypeSignature[] ubs,\n-                             FieldTypeSignature[] lbs,\n-                             GenericsFactory f) {\n+    private WildcardTypeImpl(Signature[] ubs,\n+                             Signature[] lbs,\n+                             GenericInfo<?> f) {\n@@ -74,3 +77,3 @@\n-    public static WildcardTypeImpl make(FieldTypeSignature[] ubs,\n-                                        FieldTypeSignature[] lbs,\n-                                        GenericsFactory f) {\n+    public static WildcardTypeImpl make(Signature[] ubs,\n+                                        Signature[] lbs,\n+                                        GenericInfo<?> f) {\n@@ -88,1 +91,1 @@\n-     *  (see {@link #ParameterizedType} for the details of the creation\n+     *  (see {@link ParameterizedType} for the details of the creation\n@@ -95,1 +98,1 @@\n-     * @throws {@code TypeNotPresentException} if any of the\n+     * @throws TypeNotPresentException if any of the\n@@ -97,1 +100,1 @@\n-     * @throws {@code MalformedParameterizedTypeException} if any of the\n+     * @throws MalformedParameterizedTypeException if any of the\n@@ -103,1 +106,1 @@\n-        if (value instanceof FieldTypeSignature[] sigs) {\n+        if (value instanceof Signature[] sigs) {\n@@ -119,1 +122,1 @@\n-     *   (see {@link #ParameterizedType} for the details of the creation\n+     *   (see {@link ParameterizedType} for the details of the creation\n@@ -126,1 +129,1 @@\n-     * @throws {@code TypeNotPresentException} if any of the\n+     * @throws TypeNotPresentException if any of the\n@@ -128,1 +131,1 @@\n-     * @throws {@code MalformedParameterizedTypeException} if any of the\n+     * @throws MalformedParameterizedTypeException if any of the\n@@ -134,1 +137,1 @@\n-        if (value instanceof FieldTypeSignature[] sigs) {\n+        if (value instanceof Signature[] sigs) {\n@@ -157,2 +160,0 @@\n-        assert bounds.length > 0;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/WildcardTypeImpl.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.Tree;\n-import sun.reflect.generics.visitor.Reifier;\n-\n-\n-\/**\n- * Abstract superclass for representing the generic type information for\n- * a reflective entity.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public abstract class AbstractRepository<T extends Tree> {\n-\n-    \/\/ A factory used to produce reflective objects. Provided when the\n-    \/\/repository is created. Will vary across implementations.\n-    private final GenericsFactory factory;\n-\n-    private final T tree; \/\/ the AST for the generic type info\n-\n-    \/\/accessors\n-    private GenericsFactory getFactory() { return factory;}\n-\n-    \/**\n-     * Accessor for {@code tree}.\n-     * @return the cached AST this repository holds\n-     *\/\n-    protected T getTree(){ return tree;}\n-\n-    \/**\n-     * Returns a {@code Reifier} used to convert parts of the\n-     * AST into reflective objects.\n-     * @return a {@code Reifier} used to convert parts of the\n-     * AST into reflective objects\n-     *\/\n-    protected Reifier getReifier(){return Reifier.make(getFactory());}\n-\n-    \/**\n-     * Constructor. Should only be used by subclasses. Concrete subclasses\n-     * should make their constructors private and provide public factory\n-     * methods.\n-     * @param rawSig - the generic signature of the reflective object\n-     * that this repository is servicing\n-     * @param f - a factory that will provide instances of reflective\n-     * objects when this repository converts its AST\n-     *\/\n-    protected AbstractRepository(String rawSig, GenericsFactory f) {\n-        tree = parse(rawSig);\n-        factory = f;\n-    }\n-\n-    \/**\n-     * Returns the AST for the generic type info of this entity.\n-     * @param s - a string representing the generic signature of this\n-     * entity\n-     * @return the AST for the generic type info of this entity.\n-     *\/\n-    protected abstract T parse(String s);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/AbstractRepository.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-import java.lang.reflect.Type;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.ClassSignature;\n-import sun.reflect.generics.tree.TypeTree;\n-import sun.reflect.generics.visitor.Reifier;\n-import sun.reflect.generics.parser.SignatureParser;\n-\n-\n-\/**\n- * This class represents the generic type information for a class.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public class ClassRepository extends GenericDeclRepository<ClassSignature> {\n-\n-    public static final ClassRepository NONE = ClassRepository.make(\"Ljava\/lang\/Object;\", null);\n-\n-    \/** The generic superclass info.  Lazily initialized. *\/\n-    private volatile Type superclass;\n-\n-    \/** The generic superinterface info.  Lazily initialized. *\/\n-    private volatile Type[] superInterfaces;\n-\n-    \/\/ private, to enforce use of static factory\n-    private ClassRepository(String rawSig, GenericsFactory f) {\n-        super(rawSig, f);\n-    }\n-\n-    protected ClassSignature parse(String s) {\n-        return SignatureParser.make().parseClassSig(s);\n-    }\n-\n-    \/**\n-     * Static factory method.\n-     * @param rawSig - the generic signature of the reflective object\n-     * that this repository is servicing\n-     * @param f - a factory that will provide instances of reflective\n-     * objects when this repository converts its AST\n-     * @return a {@code ClassRepository} that manages the generic type\n-     * information represented in the signature {@code rawSig}\n-     *\/\n-    public static ClassRepository make(String rawSig, GenericsFactory f) {\n-        return new ClassRepository(rawSig, f);\n-    }\n-\n-    \/*\n-     * When queried for a particular piece of type information, the\n-     * general pattern is to consult the corresponding cached value.\n-     * If the corresponding field is non-null, it is returned.\n-     * If not, it is created lazily. This is done by selecting the appropriate\n-     * part of the tree and transforming it into a reflective object\n-     * using a visitor, which is created by feeding it the factory\n-     * with which the repository was created.\n-     *\/\n-\n-    public Type getSuperclass() {\n-        Type value = superclass;\n-        if (value == null) {\n-            value = computeSuperclass();\n-            superclass = value;\n-        }\n-        return value;\n-    }\n-\n-    public Type[] getSuperInterfaces() {\n-        Type[] value = superInterfaces;\n-        if (value == null) {\n-            value = computeSuperInterfaces();\n-            superInterfaces = value;\n-        }\n-        return value.clone();\n-    }\n-\n-    private Type computeSuperclass() {\n-        Reifier r = getReifier(); \/\/ obtain visitor\n-        \/\/ Extract superclass subtree from AST and reify\n-        getTree().getSuperclass().accept(r);\n-        return r.getResult();\n-    }\n-\n-    private Type[] computeSuperInterfaces() {\n-        \/\/ first, extract super interface subtree(s) from AST\n-        TypeTree[] ts = getTree().getSuperInterfaces();\n-        \/\/ create array to store reified subtree(s)\n-        int length = ts.length;\n-        Type[] superInterfaces = new Type[length];\n-        \/\/ reify all subtrees\n-        for (int i = 0; i < length; i++) {\n-            Reifier r = getReifier(); \/\/ obtain visitor\n-            ts[i].accept(r);\/\/ reify subtree\n-            \/\/ extract result from visitor and store it\n-            superInterfaces[i] = r.getResult();\n-        }\n-        return superInterfaces;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/ClassRepository.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-import java.lang.reflect.Type;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.parser.SignatureParser;\n-import sun.reflect.generics.tree.FieldTypeSignature;\n-import sun.reflect.generics.tree.MethodTypeSignature;\n-import sun.reflect.generics.tree.TypeSignature;\n-import sun.reflect.generics.visitor.Reifier;\n-\n-\n-\n-\/**\n- * This class represents the generic type information for a constructor.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public class ConstructorRepository\n-    extends GenericDeclRepository<MethodTypeSignature> {\n-\n-    \/** The generic parameter types.  Lazily initialized. *\/\n-    private volatile Type[] parameterTypes;\n-\n-    \/** The generic exception types.  Lazily initialized. *\/\n-    private volatile Type[] exceptionTypes;\n-\n-    \/\/ protected, to enforce use of static factory yet allow subclassing\n-    protected ConstructorRepository(String rawSig, GenericsFactory f) {\n-      super(rawSig, f);\n-    }\n-\n-    protected MethodTypeSignature parse(String s) {\n-        return SignatureParser.make().parseMethodSig(s);\n-    }\n-\n-    \/**\n-     * Static factory method.\n-     * @param rawSig - the generic signature of the reflective object\n-     * that this repository is servicing\n-     * @param f - a factory that will provide instances of reflective\n-     * objects when this repository converts its AST\n-     * @return a {@code ConstructorRepository} that manages the generic type\n-     * information represented in the signature {@code rawSig}\n-     *\/\n-    public static ConstructorRepository make(String rawSig, GenericsFactory f) {\n-        return new ConstructorRepository(rawSig, f);\n-    }\n-\n-    \/*\n-     * When queried for a particular piece of type information, the\n-     * general pattern is to consult the corresponding cached value.\n-     * If the corresponding field is non-null, it is returned.\n-     * If not, it is created lazily. This is done by selecting the appropriate\n-     * part of the tree and transforming it into a reflective object\n-     * using a visitor, which is created by feeding it the factory\n-     * with which the repository was created.\n-     *\/\n-\n-    public Type[] getParameterTypes() {\n-        Type[] value = parameterTypes;\n-        if (value == null) {\n-            value = computeParameterTypes();\n-            parameterTypes = value;\n-        }\n-        return value.clone();\n-    }\n-\n-    public Type[] getExceptionTypes() {\n-        Type[] value = exceptionTypes;\n-        if (value == null) {\n-            value = computeExceptionTypes();\n-            exceptionTypes = value;\n-        }\n-        return value.clone();\n-    }\n-\n-    private Type[] computeParameterTypes() {\n-        \/\/ first, extract parameter type subtree(s) from AST\n-        TypeSignature[] pts = getTree().getParameterTypes();\n-        \/\/ create array to store reified subtree(s)\n-        int length = pts.length;\n-        Type[] parameterTypes = new Type[length];\n-        \/\/ reify all subtrees\n-        for (int i = 0; i < length; i++) {\n-            Reifier r = getReifier(); \/\/ obtain visitor\n-            pts[i].accept(r); \/\/ reify subtree\n-            \/\/ extract result from visitor and store it\n-            parameterTypes[i] = r.getResult();\n-        }\n-        return parameterTypes;\n-    }\n-\n-    private Type[] computeExceptionTypes() {\n-        \/\/ first, extract exception type subtree(s) from AST\n-        FieldTypeSignature[] ets = getTree().getExceptionTypes();\n-        \/\/ create array to store reified subtree(s)\n-        int length = ets.length;\n-        Type[] exceptionTypes = new Type[length];\n-        \/\/ reify all subtrees\n-        for (int i = 0; i < length; i++) {\n-            Reifier r = getReifier(); \/\/ obtain visitor\n-            ets[i].accept(r); \/\/ reify subtree\n-            \/\/ extract result from visitor and store it\n-            exceptionTypes[i] = r.getResult();\n-        }\n-        return exceptionTypes;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/ConstructorRepository.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-\n-import java.lang.reflect.Type;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.TypeSignature;\n-import sun.reflect.generics.parser.SignatureParser;\n-import sun.reflect.generics.visitor.Reifier;\n-\n-\n-\n-\/**\n- * This class represents the generic type information for a constructor.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public class FieldRepository extends AbstractRepository<TypeSignature> {\n-\n-    \/** The generic type info.  Lazily initialized. *\/\n-    private volatile Type genericType;\n-\n-    \/\/ protected, to enforce use of static factory yet allow subclassing\n-    protected FieldRepository(String rawSig, GenericsFactory f) {\n-      super(rawSig, f);\n-    }\n-\n-    protected TypeSignature parse(String s) {\n-        return SignatureParser.make().parseTypeSig(s);\n-    }\n-\n-    \/**\n-     * Static factory method.\n-     * @param rawSig - the generic signature of the reflective object\n-     * that this repository is servicing\n-     * @param f - a factory that will provide instances of reflective\n-     * objects when this repository converts its AST\n-     * @return a {@code FieldRepository} that manages the generic type\n-     * information represented in the signature {@code rawSig}\n-     *\/\n-    public static FieldRepository make(String rawSig, GenericsFactory f) {\n-        return new FieldRepository(rawSig, f);\n-    }\n-\n-    \/*\n-     * When queried for a particular piece of type information, the\n-     * general pattern is to consult the corresponding cached value.\n-     * If the corresponding field is non-null, it is returned.\n-     * If not, it is created lazily. This is done by selecting the appropriate\n-     * part of the tree and transforming it into a reflective object\n-     * using a visitor, which is created by feeding it the factory\n-     * with which the repository was created.\n-     *\/\n-\n-    public Type getGenericType() {\n-        Type value = genericType;\n-        if (value == null) {\n-            value = computeGenericType();\n-            genericType = value;\n-        }\n-        return value;\n-    }\n-\n-    private Type computeGenericType() {\n-        Reifier r = getReifier();       \/\/ obtain visitor\n-        getTree().accept(r);            \/\/ reify subtree\n-        return r.getResult();           \/\/ extract result from visitor\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/FieldRepository.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-import java.lang.reflect.TypeVariable;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.tree.FormalTypeParameter;\n-import sun.reflect.generics.tree.Signature;\n-import sun.reflect.generics.visitor.Reifier;\n-\n-\n-\n-\/**\n- * This class represents the generic type information for a generic\n- * declaration.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public abstract class GenericDeclRepository<S extends Signature>\n-    extends AbstractRepository<S> {\n-\n-    public static final TypeVariable<?>[] EMPTY_TYPE_VARS = new TypeVariable<?>[0];\n-\n-    \/** The formal type parameters.  Lazily initialized. *\/\n-    private volatile TypeVariable<?>[] typeParameters;\n-\n-    protected GenericDeclRepository(String rawSig, GenericsFactory f) {\n-        super(rawSig, f);\n-    }\n-\n-    \/*\n-     * When queried for a particular piece of type information, the\n-     * general pattern is to consult the corresponding cached value.\n-     * If the corresponding field is non-null, it is returned.\n-     * If not, it is created lazily. This is done by selecting the appropriate\n-     * part of the tree and transforming it into a reflective object\n-     * using a visitor, which is created by feeding it the factory\n-     * with which the repository was created.\n-     *\/\n-\n-    \/**\n-     * Returns the formal type parameters of this generic declaration.\n-     * @return the formal type parameters of this generic declaration\n-     *\/\n-    public TypeVariable<?>[] getTypeParameters() {\n-        TypeVariable<?>[] value = typeParameters;\n-        if (value == null) {\n-            value = computeTypeParameters();\n-            typeParameters = value;\n-        }\n-        return value.clone();\n-    }\n-\n-    private TypeVariable<?>[] computeTypeParameters() {\n-        \/\/ first, extract type parameter subtree(s) from AST\n-        FormalTypeParameter[] ftps = getTree().getFormalTypeParameters();\n-        \/\/ create array to store reified subtree(s)\n-        int length = ftps.length;\n-        if (length == 0) {\n-            return EMPTY_TYPE_VARS;\n-        }\n-        TypeVariable<?>[] typeParameters = new TypeVariable<?>[length];\n-        \/\/ reify all subtrees\n-        for (int i = 0; i < length; i++) {\n-            Reifier r = getReifier(); \/\/ obtain visitor\n-            ftps[i].accept(r); \/\/ reify subtree\n-            \/\/ extract result from visitor and store it\n-            typeParameters[i] = (TypeVariable<?>) r.getResult();\n-        }\n-        return typeParameters;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/GenericDeclRepository.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.repository;\n-\n-\n-import java.lang.reflect.Type;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.visitor.Reifier;\n-\n-\n-\n-\/**\n- * This class represents the generic type information for a method.\n- * The code is not dependent on a particular reflective implementation.\n- * It is designed to be used unchanged by at least core reflection and JDI.\n- *\/\n-public class MethodRepository extends ConstructorRepository {\n-\n-    \/** The generic return type info.  Lazily initialized. *\/\n-    private volatile Type returnType;\n-\n- \/\/ private, to enforce use of static factory\n-    private MethodRepository(String rawSig, GenericsFactory f) {\n-      super(rawSig, f);\n-    }\n-\n-    \/**\n-     * Static factory method.\n-     * @param rawSig - the generic signature of the reflective object\n-     * that this repository is servicing\n-     * @param f - a factory that will provide instances of reflective\n-     * objects when this repository converts its AST\n-     * @return a {@code MethodRepository} that manages the generic type\n-     * information represented in the signature {@code rawSig}\n-     *\/\n-    public static MethodRepository make(String rawSig, GenericsFactory f) {\n-        return new MethodRepository(rawSig, f);\n-    }\n-\n-    public Type getReturnType() {\n-        Type value = returnType;\n-        if (value == null) {\n-            value = computeReturnType();\n-            returnType = value;\n-        }\n-        return value;\n-    }\n-\n-    private Type computeReturnType() {\n-        Reifier r = getReifier(); \/\/ obtain visitor\n-        \/\/ Extract return type subtree from AST and reify\n-        getTree().getReturnType().accept(r);\n-        \/\/ extract result from visitor and cache it\n-        return r.getResult();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/repository\/MethodRepository.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.GenericDeclaration;\n-import java.lang.reflect.TypeVariable;\n-\n-\n-\/**\n- * Abstract superclass for lazy scope objects, used when building\n- * factories for generic information repositories.\n- * The type parameter {@code D} represents the type of reflective\n- * object whose scope this class is representing.\n- * <p> To subclass this, all one needs to do is implement\n- * {@code computeEnclosingScope} and the subclass' constructor.\n- *\/\n-public abstract class AbstractScope<D extends GenericDeclaration>\n-    implements Scope {\n-\n-    private final D recvr; \/\/ the declaration whose scope this instance represents\n-\n-    \/** The enclosing scope of this scope.  Lazily initialized. *\/\n-    private volatile Scope enclosingScope;\n-\n-    \/**\n-     * Constructor. Takes a reflective object whose scope the newly\n-     * constructed instance will represent.\n-     * @param decl - A generic declaration whose scope the newly\n-     * constructed instance will represent\n-     *\/\n-    protected AbstractScope(D decl){ recvr = decl;}\n-\n-    \/**\n-     * Accessor for the receiver - the object whose scope this {@code Scope}\n-     * object represents.\n-     * @return The object whose scope this {@code Scope} object represents\n-     *\/\n-    protected D getRecvr() {return recvr;}\n-\n-    \/** This method must be implemented by any concrete subclass.\n-     * It must return the enclosing scope of this scope. If this scope\n-     * is a top-level scope, an instance of DummyScope must be returned.\n-     * @return The enclosing scope of this scope\n-     *\/\n-    protected abstract Scope computeEnclosingScope();\n-\n-    \/**\n-     * Accessor for the enclosing scope, which is computed lazily and cached.\n-     * @return the enclosing scope\n-     *\/\n-    protected Scope getEnclosingScope() {\n-        Scope value = enclosingScope;\n-        if (value == null) {\n-            value = computeEnclosingScope();\n-            enclosingScope = value;\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Lookup a type variable in the scope, using its name. Returns null if\n-     * no type variable with this name is declared in this scope or any of its\n-     * surrounding scopes.\n-     * @param name - the name of the type variable being looked up\n-     * @return the requested type variable, if found\n-     *\/\n-    public TypeVariable<?> lookup(String name) {\n-        TypeVariable<?>[] tas = getRecvr().getTypeParameters();\n-        for (TypeVariable<?> tv : tas) {\n-            if (tv.getName().equals(name)) {return tv;}\n-        }\n-        return getEnclosingScope().lookup(name);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/AbstractScope.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-\n-\n-\/**\n- * This class represents the scope containing the type variables of\n- * a class.\n- *\/\n-public class ClassScope extends AbstractScope<Class<?>> implements Scope {\n-\n-    \/\/ constructor is private to enforce use of factory method\n-    private ClassScope(Class<?> c){\n-        super(c);\n-    }\n-\n-    \/**\n-     * Overrides the abstract method in the superclass.\n-     * @return the enclosing scope\n-     *\/\n-    protected Scope computeEnclosingScope() {\n-        Class<?> receiver = getRecvr();\n-\n-        Method m = receiver.getEnclosingMethod();\n-        if (m != null)\n-            \/\/ Receiver is a local or anonymous class enclosed in a\n-            \/\/ method.\n-            return MethodScope.make(m);\n-\n-        Constructor<?> cnstr = receiver.getEnclosingConstructor();\n-        if (cnstr != null)\n-            \/\/ Receiver is a local or anonymous class enclosed in a\n-            \/\/ constructor.\n-            return ConstructorScope.make(cnstr);\n-\n-        Class<?> c = receiver.getEnclosingClass();\n-        \/\/ if there is a declaring class, recvr is a member class\n-        \/\/ and its enclosing scope is that of the declaring class\n-        if (c != null)\n-            \/\/ Receiver is a local class, an anonymous class, or a\n-            \/\/ member class (static or not).\n-            return ClassScope.make(c);\n-\n-        \/\/ otherwise, recvr is a top level class, and it has no real\n-        \/\/ enclosing scope.\n-        return DummyScope.make();\n-    }\n-\n-    \/**\n-     * Factory method. Takes a {@code Class} object and creates a\n-     * scope for it.\n-     * @param c - a Class whose scope we want to obtain\n-     * @return The type-variable scope for the class c\n-     *\/\n-    public static ClassScope make(Class<?> c) { return new ClassScope(c);}\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/ClassScope.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.Constructor;\n-\n-\n-\/**\n- * This class represents the scope containing the type variables of\n- * a constructor.\n- *\/\n-public class ConstructorScope extends AbstractScope<Constructor<?>> {\n-\n-    \/\/ constructor is private to enforce use of factory method\n-    private ConstructorScope(Constructor<?> c){\n-        super(c);\n-    }\n-\n-    \/\/ utility method; computes enclosing class, from which we can\n-    \/\/ derive enclosing scope.\n-    private Class<?> getEnclosingClass(){\n-        return getRecvr().getDeclaringClass();\n-    }\n-\n-    \/**\n-     * Overrides the abstract method in the superclass.\n-     * @return the enclosing scope\n-     *\/\n-    protected Scope computeEnclosingScope() {\n-        \/\/ the enclosing scope of a (generic) constructor is the scope of the\n-        \/\/ class in which it was declared.\n-        return ClassScope.make(getEnclosingClass());\n-    }\n-\n-    \/**\n-     * Factory method. Takes a {@code Constructor} object and creates a\n-     * scope for it.\n-     * @param c - A Constructor whose scope we want to obtain\n-     * @return The type-variable scope for the constructor m\n-     *\/\n-    public static ConstructorScope make(Constructor<?> c) {\n-        return new ConstructorScope(c);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/ConstructorScope.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.TypeVariable;\n-\n-\/**\n- * This class is used to provide enclosing scopes for top level classes.\n- * We cannot use {@code null} to represent such a scope, since the\n- * enclosing scope is computed lazily, and so the field storing it is\n- * null until it has been computed. Therefore, {@code null} is reserved\n- * to represent an as-yet-uncomputed scope, and cannot be used for any\n- * other kind of scope.\n- *\/\n-public class DummyScope implements Scope {\n-    \/\/ Caches the unique instance of this class; instances contain no data\n-    \/\/ so we can use the singleton pattern\n-    private static final DummyScope singleton = new DummyScope();\n-\n-    \/\/ constructor is private to enforce use of factory method\n-    private DummyScope(){}\n-\n-    \/**\n-     * Factory method. Enforces the singleton pattern - only one\n-     * instance of this class ever exists.\n-     *\/\n-    public static DummyScope make() {\n-        return singleton;\n-    }\n-\n-    \/**\n-     * Lookup a type variable in the scope, using its name. Always returns\n-     * {@code null}.\n-     * @param name - the name of the type variable being looked up\n-     * @return  null\n-     *\/\n-    public TypeVariable<?> lookup(String name) {return null;}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/DummyScope.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.Method;\n-\n-\n-\/**\n- * This class represents the scope containing the type variables of\n- * a method.\n- *\/\n-public class MethodScope extends AbstractScope<Method> {\n-\n-    \/\/ constructor is private to enforce use of factory method\n-    private MethodScope(Method m){\n-        super(m);\n-    }\n-\n-    \/\/ utility method; computes enclosing class, from which we can\n-    \/\/ derive enclosing scope.\n-    private Class<?> getEnclosingClass(){\n-        return getRecvr().getDeclaringClass();\n-    }\n-\n-    \/**\n-     * Overrides the abstract method in the superclass.\n-     * @return the enclosing scope\n-     *\/\n-    protected Scope computeEnclosingScope() {\n-        \/\/ the enclosing scope of a (generic) method is the scope of the\n-        \/\/ class in which it was declared.\n-        return ClassScope.make(getEnclosingClass());\n-    }\n-\n-    \/**\n-     * Factory method. Takes a {@code Method} object and creates a\n-     * scope for it.\n-     * @param m - A Method whose scope we want to obtain\n-     * @return The type-variable scope for the method m\n-     *\/\n-    public static MethodScope make(Method m) {\n-        return new MethodScope(m);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/MethodScope.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.scope;\n-\n-import java.lang.reflect.TypeVariable;\n-\n-\n-public interface Scope {\n-    TypeVariable<?> lookup(String name);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/scope\/Scope.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-public class ArrayTypeSignature implements FieldTypeSignature {\n-    private final TypeSignature componentType;\n-\n-    private ArrayTypeSignature(TypeSignature ct) {componentType = ct;}\n-\n-    public static ArrayTypeSignature make(TypeSignature ct) {\n-        return new ArrayTypeSignature(ct);\n-    }\n-\n-    public TypeSignature getComponentType(){return componentType;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitArrayTypeSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ArrayTypeSignature.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/**\n- * Common superinterface for all nodes representing a primitive type.\n- * Corresponds to the production of the same name in the JVMS\n- * section on signatures.\n- *\/\n-public interface BaseType\n-    extends TypeSignature{}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/BaseType.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type boolean. *\/\n-public class BooleanSignature implements BaseType {\n-    private static final BooleanSignature singleton = new BooleanSignature();\n-\n-    private BooleanSignature(){}\n-\n-    public static BooleanSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitBooleanSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/BooleanSignature.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-public class BottomSignature implements FieldTypeSignature {\n-    private static final BottomSignature singleton = new BottomSignature();\n-\n-    private BottomSignature(){}\n-\n-    public static BottomSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitBottomSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/BottomSignature.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type byte. *\/\n-public class ByteSignature implements BaseType {\n-    private static final ByteSignature singleton = new ByteSignature();\n-\n-    private ByteSignature(){}\n-\n-    public static ByteSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitByteSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ByteSignature.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type char. *\/\n-public class CharSignature implements BaseType {\n-    private static final CharSignature singleton = new CharSignature();\n-\n-    private CharSignature(){}\n-\n-    public static CharSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitCharSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/CharSignature.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.Visitor;\n-\n-public class ClassSignature implements Signature {\n-    private final FormalTypeParameter[] formalTypeParams;\n-    private final ClassTypeSignature superclass;\n-    private final ClassTypeSignature[] superInterfaces;\n-\n-    private ClassSignature(FormalTypeParameter[] ftps,\n-                                      ClassTypeSignature sc,\n-                                      ClassTypeSignature[] sis) {\n-        formalTypeParams = ftps;\n-        superclass = sc;\n-        superInterfaces = sis;\n-    }\n-\n-    public static ClassSignature make(FormalTypeParameter[] ftps,\n-                                      ClassTypeSignature sc,\n-                                      ClassTypeSignature[] sis) {\n-        return new ClassSignature(ftps, sc, sis);\n-    }\n-\n-    public FormalTypeParameter[] getFormalTypeParameters(){\n-        return formalTypeParams;\n-    }\n-    public ClassTypeSignature getSuperclass(){return superclass;}\n-    public ClassTypeSignature[] getSuperInterfaces(){return superInterfaces;}\n-\n-    public void accept(Visitor<?> v){v.visitClassSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ClassSignature.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import java.util.List;\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\n-\/**\n- * AST representing class types.\n- *\/\n-public class ClassTypeSignature implements FieldTypeSignature {\n-    private final List<SimpleClassTypeSignature> path;\n-\n-\n-    private ClassTypeSignature(List<SimpleClassTypeSignature> p) {\n-        path = p;\n-    }\n-\n-    public static ClassTypeSignature make(List<SimpleClassTypeSignature> p) {\n-        return new ClassTypeSignature(p);\n-    }\n-\n-    public List<SimpleClassTypeSignature> getPath(){return path;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitClassTypeSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ClassTypeSignature.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type double. *\/\n-public class DoubleSignature implements BaseType {\n-    private static final DoubleSignature singleton = new DoubleSignature();\n-\n-    private DoubleSignature(){}\n-\n-    public static DoubleSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitDoubleSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/DoubleSignature.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/**\n- * Common superinterface for nodes that represent a (possibly generic)\n- * type.\n- * Corresponds to the production of the same name in the JVMS\n- * section on signatures.\n- *\/\n-public interface FieldTypeSignature\n-    extends BaseType, TypeSignature, TypeArgument {}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/FieldTypeSignature.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type float. *\/\n-public class FloatSignature implements BaseType {\n-    private static final FloatSignature singleton = new FloatSignature();\n-\n-    private FloatSignature(){}\n-\n-    public static FloatSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitFloatSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/FloatSignature.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents a formal type parameter. *\/\n-public class FormalTypeParameter implements TypeTree {\n-    private final String name;\n-    private final FieldTypeSignature[] bounds;\n-\n-    private FormalTypeParameter(String n, FieldTypeSignature[] bs) {\n-        name = n;\n-        bounds = bs;\n-    }\n-\n-    \/**\n-     * Factory method.\n-     * Returns a formal type parameter with the requested name and bounds.\n-     * @param n  the name of the type variable to be created by this method.\n-     * @param bs - the bounds of the type variable to be created by this method.\n-     * @return a formal type parameter with the requested name and bounds\n-     *\/\n-    public static FormalTypeParameter make(String n, FieldTypeSignature[] bs){\n-        return new FormalTypeParameter(n,bs);\n-    }\n-\n-    public FieldTypeSignature[] getBounds(){return bounds;}\n-    public String getName(){return name;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitFormalTypeParameter(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/FormalTypeParameter.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type int. *\/\n-public class IntSignature implements BaseType {\n-    private static final IntSignature singleton = new IntSignature();\n-\n-    private IntSignature(){}\n-\n-    public static IntSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitIntSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/IntSignature.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type long. *\/\n-public class LongSignature implements BaseType {\n-    private static final LongSignature singleton = new LongSignature();\n-\n-    private LongSignature(){}\n-\n-    public static LongSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitLongSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/LongSignature.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.Visitor;\n-\n-public class MethodTypeSignature implements Signature {\n-    private final FormalTypeParameter[] formalTypeParams;\n-    private final TypeSignature[] parameterTypes;\n-    private final ReturnType returnType;\n-    private final FieldTypeSignature[] exceptionTypes;\n-\n-    private MethodTypeSignature(FormalTypeParameter[] ftps,\n-                                TypeSignature[] pts,\n-                                ReturnType rt,\n-                                FieldTypeSignature[] ets) {\n-        formalTypeParams = ftps;\n-        parameterTypes = pts;\n-        returnType = rt;\n-        exceptionTypes = ets;\n-    }\n-\n-    public static MethodTypeSignature make(FormalTypeParameter[] ftps,\n-                                           TypeSignature[] pts,\n-                                           ReturnType rt,\n-                                           FieldTypeSignature[] ets) {\n-        return new MethodTypeSignature(ftps, pts, rt, ets);\n-    }\n-\n-    public FormalTypeParameter[] getFormalTypeParameters(){\n-        return formalTypeParams;\n-    }\n-    public TypeSignature[] getParameterTypes(){return parameterTypes;}\n-    public ReturnType getReturnType(){return returnType;}\n-    public FieldTypeSignature[] getExceptionTypes(){return exceptionTypes;}\n-\n-    public void accept(Visitor<?> v){v.visitMethodTypeSignature(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/MethodTypeSignature.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-public interface ReturnType extends TypeTree{}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ReturnType.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** AST that represents the type short. *\/\n-public class ShortSignature implements BaseType {\n-    private static final ShortSignature singleton = new ShortSignature();\n-\n-    private ShortSignature(){}\n-\n-    public static ShortSignature make() {return singleton;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitShortSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/ShortSignature.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/**\n- * Common superinterface for generic signatures. These are the signatures\n- * of complete class and method\/constructor declarations.\n- *\/\n-public interface Signature extends Tree{\n-    FormalTypeParameter[] getFormalTypeParameters();\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/Signature.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-public class SimpleClassTypeSignature implements FieldTypeSignature {\n-    private final boolean dollar;\n-    private final String name;\n-    private final TypeArgument[] typeArgs;\n-\n-    private SimpleClassTypeSignature(String n, boolean dollar, TypeArgument[] tas) {\n-        name = n;\n-        this.dollar = dollar;\n-        typeArgs = tas;\n-    }\n-\n-    public static SimpleClassTypeSignature make(String n,\n-                                                boolean dollar,\n-                                                TypeArgument[] tas){\n-        return new SimpleClassTypeSignature(n, dollar, tas);\n-    }\n-\n-    \/*\n-     * Should a '$' be used instead of '.' to separate this component\n-     * of the name from the previous one when composing a string to\n-     * pass to Class.forName; in other words, is this a transition to\n-     * a nested class.\n-     *\/\n-    public boolean getDollar(){return dollar;}\n-    public String getName(){return name;}\n-    public TypeArgument[] getTypeArguments(){return typeArgs;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitSimpleClassTypeSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/SimpleClassTypeSignature.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/** Root of the abstract syntax tree hierarchy for generic signatures *\/\n-public interface Tree{}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/Tree.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/** Common supertype for all possible type arguments in the\n- * generic signature AST. Corresponds to the production TypeArgument\n- * in the JVMS.\n- *\/\n-public interface TypeArgument extends TypeTree {}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/TypeArgument.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-\/**\n- * Common superinterface for all signatures that represent a\n- * type expression.\n- * Corresponds to the production of the same name in the JVMS\n- * section on signatures.\n- *\/\n-public interface TypeSignature extends ReturnType {}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/TypeSignature.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\/** Common supertype for all nodes that represent type expressions in\n- * the generic signature AST.\n- *\/\n-public interface TypeTree extends Tree {\n-    \/**\n-     * Accept method for the visitor pattern.\n-     * @param v a {@code TypeTreeVisitor} that will process this\n-     * tree\n-     *\/\n-    void accept(TypeTreeVisitor<?> v);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/TypeTree.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-public class TypeVariableSignature implements FieldTypeSignature {\n-    private final String identifier;\n-\n-    private TypeVariableSignature(String id) {identifier = id;}\n-\n-\n-    public static TypeVariableSignature make(String id) {\n-        return new TypeVariableSignature(id);\n-    }\n-\n-    public String getIdentifier(){return identifier;}\n-\n-    public void accept(TypeTreeVisitor<?> v){\n-        v.visitTypeVariableSignature(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/TypeVariableSignature.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-\n-\/** AST that represents the pseudo-type void. *\/\n-public class VoidDescriptor implements ReturnType {\n-    private static final VoidDescriptor singleton = new VoidDescriptor();\n-\n-    private VoidDescriptor(){}\n-\n-    public static VoidDescriptor make() {return singleton;}\n-\n-\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitVoidDescriptor(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/VoidDescriptor.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.tree;\n-\n-import sun.reflect.generics.visitor.TypeTreeVisitor;\n-\n-public class Wildcard implements TypeArgument {\n-    private final FieldTypeSignature[] upperBounds;\n-    private final FieldTypeSignature[] lowerBounds;\n-\n-    private Wildcard(FieldTypeSignature[] ubs, FieldTypeSignature[] lbs) {\n-        upperBounds = ubs;\n-        lowerBounds = lbs;\n-    }\n-\n-    private static final FieldTypeSignature[] emptyBounds = new FieldTypeSignature[0];\n-\n-    public static Wildcard make(FieldTypeSignature[] ubs,\n-                                FieldTypeSignature[] lbs) {\n-        return new Wildcard(ubs, lbs);\n-    }\n-\n-    public FieldTypeSignature[] getUpperBounds() {\n-        return upperBounds;\n-    }\n-\n-    public FieldTypeSignature[] getLowerBounds() {\n-        if (lowerBounds.length == 1 &&\n-            lowerBounds[0] == BottomSignature.make())\n-            return emptyBounds;\n-        else\n-            return lowerBounds;\n-    }\n-\n-    public void accept(TypeTreeVisitor<?> v){v.visitWildcard(this);}\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/Wildcard.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.visitor;\n-\n-\n-import java.lang.reflect.Type;\n-import java.util.List;\n-import java.util.Iterator;\n-import sun.reflect.generics.tree.*;\n-import sun.reflect.generics.factory.*;\n-\n-\n-\n-\/**\n- * Visitor that converts AST to reified types.\n- *\/\n-public class Reifier implements TypeTreeVisitor<Type> {\n-    private Type resultType;\n-    private final GenericsFactory factory;\n-\n-    private Reifier(GenericsFactory f){\n-        factory = f;\n-    }\n-\n-    private GenericsFactory getFactory(){ return factory;}\n-\n-    \/**\n-     * Factory method. The resulting visitor will convert an AST\n-     * representing generic signatures into corresponding reflective\n-     * objects, using the provided factory, {@code f}.\n-     * @param f - a factory that can be used to manufacture reflective\n-     * objects returned by this visitor\n-     * @return A visitor that can be used to reify ASTs representing\n-     * generic type information into reflective objects\n-     *\/\n-    public static Reifier make(GenericsFactory f){\n-        return new Reifier(f);\n-    }\n-\n-    \/\/ Helper method. Visits an array of TypeArgument and produces\n-    \/\/ reified Type array.\n-    private Type[] reifyTypeArguments(TypeArgument[] tas) {\n-        Type[] ts = new Type[tas.length];\n-        for (int i = 0; i < tas.length; i++) {\n-            tas[i].accept(this);\n-            ts[i] = resultType;\n-        }\n-        return ts;\n-    }\n-\n-\n-    \/**\n-     * Accessor for the result of the last visit by this visitor,\n-     * @return The type computed by this visitor based on its last\n-     * visit\n-     *\/\n-    public Type getResult() { assert resultType != null;return resultType;}\n-\n-    public void visitFormalTypeParameter(FormalTypeParameter ftp){\n-        resultType = getFactory().makeTypeVariable(ftp.getName(),\n-                                                   ftp.getBounds());\n-    }\n-\n-\n-    public void visitClassTypeSignature(ClassTypeSignature ct){\n-        \/\/ This method examines the pathname stored in ct, which has the form\n-        \/\/ n1.n2...nk<targs>....\n-        \/\/ where n1 ... nk-1 might not exist OR\n-        \/\/ nk might not exist (but not both). It may be that k equals 1.\n-        \/\/ The idea is that nk is the simple class type name that has\n-        \/\/ any type parameters associated with it.\n-        \/\/  We process this path in two phases.\n-        \/\/  First, we scan until we reach nk (if it exists).\n-        \/\/  If nk does not exist, this identifies a raw class n1 ... nk-1\n-        \/\/ which we can return.\n-        \/\/ if nk does exist, we begin the 2nd phase.\n-        \/\/ Here nk defines a parameterized type. Every further step nj (j > k)\n-        \/\/ down the path must also be represented as a parameterized type,\n-        \/\/ whose owner is the representation of the previous step in the path,\n-        \/\/ n{j-1}.\n-\n-        \/\/ extract iterator on list of simple class type sigs\n-        List<SimpleClassTypeSignature> scts = ct.getPath();\n-        assert(!scts.isEmpty());\n-        Iterator<SimpleClassTypeSignature> iter = scts.iterator();\n-        SimpleClassTypeSignature sc = iter.next();\n-        StringBuilder n = new StringBuilder(sc.getName());\n-        boolean dollar = sc.getDollar();\n-\n-        \/\/ phase 1: iterate over simple class types until\n-        \/\/ we are either done or we hit one with non-empty type parameters\n-        while (iter.hasNext() && sc.getTypeArguments().length == 0) {\n-            sc = iter.next();\n-            dollar = sc.getDollar();\n-            n.append(dollar?\"$\":\".\").append(sc.getName());\n-        }\n-\n-        \/\/ Now, either sc is the last element of the list, or\n-        \/\/ it has type arguments (or both)\n-        assert(!(iter.hasNext()) || (sc.getTypeArguments().length > 0));\n-        \/\/ Create the raw type\n-        Type c = getFactory().makeNamedType(n.toString());\n-        \/\/ if there are no type arguments\n-        if (sc.getTypeArguments().length == 0) {\n-            \/\/we have surely reached the end of the path\n-            assert(!iter.hasNext());\n-            resultType = c; \/\/ the result is the raw type\n-        } else {\n-            assert(sc.getTypeArguments().length > 0);\n-            \/\/ otherwise, we have type arguments, so we create a parameterized\n-            \/\/ type, whose declaration is the raw type c, and whose owner is\n-            \/\/ the declaring class of c (if any). This latter fact is indicated\n-            \/\/ by passing null as the owner.\n-            \/\/ First, we reify the type arguments\n-            Type[] pts = reifyTypeArguments(sc.getTypeArguments());\n-\n-            Type owner = getFactory().makeParameterizedType(c, pts, null);\n-            \/\/ phase 2: iterate over remaining simple class types\n-            dollar =false;\n-            while (iter.hasNext()) {\n-                sc = iter.next();\n-                dollar = sc.getDollar();\n-                n.append(dollar?\"$\":\".\").append(sc.getName()); \/\/ build up raw class name\n-                c = getFactory().makeNamedType(n.toString()); \/\/ obtain raw class\n-                pts = reifyTypeArguments(sc.getTypeArguments());\/\/ reify params\n-                \/\/ Create a parameterized type, based on type args, raw type\n-                \/\/ and previous owner\n-                owner = getFactory().makeParameterizedType(c, pts, owner);\n-            }\n-            resultType = owner;\n-        }\n-    }\n-\n-    public void visitArrayTypeSignature(ArrayTypeSignature a){\n-        \/\/ extract and reify component type\n-        a.getComponentType().accept(this);\n-        Type ct = resultType;\n-        resultType = getFactory().makeArrayType(ct);\n-    }\n-\n-    public void visitTypeVariableSignature(TypeVariableSignature tv){\n-        resultType = getFactory().findTypeVariable(tv.getIdentifier());\n-    }\n-\n-    public void visitWildcard(Wildcard w){\n-        resultType = getFactory().makeWildcard(w.getUpperBounds(),\n-                                               w.getLowerBounds());\n-    }\n-\n-    public void visitSimpleClassTypeSignature(SimpleClassTypeSignature sct){\n-        resultType = getFactory().makeNamedType(sct.getName());\n-    }\n-\n-    public void visitBottomSignature(BottomSignature b){\n-\n-    }\n-\n-    public void visitByteSignature(ByteSignature b){\n-        resultType = getFactory().makeByte();\n-    }\n-\n-    public void visitBooleanSignature(BooleanSignature b){\n-        resultType = getFactory().makeBool();\n-    }\n-\n-    public void visitShortSignature(ShortSignature s){\n-        resultType = getFactory().makeShort();\n-    }\n-\n-    public void visitCharSignature(CharSignature c){\n-        resultType = getFactory().makeChar();\n-    }\n-\n-    public void visitIntSignature(IntSignature i){\n-        resultType = getFactory().makeInt();\n-    }\n-\n-    public void visitLongSignature(LongSignature l){\n-        resultType = getFactory().makeLong();\n-    }\n-\n-    public void visitFloatSignature(FloatSignature f){\n-        resultType = getFactory().makeFloat();\n-    }\n-\n-    public void visitDoubleSignature(DoubleSignature d){\n-        resultType = getFactory().makeDouble();\n-    }\n-\n-    public void visitVoidDescriptor(VoidDescriptor v){\n-        resultType = getFactory().makeVoid();\n-    }\n-\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/Reifier.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.visitor;\n-\n-import sun.reflect.generics.tree.*;\n-\n-\/**\n- * Visit a TypeTree and produce a result of type T.\n- *\/\n-public interface TypeTreeVisitor<T> {\n-\n-    \/**\n-     * Returns the result of the visit.\n-     * @return the result of the visit\n-     *\/\n-    T getResult();\n-\n-    \/\/ Visitor methods, per node type\n-\n-    void visitFormalTypeParameter(FormalTypeParameter ftp);\n-\n-    void visitClassTypeSignature(ClassTypeSignature ct);\n-    void visitArrayTypeSignature(ArrayTypeSignature a);\n-    void visitTypeVariableSignature(TypeVariableSignature tv);\n-    void visitWildcard(Wildcard w);\n-\n-    void visitSimpleClassTypeSignature(SimpleClassTypeSignature sct);\n-    void visitBottomSignature(BottomSignature b);\n-\n-    \/\/  Primitives and Void\n-    void visitByteSignature(ByteSignature b);\n-    void visitBooleanSignature(BooleanSignature b);\n-    void visitShortSignature(ShortSignature s);\n-    void visitCharSignature(CharSignature c);\n-    void visitIntSignature(IntSignature i);\n-    void visitLongSignature(LongSignature l);\n-    void visitFloatSignature(FloatSignature f);\n-    void visitDoubleSignature(DoubleSignature d);\n-\n-    void visitVoidDescriptor(VoidDescriptor v);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/TypeTreeVisitor.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.reflect.generics.visitor;\n-\n-import sun.reflect.generics.tree.*;\n-\n-public interface Visitor<T> extends TypeTreeVisitor<T> {\n-\n-    void visitClassSignature(ClassSignature cs);\n-    void visitMethodTypeSignature(MethodTypeSignature ms);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/Visitor.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333377\n+ * @summary Test behaviors with bad EnclosingMethod attribute\n+ * @library \/test\/lib\n+ * @run junit BadEnclosingMethodTest\n+ *\/\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BadEnclosingMethodTest {\n+\n+    private static Path classPath(String className) {\n+        return Path.of(System.getProperty(\"test.classes\"), className + \".class\");\n+    }\n+\n+    private Class<?> loadTestClass(String name, String type) throws Exception {\n+        var outerName = \"Encloser\";\n+        var className = outerName + \"$1Enclosed\";\n+\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(classPath(className));\n+\n+        var bytes = cf.transformClass(cm, (cb, ce) -> {\n+            if (ce instanceof EnclosingMethodAttribute em) {\n+                var cp = cb.constantPool();\n+                var enclosingMethodName = cp.utf8Entry(name);\n+                var enclosingMethodType = cp.utf8Entry(type); \/\/ a malformed method type\n+                cb.with(EnclosingMethodAttribute.of(em.enclosingClass(), Optional.of(cp.nameAndTypeEntry(\n+                        enclosingMethodName, enclosingMethodType\n+                ))));\n+            } else {\n+                cb.with(ce);\n+            }\n+        });\n+\n+        var map = Map.of(\n+                outerName, Files.readAllBytes(classPath(outerName)),\n+                className, bytes\n+        );\n+\n+        return new ByteCodeLoader(map, BadEnclosingMethodTest.class.getClassLoader())\n+                .loadClass(className);\n+    }\n+\n+    @Test\n+    void testBadTypes() throws Exception {\n+        assertThrows(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n+        assertThrows(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+\n+        var absentMethodType = loadTestClass(\"methodName\", \"(Ldoes\/not\/Exist;)V\");\n+        var ex = assertThrows(TypeNotPresentException.class,\n+                absentMethodType::getEnclosingMethod);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+\n+        var absentConstructorType = loadTestClass(INIT_NAME, \"(Ldoes\/not\/Exist;)V\");\n+        ex = assertThrows(TypeNotPresentException.class,\n+                absentConstructorType::getEnclosingConstructor);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+}\n+\n+class Encloser {\n+    private static void work() {\n+        class Enclosed {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/BadEnclosingMethodTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333377\n+ * @summary Test behaviors with malformed annotations (in class files)\n+ *          that should stay in refactors\n+ * @library \/test\/lib\n+ * @comment\n+ * @run junit MalformedAnnotationTest\n+ *\/\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.GenericSignatureFormatError;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MalformedAnnotationTest {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassCarrier {\n+        Class<?> value();\n+    }\n+\n+    \/**\n+     * Ensures bad class descriptors in annotations lead to\n+     * {@link GenericSignatureFormatError}.\n+     *\/\n+    @Test\n+    void testMalformedClassValue() throws Exception {\n+        var badDescString = \"Not a_descriptor\";\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb\n+                .with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(ClassCarrier.class.describeConstable().orElseThrow(),\n+                                AnnotationElement.of(\"value\", AnnotationValue.ofClass(clb\n+                                        .constantPool().utf8Entry(badDescString))))\n+                )));\n+        var cl = new ByteCodeLoader(\"Test\", bytes, MalformedAnnotationTest.class.getClassLoader()).loadClass(\"Test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/MalformedAnnotationTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6832374 7052898 8333377\n+ * @summary Test behaviors with malformed signature strings in Signature attribute.\n+ * @library \/test\/lib\n+ * @run junit MalformedSignatureTest\n+ *\/\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MalformedSignatureTest {\n+\n+    private static final String BASIC_BAD_SIGNATURE_TEXT = \"I_aM_NoT_A_Signature\";\n+    static Class<?> sampleClass, sampleRecord;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        var compiledDir = Path.of(System.getProperty(\"test.classes\"));\n+        var cf = ClassFile.of();\n+\n+        var badSignatureTransform = new ClassTransform() {\n+            private SignatureAttribute badSignature;\n+\n+            @Override\n+            public void atStart(ClassBuilder builder) {\n+                badSignature = SignatureAttribute.of(builder.constantPool().utf8Entry(BASIC_BAD_SIGNATURE_TEXT));\n+            }\n+\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                switch (element) {\n+                    case SignatureAttribute _ -> {} \/\/ dropping\n+                    case FieldModel f -> builder\n+                            .transformField(f, FieldTransform.dropping(SignatureAttribute.class::isInstance)\n+                                    .andThen(FieldTransform.endHandler(fb -> fb.with(badSignature))));\n+                    case MethodModel m -> builder\n+                            .transformMethod(m, MethodTransform.dropping(SignatureAttribute.class::isInstance)\n+                                    .andThen(MethodTransform.endHandler(fb -> fb.with(badSignature))));\n+                    case RecordAttribute rec -> builder.with(RecordAttribute.of(rec.components().stream().map(comp ->\n+                                    RecordComponentInfo.of(comp.name(), comp.descriptor(), Stream.concat(\n+                                                    Stream.of(badSignature), comp.attributes().stream()\n+                                                            .filter(Predicate.not(SignatureAttribute.class::isInstance)))\n+                                            .toList()))\n+                            .toList()));\n+                    default -> builder.with(element);\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                builder.with(badSignature);\n+            }\n+        };\n+\n+        var plainBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleClass.class\")), badSignatureTransform);\n+        sampleClass = ByteCodeLoader.load(\"SampleClass\", plainBytes);\n+        var recordBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleRecord.class\")), badSignatureTransform);\n+        sampleRecord = ByteCodeLoader.load(\"SampleRecord\", recordBytes);\n+    }\n+\n+    @Test\n+    void testBasicClass() {\n+        assertEquals(ArrayList.class, sampleClass.getSuperclass());\n+        assertArrayEquals(new Class<?>[] {Predicate.class}, sampleClass.getInterfaces());\n+        var ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericSuperclass);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericInterfaces);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    @Test\n+    void testBasicField() throws ReflectiveOperationException {\n+        var field = sampleClass.getDeclaredField(\"field\");\n+        assertEquals(Optional.class, field.getType());\n+        var ex = assertThrows(GenericSignatureFormatError.class, field::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    @Test\n+    void testBasicConstructor() throws ReflectiveOperationException {\n+        var constructor = sampleClass.getDeclaredConstructors()[0];\n+        assertArrayEquals(new Class<?>[] {Optional.class}, constructor.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, constructor.getExceptionTypes());\n+        var ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    @Test\n+    void testBasicMethod() throws ReflectiveOperationException {\n+        var method = sampleClass.getDeclaredMethods()[0];\n+        assertEquals(Optional.class, method.getReturnType());\n+        assertArrayEquals(new Class<?>[] {Optional.class}, method.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, method.getExceptionTypes());\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericReturnType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    @Test\n+    void testBasicRecordComponent() {\n+        var rcs = sampleRecord.getRecordComponents();\n+        assertNotNull(rcs);\n+        assertEquals(1, rcs.length);\n+        var rc = rcs[0];\n+        assertNotNull(rc);\n+\n+        assertEquals(Optional.class, rc.getType());\n+        assertEquals(BASIC_BAD_SIGNATURE_TEXT, rc.getGenericSignature());\n+        var ex = assertThrows(GenericSignatureFormatError.class, rc::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    static String[] badMethodSignatures() {\n+        return new String[] {\n+                \/\/ Missing \":\" after first type bound\n+                \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n+\n+                \/\/ Arrays improperly indicated for exception information\n+                \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n+        };\n+    }\n+\n+    @MethodSource(\"badMethodSignatures\")\n+    @ParameterizedTest\n+    void testSignatureForMethod(String badSig) throws Throwable {\n+        var className = \"BadSignature\";\n+        var bytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n+                clb.withMethod(\"test\", MTD_void, 0, mb -> mb\n+                        .withCode(CodeBuilder::return_)\n+                        .with(SignatureAttribute.of(clb.constantPool().utf8Entry(badSig)))));\n+\n+        var cl = ByteCodeLoader.load(className, bytes);\n+        var method = cl.getDeclaredMethod(\"test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(badSig), \"Missing bad signature in error message\");\n+    }\n+}\n+\n+\/\/ Sample classes shared with TypeNotPresentInSignatureTest\n+abstract class SampleClass extends ArrayList<RuntimeException> implements Predicate<RuntimeException> { \/\/ class\n+    Optional<RuntimeException> field; \/\/ field\n+\n+    <T extends RuntimeException> SampleClass(Optional<RuntimeException> param) throws T {\n+    } \/\/ constructor\n+\n+    <T extends RuntimeException> Optional<RuntimeException> method(Optional<RuntimeException> param) throws T {\n+        return null;\n+    } \/\/ method\n+}\n+\n+record SampleRecord(Optional<RuntimeException> component) {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/MalformedSignatureTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6832374 7052898\n- * @summary Test bad signatures get a GenericSignatureFormatError thrown.\n- * @author Joseph D. Darcy\n- * @modules java.base\/sun.reflect.generics.parser\n- *\/\n-\n-import java.lang.reflect.*;\n-import sun.reflect.generics.parser.SignatureParser;\n-\n-public class TestBadSignatures {\n-    public static void main(String[] args) {\n-        String[] badSignatures = {\n-            \/\/ Missing \":\" after first type bound\n-            \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n-\n-            \/\/ Arrays improperly indicated for exception information\n-            \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n-        };\n-\n-        for(String badSig : badSignatures) {\n-            try {\n-                SignatureParser.make().parseMethodSig(badSig);\n-                throw new RuntimeException(\"Expected GenericSignatureFormatError for \" +\n-                                           badSig);\n-            } catch(GenericSignatureFormatError gsfe) {\n-                System.out.println(gsfe.toString()); \/\/ Expected\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TestBadSignatures.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333377\n+ * @summary Test behaviors with Signature attribute with any absent\n+ *          class or interface\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @compile MalformedSignatureTest.java\n+ * @comment reuses Sample classes from MalformedSignatureTest\n+ * @run junit TypeNotPresentInSignatureTest\n+ *\/\n+\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.TypeVariable;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TypeNotPresentInSignatureTest {\n+\n+    static Class<?> sampleClass, sampleRecord;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        var compiledDir = Path.of(System.getProperty(\"test.classes\"));\n+        var cf = ClassFile.of();\n+\n+        var reDesc = ClassDesc.of(\"java.lang.RuntimeException\");\n+        var fix = ClassRemapper.of(Map.of(reDesc, ClassDesc.of(\"does.not.Exist\")));\n+        var f2 = ClassTransform.transformingMethods((mb, me) -> {\n+            if (me instanceof ExceptionsAttribute) {\n+                mb.with(ExceptionsAttribute.ofSymbols(reDesc));\n+            } else {\n+                mb.with(me);\n+            }\n+        });\n+\n+        var plainBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleClass.class\")), fix);\n+        plainBytes = cf.transformClass(cf.parse(plainBytes), f2);\n+        sampleClass = ByteCodeLoader.load(\"SampleClass\", plainBytes);\n+        var recordBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleRecord.class\")), fix);\n+        recordBytes = cf.transformClass(cf.parse(recordBytes), f2);\n+        sampleRecord = ByteCodeLoader.load(\"SampleRecord\", recordBytes);\n+    }\n+\n+\n+    @Test\n+    void testClass() {\n+        assertEquals(ArrayList.class, sampleClass.getSuperclass());\n+        assertArrayEquals(new Class<?>[] {Predicate.class}, sampleClass.getInterfaces());\n+        var ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericSuperclass);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericInterfaces);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    @Test\n+    void testField() throws ReflectiveOperationException {\n+        var field = sampleClass.getDeclaredField(\"field\");\n+        assertEquals(Optional.class, field.getType());\n+        var ex = assertThrows(TypeNotPresentException.class, field::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    @Test\n+    void testConstructor() throws ReflectiveOperationException {\n+        var constructor = sampleClass.getDeclaredConstructor(Optional.class);\n+        assertArrayEquals(new Class<?>[] {Optional.class}, constructor.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, constructor.getExceptionTypes());\n+        var ex = assertThrows(TypeNotPresentException.class, constructor::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        var typeVar = (TypeVariable<?>) constructor.getGenericExceptionTypes()[0];\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    @Test\n+    void testMethod() throws ReflectiveOperationException {\n+        var method = sampleClass.getDeclaredMethod(\"method\", Optional.class);\n+        assertEquals(Optional.class, method.getReturnType());\n+        assertArrayEquals(new Class<?>[] {Optional.class}, method.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, method.getExceptionTypes());\n+        var ex = assertThrows(TypeNotPresentException.class, method::getGenericReturnType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, method::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        var typeVar = (TypeVariable<?>) method.getGenericExceptionTypes()[0];\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    @Test\n+    void testRecordComponent() {\n+        var rcs = sampleRecord.getRecordComponents();\n+        assertNotNull(rcs);\n+        assertEquals(1, rcs.length);\n+        var rc = rcs[0];\n+        assertNotNull(rc);\n+\n+        assertEquals(Optional.class, rc.getType());\n+        assertEquals(\"Ljava\/util\/Optional<Ldoes\/not\/Exist;>;\", rc.getGenericSignature());\n+        var ex = assertThrows(TypeNotPresentException.class, rc::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TypeNotPresentInSignatureTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                {\"java.base\", \"sun\/reflect\/generics\/tree\/TypeArgument.class\"},\n+                {\"java.base\", \"jdk\/internal\/misc\/Unsafe.class\"},\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}