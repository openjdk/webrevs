{"files":[{"patch":"@@ -1437,1 +1437,1 @@\n-            Class<?>[] parameterClasses   = types.toArray(GenericInfo.EMPTY_CLASS_ARRAY);\n+            Class<?>[] parameterClasses = types.toArray(GenericInfo.EMPTY_CLASS_ARRAY);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RecordComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,7 @@\n+     * Parse a single type in a descriptor. Results can be:\n+     * <ul>\n+     *     <li>A {@code Class} for successful parsing\n+     *     <li>{@code null} for malformed descriptor format\n+     *     <li>Throwing a {@link TypeNotPresentException} for valid class name,\n+     *     but class cannot be discovered\n+     * <\/ul>\n@@ -120,1 +127,2 @@\n-            return Wrapper.forBasicType(c).primitiveType();\n+            var w = Wrapper.forPrimitiveTypeOrNull(c);\n+            return w == null ? null : w.primitiveType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,0 +355,13 @@\n+    \/**\n+     * Return the primitive wrapper for the given char.  Does not return\n+     * {@code OBJECT}. Returns {@code null} to allow flexible error messages.\n+     * Dedicated for {@link BytecodeDescriptor}.\n+     *\/\n+    static Wrapper forPrimitiveTypeOrNull(char type) {\n+        Wrapper w = FROM_CHAR[(type + (type >> 1)) & 0xf];\n+        if (w != null && w != OBJECT && w.basicTypeChar == type) {\n+            return w;\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/ClassGenericInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/ExecutableGenericInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/FieldGenericInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/GenericDeclInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/info\/GenericInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/LazyReflectiveObjectGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/TypeVariableImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/WildcardTypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8333377\n@@ -42,1 +43,1 @@\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -85,1 +86,1 @@\n-        assertThrows(TypeNotPresentException.class,\n+        var ex = assertThrows(TypeNotPresentException.class,\n@@ -87,0 +88,1 @@\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -89,1 +91,1 @@\n-        assertThrows(TypeNotPresentException.class,\n+        ex = assertThrows(TypeNotPresentException.class,\n@@ -91,0 +93,1 @@\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/BadEnclosingMethodTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8333377\n@@ -47,0 +48,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -61,0 +63,1 @@\n+        var badDescString = \"Not a_descriptor\";\n@@ -65,1 +68,1 @@\n-                                        .constantPool().utf8Entry(\"Not a descriptor\"))))\n+                                        .constantPool().utf8Entry(badDescString))))\n@@ -67,2 +70,3 @@\n-        var cl = ByteCodeLoader.load(\"Test\", bytes);\n-        assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        var cl = new ByteCodeLoader(\"Test\", bytes, MalformedAnnotationTest.class.getClassLoader()).loadClass(\"Test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n","filename":"test\/jdk\/java\/lang\/annotation\/MalformedAnnotationTest.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @summary Test behaviors with malformed Signature attribute\n+ * @bug 6832374 7052898 8333377\n+ * @summary Test behaviors with malformed signature strings in Signature attribute.\n@@ -34,0 +35,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -35,8 +38,1 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.FieldModel;\n-import java.lang.classfile.FieldTransform;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.*;\n@@ -46,0 +42,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -53,0 +50,1 @@\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -57,1 +55,1 @@\n-    private static final String DUMMY_SIGNATURE_TEXT = \"Not a signature\";\n+    private static final String BASIC_BAD_SIGNATURE_TEXT = \"I_aM_NoT_A_Signature\";\n@@ -70,1 +68,1 @@\n-                badSignature = SignatureAttribute.of(builder.constantPool().utf8Entry(DUMMY_SIGNATURE_TEXT));\n+                badSignature = SignatureAttribute.of(builder.constantPool().utf8Entry(BASIC_BAD_SIGNATURE_TEXT));\n@@ -76,2 +74,1 @@\n-                    case SignatureAttribute sig -> {\n-                    } \/\/ dropping\n+                    case SignatureAttribute _ -> {} \/\/ dropping\n@@ -107,1 +104,1 @@\n-    void testClass() {\n+    void testBasicClass() {\n@@ -110,2 +107,4 @@\n-        assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericSuperclass);\n-        assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericInterfaces);\n+        var ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericSuperclass);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericInterfaces);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n@@ -115,1 +114,1 @@\n-    void testField() throws ReflectiveOperationException {\n+    void testBasicField() throws ReflectiveOperationException {\n@@ -118,1 +117,2 @@\n-        assertThrows(GenericSignatureFormatError.class, field::getGenericType);\n+        var ex = assertThrows(GenericSignatureFormatError.class, field::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n@@ -122,1 +122,1 @@\n-    void testConstructor() throws ReflectiveOperationException {\n+    void testBasicConstructor() throws ReflectiveOperationException {\n@@ -126,2 +126,4 @@\n-        assertThrows(GenericSignatureFormatError.class, constructor::getGenericParameterTypes);\n-        assertThrows(GenericSignatureFormatError.class, constructor::getGenericExceptionTypes);\n+        var ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n@@ -131,1 +133,1 @@\n-    void testMethod() throws ReflectiveOperationException {\n+    void testBasicMethod() throws ReflectiveOperationException {\n@@ -136,3 +138,6 @@\n-        assertThrows(GenericSignatureFormatError.class, method::getGenericReturnType);\n-        assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n-        assertThrows(GenericSignatureFormatError.class, method::getGenericExceptionTypes);\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericReturnType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n@@ -142,1 +147,1 @@\n-    void testRecordComponent() {\n+    void testBasicRecordComponent() {\n@@ -150,2 +155,28 @@\n-        assertEquals(DUMMY_SIGNATURE_TEXT, rc.getGenericSignature());\n-        assertThrows(GenericSignatureFormatError.class, rc::getGenericType);\n+        assertEquals(BASIC_BAD_SIGNATURE_TEXT, rc.getGenericSignature());\n+        var ex = assertThrows(GenericSignatureFormatError.class, rc::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    static String[] badMethodSignatures() {\n+        return new String[] {\n+                \/\/ Missing \":\" after first type bound\n+                \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n+\n+                \/\/ Arrays improperly indicated for exception information\n+                \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n+        };\n+    }\n+\n+    @MethodSource(\"badMethodSignatures\")\n+    @ParameterizedTest\n+    void testSignatureForMethod(String badSig) throws Throwable {\n+        var className = \"BadSignature\";\n+        var bytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n+                clb.withMethod(\"test\", MTD_void, 0, mb -> mb\n+                        .withCode(CodeBuilder::return_)\n+                        .with(SignatureAttribute.of(clb.constantPool().utf8Entry(badSig)))));\n+\n+        var cl = ByteCodeLoader.load(className, bytes);\n+        var method = cl.getDeclaredMethod(\"test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(badSig), \"Missing bad signature in error message\");\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/MalformedSignatureTest.java","additions":60,"deletions":29,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6832374 7052898\n- * @summary Test bad signatures get a GenericSignatureFormatError thrown.\n- * @author Joseph D. Darcy\n- * @library \/test\/lib\n- *\/\n-\n-import jdk.test.lib.ByteCodeLoader;\n-\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.attribute.SignatureAttribute;\n-import java.lang.constant.ClassDesc;\n-import java.lang.reflect.*;\n-\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-\n-public class TestBadSignatures {\n-    public static void main(String[] args) throws Exception {\n-        String[] badSignatures = {\n-            \/\/ Missing \":\" after first type bound\n-            \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n-\n-            \/\/ Arrays improperly indicated for exception information\n-            \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n-        };\n-\n-        int i = 0;\n-        for(String badSig : badSignatures) {\n-            var className = \"BadSignature\" + i;\n-            var bytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n-                    clb.withMethod(\"test\", MTD_void, 0, mb -> mb\n-                            .withCode(CodeBuilder::return_)\n-                            .with(SignatureAttribute.of(clb.constantPool().utf8Entry(badSig)))));\n-\n-            var cl = ByteCodeLoader.load(className, bytes);\n-            var method = cl.getDeclaredMethod(\"test\");\n-            try {\n-                method.getGenericParameterTypes();\n-                throw new RuntimeException(\"Expected GenericSignatureFormatError for \" +\n-                                           badSig);\n-            } catch(GenericSignatureFormatError gsfe) {\n-                System.out.println(gsfe.toString()); \/\/ Expected\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TestBadSignatures.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8333377\n@@ -85,2 +86,4 @@\n-        assertThrows(TypeNotPresentException.class, sampleClass::getGenericSuperclass);\n-        assertThrows(TypeNotPresentException.class, sampleClass::getGenericInterfaces);\n+        var ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericSuperclass);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericInterfaces);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -93,1 +96,2 @@\n-        assertThrows(TypeNotPresentException.class, field::getGenericType);\n+        var ex = assertThrows(TypeNotPresentException.class, field::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -101,1 +105,2 @@\n-        assertThrows(TypeNotPresentException.class, constructor::getGenericParameterTypes);\n+        var ex = assertThrows(TypeNotPresentException.class, constructor::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -103,1 +108,2 @@\n-        assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -112,2 +118,4 @@\n-        assertThrows(TypeNotPresentException.class, method::getGenericReturnType);\n-        assertThrows(TypeNotPresentException.class, method::getGenericParameterTypes);\n+        var ex = assertThrows(TypeNotPresentException.class, method::getGenericReturnType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, method::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -115,1 +123,2 @@\n-        assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n@@ -128,1 +137,2 @@\n-        assertThrows(TypeNotPresentException.class, rc::getGenericType);\n+        var ex = assertThrows(TypeNotPresentException.class, rc::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TypeNotPresentInSignatureTest.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                {\"java.base\", \"sun\/reflect\/generics\/reflectiveObjects\/ParameterizedTypeImpl.class\"},\n+                {\"java.base\", \"jdk\/internal\/misc\/Unsafe.class\"},\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}