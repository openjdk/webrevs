{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n@@ -32,0 +30,1 @@\n+import java.util.LinkedList;\n@@ -34,1 +33,0 @@\n-import java.util.Objects;\n@@ -37,1 +35,0 @@\n-import java.util.stream.Stream;\n@@ -39,1 +36,0 @@\n-import javax.tools.DiagnosticListener;\n@@ -129,3 +125,4 @@\n-        return Optional.of(sourceFile)\n-          .map(fileInfoMap::get)\n-          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+        FileInfo fileInfo = fileInfoMap.get(sourceFile);\n+        if (fileInfo != null)\n+            return fileInfo.lintAt(pos);\n+        return Optional.empty();\n@@ -183,1 +180,1 @@\n-        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+        final List<Span> unmappedDecls = new LinkedList<>();    \/\/ unmapped top-level declarations awaiting attribution\n@@ -188,4 +185,4 @@\n-            tree.defs.stream()\n-              .filter(this::isTopLevelDecl)\n-              .map(decl -> new Span(decl, tree.endPositions))\n-              .forEach(unmappedDecls::add);\n+            for (JCTree decl : tree.defs) {\n+                if (isTopLevelDecl(decl))\n+                    unmappedDecls.add(new Span(decl, tree.endPositions));\n+            }\n@@ -208,2 +205,5 @@\n-            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n-            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n+            for (Span span : unmappedDecls) {\n+                if (span.contains(pos))\n+                    return Optional.empty();\n+            }\n+            return Optional.of(rootRange.bestMatch(pos).lint);\n@@ -255,1 +255,1 @@\n-            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+            this(Span.MAXIMAL, rootLint, new LinkedList<>());\n@@ -260,1 +260,1 @@\n-            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+            this(new Span(tree, endPositions), lint, new LinkedList<>());\n@@ -265,5 +265,11 @@\n-            return children.stream()\n-              .map(child -> child.bestMatch(pos))\n-              .filter(Objects::nonNull)\n-              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n-              .orElseGet(() -> span.contains(pos) ? this : null);\n+            LintRange bestMatch = null;\n+            for (LintRange child : children) {\n+                if (!child.span.contains(pos))          \/\/ don't recurse unless necessary\n+                    continue;\n+                LintRange childBestMatch = child.bestMatch(pos);\n+                if (childBestMatch != null && (bestMatch == null || bestMatch.span.contains(childBestMatch.span)))\n+                    bestMatch = childBestMatch;\n+            }\n+            if (bestMatch == null)\n+                bestMatch = span.contains(pos) ? this : null;\n+            return bestMatch;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -145,0 +145,10 @@\n+\n+                    \/\/ Optimization: We don't need to go through the trouble of calculating the Lint instance at \"pos\" if\n+                    \/\/ (a) \"category\" is disabled at the root level, and (b) the diagnostic doesn't have the DEFAULT_ENABLED\n+                    \/\/ flag: @SuppressWarnings can only disable lint categories, so \"category\" is disabled in the entire file.\n+                    if (!rootLint().isEnabled(category) &&\n+                      !diag.isFlagSet(DEFAULT_ENABLED) &&\n+                      !diag.getCode().equals(RequiresTransitiveAutomatic.key()))    \/\/ accommodate the \"requires\" hack below\n+                        return;\n+\n+                    \/\/ Wait for the Lint instance at \"pos\" to be calculated, then proceed\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}