{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -32,0 +31,1 @@\n+import java.util.LinkedList;\n@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -183,1 +182,1 @@\n-        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+        final List<Span> unmappedDecls = new LinkedList<>();    \/\/ unmapped top-level declarations awaiting attribution\n@@ -188,4 +187,4 @@\n-            tree.defs.stream()\n-              .filter(this::isTopLevelDecl)\n-              .map(decl -> new Span(decl, tree.endPositions))\n-              .forEach(unmappedDecls::add);\n+            for (JCTree decl : tree.defs) {\n+                if (isTopLevelDecl(decl))\n+                    unmappedDecls.add(new Span(decl, tree.endPositions));\n+            }\n@@ -255,1 +254,1 @@\n-            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+            this(Span.MAXIMAL, rootLint, new LinkedList<>());\n@@ -260,1 +259,1 @@\n-            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+            this(new Span(tree, endPositions), lint, new LinkedList<>());\n@@ -265,5 +264,11 @@\n-            return children.stream()\n-              .map(child -> child.bestMatch(pos))\n-              .filter(Objects::nonNull)\n-              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n-              .orElseGet(() -> span.contains(pos) ? this : null);\n+            LintRange bestMatch = null;\n+            for (LintRange child : children) {\n+                if (!child.span.contains(pos))          \/\/ don't recurse unless necessary\n+                    continue;\n+                LintRange childBestMatch = child.bestMatch(pos);\n+                if (childBestMatch != null && (bestMatch == null || bestMatch.span.contains(childBestMatch.span)))\n+                    bestMatch = childBestMatch;\n+            }\n+            if (bestMatch == null)\n+                bestMatch = span.contains(pos) ? this : null;\n+            return bestMatch;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -145,0 +145,10 @@\n+\n+                    \/\/ Optimization: We don't need to go through the trouble of calculating the Lint instance at \"pos\" if\n+                    \/\/ (a) \"category\" is disabled at the root level, and (b) the diagnostic doesn't have the DEFAULT_ENABLED\n+                    \/\/ flag: @SuppressWarnings can only disable lint categories, so \"category\" is disabled in the entire file.\n+                    if (!rootLint().isEnabled(category) &&\n+                      !diag.isFlagSet(DEFAULT_ENABLED) &&\n+                      !diag.getCode().equals(RequiresTransitiveAutomatic.key()))    \/\/ accommodate the \"requires\" hack below\n+                        return;\n+\n+                    \/\/ Wait for the Lint instance at \"pos\" to be calculated, then proceed\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}