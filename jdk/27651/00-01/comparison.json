{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -32,0 +31,1 @@\n+import java.util.LinkedList;\n@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -183,1 +182,1 @@\n-        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+        final List<Span> unmappedDecls = new LinkedList<>();    \/\/ unmapped top-level declarations awaiting attribution\n@@ -188,4 +187,4 @@\n-            tree.defs.stream()\n-              .filter(this::isTopLevelDecl)\n-              .map(decl -> new Span(decl, tree.endPositions))\n-              .forEach(unmappedDecls::add);\n+            for (JCTree decl : tree.defs) {\n+                if (isTopLevelDecl(decl))\n+                    unmappedDecls.add(new Span(decl, tree.endPositions));\n+            }\n@@ -255,1 +254,1 @@\n-            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+            this(Span.MAXIMAL, rootLint, new LinkedList<>());\n@@ -260,1 +259,1 @@\n-            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+            this(new Span(tree, endPositions), lint, new LinkedList<>());\n@@ -265,6 +264,11 @@\n-            return children.stream()\n-              .filter(child -> child.span.contains(pos))    \/\/ don't recurse unless necessary\n-              .map(child -> child.bestMatch(pos))\n-              .filter(Objects::nonNull)\n-              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n-              .orElseGet(() -> span.contains(pos) ? this : null);\n+            LintRange bestMatch = null;\n+            for (LintRange child : children) {\n+                if (!child.span.contains(pos))          \/\/ don't recurse unless necessary\n+                    continue;\n+                LintRange childBestMatch = child.bestMatch(pos);\n+                if (childBestMatch != null && (bestMatch == null || bestMatch.span.contains(childBestMatch.span)))\n+                    bestMatch = childBestMatch;\n+            }\n+            if (bestMatch == null)\n+                bestMatch = span.contains(pos) ? this : null;\n+            return bestMatch;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"}]}