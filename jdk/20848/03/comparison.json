{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.foreign.SegmentBulkOperations;\n@@ -2637,2 +2638,3 @@\n-        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n-                dstSegment, dstFromOffset, dstToOffset);\n+        return SegmentBulkOperations.mismatch(\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment), srcFromOffset, srcToOffset,\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment), dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,5 +192,0 @@\n-    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n-    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n-\n-    @Override\n@@ -198,0 +193,1 @@\n+    @Override\n@@ -199,40 +195,1 @@\n-        checkReadOnly(false);\n-        if (length == 0) {\n-            \/\/ Implicit state check\n-            checkValidState();\n-        } else if (length < FILL_NATIVE_THRESHOLD) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n-\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n-            for (; offset < limit; offset += 8) {\n-                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n-            }\n-            int remaining = (int) length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n-                offset += 2;\n-                remaining -= 2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ Handle larger segments via native calls\n-            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n-        }\n-        return this;\n+        return SegmentBulkOperations.fill(this, value);\n@@ -332,1 +289,2 @@\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+        return SegmentBulkOperations.mismatch(this, 0, byteSize(),\n+                (AbstractMemorySegmentImpl) other, 0, other.byteSize());\n@@ -734,34 +692,0 @@\n-    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n-                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":80,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteOrder;\n+\n+\/**\n+ * This class contains optimized bulk operation methods that operate on one or several\n+ * memory segments.\n+ * <p>\n+ * Generally, the methods attempt to work with as-large-as-possible units of memory at\n+ * a time.\n+ * <p>\n+ * It should be noted that when invoking scoped memory access get\/set operations, it\n+ * is imperative from a performance perspective to convey the sharp types from the\n+ * call site in order for the compiler to pick the correct Unsafe access variant.\n+ *\/\n+public final class SegmentBulkOperations {\n+\n+    private SegmentBulkOperations() {}\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    \/\/ All the threshold values below MUST be a power of two and should preferably be\n+    \/\/ greater or equal to 2^3.\n+\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", Architecture.isAARCH64() ? 10 : 5);\n+    private static final long NATIVE_THRESHOLD_MISMATCH = powerOfPropertyOr(\"mismatch\", 20);\n+\n+    @ForceInline\n+    public static MemorySegment fill(AbstractMemorySegmentImpl dst, byte value) {\n+        dst.checkReadOnly(false);\n+        if (dst.length == 0) {\n+            \/\/ Implicit state check\n+            dst.checkValidState();\n+        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) dst.length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+        }\n+        return dst;\n+    }\n+\n+    @ForceInline\n+    public static long mismatch(AbstractMemorySegmentImpl src, long srcFromOffset, long srcToOffset,\n+                                AbstractMemorySegmentImpl dst, long dstFromOffset, long dstToOffset) {\n+        final long srcBytes = srcToOffset - srcFromOffset;\n+        final long dstBytes = dstToOffset - dstFromOffset;\n+        src.checkAccess(srcFromOffset, srcBytes, true);\n+        dst.checkAccess(dstFromOffset, dstBytes, true);\n+\n+        final long bytes = Math.min(srcBytes, dstBytes);\n+        final boolean srcAndDstBytesDiffer = srcBytes != dstBytes;\n+\n+        if (bytes == 0) {\n+            return srcAndDstBytesDiffer ? 0 : -1;\n+        } else if (bytes < NATIVE_THRESHOLD_MISMATCH) {\n+            final int limit = (int) (bytes & (NATIVE_THRESHOLD_MISMATCH - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                final long s = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+                final long d = SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+                if (s != d) {\n+                    return offset + mismatch(s, d);\n+                }\n+            }\n+            int remaining = (int) bytes - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                final int s = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+                final int d = SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+                if (s != d) {\n+                    return offset + mismatch(s, d);\n+                }\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                if (SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 2, srcAndDstBytesDiffer);\n+                }\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return offset;\n+                }\n+            }\n+            return srcAndDstBytesDiffer ? bytes : -1;\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            long i;\n+            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset) !=\n+                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            final long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+            return mismatchSmall(src, srcFromOffset + i, dst, dstFromOffset + i, i, (int) remaining, srcAndDstBytesDiffer);\n+        }\n+    }\n+\n+    \/\/ This method is intended for 0 <= bytes < 7\n+    @ForceInline\n+    private static long mismatchSmall(AbstractMemorySegmentImpl src, long srcOffset,\n+                                      AbstractMemorySegmentImpl dst, long dstOffset,\n+                                      long offset, int bytes, boolean srcAndDstBytesDiffer) {\n+        for (int i = 0; i < bytes; i++) {\n+            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + i) !=\n+                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + i)) {\n+                return offset + i;\n+            }\n+        }\n+        return srcAndDstBytesDiffer ? bytes : -1;\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(long first, long second) {\n+        final long x = first ^ second;\n+        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? Long.numberOfTrailingZeros(x)\n+                : Long.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(int first, int second) {\n+        final int x = first ^ second;\n+        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? Integer.numberOfTrailingZeros(x)\n+                : Integer.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n+    static final String PROPERTY_PATH = \"java.lang.foreign.native.threshold.power.\";\n+\n+    static long powerOfPropertyOr(String name, int defaultPower) {\n+        final int power = Integer.getInteger(PROPERTY_PATH + name, defaultPower);\n+        return 1L << Math.clamp(power, 0, Integer.SIZE - 1);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Arrays;\n@@ -33,0 +34,1 @@\n+import java.util.Random;\n@@ -125,0 +127,62 @@\n+    @Test\n+    public void random() {\n+        try (var arena = Arena.ofConfined()) {\n+            var rnd = new Random(42);\n+            for (int size = 1; size < 64; size++) {\n+                \/\/ Repeat a fair number of rounds\n+                for (int i = 0; i < 147; i++) {\n+                    var src = arena.allocate(size);\n+                    \/\/ The dst segment might be zero to eight bytes longer\n+                    var dst = arena.allocate(size + rnd.nextInt(8 + 1));\n+                    \/\/ Fill the src with random data\n+                    for (int j = 0; j < size; j++) {\n+                        src.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+                    \/\/ copy the random data from src to dst\n+                    dst.copyFrom(src);\n+                    \/\/ Fill the rest (if any) of the dst with random data\n+                    for (long j = src.byteSize(); j < dst.byteSize(); j++) {\n+                        dst.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+\n+                    if (rnd.nextBoolean()) {\n+                        \/\/ In this branch, we inject one or more deviating bytes\n+                        int beginDiff = rnd.nextInt(size);\n+                        int endDiff = rnd.nextInt(beginDiff, size);\n+                        for (int d = beginDiff; d <= endDiff; d++) {\n+                            byte existing = dst.get(ValueLayout.JAVA_BYTE, d);\n+                            \/\/ Make sure we never get back the same value\n+                            byte mutatedValue;\n+                            do {\n+                                mutatedValue = randomByte(rnd);\n+                            } while (existing == mutatedValue);\n+                            dst.set(ValueLayout.JAVA_BYTE, d, mutatedValue);\n+                        }\n+\n+                        \/\/ They are not equal and differs in position beginDiff\n+                        assertEquals(src.mismatch(dst), beginDiff);\n+                        assertEquals(dst.mismatch(src), beginDiff);\n+                    } else {\n+                        \/\/ In this branch, there is no injection\n+\n+                        if (src.byteSize() == dst.byteSize()) {\n+                            \/\/ The content matches and they are of equal size\n+                            assertEquals(src.mismatch(dst), -1);\n+                            assertEquals(dst.mismatch(src), -1);\n+                        } else {\n+                            \/\/ The content matches but they are of different length\n+                            \/\/ Remember, the size of src is always smaller or equal\n+                            \/\/ to the size of dst.\n+                            assertEquals(src.mismatch(dst), src.byteSize());\n+                            assertEquals(dst.mismatch(src), src.byteSize());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static byte randomByte(Random rnd) {\n+        return (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE + 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class Mismatch {\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int ELEM_SIZE;\n+\n+    MemorySegment srcNative;\n+    MemorySegment dstNative;\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment srcHeap;\n+    MemorySegment dstHeap;\n+\n+    @Setup\n+    public void setup() {\n+        \/\/ Always use the same alignment regardless of size\n+        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n+        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n+        var rnd = new Random(42);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        }\n+        dstNative.copyFrom(srcNative);\n+        srcArray = srcNative.toArray(JAVA_BYTE);\n+        dstArray = dstNative.toArray(JAVA_BYTE);\n+        srcHeap = MemorySegment.ofArray(srcArray);\n+        dstHeap = MemorySegment.ofArray(dstArray);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+    @Benchmark\n+    public long nativeSegmentJava() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+    @Benchmark\n+    public long heapSegmentJava() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long nativeSegmentUnsafe() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long heapSegmentUnsafe() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Benchmark\n+    public long array() {\n+        return Arrays.mismatch(srcArray, dstArray);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Mismatch.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}