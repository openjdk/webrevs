{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.foreign.SegmentBulkOperations;\n@@ -2637,2 +2638,3 @@\n-        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n-                dstSegment, dstFromOffset, dstToOffset);\n+        return SegmentBulkOperations.mismatch(\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment), srcFromOffset, srcToOffset,\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment), dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,2 @@\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+        return SegmentBulkOperations.mismatch(this, 0, byteSize(),\n+                (AbstractMemorySegmentImpl) other, 0, other.byteSize());\n@@ -734,34 +735,0 @@\n-    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n-                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class contains optimized bulk operation methods that operate on one or several\n+ * memory segments.\n+ * <p>\n+ * Generally, the methods attempt to work with as-large-as-possible units of memory at\n+ * a time.\n+ * <p>\n+ * It should be noted that when invoking scoped memory access get\/set operations, it\n+ * is imperative from a performance perspective to convey the sharp types from the\n+ * call site in order for the compiler to pick the correct Unsafe access variant.\n+ *\/\n+public final class SegmentBulkOperations {\n+\n+    private SegmentBulkOperations() {}\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    \/\/ MISMATCH_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    private static final long MISMATCH_NATIVE_THRESHOLD = 1 << 20;\n+\n+    @ForceInline\n+    public static long mismatch(AbstractMemorySegmentImpl src, long srcFromOffset, long srcToOffset,\n+                                AbstractMemorySegmentImpl dst, long dstFromOffset, long dstToOffset) {\n+        final long srcBytes = srcToOffset - srcFromOffset;\n+        final long dstBytes = dstToOffset - dstFromOffset;\n+        src.checkAccess(srcFromOffset, srcBytes, true);\n+        dst.checkAccess(dstFromOffset, dstBytes, true);\n+\n+        final long bytes = Math.min(srcBytes, dstBytes);\n+        final boolean srcAndDstBytesDiffer = srcBytes != dstBytes;\n+\n+        if (bytes == 0) {\n+            return srcAndDstBytesDiffer ? 0 : -1;\n+        } else if (bytes < MISMATCH_NATIVE_THRESHOLD) {\n+            final int limit = (int) (bytes & (MISMATCH_NATIVE_THRESHOLD - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                if (SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 8, srcAndDstBytesDiffer);\n+                }\n+            }\n+            int remaining = (int) bytes - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                if (SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 4, srcAndDstBytesDiffer);\n+                }\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                if (SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 2, srcAndDstBytesDiffer);\n+                }\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n+                        SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n+                    return offset;\n+                }\n+            }\n+            return srcAndDstBytesDiffer ? bytes : -1;\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            long i;\n+            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcToOffset) !=\n+                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            final long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+            return mismatchSmall(src, srcFromOffset + i, dst, dstFromOffset + i, i, (int) remaining, srcAndDstBytesDiffer);\n+        }\n+    }\n+\n+    \/\/ This method is intended for 0 <= bytes < 7\n+    @ForceInline\n+    private static long mismatchSmall(AbstractMemorySegmentImpl src, long srcOffset,\n+                                      AbstractMemorySegmentImpl dst, long dstOffset,\n+                                      long offset, int bytes, boolean srcAndDstBytesDiffer) {\n+        for (int i = 0; i < bytes; i++) {\n+            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + i) !=\n+                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + i)) {\n+                return offset + i;\n+            }\n+        }\n+        return srcAndDstBytesDiffer ? bytes : -1;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class Mismatch {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n+            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n+            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n+            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n+            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\",\n+            \"128\", \"256\", \"512\", \"1024\", \"8388608\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment src;\n+    MemorySegment dst;\n+\n+    @Setup\n+    public void setup() {\n+        src = Arena.ofAuto().allocate(ELEM_SIZE);\n+        dst = Arena.ofAuto().allocate(ELEM_SIZE);\n+        var rnd = new Random(42);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            src.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        }\n+        dst.copyFrom(src);\n+        srcArray = src.toArray(JAVA_BYTE);\n+        dstArray = dst.toArray(JAVA_BYTE);\n+    }\n+\n+    @Benchmark\n+    public long segment() {\n+        return src.mismatch(dst);\n+    }\n+\n+    @Benchmark\n+    public long array() {\n+        return Arrays.mismatch(srcArray, dstArray);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Mismatch.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}