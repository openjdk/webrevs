{"files":[{"patch":"@@ -192,5 +192,0 @@\n-    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n-    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n-\n-    @Override\n@@ -198,0 +193,1 @@\n+    @Override\n@@ -199,40 +195,1 @@\n-        checkReadOnly(false);\n-        if (length == 0) {\n-            \/\/ Implicit state check\n-            checkValidState();\n-        } else if (length < FILL_NATIVE_THRESHOLD) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n-\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n-            for (; offset < limit; offset += 8) {\n-                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n-            }\n-            int remaining = (int) length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n-                offset += 2;\n-                remaining -= 2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ Handle larger segments via native calls\n-            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n-        }\n-        return this;\n+        return SegmentBulkOperations.fill(this, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.util.Architecture;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -48,2 +51,50 @@\n-    \/\/ MISMATCH_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    private static final long MISMATCH_NATIVE_THRESHOLD = 1 << 20;\n+    \/\/ All the threshold values below MUST be a power of two and should preferably be\n+    \/\/ greater or equal to 2^3.\n+\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", Architecture.isAARCH64() ? 10 : 5);\n+    private static final long NATIVE_THRESHOLD_MISMATCH = powerOfPropertyOr(\"mismatch\", 20);\n+\n+    @ForceInline\n+    public static MemorySegment fill(AbstractMemorySegmentImpl dst, byte value) {\n+        dst.checkReadOnly(false);\n+        if (dst.length == 0) {\n+            \/\/ Implicit state check\n+            dst.checkValidState();\n+        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) dst.length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+        }\n+        return dst;\n+    }\n@@ -64,2 +115,2 @@\n-        } else if (bytes < MISMATCH_NATIVE_THRESHOLD) {\n-            final int limit = (int) (bytes & (MISMATCH_NATIVE_THRESHOLD - 8));\n+        } else if (bytes < NATIVE_THRESHOLD_MISMATCH) {\n+            final int limit = (int) (bytes & (NATIVE_THRESHOLD_MISMATCH - 8));\n@@ -135,0 +186,7 @@\n+    static final String PROPERTY_PATH = \"java.lang.foreign.native.threshold.power.\";\n+\n+    static long powerOfPropertyOr(String name, int defaultPower) {\n+        final int power = Integer.getInteger(PROPERTY_PATH + name, defaultPower);\n+        return 1L << Math.clamp(power, 0, Integer.SIZE - 1);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -55,6 +55,1 @@\n-    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n-            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n-            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n-            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n-            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\",\n-            \"128\", \"256\", \"512\", \"1024\", \"8388608\"})\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n@@ -63,0 +58,2 @@\n+    MemorySegment srcNative;\n+    MemorySegment dstNative;\n@@ -65,2 +62,2 @@\n-    MemorySegment src;\n-    MemorySegment dst;\n+    MemorySegment srcHeap;\n+    MemorySegment dstHeap;\n@@ -70,2 +67,3 @@\n-        src = Arena.ofAuto().allocate(ELEM_SIZE);\n-        dst = Arena.ofAuto().allocate(ELEM_SIZE);\n+        \/\/ Always use the same alignment regardless of size\n+        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n+        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n@@ -74,1 +72,1 @@\n-            src.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n@@ -76,3 +74,5 @@\n-        dst.copyFrom(src);\n-        srcArray = src.toArray(JAVA_BYTE);\n-        dstArray = dst.toArray(JAVA_BYTE);\n+        dstNative.copyFrom(srcNative);\n+        srcArray = srcNative.toArray(JAVA_BYTE);\n+        dstArray = dstNative.toArray(JAVA_BYTE);\n+        srcHeap = MemorySegment.ofArray(srcArray);\n+        dstHeap = MemorySegment.ofArray(dstArray);\n@@ -81,0 +81,1 @@\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n@@ -82,2 +83,20 @@\n-    public long segment() {\n-        return src.mismatch(dst);\n+    public long nativeSegmentJava() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+    @Benchmark\n+    public long heapSegmentJava() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long nativeSegmentUnsafe() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long heapSegmentUnsafe() {\n+        return srcNative.mismatch(dstNative);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Mismatch.java","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"}]}