{"files":[{"patch":"@@ -75,2 +75,0 @@\n-    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n@@ -204,32 +202,0 @@\n-    \/**\n-     * Mismatch over long lengths.\n-     *\/\n-    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n-                                                        Object a, long aOffset,\n-                                                        Object b, long bOffset,\n-                                                        long length) {\n-        long off = 0;\n-        long remaining = length;\n-        int i, size;\n-        boolean lastSubRange = false;\n-        while (remaining > 7 && !lastSubRange) {\n-            if (remaining > Integer.MAX_VALUE) {\n-                size = Integer.MAX_VALUE;\n-            } else {\n-                size = (int) remaining;\n-                lastSubRange = true;\n-            }\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n-                    a, aOffset + off,\n-                    b, bOffset + off,\n-                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n-            if (i >= 0)\n-                return off + i;\n-\n-            i = size - ~i;\n-            off += i;\n-            remaining -= i;\n-        }\n-        return ~remaining;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -55,3 +56,3 @@\n-    private static final long NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", Architecture.isAARCH64() ? 10 : 5);\n-    private static final long NATIVE_THRESHOLD_MISMATCH = powerOfPropertyOr(\"mismatch\", 6);\n-    private static final long NATIVE_THRESHOLD_COPY = powerOfPropertyOr(\"copy\", 6);\n+    private static final int NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", Architecture.isAARCH64() ? 10 : 5);\n+    private static final int NATIVE_THRESHOLD_MISMATCH = powerOfPropertyOr(\"mismatch\", Architecture.isAARCH64() ? 31 : 5);\n+    private static final int NATIVE_THRESHOLD_COPY = powerOfPropertyOr(\"copy\", 6);\n@@ -166,1 +167,1 @@\n-        final long bytes = Math.min(srcBytes, dstBytes);\n+        final long length = Math.min(srcBytes, dstBytes);\n@@ -169,1 +170,1 @@\n-        if (bytes == 0) {\n+        if (length == 0) {\n@@ -171,2 +172,2 @@\n-        } else if (bytes < NATIVE_THRESHOLD_MISMATCH) {\n-            return mismatch(src, srcFromOffset, dst, dstFromOffset, 0, (int) bytes, srcAndDstBytesDiffer);\n+        } else if (length < NATIVE_THRESHOLD_MISMATCH) {\n+            return mismatch(src, srcFromOffset, dst, dstFromOffset, 0, (int) length, srcAndDstBytesDiffer);\n@@ -179,1 +180,1 @@\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(src.sessionImpl(), dst.sessionImpl(),\n+            i = vectorizedMismatchLargeForBytes(src.sessionImpl(), dst.sessionImpl(),\n@@ -182,1 +183,1 @@\n-                    bytes);\n+                    length);\n@@ -188,1 +189,1 @@\n-            i = bytes - remaining;\n+            i = length - remaining;\n@@ -193,0 +194,1 @@\n+    \/\/ Mismatch is handled in chunks of 64 (unroll of eight 8s), 8, 4, 2, and 1 byte(s).\n@@ -196,2 +198,1 @@\n-                                 long start, int bytes, boolean srcAndDstBytesDiffer) {\n-        final int limit = (int) (bytes & (NATIVE_THRESHOLD_MISMATCH - 8));\n+                                 long start, int length, boolean srcAndDstBytesDiffer) {\n@@ -199,1 +200,47 @@\n-        for (; offset < limit; offset += 8) {\n+        \/\/ Currently, we do not benefit from super-word optimization on Aarch64 so\n+        \/\/ instead we manually unroll the loop.\n+        \/\/ This gives about 20% performance increase for large values of `length`.\n+        \/\/ Om non-Aarch64 architectures, the unroll code will be eliminated at compile time.\n+        if (Architecture.isX64() && NATIVE_THRESHOLD_MISMATCH > 64) {\n+\n+            \/\/ 0...X...000000\n+            final int bulkLimit = length & (NATIVE_THRESHOLD_MISMATCH - 64);\n+            for (; offset < bulkLimit; offset += 64) {\n+                \/\/ Manually unroll looping in chunks of 64 bytes\n+\n+                \/\/ The creation of long arrays will be optimized away\n+                final long[] s = new long[8];\n+                \/\/ Grouping reads from the same source together improves performance\n+                s[0] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset,      !Architecture.isLittleEndian());\n+                s[1] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset +  8, !Architecture.isLittleEndian());\n+                s[2] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 16, !Architecture.isLittleEndian());\n+                s[3] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 24, !Architecture.isLittleEndian());\n+                s[4] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 32, !Architecture.isLittleEndian());\n+                s[5] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 40, !Architecture.isLittleEndian());\n+                s[6] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 48, !Architecture.isLittleEndian());\n+                s[7] = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset + 56, !Architecture.isLittleEndian());\n+\n+                final long[] d = new long[8];\n+                d[0] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset,      !Architecture.isLittleEndian());\n+                d[1] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset +  8, !Architecture.isLittleEndian());\n+                d[2] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 16, !Architecture.isLittleEndian());\n+                d[3] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 24, !Architecture.isLittleEndian());\n+                d[4] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 32, !Architecture.isLittleEndian());\n+                d[5] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 40, !Architecture.isLittleEndian());\n+                d[6] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 48, !Architecture.isLittleEndian());\n+                d[7] = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset + 56, !Architecture.isLittleEndian());\n+\n+                \/\/ Explicitly checking each index retains performance\n+                if (s[0] != d[0]) { return start + offset +      mismatch(s[0], d[0]); }\n+                if (s[1] != d[1]) { return start + offset +  8 + mismatch(s[1], d[1]); }\n+                if (s[2] != d[2]) { return start + offset + 16 + mismatch(s[2], d[2]); }\n+                if (s[3] != d[3]) { return start + offset + 24 + mismatch(s[3], d[3]); }\n+                if (s[4] != d[4]) { return start + offset + 32 + mismatch(s[4], d[4]); }\n+                if (s[5] != d[5]) { return start + offset + 40 + mismatch(s[5], d[5]); }\n+                if (s[6] != d[6]) { return start + offset + 48 + mismatch(s[6], d[6]); }\n+                if (s[7] != d[7]) { return start + offset + 56 + mismatch(s[7], d[7]); }\n+            }\n+        }\n+        int remaining = length - offset;\n+        \/\/ 0...XXX000\n+        for (; remaining >= 8; remaining -= 8) {\n@@ -205,0 +252,1 @@\n+            offset += 8;\n@@ -206,1 +254,1 @@\n-        int remaining = bytes - offset;\n+\n@@ -235,1 +283,1 @@\n-        return srcAndDstBytesDiffer ? (start + bytes) : -1;\n+        return srcAndDstBytesDiffer ? (start + length) : -1;\n@@ -264,0 +312,32 @@\n+    \/**\n+     * Mismatch over long lengths.\n+     *\/\n+    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+                                                        Object a, long aOffset,\n+                                                        Object b, long bOffset,\n+                                                        long length) {\n+        long off = 0;\n+        long remaining = length;\n+        int i, size;\n+        boolean lastSubRange = false;\n+        while (remaining > 7 && !lastSubRange) {\n+            if (remaining > Integer.MAX_VALUE) {\n+                size = Integer.MAX_VALUE;\n+            } else {\n+                size = (int) remaining;\n+                lastSubRange = true;\n+            }\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+                    a, aOffset + off,\n+                    b, bOffset + off,\n+                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n+            if (i >= 0)\n+                return off + i;\n+\n+            i = size - ~i;\n+            off += i;\n+            remaining -= i;\n+        }\n+        return ~remaining;\n+    }\n+\n@@ -266,1 +346,2 @@\n-    static long powerOfPropertyOr(String name, int defaultPower) {\n+    \/\/ The returned value is in the interval [0, 2^30]\n+    static int powerOfPropertyOr(String name, int defaultPower) {\n@@ -268,1 +349,1 @@\n-        return 1L << Math.clamp(power, 0, Integer.SIZE - 1);\n+        return 1 << Math.clamp(power, 0, Integer.SIZE - 2);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":98,"deletions":17,"binary":false,"changes":115,"status":"modified"}]}