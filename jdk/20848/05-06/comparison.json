{"files":[{"patch":"@@ -1575,1 +1575,1 @@\n-        AbstractMemorySegmentImpl.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n+        SegmentBulkOperations.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    private boolean overlaps(AbstractMemorySegmentImpl that) {\n+    boolean overlaps(AbstractMemorySegmentImpl that) {\n@@ -611,58 +611,0 @@\n-    \/\/ COPY_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    private static final long COPY_NATIVE_THRESHOLD = 1 << 6;\n-\n-    @ForceInline\n-    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n-                            AbstractMemorySegmentImpl dst, long dstOffset,\n-                            long size) {\n-\n-        Utils.checkNonNegativeIndex(size, \"size\");\n-        \/\/ Implicit null check for src and dst\n-        src.checkAccess(srcOffset, size, true);\n-        dst.checkAccess(dstOffset, size, false);\n-\n-        if (size <= 0) {\n-            \/\/ Do nothing\n-        } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n-            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-            \/\/\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n-            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n-            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n-\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n-            int offset = 0;\n-            for (; offset < limit; offset += 8) {\n-                final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            int remaining = (int) size - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-                offset += 2;\n-                remaining -=2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ For larger sizes, the transition to native code pays off\n-            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n-                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.nio.ByteOrder;\n@@ -55,1 +54,1 @@\n-    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    \/\/ Update the FILL value for Aarch64 once 8338975 is fixed.\n@@ -58,0 +57,1 @@\n+    private static final long NATIVE_THRESHOLD_COPY = powerOfPropertyOr(\"copy\", 6);\n@@ -103,0 +103,55 @@\n+    @ForceInline\n+    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n+                            AbstractMemorySegmentImpl dst, long dstOffset,\n+                            long size) {\n+\n+        Utils.checkNonNegativeIndex(size, \"size\");\n+        \/\/ Implicit null check for src and dst\n+        src.checkAccess(srcOffset, size, true);\n+        dst.checkAccess(dstOffset, size, false);\n+\n+        if (size <= 0) {\n+            \/\/ Do nothing\n+        } else if (size < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n+            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+            \/\/\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n+\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            int remaining = (int) size - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 2;\n+                remaining -=2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3)\n-public class CopyTest {\n-\n-    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n-            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n-            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n-            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n-            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\", \"128\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment heapSrcSegment;\n-    MemorySegment heapDstSegment;\n-    MemorySegment nativeSrcSegment;\n-    MemorySegment nativeDstSegment;\n-    ByteBuffer srcBuffer;\n-    ByteBuffer dstBuffer;\n-\n-    @Setup\n-    public void setup() {\n-        srcArray = new byte[ELEM_SIZE];\n-        dstArray = new byte[ELEM_SIZE];\n-        heapSrcSegment = MemorySegment.ofArray(srcArray);\n-        heapDstSegment = MemorySegment.ofArray(dstArray);\n-        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        srcBuffer = ByteBuffer.wrap(srcArray);\n-        dstBuffer = ByteBuffer.wrap(dstArray);\n-    }\n-\n-    @Benchmark\n-    public void array_copy() {\n-        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_copy5Arg() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void native_segment_copy5Arg() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_copy7arg() {\n-        MemorySegment.copy(heapSrcSegment, JAVA_BYTE, 0, heapDstSegment, JAVA_BYTE, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void buffer_copy() {\n-        dstBuffer.put(srcBuffer);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CopyTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestCopy {\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment heapSrcSegment;\n+    MemorySegment heapDstSegment;\n+    MemorySegment nativeSrcSegment;\n+    MemorySegment nativeDstSegment;\n+    ByteBuffer srcBuffer;\n+    ByteBuffer dstBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        srcArray = new byte[ELEM_SIZE];\n+        dstArray = new byte[ELEM_SIZE];\n+        heapSrcSegment = MemorySegment.ofArray(srcArray);\n+        heapDstSegment = MemorySegment.ofArray(dstArray);\n+        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        srcBuffer = ByteBuffer.wrap(srcArray);\n+        dstBuffer = ByteBuffer.wrap(dstArray);\n+    }\n+\n+    @Benchmark\n+    public void arrayCopy() {\n+        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void bufferCopy() {\n+        dstBuffer.put(srcBuffer);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+    @Benchmark\n+    public void heapSegmentCopyJava() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+    @Benchmark\n+    public void heapSegmentCopyUnsafe() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+    @Benchmark\n+    public void nativeSegmentCopyJava() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+    @Benchmark\n+    public void nativeSegmentCopyUnsafe() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestCopy.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-public class Mismatch {\n+public class TestMismatch {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestMismatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Mismatch.java","status":"renamed"}]}