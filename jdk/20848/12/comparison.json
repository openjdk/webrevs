{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.foreign.SegmentBulkOperations;\n@@ -1574,1 +1575,1 @@\n-        AbstractMemorySegmentImpl.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n+        SegmentBulkOperations.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n@@ -2638,2 +2639,3 @@\n-        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n-                dstSegment, dstFromOffset, dstToOffset);\n+        return SegmentBulkOperations.mismatch(\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment), srcFromOffset, srcToOffset,\n+                (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment), dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n@@ -192,5 +190,0 @@\n-    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n-    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n-\n-    @Override\n@@ -198,0 +191,1 @@\n+    @Override\n@@ -199,40 +193,1 @@\n-        checkReadOnly(false);\n-        if (length == 0) {\n-            \/\/ Implicit state check\n-            checkValidState();\n-        } else if (length < FILL_NATIVE_THRESHOLD) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n-\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n-            for (; offset < limit; offset += 8) {\n-                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n-            }\n-            int remaining = (int) length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n-                offset += 2;\n-                remaining -= 2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ Handle larger segments via native calls\n-            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n-        }\n-        return this;\n+        return SegmentBulkOperations.fill(this, value);\n@@ -247,32 +202,0 @@\n-    \/**\n-     * Mismatch over long lengths.\n-     *\/\n-    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n-                                                        Object a, long aOffset,\n-                                                        Object b, long bOffset,\n-                                                        long length) {\n-        long off = 0;\n-        long remaining = length;\n-        int i, size;\n-        boolean lastSubRange = false;\n-        while (remaining > 7 && !lastSubRange) {\n-            if (remaining > Integer.MAX_VALUE) {\n-                size = Integer.MAX_VALUE;\n-            } else {\n-                size = (int) remaining;\n-                lastSubRange = true;\n-            }\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n-                    a, aOffset + off,\n-                    b, bOffset + off,\n-                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n-            if (i >= 0)\n-                return off + i;\n-\n-            i = size - ~i;\n-            off += i;\n-            remaining -= i;\n-        }\n-        return ~remaining;\n-    }\n-\n@@ -317,1 +240,1 @@\n-    private boolean overlaps(AbstractMemorySegmentImpl that) {\n+    boolean overlaps(AbstractMemorySegmentImpl that) {\n@@ -337,1 +260,2 @@\n-        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n+        return SegmentBulkOperations.mismatch(this, 0, byteSize(),\n+                (AbstractMemorySegmentImpl) other, 0, other.byteSize());\n@@ -653,58 +577,0 @@\n-    \/\/ COPY_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n-    private static final long COPY_NATIVE_THRESHOLD = 1 << 6;\n-\n-    @ForceInline\n-    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n-                            AbstractMemorySegmentImpl dst, long dstOffset,\n-                            long size) {\n-\n-        Utils.checkNonNegativeIndex(size, \"size\");\n-        \/\/ Implicit null check for src and dst\n-        src.checkAccess(srcOffset, size, true);\n-        dst.checkAccess(dstOffset, size, false);\n-\n-        if (size <= 0) {\n-            \/\/ Do nothing\n-        } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n-            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n-            \/\/\n-            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n-            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n-            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n-\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n-            int offset = 0;\n-            for (; offset < limit; offset += 8) {\n-                final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            int remaining = (int) size - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-                offset += 2;\n-                remaining -=2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n-            }\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ For larger sizes, the transition to native code pays off\n-            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n-                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n-                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n-        }\n-    }\n-\n@@ -797,34 +663,0 @@\n-    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n-                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":5,"deletions":173,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.ArraysSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+\/**\n+ * This class contains optimized bulk operation methods that operate on one or several\n+ * memory segments.\n+ * <p>\n+ * Generally, the methods attempt to work with as-large-as-possible units of memory at\n+ * a time.\n+ * <p>\n+ * It should be noted that when invoking scoped memory access get\/set operations, it\n+ * is imperative from a performance perspective to convey the sharp types from the\n+ * call site in order for the compiler to pick the correct Unsafe access variant.\n+ *\/\n+public final class SegmentBulkOperations {\n+\n+    private SegmentBulkOperations() {}\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    \/\/ All the threshold values below MUST be a power of two and should preferably be\n+    \/\/ greater or equal to 2^3.\n+\n+    \/\/ Update the FILL value for Aarch64 once 8338975 is fixed.\n+    private static final int NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", Architecture.isAARCH64() ? 10 : 5);\n+    private static final int NATIVE_THRESHOLD_MISMATCH = powerOfPropertyOr(\"mismatch\", 6);\n+    private static final int NATIVE_THRESHOLD_COPY = powerOfPropertyOr(\"copy\", 6);\n+\n+    @ForceInline\n+    public static MemorySegment fill(AbstractMemorySegmentImpl dst, byte value) {\n+        dst.checkReadOnly(false);\n+        if (dst.length == 0) {\n+            \/\/ Implicit state check\n+            dst.checkValidState();\n+        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n+            }\n+            int remaining = (int) dst.length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue, !Architecture.isLittleEndian());\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue, !Architecture.isLittleEndian());\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+        }\n+        return dst;\n+    }\n+\n+    @ForceInline\n+    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n+                            AbstractMemorySegmentImpl dst, long dstOffset,\n+                            long size) {\n+\n+        Utils.checkNonNegativeIndex(size, \"size\");\n+        \/\/ Implicit null check for src and dst\n+        src.checkAccess(srcOffset, size, true);\n+        dst.checkAccess(dstOffset, size, false);\n+\n+        if (size <= 0) {\n+            \/\/ Do nothing\n+        } else if (size < NATIVE_THRESHOLD_COPY && !src.overlaps(dst)) {\n+            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+            \/\/\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n+\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                final long v = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n+            }\n+            int remaining = (int) size - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                final int v = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n+                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                final short v = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset, !Architecture.isLittleEndian());\n+                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v, !Architecture.isLittleEndian());\n+                offset += 2;\n+                remaining -=2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static long mismatch(AbstractMemorySegmentImpl src, long srcFromOffset, long srcToOffset,\n+                                AbstractMemorySegmentImpl dst, long dstFromOffset, long dstToOffset) {\n+        final long srcBytes = srcToOffset - srcFromOffset;\n+        final long dstBytes = dstToOffset - dstFromOffset;\n+        src.checkAccess(srcFromOffset, srcBytes, true);\n+        dst.checkAccess(dstFromOffset, dstBytes, true);\n+\n+        final long length = Math.min(srcBytes, dstBytes);\n+        final boolean srcAndDstBytesDiffer = srcBytes != dstBytes;\n+\n+        if (length == 0) {\n+            return srcAndDstBytesDiffer ? 0 : -1;\n+        } else if (length < NATIVE_THRESHOLD_MISMATCH) {\n+            return mismatch(src, srcFromOffset, dst, dstFromOffset, 0, (int) length, srcAndDstBytesDiffer);\n+        } else {\n+            long i;\n+            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset) !=\n+                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset)) {\n+                return 0;\n+            }\n+            i = vectorizedMismatchLargeForBytes(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset,\n+                    length);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            final long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = length - remaining;\n+            return mismatch(src, srcFromOffset + i, dst, dstFromOffset + i, i, (int) remaining, srcAndDstBytesDiffer);\n+        }\n+    }\n+\n+    \/\/ Mismatch is handled in chunks of 64 (unroll of eight 8s), 8, 4, 2, and 1 byte(s).\n+    @ForceInline\n+    private static long mismatch(AbstractMemorySegmentImpl src, long srcFromOffset,\n+                                 AbstractMemorySegmentImpl dst, long dstFromOffset,\n+                                 long start, int length, boolean srcAndDstBytesDiffer) {\n+        int offset = 0;\n+        final int limit = length & (NATIVE_THRESHOLD_MISMATCH - 8);\n+        for (; offset < limit; offset += 8) {\n+            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n+            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+        }\n+        int remaining = length - offset;\n+        \/\/ 0...XXX000\n+        for (; remaining >= 8; remaining -= 8) {\n+            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n+            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+            offset += 8;\n+        }\n+\n+        \/\/ 0...0X00\n+        if (remaining >= 4) {\n+            final int s = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n+            final int d = SCOPED_MEMORY_ACCESS.getIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+            offset += 4;\n+            remaining -= 4;\n+        }\n+        \/\/ 0...00X0\n+        if (remaining >= 2) {\n+            final short s = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n+            final short d = SCOPED_MEMORY_ACCESS.getShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+            offset += 2;\n+            remaining -= 2;\n+        }\n+        \/\/ 0...000X\n+        if (remaining == 1) {\n+            final byte s = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+            final byte d = SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+            if (s != d) {\n+                return start + offset;\n+            }\n+        }\n+        return srcAndDstBytesDiffer ? (start + length) : -1;\n+        \/\/ We have now fully handled 0...0X...XXXX\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(long first, long second) {\n+        final long x = first ^ second;\n+        return (Architecture.isLittleEndian()\n+                ? Long.numberOfTrailingZeros(x)\n+                : Long.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(int first, int second) {\n+        final int x = first ^ second;\n+        return (Architecture.isLittleEndian()\n+                ? Integer.numberOfTrailingZeros(x)\n+                : Integer.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(short first, short second) {\n+        if (Architecture.isLittleEndian()) {\n+            return ((0xff & first) == (0xff & second)) ? 1 : 0;\n+        } else {\n+            return ((0xff & first) == (0xff & second)) ? 0 : 1;\n+        }\n+    }\n+\n+    \/**\n+     * Mismatch over long lengths.\n+     *\/\n+    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+                                                        Object a, long aOffset,\n+                                                        Object b, long bOffset,\n+                                                        long length) {\n+        long off = 0;\n+        long remaining = length;\n+        int i, size;\n+        boolean lastSubRange = false;\n+        while (remaining > 7 && !lastSubRange) {\n+            if (remaining > Integer.MAX_VALUE) {\n+                size = Integer.MAX_VALUE;\n+            } else {\n+                size = (int) remaining;\n+                lastSubRange = true;\n+            }\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+                    a, aOffset + off,\n+                    b, bOffset + off,\n+                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n+            if (i >= 0)\n+                return off + i;\n+\n+            i = size - ~i;\n+            off += i;\n+            remaining -= i;\n+        }\n+        return ~remaining;\n+    }\n+\n+    static final String PROPERTY_PATH = \"java.lang.foreign.native.threshold.power.\";\n+\n+    \/\/ The returned value is in the interval [0, 2^30]\n+    static int powerOfPropertyOr(String name, int defaultPower) {\n+        final int power = Integer.getInteger(PROPERTY_PATH + name, defaultPower);\n+        return 1 << Math.clamp(power, 0, Integer.SIZE - 2);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Arrays;\n@@ -33,0 +34,1 @@\n+import java.util.Random;\n@@ -125,0 +127,62 @@\n+    @Test\n+    public void random() {\n+        try (var arena = Arena.ofConfined()) {\n+            var rnd = new Random(42);\n+            for (int size = 1; size < 64; size++) {\n+                \/\/ Repeat a fair number of rounds\n+                for (int i = 0; i < 147; i++) {\n+                    var src = arena.allocate(size);\n+                    \/\/ The dst segment might be zero to eight bytes longer\n+                    var dst = arena.allocate(size + rnd.nextInt(8 + 1));\n+                    \/\/ Fill the src with random data\n+                    for (int j = 0; j < size; j++) {\n+                        src.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+                    \/\/ copy the random data from src to dst\n+                    dst.copyFrom(src);\n+                    \/\/ Fill the rest (if any) of the dst with random data\n+                    for (long j = src.byteSize(); j < dst.byteSize(); j++) {\n+                        dst.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+\n+                    if (rnd.nextBoolean()) {\n+                        \/\/ In this branch, we inject one or more deviating bytes\n+                        int beginDiff = rnd.nextInt(size);\n+                        int endDiff = rnd.nextInt(beginDiff, size);\n+                        for (int d = beginDiff; d <= endDiff; d++) {\n+                            byte existing = dst.get(ValueLayout.JAVA_BYTE, d);\n+                            \/\/ Make sure we never get back the same value\n+                            byte mutatedValue;\n+                            do {\n+                                mutatedValue = randomByte(rnd);\n+                            } while (existing == mutatedValue);\n+                            dst.set(ValueLayout.JAVA_BYTE, d, mutatedValue);\n+                        }\n+\n+                        \/\/ They are not equal and differs in position beginDiff\n+                        assertEquals(src.mismatch(dst), beginDiff);\n+                        assertEquals(dst.mismatch(src), beginDiff);\n+                    } else {\n+                        \/\/ In this branch, there is no injection\n+\n+                        if (src.byteSize() == dst.byteSize()) {\n+                            \/\/ The content matches and they are of equal size\n+                            assertEquals(src.mismatch(dst), -1);\n+                            assertEquals(dst.mismatch(src), -1);\n+                        } else {\n+                            \/\/ The content matches but they are of different length\n+                            \/\/ Remember, the size of src is always smaller or equal\n+                            \/\/ to the size of dst.\n+                            assertEquals(src.mismatch(dst), src.byteSize());\n+                            assertEquals(dst.mismatch(src), src.byteSize());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static byte randomByte(Random rnd) {\n+        return (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE + 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3)\n-public class CopyTest {\n-\n-    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n-            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n-            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n-            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n-            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\", \"128\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment heapSrcSegment;\n-    MemorySegment heapDstSegment;\n-    MemorySegment nativeSrcSegment;\n-    MemorySegment nativeDstSegment;\n-    ByteBuffer srcBuffer;\n-    ByteBuffer dstBuffer;\n-\n-    @Setup\n-    public void setup() {\n-        srcArray = new byte[ELEM_SIZE];\n-        dstArray = new byte[ELEM_SIZE];\n-        heapSrcSegment = MemorySegment.ofArray(srcArray);\n-        heapDstSegment = MemorySegment.ofArray(dstArray);\n-        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        srcBuffer = ByteBuffer.wrap(srcArray);\n-        dstBuffer = ByteBuffer.wrap(dstArray);\n-    }\n-\n-    @Benchmark\n-    public void array_copy() {\n-        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_copy5Arg() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void native_segment_copy5Arg() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_copy7arg() {\n-        MemorySegment.copy(heapSrcSegment, JAVA_BYTE, 0, heapDstSegment, JAVA_BYTE, 0, ELEM_SIZE);\n-    }\n-\n-    @Benchmark\n-    public void buffer_copy() {\n-        dstBuffer.put(srcBuffer);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CopyTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class SegmentBulkCopy {\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment heapSrcSegment;\n+    MemorySegment heapDstSegment;\n+    MemorySegment nativeSrcSegment;\n+    MemorySegment nativeDstSegment;\n+    ByteBuffer srcBuffer;\n+    ByteBuffer dstBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        srcArray = new byte[ELEM_SIZE];\n+        dstArray = new byte[ELEM_SIZE];\n+        heapSrcSegment = MemorySegment.ofArray(srcArray);\n+        heapDstSegment = MemorySegment.ofArray(dstArray);\n+        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        srcBuffer = ByteBuffer.wrap(srcArray);\n+        dstBuffer = ByteBuffer.wrap(dstArray);\n+    }\n+\n+    @Benchmark\n+    public void arrayCopy() {\n+        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void bufferCopy() {\n+        dstBuffer.put(srcBuffer);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+    @Benchmark\n+    public void heapSegmentCopyJava() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+    @Benchmark\n+    public void heapSegmentCopyUnsafe() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+    @Benchmark\n+    public void nativeSegmentCopyJava() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+    @Benchmark\n+    public void nativeSegmentCopyUnsafe() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class SegmentBulkFill {\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arraysFill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void heapSegmentFillJava() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void heapSegmentFillUnsafe() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void nativeSegmentFillJava() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void nativeSegmentFillUnsafe() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void unalignedSegmentFillJava() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void unalignedSegmentFillUnsafe() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class SegmentBulkMismatch {\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int ELEM_SIZE;\n+\n+    MemorySegment srcNative;\n+    MemorySegment dstNative;\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment srcHeap;\n+    MemorySegment dstHeap;\n+\n+    @Setup\n+    public void setup() {\n+        \/\/ Always use the same alignment regardless of size\n+        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n+        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n+        var rnd = new Random(42);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        }\n+        dstNative.copyFrom(srcNative);\n+        srcArray = srcNative.toArray(JAVA_BYTE);\n+        dstArray = dstNative.toArray(JAVA_BYTE);\n+        srcHeap = MemorySegment.ofArray(srcArray);\n+        dstHeap = MemorySegment.ofArray(dstArray);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+    @Benchmark\n+    public long nativeSegmentJava() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+    @Benchmark\n+    public long heapSegmentJava() {\n+        return srcHeap.mismatch(dstHeap);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long nativeSegmentUnsafe() {\n+        return srcNative.mismatch(dstNative);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+    @Benchmark\n+    public long heapSegmentUnsafe() {\n+        return srcHeap.mismatch(dstHeap);\n+    }\n+\n+    @Benchmark\n+    public long array() {\n+        return Arrays.mismatch(srcArray, dstArray);\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkMismatch.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3)\n-public class TestFill {\n-\n-    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n-            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n-            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n-            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n-            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] array;\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n-    ByteBuffer buffer;\n-\n-    @Setup\n-    public void setup() {\n-        array = new byte[ELEM_SIZE];\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n-        buffer = ByteBuffer.wrap(array);\n-    }\n-\n-    @Benchmark\n-    public void arrays_fill() {\n-        Arrays.fill(array, (byte) 0);\n-    }\n-\n-    @Benchmark\n-    public void heap_segment_fill() {\n-        heapSegment.fill((byte) 0);\n-    }\n-\n-    @Benchmark\n-    public void native_segment_fill() {\n-        nativeSegment.fill((byte) 0);\n-    }\n-\n-    @Benchmark\n-    public void unaligned_segment_fill() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}