{"files":[{"patch":"@@ -117,38 +117,1 @@\n-            final int limit = (int) (bytes & (NATIVE_THRESHOLD_MISMATCH - 8));\n-            int offset = 0;\n-            for (; offset < limit; offset += 8) {\n-                final long s = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n-                final long d = SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n-                if (s != d) {\n-                    return offset + mismatch(s, d);\n-                }\n-            }\n-            int remaining = (int) bytes - offset;\n-            \/\/ 0...0X00\n-            if (remaining >= 4) {\n-                final int s = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n-                final int d = SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n-                if (s != d) {\n-                    return offset + mismatch(s, d);\n-                }\n-                offset += 4;\n-                remaining -= 4;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= 2) {\n-                if (SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n-                        SCOPED_MEMORY_ACCESS.getShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n-                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 2, srcAndDstBytesDiffer);\n-                }\n-                offset += 2;\n-                remaining -= 2;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n-                        SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n-                    return offset;\n-                }\n-            }\n-            return srcAndDstBytesDiffer ? bytes : -1;\n-            \/\/ We have now fully handled 0...0X...XXXX\n+            return mismatch(src, srcFromOffset, dst, dstFromOffset, 0, (int) bytes, srcAndDstBytesDiffer);\n@@ -171,1 +134,1 @@\n-            return mismatchSmall(src, srcFromOffset + i, dst, dstFromOffset + i, i, (int) remaining, srcAndDstBytesDiffer);\n+            return mismatch(src, srcFromOffset + i, dst, dstFromOffset + i, i, (int) remaining, srcAndDstBytesDiffer);\n@@ -175,1 +138,0 @@\n-    \/\/ This method is intended for 0 <= bytes < 7\n@@ -177,7 +139,29 @@\n-    private static long mismatchSmall(AbstractMemorySegmentImpl src, long srcOffset,\n-                                      AbstractMemorySegmentImpl dst, long dstOffset,\n-                                      long offset, int bytes, boolean srcAndDstBytesDiffer) {\n-        for (int i = 0; i < bytes; i++) {\n-            if (SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + i) !=\n-                    SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + i)) {\n-                return offset + i;\n+    private static long mismatch(AbstractMemorySegmentImpl src, long srcFromOffset,\n+                                 AbstractMemorySegmentImpl dst, long dstFromOffset,\n+                                 long start, int bytes, boolean srcAndDstBytesDiffer) {\n+        final int limit = (int) (bytes & (NATIVE_THRESHOLD_MISMATCH - 8));\n+        int offset = 0;\n+        for (; offset < limit; offset += 8) {\n+            final long s = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+            final long d = SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+        }\n+        int remaining = bytes - offset;\n+        \/\/ 0...0X00\n+        if (remaining >= 4) {\n+            final int s = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+            final int d = SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n+            }\n+            offset += 4;\n+            remaining -= 4;\n+        }\n+        \/\/ 0...00X0\n+        if (remaining >= 2) {\n+            final short s = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+            final short d = SCOPED_MEMORY_ACCESS.getShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+            if (s != d) {\n+                return start + offset + mismatch(s, d);\n@@ -185,0 +169,2 @@\n+            offset += 2;\n+            remaining -= 2;\n@@ -186,1 +172,10 @@\n-        return srcAndDstBytesDiffer ? bytes : -1;\n+        \/\/ 0...000X\n+        if (remaining == 1) {\n+            final byte s = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+            final byte d = SCOPED_MEMORY_ACCESS.getByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+            if (s != d) {\n+                return start + offset;\n+            }\n+        }\n+        return srcAndDstBytesDiffer ? (start + bytes) : -1;\n+        \/\/ We have now fully handled 0...0X...XXXX\n@@ -192,1 +187,1 @@\n-        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+        return (Architecture.isLittleEndian()\n@@ -200,1 +195,1 @@\n-        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+        return (Architecture.isLittleEndian()\n@@ -205,0 +200,9 @@\n+    @ForceInline\n+    private static int mismatch(short first, short second) {\n+        if (Architecture.isLittleEndian()) {\n+            return ((0xff & first) == (0xff & second)) ? 1 : 0;\n+        } else {\n+            return ((0xff & first) == (0xff & second)) ? 0 : 1;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":54,"deletions":50,"binary":false,"changes":104,"status":"modified"}]}