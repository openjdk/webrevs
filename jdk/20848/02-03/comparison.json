{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -119,3 +120,4 @@\n-                if (SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n-                        SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n-                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 8, srcAndDstBytesDiffer);\n+                final long s = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+                final long d = SCOPED_MEMORY_ACCESS.getLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+                if (s != d) {\n+                    return offset + mismatch(s, d);\n@@ -127,3 +129,4 @@\n-                if (SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset) !=\n-                        SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset)) {\n-                    return mismatchSmall(src, srcFromOffset + offset, dst, dstFromOffset + offset, offset, 4, srcAndDstBytesDiffer);\n+                final int s = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset);\n+                final int d = SCOPED_MEMORY_ACCESS.getInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset);\n+                if (s != d) {\n+                    return offset + mismatch(s, d);\n@@ -186,0 +189,16 @@\n+    @ForceInline\n+    private static int mismatch(long first, long second) {\n+        final long x = first ^ second;\n+        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? Long.numberOfTrailingZeros(x)\n+                : Long.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n+    @ForceInline\n+    private static int mismatch(int first, int second) {\n+        final int x = first ^ second;\n+        return (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? Integer.numberOfTrailingZeros(x)\n+                : Integer.numberOfLeadingZeros(x)) \/ 8;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Arrays;\n@@ -33,0 +34,1 @@\n+import java.util.Random;\n@@ -125,0 +127,62 @@\n+    @Test\n+    public void random() {\n+        try (var arena = Arena.ofConfined()) {\n+            var rnd = new Random(42);\n+            for (int size = 1; size < 64; size++) {\n+                \/\/ Repeat a fair number of rounds\n+                for (int i = 0; i < 147; i++) {\n+                    var src = arena.allocate(size);\n+                    \/\/ The dst segment might be zero to eight bytes longer\n+                    var dst = arena.allocate(size + rnd.nextInt(8 + 1));\n+                    \/\/ Fill the src with random data\n+                    for (int j = 0; j < size; j++) {\n+                        src.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+                    \/\/ copy the random data from src to dst\n+                    dst.copyFrom(src);\n+                    \/\/ Fill the rest (if any) of the dst with random data\n+                    for (long j = src.byteSize(); j < dst.byteSize(); j++) {\n+                        dst.set(ValueLayout.JAVA_BYTE, j, randomByte(rnd));\n+                    }\n+\n+                    if (rnd.nextBoolean()) {\n+                        \/\/ In this branch, we inject one or more deviating bytes\n+                        int beginDiff = rnd.nextInt(size);\n+                        int endDiff = rnd.nextInt(beginDiff, size);\n+                        for (int d = beginDiff; d <= endDiff; d++) {\n+                            byte existing = dst.get(ValueLayout.JAVA_BYTE, d);\n+                            \/\/ Make sure we never get back the same value\n+                            byte mutatedValue;\n+                            do {\n+                                mutatedValue = randomByte(rnd);\n+                            } while (existing == mutatedValue);\n+                            dst.set(ValueLayout.JAVA_BYTE, d, mutatedValue);\n+                        }\n+\n+                        \/\/ They are not equal and differs in position beginDiff\n+                        assertEquals(src.mismatch(dst), beginDiff);\n+                        assertEquals(dst.mismatch(src), beginDiff);\n+                    } else {\n+                        \/\/ In this branch, there is no injection\n+\n+                        if (src.byteSize() == dst.byteSize()) {\n+                            \/\/ The content matches and they are of equal size\n+                            assertEquals(src.mismatch(dst), -1);\n+                            assertEquals(dst.mismatch(src), -1);\n+                        } else {\n+                            \/\/ The content matches but they are of different length\n+                            \/\/ Remember, the size of src is always smaller or equal\n+                            \/\/ to the size of dst.\n+                            assertEquals(src.mismatch(dst), src.byteSize());\n+                            assertEquals(dst.mismatch(src), src.byteSize());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static byte randomByte(Random rnd) {\n+        return (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE + 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}