{"files":[{"patch":"@@ -3987,0 +3987,1 @@\n+  ExternalsRecorder::print_statistics();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -708,0 +708,1 @@\n+  void copy_values(GrowableArray<address>* metadata) {} \/\/ Nothing to do\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -214,0 +215,42 @@\n+\n+\/\/ Explicitly instantiate\n+template class ValueRecorder<address>;\n+\n+ExternalsRecorder* ExternalsRecorder::_recorder = nullptr;\n+\n+ExternalsRecorder::ExternalsRecorder(): _arena(mtCode), _externals(&_arena) {}\n+\n+void ExternalsRecorder_init() {\n+  ExternalsRecorder::initialize();\n+}\n+\n+void ExternalsRecorder::initialize() {\n+  \/\/ After Mutex and before CodeCache are initialized\n+  _recorder = new ExternalsRecorder();\n+}\n+\n+int ExternalsRecorder::find_index(address adr) {\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.find_index(adr);\n+}\n+\n+address ExternalsRecorder::at(int index) {\n+  \/\/ find_index() may resize array by reallocating it and freeing old,\n+  \/\/ we need loock here to make sure we not accessing to old freed array.\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.at(index);\n+}\n+\n+int ExternalsRecorder::count() {\n+  MutexLocker ml(ExternalsRecorder_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_recorder != nullptr, \"sanity\");\n+  return _recorder->_externals.count();\n+}\n+\n+#ifndef PRODUCT\n+void ExternalsRecorder::print_statistics() {\n+  tty->print_cr(\"External addresses table: %d entries\", count());\n+}\n+#endif\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-  GrowableArray<int>*       _no_finds; \/\/ all unfindable indexes; usually empty\n+  GrowableArray<int>*      _no_finds; \/\/ all unfindable indexes; usually empty\n@@ -138,2 +138,2 @@\n-  Arena*                    _arena;\n-  bool                      _complete;\n+  Arena*                   _arena;\n+  bool                     _complete;\n@@ -189,1 +189,1 @@\n-  virtual int find_index(jobject h) {\n+  int find_index(jobject h) {\n@@ -206,1 +206,1 @@\n-  virtual int find_index(Metadata* h) {\n+  int find_index(Metadata* h) {\n@@ -246,0 +246,15 @@\n+\/\/ Class is used to record and retrive external addresses\n+\/\/ for Relocation info in compiled code and stubs.\n+class ExternalsRecorder : public CHeapObj<mtCode> {\n+ private:\n+  Arena  _arena;\n+  ValueRecorder<address> _externals;\n+  static ExternalsRecorder* _recorder;\n+ public:\n+  ExternalsRecorder();\n+  static void initialize();\n+  static int find_index(address adr);\n+  static address at(int index);\n+  static int count();\n+  static void print_statistics() PRODUCT_RETURN;\n+};\n","filename":"src\/hotspot\/share\/code\/oopRecorder.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -457,8 +457,2 @@\n-#ifndef _LP64\n-  p = pack_1_int_to(p, (int32_t) (intptr_t)_target);\n-#else\n-  jlong t = (jlong) _target;\n-  int32_t lo = low(t);\n-  int32_t hi = high(t);\n-  p = pack_2_ints_to(p, lo, hi);\n-#endif \/* _LP64 *\/\n+  int index = ExternalsRecorder::find_index(_target);\n+  p = pack_1_int_to(p, index);\n@@ -470,8 +464,2 @@\n-#ifndef _LP64\n-  _target = (address) (intptr_t)unpack_1_int();\n-#else\n-  jint lo, hi;\n-  unpack_2_ints(lo, hi);\n-  jlong t = jlong_from(hi, lo);;\n-  _target = (address) t;\n-#endif \/* _LP64 *\/\n+  int index = unpack_1_int();\n+  _target = ExternalsRecorder::at(index);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+void ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n@@ -110,0 +111,1 @@\n+  ExternalsRecorder_init(); \/\/ After mutex_init() and before CodeCache_init\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+Mutex*   ExternalsRecorder_lock       = nullptr;\n+\n@@ -331,0 +333,3 @@\n+  \/\/ tty_lock is held when printing nmethod and its relocations which use this lock.\n+  MUTEX_DEFL(ExternalsRecorder_lock         , PaddedMutex  , tty_lock);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+extern Mutex*   ExternalsRecorder_lock;          \/\/ used to guard access to the external addresses table\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}