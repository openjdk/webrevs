{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -627,22 +627,2 @@\n-const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int lo = java_add(r0->_lo, r1->_lo);\n-  int hi = java_add(r0->_hi, r1->_hi);\n-  if( !(r0->is_con() && r1->is_con()) ) {\n-    \/\/ Not both constants, compute approximate result\n-    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Underflow on the low side\n-    }\n-    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Overflow on the high side\n-    }\n-    if( lo > hi ) {               \/\/ Handle overflow\n-      lo = min_jint; hi = max_jint;\n-    }\n-  } else {\n-    \/\/ both constants, compute precise result using 'lo' and 'hi'\n-    \/\/ Semantics define overflow and underflow for integer addition\n-    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n-  }\n-  return TypeInt::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n+const Type* AddINode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_add(t1->is_int(), t2->is_int());\n@@ -675,22 +655,2 @@\n-const Type *AddLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  jlong lo = java_add(r0->_lo, r1->_lo);\n-  jlong hi = java_add(r0->_hi, r1->_hi);\n-  if( !(r0->is_con() && r1->is_con()) ) {\n-    \/\/ Not both constants, compute approximate result\n-    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n-      lo =min_jlong; hi = max_jlong; \/\/ Underflow on the low side\n-    }\n-    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n-      lo = min_jlong; hi = max_jlong; \/\/ Overflow on the high side\n-    }\n-    if( lo > hi ) {               \/\/ Handle overflow\n-      lo = min_jlong; hi = max_jlong;\n-    }\n-  } else {\n-    \/\/ both constants, compute precise result using 'lo' and 'hi'\n-    \/\/ Semantics define overflow and underflow for integer addition\n-    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n-  }\n-  return TypeLong::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n+const Type* AddLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_add(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":5,"deletions":45,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -410,0 +410,200 @@\n+\n+  template <class CTP>\n+  static CTP infer_add(CTP t1, CTP t2) {\n+    return infer_binary(t1, t2, [&](const TypeIntMirror<S<CTP>, U<CTP>>& st1, const TypeIntMirror<S<CTP>, U<CTP>>& st2) {\n+      S<CTP> lo = std::numeric_limits<S<CTP>>::min();\n+      S<CTP> hi = std::numeric_limits<S<CTP>>::max();\n+      U<CTP> ulo = std::numeric_limits<U<CTP>>::min();\n+      U<CTP> uhi = std::numeric_limits<U<CTP>>::max();\n+\n+      \/\/ Reminder: st1 is a simple interval, which means:\n+      \/\/ + (st1._lo < 0) == (st1._hi < 0)\n+      \/\/ + st1._lo == st1._ulo\n+      \/\/ + st1._hi == st1._uhi\n+      \/\/ The same is true for st2.\n+      \/\/ Consider unsigned values v1 and v2 satisfying st1 and st2, respectively.\n+      if ((st1._lo < S<CTP>(0)) == (st2._lo < S<CTP>(0))) {\n+        \/\/ All calculations in this section are done on the set of integers, not the set of\n+        \/\/ congruence classes mod 2^n (the set of values of an intn_t).\n+        \/\/\n+        \/\/ If st1._lo >= 0 and st2._lo >= 0, and since st1._lo == st1._ulo, st1._hi == st1._uhi,\n+        \/\/ st2._lo == st2._ulo, st2._hi == st2._uhi, we have both:\n+        \/\/ + 0 <= st1._ulo <= v1 <= st1._uhi <= 2^(n-1) - 1\n+        \/\/ + 0 <= st2._ulo <= v2 <= st2._uhi <= 2^(n-1) - 1\n+        \/\/ Which means 0 <= st1._ulo + st2._ulo <= v1 + v2 <= st1._uhi + st2._uhi <= 2^n - 2, so\n+        \/\/ 0 <= (st1._ulo + st2._ulo) mod 2^n <= (v1 + v2) mod 2^n <= (st1._uhi + st2._uhi) mod 2^n\n+        \/\/\n+        \/\/ Similarly, if st1._lo < 0 and st2._lo < 0, we have:\n+        \/\/ + 2^(n-1) <= st1._ulo <= v1 <= st1._uhi <= 2^n - 1\n+        \/\/ + 2^(n-1) <= st2._ulo <= v2 <= st2._uhi <= 2^n - 1\n+        \/\/ Which means 2^n <= st1._ulo + st2._ulo <= v1 + v2 <= st1._uhi + st2._uhi <= 2^n + 2^n - 2\n+        \/\/ For all value x such that 2^n <= x <= 2^n + 2^n - 1, we have x mod 2^n == x - 2^n. So:\n+        \/\/ 0 <= (st1._ulo + st2._ulo) mod 2^n <= (v1 + v2) mod 2^n <= (st1._uhi + st2._uhi) mod 2^n\n+        \/\/\n+        \/\/ In other words, we can calculate the unsigned bounds.\n+        ulo = st1._ulo + st2._ulo;\n+        uhi = st1._uhi + st2._uhi;\n+        \/\/ We don't actually need to calculate the signed bounds for the sum, because:\n+        \/\/ - If the addition of the ranges does not overflow, then the bounds are\n+        \/\/   [st1._lo + st2._lo, st1._hi + st2._hi], which is equivalent to the unsigned bounds\n+        \/\/   calculation.\n+        \/\/ - If the addition of the ranges overflows, then the bounds are [min_signed, max_signed].\n+        \/\/ In both cases, the signed bounds can be inferred from the computed unsigned bounds.\n+      } else {\n+        \/\/ Similarly, in this case, since one of the ranges is negative, and the other is\n+        \/\/ non-negative, the signed addition does not overflow, we can compute it directly.\n+        lo = S<CTP>(st1._ulo + st2._ulo);\n+        hi = S<CTP>(st1._uhi + st2._uhi);\n+        \/\/ We do not need to compute the unsigned bounds because they can be inferred from the\n+        \/\/ computed signed bounds.\n+      }\n+\n+      \/\/ Consider the addition of v1 and v2, denote v[i] the i-th bit of v, since:\n+      \/\/ - If st1._bits._ones[i] == 1, then v1[i] == 1.\n+      \/\/ - If st1._bits._zeros[i] == 1, then v1[i] == 0.\n+      \/\/ We have: st1._bits._ones[i] <= v1[i] <= (~st1._bits._zeros)[i]\n+      \/\/\n+      \/\/ Try to calculate the sum bits by bits:\n+      \/\/ carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int bit = v1[i] + v2[i] + carry[i];\n+      \/\/   sum[i] = bit & 1;\n+      \/\/   carry[i - 1] = (bit >= 2);\n+      \/\/ }\n+      \/\/\n+      \/\/ Then, try to calculate the min and max of carry[i] from the bounds of v1[i] and v2[i]:\n+      \/\/ min_carry[n - 1] = 0;\n+      \/\/ max_carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int min_bit = min_v1[i] + min_v2[i] + min_carry[i];\n+      \/\/   int max_bit = max_v1[i] + max_v2[i] + max_carry[i];\n+      \/\/   min_carry[i - 1] = (min_bit >= 2);\n+      \/\/   max_carry[i - 1] = (max_bit >= 2);\n+      \/\/ }\n+      \/\/\n+      \/\/ In other word:\n+      \/\/ min_carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int min_bit = min_v1[i] + min_v2[i] + min_carry[i];\n+      \/\/   min_carry[i - 1] = (min_bit >= 2);\n+      \/\/ }\n+      \/\/\n+      \/\/ Since st1._bits._ones[i] <= v1[i], we have:\n+      \/\/ min_carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int min_bit = st1._bits._ones[i] + st2._bits._ones[i] + min_carry[i];\n+      \/\/   min_carry[i - 1] = (min_bit >= 2);\n+      \/\/ }\n+      \/\/\n+      \/\/ If we gather the min_bits into a value tmp, it is clear that\n+      \/\/ tmp = st1._bits._ones + st2._bits._ones:\n+      \/\/ min_carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int min_bit = st1._bits._ones[i] + st2._bits._ones[i] + min_carry[i];\n+      \/\/   tmp[i] = min_bit & 1;\n+      \/\/   min_carry[i - 1] = (min_bit >= 2)\n+      \/\/ }\n+      \/\/\n+      \/\/ Since st1._bits._ones[i], st2._bits._ones[i], min_carry[i] can only be 0 or 1,\n+      \/\/ min_bit >= 2 if and only if either:\n+      \/\/ + st1._bits._ones[i] == st2._bits._ones[i] == 1\n+      \/\/ + (st1._bits._ones[i] != st2._bits._ones[i]) && ((min_bit & 1) == 0)\n+      \/\/\n+      \/\/ In other words:\n+      \/\/ min_carry[i - 1] == 1 iff either:\n+      \/\/ + (st1._bits._ones[i] & st2._bits._ones[i]) == 1\n+      \/\/ + ((st1._bits._ones[i] ^ st2._bits._ones[i]) & (~tmp[i])) == 1\n+      \/\/\n+      \/\/ As a result, we can calculate min_carry:\n+      \/\/ min_carry = ((st1._bits._ones & st2._bits._ones) | ((st1._bits._ones ^ st2._bits._ones) & (~(st1._bits._ones + st2._bits._ones)))) << 1\n+      U<CTP> min_carry = ((st1._bits._ones & st2._bits._ones) |\n+                          ((st1._bits._ones ^ st2._bits._ones) & (~(st1._bits._ones + st2._bits._ones))));\n+      min_carry = min_carry << 1;\n+      \/\/ Similarly, we can calculate max_carry from ~st1._bits._zeros and ~st2._bits._zeros\n+      U<CTP> max_carry = ((~st1._bits._zeros & ~st2._bits._zeros) |\n+                          ((~st1._bits._zeros ^ ~st2._bits._zeros) & (~(~st1._bits._zeros + ~st2._bits._zeros))));\n+      max_carry = max_carry << 1;\n+      \/\/ A bit carry[i] is known iff min_carry[i] == max_carry[i], or (min_carry[i] ^ max_carry[i]) == 0\n+      U<CTP> carry_known_bits = ~(min_carry ^ max_carry);\n+      \/\/ A bit of sum is only known if the corresponding bit in all of v1, v2, and carry is known,\n+      \/\/ and the value of sum[i] then would be (v1[i] + v2[i] + carry[i]) & 1, or\n+      \/\/ (v1[i] ^ v2[i] ^ carry[i])\n+      U<CTP> known_bits = (st1._bits._ones | st1._bits._zeros) & (st2._bits._ones | st2._bits._zeros) & carry_known_bits;\n+      \/\/ Calculate the result and filter in the bit positions that are known\n+      U<CTP> res = st1._bits._ones ^ st2._bits._ones ^ min_carry;\n+      U<CTP> zeros = known_bits & ~res;\n+      U<CTP> ones = known_bits & res;\n+      return TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}});\n+    });\n+  }\n+\n+  template <class CTP>\n+  static CTP infer_sub(CTP t1, CTP t2) {\n+    return infer_binary(t1, t2, [&](const TypeIntMirror<S<CTP>, U<CTP>>& st1, const TypeIntMirror<S<CTP>, U<CTP>>& st2) {\n+      \/\/ The reasoning is very similar to infer_add, so I go through it quickly\n+      S<CTP> lo = std::numeric_limits<S<CTP>>::min();\n+      S<CTP> hi = std::numeric_limits<S<CTP>>::max();\n+      U<CTP> ulo = std::numeric_limits<U<CTP>>::min();\n+      U<CTP> uhi = std::numeric_limits<U<CTP>>::max();\n+\n+      \/\/ Consider unsigned values v1 and v2 satisfying st1 and st2, respectively.\n+      if ((st1._lo < S<CTP>(0)) == (st2._lo < S<CTP>(0))) {\n+        \/\/ Signed subtraction of 2 values with the same sign cannot overflow, we can directly\n+        \/\/ compute the signed bounds.\n+        lo = S<CTP>(st1._ulo - st2._uhi);\n+        hi = S<CTP>(st1._uhi - st2._ulo);\n+        \/\/ The unsigned bounds can be inferred from the signed bounds, so there is no need to\n+        \/\/ compute them.\n+      } else {\n+        \/\/ Unsigned subtraction of 2 values v1, v2 such that 0 <= vi < 2^(n-1) <= vj < 2^n\n+        \/\/ If i == 1, j == 2, the operation always overflows, and the result in the mod 2^n\n+        \/\/ arithmetic is always v1 - v2 + 2^n. Which means that we still satisfy:\n+        \/\/ (st1._ulo - st2._uhi) mod 2^n <= (v1 - v2) mod 2^n <= (st1._uhi - st2._ulo) mod 2^n\n+        \/\/\n+        \/\/ On the other hand, if i == 2, j == 1, the subtraction never overflows, and the bounds\n+        \/\/ can be computed trivially:\n+        \/\/ (st1._ulo - st2._uhi) mod 2^n <= (v1 - v2) mod 2^n <= (st1._uhi - st2._ulo) mod 2^n\n+        ulo = st1._ulo - st2._uhi;\n+        uhi = st1._uhi - st2._ulo;\n+        \/\/ The signed bounds can be inferred from the unsigned bounds, so there is no need to\n+        \/\/ compute them.\n+      }\n+\n+      \/\/ Bit calculation is similar to infer_add:\n+      \/\/ max_carry[n - 1] = 0;\n+      \/\/ for (int i = n - 1; i >= 0; i--) {\n+      \/\/   int min_bit = st1._bits._ones[i] - (~st2._bits._zeros)[i] - max_carry[i];\n+      \/\/   tmp[i] = min_bit & 1;\n+      \/\/   max_carry[i - 1] = (min_bit < 0)\n+      \/\/ }\n+      \/\/\n+      \/\/ Since st1._bits._ones[i], (~st2._bits._ones)[i], max_carry[i] can only be 0 or 1,\n+      \/\/ min_bit < 0 if and only if either:\n+      \/\/ + st1._bits._ones[i] == 0 && (~st2._bits._zeros)[i] == 1\n+      \/\/ + st1._bits._ones[i] == (~st2._bits._zeros)[i] && ((min_bit & 1) == 1)\n+      \/\/\n+      \/\/ In other words:\n+      \/\/ max_carry[i - 1] == 1 iff either:\n+      \/\/ + ((~st1._bits._ones)[i] | (~st2._bits._zeros)[i]) == 1\n+      \/\/ + ((st1._bits._ones[i] ^ st2._bits._zeros[i]) & tmp[i]) == 1\n+      U<CTP> max_carry = ((~st1._bits._ones & ~st2._bits._zeros) |\n+                          ((st1._bits._ones ^ st2._bits._zeros) & (st1._bits._ones - (~st2._bits._zeros))));\n+      max_carry = max_carry << 1;\n+      \/\/ Similarly, we can calculate min_carry, just substitute st1._bits._ones and\n+      \/\/ ~st2._bits._zeros from above with ~st1._bits._zeros and st2._bits._ones, respectively.\n+      \/\/ Note that x ^ y == ~x ^ ~y.\n+      U<CTP> min_carry = ((st1._bits._zeros & st2._bits._ones) |\n+                          ((st1._bits._zeros ^ st2._bits._ones) & ((~st1._bits._zeros) - st2._bits._ones)));\n+      min_carry = min_carry << 1;\n+      \/\/ A bit of the result is only known if the corresponding bit in all of v1, v2, and carry is\n+      \/\/ known.\n+      U<CTP> carry_known_bits = ~(min_carry ^ max_carry);\n+      U<CTP> known_bits = (st1._bits._ones | st1._bits._zeros) & (st2._bits._ones | st2._bits._zeros) & carry_known_bits;\n+      \/\/ Calculate the result and filter in the bit positions that are known, carry-less bit\n+      \/\/ subtraction is also bitwise-xor.\n+      U<CTP> res = st1._bits._ones ^ st2._bits._ones ^ min_carry;\n+      U<CTP> zeros = known_bits & ~res;\n+      U<CTP> ones = known_bits & res;\n+      return TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}});\n+    });\n+  }\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -337,15 +338,2 @@\n-const Type *SubINode::sub( const Type *t1, const Type *t2 ) const {\n-  const TypeInt *r0 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t2->is_int();\n-  int32_t lo = java_subtract(r0->_lo, r1->_hi);\n-  int32_t hi = java_subtract(r0->_hi, r1->_lo);\n-\n-  \/\/ We next check for 32-bit overflow.\n-  \/\/ If that happens, we just assume all integers are possible.\n-  if( (((r0->_lo ^ r1->_hi) >= 0) ||    \/\/ lo ends have same signs OR\n-       ((r0->_lo ^      lo) >= 0)) &&   \/\/ lo results have same signs AND\n-      (((r0->_hi ^ r1->_lo) >= 0) ||    \/\/ hi ends have same signs OR\n-       ((r0->_hi ^      hi) >= 0)) )    \/\/ hi results have same signs\n-    return TypeInt::make(lo,hi,MAX2(r0->_widen,r1->_widen));\n-  else                          \/\/ Overflow; assume all integers\n-    return TypeInt::INT;\n+const Type* SubINode::sub(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_sub(t1->is_int(), t2->is_int());\n@@ -514,15 +502,2 @@\n-const Type *SubLNode::sub( const Type *t1, const Type *t2 ) const {\n-  const TypeLong *r0 = t1->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t2->is_long();\n-  jlong lo = java_subtract(r0->_lo, r1->_hi);\n-  jlong hi = java_subtract(r0->_hi, r1->_lo);\n-\n-  \/\/ We next check for 32-bit overflow.\n-  \/\/ If that happens, we just assume all integers are possible.\n-  if( (((r0->_lo ^ r1->_hi) >= 0) ||    \/\/ lo ends have same signs OR\n-       ((r0->_lo ^      lo) >= 0)) &&   \/\/ lo results have same signs AND\n-      (((r0->_hi ^ r1->_lo) >= 0) ||    \/\/ hi ends have same signs OR\n-       ((r0->_hi ^      hi) >= 0)) )    \/\/ hi results have same signs\n-    return TypeLong::make(lo,hi,MAX2(r0->_widen,r1->_widen));\n-  else                          \/\/ Overflow; assume all integers\n-    return TypeLong::LONG;\n+const Type* SubLNode::sub(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_sub(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -621,0 +621,32 @@\n+template <class U>\n+class OpAdd {\n+public:\n+  U operator()(U v1, U v2) const {\n+    return v1 + v2;\n+  }\n+};\n+\n+template <class CTP>\n+class InferAdd {\n+public:\n+  CTP operator()(CTP t1, CTP t2) const {\n+    return RangeInference::infer_add(t1, t2);\n+  }\n+};\n+\n+template <class U>\n+class OpSub {\n+public:\n+  U operator()(U v1, U v2) const {\n+    return v1 - v2;\n+  }\n+};\n+\n+template <class CTP>\n+class InferSub {\n+public:\n+  CTP operator()(CTP t1, CTP t2) const {\n+    return RangeInference::infer_sub(t1, t2);\n+  }\n+};\n+\n@@ -625,0 +657,2 @@\n+  test_binary<OpAdd, InferAdd>();\n+  test_binary<OpSub, InferSub>();\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}