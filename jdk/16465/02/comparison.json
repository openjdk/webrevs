{"files":[{"patch":"@@ -471,1 +471,4 @@\n-          \"Trace decision for simplifying allocation merges.\")              \\\n+             \"Trace decision for simplifying allocation merges.\")           \\\n+                                                                            \\\n+  develop(bool, VerifyReduceAllocationMerges, true,                         \\\n+          \"Verify reduce allocation merges in escape analysis\")             \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -372,0 +372,12 @@\n+\n+  if (VerifyReduceAllocationMerges) {\n+    for (uint i = 0; i < reducible_merges.size(); i++ ) {\n+      Node* n = reducible_merges.at(i);\n+      if (!can_reduce_phi(n->as_Phi())) {\n+        TraceReduceAllocationMerges = true;\n+        n->dump(2);\n+        n->dump(-2);\n+        assert(can_reduce_phi(n->as_Phi()), \"Sanity: previous reducible Phi is no longer reducible before SUT.\");\n+      }\n+    }\n+  }\n@@ -533,0 +545,9 @@\n+#ifdef ASSERT\n+  if (VerifyReduceAllocationMerges && !can_reduce_phi(ophi)) {\n+    TraceReduceAllocationMerges = true;\n+    ophi->dump(2);\n+    ophi->dump(-2);\n+    assert(can_reduce_phi(ophi), \"Sanity: previous reducible Phi is no longer reducible inside reduce_phi_on_field_access.\");\n+  }\n+#endif\n+\n@@ -536,1 +557,0 @@\n-    uint num_edges = 1;\n@@ -540,1 +560,0 @@\n-      num_edges = previous_addp->in(AddPNode::Address) == previous_addp->in(AddPNode::Base) ? 2 : 1;\n@@ -550,0 +569,1 @@\n+          assert(data_phi->is_Phi(), \"Return of split_through_phi should be a Phi.\");\n@@ -555,13 +575,12 @@\n-          if (data_phi != nullptr && data_phi->is_Phi()) {\n-            for (uint i = 1; i < data_phi->req(); i++) {\n-              Node* new_load = data_phi->in(i);\n-              if (new_load->is_Load()) {\n-                Node* new_addp = new_load->in(MemNode::Address);\n-                Node* base = get_addp_base(new_addp);\n-\n-                \/\/ The base might not be something that we can create an unique\n-                \/\/ type for. If that's the case we are done with that input.\n-                PointsToNode* jobj_ptn = unique_java_object(base);\n-                if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n-                  continue;\n-                }\n+          for (uint i = 1; i < data_phi->req(); i++) {\n+            Node* new_load = data_phi->in(i);\n+            if (new_load->is_Load()) {\n+              Node* new_addp = new_load->in(MemNode::Address);\n+              Node* base = get_addp_base(new_addp);\n+\n+              \/\/ The base might not be something that we can create an unique\n+              \/\/ type for. If that's the case we are done with that input.\n+              PointsToNode* jobj_ptn = unique_java_object(base);\n+              if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n+                continue;\n+              }\n@@ -569,16 +588,15 @@\n-                \/\/ Push to alloc_worklist since the base has an unique_type\n-                alloc_worklist.append_if_missing(new_addp);\n-\n-                \/\/ Now let's add the node to the connection graph\n-                _nodes.at_grow(new_addp->_idx, nullptr);\n-                add_field(new_addp, fn->escape_state(), fn->offset());\n-                add_base(ptnode_adr(new_addp->_idx)->as_Field(), ptnode_adr(base->_idx));\n-\n-                \/\/ If the load doesn't load an object then it won't be\n-                \/\/ part of the connection graph\n-                PointsToNode* curr_load_ptn = ptnode_adr(previous_load->_idx);\n-                if (curr_load_ptn != nullptr) {\n-                  _nodes.at_grow(new_load->_idx, nullptr);\n-                  add_local_var(new_load, curr_load_ptn->escape_state());\n-                  add_edge(ptnode_adr(new_load->_idx), ptnode_adr(new_addp->_idx)->as_Field());\n-                }\n+              \/\/ Push to alloc_worklist since the base has an unique_type\n+              alloc_worklist.append_if_missing(new_addp);\n+\n+              \/\/ Now let's add the node to the connection graph\n+              _nodes.at_grow(new_addp->_idx, nullptr);\n+              add_field(new_addp, fn->escape_state(), fn->offset());\n+              add_base(ptnode_adr(new_addp->_idx)->as_Field(), ptnode_adr(base->_idx));\n+\n+              \/\/ If the load doesn't load an object then it won't be\n+              \/\/ part of the connection graph\n+              PointsToNode* curr_load_ptn = ptnode_adr(previous_load->_idx);\n+              if (curr_load_ptn != nullptr) {\n+                _nodes.at_grow(new_load->_idx, nullptr);\n+                add_local_var(new_load, curr_load_ptn->escape_state());\n+                add_edge(ptnode_adr(new_load->_idx), ptnode_adr(new_addp->_idx)->as_Field());\n@@ -589,2 +607,1 @@\n-        --k;\n-        k = MIN2(k, (int)previous_addp->outcnt()-1);\n+        k = MIN2(--k, (int)previous_addp->outcnt()-1);\n@@ -595,0 +612,14 @@\n+      _igvn->remove_globally_dead_node(previous_addp);\n+    }\n+    j = MIN2(--j, (int)ophi->outcnt()-1);\n+  }\n+\n+#ifdef ASSERT\n+  if (VerifyReduceAllocationMerges) {\n+    for (uint j = 0; j < ophi->outcnt(); j++) {\n+      Node* use = ophi->raw_out(j);\n+      if (!use->is_SafePoint()) {\n+        ophi->dump(2);\n+        ophi->dump(-2);\n+        assert(false, \"Should be a SafePoint.\");\n+      }\n@@ -596,2 +627,0 @@\n-    j -= num_edges;\n-    j = MIN2(j, (int)ophi->outcnt()-1);\n@@ -599,0 +628,1 @@\n+#endif\n@@ -3610,0 +3640,1 @@\n+  DEBUG_ONLY(Unique_Node_List reduced_merges;)\n@@ -3786,0 +3817,5 @@\n+#ifdef ASSERT\n+        if (VerifyReduceAllocationMerges) {\n+          reduced_merges.push(n);\n+        }\n+#endif\n@@ -3898,8 +3934,18 @@\n-  \/\/ At this point reducible Phis shouldn't have AddP users anymore; only SafePoints.\n-  for (uint i = 0; i < reducible_merges.size(); i++) {\n-    Node* phi = reducible_merges.at(i);\n-    for (DUIterator_Fast jmax, j = phi->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = phi->fast_out(j);\n-      if (!use->is_SafePoint()) {\n-        phi->dump(-3);\n-        assert(false, \"Unexpected user of reducible Phi -> %s\", use->Name());\n+  if (VerifyReduceAllocationMerges) {\n+    \/\/ At this point reducible Phis shouldn't have AddP users anymore; only SafePoints.\n+    for (uint i = 0; i < reducible_merges.size(); i++) {\n+      Node* phi = reducible_merges.at(i);\n+\n+      if (!reduced_merges.member(phi)) {\n+        phi->dump(2);\n+        phi->dump(-2);\n+        assert(false, \"This reducible merge wasn't reduced.\");\n+      }\n+\n+      for (DUIterator_Fast jmax, j = phi->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = phi->fast_out(j);\n+        if (!use->is_SafePoint()) {\n+          phi->dump(2);\n+          phi->dump(-2);\n+          assert(false, \"Unexpected user of reducible Phi -> %d:%s:%d\", use->_idx, use->Name(), use->outcnt());\n+        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":89,"deletions":43,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n) && !reduce_merge_precheck) {\n@@ -678,0 +678,5 @@\n+\n+  if (TraceReduceAllocationMerges && !can_eliminate && reduce_merge_precheck) {\n+    tty->print_cr(\"\\tCan't eliminate allocation because '%s': \", fail_eliminate != nullptr ? fail_eliminate : \"\");\n+    DEBUG_ONLY(if (disq_node != nullptr) disq_node->dump();)\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}