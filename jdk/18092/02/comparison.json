{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,48 @@\n+template <class BitMapWithAllocator>\n+bm_word_t* GrowableBitMap<BitMapWithAllocator>::copy_of_range(idx_t start_bit, idx_t end_bit) {\n+  assert(start_bit < end_bit, \"End bit must come after start bit\");\n+  assert(end_bit <= size(), \"End bit not in bitmap\");\n+\n+  \/\/ We might have extra bits at the end that we don't want to lose\n+  idx_t const cutoff = bit_in_word(end_bit);\n+  idx_t const start_word = to_words_align_down(start_bit);\n+  idx_t const end_word = to_words_align_up(end_bit);\n+  bm_word_t* const old_map = map();\n+\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n+\n+  bm_word_t* new_map = derived->allocate(end_word - start_word);\n+\n+  \/\/ All words need to be shifted by this amount\n+  idx_t const shift = bit_in_word(start_bit);\n+  \/\/ Bits shifted out by a word need to be passed into the next\n+  idx_t carry = 0;\n+\n+  \/\/ Iterate the map backwards as the shift will result in carry-out bits\n+  for (idx_t i = end_word; i-- > start_word;) {\n+    new_map[i-start_word] = old_map[i] >> shift;\n+\n+    if (shift != 0) {\n+      new_map[i-start_word] |= carry;\n+      carry = old_map[i] << (BitsPerWord - shift);\n+    }\n+  }\n+\n+  return new_map;\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::truncate(idx_t start_bit, idx_t end_bit) {\n+  const size_t old_size_in_words = calc_size_in_words(size());\n+  const idx_t new_size_in_bits = end_bit - start_bit;\n+  bm_word_t* const old_map = map();\n+\n+  bm_word_t* new_map = copy_of_range(start_bit, end_bit);\n+\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n+  \/\/ Free and clear old map to avoid left over bits\n+  derived->free(old_map, old_size_in_words);\n+  update(nullptr, 0);\n+  update(new_map, new_size_in_bits);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -569,0 +569,5 @@\n+ private:\n+  \/\/ Copy the region [start, end) of the bitmap\n+  \/\/ Bits in the selected range are copied to a newly allocated map\n+  bm_word_t* copy_of_range(idx_t start_bit, idx_t end_bit);\n+\n@@ -588,0 +593,3 @@\n+  \/\/ Reduce bitmap to the region [start, end)\n+  \/\/ Previous map is deallocated and replaced with the newly allocated map from copy_of_range\n+  void truncate(idx_t start_bit, idx_t end_bit);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,0 +117,127 @@\n+class BitMapTruncateTest {\n+\n+ public:\n+  const static BitMap::idx_t BITMAP_SIZE = 128;\n+\n+  template <class ResizableBitMapClass>\n+  static void fillBitMap(ResizableBitMapClass& map,  BitMap::idx_t size) {\n+    BitMap::idx_t set_bits[] = {0, 31, 63, 64, 95, 127};\n+    for (BitMap::idx_t bit : set_bits) {\n+        if (bit < size) {\n+            map.set_bit(bit);\n+        }\n+    }\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateOneWord() {\n+    ResourceMark rm;\n+\n+    ResizableBitMapClass map(64);\n+    map.set_bit(0);\n+    map.set_bit(1);\n+    map.set_bit(2);\n+    map.set_bit(3);\n+\n+    ResizableBitMapClass result(2);\n+    result.set_bit(0);\n+    result.set_bit(1);\n+\n+    map.truncate(1, 3);\n+\n+    EXPECT_TRUE(map.is_same(result));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateSame() {\n+    \/\/ Resulting map should be the same as the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(BITMAP_SIZE);\n+    fillBitMap(expected, BITMAP_SIZE);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, BITMAP_SIZE);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStart() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    fillBitMap(expected, 64);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, 64);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEnd() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    expected.set_bit(0);\n+    expected.set_bit(31);\n+    expected.set_bit(63);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(64, 128);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateMiddle() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    expected.set_bit(31);\n+    expected.set_bit(32);\n+    expected.set_bit(63);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(32, 96);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStartUnaligned() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(96);\n+    fillBitMap(expected, 96);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, 96);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEndUnaligned() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(97);\n+    expected.set_bit(0);\n+    expected.set_bit(32);\n+    expected.set_bit(33);\n+    expected.set_bit(64);\n+    expected.set_bit(96);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(31, 128);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+};\n+\n@@ -207,0 +334,63 @@\n+\n+TEST_VM(BitMap, truncate_same) {\n+  BitMapTruncateTest::testTruncateSame<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_start) {\n+  BitMapTruncateTest::testTruncateStart<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_end) {\n+  BitMapTruncateTest::testTruncateEnd<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_middle) {\n+  BitMapTruncateTest::testTruncateMiddle<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_start_unaligned) {\n+  BitMapTruncateTest::testTruncateStartUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_end_unaligned) {\n+  BitMapTruncateTest::testTruncateEndUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_one_word) {\n+  BitMapTruncateTest::testTruncateOneWord<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap.cpp","additions":190,"deletions":0,"binary":false,"changes":190,"status":"modified"}]}