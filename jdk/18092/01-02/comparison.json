{"files":[{"patch":"@@ -118,1 +118,1 @@\n-  idx_t shift = bit_in_word(start_bit);\n+  idx_t const shift = bit_in_word(start_bit);\n@@ -135,5 +135,0 @@\n-template <class BitMapWithAllocator>\n-bm_word_t* GrowableBitMap<BitMapWithAllocator>::copy_of_range(idx_t start_bit) {\n-  return copy_of_range(start_bit, size());\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -573,2 +573,0 @@\n-  \/\/ Copy the region from the start bit to the end of the map\n-  bm_word_t* copy_of_range(idx_t start_bit);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,127 @@\n+class BitMapTruncateTest {\n+\n+ public:\n+  const static BitMap::idx_t BITMAP_SIZE = 128;\n+\n+  template <class ResizableBitMapClass>\n+  static void fillBitMap(ResizableBitMapClass& map,  BitMap::idx_t size) {\n+    BitMap::idx_t set_bits[] = {0, 31, 63, 64, 95, 127};\n+    for (BitMap::idx_t bit : set_bits) {\n+        if (bit < size) {\n+            map.set_bit(bit);\n+        }\n+    }\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateOneWord() {\n+    ResourceMark rm;\n+\n+    ResizableBitMapClass map(64);\n+    map.set_bit(0);\n+    map.set_bit(1);\n+    map.set_bit(2);\n+    map.set_bit(3);\n+\n+    ResizableBitMapClass result(2);\n+    result.set_bit(0);\n+    result.set_bit(1);\n+\n+    map.truncate(1, 3);\n+\n+    EXPECT_TRUE(map.is_same(result));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateSame() {\n+    \/\/ Resulting map should be the same as the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(BITMAP_SIZE);\n+    fillBitMap(expected, BITMAP_SIZE);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, BITMAP_SIZE);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStart() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    fillBitMap(expected, 64);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, 64);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEnd() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    expected.set_bit(0);\n+    expected.set_bit(31);\n+    expected.set_bit(63);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(64, 128);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateMiddle() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(64);\n+    expected.set_bit(31);\n+    expected.set_bit(32);\n+    expected.set_bit(63);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(32, 96);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStartUnaligned() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(96);\n+    fillBitMap(expected, 96);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(0, 96);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEndUnaligned() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass expected(97);\n+    expected.set_bit(0);\n+    expected.set_bit(32);\n+    expected.set_bit(33);\n+    expected.set_bit(64);\n+    expected.set_bit(96);\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(31, 128);\n+\n+    EXPECT_TRUE(map.is_same(expected));\n+  }\n+};\n+\n@@ -207,0 +334,63 @@\n+\n+TEST_VM(BitMap, truncate_same) {\n+  BitMapTruncateTest::testTruncateSame<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_start) {\n+  BitMapTruncateTest::testTruncateStart<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_end) {\n+  BitMapTruncateTest::testTruncateEnd<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_middle) {\n+  BitMapTruncateTest::testTruncateMiddle<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_start_unaligned) {\n+  BitMapTruncateTest::testTruncateStartUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_end_unaligned) {\n+  BitMapTruncateTest::testTruncateEndUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMap, truncate_one_word) {\n+  BitMapTruncateTest::testTruncateOneWord<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap.cpp","additions":190,"deletions":0,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -1,215 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/arena.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-#include \"unittest.hpp\"\n-\n-class BitMapTruncateTest {\n-\n- public:\n-  const static BitMap::idx_t BITMAP_SIZE = 128;\n-\n-  template <class ResizableBitMapClass>\n-  static void fillBitMap(ResizableBitMapClass& map,  BitMap::idx_t size) {\n-    BitMap::idx_t set_bits[] = {0, 31, 63, 64, 95, 127};\n-    for (BitMap::idx_t bit : set_bits) {\n-        if (bit < size) {\n-            map.set_bit(bit);\n-        }\n-    }\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncate(BitMap::idx_t start_bit, BitMap::idx_t end_bit, ResizableBitMapClass& result) {\n-    ResourceMark rm;\n-\n-    ResizableBitMapClass map(BITMAP_SIZE);\n-    fillBitMap(map, BITMAP_SIZE);\n-    map.truncate(start_bit, end_bit);\n-\n-    EXPECT_TRUE(map.is_same(result));\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateOneWord() {\n-    ResourceMark rm;\n-\n-    ResizableBitMapClass map(64);\n-    map.set_bit(0);\n-    map.set_bit(1);\n-    map.set_bit(2);\n-    map.set_bit(3);\n-\n-    ResizableBitMapClass result(2);\n-    result.set_bit(0);\n-    result.set_bit(1);\n-\n-    map.truncate(1, 3);\n-\n-    EXPECT_TRUE(map.is_same(result));\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateSame() {\n-    \/\/ Resulting map should be the same as the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(BITMAP_SIZE);\n-    fillBitMap(map, BITMAP_SIZE);\n-    testTruncate<ResizableBitMapClass>(0, BITMAP_SIZE, map);\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateStart() {\n-    \/\/ Resulting map should start at the beginning of the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(64);\n-    fillBitMap(map, 64);\n-    testTruncate<ResizableBitMapClass>(0, 64, map);\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateEnd() {\n-    \/\/ Resulting map should end at the end of the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(64);\n-    map.set_bit(0);\n-    map.set_bit(31);\n-    map.set_bit(63);\n-    testTruncate<ResizableBitMapClass>(64, 128, map);\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateMiddle() {\n-    \/\/ Resulting map should end at the end of the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(64);\n-    map.set_bit(31);\n-    map.set_bit(32);\n-    map.set_bit(63);\n-    testTruncate<ResizableBitMapClass>(32, 96, map);\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateStartUnaligned() {\n-    \/\/ Resulting map should start at the beginning of the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(96);\n-    fillBitMap(map, 96);\n-    testTruncate<ResizableBitMapClass>(0, 96, map);\n-  }\n-\n-  template <class ResizableBitMapClass>\n-  static void testTruncateEndUnaligned() {\n-    \/\/ Resulting map should end at the end of the original\n-    ResourceMark rm;\n-    ResizableBitMapClass map(97);\n-    map.set_bit(0);\n-    map.set_bit(32);\n-    map.set_bit(33);\n-    map.set_bit(64);\n-    map.set_bit(96);\n-    testTruncate<ResizableBitMapClass>(31, 128, map);\n-  }\n-};\n-\n-\/\/ TestArenaBitMap is the shorthand combination of Arena and ArenaBitMap.\n-\/\/ Multiple inheritance guarantees to construct Arena first.\n-class TestArenaBitMap : private Arena, public ArenaBitMap {\n- public:\n-  TestArenaBitMap() : TestArenaBitMap(0) {}\n-  TestArenaBitMap(idx_t size_in_bits, bool clear = true) : Arena(mtTest),\n-                                                           ArenaBitMap(static_cast<Arena*>(this), size_in_bits, clear) {}\n-};\n-\n-class TestCHeapBitMap : public CHeapBitMap {\n-public:\n-  TestCHeapBitMap(size_t size = 0) : CHeapBitMap(size, mtTest) {}\n-\n-};\n-\n-TEST_VM(BitMapTruncate, truncate_same) {\n-  BitMapTruncateTest::testTruncateSame<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateSame<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateSame<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_start) {\n-  BitMapTruncateTest::testTruncateStart<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateStart<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateStart<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_end) {\n-  BitMapTruncateTest::testTruncateEnd<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateEnd<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateEnd<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_middle) {\n-  BitMapTruncateTest::testTruncateMiddle<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateMiddle<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateMiddle<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_start_unaligned) {\n-  BitMapTruncateTest::testTruncateStartUnaligned<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateStartUnaligned<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateStartUnaligned<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_end_unaligned) {\n-  BitMapTruncateTest::testTruncateEndUnaligned<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateEndUnaligned<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateEndUnaligned<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n-\n-TEST_VM(BitMapTruncate, truncate_one_word) {\n-  BitMapTruncateTest::testTruncateOneWord<ResourceBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n-  BitMapTruncateTest::testTruncateOneWord<TestCHeapBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n-  BitMapTruncateTest::testTruncateOneWord<TestArenaBitMap>();\n-  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_truncate.cpp","additions":0,"deletions":215,"binary":false,"changes":215,"status":"deleted"}]}