{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,64 @@\n+template <class BitMapWithAllocator>\n+bm_word_t* GrowableBitMap<BitMapWithAllocator>::copy_of_range(idx_t start_bit, idx_t end_bit, bool clear) {\n+  assert(start_bit < end_bit, \"End bit must come after start bit\");\n+  assert(end_bit <= size(), \"End bit not in bitmap\");\n+\n+  \/\/ We might have extra bits at the end that we don't want to lose\n+  idx_t cutoff = bit_in_word(end_bit);\n+  idx_t start_word = to_words_align_down(start_bit);\n+  idx_t end_word = to_words_align_up(end_bit);\n+  bm_word_t* const old_map = map();\n+\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n+\n+  bm_word_t* new_map = derived->allocate(end_word - start_word);\n+\n+  \/\/ All words need to be shifted by this amount\n+  idx_t shift = bit_in_word(start_bit);\n+  \/\/ Bits shifted out by a word need to be passed into the next\n+  idx_t carry = 0;\n+\n+  \/\/ Iterate the map backwards as the shift will result in carry-out bits\n+  for (idx_t i = end_word; i --> start_word;) {\n+    \/\/ First iteration is a special case:\n+    \/\/ There may be left over bits in the last word that we want to keep while discarding the rest\n+    if (i == end_word - 1 && cutoff > 0) {\n+      bm_word_t mask = bit_mask(cutoff) - 1;\n+      new_map[i-start_word] = old_map[i] & mask >> shift;\n+    } else {\n+      new_map[i-start_word] = old_map[i] >> shift;\n+    }\n+    new_map[i-start_word] |= carry;\n+\n+    \/\/ A full shift by BitsPerWord could be sign extended\n+    carry = old_map[i] << (BitsPerWord - shift) % BitsPerWord;\n+  }\n+\n+  return new_map;\n+}\n+\n+template <class BitMapWithAllocator>\n+bm_word_t* GrowableBitMap<BitMapWithAllocator>::copy_of_range(idx_t start_bit, bool clear) {\n+  return copy_of_range(start_bit, size(), clear);\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::truncate(idx_t start_bit, idx_t end_bit, bool clear) {\n+  const size_t old_size_in_words = calc_size_in_words(size());\n+  const idx_t new_size_in_bits = end_bit - start_bit;\n+  bm_word_t* const old_map = map();\n+\n+  bm_word_t* new_map = copy_of_range(start_bit, end_bit, clear);\n+\n+  BitMapWithAllocator* derived = static_cast<BitMapWithAllocator*>(this);\n+  \/\/ Free and clear old map to avoid left over bits\n+  derived->free(old_map, old_size_in_words);\n+  update(nullptr, 0);\n+  update(new_map, new_size_in_bits);\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::truncate(idx_t start_bit, bool clear) {\n+  truncate(start_bit, size(), clear);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -569,0 +569,7 @@\n+ private:\n+  \/\/ Copy the region [start, end) of the bitmap\n+  \/\/ Bits in the selected range are copied to a newly allocated map\n+  bm_word_t* copy_of_range(idx_t start_bit, idx_t end_bit, bool clear = true);\n+  \/\/ Copy the region from the start bit to the end of the map\n+  bm_word_t* copy_of_range(idx_t start_bit, bool clear = true);\n+\n@@ -588,0 +595,5 @@\n+  \/\/ Reduce bitmap to the region [start, end)\n+  \/\/ Previous map is deallocated and replaced with the newly allocated map from copy_of_range\n+  void truncate(idx_t start_bit, idx_t end_bit, bool clear = true);\n+  \/\/ Truncate from the start bit to the end of the map\n+  void truncate(idx_t start_bit, bool clear = true);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+class BitMapTruncateTest {\n+\n+ public:\n+  const static BitMap::idx_t BITMAP_SIZE = 128;\n+\n+  template <class ResizableBitMapClass>\n+  static void fillBitMap(ResizableBitMapClass& map,  BitMap::idx_t size) {\n+    BitMap::idx_t set_bits[] = {0, 31, 63, 64, 95, 127};\n+    for (BitMap::idx_t bit : set_bits) {\n+        if (bit < size) {\n+            map.set_bit(bit);\n+        }\n+    }\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncate(BitMap::idx_t start_bit, BitMap::idx_t end_bit, ResizableBitMapClass& result) {\n+    ResourceMark rm;\n+\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    map.truncate(start_bit, end_bit);\n+\n+    EXPECT_TRUE(map.is_same(result));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateOneWord() {\n+    ResourceMark rm;\n+\n+    ResizableBitMapClass map(64);\n+    map.set_bit(0);\n+    map.set_bit(1);\n+    map.set_bit(2);\n+    map.set_bit(3);\n+\n+    ResizableBitMapClass result(2);\n+    result.set_bit(0);\n+    result.set_bit(1);\n+\n+    map.truncate(1, 3, true);\n+\n+    EXPECT_TRUE(map.is_same(result));\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateSame() {\n+    \/\/ Resulting map should be the same as the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(BITMAP_SIZE);\n+    fillBitMap(map, BITMAP_SIZE);\n+    testTruncate<ResizableBitMapClass>(0, BITMAP_SIZE, map);\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStart() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(64);\n+    fillBitMap(map, 64);\n+    testTruncate<ResizableBitMapClass>(0, 64, map);\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEnd() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(64);\n+    map.set_bit(0);\n+    map.set_bit(31);\n+    map.set_bit(63);\n+    testTruncate<ResizableBitMapClass>(64, 128, map);\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateMiddle() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(64);\n+    map.set_bit(31);\n+    map.set_bit(32);\n+    map.set_bit(63);\n+    testTruncate<ResizableBitMapClass>(32, 96, map);\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateStartUnaligned() {\n+    \/\/ Resulting map should start at the beginning of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(96);\n+    fillBitMap(map, 96);\n+    testTruncate<ResizableBitMapClass>(0, 96, map);\n+  }\n+\n+  template <class ResizableBitMapClass>\n+  static void testTruncateEndUnaligned() {\n+    \/\/ Resulting map should end at the end of the original\n+    ResourceMark rm;\n+    ResizableBitMapClass map(97);\n+    map.set_bit(0);\n+    map.set_bit(32);\n+    map.set_bit(33);\n+    map.set_bit(64);\n+    map.set_bit(96);\n+    testTruncate<ResizableBitMapClass>(31, 128, map);\n+  }\n+};\n+\n+\/\/ TestArenaBitMap is the shorthand combination of Arena and ArenaBitMap.\n+\/\/ Multiple inheritance guarantees to construct Arena first.\n+class TestArenaBitMap : private Arena, public ArenaBitMap {\n+ public:\n+  TestArenaBitMap() : TestArenaBitMap(0) {}\n+  TestArenaBitMap(idx_t size_in_bits, bool clear = true) : Arena(mtTest),\n+                                                           ArenaBitMap(static_cast<Arena*>(this), size_in_bits, clear) {}\n+};\n+\n+class TestCHeapBitMap : public CHeapBitMap {\n+public:\n+  TestCHeapBitMap(size_t size = 0) : CHeapBitMap(size, mtTest) {}\n+\n+};\n+\n+TEST_VM(BitMapTruncate, truncate_same) {\n+  BitMapTruncateTest::testTruncateSame<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateSame<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_start) {\n+  BitMapTruncateTest::testTruncateStart<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStart<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_end) {\n+  BitMapTruncateTest::testTruncateEnd<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEnd<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_middle) {\n+  BitMapTruncateTest::testTruncateMiddle<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateMiddle<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_start_unaligned) {\n+  BitMapTruncateTest::testTruncateStartUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateStartUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_end_unaligned) {\n+  BitMapTruncateTest::testTruncateEndUnaligned<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateEndUnaligned<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n+\n+TEST_VM(BitMapTruncate, truncate_one_word) {\n+  BitMapTruncateTest::testTruncateOneWord<ResourceBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ResourceBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestCHeapBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type CHeapBitMap\";\n+  BitMapTruncateTest::testTruncateOneWord<TestArenaBitMap>();\n+  EXPECT_FALSE(HasFailure()) << \"Failed on type ArenaBitMap\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_truncate.cpp","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}