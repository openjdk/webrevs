{"files":[{"patch":"@@ -2072,3 +2072,9 @@\n-Node* ReverseINode::Identity(PhaseGVN* phase) {\n-  if (in(1)->Opcode() == Op_ReverseI) {\n-    return in(1)->in(1);\n+static Node* simplify_involution(PhaseGVN* phase, Node* involution) {\n+  if (involution->in(1)->Opcode() == involution->Opcode()) {\n+    Node* original = involution->in(1)->in(1);\n+    const TypeInt *type = phase->type(original)->isa_int();\n+    \/\/ Operations on sub-int types might not be \"real\" involutions for values outside their type range.\n+    \/\/ Make sure not to drop potential truncations.\n+    if (type == nullptr || involution->bottom_type()->is_int()->contains(type)) {\n+      return involution->in(1)->in(1);\n+    }\n@@ -2076,1 +2082,13 @@\n-  return this;\n+  return involution;\n+}\n+\n+Node* NegNode::Identity(PhaseGVN* phase) {\n+  return simplify_involution(phase, this);\n+}\n+\n+Node* ReverseBytesNode::Identity(PhaseGVN* phase) {\n+  return simplify_involution(phase, this);\n+}\n+\n+Node* ReverseINode::Identity(PhaseGVN* phase) {\n+  return simplify_involution(phase, this);\n@@ -2080,4 +2098,1 @@\n-  if (in(1)->Opcode() == Op_ReverseL) {\n-    return in(1)->in(1);\n-  }\n-  return this;\n+  return simplify_involution(phase, this);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -562,0 +563,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8350988 8364407\n+ * @summary Test that Identity simplifications of Involution nodes are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @compile ReverseBytesConstantsHelper.jasm\n+ * @run driver compiler.c2.gvn.InvolutionIdentityTests\n+ *\/\n+public class InvolutionIdentityTests {\n+\n+    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=inline,compiler.c2.gvn.ReverseBytesConstantsHelper::*\");\n+    }\n+\n+    @Run(test = {\n+        \"testI1\", \"testI2\",\n+        \"testL1\", \"testL2\",\n+        \"testS1\", \"testS2\",\n+        \"testUS1\", \"testUS2\",\n+        \"testF1\",\n+        \"testD1\"\n+    })\n+    public void runMethod() {\n+        int ai = GEN_INT.next();\n+\n+        int mini = Integer.MIN_VALUE;\n+        int maxi = Integer.MAX_VALUE;\n+\n+        assertResultI(0);\n+        assertResultI(ai);\n+        assertResultI(mini);\n+        assertResultI(maxi);\n+\n+        long al = GEN_LONG.next();\n+\n+        long minl = Long.MIN_VALUE;\n+        long maxl = Long.MAX_VALUE;\n+\n+        assertResultL(0);\n+        assertResultL(al);\n+        assertResultL(minl);\n+        assertResultL(maxl);\n+\n+        short as = GEN_SHORT.next().shortValue();\n+\n+        short mins = Short.MIN_VALUE;\n+        short maxs = Short.MAX_VALUE;\n+\n+        assertResultS((short) 0);\n+        assertResultS(as);\n+        assertResultS(mins);\n+        assertResultS(maxs);\n+\n+        char ac = (char) GEN_CHAR.next().intValue();\n+\n+        char minc = Character.MIN_VALUE;\n+        char maxc = Character.MAX_VALUE;\n+\n+        assertResultUS((char) 0);\n+        assertResultUS(ac);\n+        assertResultUS(minc);\n+        assertResultUS(maxc);\n+\n+        \/\/ short and char variants but passing an int\n+        assertResultTruncating(0);\n+        assertResultTruncating(ai);\n+        assertResultTruncating(mini);\n+        assertResultTruncating(maxi);\n+\n+        float af = GEN_FLOAT.next();\n+        float inf = Float.POSITIVE_INFINITY;\n+        float nanf = Float.NaN;\n+\n+        assertResultF(0f);\n+        assertResultF(-0f);\n+        assertResultF(af);\n+        assertResultF(inf);\n+        assertResultF(nanf);\n+\n+        double ad = GEN_DOUBLE.next();\n+        double ind = Double.POSITIVE_INFINITY;\n+        double nand = Double.NaN;\n+\n+        assertResultD(0d);\n+        assertResultD(-0d);\n+        assertResultD(ad);\n+        assertResultD(ind);\n+        assertResultD(nand);\n+\n+    }\n+\n+    @DontCompile\n+    public void assertResultI(int a) {\n+        Asserts.assertEQ(Integer.reverseBytes(Integer.reverseBytes(a)), testI1(a));\n+        Asserts.assertEQ(Integer.reverse(Integer.reverse(a))          , testI2(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultL(long a) {\n+        Asserts.assertEQ(Long.reverseBytes(Long.reverseBytes(a)), testL1(a));\n+        Asserts.assertEQ(Long.reverse(Long.reverse(a))          , testL2(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultS(short a) {\n+        Asserts.assertEQ(Short.reverseBytes(Short.reverseBytes(a)), testS1(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultUS(char a) {\n+        Asserts.assertEQ(Character.reverseBytes(Character.reverseBytes(a)), testUS1(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultF(float a) {\n+        Asserts.assertEQ(Float.floatToRawIntBits(-(-a)), Float.floatToRawIntBits(testF1(a)));\n+    }\n+\n+    @DontCompile\n+    public void assertResultD(double a) {\n+        Asserts.assertEQ(Double.doubleToRawLongBits(-(-a)), Double.doubleToRawLongBits(testD1(a)));\n+    }\n+\n+    @DontCompile\n+    public void assertResultTruncating(int a) {\n+        Asserts.assertEQ((int) Short.reverseBytes(    ReverseBytesConstantsHelper.reverseBytesShort(a)), testS2( a));\n+        Asserts.assertEQ((int) Character.reverseBytes(ReverseBytesConstantsHelper.reverseBytesChar( a)), testUS2(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_I})\n+    public int testI1(int x) {\n+        return Integer.reverseBytes(Integer.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_I})\n+    public int testI2(int x) {\n+        return Integer.reverse(Integer.reverse(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_L})\n+    public long testL1(long x) {\n+        return Long.reverseBytes(Long.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_L})\n+    public long testL2(long x) {\n+        return Long.reverse(Long.reverse(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_S})\n+    public short testS1(short x) {\n+        \/\/ explicit cast to restrict the input to TypeInt::SHORT\n+        return Short.reverseBytes(Short.reverseBytes((short) (int) x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_US})\n+    public char testUS1(char x) {\n+        \/\/ explicit cast to restrict the input to TypeInt::CHAR\n+        return Character.reverseBytes(Character.reverseBytes((char) (int) x));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REVERSE_BYTES_S, \"2\"})\n+    public int testS2(int x) {\n+        return Short.reverseBytes(ReverseBytesConstantsHelper.reverseBytesShort(x));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REVERSE_BYTES_US, \"2\"})\n+    public int testUS2(int x) {\n+        return Character.reverseBytes(ReverseBytesConstantsHelper.reverseBytesChar(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.NEG_F})\n+    public float testF1(float x) {\n+        return -(-x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.NEG_D})\n+    public double testD1(double x) {\n+        return -(-x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/InvolutionIdentityTests.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -1516,0 +1516,10 @@\n+    public static final String NEG_F = PREFIX + \"NEG_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_F, \"NegF\");\n+    }\n+\n+    public static final String NEG_D = PREFIX + \"NEG_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_D, \"NegD\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}