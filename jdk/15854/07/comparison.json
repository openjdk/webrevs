{"files":[{"patch":"@@ -477,6 +477,1 @@\n-             VarHandleByteArrayAsChars.ByteArrayViewVarHandle,\n-             VarHandleByteArrayAsDoubles.ByteArrayViewVarHandle,\n-             VarHandleByteArrayAsFloats.ByteArrayViewVarHandle,\n-             VarHandleByteArrayAsInts.ByteArrayViewVarHandle,\n-             VarHandleByteArrayAsLongs.ByteArrayViewVarHandle,\n-             VarHandleByteArrayAsShorts.ByteArrayViewVarHandle,\n+             VarHandleByteArrayBase,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,8 @@\n-import java.nio.Buffer;\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n@@ -36,4 +43,15 @@\n-abstract class VarHandleByteArrayBase {\n-    \/\/ Buffer.address\n-    static final long BUFFER_ADDRESS\n-            = UNSAFE.objectFieldOffset(Buffer.class, \"address\");\n+abstract sealed class VarHandleByteArrayBase extends VarHandle\n+    permits VarHandleByteArrayAsChars.ArrayHandle,\n+            VarHandleByteArrayAsChars.ByteBufferHandle,\n+            VarHandleByteArrayAsDoubles.ArrayHandle,\n+            VarHandleByteArrayAsDoubles.ByteBufferHandle,\n+            VarHandleByteArrayAsFloats.ArrayHandle,\n+            VarHandleByteArrayAsFloats.ByteBufferHandle,\n+            VarHandleByteArrayAsInts.ArrayHandle,\n+            VarHandleByteArrayAsInts.ByteBufferHandle,\n+            VarHandleByteArrayAsLongs.ArrayHandle,\n+            VarHandleByteArrayAsLongs.ByteBufferHandle,\n+            VarHandleByteArrayAsShorts.ArrayHandle,\n+            VarHandleByteArrayAsShorts.ByteBufferHandle {\n+\n+    static final boolean BE = UNSAFE.isBigEndian();\n@@ -41,3 +59,1 @@\n-    \/\/ Buffer.limit\n-    static final long BUFFER_LIMIT\n-            = UNSAFE.objectFieldOffset(Buffer.class, \"limit\");\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -45,3 +61,1 @@\n-    \/\/ ByteBuffer.hb\n-    static final long BYTE_BUFFER_HB\n-            = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -49,3 +63,1 @@\n-    \/\/ ByteBuffer.isReadOnly\n-    static final long BYTE_BUFFER_IS_READ_ONLY\n-            = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n+    final boolean be;\n@@ -53,1 +65,11 @@\n-    static final boolean BE = UNSAFE.isBigEndian();\n+    VarHandleByteArrayBase(VarForm form, boolean be, boolean exact) {\n+        super(form, exact);\n+        this.be = be;\n+    }\n+\n+    @ForceInline\n+    static MemorySessionImpl session(ByteBuffer bb) {\n+        MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n+        return segment != null ?\n+                ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleByteArrayBase.java","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -29,0 +30,6 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Objects;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -42,0 +49,4 @@\n+    static final boolean BE = UNSAFE.isBigEndian();\n+\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -58,0 +69,18 @@\n+    @ForceInline\n+    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl) Objects.requireNonNull(obb);\n+        oo.checkAccess(offset, length, ro);\n+        return oo;\n+    }\n+\n+    @ForceInline\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        long base = bb.unsafeGetOffset();\n+        long address = base + offset;\n+        long maxAlignMask = bb.maxAlignMask();\n+        if (((address | maxAlignMask) & alignmentMask) != 0) {\n+            throw newIllegalArgumentExceptionForMisalignedAccess(address);\n+        }\n+        return address;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n@@ -50,7 +48,0 @@\n-    static ClassValue<ConcurrentMap<Integer, MethodHandle>> ADDRESS_FACTORIES = new ClassValue<>() {\n-        @Override\n-        protected ConcurrentMap<Integer, MethodHandle> computeValue(Class<?> type) {\n-            return new ConcurrentHashMap<>();\n-        }\n-    };\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.invoke.VarHandle.VarHandleDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -36,1 +31,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -39,1 +33,0 @@\n-import java.util.List;\n@@ -41,1 +34,0 @@\n-import java.util.function.BiFunction;\n@@ -47,3 +39,1 @@\n-final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {\n-\n-    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+final class VarHandleByteArrayAs$Type$s {\n@@ -52,2 +42,0 @@\n-    \n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -59,1 +47,1 @@\n-        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+        return big == VarHandleByteArrayBase.BE ? rv : $RawBoxType$.reverseBytes(rv);\n@@ -64,1 +52,1 @@\n-        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+        rv = big == VarHandleByteArrayBase.BE ? rv : $RawBoxType$.reverseBytes(rv);\n@@ -70,1 +58,1 @@\n-        return big == BE ? n : $BoxType$.reverseBytes(n);\n+        return big == VarHandleByteArrayBase.BE ? n : $BoxType$.reverseBytes(n);\n@@ -74,11 +62,1 @@\n-\n-    static abstract sealed class ByteArrayViewVarHandle extends VarHandle {\n-        final boolean be;\n-\n-        ByteArrayViewVarHandle(VarForm form, boolean be, boolean exact) {\n-            super(form, exact);\n-            this.be = be;\n-        }\n-    }\n-\n-    static final class ArrayHandle extends ByteArrayViewVarHandle {\n+    static final class ArrayHandle extends VarHandleByteArrayBase {\n@@ -580,1 +558,1 @@\n-    static final class ByteBufferHandle extends ByteArrayViewVarHandle {\n+    static final class ByteBufferHandle extends VarHandleByteArrayBase {\n@@ -611,9 +589,1 @@\n-            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n-            return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);\n-        }\n-\n-        @ForceInline\n-        static MemorySessionImpl session(ByteBuffer bb) {\n-            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n-            return segment != null ?\n-                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n+            return Preconditions.checkIndex(index, bb.limit() - ALIGN, null);\n@@ -624,1 +594,1 @@\n-            if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))\n+            if (bb.isReadOnly())\n@@ -631,1 +601,1 @@\n-            long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);\n+            long address = ((long) index) + NIO_ACCESS.getBufferAddress(bb);\n@@ -643,2 +613,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) index(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -649,2 +619,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) index(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -661,2 +631,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) indexRO(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -667,2 +637,2 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n-                    ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),\n+                    NIO_ACCESS.getBufferBase(bb),\n+                    ((long) indexRO(bb, index)) + NIO_ACCESS.getBufferAddress(bb),\n@@ -680,1 +650,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -689,1 +659,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -700,1 +670,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -709,1 +679,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -720,1 +690,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -729,1 +699,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -741,1 +711,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -746,1 +716,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -758,1 +728,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -769,1 +739,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -780,1 +750,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -790,1 +760,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -800,1 +770,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -810,1 +780,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -820,1 +790,1 @@\n-                    UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                    NIO_ACCESS.getBufferBase(bb),\n@@ -832,1 +802,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -838,1 +808,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -850,1 +820,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -861,1 +831,1 @@\n-                                      UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                                      NIO_ACCESS.getBufferBase(bb),\n@@ -874,1 +844,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -888,1 +858,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -902,1 +872,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -913,1 +883,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -931,1 +901,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -945,1 +915,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -959,1 +929,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -970,1 +940,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -986,1 +956,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1000,1 +970,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1014,1 +984,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1025,1 +995,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n@@ -1042,1 +1012,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1056,1 +1026,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1070,1 +1040,1 @@\n-                        UNSAFE.getReference(bb, BYTE_BUFFER_HB),\n+                        NIO_ACCESS.getBufferBase(bb),\n@@ -1081,1 +1051,1 @@\n-            Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n+            Object base = NIO_ACCESS.getBufferBase(bb);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":53,"deletions":83,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,5 +31,0 @@\n-import java.lang.ref.Reference;\n-\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -42,4 +36,0 @@\n-    static final boolean BE = UNSAFE.isBigEndian();\n-\n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n@@ -99,7 +89,0 @@\n-    @ForceInline\n-    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n-        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n-        oo.checkAccess(offset, length, ro);\n-        return oo;\n-    }\n-\n@@ -114,11 +97,0 @@\n-    @ForceInline\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long base = bb.unsafeGetOffset();\n-        long address = base + offset;\n-        long maxAlignMask = bb.maxAlignMask();\n-        if (((address | maxAlignMask) & alignmentMask) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"}]}