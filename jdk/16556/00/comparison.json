{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.jimage.decompressor.ResourceDecompressor;\n@@ -347,0 +348,17 @@\n+    int getStringMUTF8(int offset, byte[] bytesOut, int bytesOutOffset) {\n+        if (offset < 0 || offset >= strings.limit()) {\n+            throw new IndexOutOfBoundsException(\"offset\");\n+        }\n+\n+        for (int i = 0, end = strings.limit() - offset; i < end; i++) {\n+            byte b = strings.get(offset + i);\n+            if (b == 0) {\n+                return i;\n+            } else {\n+                bytesOut[bytesOutOffset + i] = b;\n+            }\n+        }\n+\n+        throw new InternalError(\"No terminating zero byte for modified UTF-8 byte sequence\");\n+    }\n+\n@@ -449,1 +467,11 @@\n-                            (int strOffset) -> getString(strOffset), bytesIn);\n+                            new ResourceDecompressor.StringsProvider() {\n+                                @Override\n+                                public String getString(int strOffset) {\n+                                    return BasicImageReader.this.getString(strOffset);\n+                                }\n+\n+                                @Override\n+                                public int getStringMUTF8(int offset, byte[] bytesOut, int bytesOutOffset) {\n+                                    return BasicImageReader.this.getStringMUTF8(offset, bytesOut, bytesOutOffset);\n+                                }\n+                            }, bytesIn);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.io.DataInputStream;\n@@ -30,2 +29,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Arrays;\n@@ -49,2 +47,2 @@\n-    public static List<Integer> decompressFlow(byte[] values) {\n-        List<Integer> lst = new ArrayList<>();\n+    public static int[] decompressFlow(byte[] values) {\n+        int[] ints = new int[values.length];\n@@ -52,0 +50,1 @@\n+        int count = 0;\n@@ -54,1 +53,1 @@\n-            lst.add(decompressed);\n+            ints[count++] = decompressed;\n@@ -57,1 +56,1 @@\n-        return lst;\n+        return count == ints.length ? ints : Arrays.copyOf(ints, count);\n@@ -60,1 +59,1 @@\n-    public static int readInt(DataInputStream cr) throws IOException {\n+    public static int readInt(ByteBuffer cr) throws IOException {\n@@ -62,1 +61,1 @@\n-        byte header = cr.readByte();\n+        byte header = cr.get();\n@@ -72,1 +71,1 @@\n-            result |= cr.readByte() & 0xFF;\n+            result |= cr.get() & 0xFF;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/CompressIndexes.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.ImageStringsReader;\n+\n@@ -39,2 +41,8 @@\n-    public interface StringsProvider {\n-        public String getString(int offset);\n+    interface StringsProvider {\n+        String getString(int offset);\n+\n+        default int getStringMUTF8(int offset, byte[] bytesOut, int bytesOutOffset) {\n+            byte[] bytes = ImageStringsReader.mutf8FromString(getString(offset));\n+            System.arraycopy(bytes, 0, bytesOut, bytesOutOffset, bytes.length);\n+            return bytes.length;\n+        }\n@@ -46,1 +54,1 @@\n-    public String getName();\n+    String getName();\n@@ -57,1 +65,1 @@\n-    public byte[] decompress(StringsProvider strings, byte[] content, int offset,\n+    byte[] decompress(StringsProvider strings, byte[] content, int offset,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ResourceDecompressor.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,2 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n+import jdk.internal.jimage.ImageStringsReader;\n+\n@@ -33,3 +31,0 @@\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-import java.util.List;\n@@ -39,1 +34,0 @@\n- *\n@@ -98,10 +92,19 @@\n-            int offset) throws IOException {\n-        DataInputStream stream = new DataInputStream(new ByteArrayInputStream(transformed,\n-                offset, transformed.length - offset));\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream(transformed.length);\n-        DataOutputStream out = new DataOutputStream(outStream);\n-        byte[] header = new byte[8]; \/\/maginc\/4, minor\/2, major\/2\n-        stream.readFully(header);\n-        out.write(header);\n-        int count = stream.readUnsignedShort();\n-        out.writeShort(count);\n+                                   int offset, long originalSize) throws IOException {\n+        if (originalSize > Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required array size too large\");\n+        }\n+\n+        byte[] bytesOut = new byte[(int) originalSize];\n+        int bytesOutOffset = 0;\n+\n+        \/\/ maginc\/4, minor\/2, major\/2\n+        final int headerSize = 8;\n+\n+        System.arraycopy(transformed, offset, bytesOut, bytesOutOffset, headerSize);\n+        bytesOutOffset += headerSize;\n+\n+        ByteBuffer bytesIn = ByteBuffer.wrap(transformed);\n+        bytesIn.position(offset + headerSize);\n+        int count = Short.toUnsignedInt(bytesIn.getShort());\n+        bytesOut[bytesOutOffset++] = (byte) ((count >> 8) & 0xff);\n+        bytesOut[bytesOutOffset++] = (byte) (count & 0xff);\n@@ -109,2 +112,1 @@\n-            int tag = stream.readUnsignedByte();\n-            byte[] arr;\n+            int tag = Byte.toUnsignedInt(bytesIn.get());\n@@ -113,3 +115,6 @@\n-                    out.write(tag);\n-                    String utf = stream.readUTF();\n-                    out.writeUTF(utf);\n+                    bytesOut[bytesOutOffset++] = (byte) tag;\n+                    int stringLength = Short.toUnsignedInt(bytesIn.getShort());\n+                    bytesOut[bytesOutOffset++] = (byte) ((stringLength >> 8) & 0xff);\n+                    bytesOut[bytesOutOffset++] = (byte) (stringLength & 0xff);\n+                    bytesIn.get(bytesOut, bytesOutOffset, stringLength);\n+                    bytesOutOffset += stringLength;\n@@ -120,4 +125,6 @@\n-                    int index = CompressIndexes.readInt(stream);\n-                    String orig = provider.getString(index);\n-                    out.write(CONSTANT_Utf8);\n-                    out.writeUTF(orig);\n+                    bytesOut[bytesOutOffset++] = CONSTANT_Utf8;\n+                    int index = CompressIndexes.readInt(bytesIn);\n+                    int bytesLength = provider.getStringMUTF8(index, bytesOut, bytesOutOffset + 2);\n+                    bytesOut[bytesOutOffset++] = (byte) ((bytesLength >> 8) & 0xff);\n+                    bytesOut[bytesOutOffset++] = (byte) (bytesLength & 0xff);\n+                    bytesOutOffset += bytesLength;\n@@ -128,3 +135,2 @@\n-                    String orig = reconstruct(provider, stream);\n-                    out.write(CONSTANT_Utf8);\n-                    out.writeUTF(orig);\n+                    bytesOut[bytesOutOffset++] = CONSTANT_Utf8;\n+                    bytesOutOffset += reconstruct(provider, bytesIn, bytesOut, bytesOutOffset);\n@@ -138,1 +144,1 @@\n-                    out.write(tag);\n+                    bytesOut[bytesOutOffset++] = (byte) tag;\n@@ -140,3 +146,2 @@\n-                    arr = new byte[size];\n-                    stream.readFully(arr);\n-                    out.write(arr);\n+                    bytesIn.get(bytesOut, bytesOutOffset, size);\n+                    bytesOutOffset += size;\n@@ -146,3 +151,0 @@\n-        out.write(transformed, transformed.length - stream.available(),\n-                stream.available());\n-        out.flush();\n@@ -150,1 +152,6 @@\n-        return outStream.toByteArray();\n+        if (bytesIn.remaining() != bytesOut.length - bytesOutOffset) {\n+            throw new IOException(\"Resource content size mismatch\");\n+        }\n+\n+        bytesIn.get(bytesOut, bytesOutOffset, bytesIn.remaining());\n+        return bytesOut;\n@@ -153,1 +160,1 @@\n-    private static String reconstruct(StringsProvider reader, DataInputStream cr)\n+    private static int reconstruct(StringsProvider reader, ByteBuffer bytesIn, byte[] bytesOut, int bytesOutOffset)\n@@ -155,1 +162,1 @@\n-        int descIndex = CompressIndexes.readInt(cr);\n+        int descIndex = CompressIndexes.readInt(bytesIn);\n@@ -157,2 +164,2 @@\n-        byte[] encodedDesc = getEncoded(desc);\n-        int indexes_length = CompressIndexes.readInt(cr);\n+        byte[] encodedDesc = ImageStringsReader.mutf8FromString(desc);\n+        int indexes_length = CompressIndexes.readInt(bytesIn);\n@@ -160,4 +167,2 @@\n-        cr.readFully(bytes);\n-        List<Integer> indices = CompressIndexes.decompressFlow(bytes);\n-        ByteBuffer buffer = ByteBuffer.allocate(encodedDesc.length * 2);\n-        buffer.order(ByteOrder.BIG_ENDIAN);\n+        bytesIn.get(bytes);\n+        int[] indices = CompressIndexes.decompressFlow(bytes);\n@@ -165,0 +170,1 @@\n+        int current = bytesOutOffset + 2;\n@@ -167,2 +173,2 @@\n-                buffer = safeAdd(buffer, c);\n-                int index = indices.get(argIndex);\n+                bytesOut[current++] = c;\n+                int index = indices[argIndex];\n@@ -170,5 +176,4 @@\n-                String pkg = reader.getString(index);\n-                if (!pkg.isEmpty()) {\n-                    pkg = pkg + \"\/\";\n-                    byte[] encoded = getEncoded(pkg);\n-                    buffer = safeAdd(buffer, encoded);\n+                int pkgLen = reader.getStringMUTF8(index, bytesOut, current);\n+                if (pkgLen > 0) {\n+                    current += pkgLen;\n+                    bytesOut[current++] = '\/';\n@@ -176,1 +181,1 @@\n-                int classIndex = indices.get(argIndex);\n+                int classIndex = indices[argIndex];\n@@ -178,3 +183,1 @@\n-                String clazz = reader.getString(classIndex);\n-                byte[] encoded = getEncoded(clazz);\n-                buffer = safeAdd(buffer, encoded);\n+                current += reader.getStringMUTF8(classIndex, bytesOut, current);\n@@ -182,1 +185,1 @@\n-                buffer = safeAdd(buffer, c);\n+                bytesOut[current++] = c;\n@@ -185,39 +188,4 @@\n-\n-        byte[] encoded = buffer.array();\n-        ByteBuffer result = ByteBuffer.allocate(encoded.length + 2);\n-        result.order(ByteOrder.BIG_ENDIAN);\n-        result.putShort((short) buffer.position());\n-        result.put(encoded, 0, buffer.position());\n-        ByteArrayInputStream stream = new ByteArrayInputStream(result.array());\n-        DataInputStream inStream = new DataInputStream(stream);\n-        String str = inStream.readUTF();\n-        return str;\n-    }\n-\n-    public static byte[] getEncoded(String pre) throws IOException {\n-        ByteArrayOutputStream resultStream = new ByteArrayOutputStream();\n-        DataOutputStream resultOut = new DataOutputStream(resultStream);\n-        resultOut.writeUTF(pre);\n-        byte[] content = resultStream.toByteArray();\n-        \/\/ first 2 items are length;\n-        if (content.length <= 2) {\n-            return new byte[0];\n-        }\n-        return Arrays.copyOfRange(content, 2, content.length);\n-    }\n-\n-    private static ByteBuffer safeAdd(ByteBuffer current, byte b) {\n-        byte[] bytes = {b};\n-        return safeAdd(current, bytes);\n-    }\n-\n-    private static ByteBuffer safeAdd(ByteBuffer current, byte[] bytes) {\n-        if (current.remaining() < bytes.length) {\n-            ByteBuffer newBuffer = ByteBuffer.allocate((current.capacity()\n-                    + bytes.length) * 2);\n-            newBuffer.order(ByteOrder.BIG_ENDIAN);\n-            newBuffer.put(current.array(), 0, current.position());\n-            current = newBuffer;\n-        }\n-        current.put(bytes);\n-        return current;\n+        int stringLength = current - bytesOutOffset - 2;\n+        bytesOut[bytesOutOffset] = (byte) ((stringLength >> 8) & 0xff);\n+        bytesOut[bytesOutOffset + 1] = (byte) (stringLength & 0xff);\n+        return stringLength + 2;\n@@ -237,2 +205,2 @@\n-            int offset, long originalSize) throws Exception {\n-        return normalize(reader, content, offset);\n+                             int offset, long originalSize) throws Exception {\n+        return normalize(reader, content, offset, originalSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/StringSharingDecompressor.java","additions":68,"deletions":100,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -47,1 +48,6 @@\n-    static byte[] decompress(byte[] bytesIn, int offset) throws Exception {\n+    static byte[] decompress(byte[] bytesIn, int offset, long originalSize) throws Exception {\n+        if (originalSize > Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required array size too large\");\n+        }\n+        byte[] bytesOut = new byte[(int) originalSize];\n+\n@@ -50,2 +56,0 @@\n-        ByteArrayOutputStream stream = new ByteArrayOutputStream(bytesIn.length - offset);\n-        byte[] buffer = new byte[1024];\n@@ -53,3 +57,3 @@\n-        while (!inflater.finished()) {\n-            int count = inflater.inflate(buffer);\n-            stream.write(buffer, 0, count);\n+        int count = 0;\n+        while (!inflater.finished() && count < originalSize) {\n+            count += inflater.inflate(bytesOut, count, bytesOut.length - count);\n@@ -58,3 +62,0 @@\n-        stream.close();\n-\n-        byte[] bytesOut = stream.toByteArray();\n@@ -63,0 +64,4 @@\n+        if (count != originalSize) {\n+            throw new IOException(\"Resource content size mismatch\");\n+        }\n+\n@@ -69,1 +74,1 @@\n-        byte[] decompressed = decompress(content, offset);\n+        byte[] decompressed = decompress(content, offset, originalSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/decompressor\/ZipDecompressor.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -86,8 +87,7 @@\n-        try (DataInputStream is = new DataInputStream(new ByteArrayInputStream(flow))) {\n-            int index = 0;\n-            while (is.available() > 0) {\n-                int d = CompressIndexes.readInt(is);\n-                if (data[index] != d) {\n-                    throw new AssertionError(\"Expected: \" + data[index] + \", got: \" + d);\n-                }\n-                ++index;\n+\n+        ByteBuffer bf = ByteBuffer.wrap(flow);\n+        int index = 0;\n+        while (bf.hasRemaining()) {\n+            int d = CompressIndexes.readInt(bf);\n+            if (data[index] != d) {\n+                throw new AssertionError(\"Expected: \" + data[index] + \", got: \" + d);\n@@ -95,0 +95,1 @@\n+            ++index;\n@@ -99,1 +100,1 @@\n-        List<Integer> d = CompressIndexes.decompressFlow(flow);\n+        List<Integer> d = Arrays.stream(CompressIndexes.decompressFlow(flow)).boxed().toList();\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompressIndexesTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,2 @@\n-                        CompressedResourceHeader.getSize());\n+                        CompressedResourceHeader.getSize(),\n+                        ((ResourcePoolManager.CompressedModuleData) res).getUncompressedSize());\n","filename":"test\/jdk\/tools\/jlink\/plugins\/StringSharingPluginTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}