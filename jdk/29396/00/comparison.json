{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -36,6 +36,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,1 +42,1 @@\n- * @run testng ClassDescTest\n+ * @run junit ClassDescTest\n@@ -50,1 +45,0 @@\n-@Test\n@@ -76,1 +70,1 @@\n-            assertEquals(r.packageName(), \"\");\n+            assertEquals(\"\", r.packageName());\n@@ -100,3 +94,3 @@\n-        assertEquals(r.resolveConstantDesc(LOOKUP), c);\n-        assertEquals(c.describeConstable().orElseThrow(), r);\n-        assertEquals(ClassDesc.ofDescriptor(c.descriptorString()), r);\n+        assertEquals(c, r.resolveConstantDesc(LOOKUP));\n+        assertEquals(r, c.describeConstable().orElseThrow());\n+        assertEquals(r, ClassDesc.ofDescriptor(c.descriptorString()));\n@@ -107,1 +101,1 @@\n-            assertEquals(r.packageName(), c.getPackageName());\n+            assertEquals(c.getPackageName(), r.packageName());\n@@ -109,1 +103,1 @@\n-        assertEquals(r.displayName(), classDisplayName(c));\n+        assertEquals(classDisplayName(c), r.displayName());\n@@ -112,0 +106,1 @@\n+    @Test\n@@ -135,0 +130,1 @@\n+    @Test\n@@ -143,3 +139,3 @@\n-                assertEquals(p.descriptor, c.descriptorString());\n-                assertEquals(p.name, c.displayName());\n-                descs.forEach(cc -> assertEquals(c, cc));\n+                assertEquals(c.descriptorString(), p.descriptor);\n+                assertEquals(c.displayName(), p.name);\n+                descs.forEach(cc -> assertEquals(cc, c));\n@@ -148,2 +144,2 @@\n-                    assertEquals(c, p.arrayClass.describeConstable().orElseThrow().componentType());\n-                    assertEquals(c, p.classDesc.arrayType().componentType());\n+                    assertEquals(p.arrayClass.describeConstable().orElseThrow().componentType(), c);\n+                    assertEquals(p.classDesc.arrayType().componentType(), c);\n@@ -156,1 +152,1 @@\n-                    descs.forEach(c -> assertNotEquals(c, otherDescr));\n+                    descs.forEach(c -> assertNotEquals(otherDescr, c));\n@@ -158,1 +154,1 @@\n-                    descs.forEach(c -> assertEquals(c, otherDescr));\n+                    descs.forEach(c -> assertEquals(otherDescr, c));\n@@ -163,0 +159,1 @@\n+    @Test\n@@ -178,1 +175,1 @@\n-            stringClassDescs.forEach(rr -> assertEquals(r, rr));\n+            stringClassDescs.forEach(rr -> assertEquals(rr, r));\n@@ -184,2 +181,2 @@\n-        assertEquals(ClassDesc.of(\"java.lang.String\"), ClassDesc.ofDescriptor(\"Ljava\/lang\/String;\"));\n-        assertEquals(ClassDesc.of(\"java.lang.String\"), ClassDesc.ofInternalName(\"java\/lang\/String\"));\n+        assertEquals(ClassDesc.ofDescriptor(\"Ljava\/lang\/String;\"), ClassDesc.of(\"java.lang.String\"));\n+        assertEquals(ClassDesc.ofInternalName(\"java\/lang\/String\"), ClassDesc.of(\"java.lang.String\"));\n@@ -188,3 +185,3 @@\n-        assertEquals(thisClassDesc, ClassDesc.of(\"\", \"ClassDescTest\"));\n-        assertEquals(thisClassDesc, ClassDesc.of(\"ClassDescTest\"));\n-        assertEquals(thisClassDesc.displayName(), \"ClassDescTest\");\n+        assertEquals(ClassDesc.of(\"\", \"ClassDescTest\"), thisClassDesc);\n+        assertEquals(ClassDesc.of(\"ClassDescTest\"), thisClassDesc);\n+        assertEquals(\"ClassDescTest\", thisClassDesc.displayName());\n@@ -194,0 +191,1 @@\n+    @Test\n@@ -208,12 +206,2 @@\n-        try {\n-            cr.arrayType(-1);\n-            fail(\"\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n-        try {\n-            cr.arrayType(0);\n-            fail(\"\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n+        assertThrows(IllegalArgumentException.class, () -> cr.arrayType(-1));\n+        assertThrows(IllegalArgumentException.class, () -> cr.arrayType(0));\n@@ -226,6 +214,1 @@\n-        try {\n-            TwoDArrayDesc.arrayType(Integer.MAX_VALUE);\n-            fail(\"\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ Expected\n-        }\n+        assertThrows(IllegalArgumentException.class, () -> TwoDArrayDesc.arrayType(Integer.MAX_VALUE));\n@@ -235,0 +218,1 @@\n+    @Test\n@@ -249,3 +233,3 @@\n-            assertEquals(a0.descriptorString(), d);\n-            assertEquals(a1.descriptorString(), \"[\" + a0.descriptorString());\n-            assertEquals(a2.descriptorString(), \"[[\" + a0.descriptorString());\n+            assertEquals(d, a0.descriptorString());\n+            assertEquals(\"[\" + a0.descriptorString(), a1.descriptorString());\n+            assertEquals(\"[[\" + a0.descriptorString(), a2.descriptorString());\n@@ -254,2 +238,2 @@\n-            assertEquals(a0, a1.componentType());\n-            assertEquals(a1, a2.componentType());\n+            assertEquals(a1.componentType(), a0);\n+            assertEquals(a2.componentType(), a1);\n@@ -257,2 +241,2 @@\n-            assertNotEquals(a0, a1);\n-            assertNotEquals(a1, a2);\n+            assertNotEquals(a1, a0);\n+            assertNotEquals(a2, a1);\n@@ -260,5 +244,5 @@\n-            assertEquals(a1, ClassDesc.ofDescriptor(\"[\" + d));\n-            assertEquals(a2, ClassDesc.ofDescriptor(\"[[\" + d));\n-            assertEquals(classToDescriptor(a0.resolveConstantDesc(LOOKUP)), a0.descriptorString());\n-            assertEquals(classToDescriptor(a1.resolveConstantDesc(LOOKUP)), a1.descriptorString());\n-            assertEquals(classToDescriptor(a2.resolveConstantDesc(LOOKUP)), a2.descriptorString());\n+            assertEquals(ClassDesc.ofDescriptor(\"[\" + d), a1);\n+            assertEquals(ClassDesc.ofDescriptor(\"[[\" + d), a2);\n+            assertEquals(a0.descriptorString(), classToDescriptor(a0.resolveConstantDesc(LOOKUP)));\n+            assertEquals(a1.descriptorString(), classToDescriptor(a1.resolveConstantDesc(LOOKUP)));\n+            assertEquals(a2.descriptorString(), classToDescriptor(a2.resolveConstantDesc(LOOKUP)));\n@@ -271,6 +255,1 @@\n-        try {\n-            ConstantDescs.CD_void.arrayType();\n-            fail(\"Should throw IAE\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ Expected\n-        }\n+        assertThrows(IllegalArgumentException.class, () -> ConstantDescs.CD_void.arrayType());\n@@ -279,0 +258,1 @@\n+    @Test\n@@ -286,7 +266,1 @@\n-            try {\n-                ClassDesc constant = ClassDesc.ofDescriptor(d);\n-                fail(d);\n-            }\n-            catch (IllegalArgumentException e) {\n-                \/\/ good\n-            }\n+            assertThrows(IllegalArgumentException.class, () -> ClassDesc.ofDescriptor(d), d);\n@@ -298,6 +272,1 @@\n-            try {\n-                ClassDesc constant = ClassDesc.of(d);\n-                fail(d);\n-            } catch (IllegalArgumentException e) {\n-                \/\/ good\n-            }\n+            assertThrows(IllegalArgumentException.class, () -> ClassDesc.of(d), d);\n@@ -309,6 +278,1 @@\n-            try {\n-                ClassDesc constant = ClassDesc.ofInternalName(d);\n-                fail(d);\n-            } catch (IllegalArgumentException e) {\n-                \/\/ good\n-            }\n+            assertThrows(IllegalArgumentException.class, () -> ClassDesc.ofInternalName(d), d);\n@@ -324,20 +288,8 @@\n-        try {\n-            ClassDesc arrGreaterThan255 = stringArrDesc.arrayType();\n-            fail(\"can't create an array type descriptor with more than 255 dimensions\");\n-        } catch (IllegalStateException e) {\n-            \/\/ good\n-        }\n-        String descWith255ArrayDims = new String(new char[255]).replace('\\0', '[');\n-        try {\n-            ClassDesc arrGreaterThan255 = ClassDesc.ofDescriptor(descWith255ArrayDims + \"[Ljava\/lang\/String;\");\n-            fail(\"can't create an array type descriptor with more than 255 dimensions\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n-        try {\n-            ClassDesc arrWith255Dims = ClassDesc.ofDescriptor(descWith255ArrayDims + \"Ljava\/lang\/String;\");\n-            arrWith255Dims.arrayType(1);\n-            fail(\"can't create an array type descriptor with more than 255 dimensions\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n+        assertThrows(IllegalStateException.class, () -> stringArrDesc.arrayType(),\n+                \"can't create an array type descriptor with more than 255 dimensions\");\n+        String descWith255ArrayDims = \"[\".repeat(255);\n+        assertThrows(IllegalArgumentException.class, () -> ClassDesc.ofDescriptor(descWith255ArrayDims + \"[Ljava\/lang\/String;\"),\n+                \"can't create an array type descriptor with more than 255 dimensions\");\n+        ClassDesc arrWith255Dims = ClassDesc.ofDescriptor(descWith255ArrayDims + \"Ljava\/lang\/String;\");\n+        assertThrows(IllegalArgumentException.class, () -> arrWith255Dims.arrayType(1),\n+                \"can't create an array type descriptor with more than 255 dimensions\");\n@@ -347,6 +299,1 @@\n-        try {\n-            cr.nested(firstNestedName, moreNestedNames);\n-            fail(\"\");\n-        } catch (IllegalStateException e) {\n-            \/\/ good\n-        }\n+        assertThrows(IllegalStateException.class, () -> cr.nested(firstNestedName, moreNestedNames));\n@@ -355,0 +302,1 @@\n+    @Test\n@@ -357,2 +305,2 @@\n-        assertEquals(d.resolveConstantDesc(LOOKUP), d);\n-        assertEquals(d.describeConstable().get(), d);\n+        assertEquals(d, d.resolveConstantDesc(LOOKUP));\n+        assertEquals(d, d.describeConstable().get());\n@@ -361,2 +309,2 @@\n-        assertEquals(i.resolveConstantDesc(LOOKUP), i);\n-        assertEquals(i.describeConstable().get(), i);\n+        assertEquals(i, i.resolveConstantDesc(LOOKUP));\n+        assertEquals(i, i.describeConstable().get());\n@@ -365,2 +313,2 @@\n-        assertEquals(f.resolveConstantDesc(LOOKUP), f);\n-        assertEquals(f.describeConstable().get(), f);\n+        assertEquals(f, f.resolveConstantDesc(LOOKUP));\n+        assertEquals(f, f.describeConstable().get());\n@@ -369,2 +317,2 @@\n-        assertEquals(l.resolveConstantDesc(LOOKUP), l);\n-        assertEquals(l.describeConstable().get(), l);\n+        assertEquals(l, l.resolveConstantDesc(LOOKUP));\n+        assertEquals(l, l.describeConstable().get());\n@@ -373,2 +321,2 @@\n-        assertEquals(s.resolveConstantDesc(LOOKUP), s);\n-        assertEquals(s.describeConstable().get(), s);\n+        assertEquals(s, s.resolveConstantDesc(LOOKUP));\n+        assertEquals(s, s.describeConstable().get());\n@@ -377,0 +325,1 @@\n+    @Test\n@@ -379,20 +328,3 @@\n-        try {\n-            cd.nested(null);\n-            fail(\"\");\n-        } catch (NullPointerException e) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            cd.nested(\"good\", null);\n-            fail(\"\");\n-        } catch (NullPointerException e) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            cd.nested(\"good\", \"goodToo\", null);\n-            fail(\"\");\n-        } catch (NullPointerException e) {\n-            \/\/ good\n-        }\n+        assertThrows(NullPointerException.class, () -> cd.nested(null));\n+        assertThrows(NullPointerException.class, () -> cd.nested(\"good\", null));\n+        assertThrows(NullPointerException.class, () -> cd.nested(\"good\", \"goodToo\", null));\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":72,"deletions":140,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-import org.testng.annotations.Test;\n-\n@@ -43,7 +41,7 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertNotSame;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -54,1 +52,1 @@\n- * @run testng CondyDescTest\n+ * @run junit CondyDescTest\n@@ -57,1 +55,0 @@\n-@Test\n@@ -63,2 +60,2 @@\n-        assertEquals(r, DynamicConstantDesc.ofNamed(r.bootstrapMethod(), r.constantName(), r.constantType(), r.bootstrapArgs()));\n-        assertEquals(r.resolveConstantDesc(LOOKUP), c);\n+        assertEquals(DynamicConstantDesc.ofNamed(r.bootstrapMethod(), r.constantName(), r.constantType(), r.bootstrapArgs()), r);\n+        assertEquals(c, r.resolveConstantDesc(LOOKUP));\n@@ -69,1 +66,1 @@\n-        assertEquals(vh.describeConstable().orElseThrow(), r);\n+        assertEquals(r, vh.describeConstable().orElseThrow());\n@@ -75,2 +72,2 @@\n-        assertEquals(r, EnumDesc.of(r.constantType(), r.constantName()));\n-        assertEquals(r.resolveConstantDesc(LOOKUP), e);\n+        assertEquals(EnumDesc.of(r.constantType(), r.constantName()), r);\n+        assertEquals(e, r.resolveConstantDesc(LOOKUP));\n@@ -79,0 +76,1 @@\n+    @Test\n@@ -81,1 +79,1 @@\n-        assertEquals(r, DynamicConstantDesc.ofNamed(r.bootstrapMethod(), r.constantName(), r.constantType(), r.bootstrapArgs()));\n+        assertEquals(DynamicConstantDesc.ofNamed(r.bootstrapMethod(), r.constantName(), r.constantType(), r.bootstrapArgs()), r);\n@@ -89,0 +87,1 @@\n+    @Test\n@@ -96,0 +95,1 @@\n+    @Test\n@@ -104,1 +104,1 @@\n-        assertEquals(s, \"moocow\");\n+        assertEquals(\"moocow\", s);\n@@ -115,0 +115,1 @@\n+    @Test\n@@ -134,0 +135,1 @@\n+    @Test\n@@ -143,1 +145,1 @@\n-        assertEquals(varHandle.varType(), int.class);\n+        assertEquals(int.class, varHandle.varType());\n@@ -146,1 +148,1 @@\n-        assertEquals(MyClass.sf, 8);\n+        assertEquals(8, MyClass.sf);\n@@ -153,1 +155,1 @@\n-        assertEquals(varHandle.varType(), int.class);\n+        assertEquals(int.class, varHandle.varType());\n@@ -156,1 +158,1 @@\n-        assertEquals(instance.f, 9);\n+        assertEquals(9, instance.f);\n@@ -208,1 +210,0 @@\n-        assertEquals(prototype, canonical);\n@@ -210,0 +211,1 @@\n+        assertEquals(prototype, canonical);\n@@ -211,1 +213,0 @@\n-            assertEquals(canonical, nonCanonical);\n@@ -213,1 +214,1 @@\n-            assertEquals(prototype, nonCanonical);\n+            assertEquals(canonical, nonCanonical);\n@@ -215,0 +216,1 @@\n+            assertEquals(prototype, nonCanonical);\n@@ -218,0 +220,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/lang\/constant\/CondyDescTest.java","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -50,1 +47,4 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -55,1 +55,1 @@\n- * @run testng ConstantDescsTest\n+ * @run junit ConstantDescsTest\n@@ -60,2 +60,1 @@\n-    @DataProvider(name = \"validateFields\")\n-    public Object[][] knownFieldsData() {\n+    public static Object[][] knownFieldsData() {\n@@ -120,1 +119,2 @@\n-    @Test(dataProvider = \"validateFields\")\n+    @ParameterizedTest\n+    @MethodSource(\"knownFieldsData\")\n@@ -123,1 +123,1 @@\n-        assertEquals(desc.resolveConstantDesc(MethodHandles.publicLookup()), value);\n+        assertEquals(value, desc.resolveConstantDesc(MethodHandles.publicLookup()));\n","filename":"test\/jdk\/java\/lang\/constant\/ConstantDescsTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.constant.*;\n+import java.util.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.internal.constant.ConstantAccess;\n+import jdk.internal.constant.ConstantUtils;\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8303930\n+ * @build java.base\/jdk.internal.constant.*\n+ * @compile ConstantUtilsTest.java\n+ * @modules java.base\/jdk.internal.constant\n+ * @run junit ConstantUtilsTest\n+ * @summary unit tests for methods of java.lang.constant.ConstantUtils that are not covered by other unit tests\n+ *\/\n+public class ConstantUtilsTest {\n+    private static ClassDesc thisClass = ClassDesc.of(\"MethodHandleDescTest\");\n+\n+    @Test\n+    public void testValidateMemberName() {\n+        assertThrows(NullPointerException.class, () -> ConstantUtils.validateMemberName(null, false));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantUtils.validateMemberName(\"\", false));\n+\n+        List<String> badNames = List.of(\".\", \";\", \"[\", \"\/\", \"<\", \">\");\n+        for (String n : badNames) {\n+            assertThrows(IllegalArgumentException.class, () -> ConstantUtils.validateMemberName(n, true), n);\n+        }\n+    }\n+\n+    @Test\n+    public void testSkipOverFieldSignatureVoid() {\n+       int ret = ConstantAccess.skipOverFieldSignature(\"(V)V\", 1, 4);\n+       assertEquals(0, ret, \"Descriptor of (V)V starting at index 1, void disallowed\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/constant\/ConstantUtilsTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng DescribeResolveTest\n+ * @run junit DescribeResolveTest\n@@ -29,3 +29,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -36,1 +33,3 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -40,1 +39,0 @@\n-    @DataProvider\n@@ -51,1 +49,2 @@\n-    @Test(dataProvider = \"constables\")\n+    @ParameterizedTest\n+    @MethodSource(\"constables\")\n","filename":"test\/jdk\/java\/lang\/constant\/DescribeResolveTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.lang.invoke.MethodType;\n@@ -26,4 +25,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n@@ -31,1 +26,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -33,6 +28,1 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,1 +30,1 @@\n-\/**\n+\/*\n@@ -43,1 +33,1 @@\n- * @run testng DynamicCallSiteDescTest\n+ * @run junit DynamicCallSiteDescTest\n@@ -47,1 +37,0 @@\n-@Test\n@@ -53,0 +42,1 @@\n+    @Test\n@@ -59,66 +49,37 @@\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    dmh,\n-                    \"\",\n-                    MethodTypeDesc.ofDescriptor(\"()I\")\n-            );\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    null,\n-                    \"getTarget\",\n-                    MethodTypeDesc.ofDescriptor(\"()I\")\n-            );\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    dmh,\n-                    null,\n-                    MethodTypeDesc.ofDescriptor(\"()I\")\n-            );\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    dmh,\n-                    \"getTarget\",\n-                    null\n-            );\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    dmh,\n-                    \"getTarget\",\n-                    MethodTypeDesc.ofDescriptor(\"()I\"),\n-                    null\n-            );\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-        try {\n-            DynamicCallSiteDesc.of(\n-                    dmh,\n-                    \"getTarget\",\n-                    MethodTypeDesc.ofDescriptor(\"()I\"),\n-                    new ConstantDesc[]{ null }\n-            );\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n+        assertThrows(IllegalArgumentException.class, () -> DynamicCallSiteDesc.of(\n+                dmh,\n+                \"\",\n+                MethodTypeDesc.ofDescriptor(\"()I\")\n+        ));\n+\n+        assertThrows(NullPointerException.class, () -> DynamicCallSiteDesc.of(\n+                null,\n+                \"getTarget\",\n+                MethodTypeDesc.ofDescriptor(\"()I\")\n+        ));\n+\n+        assertThrows(NullPointerException.class, () -> DynamicCallSiteDesc.of(\n+                dmh,\n+                null,\n+                MethodTypeDesc.ofDescriptor(\"()I\")\n+        ));\n+\n+        assertThrows(NullPointerException.class, () -> DynamicCallSiteDesc.of(\n+                dmh,\n+                \"getTarget\",\n+                null\n+        ));\n+\n+        assertThrows(NullPointerException.class, () -> DynamicCallSiteDesc.of(\n+                dmh,\n+                \"getTarget\",\n+                MethodTypeDesc.ofDescriptor(\"()I\"),\n+                null\n+        ));\n+\n+        assertThrows(NullPointerException.class, () -> DynamicCallSiteDesc.of(\n+                dmh,\n+                \"getTarget\",\n+                MethodTypeDesc.ofDescriptor(\"()I\"),\n+                new ConstantDesc[]{ null }\n+        ));\n@@ -127,0 +88,1 @@\n+    @Test\n@@ -137,13 +99,2 @@\n-        try {\n-            desc.withArgs(null);\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            desc.withArgs(new ConstantDesc[]{ null });\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n+        assertThrows(NullPointerException.class, () -> desc.withArgs(null));\n+        assertThrows(NullPointerException.class, () -> desc.withArgs(new ConstantDesc[]{ null }));\n@@ -152,0 +103,1 @@\n+    @Test\n@@ -162,13 +114,2 @@\n-        try {\n-            desc.withNameAndType(null, MethodTypeDesc.ofDescriptor(\"()I\"));\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            desc.withNameAndType(\"bootstrap\", null);\n-            fail(\"NullPointerException expected\");\n-        } catch (NullPointerException npe) {\n-            \/\/ good\n-        }\n+        assertThrows(NullPointerException.class, () -> desc.withNameAndType(null, MethodTypeDesc.ofDescriptor(\"()I\")));\n+        assertThrows(NullPointerException.class, () -> desc.withNameAndType(\"bootstrap\", null));\n@@ -177,0 +118,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/lang\/constant\/DynamicCallSiteDescTest.java","additions":50,"deletions":108,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import org.testng.annotations.Test;\n@@ -38,2 +37,4 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotEquals;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +42,1 @@\n-\/**\n+\/*\n@@ -44,1 +45,1 @@\n- * @run testng IndyDescTest\n+ * @run junit IndyDescTest\n@@ -47,1 +48,0 @@\n-@Test\n@@ -57,0 +57,1 @@\n+    @Test\n@@ -99,0 +100,1 @@\n+    @Test\n@@ -112,1 +114,1 @@\n-        assertEquals(csd1.toString(), \"DynamicCallSiteDesc[IndyDescTest::bootstrap(wooga\/):()String]\");\n+        assertEquals(\"DynamicCallSiteDesc[IndyDescTest::bootstrap(wooga\/):()String]\", csd1.toString());\n@@ -115,1 +117,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -120,1 +122,1 @@\n-        DynamicCallSiteDesc csd1 = DynamicCallSiteDesc.of(mh, \"\", MethodTypeDesc.of(CD_String));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> DynamicCallSiteDesc.of(mh, \"\", MethodTypeDesc.of(CD_String)));\n","filename":"test\/jdk\/java\/lang\/constant\/IndyDescTest.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import org.testng.annotations.Test;\n@@ -57,8 +56,6 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertNotSame;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n-\n-\/**\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n@@ -67,1 +64,1 @@\n- * @run testng MethodHandleDescTest\n+ * @run junit MethodHandleDescTest\n@@ -70,1 +67,0 @@\n-@Test\n@@ -92,2 +88,2 @@\n-            assertEquals(r, MethodHandleDesc.of(rr.kind(), rr.owner(), rr.methodName(), rr.lookupDescriptor()));\n-            assertEquals(r.invocationType().resolveConstantDesc(LOOKUP), r.resolveConstantDesc(LOOKUP).type());\n+            assertEquals(MethodHandleDesc.of(rr.kind(), rr.owner(), rr.methodName(), rr.lookupDescriptor()), r);\n+            assertEquals(r.resolveConstantDesc(LOOKUP).type(), r.invocationType().resolveConstantDesc(LOOKUP));\n@@ -117,2 +113,2 @@\n-        assertMHEquals(r.resolveConstantDesc(LOOKUP), mh);\n-        assertEquals(mh.describeConstable().orElseThrow(), r);\n+        assertMHEquals(mh, r.resolveConstantDesc(LOOKUP));\n+        assertEquals(r, mh.describeConstable().orElseThrow());\n@@ -123,3 +119,3 @@\n-        assertEquals(mhi.getDeclaringClass().descriptorString(), rr.owner().descriptorString());\n-        assertEquals(mhi.getName(), rr.methodName());\n-        assertEquals(mhi.getReferenceKind(), rr.kind().refKind);\n+        assertEquals(rr.owner().descriptorString(), mhi.getDeclaringClass().descriptorString());\n+        assertEquals(rr.methodName(), mhi.getName());\n+        assertEquals(rr.kind().refKind, mhi.getReferenceKind());\n@@ -127,1 +123,1 @@\n-        assertEquals(type.toMethodDescriptorString(), lookupDescriptor(rr));\n+        assertEquals(lookupDescriptor(rr), type.toMethodDescriptorString());\n@@ -130,0 +126,1 @@\n+    @Test\n@@ -150,15 +147,4 @@\n-        \/\/ bad constructor non void return type\n-        try {\n-            MethodHandleDesc.of(Kind.CONSTRUCTOR, ClassDesc.of(\"java.util.ArrayList\"), \"<init>\", \"()I\");\n-            fail(\"should have failed: non void return type for constructor\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ good\n-        }\n-\n-        \/\/ null list of parameters\n-        try {\n-            MethodHandleDesc.ofConstructor(ClassDesc.of(\"java.util.ArrayList\", null));\n-            fail(\"should have failed: null list of parameters\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        assertThrows(IllegalArgumentException.class, () -> MethodHandleDesc.of(Kind.CONSTRUCTOR, ClassDesc.of(\"java.util.ArrayList\"), \"<init>\", \"()I\"),\n+                \"bad constructor non void return type\");\n+        assertThrows(NullPointerException.class, () -> MethodHandleDesc.ofConstructor(ClassDesc.of(\"java.util.ArrayList\", null)),\n+                \"null list of parameters\");\n@@ -166,9 +152,2 @@\n-        \/\/ null elements in list of parameters\n-        try {\n-            ClassDesc[] paramList = new ClassDesc[1];\n-            paramList[0] = null;\n-            MethodHandleDesc.ofConstructor(ClassDesc.of(\"java.util.ArrayList\"), paramList);\n-            fail(\"should have failed: null content in list of parameters\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        assertThrows(NullPointerException.class, () -> MethodHandleDesc.ofConstructor(ClassDesc.of(\"java.util.ArrayList\"), new ClassDesc[] { null }),\n+                \"null elements in list of parameters\");\n@@ -177,0 +156,1 @@\n+    @Test\n@@ -184,1 +164,1 @@\n-        assertEquals(takesInteger.toString(), \"MethodHandleDesc[STATIC\/Integer::valueOf(int)Integer].asType(Integer)Integer\");\n+        assertEquals(\"MethodHandleDesc[STATIC\/Integer::valueOf(int)Integer].asType(Integer)Integer\", takesInteger.toString());\n@@ -186,5 +166,3 @@\n-        try {\n-            Integer i = (Integer) mh1.invokeExact(3);\n-            fail(\"Expected WMTE\");\n-        }\n-        catch (WrongMethodTypeException ignored) { }\n+        assertThrows(WrongMethodTypeException.class, () -> {\n+            Integer _ = (Integer) mh1.invokeExact(3);\n+        });\n@@ -197,5 +175,3 @@\n-        try {\n-            Integer i = (Integer) mh2.invokeExact((Integer) 3);\n-            fail(\"Expected WMTE\");\n-        }\n-        catch (WrongMethodTypeException ignored) { }\n+        assertThrows(WrongMethodTypeException.class, () -> {\n+            Integer _ = (Integer) mh2.invokeExact((Integer) 3);\n+        });\n@@ -207,6 +183,1 @@\n-        try {\n-            mhr.asType(null);\n-            fail(\"Expected NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        assertThrows(NullPointerException.class, () -> mhr.asType(null));\n@@ -219,0 +190,1 @@\n+    @Test\n@@ -232,2 +204,2 @@\n-        assertEquals(ctorDesc.invocationType(), MethodTypeDesc.of(testClass));\n-        assertEquals(((DirectMethodHandleDesc) ctorDesc).lookupDescriptor(), \"()V\");\n+        assertEquals(MethodTypeDesc.of(testClass), ctorDesc.invocationType());\n+        assertEquals(\"()V\", ((DirectMethodHandleDesc) ctorDesc).lookupDescriptor());\n@@ -235,2 +207,2 @@\n-        assertEquals(staticMethodDesc.invocationType().descriptorString(), \"(I)I\");\n-        assertEquals(((DirectMethodHandleDesc) staticMethodDesc).lookupDescriptor(), \"(I)I\");\n+        assertEquals(\"(I)I\", staticMethodDesc.invocationType().descriptorString());\n+        assertEquals(\"(I)I\", ((DirectMethodHandleDesc) staticMethodDesc).lookupDescriptor());\n@@ -238,2 +210,2 @@\n-        assertEquals(instanceMethodDesc.invocationType().descriptorString(), \"(\" + testClass.descriptorString() + \"I)I\");\n-        assertEquals(((DirectMethodHandleDesc) instanceMethodDesc).lookupDescriptor(), \"(I)I\");\n+        assertEquals(\"(\" + testClass.descriptorString() + \"I)I\", instanceMethodDesc.invocationType().descriptorString());\n+        assertEquals(\"(I)I\", ((DirectMethodHandleDesc) instanceMethodDesc).lookupDescriptor());\n@@ -260,2 +232,1 @@\n-        try { superMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> superMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -264,2 +235,1 @@\n-        try { superIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> superIMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -268,2 +238,1 @@\n-        try { privateMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> privateMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -272,2 +241,1 @@\n-        try { privateIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> privateIMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -277,2 +245,1 @@\n-        try { privateStaticMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> privateStaticMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -281,2 +248,1 @@\n-        try { privateStaticIMethodDesc.resolveConstantDesc(LOOKUP); fail(); }\n-        catch (IllegalAccessException e) { \/* expected *\/ }\n+        assertThrows(IllegalAccessException.class, () -> privateStaticIMethodDesc.resolveConstantDesc(LOOKUP));\n@@ -295,1 +261,1 @@\n-        staticSetterDesc.resolveConstantDesc(LOOKUP).invokeExact(6); assertEquals(TestHelpers.TestClass.sf, 6);\n+        staticSetterDesc.resolveConstantDesc(LOOKUP).invokeExact(6); assertEquals(6, TestHelpers.TestClass.sf);\n@@ -298,1 +264,1 @@\n-        staticSetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP).invokeExact(7); assertEquals(TestHelpers.TestClass.sf, 7);\n+        staticSetterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP).invokeExact(7); assertEquals(7, TestHelpers.TestClass.sf);\n@@ -305,1 +271,1 @@\n-        setterDesc.resolveConstantDesc(LOOKUP).invokeExact(instance, 6); assertEquals(instance.f, 6);\n+        setterDesc.resolveConstantDesc(LOOKUP).invokeExact(instance, 6); assertEquals(6, instance.f);\n@@ -308,1 +274,1 @@\n-        setterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP).invokeExact(instance, 7); assertEquals(instance.f, 7);\n+        setterDesc.resolveConstantDesc(TestHelpers.TestClass.LOOKUP).invokeExact(instance, 7); assertEquals(7, instance.f);\n@@ -314,7 +280,1 @@\n-        try {\n-            MethodHandleDesc r = supplier.get();\n-            fail(\"Expected failure for \" + s);\n-        }\n-        catch (IllegalArgumentException e) {\n-            \/\/ succeed\n-        }\n+        assertThrows(IllegalArgumentException.class, supplier::get, s);\n@@ -323,0 +283,1 @@\n+    @Test\n@@ -335,1 +296,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -337,1 +298,1 @@\n-        MethodHandleDesc.ofMethod(VIRTUAL, ClassDesc.ofDescriptor(\"I\"), \"x\", MethodTypeDesc.ofDescriptor(\"()I\"));\n+        assertThrows(IllegalArgumentException.class, () -> MethodHandleDesc.ofMethod(VIRTUAL, ClassDesc.ofDescriptor(\"I\"), \"x\", MethodTypeDesc.ofDescriptor(\"()I\")));\n@@ -340,0 +301,1 @@\n+    @Test\n@@ -362,0 +324,1 @@\n+    @Test\n@@ -364,2 +327,2 @@\n-            assertEquals(Kind.valueOf(k.refKind), Kind.valueOf(k.refKind, k.refKind == MethodHandleInfo.REF_invokeInterface));\n-            assertEquals(Kind.valueOf(k.refKind, k.isInterface), k);\n+            assertEquals(Kind.valueOf(k.refKind, k.refKind == MethodHandleInfo.REF_invokeInterface), Kind.valueOf(k.refKind));\n+            assertEquals(k, Kind.valueOf(k.refKind, k.isInterface));\n@@ -377,1 +340,1 @@\n-            assertEquals(Kind.valueOf(refKind, false), Kind.valueOf(refKind, true));\n+            assertEquals(Kind.valueOf(refKind, true), Kind.valueOf(refKind, false));\n@@ -381,6 +344,6 @@\n-        assertNotEquals(Kind.valueOf(REF_invokeStatic, false), Kind.valueOf(REF_invokeStatic, true));\n-        assertNotEquals(Kind.valueOf(REF_invokeSpecial, false), Kind.valueOf(REF_invokeSpecial, true));\n-        assertEquals(Kind.valueOf(REF_invokeStatic, false), Kind.STATIC);\n-        assertEquals(Kind.valueOf(REF_invokeStatic, true), Kind.INTERFACE_STATIC);\n-        assertEquals(Kind.valueOf(REF_invokeSpecial, false), Kind.SPECIAL);\n-        assertEquals(Kind.valueOf(REF_invokeSpecial, true), Kind.INTERFACE_SPECIAL);\n+        assertNotEquals(Kind.valueOf(REF_invokeStatic, true), Kind.valueOf(REF_invokeStatic, false));\n+        assertNotEquals(Kind.valueOf(REF_invokeSpecial, true), Kind.valueOf(REF_invokeSpecial, false));\n+        assertEquals(Kind.STATIC, Kind.valueOf(REF_invokeStatic, false));\n+        assertEquals(Kind.INTERFACE_STATIC, Kind.valueOf(REF_invokeStatic, true));\n+        assertEquals(Kind.SPECIAL, Kind.valueOf(REF_invokeSpecial, false));\n+        assertEquals(Kind.INTERFACE_SPECIAL, Kind.valueOf(REF_invokeSpecial, true));\n","filename":"test\/jdk\/java\/lang\/constant\/MethodHandleDescTest.java","additions":64,"deletions":101,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import org.testng.annotations.Test;\n@@ -40,1 +39,2 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +42,1 @@\n-\/**\n+\/*\n@@ -46,1 +46,1 @@\n- * @run testng MethodTypeDescTest\n+ * @run junit MethodTypeDescTest\n@@ -49,1 +49,0 @@\n-@Test\n@@ -78,2 +77,2 @@\n-        assertEquals(r.resolveConstantDesc(LOOKUP), mt);\n-        assertEquals(mt.describeConstable().get(), r);\n+        assertEquals(mt, r.resolveConstantDesc(LOOKUP));\n+        assertEquals(r, mt.describeConstable().get());\n@@ -81,4 +80,4 @@\n-        assertEquals(r.descriptorString(), mt.toMethodDescriptorString());\n-        assertEquals(r.parameterCount(), mt.parameterCount());\n-        assertEquals(r.parameterList(), mt.parameterList().stream().map(SymbolicDescTest::classToDesc).collect(toList()));\n-        assertEquals(r.parameterArray(), Stream.of(mt.parameterArray()).map(SymbolicDescTest::classToDesc).toArray(ClassDesc[]::new));\n+        assertEquals(mt.toMethodDescriptorString(), r.descriptorString());\n+        assertEquals(mt.parameterCount(), r.parameterCount());\n+        assertEquals(mt.parameterList().stream().map(SymbolicDescTest::classToDesc).collect(toList()), r.parameterList());\n+        assertArrayEquals(Stream.of(mt.parameterArray()).map(SymbolicDescTest::classToDesc).toArray(ClassDesc[]::new), r.parameterArray());\n@@ -86,2 +85,2 @@\n-            assertEquals(r.parameterType(i), classToDesc(mt.parameterType(i)));\n-        assertEquals(r.returnType(), classToDesc(mt.returnType()));\n+            assertEquals(classToDesc(mt.parameterType(i)), r.parameterType(i));\n+        assertEquals(classToDesc(mt.returnType()), r.returnType());\n@@ -97,5 +96,5 @@\n-        assertEquals(descriptor, mtDesc.descriptorString());\n-        assertEquals(returnType, mtDesc.returnType());\n-        assertEquals(paramTypes, mtDesc.parameterArray());\n-        assertEquals(Arrays.asList(paramTypes), mtDesc.parameterList());\n-        assertEquals(paramTypes.length, mtDesc.parameterCount());\n+        assertEquals(mtDesc.descriptorString(), descriptor);\n+        assertEquals(mtDesc.returnType(), returnType);\n+        assertArrayEquals(mtDesc.parameterArray(), paramTypes);\n+        assertEquals(mtDesc.parameterList(), Arrays.asList(paramTypes));\n+        assertEquals(mtDesc.parameterCount(), paramTypes.length);\n@@ -103,1 +102,1 @@\n-            assertEquals(paramTypes[i], mtDesc.parameterType(i));\n+            assertEquals(mtDesc.parameterType(i), paramTypes[i]);\n@@ -113,1 +112,1 @@\n-            assertEquals(newDesc, MethodTypeDesc.of(rc, paramTypes));\n+            assertEquals(MethodTypeDesc.of(rc, paramTypes), newDesc);\n@@ -118,3 +117,1 @@\n-        expectThrows(NullPointerException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.changeReturnType(null);\n-        });\n+        assertThrows(NullPointerException.class, () -> mtDesc.changeReturnType(null));\n@@ -129,1 +126,1 @@\n-                assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));\n+                assertEquals(MethodTypeDesc.of(returnType, ps), newDesc);\n@@ -142,1 +139,1 @@\n-            assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));\n+            assertEquals(MethodTypeDesc.of(returnType, ps), newDesc);\n@@ -150,1 +147,1 @@\n-                assertEquals(multiDrop, MethodTypeDesc.of(returnType, t.toArray(ClassDesc[]::new)));\n+                assertEquals(MethodTypeDesc.of(returnType, t.toArray(ClassDesc[]::new)), multiDrop);\n@@ -165,1 +162,1 @@\n-                assertEquals(newDesc, MethodTypeDesc.of(returnType, ps));\n+                assertEquals(MethodTypeDesc.of(returnType, ps), newDesc);\n@@ -175,1 +172,1 @@\n-            assertEquals(newDesc, MethodTypeDesc.of(returnType, a.toArray(ClassDesc[]::new)));\n+            assertEquals(MethodTypeDesc.of(returnType, a.toArray(ClassDesc[]::new)), newDesc);\n@@ -193,3 +190,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.insertParameterTypes(-1, paramTypes);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.insertParameterTypes(-1, paramTypes));\n@@ -197,3 +192,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.insertParameterTypes(paramTypes.length + 1, paramTypes));\n@@ -201,1 +194,1 @@\n-        expectThrows(IllegalArgumentException.class, () -> {\n+        {\n@@ -205,2 +198,2 @@\n-            newDesc = newDesc.insertParameterTypes(0, newParamTypes);\n-        });\n+            assertThrows(IllegalArgumentException.class, () -> newDesc.insertParameterTypes(0, newParamTypes));\n+        }\n@@ -208,1 +201,1 @@\n-        expectThrows(NullPointerException.class, () -> {\n+        {\n@@ -210,2 +203,2 @@\n-            newDesc = newDesc.insertParameterTypes(0, null);\n-        });\n+            assertThrows(NullPointerException.class, () -> newDesc.insertParameterTypes(0, null));\n+        }\n@@ -213,1 +206,1 @@\n-        expectThrows(NullPointerException.class, () -> {\n+        {\n@@ -217,2 +210,2 @@\n-            newDesc = newDesc.insertParameterTypes(0, newParamTypes);\n-        });\n+            assertThrows(NullPointerException.class, () -> newDesc.insertParameterTypes(0, newParamTypes));\n+        }\n@@ -227,3 +220,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.dropParameterTypes(-1, 0);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.dropParameterTypes(-1, 0));\n@@ -231,3 +222,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length, 0);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.dropParameterTypes(paramTypes.length, 0));\n@@ -235,3 +224,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.dropParameterTypes(paramTypes.length + 1, 0);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.dropParameterTypes(paramTypes.length + 1, 0));\n@@ -239,3 +226,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.dropParameterTypes(0, paramTypes.length + 1);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.dropParameterTypes(0, paramTypes.length + 1));\n@@ -243,3 +228,1 @@\n-        expectThrows(IndexOutOfBoundsException.class, () -> {\n-            MethodTypeDesc newDesc = mtDesc.dropParameterTypes(1, 0);\n-        });\n+        assertThrows(IndexOutOfBoundsException.class, () -> mtDesc.dropParameterTypes(1, 0));\n@@ -248,0 +231,1 @@\n+    @Test\n@@ -260,0 +244,1 @@\n+    @Test\n@@ -286,0 +271,1 @@\n+    @Test\n@@ -291,1 +277,1 @@\n-        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+        assertEquals(MethodTypeDesc.of(CD_void, CD_Object, CD_int), mtd);\n@@ -294,1 +280,1 @@\n-        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+        assertEquals(MethodTypeDesc.of(CD_void, CD_Object, CD_int), mtd);\n@@ -297,0 +283,1 @@\n+    @Test\n@@ -302,1 +289,1 @@\n-        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+        assertEquals(MethodTypeDesc.of(CD_void, CD_Object, CD_int), mtd);\n@@ -306,1 +293,1 @@\n-        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+        assertEquals(MethodTypeDesc.of(CD_void, CD_Object, CD_int), mtd);\n@@ -309,0 +296,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/lang\/constant\/MethodTypeDescTest.java","additions":51,"deletions":63,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,1 +28,1 @@\n- * @run testng NameValidationTest\n+ * @run junit NameValidationTest\n@@ -33,3 +33,0 @@\n-import java.lang.invoke.*;\n-\n-import org.testng.annotations.Test;\n@@ -39,1 +36,0 @@\n-import static java.lang.constant.DirectMethodHandleDesc.Kind.VIRTUAL;\n@@ -41,1 +37,2 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +40,0 @@\n-@Test\n@@ -52,0 +48,1 @@\n+    @Test\n@@ -55,12 +52,2 @@\n-            try {\n-                memberNamesHelper(badName, mh, CD_int, null);\n-                fail(\"Expected failure for name \" + badName);\n-            } catch (IllegalArgumentException iae) {\n-                \/\/ expected\n-            }\n-            try {\n-                memberNamesHelper(badName, mh, CD_int, new ConstantDesc[0]);\n-                fail(\"Expected failure for name \" + badName);\n-            } catch (IllegalArgumentException iae) {\n-                \/\/ expected\n-            }\n+            assertThrows(IllegalArgumentException.class, () -> memberNamesHelper(badName, mh, CD_int, null), badName);\n+            assertThrows(IllegalArgumentException.class, () -> memberNamesHelper(badName, mh, CD_int, new ConstantDesc[0]), badName);\n@@ -69,3 +56,3 @@\n-        for (String badName : goodMemberNames) {\n-            memberNamesHelper(badName, mh, CD_int, null);\n-            memberNamesHelper(badName, mh, CD_int, new ConstantDesc[0]);\n+        for (String goodName : goodMemberNames) {\n+            memberNamesHelper(goodName, mh, CD_int, null);\n+            memberNamesHelper(goodName, mh, CD_int, new ConstantDesc[0]);\n@@ -86,0 +73,1 @@\n+    @Test\n@@ -88,6 +76,1 @@\n-            try {\n-                ClassDesc.of(badName);\n-                fail(\"Expected failure for name \" + badName);\n-            } catch (IllegalArgumentException iae) {\n-                \/\/ expected\n-            }\n+            assertThrows(IllegalArgumentException.class, () -> ClassDesc.of(badName), badName);\n","filename":"test\/jdk\/java\/lang\/constant\/NameValidationTest.java","additions":13,"deletions":30,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -109,1 +109,1 @@\n-            assertEquals(sr, desc);\n+            assertEquals(desc, sr);\n","filename":"test\/jdk\/java\/lang\/constant\/SymbolicDescTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,0 @@\n-import java.lang.constant.ClassDesc;\n-\n-import org.testng.annotations.Test;\n@@ -30,4 +27,5 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -35,1 +33,1 @@\n-\/**\n+\/*\n@@ -38,1 +36,1 @@\n- * @run testng TypeDescriptorTest\n+ * @run junit TypeDescriptorTest\n@@ -41,1 +39,0 @@\n-@Test\n@@ -46,2 +43,2 @@\n-            assertEquals(f.arrayType(), array);\n-            assertEquals(f.componentType(), component);\n+            assertEquals(array, f.arrayType());\n+            assertEquals(component, f.componentType());\n@@ -51,1 +48,1 @@\n-            assertEquals(f.arrayType(), array);\n+            assertEquals(array, f.arrayType());\n@@ -56,0 +53,1 @@\n+    @Test\n@@ -70,0 +68,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/lang\/constant\/TypeDescriptorTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-# This file identifies root(s) of the test-ng hierarchy.\n-\n-TestNG.dirs = .\n-lib.dirs = \/lib\/testlibrary\/bootlib\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/TEST.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.constant;\n-\n-import java.lang.constant.*;\n-import java.util.*;\n-\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @bug 8303930\n- * @compile ConstantUtilsTest.java\n- * @modules java.base\/jdk.internal.constant\n- * @run testng ConstantUtilsTest\n- * @summary unit tests for methods of java.lang.constant.ConstantUtils that are not covered by other unit tests\n- *\/\n-@Test\n-public class ConstantUtilsTest {\n-    private static ClassDesc thisClass = ClassDesc.of(\"MethodHandleDescTest\");\n-\n-    public void testValidateMemberName() {\n-        try {\n-            ConstantUtils.validateMemberName(null, false);\n-            fail(\"\");\n-        } catch (NullPointerException e) {\n-            \/\/ good\n-        }\n-\n-        try {\n-            ConstantUtils.validateMemberName(\"\", false);\n-            fail(\"\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ good\n-        }\n-\n-        List<String> badNames = List.of(\".\", \";\", \"[\", \"\/\", \"<\", \">\");\n-        for (String n : badNames) {\n-            try {\n-                ConstantUtils.validateMemberName(n, true);\n-                fail(n);\n-            } catch (IllegalArgumentException e) {\n-                \/\/ good\n-            }\n-        }\n-    }\n-\n-    public void testSkipOverFieldSignatureVoid() {\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n-       assertEquals(ret, 0, \"Descriptor of (V)V starting at index 1, void disallowed\");\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+\/\/ Exposes packaage-private methods for testing.\n+public final class ConstantAccess {\n+    public static int skipOverFieldSignature(String descriptor, int start, int end) {\n+        return ConstantUtils.skipOverFieldSignature(descriptor, start, end);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/constant\/java.base\/jdk\/internal\/constant\/ConstantAccess.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"}]}