{"files":[{"patch":"@@ -82,7 +82,8 @@\n- * Note, that if we use {@link insert} with {@link transparentScope}, then {@link DataName}s\n- * and {@link StructuralName}s escape from the inserted scope to the anchor scope, but\n- * hashtag replacements and {@link setFuelCost} escapes to the caller, i.e. from where\n- * we inserted the scope. This makes sense if we consider {@link DataName}s belong to\n- * the structure of the generated code, and the inserted scope thus belongs nested into\n- * the anchor scope. On the other hand, hashtag replacements and {@link setFuelCost}\n- * rather belongs to the code generation that happens within the context of a template.\n+ * Note that if we use {@link #insert} with {@link Template#transparentScope}, then \n+ * {@link DataName}s  and {@link StructuralName}s escape from the inserted scope to the \n+ * anchor scope, but hashtag replacements and {@link Template#setFuelCost} escape to \n+ * the caller, i.e. from where we inserted the scope. This makes sense if we consider \n+ * {@link DataName}s belonging to the structure of the generated code and the inserted \n+ * scope belonging to the anchor scope. On the other hand, hashtag replacements and \n+ * {@link Template#setFuelCost} rather belong to the code generation that happens \n+ * within the context of a template.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.function.Function;\n@@ -117,1 +116,1 @@\n-            throw new RendererException(\"A Template method such as '$', 'fuel', etc. was called outside a template rendering.\");\n+            throw new RendererException(\"A Template method such as '$', 'fuel', etc. was called outside a template rendering call.\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}