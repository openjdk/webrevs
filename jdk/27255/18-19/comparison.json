{"files":[{"patch":"@@ -49,2 +49,56 @@\n- * Note, that {@link CodeFrame}s and {@link TemplateFrame}s often go together, but can also\n- * diverge.\n+ * Note, that {@link CodeFrame}s and {@link TemplateFrame}s often go together. But they do diverge when\n+ * we call {@link Hook#insert}. On the {@link CodeFrame} side, the inserted scope is nested in the anchoring\n+ * scope, so that the inserted scope has access to the Names of the anchoring scope, and not the caller\n+ * scope. But the {@link TemplateFrame} of the inserted scope is nested in the caller scope, so\n+ * that the inserted scope has access to hashtag replacements of the caller scope, and not the\n+ * anchoring scope.\n+ *\/\n+\n+\/*\n+ * Below, we look at a few examples, and show the use of CodeFrames (c) and TemplateFrames (t).\n+ *\n+ * Example1: anchoring and insertion in the same Template\n+ *\n+ * Template(\n+ *   t c\n+ *   t c\n+ *   t c  Anchoring Scope\n+ *   t c  hook.anchor(scope(\n+ *   t c  t c\n+ *   t c  t c  <----- CodeFrame -------------+\n+ *   t c  t c         with Names             |\n+ *   t c  t                                  |\n+ *   t c  t c                                |\n+ *   t c  t c                                |\n+ *   t c  t c     Caller Scope               |\n+ *   t c  t c ... scope(                     |\n+ *   t c  t c ... t c                        |     Insertion Scope\n+ *   t c  t c ... t c                        |     hook.insert(transparentScope(\n+ *   t c  t c ... t c                        |     t c\n+ *   t c  t c ... t c                        +---  t c\n+ *   t c  t c ... t c                              t c\n+ *   t c  t c ... t c  <----- TemplateFrame -----  t c\n+ *   t c  t c ... t c         with hashtag and     t c\n+ *   t c  t c ... t c         setFuelCost          t c\n+ *   t c  t c ... t c                              t c \"use hashtag #x\"           -> t: hashtag queried in insertion and caller scope\n+ *   t c  t c ... t c                              t c                               c: code added to anchoring scope\n+ *   t c  t c ... t c                              t c\n+ *   t c  t c ... t c                              t c let(\"x\", 42)               -> t: hashtag escapes to caller scope because\n+ *   t c  t c ... t c                              t c                                  insertion scope is transparent\n+ *   t c  t c ... t c                              t c\n+ *   t c  t c ... t c                              t c dataNames(...)...sample()  -> c: sample from insertion and anchoring scope\n+ *   t c  t c ... t c                              t c\n+ *   t c  t c ... t c                              t c addDataName(...)           -> c: names escape to the caller scope because\n+ *   t c  t c ... t c                              t c                                  insertion scope is transparent\n+ *   t c  t c ... t c                              t c\n+ *   t c  t c ... t c                              ))\n+ *   t c  t c ... t c\n+ *   t c  t c ... t c\n+ *   t c  t c ... )\n+ *   t c  t c\n+ *   t c  t c\n+ *   t c  ))\n+ *   t c\n+ *   t c\n+ * )\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -248,1 +248,4 @@\n-        if (!(st instanceof ScopeTokenImpl sti)) {\n+        if (!(st instanceof ScopeTokenImpl(List<Token> tokens,\n+                                           boolean nestedNamesAreLocal,\n+                                           boolean nestedHashtagsAreLocal,\n+                                           boolean nestedSetFuelCostAreLocal))) {\n@@ -254,1 +257,1 @@\n-        if (sti.nestedNamesAreLocal()) {\n+        if (nestedNamesAreLocal) {\n@@ -263,1 +266,1 @@\n-        if (sti.nestedHashtagsAreLocal() || sti.nestedSetFuelCostAreLocal()) {\n+        if (nestedHashtagsAreLocal || nestedSetFuelCostAreLocal) {\n@@ -265,2 +268,2 @@\n-                                                              !sti.nestedHashtagsAreLocal(),\n-                                                              !sti.nestedSetFuelCostAreLocal());\n+                                                              !nestedHashtagsAreLocal,\n+                                                              !nestedSetFuelCostAreLocal);\n@@ -274,1 +277,1 @@\n-        renderTokenList(sti.tokens());\n+        renderTokenList(tokens);\n@@ -276,1 +279,1 @@\n-        if (sti.nestedHashtagsAreLocal() || sti.nestedSetFuelCostAreLocal()) {\n+        if (nestedHashtagsAreLocal || nestedSetFuelCostAreLocal) {\n@@ -285,1 +288,1 @@\n-        if (sti.nestedNamesAreLocal()) {\n+        if (nestedNamesAreLocal) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,2 +33,4 @@\n- * Note: we want the tokens to be package private, so we create this Impl\n- *       record.\n+ * Note: We want the {@link ScopeToken} to be public, but the internals of the\n+ *       record should be private. One way too solve this is with a public interface\n+ *       that exposes nothing but its name, and a private implementation via a\n+ *       record that allows easy destructuring with pattern matching.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/ScopeTokenImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,5 +30,5 @@\n- * The {@link TemplateFrame} is the frame for a {@link Template} and its inner\n- * {@link Template#scope}s. It ensures that each {@link Template} use has its own unique\n- * {@link #id} used to deconflict names using {@link Template#$}. It also has a set of hashtag\n- * replacements, which combine the key-value pairs from the template argument and the\n- * {@link Template#let} definitions. Inner scopes of a {@link Template} have access to\n+ * The {@link TemplateFrame} is the frame for a single rendering of a {@link Template} and\n+ * its inner {@link Template#scope}s. It ensures that each {@link Template} use has its own\n+ * unique {@link #id} used to deconflict names using {@link Template#$}. It also has a set\n+ * of hashtag replacements, which combine the key-value pairs from the template argument and\n+ * the {@link Template#let} definitions. Inner scopes of a {@link Template} have access to\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}