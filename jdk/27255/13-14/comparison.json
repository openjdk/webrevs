{"files":[{"patch":"@@ -79,1 +79,2 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9\",  generateWithScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithScopes2());\n@@ -102,1 +103,2 @@\n-        comp.invoke(\"p.xyz.InnerTest9\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9a\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9b\", \"main\", new Object[] {});\n@@ -348,0 +350,1 @@\n+    \/\/ See: generateWithScopes2\n@@ -491,0 +494,1 @@\n+    \/\/ See: generateWithScopes2\n@@ -618,0 +622,1 @@\n+            \/\/ See: generateWithScopes2\n@@ -1136,1 +1141,1 @@\n-            public class InnerTest9 {\n+            public class InnerTest9a {\n@@ -1158,0 +1163,125 @@\n+    public static String generateWithScopes2() {\n+\n+        \/\/ In this section, we will look at some subtle facts about the behavior of\n+        \/\/ transparent scopes around hook insertion. This inteded for expert users\n+        \/\/ so feel free to skip it until you extensively use hook insertion.\n+\n+        \/\/ Helper method to check that the expected DataNames are available.\n+        var templateVerify = Template.make(\"toList\", (String toList) -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> transparentScope(\n+                let(\"toList2\", String.join(\", \", list.stream().map(DataName::name).toList()))\n+            )),\n+            \"\"\"\n+            if (!\"#toList\".equals(\"#toList2\")) {\n+                throw new RuntimeException(\"verify failed: '#toList' vs '#toList2'.\");\n+            }\n+            \"\"\"\n+        ));\n+\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var templateMain = Template.make(() -> scope(\n+            \/\/ Start with nothing:\n+            templateVerify.asToken(\"\"),\n+            addDataName(\"v1\", myInt, MUTABLE),\n+            templateVerify.asToken(\"v1\"),\n+            \/\/ Non-transparent hook anchor:\n+            myHook.anchor(scope(\n+                templateVerify.asToken(\"v1\"),\n+                addDataName(\"v2\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ Insert a non-transparent scope: nothing escapes.\n+                myHook.insert(scope(\n+                    \/\/ Note that at the anchor insertion point, v2 is not yet\n+                    \/\/ available, because it is added after the anchoring.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x3\", 42),\n+                    addDataName(\"v3\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v3\")\n+                )),\n+                \/\/ Note: x3 and v3 do not escape.\n+                let(\"x3\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ While not letting hashtags escape may be helpful, it is probably\n+                \/\/ not very helpful if the DataNames don't escape. For example, if\n+                \/\/ we are inserting some variable at an outer scope, we would like\n+                \/\/ it to be available for the rest of the scope.\n+                \/\/ That's where a transparent scope can be helpful.\n+                myHook.insert(transparentScope(\n+                    \/\/ At the anchoring, still only v1 is available.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x4\", 42), \/\/ escapes to caller scope\n+                    addDataName(\"v4\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4\")\n+                )),\n+                \/\/ x4 escapes to the caller out here, and not to the anchor scope.\n+                \"\/\/ x4: #x4\\n\",\n+                \/\/ And v4 escapes to the anchor scope, which is available from hee too.\n+                \/\/ Interesting detail: the ordering in the list indicates that v1\n+                \/\/ is from the outermost scope of the template, v4 is located at the\n+                \/\/ anchor scope, and v2 is located inside the anchor scope, and\n+                \/\/ thus comes last.\n+                templateVerify.asToken(\"v1, v4, v2\"),\n+                \/\/ In most practical cases we probably don't want to let the hashtag\n+                \/\/ escape, because they just represent something local. So we can\n+                \/\/ use a hashtagScope, so that DataNames escape, but not hashtags.\n+                myHook.insert(hashtagScope(\n+                    \/\/ Note: both v1 and v4 are now available at the anchoring, since\n+                    \/\/ v1 was inserted outside the anchoring scope, and v4 was just\n+                    \/\/ inserted to the anchoring scope.\n+                    templateVerify.asToken(\"v1, v4\"),\n+                    let(\"x5\", 42), \/\/ local, does not escape.\n+                    addDataName(\"v5\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4, v5\")\n+                )),\n+                let(\"x5\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v4, v5, v2\")\n+            )),\n+            templateVerify.asToken(\"v1\"),\n+\n+            \/\/ Let us now do something that probably should never be done. But still\n+            \/\/ we want to demonstrate it for educational purposes: transparent anchoring\n+            \/\/ scopes.\n+            myHook.anchor(transparentScope(\n+                templateVerify.asToken(\"v1\"),\n+                \/\/ For one, this means that DataName escape the scope directly.\n+                addDataName(\"v6\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v6\"),\n+                \/\/ But also if we insert to the anchoring scope, DataNames don't just\n+                \/\/ escape from the anchoring scope, but further out to the enclosing\n+                \/\/ scope.\n+                myHook.insert(transparentScope(\n+                    templateVerify.asToken(\"v1, v6\"),\n+                    addDataName(\"v7\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v6, v7\")\n+                )),\n+                templateVerify.asToken(\"v1, v6, v7\")\n+            )),\n+            templateVerify.asToken(\"v1, v6, v7\")\n+        ));\n+\n+        var templateClass = Template.make(() -> scope(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9b {\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(scope(\n+            \"\"\"\n+                public static void main() {\n+            \"\"\",\n+                Hooks.METHOD_HOOK.anchor(scope(\n+                    templateMain.asToken()\n+                )),\n+            \"\"\"\n+                }\n+            \"\"\"\n+            )),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":133,"deletions":3,"binary":false,"changes":136,"status":"modified"}]}