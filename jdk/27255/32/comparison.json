{"files":[{"patch":"@@ -63,1 +63,1 @@\n-        return Template.make(() -> Template.body(\n+        return Template.make(() -> Template.scope(\n@@ -118,1 +118,1 @@\n-        return Template.make(() -> Template.body(\n+        return Template.make(() -> Template.scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMethodArguments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -102,1 +102,1 @@\n-        var bodyTemplate = Template.make(\"expression\", \"arguments\", \"checksum\", (Expression expression, List<Object> arguments, String checksum) -> body(\n+        var bodyTemplate = Template.make(\"expression\", \"arguments\", \"checksum\", (Expression expression, List<Object> arguments, String checksum) -> scope(\n@@ -170,1 +170,1 @@\n-            return body(\n+            return scope(\n@@ -177,1 +177,1 @@\n-        var checksumTemplate = Template.make(\"expression\", \"checksum\", (Expression expression, String checksum) -> body(\n+        var checksumTemplate = Template.make(\"expression\", \"checksum\", (Expression expression, String checksum) -> scope(\n@@ -204,1 +204,1 @@\n-        var valueTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+        var valueTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> scope(\n@@ -216,1 +216,1 @@\n-        var constrainArgumentMethodTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+        var constrainArgumentMethodTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> scope(\n@@ -250,1 +250,1 @@\n-        var constrainArgumentTemplate = Template.make(\"name\", (String name) -> body(\n+        var constrainArgumentTemplate = Template.make(\"name\", (String name) -> scope(\n@@ -282,1 +282,1 @@\n-            return body(\n+            return scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+\/**\n+ * Represents the addition of the specified {@link Name} to the current scope,\n+ * or an outer scope if the inner scope is transparent to {@link Name}s.\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/AddNameToken.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * The {@link CodeFrame} represents a frame (i.e. scope) of code, appending {@link Code} to the {@code 'codeList'}\n+ * The {@link CodeFrame} represents a frame (i.e. scope) of generated code by appending {@link Code} to the {@link #codeList}\n@@ -34,3 +34,2 @@\n- * {@link Template#addDataName}. {@link Hook}s can be added to a frame, which allows code to be inserted at that\n- * location later. When a {@link Hook} is {@link Hook#anchor}ed, it separates the Template into an outer and inner\n- * {@link CodeFrame}, ensuring that names that are added inside the inner frame are only available inside that frame.\n+ * {@link Template#addDataName}. {@link Hook}s can be added to a code frame, which allows code to be inserted at that\n+ * location later.\n@@ -39,2 +38,1 @@\n- * On the other hand, each {@link TemplateFrame} represents the frame (or scope) of exactly one use of a\n- * Template.\n+ * The {@link CodeFrame} thus implements the {@link Name} non-transparency aspect of {@link ScopeToken}.\n@@ -43,5 +41,81 @@\n- * For simple Template nesting, the {@link CodeFrame}s and {@link TemplateFrame}s overlap exactly.\n- * However, when using {@link Hook#insert}, we simply nest {@link TemplateFrame}s, going further \"in\",\n- * but we jump to an outer {@link CodeFrame}, ensuring that we insert {@link Code} at the outer frame,\n- * and operating on the names of the outer frame. Once the {@link Hook#insert}ion is complete, we jump\n- * back to the caller {@link TemplateFrame} and {@link CodeFrame}.\n+ * The {@link CodeFrame}s are nested relative to the order of the final rendered code. This can\n+ * diverge from the nesting order of the {@link Template} when using {@link Hook#insert}, where\n+ * the execution jumps from the current (caller) {@link CodeFrame} scope to the scope of the\n+ * {@link Hook#anchor}. This ensures that the {@link Name}s of the anchor scope are accessed,\n+ * and not the ones from the caller scope. Once the {@link Hook#insert}ion is complete, we\n+ * jump back to the caller {@link CodeFrame}.\n+ *\n+ * <p>\n+ * Note, that {@link CodeFrame}s and {@link TemplateFrame}s often go together. But they do diverge when\n+ * we call {@link Hook#insert}. On the {@link CodeFrame} side, the inserted scope is nested in the anchoring\n+ * scope, so that the inserted scope has access to the Names of the anchoring scope, and not the caller\n+ * scope. But the {@link TemplateFrame} of the inserted scope is nested in the caller scope, so\n+ * that the inserted scope has access to hashtag replacements of the caller scope, and not the\n+ * anchoring scope.\n+ *\/\n+\n+\/*\n+ * Below, we look at an example, and show the use of CodeFrames (c) and TemplateFrames (t).\n+ *\n+ * Explanations:\n+ *  - Generally, every scope has a CodeFrame and a TemplateFrame. There can be multiple\n+ *    scopes inside a Template, and so there can be multiple CodeFrames and TemplateFrames.\n+ *    In the drawing below, we draw the frames vertically, and give each a unique id.\n+ *  - When we nest scopes inside scopes, we create a new CodeFrame and a new TemplateFrame,\n+ *    and so they grow the same nested structure. Example: t3 is nested inside t2 and\n+ *    c3 is nested inside c2b.\n+ *  - The exception to this:\n+ *    - At a hook.anchor, there are two CodeFrames. The first one (e.g. c2a) we call the\n+ *      hook CodeFrame, it is kept empty until we insert code to the hook. The second\n+ *      (e.g. c2b) we call the inner CodeFrame of the anchoring, into which we keep\n+ *      generating the code that is inside the scope of the hook.anchor.\n+ *    - At a hook.insert, the TemplateFrame (e.g. t4) is nested into the caller (e.g. t3),\n+ *      while the CodeFrame (e.g. c4) is nested into the anchoring CodeFrame (e.g. c2a).\n+ *\n+ * Template(\n+ *   t1 c1\n+ *   t1 c1\n+ *   t1 c1  Anchoring Scope\n+ *   t1 c1  hook.anchor(scope(\n+ *   t1 c1  t2 c2a\n+ *   t1 c1  t2 c2a <------ CodeFrame nesting--------+\n+ *   t1 c1  t2 c2a         with generated code      |\n+ *   t1 c1  t2             and Names                |\n+ *   t1 c1  t2  ^                                   |\n+ *   t1 c1  t2  +- Two CodeFramees                  |\n+ *   t1 c1  t2  v                                   |\n+ *   t1 c1  t2                                      |\n+ *   t1 c1  t2 c2b                                  |\n+ *   t1 c1  t2 c2b                                  |\n+ *   t1 c1  t2 c2b     Caller Scope                 |\n+ *   t1 c1  t2 c2b ... scope(                       |\n+ *   t1 c1  t2 c2b ... t3 c3                        |     Insertion Scope\n+ *   t1 c1  t2 c2b ... t3 c3                        |     hook.insert(transparentScope(\n+ *   t1 c1  t2 c2b ... t3 c3                        |     t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                        +---- t4 ----c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3 <-- TemplateFrame nesting ---t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3     with hashtag             t4     c4                            \/\/ t: Concerns Template Frame\n+ *   t1 c1  t2 c2b ... t3 c3     and setFuelCost          t4     c4                            \/\/ c: Concerns Code Frame\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 \"use hashtag #x\"           -> t: hashtag queried in Insertion (t4) and Caller Scope (t3)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                               c: code added to Anchoring Scope (c2a)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 let(\"x\", 42)               -> t: hashtag definition escapes to Caller Scope (t3) because\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  Insertion Scope is transparent\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 dataNames(...)...sample()  -> c: sample from Insertion (c4) and Anchoring Scope (c2a)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  (CodeFrame nesting: c2a -> c4)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 addDataName(...)           -> c: names escape to the Caller Scope (c3) because\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  Insertion Scope is transparent\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              ))\n+ *   t1 c1  t2 c2b ... t3 c3\n+ *   t1 c1  t2 c2b ... t3 c3\n+ *   t1 c1  t2 c2b ... )\n+ *   t1 c1  t2 c2b\n+ *   t1 c1  t2 c2b\n+ *   t1 c1  ))\n+ *   t1 c1\n+ *   t1 c1\n+ * )\n+ *\n@@ -81,16 +155,7 @@\n-     * Creates a normal frame, which has a {@link #parent} and which defines an inner\n-     * {@link NameSet}, for the names that are generated inside this frame. Once this\n-     * frame is exited, the name from inside this frame are not available anymore.\n-     *\/\n-    public static CodeFrame make(CodeFrame parent) {\n-        return new CodeFrame(parent, false);\n-    }\n-\n-    \/**\n-     * Creates a special frame, which has a {@link #parent} but uses the {@link NameSet}\n-     * from the parent frame, allowing {@link Template#addDataName}\/\n-     * {@link Template#addStructuralName} to persist in the outer frame when the current frame\n-     * is exited. This is necessary for {@link Hook#insert},  where we would possibly want to\n-     * make field or variable definitions during the insertion that are not just local to the\n-     * insertion but affect the {@link CodeFrame} that we {@link Hook#anchor} earlier and are\n-     * now {@link Hook#insert}ing into.\n+     * Creates a normal frame, which has a {@link #parent}. It can either be\n+     * transparent for names, meaning that names are added and accessed to and\n+     * from an outer frame. Names that are added in a transparent frame are\n+     * still available in the outer frames, as far out as the next non-transparent\n+     * frame. If a frame is non-transparent, this frame defines an inner\n+     * {@link NameSet}, for the names that are generated inside this frame. Once\n+     * this frame is exited, the names from inside this frame are not available.\n@@ -98,2 +163,2 @@\n-    public static CodeFrame makeTransparentForNames(CodeFrame parent) {\n-        return new CodeFrame(parent, true);\n+    public static CodeFrame make(CodeFrame parent, boolean isTransparentForNames) {\n+        return new CodeFrame(parent, isTransparentForNames);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":94,"deletions":29,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.function.Function;\n@@ -117,0 +118,10 @@\n+        \/\/ Wrap the FilteredSet as a Predicate.\n+        private record DataNamePredicate(FilteredSet fs) implements NameSet.Predicate {\n+            public boolean check(Name type) {\n+                return fs.check(type);\n+            }\n+            public String toString() {\n+                return fs.toString();\n+            }\n+        }\n+\n@@ -121,8 +132,16 @@\n-            return (Name name) -> {\n-                if (!(name instanceof DataName dataName)) { return false; }\n-                if (mutability == Mutability.MUTABLE && !dataName.mutable()) { return false; }\n-                if (mutability == Mutability.IMMUTABLE && dataName.mutable()) { return false; }\n-                if (subtype != null && !dataName.type().isSubtypeOf(subtype)) { return false; }\n-                if (supertype != null && !supertype.isSubtypeOf(dataName.type())) { return false; }\n-                return true;\n-            };\n+            return new DataNamePredicate(this);\n+        }\n+\n+        boolean check(Name name) {\n+            if (!(name instanceof DataName dataName)) { return false; }\n+            if (mutability == Mutability.MUTABLE && !dataName.mutable()) { return false; }\n+            if (mutability == Mutability.IMMUTABLE && dataName.mutable()) { return false; }\n+            if (subtype != null && !dataName.type().isSubtypeOf(subtype)) { return false; }\n+            if (supertype != null && !supertype.isSubtypeOf(dataName.type())) { return false; }\n+            return true;\n+        }\n+\n+        public String toString() {\n+            String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n+            String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n+            return \"DataName.FilterdSet(\" + mutability + msg1 + msg2 + \")\";\n@@ -176,1 +195,2 @@\n-         * of the contained {@link DataName}s.\n+         * of the contained {@link DataName}s, making the sampled {@link DataName}\n+         * available to an inner scope.\n@@ -178,1 +198,3 @@\n-         * @return The sampled {@link DataName}.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the sampled {@link DataName}.\n+         * @return a token that represents the sampling and inner scope.\n@@ -181,10 +203,3 @@\n-         * @throws RendererException If the set was empty.\n-         *\/\n-        public DataName sample() {\n-            DataName n = (DataName)Renderer.getCurrent().sampleName(predicate());\n-            if (n == null) {\n-                String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n-                String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n-                throw new RendererException(\"No variable: \" + mutability + msg1 + msg2 + \".\");\n-            }\n-            return n;\n+         *\/\n+        public Token sample(Function<DataName, ScopeToken> function) {\n+            return new NameSampleToken<>(predicate(), null, null, function);\n@@ -194,1 +209,6 @@\n-         * Counts the number of {@link DataName}s in the filtered set.\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s, and makes a hashtag replacement for both\n+         * the name and type of the {@link DataName}, in the current scope.\n+         *\n+         * <p>\n+         * Note, that the following two do the equivalent:\n@@ -196,1 +216,27 @@\n-         * @return The number of {@link DataName}s in the filtered set.\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name\", \"type\"),\n+         *     \"\"\"\n+         *     #name #type\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> transparentScope(\n+         *         \/\/ The \"let\" hashtag definitions escape the \"transparentScope\".\n+         *         let(\"name\", dn.name()),\n+         *         let(\"type\", dn.type())\n+         *     )),\n+         *     \"\"\"\n+         *     #name #type\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * @param name the key of the hashtag replacement for the {@link DataName} name.\n+         * @param type the key of the hashtag replacement for the {@link DataName} type.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -200,2 +246,2 @@\n-        public int count() {\n-            return Renderer.getCurrent().countNames(predicate());\n+        public Token sampleAndLetAs(String name, String type) {\n+            return new NameSampleToken<DataName>(predicate(), name, type, n -> Template.transparentScope());\n@@ -205,1 +251,29 @@\n-         * Checks if there are any {@link DataName}s in the filtered set.\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s, and makes a hashtag replacement for the\n+         * name of the {@link DataName}, in the current scope.\n+         *\n+         * <p>\n+         * Note, that the following two do the equivalent:\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name\"),\n+         *     \"\"\"\n+         *     #name\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> transparentScope(\n+         *         \/\/ The \"let\" hashtag definition escape the \"transparentScope\".\n+         *         let(\"name\", dn.name())\n+         *     )),\n+         *     \"\"\"\n+         *     #name\n+         *     \"\"\"\n+         * ));\n+         * }\n@@ -207,1 +281,2 @@\n-         * @return Returns {@code true} iff there is at least one {@link DataName} in the filtered set.\n+         * @param name the key of the hashtag replacement for the {@link DataName} name.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -211,2 +286,2 @@\n-        public boolean hasAny() {\n-            return Renderer.getCurrent().hasAnyNames(predicate());\n+        public Token sampleAndLetAs(String name) {\n+            return new NameSampleToken<DataName>(predicate(), name, null, n -> Template.transparentScope());\n@@ -216,1 +291,2 @@\n-         * Collects all {@link DataName}s in the filtered set.\n+         * Counts the number of {@link DataName}s in the filtered set, making the count\n+         * available to an inner scope.\n@@ -218,0 +294,30 @@\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the count.\n+         * @return a token that represents the counting and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token count(Function<Integer, ScopeToken> function) {\n+            return new NameCountToken(predicate(), function);\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link DataName}s in the filtered set, making the resulting boolean\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the boolean indicating iff there are any {@link DataName}s in the filtered set.\n+         * @return a token that represents the checking and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token hasAny(Function<Boolean, ScopeToken> function) {\n+            return new NameHasAnyToken(predicate(), function);\n+        }\n+\n+        \/**\n+         * Collects all {@link DataName}s in the filtered set, making the collected list\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the list of {@link DataName}.\n@@ -222,3 +328,40 @@\n-        public List<DataName> toList() {\n-            List<Name> list = Renderer.getCurrent().listNames(predicate());\n-            return list.stream().map(n -> (DataName)n).toList();\n+        public Token toList(Function<List<DataName>, ScopeToken> function) {\n+            return new NamesToListToken<>(predicate(), function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link DataName}s in the filtered set,\n+         * making each of these {@link DataName}s available to a separate inner scope.\n+         *\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link DataName}s in the filtered set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(Function<DataName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link DataName}s in the filtered set,\n+         * making each of these {@link DataName}s available to a separate inner scope, and additionally\n+         * setting hashtag replacements for the {@code name} and {@code type} of the respective\n+         * {@link DataName}s.\n+         *\n+         * <p>\n+         * Note, to avoid duplication of the {@code name} and {@code type}\n+         * hashtag replacements, the scope created by the provided {@code function} should be\n+         * non-transparent to hashtag replacements, for example {@link Template#scope} or\n+         * {@link Template#hashtagScope}.\n+         *\n+         * @param name the key of the hashtag replacement for each individual {@link DataName} name.\n+         * @param type the key of the hashtag replacement for each individual {@link DataName} type.\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link DataName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(String name, String type, Function<DataName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), name, type, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/DataName.java","additions":175,"deletions":32,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.util.function.Function;\n+\n@@ -27,5 +29,10 @@\n- * {@link Hook}s can be {@link #anchor}ed for a certain scope in a Template, and all nested\n- * Templates in this scope, and then from within this scope, any Template can\n- * {@link #insert} code to where the {@link Hook} was {@link #anchor}ed. This can be useful to reach\n- * \"back\" or to some outer scope, e.g. while generating code for a method, one can reach out\n- * to the class scope to insert fields.\n+ * A {@link Hook} can be {@link #anchor}ed for a certain scope ({@link ScopeToken}), and that\n+ * anchoring stays active for any nested scope or nested {@link Template}. With {@link #insert},\n+ * one can insert a template ({@link TemplateToken}) or scope ({@link ScopeToken}) to where the\n+ * {@link Hook} was {@link #anchor}'ed. If the hook was anchored for multiple outer scopes, the\n+ * innermost is chosen for insertion.\n+ *\n+ * <p>\n+ * This can be useful to reach \"back\" or to some outer scope, e.g. while generating code for a\n+ * method, one can reach out to the class scope to insert fields. Or one may want to reach back\n+ * to the beginning of a method to insert local variables that should be live for the whole method.\n@@ -34,0 +41,6 @@\n+ * The choice of {@link ScopeToken} is very important and powerful.\n+ * For example, if you want to insert a {@link DataName} to the scope of an anchor,\n+ * it is important that the scope of the insertion is transparent for {@link DataName}s,\n+ * e.g. using {@link Template#transparentScope}. In most cases, we want {@link DataName}s to escape\n+ * the inserted scope but not the anchor scope, so the anchor scope should be\n+ * non-transparent for {@link DataName}s, e.g. using {@link Template#scope}.\n@@ -35,0 +48,2 @@\n+ *\n+ * <p>\n@@ -38,7 +53,1 @@\n- * var template1 = Template.make(\"name\", (String name) -> body(\n- *     \"\"\"\n- *     public static int #name = 42;\n- *     \"\"\"\n- * ));\n- *\n- * var template2 = Template.make(() -> body(\n+ * var template = Template.make(() -> scope(\n@@ -49,1 +58,1 @@\n- *     myHook.anchor(\n+ *     myHook.anchor(scope(\n@@ -54,2 +63,8 @@\n- *         \/\/ Reach out to where the hook was anchored, and insert the code of template1.\n- *         myHook.insert(template1.asToken($(\"field\"))),\n+ *         \/\/ Reach out to where the hook was anchored, and insert some code.\n+ *         myHook.insert(transparentScope(\n+ *             \/\/ The field (DataName) escapes because the inserted scope is \"transparentScope\"\n+ *             addDataName($(\"field\"), Primitives.INTS, MUTABLE),\n+ *             \"\"\"\n+ *             public static int $field = 42;\n+ *             \"\"\"\n+ *         )),\n@@ -59,1 +74,1 @@\n- *     ),\n+ *     )),\n@@ -66,0 +81,10 @@\n+ * <p>\n+ * Note that if we use {@link #insert} with {@link Template#transparentScope}, then\n+ * {@link DataName}s  and {@link StructuralName}s escape from the inserted scope to the\n+ * anchor scope, but hashtag replacements and {@link Template#setFuelCost} escape to\n+ * the caller, i.e. from where we inserted the scope. This makes sense if we consider\n+ * {@link DataName}s belonging to the structure of the generated code and the inserted\n+ * scope belonging to the anchor scope. On the other hand, hashtag replacements and\n+ * {@link Template#setFuelCost} rather belong to the code generation that happens\n+ * within the context of a template.\n+ *\n@@ -70,1 +95,1 @@\n-     * Anchor this {@link Hook} for the scope of the provided {@code 'tokens'}.\n+     * Anchor this {@link Hook} for the provided inner scope.\n@@ -74,2 +99,2 @@\n-     * @param tokens A list of tokens, which have the same restrictions as {@link Template#body}.\n-     * @return A {@link Token} that captures the anchoring of the scope and the list of validated {@link Token}s.\n+     * @param innerScope An inner scope, for which the {@link Hook} is anchored.\n+     * @return A {@link Token} that captures the anchoring and the inner scope.\n@@ -77,2 +102,2 @@\n-    public Token anchor(Object... tokens) {\n-        return new HookAnchorToken(this, TokenParser.parse(tokens));\n+    public Token anchor(ScopeToken innerScope) {\n+        return new HookAnchorToken(this, innerScope);\n@@ -86,1 +111,1 @@\n-     * @return The {@link Token} which when used inside a {@link Template#body} performs the code insertion into the {@link Hook}.\n+     * @return The {@link Token} which represents the code insertion into the {@link Hook}.\n@@ -89,1 +114,12 @@\n-        return new HookInsertToken(this, templateToken);\n+        return new HookInsertToken(this, Template.transparentScope(templateToken));\n+    }\n+\n+    \/**\n+     * Inserts a scope ({@link ScopeToken}) to the innermost location where this {@link Hook} was {@link #anchor}ed.\n+     * This could be in the same Template, or one nested further out.\n+     *\n+     * @param scopeToken The scope to be inserted at the {@link Hook}.\n+     * @return The {@link Token} which represents the code insertion into the {@link Hook}.\n+     *\/\n+    public Token insert(ScopeToken scopeToken) {\n+        return new HookInsertToken(this, scopeToken);\n@@ -93,1 +129,2 @@\n-     * Checks if the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     * Checks if the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope,\n+     * and makes the boolean result available to an inner scope.\n@@ -95,1 +132,2 @@\n-     * @return If the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     * @param function the function that generates the inner scope given the boolean result.\n+     * @return the token that represents the check and inner scope.\n@@ -97,2 +135,2 @@\n-    public boolean isAnchored() {\n-        return Renderer.getCurrent().isAnchored(this);\n+    public Token isAnchored(Function<Boolean, ScopeToken> function) {\n+        return new HookIsAnchoredToken(this, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":65,"deletions":27,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-record HookAnchorToken(Hook hook, List<Token> tokens) implements Token {}\n+\/**\n+ * Represents the {@link Hook#anchor} with its inner scope.\n+ *\/\n+record HookAnchorToken(Hook hook, ScopeToken innerScope) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookAnchorToken.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,5 @@\n-record HookInsertToken(Hook hook, TemplateToken templateToken) implements Token {}\n+\/**\n+ * Represents the {@link Hook#insert} with the {@link ScopeToken} of the\n+ * scope that is to be inserted.\n+ *\/\n+record HookInsertToken(Hook hook, ScopeToken scopeToken) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookInsertToken.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents an {@link Hook#isAnchored} query with the function that creates an inner scope\n+ * given the boolean answer.\n+ *\/\n+record HookIsAnchoredToken(Hook hook, Function<Boolean, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(boolean isAnchored) {\n+        return function().apply(isAnchored);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookIsAnchoredToken.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents a let (aka hashtag) definition. The hashtag replacement is active for the\n+ * scope ({@link ScopeToken}) that the {@code function} creates, but can escape that\n+ * scope if it is transparent to hashtags.\n+ *\/\n+record LetToken<T>(String key, T value, Function<T, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken() {\n+        return function().apply(value);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/LetToken.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the counting of {@link Name}s, and the function that is called\n+ * to create an inner scope given the count.\n+ *\/\n+record NameCountToken(\n+        NameSet.Predicate predicate,\n+        Function<Integer, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(int count) {\n+        return function().apply(count);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameCountToken.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the for-each execution of the provided function and (optional) hashtag replacement\n+ * keys for name and type of each name.\n+ *\/\n+record NameForEachToken<N>(\n+        NameSet.Predicate predicate,\n+        String name,\n+        String type,\n+        Function<N, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(Name n) {\n+        return function().apply((N)n);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameForEachToken.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the check if there is any name and the function that is to\n+ * be called given the boolean value (true iff there are any names).\n+ *\/\n+record NameHasAnyToken(\n+        NameSet.Predicate predicate,\n+        Function<Boolean, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(boolean hasAny) {\n+        return function().apply(hasAny);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameHasAnyToken.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the sampling of {@link Name}s, and the function that is called given\n+ * the sampled name, as well as the (optional) hashtag replacement keys for the\n+ * name and type of the sampled name, which are then available in the inner scope\n+ * created by the provided function.\n+ *\/\n+record NameSampleToken<N>(\n+        NameSet.Predicate predicate,\n+        String name,\n+        String type,\n+        Function<N, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(Name n) {\n+        return function().apply((N)n);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSampleToken.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+        String toString(); \/\/ used when sampling fails.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+import java.util.List;\n+\n+\/**\n+ * Represents the {@code toList} on a filtered name set, including the collection of the\n+ * names and the creation of the inner scope with the function.\n+ *\/\n+record NamesToListToken<N>(\n+        NameSet.Predicate predicate,\n+        Function<List<N>, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(List<Name> names) {\n+        List<N> castNames = names.stream().map(n -> (N)n).toList();\n+        return function().apply(castNames);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NamesToListToken.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.template_framework;\n-\n-record NothingToken() implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NothingToken.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -79,1 +79,1 @@\n-     * {@link Template#body}. This would be a bad pattern: the outer and nested {@link Template} would\n+     * {@link Template#scope}. This would be a bad pattern: the outer and nested {@link Template} would\n@@ -87,2 +87,2 @@\n-     * Instead, the user should create a {@link TemplateToken} from the inner {@link Template}, and\n-     * use that {@link TemplateToken} in the {@link Template#body} of the outer {@link Template}.\n+     * Instead, the user must create a {@link TemplateToken} from the inner {@link Template}, and\n+     * use that {@link TemplateToken} in the {@link Template#scope} of the outer {@link Template}.\n@@ -116,1 +116,1 @@\n-            throw new RendererException(\"A Template method such as '$', 'let', 'sample', 'count' etc. was called outside a template rendering.\");\n+            throw new RendererException(\"A Template method such as '$', 'fuel', etc. was called outside a template rendering call.\");\n@@ -174,20 +174,0 @@\n-    void setFuelCost(float fuelCost) {\n-        currentTemplateFrame.setFuelCost(fuelCost);\n-    }\n-\n-    Name sampleName(NameSet.Predicate predicate) {\n-        return currentCodeFrame.sampleName(predicate);\n-    }\n-\n-    int countNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.countNames(predicate);\n-    }\n-\n-    boolean hasAnyNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.hasAnyNames(predicate);\n-    }\n-\n-    List<Name> listNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.listNames(predicate);\n-    }\n-\n@@ -246,0 +226,3 @@\n+        \/\/ We need a TemplateFrame in all cases, this ensures that the outermost scope of the template\n+        \/\/ is not transparent for hashtags and setFuelCost, and also that the id of the template is\n+        \/\/ unique.\n@@ -250,2 +233,3 @@\n-        TemplateBody body = templateToken.instantiate();\n-        renderTokenList(body.tokens());\n+\n+        \/\/ If the ScopeToken is transparent to Names, then the Template is transparent to names.\n+        renderScopeToken(templateToken.instantiate());\n@@ -259,0 +243,51 @@\n+    private void renderScopeToken(ScopeToken st) {\n+        renderScopeToken(st, () -> {});\n+    }\n+\n+    private void renderScopeToken(ScopeToken st, Runnable preamble) {\n+        if (!(st instanceof ScopeTokenImpl(List<Token> tokens,\n+                                           boolean isTransparentForNames,\n+                                           boolean isTransparentForHashtags,\n+                                           boolean isTransparentForSetFuelCost))) {\n+            throw new RuntimeException(\"Internal error: could not unpack ScopeTokenImpl.\");\n+        }\n+\n+        \/\/ We need the CodeFrame for local names.\n+        CodeFrame outerCodeFrame = currentCodeFrame;\n+        if (!isTransparentForNames) {\n+            currentCodeFrame = CodeFrame.make(currentCodeFrame, false);\n+        }\n+\n+        \/\/ We need to be able to define local hashtag replacements, but still\n+        \/\/ see the outer ones. We also need to have the same id for dollar\n+        \/\/ replacement as the outer frame. And we need to be able to allow\n+        \/\/ local setFuelCost definitions.\n+        TemplateFrame innerTemplateFrame = null;\n+        if (!isTransparentForHashtags || !isTransparentForSetFuelCost) {\n+            innerTemplateFrame = TemplateFrame.makeInnerScope(currentTemplateFrame,\n+                                                              isTransparentForHashtags,\n+                                                              isTransparentForSetFuelCost);\n+            currentTemplateFrame = innerTemplateFrame;\n+        }\n+\n+        \/\/ Allow definition of hashtags and variables to be placed in the nested frames.\n+        preamble.run();\n+\n+        \/\/ Now render the nested code.\n+        renderTokenList(tokens);\n+\n+        if (!isTransparentForHashtags || !isTransparentForSetFuelCost) {\n+            if (currentTemplateFrame != innerTemplateFrame) {\n+                throw new RuntimeException(\"Internal error: TemplateFrame mismatch!\");\n+            }\n+            currentTemplateFrame = currentTemplateFrame.parent;\n+        }\n+\n+        \/\/ Tear down CodeFrame nesting. If no nesting happened, the code is already\n+        \/\/ in the currentCodeFrame.\n+        if (!isTransparentForNames) {\n+            outerCodeFrame.addCode(currentCodeFrame.getCode());\n+            currentCodeFrame = outerCodeFrame;\n+        }\n+    }\n+\n@@ -264,4 +299,1 @@\n-            case NothingToken() -> {\n-                \/\/ Nothing.\n-            }\n-            case HookAnchorToken(Hook hook, List<Token> tokens) -> {\n+            case HookAnchorToken(Hook hook, ScopeTokenImpl innerScope) -> {\n@@ -270,3 +302,3 @@\n-                \/\/ We need a CodeFrame to which the hook can insert code. That way, name\n-                \/\/ definitions at the hook cannot escape the hookCodeFrame.\n-                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame);\n+                \/\/ We need a CodeFrame to which the hook can insert code. If the nested names\n+                \/\/ are to be local, the CodeFrame must be non-transparent for names.\n+                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame, innerScope.isTransparentForNames());\n@@ -275,4 +307,3 @@\n-                \/\/ We need a CodeFrame where the tokens can be rendered. That way, name\n-                \/\/ definitions from the tokens cannot escape the innerCodeFrame to the\n-                \/\/ hookCodeFrame.\n-                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame);\n+                \/\/ We need a CodeFrame where the tokens can be rendered for code that is\n+                \/\/ generated inside the anchor scope, but not inserted directly to the hook.\n+                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame, innerScope.isTransparentForNames());\n@@ -281,1 +312,1 @@\n-                renderTokenList(tokens);\n+                renderScopeToken(innerScope);\n@@ -289,1 +320,1 @@\n-            case HookInsertToken(Hook hook, TemplateToken templateToken) -> {\n+            case HookInsertToken(Hook hook, ScopeTokenImpl scopeToken) -> {\n@@ -295,2 +326,2 @@\n-                \/\/ by the TemplateToken can be collected, and hook insertions from it can still\n-                \/\/ be made to the hookCodeFrame before the code from the TemplateToken is added to\n+                \/\/ by the scopeToken can be collected, and hook insertions from it can still\n+                \/\/ be made to the hookCodeFrame before the code from the scopeToken is added to\n@@ -299,2 +330,2 @@\n-                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the TemplateToken.\n-                currentCodeFrame = CodeFrame.makeTransparentForNames(hookCodeFrame);\n+                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the scopeToken.\n+                currentCodeFrame = CodeFrame.make(hookCodeFrame, true);\n@@ -302,1 +333,1 @@\n-                renderTemplateToken(templateToken);\n+                renderScopeToken(scopeToken);\n@@ -310,4 +341,0 @@\n-                \/\/ Use a nested CodeFrame.\n-                CodeFrame callerCodeFrame = currentCodeFrame;\n-                currentCodeFrame = CodeFrame.make(currentCodeFrame);\n-\n@@ -315,3 +342,0 @@\n-\n-                callerCodeFrame.addCode(currentCodeFrame.getCode());\n-                currentCodeFrame = callerCodeFrame;\n@@ -322,0 +346,57 @@\n+            case ScopeToken scopeToken -> {\n+                renderScopeToken(scopeToken);\n+            }\n+            case NameSampleToken nameScopeToken -> {\n+                Name name = currentCodeFrame.sampleName(nameScopeToken.predicate());\n+                if (name == null) {\n+                    throw new RendererException(\"No Name found for \" + nameScopeToken.predicate().toString());\n+                }\n+                ScopeToken scopeToken = nameScopeToken.getScopeToken(name);\n+                renderScopeToken(scopeToken, () -> {\n+                    if (nameScopeToken.name() != null) {\n+                        addHashtagReplacement(nameScopeToken.name(), name.name());\n+                    }\n+                    if (nameScopeToken.type() != null) {\n+                        addHashtagReplacement(nameScopeToken.type(), name.type());\n+                    }\n+                });\n+            }\n+            case NameForEachToken nameForEachToken -> {\n+                List<Name> list = currentCodeFrame.listNames(nameForEachToken.predicate());\n+                list.stream().forEach(name -> {\n+                    ScopeToken scopeToken = nameForEachToken.getScopeToken(name);\n+                    renderScopeToken(scopeToken, () -> {\n+                        if (nameForEachToken.name() != null) {\n+                            addHashtagReplacement(nameForEachToken.name(), name.name());\n+                        }\n+                        if (nameForEachToken.type() != null) {\n+                            addHashtagReplacement(nameForEachToken.type(), name.type());\n+                        }\n+                    });\n+                });\n+            }\n+            case NamesToListToken nameToListToken -> {\n+                List<Name> list = currentCodeFrame.listNames(nameToListToken.predicate());\n+                renderScopeToken(nameToListToken.getScopeToken(list));\n+            }\n+            case NameCountToken nameCountToken -> {\n+                int count = currentCodeFrame.countNames(nameCountToken.predicate());\n+                renderScopeToken(nameCountToken.getScopeToken(count));\n+            }\n+            case NameHasAnyToken nameHasAnyToken -> {\n+                boolean hasAny = currentCodeFrame.hasAnyNames(nameHasAnyToken.predicate());\n+                renderScopeToken(nameHasAnyToken.getScopeToken(hasAny));\n+            }\n+            case SetFuelCostToken(float fuelCost) -> {\n+                currentTemplateFrame.setFuelCost(fuelCost);\n+            }\n+            case LetToken letToken -> {\n+                ScopeToken scopeToken = letToken.getScopeToken();\n+                renderScopeToken(scopeToken, () -> {\n+                    addHashtagReplacement(letToken.key(), letToken.value());\n+                });\n+            }\n+            case HookIsAnchoredToken hookIsAnchoredToken -> {\n+                boolean isAnchored = currentCodeFrame.codeFrameForHook(hookIsAnchoredToken.hook()) != null;\n+                renderScopeToken(hookIsAnchoredToken.getScopeToken(isAnchored));\n+            }\n@@ -426,4 +507,0 @@\n-    boolean isAnchored(Hook hook) {\n-        return currentCodeFrame.codeFrameForHook(hook) != null;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":132,"deletions":55,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * A {@link ScopeToken} represents a scope in a {@link Template}, which can be\n+ * created with {@link Template#scope}, {@link Template#transparentScope}, and other related methods.\n+ *\/\n+public sealed interface ScopeToken extends Token permits ScopeTokenImpl {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/ScopeToken.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * Represents a scope with its tokens. Boolean flags indicate if names,\n+ * hashtag replacements and {@link Template#setFuelCost} are local, or escape to\n+ * outer scopes.\n+ *\n+ * <p>\n+ * Note: We want the {@link ScopeToken} to be public, but the internals of the\n+ *       record should be private. One way to solve this is with a public interface\n+ *       that exposes nothing but its name, and a private implementation via a\n+ *       record that allows easy destructuring with pattern matching.\n+ *\/\n+record ScopeTokenImpl(List<Token> tokens,\n+                      boolean isTransparentForNames,\n+                      boolean isTransparentForHashtags,\n+                      boolean isTransparentForSetFuelCost) implements ScopeToken, Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/ScopeTokenImpl.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * Represents the setting of the fuel cost in the current scope.\n+ *\/\n+record SetFuelCostToken(float fuelCost) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/SetFuelCostToken.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.function.Function;\n@@ -92,0 +93,10 @@\n+        \/\/ Wrap the FilteredSet as a Predicate.\n+        private record StructuralNamePredicate(FilteredSet fs) implements NameSet.Predicate {\n+            public boolean check(Name type) {\n+                return fs.check(type);\n+            }\n+            public String toString() {\n+                return fs.toString();\n+            }\n+        }\n+\n@@ -96,6 +107,14 @@\n-            return (Name name) -> {\n-                if (!(name instanceof StructuralName structuralName)) { return false; }\n-                if (subtype != null && !structuralName.type().isSubtypeOf(subtype)) { return false; }\n-                if (supertype != null && !supertype.isSubtypeOf(structuralName.type())) { return false; }\n-                return true;\n-            };\n+            return new StructuralNamePredicate(this);\n+        }\n+\n+        boolean check(Name name) {\n+            if (!(name instanceof StructuralName structuralName)) { return false; }\n+            if (subtype != null && !structuralName.type().isSubtypeOf(subtype)) { return false; }\n+            if (supertype != null && !supertype.isSubtypeOf(structuralName.type())) { return false; }\n+            return true;\n+        }\n+\n+        public String toString() {\n+            String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n+            String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n+            return \"StructuralName.FilteredSet(\" + msg1 + msg2 + \")\";\n@@ -149,1 +168,2 @@\n-         * of the contained {@link StructuralName}s.\n+         * of the contained {@link StructuralName}s, making the sampled {@link StructuralName}\n+         * available to an inner scope.\n@@ -151,1 +171,3 @@\n-         * @return The sampled {@link StructuralName}.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the sampled {@link StructuralName}.\n+         * @return a token that represents the sampling and inner scope.\n@@ -154,1 +176,0 @@\n-         * @throws RendererException If the set was empty.\n@@ -156,8 +177,17 @@\n-        public StructuralName sample() {\n-            StructuralName n = (StructuralName)Renderer.getCurrent().sampleName(predicate());\n-            if (n == null) {\n-                String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n-                String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n-                throw new RendererException(\"No variable:\" + msg1 + msg2 + \".\");\n-            }\n-            return n;\n+        public Token sample(Function<StructuralName, ScopeToken> function) {\n+            return new NameSampleToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s, and makes a hashtag replacement for both\n+         * the name and type of the {@link StructuralName}, in the current scope.\n+         *\n+         * @param name the key of the hashtag replacement for the {@link StructuralName} name.\n+         * @param type the key of the hashtag replacement for the {@link StructuralName} type.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token sampleAndLetAs(String name, String type) {\n+            return new NameSampleToken<StructuralName>(predicate(), name, type, n -> Template.transparentScope());\n@@ -167,1 +197,3 @@\n-         * Counts the number of {@link StructuralName}s in the filtered set.\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s, and makes a hashtag replacement for the\n+         * name of the {@link StructuralName}, in the current scope.\n@@ -169,1 +201,2 @@\n-         * @return The number of {@link StructuralName}s in the filtered set.\n+         * @param name the key of the hashtag replacement for the {@link StructuralName} name.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -173,2 +206,2 @@\n-        public int count() {\n-            return Renderer.getCurrent().countNames(predicate());\n+        public Token sampleAndLetAs(String name) {\n+            return new NameSampleToken<StructuralName>(predicate(), name, null, n -> Template.transparentScope());\n@@ -178,1 +211,2 @@\n-         * Checks if there are any {@link StructuralName}s in the filtered set.\n+         * Counts the number of {@link StructuralName}s in the filtered set, making the count\n+         * available to an inner scope.\n@@ -180,1 +214,3 @@\n-         * @return Returns {@code true} iff there is at least one {@link StructuralName} in the filtered set.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the count.\n+         * @return a token that represents the counting and inner scope.\n@@ -184,2 +220,2 @@\n-        public boolean hasAny() {\n-            return Renderer.getCurrent().hasAnyNames(predicate());\n+        public Token count(Function<Integer, ScopeToken> function) {\n+            return new NameCountToken(predicate(), function);\n@@ -189,1 +225,2 @@\n-         * Collects all {@link StructuralName}s in the filtered set.\n+         * Checks if there are any {@link StructuralName}s in the filtered set, making the resulting boolean\n+         * available to an inner scope.\n@@ -191,0 +228,15 @@\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the boolean indicating iff there are any {@link StructuralName}s in the filtered set.\n+         * @return a token that represents the checking and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token hasAny(Function<Boolean, ScopeToken> function) {\n+            return new NameHasAnyToken(predicate(), function);\n+        }\n+        \/**\n+         * Collects all {@link StructuralName}s in the filtered set, making the collected list\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the list of {@link StructuralName}.\n@@ -195,3 +247,40 @@\n-        public List<StructuralName> toList() {\n-            List<Name> list = Renderer.getCurrent().listNames(predicate());\n-            return list.stream().map(n -> (StructuralName)n).toList();\n+        public Token toList(Function<List<StructuralName>, ScopeToken> function) {\n+            return new NamesToListToken<>(predicate(), function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link StructuralName}s in the filtered set,\n+         * making each of these {@link StructuralName}s available to a separate inner scope.\n+         *\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link StructuralName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(Function<StructuralName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link StructuralName}s in the filtered set,\n+         * making each of these {@link StructuralName}s available to a separate inner scope, and additionally\n+         * setting hashtag replacements for the {@code name} and {@code type} of the respective\n+         * {@link StructuralName}s.\n+         *\n+         * <p>\n+         * Note, to avoid duplication of the {@code name} and {@code type}\n+         * hashtag replacements, the scope created by the provided {@code function} should be\n+         * non-transparent to hashtag replacements, for example {@link Template#scope} or\n+         * {@link Template#hashtagScope}.\n+         *\n+         * @param name the key of the hashtag replacement for each individual {@link StructuralName} name.\n+         * @param type the key of the hashtag replacement for each individual {@link StructuralName} type.\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link StructuralName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(String name, String type, Function<StructuralName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), name, type, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StructuralName.java","additions":118,"deletions":29,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n- * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+ * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> scope(\n@@ -89,1 +89,1 @@\n- * To get an executable test, we define a {@link Template} that produces a class body with a main method. The Template\n+ * To get an executable test, we define a {@link Template} that produces a class scope with a main method. The Template\n@@ -95,1 +95,1 @@\n- * var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+ * var classTemplate = Template.make(\"types\", (List<Type> types) -> scope(\n@@ -151,1 +151,1 @@\n- *  It is currently only allowed to use up to three arguments.\n+ * It is currently only allowed to use up to three arguments.\n@@ -156,1 +156,1 @@\n- * (e.g. {@link Template.ZeroArgs#asToken()}), and use the {@link Token} inside another {@link Template#body}.\n+ * (e.g. {@link Template.ZeroArgs#asToken()}), and use the {@link Token} inside another {@link Template#scope}.\n@@ -164,0 +164,5 @@\n+ * We have decided to keep hashtag replacements constrained to the scope of one Template. They\n+ * do not escape to outer or inner Template uses. If one needs to pass values to inner Templates,\n+ * this can be done with Template arguments. Keeping hashtag replacements local to Templates\n+ * has the benefit that there is no conflict in recursive templates, where outer and inner Templates\n+ * define the same hashtag replacement.\n@@ -179,19 +184,0 @@\n- * A {@link TemplateToken} cannot just be used in {@link Template#body}, but it can also be\n- * {@link Hook#insert}ed to where a {@link Hook} was {@link Hook#anchor}ed earlier (in some outer scope of the code).\n- * For example, while generating code in a method, one can reach out to the scope of the class, and insert a\n- * new field, or define a utility method.\n- *\n- * <p>\n- * A {@link TemplateBinding} allows the recursive use of Templates. With the indirection of such a binding,\n- * a Template can reference itself.\n- *\n- * <p>\n- * The writer of recursive {@link Template}s must ensure that this recursion terminates. To unify the\n- * approach across {@link Template}s, we introduce the concept of {@link #fuel}. Templates are rendered starting\n- * with a limited amount of {@link #fuel} (default: 100, see {@link #DEFAULT_FUEL}), which is decreased at each\n- * Template nesting by a certain amount (default: 10, see {@link #DEFAULT_FUEL_COST}). The default fuel for a\n- * template can be changed when we {@code render()} it (e.g. {@link ZeroArgs#render(float)}) and the default\n- * fuel cost with {@link #setFuelCost}) when defining the {@link #body(Object...)}. Recursive templates are\n- * supposed to terminate once the {@link #fuel} is depleted (i.e. reaches zero).\n- *\n- * <p>\n@@ -214,12 +200,33 @@\n- * When working with {@link DataName}s and {@link StructuralName}s, it is important to be aware of the\n- * relevant scopes, as well as the execution order of the {@link Template} lambdas and the evaluation\n- * of the {@link Template#body} tokens. When a {@link Template} is rendered, its lambda is invoked. In the\n- * lambda, we generate the tokens, and create the {@link Template#body}. Once the lambda returns, the\n- * tokens are evaluated one by one. While evaluating the tokens, the {@link Renderer} might encounter a nested\n- * {@link TemplateToken}, which in turn triggers the evaluation of that nested {@link Template}, i.e.\n- * the evaluation of its lambda and later the evaluation of its tokens. It is important to keep in mind\n- * that the lambda is always executed first, and the tokens are evaluated afterwards. A method like\n- * {@code dataNames(MUTABLE).exactOf(type).count()} is a method that is executed during the evaluation\n- * of the lambda. But a method like {@link #addDataName} returns a token, and does not immediately add\n- * the {@link DataName}. This ensures that the {@link DataName} is only inserted when the tokens are\n- * evaluated, so that it is inserted at the exact scope where we would expect it.\n+ * Code generation can involve keeping track of scopes in the code (e.g. liveness and availability of\n+ * {@link DataName}s) and of the hashtag replacements in the templates. The {@link ScopeToken} serves\n+ * this purpose, and allows the definition of transparent scopes (e.g. {@link #transparentScope}) and\n+ * non-transparent scopes (e.g. {@link #scope}).\n+ *\n+ * <table border=\"1\">\n+ *   <caption>Scopes and (non-)transparency<\/caption>\n+ *   <tr>\n+ *     <th>                           <\/th><th> hashtag         <\/th><th> {@link DataName} and {@link StructuralName} <\/th><th> {@link #setFuelCost} <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #scope}            <\/th><th> non-transparent <\/th><th> non-transparent                             <\/th><th> non-transparent     <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #hashtagScope}     <\/th><th> non-transparent <\/th><th> transparent                                 <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #nameScope}        <\/th><th> transparent     <\/th><th> non-transparent                             <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #setFuelCostScope} <\/th><th> transparent     <\/th><th> transparent                                 <\/th><th> non-transparent     <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #transparentScope} <\/th><th> transparent     <\/th><th> transparent                                 <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ * <\/table>\n+ *\n+ * <p>\n+ * In some cases, we may be deeper nested in templates and scopes, and would like to reach \"back\" or\n+ * to outer scopes. This is possible with {@link Hook#anchor}ing in some outer scope, and later\n+ * {@link Hook#insert}ing from an inner scope to the scope of the anchoring. For example, while\n+ * generating code in a method, one can reach out to the scope of the class, and insert a new field,\n+ * or define a utility method.\n@@ -228,1 +235,2 @@\n- * Let us look at the following example to better understand the execution order.\n+ * A {@link TemplateBinding} allows the recursive use of Templates. With the indirection of such a binding,\n+ * a Template can reference itself.\n@@ -231,38 +239,25 @@\n- * {@snippet lang=java :\n- * var testTemplate = Template.make(() -> body(\n- *     \/\/ The lambda has just been invoked.\n- *     \/\/ We count the DataNames and assign the count to the hashtag replacement \"c1\".\n- *     let(\"c1\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ We want to define a DataName \"v1\", and create a token for it.\n- *     addDataName($(\"v1\"), someType, MUTABLE),\n- *     \/\/ We count the DataNames again, but the count does NOT change compared to \"c1\".\n- *     \/\/ This is because the token for \"v1\" is only evaluated later.\n- *     let(\"c2\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ Create a nested scope.\n- *     METHOD_HOOK.anchor(\n- *         \/\/ We want to define a DataName \"v2\", which is only valid inside this\n- *         \/\/ nested scope.\n- *         addDataName($(\"v2\"), someType, MUTABLE),\n- *         \/\/ The count is still not different to \"c1\".\n- *         let(\"c3\", dataNames(MUTABLE).exactOf(someType).count()),\n- *         \/\/ We nest a Template. This creates a TemplateToken, which is later evaluated.\n- *         \/\/ By the time the TemplateToken is evaluated, the tokens from above will\n- *         \/\/ be already evaluated. Hence, \"v1\" and \"v2\" are added by then, and if the\n- *         \/\/ \"otherTemplate\" were to count the DataNames, the count would be increased\n- *         \/\/ by 2 compared to \"c1\".\n- *         otherTemplate.asToken()\n- *     ),\n- *     \/\/ After closing the scope, \"v2\" is no longer available.\n- *     \/\/ The count is still the same as \"c1\", since \"v1\" is still only a token.\n- *     let(\"c4\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ We nest another Template. Again, this creates a TemplateToken, which is only\n- *     \/\/ evaluated later. By that time, the token for \"v1\" is evaluated, and so the\n- *     \/\/ nested Template would observe an increment in the count.\n- *     anotherTemplate.asToken()\n- *     \/\/ By this point, all methods are called, and the tokens generated.\n- *     \/\/ The lambda returns the \"body\", which is all of the tokens that we just\n- *     \/\/ generated. After returning from the lambda, the tokens will be evaluated\n- *     \/\/ one by one.\n- * ));\n- * }\n-\n+ * The writer of recursive {@link Template}s must ensure that this recursion terminates. To unify the\n+ * approach across {@link Template}s, we introduce the concept of {@link #fuel}. Templates are rendered starting\n+ * with a limited amount of {@link #fuel} (default: 100, see {@link #DEFAULT_FUEL}), which is decreased at each\n+ * Template nesting by a certain amount (default: 10, see {@link #DEFAULT_FUEL_COST}). The default fuel for a\n+ * template can be changed when we {@code render()} it (e.g. {@link ZeroArgs#render(float)}) and the default\n+ * fuel cost with {@link #setFuelCost}) when defining the {@link #scope(Object...)}. Recursive templates are\n+ * supposed to terminate once the {@link #fuel} is depleted (i.e. reaches zero).\n+ *\n+ * <p>\n+ * A note from the implementor to the user: We have decided to implement the Template Framework using\n+ * a functional (lambdas) and data-oriented (tokens) model. The consequence is that there are three\n+ * orders in template rendering: (1) the execution order in lambdas, where we usually assemble the\n+ * tokens and pass them to some scope ({@link ScopeToken}) as arguments. (2) the token evaluation\n+ * order, which occurs in the order of how tokens are listed in a scope. By design, the token order\n+ * is the same order as execution in lambdas. To keep the lambda and token order in sync, most of the\n+ * queries about the state of code generation, such as {@link DataName}s and {@link Hook}s cannot\n+ * return the values immediately, but have to be expressed as tokens. If we had a mix of tokens and\n+ * immediate queries, then the immediate queries would \"float\" by the tokens, because the immediate\n+ * queries are executed during the lambda execution, but the tokens are only executed later. Having\n+ * to express everything as tokens can be a little more cumbersome (e.g. sample requires a lambda\n+ * that captures the {@link DataName}, and sample does not return the {@link DataName} directly).\n+ * But this ensures that reasoning about execution order is relatively straight forward, namely in\n+ * the order of the specified tokens. (3) the final code order is the same as the lambda and token\n+ * order, except when using {@link Hook#insert}, which places the code at the innermost {@link Hook#anchor}.\n+ *\n@@ -284,1 +279,1 @@\n-     * @param function The {@link Supplier} that creates the {@link TemplateBody}.\n+     * @param function The {@link Supplier} that creates the {@link ScopeToken}.\n@@ -286,2 +281,2 @@\n-    record ZeroArgs(Supplier<TemplateBody> function) implements Template {\n-        TemplateBody instantiate() {\n+    record ZeroArgs(Supplier<ScopeToken> function) implements Template {\n+        ScopeToken instantiate() {\n@@ -327,1 +322,1 @@\n-     * @param function The {@link Function} that creates the {@link TemplateBody} given the template argument.\n+     * @param function The {@link Function} that creates the {@link ScopeToken} given the template argument.\n@@ -329,2 +324,2 @@\n-    record OneArg<T1>(String arg1Name, Function<T1, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1) {\n+    record OneArg<T1>(String arg1Name, Function<T1, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1) {\n@@ -375,1 +370,1 @@\n-     * @param function The {@link BiFunction} that creates the {@link TemplateBody} given the template arguments.\n+     * @param function The {@link BiFunction} that creates the {@link ScopeToken} given the template arguments.\n@@ -377,2 +372,2 @@\n-    record TwoArgs<T1, T2>(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1, T2 arg2) {\n+    record TwoArgs<T1, T2>(String arg1Name, String arg2Name, BiFunction<T1, T2, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1, T2 arg2) {\n@@ -450,1 +445,1 @@\n-     * @param function The function with three arguments that creates the {@link TemplateBody} given the template arguments.\n+     * @param function The function with three arguments that creates the {@link ScopeToken} given the template arguments.\n@@ -452,2 +447,2 @@\n-    record ThreeArgs<T1, T2, T3>(String arg1Name, String arg2Name, String arg3Name, TriFunction<T1, T2, T3, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1, T2 arg2, T3 arg3) {\n+    record ThreeArgs<T1, T2, T3>(String arg1Name, String arg2Name, String arg3Name, TriFunction<T1, T2, T3, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1, T2 arg2, T3 arg3) {\n@@ -499,1 +494,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -504,1 +499,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -511,1 +506,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -514,2 +509,2 @@\n-    static Template.ZeroArgs make(Supplier<TemplateBody> body) {\n-        return new Template.ZeroArgs(body);\n+    static Template.ZeroArgs make(Supplier<ScopeToken> scope) {\n+        return new Template.ZeroArgs(scope);\n@@ -520,1 +515,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -528,1 +523,1 @@\n-     * var template = Template.make(\"a\", (Integer a) -> body(\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n@@ -537,1 +532,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -542,2 +537,2 @@\n-    static <T1> Template.OneArg<T1> make(String arg1Name, Function<T1, TemplateBody> body) {\n-        return new Template.OneArg<>(arg1Name, body);\n+    static <T1> Template.OneArg<T1> make(String arg1Name, Function<T1, ScopeToken> scope) {\n+        return new Template.OneArg<>(arg1Name, scope);\n@@ -548,1 +543,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -556,1 +551,1 @@\n-     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> body(\n+     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> scope(\n@@ -565,1 +560,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -572,2 +567,2 @@\n-    static <T1, T2> Template.TwoArgs<T1, T2> make(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> body) {\n-        return new Template.TwoArgs<>(arg1Name, arg2Name, body);\n+    static <T1, T2> Template.TwoArgs<T1, T2> make(String arg1Name, String arg2Name, BiFunction<T1, T2, ScopeToken> scope) {\n+        return new Template.TwoArgs<>(arg1Name, arg2Name, scope);\n@@ -578,1 +573,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -581,1 +576,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -590,2 +585,2 @@\n-    static <T1, T2, T3> Template.ThreeArgs<T1, T2, T3> make(String arg1Name, String arg2Name, String arg3Name, Template.TriFunction<T1, T2, T3, TemplateBody> body) {\n-        return new Template.ThreeArgs<>(arg1Name, arg2Name, arg3Name, body);\n+    static <T1, T2, T3> Template.ThreeArgs<T1, T2, T3> make(String arg1Name, String arg2Name, String arg3Name, Template.TriFunction<T1, T2, T3, ScopeToken> scope) {\n+        return new Template.ThreeArgs<>(arg1Name, arg2Name, arg3Name, scope);\n@@ -595,3 +590,20 @@\n-     * Creates a {@link TemplateBody} from a list of tokens, which can be {@link String}s,\n-     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}), any {@link Token},\n-     * or {@link List}s of any of these.\n+     * Creates a {@link ScopeToken} that represents a scope that is completely\n+     * non-transparent, <strong>not<\/strong> allowing anything to escape. This\n+     * means that no {@link DataName}, {@link StructuralName}s, hashtag-replacement\n+     * or {@link #setFuelCost} defined inside the scope is available outside. All\n+     * these usages are only local to the defining scope here.\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is either fully transparent (i.e. everything escapes)\n+     * or only restricts a specific kind to not escape, consider using one of the other\n+     * provided scopes: {@link #transparentScope}, {@link #nameScope}, {@link #hashtagScope},\n+     * or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can also be found in\n+     * the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * The most common use of {@link #scope} is in the construction of templates:\n@@ -601,1 +613,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -611,0 +623,36 @@\n+     * <p>\n+     * Note that regardless of the chosen scope for {@code Template.make},\n+     * hashtag-replacements and {@link #setFuelCost} are always implicitly\n+     * non-transparent (i.e. non-escaping). For example, {@link #let} will\n+     * not escape the template scope even when using {@link #transparentScope}.\n+     * As a default, it is recommended to use {@link #scope} for\n+     * {@code Template.make} since in most cases template scopes align with\n+     * code scopes that are non-transparent for fields, variables, etc. In\n+     * rare cases, where the scope of the template needs to be transparent\n+     * (e.g. because we need to insert a variable or field into an outer scope),\n+     * it is recommended to use {@link #transparentScope}. This allows to make\n+     * {@link DataName}s and {@link StructuralName}s available outside this\n+     * template crossing the template boundary.\n+     *\n+     * <p>\n+     * We can also use nested scopes inside of templates:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     \/\/ CODE1: some code in the outer scope\n+     *     scope(\n+     *       \/\/ CODE2: some code in the inner scope. Names, hashtags and setFuelCost\n+     *       \/\/        do not escape the inner scope.\n+     *     ),\n+     *     \/\/ CODE3: more code in the outer scope, names and hashtags from CODE2 are\n+     *     \/\/        not available anymore because of the non-transparent \"scope\".\n+     *     transparentScope(\n+     *       \/\/ CODE4: some code in the inner \"transparentScope\". Names, hashtags and setFuelCost\n+     *       \/\/        escape the \"transparentScope\" and are still available after the \"transparentScope\"\n+     *       \/\/        closes.\n+     *     )\n+     *     \/\/ CODE5: we still have access to names and hashtags from CODE4.\n+     * ));\n+     * }\n+     *\n@@ -614,1 +662,1 @@\n-     * @return The {@link TemplateBody} which captures the list of validated {@link Token}s.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n@@ -617,2 +665,152 @@\n-    static TemplateBody body(Object... tokens) {\n-        return new TemplateBody(TokenParser.parse(tokens));\n+    static ScopeToken scope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), false, false, false);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a completely transparent scope.\n+     * This means that {@link DataName}s, {@link StructuralName}s,\n+     * hashtag-replacements and {@link #setFuelCost} declared inside the scope will be available\n+     * in the outer scope.\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is non-transparent (i.e. nothing escapes) or only restricts\n+     * a specific kind to not escape, consider using one of the other provided scopes:\n+     * {@link #scope}, {@link #nameScope}, {@link #hashtagScope}, or {@link #setFuelCostScope}.\n+     * A \"scope-transparency-matrix\" can also be found in the interface comment for {@link Template}.\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken transparentScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, true, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * {@link DataName}s and {@link StructuralName}s (i.e. cannot escape), but\n+     * transparent for hashtag-replacements and {@link #setFuelCost} (i.e. available\n+     * in outer scope).\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #hashtagScope}, or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken nameScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), false, true, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * hashtag-replacements (i.e. cannot escape), but transparent for {@link DataName}s\n+     * and {@link StructuralName}s and {@link #setFuelCost} (i.e. available in outer scope).\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #nameScope}, or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * Keeping hashtag-replacements local but letting {@link DataName}s escape can be\n+     * useful in cases like the following, where we may want to reuse the hashtag\n+     * multiple times:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     List.of(\"a\", \"b\", \"c\").stream().map(name -> hashtagScope(\n+     *         let(\"name\", name), \/\/ assumes values: a, b, c\n+     *         addDataName(name, PrimitiveType.INTS, MUTABLE), \/\/ escapes\n+     *         \"\"\"\n+     *         int #name = 42;\n+     *         \"\"\"\n+     *     ))\n+     *     \/\/ We still have access to the three DataNames.\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken hashtagScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, false, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * {@link #setFuelCost} (i.e. cannot escape), but transparent for hashtag-replacements,\n+     * {@link DataName}s and {@link StructuralName}s (i.e. available in outer scope).\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #hashtagScope}, or {@link #nameScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * In some cases, it can be helpful to have different {@link #setFuelCost} within\n+     * a single template, depending on the code nesting depth. Example:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     setFuelCost(1),\n+     *     \/\/ CODE1: some shallow code, allowing recursive template uses here\n+     *     \/\/        to use more fuel.\n+     *     \"\"\"\n+     *     for (int i = 0; i < 1000; i++) {\n+     *     \"\"\",\n+     *     setFuelCostScope(\n+     *         setFuelCost(100)\n+     *         \/\/ CODE2: with the for-loop, we already have a deeper nesting\n+     *         \/\/        depth, and recursive template uses should not get\n+     *         \/\/        as much fuel as in CODE1.\n+     *     ),\n+     *     \"\"\"\n+     *     }\n+     *     \"\"\"\n+     *     \/\/ CODE3: we are back in the outer scope of CODE1, and can use\n+     *     \/\/        more fuel again in nested template uses. setFuelCost\n+     *     \/\/        is automatically restored to what was set before the\n+     *     \/\/        inner scope.\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken setFuelCostScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, true, false);\n@@ -631,1 +829,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -643,0 +841,3 @@\n+        \/\/ Note, since the dollar replacements do not change within a template\n+        \/\/ and the retrieval has no side effects, we can return the value immediately,\n+        \/\/ and do not need a token.\n@@ -651,1 +852,1 @@\n-     * var template = Template.make(\"a\", (Integer a) -> body(\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n@@ -659,0 +860,9 @@\n+     * <p>\n+     * Note that a {@code let} definition makes the hashtag replacement available\n+     * for anything that follows it, until the the end of the next outer scope\n+     * that is non-transparent for hashtag replacements. Additionally, hashtag\n+     * replacements are limited to the template they were defined in.\n+     * If you want to pass values from an outer to an inner template, this cannot\n+     * be done with hashtags directly. Instead, one has to pass the values via\n+     * template arguments.\n+     *\n@@ -661,3 +871,1 @@\n-     * @return A token that does nothing, so that the {@link #let} can easily be put in a list of tokens\n-     *         inside a {@link Template#body}.\n-     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     * @return A token that represents the hashtag replacement definition.\n@@ -666,2 +874,1 @@\n-        Renderer.getCurrent().addHashtagReplacement(key, value);\n-        return new NothingToken();\n+        return new LetToken(key, value, v -> transparentScope());\n@@ -672,1 +879,4 @@\n-     * by the provided {@code function} with type {@code <T>}.\n+     * by the provided {@code function} with type {@code <T>}. While the argument of the lambda that\n+     * captures the value is naturally bounded to the scope of the lambda, the hashtag replacement\n+     * may be bound to the scope or escape it, depending on the choice of scope, see {@link #scope}\n+     * and {@link #transparentScope}.\n@@ -676,6 +886,8 @@\n-     * var template = Template.make(\"a\", (Integer a) -> let(\"b\", a * 2, (Integer b) -> body(\n-     *     \"\"\"\n-     *     System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n-     *     \"\"\",\n-     *     \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n-     * )));\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n+     *     let(\"b\", a * 2, (Integer b) -> scope(\n+     *         \"\"\"\n+     *         System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n+     *         \"\"\",\n+     *         \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n+     *     ))\n+     * ));\n@@ -688,2 +900,1 @@\n-     * @return A {@link TemplateBody}.\n-     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     * @return A {@link Token} representing the hashtag replacement definition and inner scope.\n@@ -691,3 +902,2 @@\n-    static <T> TemplateBody let(String key, T value, Function<T, TemplateBody> function) {\n-        Renderer.getCurrent().addHashtagReplacement(key, value);\n-        return function.apply(value);\n+    static <T> Token let(String key, T value, Function<T, ScopeToken> function) {\n+        return new LetToken(key, value, function);\n@@ -705,1 +915,1 @@\n-     * with {@link #setFuelCost(float)} inside {@link #body(Object...)}.\n+     * with {@link #setFuelCost(float)} inside {@link #scope(Object...)}.\n@@ -724,1 +934,1 @@\n-     * var template = Template.make(\"depth\", (Integer depth) -> body(\n+     * var template = Template.make(\"depth\", (Integer depth) -> scope(\n@@ -740,0 +950,3 @@\n+        \/\/ Note, since the fuel amount does not change within a template\n+        \/\/ and the retrieval has no side effects, we can return the value immediately,\n+        \/\/ and do not need a token.\n@@ -748,1 +961,1 @@\n-     * @return A token for convenient use in {@link Template#body}.\n+     * @return A token for convenient use in {@link Template#scope}.\n@@ -751,2 +964,1 @@\n-        Renderer.getCurrent().setFuelCost(fuelCost);\n-        return new NothingToken();\n+        return new SetFuelCostToken(fuelCost);\n@@ -756,2 +968,4 @@\n-     * Add a {@link DataName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}.\n+     * Add a {@link DataName} in the current {@link #scope}.\n+     * If the current scope is transparent to {@link DataName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addDataName} until the end of that non-transparent scope.\n@@ -782,2 +996,4 @@\n-     * Add a {@link DataName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     * Add a {@link DataName} in the current {@link #scope}, with a {@code weight} of 1.\n+     * If the current scope is transparent to {@link DataName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addDataName} until the end of that non-transparent scope.\n@@ -807,2 +1023,4 @@\n-     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}.\n+     * Add a {@link StructuralName} in the current {@link #scope}.\n+     * If the current scope is transparent to {@link StructuralName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addStructuralName} until the end of that non-transparent scope.\n@@ -825,2 +1043,4 @@\n-     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     * Add a {@link StructuralName} in the current {@link #scope}, with a {@code weight} of 1.\n+     * If the current scope is transparent to {@link StructuralName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addStructuralName} until the end of that non-transparent scope.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":365,"deletions":145,"binary":false,"changes":510,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.template_framework;\n-\n-import java.util.List;\n-\n-\/**\n- * A Template generates a {@link TemplateBody}, which is a list of {@link Token}s,\n- * which are then later rendered to {@link String}s.\n- *\n- * @param tokens The list of {@link Token}s that are later rendered to {@link String}s.\n- *\/\n-public record TemplateBody(List<Token> tokens) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBody.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -30,8 +30,6 @@\n- * The {@link TemplateFrame} is the frame for a {@link Template}, i.e. the corresponding\n- * {@link TemplateToken}. It ensures that each template use has its own unique {@link #id}\n- * used to deconflict names using {@link Template#$}. It also has a set of hashtag\n- * replacements, which combine the key-value pairs from the template argument and the\n- * {@link Template#let} definitions. The {@link #parent} relationship provides a trace\n- * for the use chain of templates. The {@link #fuel} is reduced over this chain, to give\n- * a heuristic on how much time is spent on the code from the template corresponding to\n- * the frame, and to give a termination criterion to avoid nesting templates too deeply.\n+ * The {@link TemplateFrame} keeps track of the nested hashtag replacements available\n+ * inside the {@link Template}, as well as the unique id of the {@link Template} use,\n+ * and how much fuel is available for recursive {@link Template} calls. The name of\n+ * the {@link TemplateFrame} indicates that it corresponds to the structure of the\n+ * {@link Template}, whereas the {@link CodeFrame} corresponds to the structure of\n+ * the generated code.\n@@ -40,1 +38,39 @@\n- * See also {@link CodeFrame} for more explanations about the frames.\n+ * The unique id is used to deconflict names using {@link Template#$}.\n+ *\n+ * <p>\n+ * A {@link Template} can have multiple {@link TemplateFrame}s, if there are nested\n+ * scopes. The outermost {@link TemplateFrame} determines the id of the {@link Template}\n+ * use and performs the subtraction of fuel from the outer {@link Template}. Inner\n+ * {@link TemplateFrame}s ensure the correct availability of hashtag replacement and\n+ * {@link Template#setFuelCost} definitions, so that they are local to their scope and\n+ * nested scopes, and only escape if the scope is transparent.\n+ *\n+ * <p>\n+ * The hashtag replacements are a set of key-value pairs from the template arguments\n+ * and queries such as {@link Template#let} definitions. Each {@link TemplateFrame}\n+ * has such a set of hashtag replacements, and implicitly provides access to the\n+ * hashtag replacements of the outer {@link TemplateFrame}s, up to the outermost\n+ * of the current {@link Template}. If a hashtag replacement is added in a scope,\n+ * we have to traverse to outer scopes until we find one that is not transparent\n+ * for hashtags (at most it is the frame of the Template), and insert it there.\n+ * The hashtag replacent is local to that frame, and accessible for any frames nested\n+ * inside it, but not inside other Templates. The hashtag replacement disappears once\n+ * the corresponding scope is exited, i.e. the frame removed.\n+ *\n+ * <p>\n+ * The {@link #parent} relationship provides a trace for the use chain of templates and\n+ * their inner scopes. The {@link #fuel} is reduced over this chain to give a heuristic\n+ * on how deeply nested the code is at a given point, correlating to the runtime that\n+ * would be spent if the code was executed. The idea is that once the fuel is depleated,\n+ * we do not want to nest more deeply, so that there is a reasonable chance that the\n+ * execution of the generated code can terminate.\n+ *\n+ * <p>\n+ * The {@link TemplateFrame} thus implements the hashtag and {@link Template#setFuelCost}\n+ * non-transparency aspect of {@link ScopeToken}.\n+ *\n+ * <p>\n+ * See also {@link CodeFrame} for more explanations about the frames. Note, that while\n+ * {@link TemplateFrame} always nests inward, even with {@link Hook#insert}, the\n+ * {@link CodeFrame} can also jump to the {@link Hook#anchor} {@link CodeFrame} when\n+ * using {@link Hook#insert}.\n@@ -44,0 +80,1 @@\n+    private final boolean isInnerScope;\n@@ -48,0 +85,2 @@\n+    private final boolean isTransparentForHashtag;\n+    private final boolean isTransparentForFuel;\n@@ -50,1 +89,1 @@\n-        return new TemplateFrame(null, id, fuel, 0.0f);\n+        return new TemplateFrame(null, false, id, fuel, 0.0f, false, false);\n@@ -54,1 +93,2 @@\n-        return new TemplateFrame(parent, id, parent.fuel - parent.fuelCost, Template.DEFAULT_FUEL_COST);\n+        float fuel = parent.fuel - parent.fuelCost;\n+        return new TemplateFrame(parent, false, id, fuel, Template.DEFAULT_FUEL_COST, false, false);\n@@ -57,1 +97,16 @@\n-    private TemplateFrame(TemplateFrame parent, int id, float fuel, float fuelCost) {\n+    public static TemplateFrame makeInnerScope(TemplateFrame parent,\n+                                               boolean isTransparentForHashtag,\n+                                               boolean isTransparentForFuel) {\n+        \/\/ We keep the id of the parent, so that we have the same dollar replacements.\n+        \/\/ And we subtract no fuel, but forward the cost.\n+        return new TemplateFrame(parent, true, parent.id, parent.fuel, parent.fuelCost,\n+                                 isTransparentForHashtag, isTransparentForFuel);\n+    }\n+\n+    private TemplateFrame(TemplateFrame parent,\n+                          boolean isInnerScope,\n+                          int id,\n+                          float fuel,\n+                          float fuelCost,\n+                          boolean isTransparentForHashtag,\n+                          boolean isTransparentForFuel) {\n@@ -59,0 +114,1 @@\n+        this.isInnerScope = isInnerScope;\n@@ -62,0 +118,2 @@\n+        this.isTransparentForHashtag = isTransparentForHashtag;\n+        this.isTransparentForFuel = isTransparentForFuel;\n@@ -81,2 +139,9 @@\n-        if (hashtagReplacements.putIfAbsent(key, value) != null) {\n-            throw new RendererException(\"Duplicate hashtag replacement for #\" + key);\n+        String previous = findHashtagReplacementInScopes(key);\n+        if (previous != null) {\n+            throw new RendererException(\"Duplicate hashtag replacement for #\" + key + \". \" +\n+                                        \"previous: \" + previous + \", new: \" + value);\n+        }\n+        if (isTransparentForHashtag) {\n+            parent.addHashtagReplacement(key, value);\n+        } else {\n+            hashtagReplacements.put(key, value);\n@@ -90,0 +155,8 @@\n+        String value = findHashtagReplacementInScopes(key);\n+        if (value != null) {\n+            return value;\n+        }\n+        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+    }\n+\n+    private String findHashtagReplacementInScopes(String key) {\n@@ -93,1 +166,4 @@\n-        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+        if (!isInnerScope) {\n+            return null;\n+        }\n+        return parent.findHashtagReplacementInScopes(key);\n@@ -98,0 +174,3 @@\n+        if (isTransparentForFuel) {\n+            parent.setFuelCost(fuelCost);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":94,"deletions":15,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -77,1 +77,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -107,1 +107,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -141,1 +141,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -153,1 +153,1 @@\n-    abstract TemplateBody instantiate();\n+    abstract ScopeToken instantiate();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateToken.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * The {@link Template#scope} and {@link Hook#anchor} are given a list of tokens, which are either\n@@ -31,9 +31,18 @@\n-                               TemplateToken,\n-                               TemplateToken.ZeroArgs,\n-                               TemplateToken.OneArg,\n-                               TemplateToken.TwoArgs,\n-                               TemplateToken.ThreeArgs,\n-                               HookAnchorToken,\n-                               HookInsertToken,\n-                               AddNameToken,\n-                               NothingToken {}\n+                                      TemplateToken,\n+                                      TemplateToken.ZeroArgs,\n+                                      TemplateToken.OneArg,\n+                                      TemplateToken.TwoArgs,\n+                                      TemplateToken.ThreeArgs,\n+                                      HookAnchorToken,\n+                                      HookInsertToken,\n+                                      HookIsAnchoredToken,\n+                                      AddNameToken,\n+                                      NameSampleToken,\n+                                      NameForEachToken,\n+                                      NamesToListToken,\n+                                      NameCountToken,\n+                                      NameHasAnyToken,\n+                                      LetToken,\n+                                      ScopeToken,\n+                                      ScopeTokenImpl,\n+                                      SetFuelCostToken {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * The {@link Template#scope} and {@link Hook#anchor} are given a list of tokens, which are either\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TokenParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -360,1 +360,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Expression.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -193,1 +193,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -54,1 +54,1 @@\n-     * This method renders a list of {@code testTemplateTokens} into the body of a class\n+     * This method renders a list of {@code testTemplateTokens} into the scope of a class\n@@ -84,1 +84,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -99,1 +99,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -111,1 +111,1 @@\n-            ),\n+            )),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -336,1 +336,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -352,1 +352,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -368,1 +368,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -613,1 +613,1 @@\n-                return body(\n+                return scope(\n@@ -665,1 +665,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -679,1 +679,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -701,1 +701,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -712,1 +712,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -744,1 +744,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -756,1 +756,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -768,1 +768,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -787,1 +787,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -801,1 +801,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -835,1 +835,1 @@\n-            var templateSplitRanges = Template.make(() -> body(\n+            var templateSplitRanges = Template.make(() -> scope(\n@@ -868,1 +868,1 @@\n-            var templateWholeRanges = Template.make(() -> body(\n+            var templateWholeRanges = Template.make(() -> scope(\n@@ -876,1 +876,1 @@\n-            var templateRandomRanges = Template.make(() -> body(\n+            var templateRandomRanges = Template.make(() -> scope(\n@@ -886,1 +886,1 @@\n-            var templateSmallOverlapRanges = Template.make(() -> body(\n+            var templateSmallOverlapRanges = Template.make(() -> scope(\n@@ -910,1 +910,1 @@\n-            var templateAnyRanges = Template.make(() -> body(\n+            var templateAnyRanges = Template.make(() -> scope(\n@@ -920,1 +920,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -944,1 +944,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -952,1 +952,1 @@\n-                    Template.make(() -> body(\n+                    Template.make(() -> scope(\n@@ -993,1 +993,1 @@\n-                                Template.make(() -> body(\n+                                Template.make(() -> scope(\n@@ -1024,1 +1024,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1037,1 +1037,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1097,1 +1097,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1148,1 +1148,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1161,1 +1161,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1172,1 +1172,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1183,1 +1183,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1233,1 +1233,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1248,1 +1248,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1268,1 +1268,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -99,1 +99,1 @@\n-        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> scope(\n@@ -119,1 +119,1 @@\n-        var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+        var classTemplate = Template.make(\"types\", (List<Type> types) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -81,1 +81,1 @@\n-            return body(\n+            return scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n@@ -80,1 +81,1 @@\n-        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> scope(\n@@ -102,1 +103,1 @@\n-        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> scope(\n@@ -132,1 +133,5 @@\n-        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+        \/\/ IMPORTANT: since we are adding the DataName via an inserted Template, we\n+        \/\/            must chose a \"transparentScope\", so that the DataName escapes. If we\n+        \/\/            instead chose \"scope\", the test would fail, because it later\n+        \/\/            finds no DataNames when we sample.\n+        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> transparentScope(\n@@ -134,1 +139,1 @@\n-            addDataName($(\"var\"), type, MUTABLE),\n+            addDataName($(\"var\"), type, MUTABLE), \/\/ escapes the Template\n@@ -140,2 +145,1 @@\n-        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n-            let(\"var\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> scope(\n@@ -143,0 +147,1 @@\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"var\"),\n@@ -148,1 +153,1 @@\n-        var namesTemplate = Template.make(() -> body(\n+        var namesTemplate = Template.make(() -> scope(\n@@ -152,1 +157,1 @@\n-            Hooks.METHOD_HOOK.anchor(\n+            Hooks.METHOD_HOOK.anchor(scope(\n@@ -164,1 +169,1 @@\n-            ),\n+            )),\n@@ -175,1 +180,1 @@\n-        var libraryRNGWithTypeTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+        var libraryRNGWithTypeTemplate = Template.make(\"type\", (PrimitiveType type) -> scope(\n@@ -199,1 +204,1 @@\n-        var libraryRNGTemplate = Template.make(() -> body(\n+        var libraryRNGTemplate = Template.make(() -> scope(\n@@ -216,1 +221,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -64,1 +64,1 @@\n-        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> body(\n+        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestSimple.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n+import static compiler.lib.template_framework.Template.hashtagScope;\n@@ -71,0 +73,1 @@\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3c\", generateWithHashtagAndDollarReplacements3());\n@@ -76,2 +79,2 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithDataNamesAndScopes1());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithDataNamesAndScopes2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithScopes2());\n@@ -94,0 +97,1 @@\n+        comp.invoke(\"p.xyz.InnerTest3c\", \"main\", new Object[] {});\n@@ -108,3 +112,3 @@\n-        \/\/ token body, which is a list of Tokens that are concatenated.\n-        var templateClass = Template.make(() -> body(\n-            \/\/ The \"body\" method is filled by a sequence of \"Tokens\".\n+        \/\/ scope, which contains a list of Tokens that are concatenated.\n+        var templateClass = Template.make(() -> scope(\n+            \/\/ The \"scope\" arguments are a sequence of \"Tokens\".\n@@ -144,1 +148,1 @@\n-        var templateHello = Template.make(() -> body(\n+        var templateHello = Template.make(() -> scope(\n@@ -151,1 +155,1 @@\n-        var templateCompare = Template.make(\"arg\", (Integer arg) -> body(\n+        var templateCompare = Template.make(\"arg\", (Integer arg) -> scope(\n@@ -159,1 +163,1 @@\n-            \/\/ 1) By appending to the comma-separated list of Tokens passed to body().\n+            \/\/ 1) By appending to the comma-separated list of Tokens passed to scope().\n@@ -183,1 +187,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -207,0 +211,8 @@\n+    \/\/\n+    \/\/ Important: hashtag replacements are always constrained to a single template\n+    \/\/            and are not available in any nested templates. Hashtag replacements\n+    \/\/            are only there to facilitate string templating within the limited\n+    \/\/            scope of a template. You may consider it like a \"local variable\"\n+    \/\/            for code generation purposes only.\n+    \/\/            If you need to pass some value to a nested Template, consider using\n+    \/\/            a Template argument, and capturing that Template argument.\n@@ -208,1 +220,1 @@\n-        var template1 = Template.make(\"x\", (Integer x) -> body(\n+        var template1 = Template.make(\"x\", (Integer x) -> scope(\n@@ -222,1 +234,1 @@\n-        var template2 = Template.make(\"x\", (Integer x) ->\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n@@ -225,9 +237,7 @@\n-            let(\"y\", 11 * x, y ->\n-                body(\n-                    \"\"\"\n-                    System.out.println(\"T2: #x, #y\");\n-                    \"\"\",\n-                    template1.asToken(y)\n-                )\n-            )\n-        );\n+            let(\"y\", 11 * x, y -> scope(\n+                \"\"\"\n+                System.out.println(\"T2: #x, #y\");\n+                \"\"\",\n+                template1.asToken(y)\n+            ))\n+        ));\n@@ -238,1 +248,1 @@\n-        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> scope(\n@@ -244,1 +254,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -255,1 +265,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -303,1 +313,1 @@\n-        var template1 = Template.make(\"type\", (String type) -> body(\n+        var template1 = Template.make(\"type\", (String type) -> scope(\n@@ -312,1 +322,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -334,0 +344,139 @@\n+    \/\/ We already have used \"scope\" multiple times, but not explained it yet.\n+    \/\/ So far, we have seen \"scope\" mostly in the context of Template scopes, but they\n+    \/\/ can be used in many contexts as we will see below. They can also be used on\n+    \/\/ their own and in the use of \"let\", as we will show right now.\n+    \/\/\n+    \/\/ Scopes are even more relevant for DataNames and Structural names.\n+    \/\/ See: generateWithDataNamesForFieldsAndVariables\n+    \/\/ See: generateWithScopes1\n+    \/\/ See: generateWithScopes2\n+    public static String generateWithHashtagAndDollarReplacements3() {\n+\n+        var template1 = Template.make(() -> scope(\n+            \/\/ We can use scopes to limit the liveness of hashtag replacements.\n+            scope(\n+                let(\"x\", 3), \/\/ does not escape\n+                \"\"\"\n+                static int v1_3 = #x;\n+                \"\"\"\n+            ),\n+            scope(\n+                let(\"x\", 5), \/\/ does not escape\n+                \"\"\"\n+                static int v1_5 = #x;\n+                \"\"\"\n+            ),\n+            \/\/ Using \"scope\" does not just limit the liveness \/ availability\n+            \/\/ of hashtag replacements, but also of DataNames, StructuralNames,\n+            \/\/ and setFuelCost. We can use \"hashtagScope\" to only limit hashtag\n+            \/\/ replacements.\n+            hashtagScope(\n+                let(\"x\", 7), \/\/ does not escape\n+                \"\"\"\n+                static int v1_7 = #x;\n+                \"\"\"\n+            ),\n+            \/\/ Using \"transparentScope\" means the scope is transparent, and the hashtag\n+            \/\/ replacements escape the scope.\n+            transparentScope(\n+                let(\"x\", 11), \/\/ escapes the \"transparentScope\".\n+                \"\"\"\n+                static int v1_11a = #x;\n+                \"\"\"\n+            ),\n+            \/\/ The hashtag replacement from the \"transparentScope\" escaped, and is\n+            \/\/ still available.\n+            \"\"\"\n+            static int v1_11b = #x;\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n+            \/\/ We can map a list of values to a list of scopes. Using a scope that is\n+            \/\/ non-transparent for hashtag replacements means that we can reuse the same\n+            \/\/ hashtag key when looping \/ streaming over multiple values.\n+            List.of(3, 5, 7).stream().map(y -> scope(\n+                let(\"y\", y), \/\/ does not escape -> allows reuse of hashtag key \"y\".\n+                \"\"\"\n+                static int v2_#{x}_#{y} = #x * #y;\n+                \"\"\"\n+            )).toList()\n+        ));\n+\n+        var template3 = Template.make(\"x\", (Integer x) -> scope(\n+            \/\/ When using a \"let\" that captures the value in a lambda argument, we have\n+            \/\/ to choose what kind of scope we generate. In most cases \"scope\" or\n+            \/\/ \"hashtagScope\" are the best, because they limit the hashtag replacement\n+            \/\/ of \"y\" to the same scope as the lambda argument.\n+            let(\"y\", x * 11, y -> scope(\n+                \"\"\"\n+                static int v3a_#{x} = #y;\n+                \"\"\"\n+            )),\n+            \/\/ But in rare cases, we may want \"y\" and some nested \"z\" to escape.\n+            let(\"y\", x * 11, y -> transparentScope(\n+                let(\"z\", y * 2),\n+                \"\"\"\n+                static int v3b_#{x} = #y - #z;\n+                \"\"\"\n+            )),\n+            \/\/ Because of the \"transparentScope\", \"y\" and \"z\" have escaped.\n+            \"\"\"\n+            static int v3c_#{x} = #y - #z;\n+            \"\"\",\n+            \/\/ Side note: We can simulate a \"let\" without lambda with a \"let\" that has a lambda.\n+            \/\/ That is not very useful, but a similar trick can be used for other queries, that\n+            \/\/ only provide a lambda version, and where we only want to use the hashtag replacement.\n+            \/\/\n+            \/\/ Below we see the standard use of \"let\", where we add a hashtag replacement for \"a\"\n+            \/\/ for the rest of the enclosing scope. We then also use a lambda version of \"let\"\n+            \/\/ with a transparent scope, which means that \"b\" escapes that scope and is also\n+            \/\/ available in the enclosing scope. In the implementation of the framework, we\n+            \/\/ actually use a \"transparentScope\", so the standard \"let\" is really just syntactic\n+            \/\/ sugar for the lambda \"let\" with \"transparentScope\".\n+            let(\"a\", -x),\n+            let(\"b\", -x, b -> transparentScope()),\n+            \"\"\"\n+            static int v3d_#{x} = #a + #b;\n+            \"\"\"\n+        ));\n+\n+        \/\/ Let's write a simple class to demonstrate that this works, i.e. produces compilable code.\n+        var templateClass = Template.make(() -> scope(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3c {\n+            \"\"\",\n+            template1.asToken(),\n+            template2.asToken(1),\n+            template2.asToken(2),\n+            template3.asToken(2),\n+            \"\"\"\n+                public static void main() {\n+                    if (v1_3 != 3 ||\n+                        v1_5 != 5 ||\n+                        v1_7 != 7 ||\n+                        v1_11a != 11 ||\n+                        v1_11b != 11 ||\n+                        v2_1_3 != 3 ||\n+                        v2_1_5 != 5 ||\n+                        v2_1_7 != 7 ||\n+                        v2_2_3 != 6 ||\n+                        v2_2_5 != 10 ||\n+                        v2_2_7 != 14 ||\n+                        v3a_2 != 22 ||\n+                        v3b_2 != -22 ||\n+                        v3c_2 != -22 ||\n+                        v3d_2 != -4) {\n+                        throw new RuntimeException(\"Wrong result!\");\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n@@ -337,0 +486,11 @@\n+    \/\/\n+    \/\/ When we insert to a hook, we have 3 relevant scopes:\n+    \/\/ - Anchor scope: the scope defined at \"hook.anchor(scope(...))\"\n+    \/\/ - Insertion scope: the scope that is inserted, see \"hook.insert(scope(...))\"\n+    \/\/ - Caller scope: the scope we insert from.\n+    \/\/\n+    \/\/ The choice of transparency of an insertion scope (the scope that is inserted) is quite\n+    \/\/ important. A common use case is to insert a DataName.\n+    \/\/ See: generateWithDataNamesForFieldsAndVariables\n+    \/\/ See: generateWithScopes1\n+    \/\/ See: generateWithScopes2\n@@ -343,1 +503,1 @@\n-        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> scope(\n@@ -349,1 +509,12 @@\n-        var template2 = Template.make(\"x\", (Integer x) -> body(\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n+            \"\"\"\n+            \/\/ Let us go back to where we anchored the hook with anchor() (see 'templateClass' below) and define a field\n+            \/\/ named $field1 there.\n+            \"\"\",\n+            myHook.insert(scope( \/\/ <- insertion scope\n+                \"\"\"\n+                public static int $field1 = #x;\n+                \"\"\"\n+                \/\/ Note that we were able to use the dollar replacement \"$field1\" and the hashtag\n+                \/\/ replacement \"#x\" inside the scope that is inserted to myHook.\n+            )),\n@@ -351,4 +522,7 @@\n-            \/\/ Let us go back to where we anchored the hook with anchor() and define a field named $field there.\n-            \/\/ Note that in the Java code we have not defined anchor() on the hook, yet. But since it's a lambda\n-            \/\/ expression, it is not evaluated, yet! Eventually, anchor() will be evaluated before insert() in\n-            \/\/ this example.\n+            \/\/ We can do that by inserting a scope like above, or by inserting a template, like below.\n+            \/\/\n+            \/\/ Which method is used is up to the user. General guidance is if the same code may also\n+            \/\/ be inserted elsewhere, one should lean towards inserting templates. But in many cases\n+            \/\/ it is nice to see the inserted code directly, and to be able to use hashtag replacements\n+            \/\/ from the outer scope directly, without having to route them via template arguments,\n+            \/\/ as we have to do below.\n@@ -356,1 +530,2 @@\n-            myHook.insert(template1.asToken($(\"field\"), x)),\n+            \/\/ <- caller scope\n+            myHook.insert(template1.asToken($(\"field2\"), x)),\n@@ -358,2 +533,4 @@\n-            System.out.println(\"$field: \" + $field);\n-            if ($field != #x) { throw new RuntimeException(\"Wrong value!\"); }\n+            System.out.println(\"$field1: \" + $field1);\n+            System.out.println(\"$field2: \" + $field2);\n+            if ($field1 != #x) { throw new RuntimeException(\"Wrong value 1!\"); }\n+            if ($field2 != #x) { throw new RuntimeException(\"Wrong value 2!\"); }\n@@ -363,1 +540,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -370,4 +547,5 @@\n-            \/\/ Anchoring a Hook creates a scope, spanning the braces of the\n-            \/\/ \"anchor\" call. Any Hook.insert that happens inside this scope\n-            \/\/ goes to the top of that scope.\n-            myHook.anchor(\n+            \/\/ Anchoring a Hook requires the definition of an inner scope,\n+            \/\/ aka the \"anchor scope\", spanning the braces of the \"anchor\" call.\n+            \/\/ Any Hook.insert that happens inside this scope goes to the top of\n+            \/\/ that scope.\n+            myHook.anchor(scope( \/\/ <- anchor scope\n@@ -376,2 +554,5 @@\n-                \/\/ <-------- field_X = 5 ------------------+\n-                \/\/ <-------- field_Y = 7 -------------+    |\n+                \/\/ <-------- field1_X = 5 -----------------+\n+                \/\/           field2_X = 5                  |\n+                \/\/                                         |\n+                \/\/ <-------- field1_Y = 7 ------------+    |\n+                \/\/           field2_Y = 7             |    |\n@@ -387,1 +568,1 @@\n-            ), \/\/ The Hook scope ends here.\n+            )), \/\/ The Hook scope ends here.\n@@ -411,13 +592,0 @@\n-        var templateStaticField = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n-            \"\"\"\n-            static { System.out.println(\"Defining static field #name\"); }\n-            public static int #name = #value;\n-            \"\"\"\n-        ));\n-\n-        var templateLocalVariable = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n-            \"\"\"\n-            System.out.println(\"Defining local variable #name\");\n-            int #name = #value;\n-            \"\"\"\n-        ));\n@@ -425,1 +593,1 @@\n-        var templateMethodBody = Template.make(() -> body(\n+        var templateMethodBody = Template.make(() -> scope(\n@@ -428,4 +596,2 @@\n-            \"\"\",\n-            Hooks.CLASS_HOOK.insert(templateStaticField.asToken($(\"field\"), 5)),\n-            Hooks.METHOD_HOOK.insert(templateLocalVariable.asToken($(\"var\"), 11)),\n-            \"\"\"\n+            \/\/ Since we are inserting them at the anchor before the code below,\n+            \/\/ they will already be available:\n@@ -434,0 +600,14 @@\n+            \"\"\",\n+            Hooks.CLASS_HOOK.insert(scope(\n+                \"\"\"\n+                static { System.out.println(\"Defining static field $field\"); }\n+                public static int $field = 5;\n+                \"\"\"\n+            )),\n+            Hooks.METHOD_HOOK.insert(scope(\n+                \"\"\"\n+                System.out.println(\"Defining local variable $var\");\n+                int $var = 11;\n+                \"\"\"\n+            )),\n+            \"\"\"\n@@ -436,0 +616,9 @@\n+            \/\/ Note: we have used \"scope\" for the \"insert\" scope. This is fine here as\n+            \/\/ we are only working with code and hashtags, but not with DataNames. If\n+            \/\/ we were to also \"addDataName\" inside the insert scope, we would have to\n+            \/\/ make sure that the scope is transparent for DataNames, so that they can\n+            \/\/ escape to the anchor scope, and can be available to the caller of the\n+            \/\/ insertion. One might want to use \"transparentScope\" for the insertion scope.\n+            \/\/ See: generateWithDataNamesForFieldsAndVariables.\n+            \/\/ See: generateWithScopes1\n+            \/\/ See: generateWithScopes2\n@@ -438,1 +627,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -445,1 +634,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -450,1 +639,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -460,1 +649,1 @@\n-                ),\n+                )),\n@@ -468,1 +657,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -476,1 +665,1 @@\n-                ),\n+                )),\n@@ -480,1 +669,1 @@\n-            ),\n+            )),\n@@ -496,1 +685,1 @@\n-        var template1 = Template.make(\"depth\", (Integer depth) -> body(\n+        var template1 = Template.make(\"depth\", (Integer depth) -> scope(\n@@ -517,1 +706,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -564,0 +753,6 @@\n+    \/\/\n+    \/\/ Note: the template library contains a lot of types that model the Java types,\n+    \/\/       such as primitive types ({@code PrimitiveType}). The following examples\n+    \/\/       give insight into how those types work. If you are just interested in\n+    \/\/       how to use the predefined types, then you can find other examples in\n+    \/\/       {@code examples\/TestPrimitiveTypes.java}.\n@@ -580,3 +775,3 @@\n-    \/\/ current scope. In a nested Template, we can then sample one of these\n-    \/\/ DataNames, which gives us one of the fields. We increment that randomly\n-    \/\/ chosen field. At the end, we print all three fields.\n+    \/\/ current scope. We can then sample some of these DataNames, which\n+    \/\/ gives us one of those fields each time. We increment those randomly\n+    \/\/ chosen fields. At the end, we print all three fields.\n@@ -584,13 +779,1 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ Sample a random DataName, i.e. field, and assign its name to\n-            \/\/ the hashtag replacement \"#f\".\n-            \/\/ We are picking a mutable DataName, because we are not just\n-            \/\/ reading but also writing to the field.\n-            let(\"f\", dataNames(MUTABLE).exactOf(mySimpleInt).sample().name()),\n-            \"\"\"\n-            \/\/ Let us now sample a random field #f, and increment it.\n-            #f += 42;\n-            \"\"\"\n-        ));\n-\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -598,1 +781,0 @@\n-            \/\/ We can then sample from these names in a nested Template.\n@@ -602,0 +784,4 @@\n+            \/\/\n+            \/\/ Also note that DataNames are only available once they are defined:\n+            \/\/\n+            \/\/ Nothing defined, yet: dataNames() = {}\n@@ -603,0 +789,1 @@\n+            \/\/ Only now dataNames() contains f1: dataNames() = {f1}\n@@ -604,0 +791,1 @@\n+            \/\/ dataNames() = {f1, f2}\n@@ -605,0 +793,1 @@\n+            \/\/ dataNames() = {f1, f2, f3}\n@@ -615,2 +804,2 @@\n-                    \/\/ Let us now call the nested template that samples\n-                    \/\/ a random field and increments it.\n+                    \/\/ Let us now sample a random field and assign its name to\n+                    \/\/ the hashtag replacement \"a\".\n@@ -618,1 +807,18 @@\n-                    templateMain.asToken(),\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sampleAndLetAs(\"a\"),\n+                    \"\"\"\n+                    \/\/ We can now access the field, and increment it.\n+                    #a += 42;\n+                    \/\/ If we are also interested in the type of the field, we can do:\n+                    \"\"\",\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sampleAndLetAs(\"b\", \"bType\"),\n+                    \"\"\"\n+                    #b += 7;\n+                    \/\/ In some cases, we may want to capture the DataName directly, which\n+                    \/\/ requires capturing the value in a lambda that creates an inner scope:\n+                    \"\"\",\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sample((DataName dn) -> scope(\n+                        let(\"c\", dn.name()),\n+                        \"\"\"\n+                        #c += 12;\n+                        \"\"\"\n+                    )),\n@@ -621,1 +827,1 @@\n-                    \/\/ one was incremented.\n+                    \/\/ ones were incremented.\n@@ -625,2 +831,2 @@\n-                    \/\/ We have two zeros, and one 42.\n-                    if ($f1 + $f2 + $f3 != 42) { throw new RuntimeException(\"wrong result!\"); }\n+                    \/\/ Make sure they add up to the correct sum.\n+                    if ($f1 + $f2 + $f3 != 42 + 7 + 12) { throw new RuntimeException(\"wrong result!\"); }\n@@ -665,2 +871,9 @@\n-        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> body(\n-            addDataName($(\"field\"), type, MUTABLE),\n+        \/\/ Note: it is very important that we use a \"transparentScope\" for the template here,\n+        \/\/       so that the DataName can escape to outer scopes, so that it is available to\n+        \/\/       everything that follows the DataName definition in the outer scope.\n+        \/\/       (We could also use \"hashtagScope\", since those are also transparent for\n+        \/\/        names. But it is not great style, because template boundaries are\n+        \/\/        non-transparent for hashtags and setFuelCost anyway. So we might as\n+        \/\/        well just use \"transparentScope\".)\n+        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> transparentScope(\n+            addDataName($(\"field\"), type, MUTABLE), \/\/ escapes template because of \"transparentScope\"\n@@ -676,2 +889,4 @@\n-        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> body(\n-            addDataName($(\"var\"), type, MUTABLE),\n+        \/\/ Note: it is very important that we use a \"transparentScope\" for the template here,\n+        \/\/       so that the DataName can escape to outer scopes.\n+        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> transparentScope(\n+            addDataName($(\"var\"), type, MUTABLE), \/\/ escapes template because of \"transparentScope\"\n@@ -685,2 +900,2 @@\n-        var templateSample = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"name\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var templateSample = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"name\"),\n@@ -695,5 +910,23 @@\n-        var templateStatus = Template.make(() -> body(\n-            let(\"ints\", dataNames(MUTABLE).exactOf(myInt).count()),\n-            let(\"longs\", dataNames(MUTABLE).exactOf(myLong).count()),\n-            \/\/ Note: we could also count the MUTABLE_OR_IMMUTABLE, we will\n-            \/\/       cover the concept of mutability in an example further down.\n+        var templateStatus = Template.make(() -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).count(ints -> scope(\n+                dataNames(MUTABLE).exactOf(myLong).count(longs -> scope(\n+                    \/\/ We have now captured the values as Java variables, and can\n+                    \/\/ use them inside the scope in some \"let\" definitions.\n+                    let(\"ints\", ints),\n+                    let(\"longs\", longs),\n+                    \/\/ Note: we could also count the MUTABLE_OR_IMMUTABLE, we will\n+                    \/\/       cover the concept of mutability in an example further down.\n+                    \"\"\"\n+                    System.out.println(\"Status: #ints ints, #longs longs.\");\n+                    \"\"\"\n+                ))\n+            )),\n+            \/\/ In a real code generation case, we would most likely want to\n+            \/\/ have the count as a Java variable so that one can take conditional\n+            \/\/ action based on the value. For that we have to capture the count\n+            \/\/ with a lambda and inner scope as above. If we only need to have\n+            \/\/ the count as a hashtag replacement, we can also use the following\n+            \/\/ trick:\n+            dataNames(MUTABLE).exactOf(myInt).count(c -> transparentScope(let(\"ints\", c))),\n+            dataNames(MUTABLE).exactOf(myLong).count(c -> transparentScope(let(\"longs\", c))),\n+            \/\/ Because of the \"transparentScope\", the hashtag replacements escape.\n@@ -706,1 +939,1 @@\n-        var templateMain = Template.make(() -> body(\n+        var templateMain = Template.make(() -> scope(\n@@ -739,1 +972,1 @@\n-        var templateOther = Template.make(() -> body(\n+        var templateOther = Template.make(() -> scope(\n@@ -758,1 +991,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -765,1 +998,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -770,1 +1003,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -780,1 +1013,1 @@\n-                ),\n+                )),\n@@ -788,1 +1021,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -796,1 +1029,1 @@\n-                ),\n+                )),\n@@ -800,1 +1033,1 @@\n-            ),\n+            )),\n@@ -810,32 +1043,16 @@\n-    \/\/ Let us have a closer look at how DataNames interact with scopes created by\n-    \/\/ Templates and Hooks. Additionally, we see how the execution order of the\n-    \/\/ lambdas and token evaluation affects the availability of DataNames.\n-    \/\/\n-    \/\/ We inject the results directly into verification inside the code, so it\n-    \/\/ is relatively simple to see what the expected results are.\n-    \/\/\n-    \/\/ For simplicity, we define a simple \"list\" function. It collects all\n-    \/\/ field and variable names, and immediately returns the comma separated\n-    \/\/ list of the names. We can use that to visualize the available names\n-    \/\/ at any point.\n-    public static String listNames() {\n-        return \"{\" + String.join(\", \", dataNames(MUTABLE).exactOf(myInt).toList()\n-                                       .stream().map(DataName::name).toList()) + \"}\";\n-    }\n-\n-    \/\/ Even simpler: count the available variables and return the count immediately.\n-    public static int countNames() {\n-        return dataNames(MUTABLE).exactOf(myInt).count();\n-    }\n-\n-    \/\/ Having defined these helper methods, let us start with the first example.\n-    \/\/ You should start reading this example bottom-up, starting at\n-    \/\/ templateClass, then going to templateMain and last to templateInner.\n-    public static String generateWithDataNamesAndScopes1() {\n-\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so \"v1\" is now available:\n-            let(\"l1\", listNames()),\n-            \"\"\"\n-            if (!\"{v1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{v1}' but was '#l1'\"); }\n+    public static String generateWithScopes1() {\n+\n+        \/\/ For the examples below, we need a convenient way of asserting the state\n+        \/\/ of the available DataNames.\n+        var templateVerify = Template.make(\"count\", \"hasAny\", \"toList\", (Integer count, Boolean hasAny, String toList) -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).count(c -> transparentScope(let(\"count2\", c))),\n+            dataNames(MUTABLE).exactOf(myInt).hasAny(h -> transparentScope(let(\"hasAny2\", h))),\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> transparentScope(\n+                let(\"toList2\", String.join(\", \", list.stream().map(DataName::name).toList()))\n+            )),\n+            \"\"\"\n+            if (#count != #count2 ||\n+                #hasAny != #hasAny2 ||\n+                !\"#toList\".equals(\"#toList2\")) {\n+                throw new RuntimeException(\"verify failed\");\n+            }\n@@ -845,10 +1062,4 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We now add a local variable \"v1\" to the scope of this templateMain.\n-            \/\/ This only generates a token, and does not immediately add the name.\n-            \/\/ The name is only added once we evaluate the tokens, and arrive at\n-            \/\/ this particular token.\n+        var templateMain = Template.make(() -> scope(\n+            \"\/\/ Start with nothing:\\n\",\n+            templateVerify.asToken(0, false, \"\"),\n+            \"\/\/ Add v1:\\n\",\n@@ -856,6 +1067,59 @@\n-            \/\/ We count again with \"c2\". The variable \"v1\" is at this point still\n-            \/\/ in token form, hence it is not yet made available while executing\n-            \/\/ the template lambda of templateMain.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"int v1 = 1;\\n\",\n+            \"\/\/ Check that it is visible:\\n\",\n+            templateVerify.asToken(1, true, \"v1\"),\n+            \"\/\/ Add v2:\\n\",\n+            addDataName(\"v2\", myInt, MUTABLE),\n+            \"int v2 = 2;\\n\",\n+            \"\/\/ Check that both are visible:\\n\",\n+            templateVerify.asToken(2, true, \"v1, v2\"),\n+\n+            \"\/\/ Create a local scope:\\n\",\n+            \"{\\n\", scope( \/\/ for consistency, we model the code and template scope together.\n+                \"\/\/ Add v3:\\n\",\n+                addDataName(\"v3\", myInt, MUTABLE),\n+                \"int v3 = 3;\\n\",\n+                \"\/\/ Check that all are visible:\\n\",\n+                templateVerify.asToken(3, true, \"v1, v2, v3\")\n+            ), \"}\\n\",\n+            \"\/\/ But after the scope, v3 is no longer available:\\n\",\n+            templateVerify.asToken(2, true, \"v1, v2\"),\n+\n+            \"\/\/ Now let's create a list of variables.\\n\",\n+            List.of(4, 5, 6).stream().map(i -> hashtagScope(\n+                \/\/ The hashtagScope allows hashtag replacements to be local,\n+                \/\/ and DataNames to escape, so we can use them afterwards.\n+                let(\"i\", i),\n+                addDataName(\"v\" + i, myInt, MUTABLE),\n+                \"int v#i = #i;\\n\"\n+            )).toList(),\n+            templateVerify.asToken(5, true, \"v1, v2, v4, v5, v6\"),\n+\n+            \"\/\/ Let's multiply all variables by a factor of 2, using forEach:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(dn -> scope(\n+                let(\"v\", dn.name()),\n+                \"#v *= 2;\\n\"\n+            )),\n+            \"\/\/ We can also capture the name (v) and type of the DataName:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"v\", \"type\", dn -> scope(\n+                \"#v *= 2;\\n\"\n+            )),\n+            \"\/\/ Yet another option is using toList, but here that is more cumbersome:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> scope(\n+                list.stream().map(dn -> scope(\n+                    let(\"v\", dn.name()),\n+                    \"#v *= 2;\\n\"\n+                )).toList()\n+            )),\n+\n+            \"\"\"\n+            \/\/ We verify the result again.\n+            \"\"\",\n+            templateVerify.asToken(5, true, \"v1, v2, v4, v5, v6\"),\n+            \"\"\"\n+            if (v1 != 1 * 8 ||\n+                v2 != 2 * 8 ||\n+                v4 != 4 * 8 ||\n+                v5 != 5 * 8 ||\n+                v6 != 6 * 8) {\n+                throw new RuntimeException(\"wrong value!\");\n+            }\n@@ -863,5 +1127,10 @@\n-            \/\/ But now we call an inner Template. This is added as a TemplateToken.\n-            \/\/ This means it is not evaluated immediately, but only once we evaluate\n-            \/\/ the tokens. By that time, all tokens from above are already evaluated\n-            \/\/ and we see that \"v1\" is available.\n-            templateInner.asToken()\n+\n+            \"\/\/ Let us copy each variable:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"v\", \"type\", dn -> hashtagScope(\n+                \/\/ Note that we need a hashtagScope here, so that we can reuse \"v\" and\n+                \/\/ \"type\" as hashtag replacements in each iteration, but still let the\n+                \/\/ copied DataNames escape.\n+                addDataName(dn.name() + \"_copy\", myInt, MUTABLE),\n+                \"#type #{v}_copy = #v;\\n\"\n+            )),\n+            templateVerify.asToken(10, true, \"v1, v2, v4, v5, v6, v1_copy, v2_copy, v4_copy, v5_copy, v6_copy\")\n@@ -870,1 +1139,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -876,1 +1145,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -880,1 +1149,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -882,1 +1151,1 @@\n-                ),\n+                )),\n@@ -886,1 +1155,1 @@\n-            ),\n+            )),\n@@ -896,4 +1165,1 @@\n-    \/\/ Now that we understand this simple example, we go to a more complicated one\n-    \/\/ where we use Hook.insert. Just as above, you should read this example\n-    \/\/ bottom-up, starting at templateClass.\n-    public static String generateWithDataNamesAndScopes2() {\n+    public static String generateWithScopes2() {\n@@ -901,44 +1167,4 @@\n-        var templateFields = Template.make(() -> body(\n-            \/\/ We were just called from templateMain. But the code is not\n-            \/\/ generated into the main scope, rather into the class scope\n-            \/\/ out in templateClass.\n-            \/\/ Let us now add a field \"f1\".\n-            addDataName(\"f1\", myInt, MUTABLE),\n-            \/\/ And let's also generate the code for it.\n-            \"\"\"\n-            public static int f1 = 42;\n-            \"\"\",\n-            \/\/ But why is this DataName now available inside the scope of\n-            \/\/ templateInner? Does that not mean that \"f1\" escapes this\n-            \/\/ templateFields here? Yes it does!\n-            \/\/ For normal template nesting, the names do not escape the\n-            \/\/ scope of the nested template. But this here is no normal\n-            \/\/ template nesting, rather it is an insertion into a Hook,\n-            \/\/ and we treat those differently. We make the scope of the\n-            \/\/ inserted templateFields transparent, so that any added\n-            \/\/ DataNames are added to the scope of the Hook we just\n-            \/\/ inserted into, i.e. the CLASS_HOOK. This is very important,\n-            \/\/ if we did not make that scope transparent, we could not\n-            \/\/ add any DataNames to the class scope anymore, and we could\n-            \/\/ not add any fields that would be available in the class\n-            \/\/ scope.\n-            Hooks.METHOD_HOOK.anchor(\n-                \/\/ We now create a separate scope. This one is not the\n-                \/\/ template scope from above, and it is not transparent.\n-                \/\/ Hence, \"f2\" will not be available outside of this\n-                \/\/ scope.\n-                addDataName(\"f2\", myInt, MUTABLE),\n-                \/\/ And let's also generate the code for it.\n-                \"\"\"\n-                public static int f2 = 666;\n-                \"\"\"\n-                \/\/ Similarly, if we called any nested Template here,\n-                \/\/ and added DataNames inside, this would happen inside\n-                \/\/ nested scopes that are not transparent. If one wanted\n-                \/\/ to add names to the CLASS_HOOK from there, one would\n-                \/\/ have to do another Hook.insert, and make sure that\n-                \/\/ the names are added from the outermost scope of that\n-                \/\/ inserted Template, because only that outermost scope\n-                \/\/ is transparent to the CLASS_HOOK.\n-            )\n-        ));\n+        \/\/ In this section, we will look at some subtle facts about the behavior of\n+        \/\/ transparent scopes around hook insertion. This is intended for expert users\n+        \/\/ so feel free to skip it until you extensively use hook insertion.\n+        \/\/ More info can also be found in the Javadocs of the Hook class.\n@@ -946,5 +1172,5 @@\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so there should be some fields available.\n-            \/\/ We can see field \"f1\".\n-            let(\"l1\", listNames()),\n+        \/\/ Helper method to check that the expected DataNames are available.\n+        var templateVerify = Template.make(\"toList\", (String toList) -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> transparentScope(\n+                let(\"toList2\", String.join(\", \", list.stream().map(DataName::name).toList()))\n+            )),\n@@ -952,1 +1178,3 @@\n-            if (!\"{f1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{f1}' but was '#l1'\"); }\n+            if (!\"#toList\".equals(\"#toList2\")) {\n+                throw new RuntimeException(\"verify failed: '#toList' vs '#toList2'.\");\n+            }\n@@ -954,2 +1182,0 @@\n-            \/\/ Now go and have a look at templateFields, to understand how that\n-            \/\/ field was added, and why not any others.\n@@ -958,24 +1184,85 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We would now like to add some fields to the class scope, out in the\n-            \/\/ templateClass. This creates a token, which is only evaluated after\n-            \/\/ the completion of the templateMain lambda. Before you go and look\n-            \/\/ at templateFields, just assume that it does add some fields, and\n-            \/\/ continue reading in templateMain.\n-            Hooks.CLASS_HOOK.insert(templateFields.asToken()),\n-            \/\/ We count again with \"c2\". The fields we wanted to add above are not\n-            \/\/ yet available, because the token is not yet evaluated. Hence, we\n-            \/\/ still only count zero names.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n-            \"\"\",\n-            \/\/ Now we call an inner Template. This also creates a token, and so it\n-            \/\/ is not evaluated immediately. And by the time this token is evaluated\n-            \/\/ the tokens from above are already evaluated, and so the fields should\n-            \/\/ be available. Go have a look at templateInner now.\n-            templateInner.asToken()\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var templateMain = Template.make(() -> scope(\n+            \/\/ Start with nothing:\n+            templateVerify.asToken(\"\"),\n+            addDataName(\"v1\", myInt, MUTABLE),\n+            templateVerify.asToken(\"v1\"),\n+            \/\/ Non-transparent hook anchor:\n+            myHook.anchor(scope(\n+                templateVerify.asToken(\"v1\"),\n+                addDataName(\"v2\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ Insert a non-transparent scope: nothing escapes.\n+                myHook.insert(scope(\n+                    \/\/ Note that at the anchor insertion point, v2 is not yet\n+                    \/\/ available, because it is added after the anchoring.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x3\", 42),\n+                    addDataName(\"v3\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v3\")\n+                )),\n+                \/\/ Note: x3 and v3 do not escape.\n+                let(\"x3\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ While not letting hashtags escape may be helpful, it is probably\n+                \/\/ not very helpful if the DataNames don't escape. For example, if\n+                \/\/ we are inserting some variable at an outer scope, we would like\n+                \/\/ it to be available for the rest of the scope.\n+                \/\/ That's where a transparent scope can be helpful.\n+                myHook.insert(transparentScope(\n+                    \/\/ At the anchoring, still only v1 is available.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x4\", 42), \/\/ escapes to caller scope\n+                    addDataName(\"v4\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4\")\n+                )),\n+                \/\/ x4 escapes to the caller out here, and not to the anchor scope.\n+                \"\/\/ x4: #x4\\n\",\n+                \/\/ And v4 escapes to the anchor scope, which is available from here too.\n+                \/\/ Interesting detail: the ordering in the list indicates that v1\n+                \/\/ is from the outermost scope of the template, v4 is located at the\n+                \/\/ anchor scope, and v2 is located inside the anchor scope, and\n+                \/\/ thus comes last.\n+                templateVerify.asToken(\"v1, v4, v2\"),\n+                \/\/ In most practical cases we probably don't want to let the hashtag\n+                \/\/ escape, because they just represent something local. So we can\n+                \/\/ use a hashtagScope, so that DataNames escape, but not hashtags.\n+                myHook.insert(hashtagScope(\n+                    \/\/ Note: both v1 and v4 are now available at the anchoring, since\n+                    \/\/ v1 was inserted outside the anchoring scope, and v4 was just\n+                    \/\/ inserted to the anchoring scope.\n+                    templateVerify.asToken(\"v1, v4\"),\n+                    let(\"x5\", 42), \/\/ local, does not escape.\n+                    addDataName(\"v5\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4, v5\")\n+                )),\n+                let(\"x5\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v4, v5, v2\")\n+            )),\n+            \/\/ We left the non-transparent anchoring scope which does not let anything escape\n+            templateVerify.asToken(\"v1\"),\n+\n+            \/\/ Let us now do something that probably should never be done. But still\n+            \/\/ we want to demonstrate it for educational purposes: transparent anchoring\n+            \/\/ scopes.\n+            myHook.anchor(transparentScope(\n+                templateVerify.asToken(\"v1\"),\n+                \/\/ For one, this means that DataName escape the scope directly.\n+                addDataName(\"v6\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v6\"),\n+                \/\/ But also if we insert to the anchoring scope, DataNames don't just\n+                \/\/ escape from the anchoring scope, but further out to the enclosing\n+                \/\/ scope.\n+                myHook.insert(transparentScope(\n+                    templateVerify.asToken(\"v1, v6\"),\n+                    addDataName(\"v7\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v6, v7\")\n+                )),\n+                templateVerify.asToken(\"v1, v6, v7\"),\n+                let(\"x6\", 42) \/\/ escapes the anchor scope\n+            )),\n+            \/\/ We left the transparent anchoring scope which lets the DataNames and\n+            \/\/ hashtags escape.\n+            \"\/\/ x6: #x6\\n\",\n+            templateVerify.asToken(\"v1, v6, v7\")\n@@ -984,1 +1271,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -990,1 +1277,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -994,1 +1281,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -996,1 +1283,1 @@\n-                ),\n+                )),\n@@ -1000,1 +1287,1 @@\n-            ),\n+            )),\n@@ -1009,2 +1296,0 @@\n-\n-\n@@ -1048,2 +1333,4 @@\n-        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> body(\n-            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE),\n+        \/\/ This template is used to insert a DataName (field) into an outer scope, hence we must use\n+        \/\/ \"transparentScope\" instead of \"scope\".\n+        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> transparentScope(\n+            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE), \/\/ Escapes the template.\n@@ -1056,1 +1343,1 @@\n-        var templateLoad = Template.make(\"type\", (DataName.Type type) -> body(\n+        var templateLoad = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1062,1 +1349,1 @@\n-            let(\"field\", dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sample().name()),\n+            dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sampleAndLetAs(\"field\"),\n@@ -1069,1 +1356,1 @@\n-        var templateStore = Template.make(\"type\", (DataName.Type type) -> body(\n+        var templateStore = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1073,1 +1360,1 @@\n-            let(\"field\", dataNames(MUTABLE).supertypeOf(type).sample().name()),\n+            dataNames(MUTABLE).supertypeOf(type).sampleAndLetAs(\"field\"),\n@@ -1079,1 +1366,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -1097,1 +1384,1 @@\n-                Hooks.CLASS_HOOK.anchor(\n+                Hooks.CLASS_HOOK.anchor(scope(\n@@ -1121,1 +1408,1 @@\n-                ),\n+                )),\n@@ -1129,1 +1416,0 @@\n-\n@@ -1168,1 +1454,1 @@\n-        var templateMethod = Template.make(\"op\", (String op) -> body(\n+        var templateMethod = Template.make(\"op\", (String op) -> transparentScope(\n@@ -1170,1 +1456,1 @@\n-            addStructuralName($(\"methodName\"), myMethodType),\n+            addStructuralName($(\"methodName\"), myMethodType), \/\/ escapes the template because of \"transparentScope\"\n@@ -1178,1 +1464,1 @@\n-        var templateSample = Template.make(() -> body(\n+        var templateSample = Template.make(() -> scope(\n@@ -1180,1 +1466,1 @@\n-            let(\"methodName\", structuralNames().exactOf(myMethodType).sample().name()),\n+            structuralNames().exactOf(myMethodType).sampleAndLetAs(\"methodName\"),\n@@ -1187,1 +1473,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -1195,1 +1481,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -1221,1 +1507,1 @@\n-            )\n+            ))\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":561,"deletions":275,"binary":false,"changes":836,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -85,1 +85,1 @@\n-        var commentTemplate = Template.make(() -> body(\n+        var commentTemplate = Template.make(() -> scope(\n@@ -106,1 +106,1 @@\n-        var testTemplate = Template.make(\"op\", (String op) -> body(\n+        var testTemplate = Template.make(\"op\", (String op) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -96,1 +96,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -144,1 +144,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -187,1 +187,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestExpression.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -87,1 +87,1 @@\n-        var template1 = Template.make(\"info\", (FormatInfo info) -> body(\n+        var template1 = Template.make(\"info\", (FormatInfo info) -> scope(\n@@ -98,1 +98,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestFormat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,5 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n+import static compiler.lib.template_framework.Template.nameScope;\n+import static compiler.lib.template_framework.Template.hashtagScope;\n+import static compiler.lib.template_framework.Template.setFuelCostScope;\n@@ -124,1 +128,1 @@\n-        testBodyTokens();\n+        testBasicTokens();\n@@ -128,2 +132,4 @@\n-        testNested();\n-        testHookSimple();\n+        testNestedTemplates();\n+        testHookSimple1();\n+        testHookSimple2();\n+        testHookSimple3();\n@@ -135,1 +141,2 @@\n-        testLet();\n+        testLet1();\n+        testLet2();\n@@ -141,0 +148,5 @@\n+        testFuelAndScopes();\n+        testDataNames0a();\n+        testDataNames0b();\n+        testDataNames0c();\n+        testDataNames0d();\n@@ -146,0 +158,2 @@\n+        testDataNames6();\n+        testStructuralNames0();\n@@ -148,0 +162,4 @@\n+        testStructuralNames3();\n+        testStructuralNames4();\n+        testStructuralNames5();\n+        testStructuralNames6();\n@@ -149,0 +167,6 @@\n+        testNestedScopes1();\n+        testNestedScopes2();\n+        testTemplateScopes();\n+        testHookAndScopes1();\n+        testHookAndScopes2();\n+        testHookAndScopes3();\n@@ -153,1 +177,0 @@\n-        expectRendererException(() -> let(\"x\",\"y\"),                       \"A Template method such as\");\n@@ -155,4 +178,0 @@\n-        expectRendererException(() -> setFuelCost(1.0f),                  \"A Template method such as\");\n-        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),  \"A Template method such as\");\n-        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).sample(), \"A Template method such as\");\n-        expectRendererException(() -> (new Hook(\"abc\")).isAnchored(),     \"A Template method such as\");\n@@ -181,1 +200,2 @@\n-        expectRendererException(() -> testFailingSample1(),  \"No variable: MUTABLE, subtypeOf(int), supertypeOf(int).\");\n+        expectRendererException(() -> testFailingSample1a(),  \"No Name found for DataName.FilterdSet(MUTABLE, subtypeOf(int), supertypeOf(int))\");\n+        expectRendererException(() -> testFailingSample1b(),  \"No Name found for StructuralName.FilteredSet( subtypeOf(StructuralA) supertypeOf(StructuralA))\");\n@@ -186,0 +206,1 @@\n+        expectRendererException(() -> testFailingHashtag5(), \"Missing hashtag replacement for #a\");\n@@ -188,3 +209,15 @@\n-        expectIllegalArgumentException(() -> body(null),              \"Unexpected tokens: null\");\n-        expectIllegalArgumentException(() -> body(\"x\", null),         \"Unexpected token: null\");\n-        expectIllegalArgumentException(() -> body(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> scope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> scope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> scope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> transparentScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> transparentScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> transparentScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> nameScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> nameScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> nameScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> hashtagScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> hashtagScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> hashtagScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n@@ -192,3 +225,0 @@\n-        expectIllegalArgumentException(() -> hook1.anchor(null),      \"Unexpected tokens: null\");\n-        expectIllegalArgumentException(() -> hook1.anchor(\"x\", null), \"Unexpected token: null\");\n-        expectIllegalArgumentException(() -> hook1.anchor(hook1),     \"Unexpected token:\");\n@@ -202,1 +232,2 @@\n-        expectUnsupportedOperationException(() -> testFailingSample2(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+        expectUnsupportedOperationException(() -> testFailingSample2a(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+        expectUnsupportedOperationException(() -> testFailingSample2b(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n@@ -211,0 +242,7 @@\n+        expectRendererException(() -> testFailingScope1(), \"Duplicate hashtag replacement for #x. previous: x1, new: x2\");\n+        expectRendererException(() -> testFailingScope2(), \"Duplicate hashtag replacement for #x. previous: x1, new: x2\");\n+        expectRendererException(() -> testFailingScope3(), \"Duplicate hashtag replacement for #x. previous: a, new: b\");\n+        expectRendererException(() -> testFailingScope4(), \"Duplicate hashtag replacement for #x. previous: a, new: b\");\n+        expectRendererException(() -> testFailingScope5(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingScope6(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingScope7(), \"Duplicate name:\");\n@@ -214,1 +252,1 @@\n-        var template = Template.make(() -> body(\"Hello World!\"));\n+        var template = Template.make(() -> scope(\"Hello World!\"));\n@@ -220,1 +258,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -235,4 +273,4 @@\n-    public static void testBodyTokens() {\n-        \/\/ We can fill the body with Objects of different types, and they get concatenated.\n-        \/\/ Lists get flattened into the body.\n-        var template = Template.make(() -> body(\n+    public static void testBasicTokens() {\n+        \/\/ We can fill the scope with Objects of different types, and they get concatenated.\n+        \/\/ Lists get flattened into the scope.\n+        var template = Template.make(() -> scope(\n@@ -253,1 +291,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"start #a end\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"start #a end\"));\n@@ -259,1 +297,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\"start \", a, \" end\"));\n+        var template2 = Template.make(\"a\", (String a) -> scope(\"start \", a, \" end\"));\n@@ -265,1 +303,1 @@\n-        var template3 = Template.make(\"a\", (Integer a) -> body(\"start #a end\"));\n+        var template3 = Template.make(\"a\", (Integer a) -> scope(\"start #a end\"));\n@@ -271,1 +309,1 @@\n-        var template4 = Template.make(\"a\", (Integer a) -> body(\"start \", a, \" end\"));\n+        var template4 = Template.make(\"a\", (Integer a) -> scope(\"start \", a, \" end\"));\n@@ -277,1 +315,1 @@\n-        var template5 = Template.make(\"a\", (String a) -> body(\"start #a \" + a + \" end\"));\n+        var template5 = Template.make(\"a\", (String a) -> scope(\"start #a \" + a + \" end\"));\n@@ -285,1 +323,1 @@\n-        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start #a1 #a2 end\"));\n+        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\"start #a1 #a2 end\"));\n@@ -291,1 +329,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\"start \", a1, \" \", a2, \" end\"));\n@@ -297,1 +335,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start #a1 #a2 end\"));\n+        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> scope(\"start #a1 #a2 end\"));\n@@ -303,1 +341,1 @@\n-        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> scope(\"start \", a1, \" \", a2, \" end\"));\n@@ -311,1 +349,1 @@\n-        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> scope(\"start #a1 #a2 #a3 end\"));\n@@ -317,1 +355,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> scope(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n@@ -323,1 +361,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> scope(\"start #a1 #a2 #a3 end\"));\n@@ -329,1 +367,1 @@\n-        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> scope(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n@@ -335,2 +373,2 @@\n-    public static void testNested() {\n-        var template1 = Template.make(() -> body(\"proton\"));\n+    public static void testNestedTemplates() {\n+        var template1 = Template.make(() -> scope(\"proton\"));\n@@ -338,1 +376,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\n@@ -343,1 +381,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\n@@ -350,1 +388,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -377,1 +415,1 @@\n-    public static void testHookSimple() {\n+    public static void testHookSimple1() {\n@@ -380,1 +418,1 @@\n-        var template1 = Template.make(() -> body(\"Hello\\n\"));\n+        var template1 = Template.make(() -> scope(\"Hello\\n\"));\n@@ -382,1 +420,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -384,1 +422,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -389,1 +427,27 @@\n-            ),\n+            )),\n+            \"}\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Hello\n+            World\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookSimple2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template2 = Template.make(() -> scope(\n+            \"{\\n\",\n+            hook1.anchor(scope(\n+                \"World\\n\",\n+                \/\/ Note: \"Hello\" from the scope below will be inserted\n+                \/\/ above \"World\" above.\n+                hook1.insert(scope(\n+                    \"Hello\\n\"\n+                ))\n+            )),\n@@ -403,0 +467,33 @@\n+    public static void testHookSimple3() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        \/\/ Ensure that insert inside insert really goes first.\n+        var template = Template.make(() -> scope(\n+            \"{\\n\",\n+            hook1.anchor(scope(\n+                \"<Anchor\\n\",\n+                hook1.insert(scope(\n+                    \"<Outer Insert\\n\",\n+                    hook1.insert(scope(\n+                        \"Inner Insert\\n\"\n+                    )),\n+                    \">Outer Insert\\n\"\n+                )),\n+                \">Anchor\\n\"\n+            )),\n+            \"}\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Inner Insert\n+            <Outer Insert\n+            >Outer Insert\n+            <Anchor\n+            >Anchor\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -406,1 +503,1 @@\n-        var template0 = Template.make(() -> body(\"isAnchored: \", hook1.isAnchored(), \"\\n\"));\n+        var template0 = Template.make(() -> scope(\"t0 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\"));\n@@ -408,1 +505,1 @@\n-        var template1 = Template.make(() -> body(\"Hello\\n\", template0.asToken()));\n+        var template1 = Template.make(() -> scope(\"Hello\\n\", template0.asToken()));\n@@ -410,1 +507,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -412,0 +509,1 @@\n+            \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -413,1 +511,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -415,0 +513,1 @@\n+                \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -416,2 +515,5 @@\n-                hook1.insert(template1.asToken())\n-            ),\n+                hook1.insert(template1.asToken()),\n+                hook1.insert(scope(\"Beautiful\\n\", template0.asToken())),\n+                \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\"\n+            )),\n+            \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -426,1 +528,2 @@\n-            isAnchored: false\n+            t2 isAnchored: false\n+            t0 isAnchored: false\n@@ -428,1 +531,3 @@\n-            isAnchored: true\n+            t0 isAnchored: true\n+            Beautiful\n+            t0 isAnchored: true\n@@ -430,2 +535,5 @@\n-            isAnchored: true\n-            isAnchored: false\n+            t2 isAnchored: true\n+            t0 isAnchored: true\n+            t2 isAnchored: true\n+            t2 isAnchored: false\n+            t0 isAnchored: false\n@@ -439,1 +547,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -442,1 +550,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -444,1 +552,1 @@\n-            hook1.anchor(), \/\/ empty\n+            hook1.anchor(scope()), \/\/ empty\n@@ -446,1 +554,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -451,0 +559,2 @@\n+                hook1.insert(scope(\"y 1 y\\n\")),\n+                hook1.insert(scope(\"y 2 y\\n\")),\n@@ -452,1 +562,1 @@\n-                hook1.anchor(\n+                hook1.anchor(scope(\n@@ -455,0 +565,1 @@\n+                    hook1.insert(scope(\"y 3 y\\n\")),\n@@ -456,1 +567,1 @@\n-                ),\n+                )),\n@@ -458,1 +569,1 @@\n-                hook1.anchor(), \/\/ empty\n+                hook1.anchor(scope()), \/\/ empty\n@@ -461,0 +572,1 @@\n+                hook1.insert(scope(\"y 4 y\\n\")),\n@@ -462,1 +574,1 @@\n-                hook1.anchor(\n+                hook1.anchor(scope(\n@@ -465,0 +577,1 @@\n+                    hook1.insert(scope(\"y 5 y\\n\")),\n@@ -466,1 +579,1 @@\n-                ),\n+                )),\n@@ -468,1 +581,1 @@\n-            ),\n+            )),\n@@ -479,0 +592,2 @@\n+            y 1 y\n+            y 2 y\n@@ -480,0 +595,1 @@\n+            y 4 y\n@@ -484,0 +600,1 @@\n+            y 3 y\n@@ -490,0 +607,1 @@\n+            y 5 y\n@@ -501,1 +619,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -503,1 +621,1 @@\n-        var template2 = Template.make(\"b\", (String b) -> body(\n+        var template2 = Template.make(\"b\", (String b) -> scope(\n@@ -509,1 +627,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -514,1 +632,1 @@\n-                hook2.anchor(\n+                hook2.anchor(scope(\n@@ -519,1 +637,1 @@\n-                ),\n+                )),\n@@ -524,1 +642,1 @@\n-            ),\n+            )),\n@@ -533,1 +651,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -536,1 +654,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -538,1 +656,1 @@\n-                hook2.anchor(\n+                hook2.anchor(scope(\n@@ -542,1 +660,1 @@\n-                ),\n+                )),\n@@ -544,1 +662,1 @@\n-            ),\n+            )),\n@@ -589,1 +707,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -591,1 +709,1 @@\n-        var template2 = Template.make(\"b\", (String b) -> body(\n+        var template2 = Template.make(\"b\", (String b) -> scope(\n@@ -597,1 +715,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -602,1 +720,1 @@\n-            ),\n+            )),\n@@ -607,1 +725,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -610,1 +728,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -614,1 +732,1 @@\n-            ),\n+            )),\n@@ -645,1 +763,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x $name #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x $name #a x\\n\"));\n@@ -647,1 +765,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\n+        var template2 = Template.make(\"a\", (String a) -> scope(\n@@ -654,1 +772,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -663,1 +781,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -665,1 +783,1 @@\n-            ),\n+            )),\n@@ -667,1 +785,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -675,1 +793,1 @@\n-            ),\n+            )),\n@@ -707,1 +825,1 @@\n-    public static void testLet() {\n+    public static void testLet1() {\n@@ -710,1 +828,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\n+        var template1 = Template.make(\"a\", (String a) -> scope(\n@@ -718,2 +836,2 @@\n-        var template2 = Template.make(\"a\", (Integer a) -> let(\"b\", a * 10, b ->\n-            body(\n+        var template2 = Template.make(\"a\", (Integer a) -> scope(\n+            let(\"b\", a * 10, b -> scope(\n@@ -722,1 +840,1 @@\n-            )\n+            ))\n@@ -725,1 +843,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -731,1 +849,1 @@\n-            hook1.anchor(\n+            hook1.anchor(transparentScope( \/\/ transparentScope allows hashtags to escape\n@@ -736,1 +854,1 @@\n-            ),\n+            )),\n@@ -769,0 +887,22 @@\n+    public static void testLet2() {\n+        var template = Template.make(() -> scope(\n+            \"outer {\\n\",\n+            let(\"x\", \"x1\", x -> scope(\n+                \"x: #x \", x, \".\\n\"\n+            )),\n+            let(\"x\", \"x2\"), \/\/ definition above is limited to its scope\n+            \"x: #x\\n\",\n+            \"} outer\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            outer {\n+            x: x1 x1.\n+            x: x2\n+            } outer\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -770,1 +910,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -795,1 +935,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\n+        var template1 = Template.make(\"a\", (String a) -> scope(\n@@ -801,1 +941,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\n+        var template2 = Template.make(\"a\", (String a) -> scope(\n@@ -807,1 +947,1 @@\n-        var template3 = Template.make(\"a\", (Integer a) -> body(\n+        var template3 = Template.make(\"a\", (Integer a) -> scope(\n@@ -816,1 +956,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -868,1 +1008,1 @@\n-        var template1 = Template.make(\"i\", (Integer i) -> body(\n+        var template1 = Template.make(\"i\", (Integer i) -> scope(\n@@ -877,1 +1017,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -905,1 +1045,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -913,1 +1053,1 @@\n-        var template2 = Template.make(\"i\", (Integer i) -> body(\n+        var template2 = Template.make(\"i\", (Integer i) -> scope(\n@@ -923,1 +1063,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -951,1 +1091,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -960,1 +1100,1 @@\n-        var template2 = Template.make(\"i\", (Integer i) -> body(\n+        var template2 = Template.make(\"i\", (Integer i) -> scope(\n@@ -971,1 +1111,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1005,0 +1145,216 @@\n+    public static void testFuelAndScopes() {\n+        var readFuelTemplate = Template.make(() -> scope(\n+            let(\"f\", fuel()),\n+            \"<#f>\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            let(\"f\", fuel()),\n+            \"{#f}\\n\",\n+            readFuelTemplate.asToken(),\n+\n+            \"scope:\\n\",\n+            setFuelCost(1.0f),\n+            scope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(2.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"transparentScope:\\n\",\n+            setFuelCost(4.0f),\n+            transparentScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(8.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"nameScope:\\n\",\n+            setFuelCost(16.0f),\n+            nameScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(32.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"hashtagScope:\\n\",\n+            setFuelCost(64.0f),\n+            hashtagScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(128.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"setFuelCostScope:\\n\",\n+            setFuelCost(256.0f),\n+            setFuelCostScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(512.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken()\n+        ));\n+\n+        String code = template.render(1000.0f);\n+        String expected =\n+            \"\"\"\n+            {1000.0f}\n+            <990.0f>\n+            scope:\n+            <999.0f>\n+            <998.0f>\n+            <999.0f>\n+            transparentScope:\n+            <996.0f>\n+            <992.0f>\n+            <992.0f>\n+            nameScope:\n+            <984.0f>\n+            <968.0f>\n+            <968.0f>\n+            hashtagScope:\n+            <936.0f>\n+            <872.0f>\n+            <872.0f>\n+            setFuelCostScope:\n+            <744.0f>\n+            <488.0f>\n+            <744.0f>\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0a() {\n+        var template = Template.make(() -> scope(\n+            \/\/ When a DataName is added, it is immediately available afterwards.\n+            \/\/ This may seem trivial, but it requires that either both \"add\" and\n+            \/\/ \"sample\" happen in lambda execution, or in token evaluation.\n+            \/\/ Otherwise, one can float above the other, and lead to unintuitive\n+            \/\/ behavior.\n+            addDataName(\"x\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"v\"),\n+            \"sample: #v.\"\n+        ));\n+\n+        String code = template.render();\n+        checkEQ(code, \"sample: x.\");\n+    }\n+\n+    public static void testDataNames0b() {\n+        \/\/ Test that the scope keeps local DataNames only for the scope, but that\n+        \/\/ we can see DataNames of outer scopes.\n+        var template = Template.make(() -> scope(\n+            \/\/ Outer scope DataName:\n+            addDataName(\"outerInt\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                let(\"name1\", dn.name()),\n+                \"sample: #name1.\\n\",\n+                \/\/ We can also see the outer DataName:\n+                dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"name2\"),\n+                \"sample: #name2.\\n\",\n+                \/\/ Local DataName:\n+                addDataName(\"innerLong\", myLong, MUTABLE),\n+                dataNames(MUTABLE).exactOf(myLong).sampleAndLetAs(\"name3\"),\n+                \"sample: #name3.\\n\"\n+            )),\n+            \/\/ We can still see the outer scope DataName:\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"name4\"),\n+            \"sample: #name4.\\n\",\n+            \/\/ But we cannot see the DataNames that are local to the inner scope.\n+            \/\/ So here, we will always see \"outerLong\", and never \"innerLong\".\n+            addDataName(\"outerLong\", myLong, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myLong).sampleAndLetAs(\"name5\"),\n+            \"sample: #name5.\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            sample: outerInt.\n+            sample: outerInt.\n+            sample: innerLong.\n+            sample: outerInt.\n+            sample: outerLong.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0c() {\n+        \/\/ Test that hashtag replacements that are local to inner scopes are\n+        \/\/ only visible to inner scopes, but dollar replacements are the same\n+        \/\/ for the whole Template.\n+        var template = Template.make(() -> scope(\n+            let(\"global\", \"GLOBAL\"),\n+            \"g: #global. $a\\n\",\n+            \/\/ Create a dummy DataName so we don't get an exception from sample.\n+            addDataName(\"x\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                \"g: #global. $b\\n\",\n+                let(\"local\", \"LOCAL1\"),\n+                \"l: #local. $c\\n\"\n+            )),\n+            \"g: #global. $d\\n\",\n+            \/\/ Open the scope again just to see if we can create the local again there.\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                \"g: #global. $e\\n\",\n+                let(\"local\", \"LOCAL2\"),\n+                \"l: #local. $f\\n\"\n+            )),\n+            \/\/ We can now use the \"local\" hashtag replacement again, since it\n+            \/\/ was previously only defined in an inner scope.\n+            let(\"local\", \"LOCAL3\"),\n+            \"g: #global. $g\\n\",\n+            \"l: #local. $h\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            g: GLOBAL. a_1\n+            g: GLOBAL. b_1\n+            l: LOCAL1. c_1\n+            g: GLOBAL. d_1\n+            g: GLOBAL. e_1\n+            l: LOCAL2. f_1\n+            g: GLOBAL. g_1\n+            l: LOCAL3. h_1\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0d() {\n+        var template = Template.make(() -> scope(\n+            addDataName(\"x\", myInt, MUTABLE),\n+            addDataName(\"y\", myInt, MUTABLE),\n+            addDataName(\"z\", myInt, MUTABLE),\n+            addDataName(\"a\", myLong, MUTABLE),\n+            addDataName(\"b\", myLong, MUTABLE),\n+            addDataName(\"c\", myLong, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).forEach((DataName dn) -> scope(\n+                let(\"name\", dn.name()),\n+                let(\"type\", dn.type()),\n+                \"listI: #name #type.\\n\"\n+            )),\n+            dataNames(MUTABLE).exactOf(myLong).forEach((DataName dn) -> scope(\n+                let(\"name\", dn.name()),\n+                let(\"type\", dn.type()),\n+                \"listL: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            listI: x int.\n+            listI: y int.\n+            listI: z int.\n+            listL: a long.\n+            listL: b long.\n+            listL: c long.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n@@ -1008,1 +1364,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1010,1 +1366,1 @@\n-            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1012,1 +1368,1 @@\n-            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(c -> scope(c)),\n@@ -1014,1 +1370,3 @@\n-            String.join(\", \", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1018,2 +1376,3 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, MUTABLE),\n+        \/\/ Note: the scope of the template must be transparentScope, so that the addDataName can escape.\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, MUTABLE), \/\/ escapes\n@@ -1024,1 +1383,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1031,1 +1390,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1034,1 +1393,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1037,1 +1396,1 @@\n-                template3.asToken(),\n+                template3.asToken(), \/\/ name_4 is inserted to hook1\n@@ -1041,1 +1400,1 @@\n-                template2.asToken($(\"name\"), myInt),\n+                template2.asToken($(\"name\"), myInt), \/\/ name_1 escapes\n@@ -1043,0 +1402,10 @@\n+                template1.asToken(),\n+                \"extra\\n\",\n+                hook1.insert(scope(\n+                    addDataName($(\"extra1\"), myInt, MUTABLE), \/\/ does not escape\n+                    \"$extra1 = 666\\n\"\n+                )),\n+                hook1.insert(transparentScope(\n+                    addDataName($(\"extra2\"), myInt, MUTABLE), \/\/ escapes\n+                    \"$extra2 = 42\\n\"\n+                )),\n@@ -1044,1 +1413,3 @@\n-            ),\n+            )),\n+            \/\/ But no names escape to down here, because the anchor scope is \"scope\".\n+            \"final:\\n\",\n@@ -1056,0 +1427,2 @@\n+            extra1_1 = 666\n+            extra2_1 = 42\n@@ -1067,1 +1440,4 @@\n-            [true, 1, names: {name_4}]\n+            [true, 2, names: {name_4, name_1}]\n+            extra\n+            [true, 3, names: {name_4, extra2_1, name_1}]\n+            final:\n@@ -1077,1 +1453,1 @@\n-        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> scope(\n@@ -1079,1 +1455,1 @@\n-            dataNames(mutability).exactOf(myInt).hasAny(),\n+            dataNames(mutability).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1081,1 +1457,1 @@\n-            dataNames(mutability).exactOf(myInt).count(),\n+            dataNames(mutability).exactOf(myInt).count(c -> scope(c)),\n@@ -1083,1 +1459,3 @@\n-            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(mutability).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1087,1 +1465,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1095,2 +1473,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, MUTABLE),\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, MUTABLE), \/\/ escapes\n@@ -1101,2 +1479,2 @@\n-        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, IMMUTABLE),\n+        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, IMMUTABLE), \/\/ escapes\n@@ -1107,1 +1485,1 @@\n-        var template4 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template4 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1114,1 +1492,1 @@\n-        var template5 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template5 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1121,2 +1499,2 @@\n-        var template6 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"v\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var template6 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1128,2 +1506,2 @@\n-        var template7 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"v\", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sample().name()),\n+        var template7 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1135,1 +1513,1 @@\n-        var template8 = Template.make(() -> body(\n+        var template8 = Template.make(() -> scope(\n@@ -1138,2 +1516,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1151,1 +1529,1 @@\n-            ),\n+            )),\n@@ -1177,1 +1555,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1222,1 +1600,1 @@\n-        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> scope(\n@@ -1224,1 +1602,1 @@\n-            dataNames(mutability).exactOf(myInt).hasAny(),\n+            dataNames(mutability).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1226,1 +1604,1 @@\n-            dataNames(mutability).exactOf(myInt).count(),\n+            dataNames(mutability).exactOf(myInt).count(c -> scope(c)),\n@@ -1228,1 +1606,3 @@\n-            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(mutability).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1232,1 +1612,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1240,1 +1620,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1243,2 +1623,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1252,1 +1632,1 @@\n-            ),\n+            )),\n@@ -1266,1 +1646,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1297,1 +1677,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1300,1 +1680,1 @@\n-            dataNames(MUTABLE).exactOf(type).hasAny(),\n+            dataNames(MUTABLE).exactOf(type).hasAny(h -> scope(h)),\n@@ -1302,1 +1682,1 @@\n-            dataNames(MUTABLE).exactOf(type).count(),\n+            dataNames(MUTABLE).exactOf(type).count(c -> scope(c)),\n@@ -1304,1 +1684,3 @@\n-            String.join(\", \", dataNames(MUTABLE).exactOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1307,1 +1689,1 @@\n-            dataNames(MUTABLE).subtypeOf(type).hasAny(),\n+            dataNames(MUTABLE).subtypeOf(type).hasAny(h -> scope(h)),\n@@ -1309,1 +1691,1 @@\n-            dataNames(MUTABLE).subtypeOf(type).count(),\n+            dataNames(MUTABLE).subtypeOf(type).count(c -> scope(c)),\n@@ -1311,1 +1693,4 @@\n-            String.join(\", \", dataNames(MUTABLE).subtypeOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).subtypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n+\n@@ -1314,1 +1699,1 @@\n-            dataNames(MUTABLE).supertypeOf(type).hasAny(),\n+            dataNames(MUTABLE).supertypeOf(type).hasAny(h -> scope(h)),\n@@ -1316,1 +1701,1 @@\n-            dataNames(MUTABLE).supertypeOf(type).count(),\n+            dataNames(MUTABLE).supertypeOf(type).count(c -> scope(c)),\n@@ -1318,1 +1703,3 @@\n-            String.join(\", \", dataNames(MUTABLE).supertypeOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).supertypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1324,1 +1711,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1329,3 +1716,11 @@\n-        var template3 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"name\", dataNames(MUTABLE).subtypeOf(type).sample()),\n-            \"Sample #type: #name\\n\"\n+        var template3 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name1\"),\n+            \"Sample #type: #name1\\n\",\n+            dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name2\", \"type2\"),\n+            \"Sample #type: #name2 #type2\\n\",\n+            dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> scope(\n+                let(\"name3\", dn.name()),\n+                let(\"type3\", dn.type()),\n+                let(\"dn\", dn), \/\/ format the whole DataName with toString\n+                \"Sample #type: #name3 #type3 #dn\\n\"\n+            ))\n@@ -1334,1 +1729,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1337,1 +1732,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1348,1 +1743,1 @@\n-            ),\n+            )),\n@@ -1384,3 +1779,9 @@\n-            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA11: v1_1\n+            Sample myClassA11: v1_1 myClassA11\n+            Sample myClassA11: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: v1_1\n+            Sample myClassA1: v1_1 myClassA11\n+            Sample myClassA1: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA: v1_1\n+            Sample myClassA: v1_1 myClassA11\n+            Sample myClassA: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n@@ -1388,2 +1789,6 @@\n-            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA11: v1_1\n+            Sample myClassA11: v1_1 myClassA11\n+            Sample myClassA11: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: v1_1\n+            Sample myClassA1: v1_1 myClassA11\n+            Sample myClassA1: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n@@ -1452,3 +1857,12 @@\n-        \/\/ It is safe in separate Hook scopes.\n-        var template1 = Template.make(() -> body(\n-            hook1.anchor(\n+        \/\/ It is safe in separate scopes.\n+        var template1 = Template.make(() -> scope(\n+            scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            nameScope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            nameScope(\n@@ -1457,1 +1871,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1459,1 +1873,4 @@\n-            )\n+            )),\n+            hook1.anchor(scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ))\n@@ -1463,1 +1880,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1466,1 +1883,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1471,1 +1888,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1478,1 +1895,1 @@\n-            hook2.anchor(\n+            hook2.anchor(scope(\n@@ -1484,1 +1901,1 @@\n-            )\n+            ))\n@@ -1486,2 +1903,2 @@\n-        var template5 = Template.make(() -> body(\n-            hook1.anchor(\n+        var template5 = Template.make(() -> scope(\n+            hook1.anchor(scope(\n@@ -1490,1 +1907,1 @@\n-            )\n+            ))\n@@ -1494,1 +1911,1 @@\n-        var template6 = Template.make(() -> body(\n+        var template6 = Template.make(() -> scope(\n@@ -1505,0 +1922,91 @@\n+    public static void testDataNames6() {\n+        var template = Template.make(() -> scope(\n+            addDataName(\"x\", myInt, IMMUTABLE),\n+            \"int x = 5;\\n\",\n+            \/\/ A DataName can be captured, and used to define a new one with the same type.\n+            \/\/ It is important that the new DataName can escape the hashtagScope, so we have\n+            \/\/ access to it later.\n+            \/\/ Using \"scope\", it does not escape.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> scope(\n+                addDataName(\"a\", dn.type(), MUTABLE),\n+                let(\"v1\", \"a\"),\n+                \"int #v1 = x + 1;\\n\"\n+            )),\n+            \/\/ Using \"transparentScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> transparentScope(\n+                addDataName(\"b\", dn.type(), MUTABLE),\n+                let(\"v2\", \"b\"),\n+                \"int #v2 = x + 2;\\n\"\n+            )),\n+            \/\/ Using \"nameScope\", it does not escape.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> nameScope(\n+                addDataName(\"c\", dn.type(), MUTABLE),\n+                let(\"v3\", \"c\"),\n+                \"int #v3 = x + 3;\\n\"\n+            )),\n+            \/\/ Using \"hashtagScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> hashtagScope(\n+                addDataName(\"d\", dn.type(), MUTABLE),\n+                let(\"v4\", \"d\"),\n+                \"int #v4 = x + 4;\\n\"\n+            )),\n+            \/\/ Using \"setFuelCostScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> setFuelCostScope(\n+                addDataName(\"e\", dn.type(), MUTABLE),\n+                let(\"v5\", \"e\"),\n+                \"int #v5 = x + 5;\\n\"\n+            )),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).forEach(\"name\", \"type\", dn -> scope(\n+                \"available1: #name #type.\\n\"\n+            )),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).forEach(\"name\", \"type\", dn -> hashtagScope(\n+                \"available2: #name #type.\\n\"\n+            )),\n+            \/\/ Check that hashtags escape correctly too.\n+            \"hashtag v2: #v2.\\n\",\n+            \"hashtag v3: #v3.\\n\",\n+            \"hashtag v5: #v5.\\n\",\n+            let(\"v1\", \"aaa\"),\n+            let(\"v4\", \"ddd\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            int x = 5;\n+            int a = x + 1;\n+            int b = x + 2;\n+            int c = x + 3;\n+            int d = x + 4;\n+            int e = x + 5;\n+            available1: x int.\n+            available1: b int.\n+            available1: d int.\n+            available1: e int.\n+            available2: x int.\n+            available2: b int.\n+            available2: d int.\n+            available2: e int.\n+            hashtag v2: b.\n+            hashtag v3: c.\n+            hashtag v5: e.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames0() {\n+        var template = Template.make(() -> scope(\n+            \/\/ When a StructuralName is added, it is immediately available afterwards.\n+            \/\/ This may seem trivial, but it requires that either both \"add\" and\n+            \/\/ \"sample\" happen in lambda execution, or in token evaluation.\n+            \/\/ Otherwise, one can float above the other, and lead to unintuitive\n+            \/\/ behavior.\n+            addStructuralName(\"x\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).sampleAndLetAs(\"v\"),\n+            \"sample: #v.\"\n+        ));\n+\n+        String code = template.render();\n+        checkEQ(code, \"sample: x.\");\n+    }\n+\n@@ -1508,1 +2016,1 @@\n-        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1511,1 +2019,1 @@\n-            structuralNames().exactOf(type).hasAny(),\n+            structuralNames().exactOf(type).hasAny(h -> scope(h)),\n@@ -1513,1 +2021,1 @@\n-            structuralNames().exactOf(type).count(),\n+            structuralNames().exactOf(type).count(c -> scope(c)),\n@@ -1515,1 +2023,3 @@\n-            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1518,1 +2028,1 @@\n-            structuralNames().subtypeOf(type).hasAny(),\n+            structuralNames().subtypeOf(type).hasAny(h -> scope(h)),\n@@ -1520,1 +2030,1 @@\n-            structuralNames().subtypeOf(type).count(),\n+            structuralNames().subtypeOf(type).count(c -> scope(c)),\n@@ -1522,1 +2032,3 @@\n-            String.join(\", \", structuralNames().subtypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().subtypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1525,1 +2037,1 @@\n-            structuralNames().supertypeOf(type).hasAny(),\n+            structuralNames().supertypeOf(type).hasAny(h -> scope(h)),\n@@ -1527,1 +2039,1 @@\n-            structuralNames().supertypeOf(type).count(),\n+            structuralNames().supertypeOf(type).count(c -> scope(c)),\n@@ -1529,1 +2041,3 @@\n-            String.join(\", \", structuralNames().supertypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().supertypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1539,1 +2053,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1544,3 +2058,11 @@\n-        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n-            let(\"name\", structuralNames().subtypeOf(type).sample()),\n-            \"Sample #type: #name\\n\"\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n+            structuralNames().subtypeOf(type).sampleAndLetAs(\"name1\"),\n+            \"Sample #type: #name1\\n\",\n+            structuralNames().subtypeOf(type).sampleAndLetAs(\"name2\", \"type2\"),\n+            \"Sample #type: #name2 #type2\\n\",\n+            structuralNames().subtypeOf(type).sample((StructuralName sn) -> scope(\n+                let(\"name3\", sn.name()),\n+                let(\"type3\", sn.type()),\n+                let(\"sn\", sn), \/\/ format the whole StructuralName with toString\n+                \"Sample #type: #name3 #type3 #sn\\n\"\n+            ))\n@@ -1549,1 +2071,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1552,1 +2074,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1563,1 +2085,1 @@\n-            ),\n+            )),\n@@ -1599,3 +2121,9 @@\n-            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA11: v1_1\n+            Sample StructuralA11: v1_1 StructuralA11\n+            Sample StructuralA11: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: v1_1\n+            Sample StructuralA1: v1_1 StructuralA11\n+            Sample StructuralA1: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA: v1_1\n+            Sample StructuralA: v1_1 StructuralA11\n+            Sample StructuralA: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n@@ -1603,2 +2131,6 @@\n-            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA11: v1_1\n+            Sample StructuralA11: v1_1 StructuralA11\n+            Sample StructuralA11: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: v1_1\n+            Sample StructuralA1: v1_1 StructuralA11\n+            Sample StructuralA1: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n@@ -1665,1 +2197,1 @@\n-        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1667,1 +2199,1 @@\n-            structuralNames().exactOf(type).hasAny(),\n+            structuralNames().exactOf(type).hasAny(h -> scope(h)),\n@@ -1669,1 +2201,1 @@\n-            structuralNames().exactOf(type).count(),\n+            structuralNames().exactOf(type).count(c -> scope(c)),\n@@ -1671,1 +2203,3 @@\n-            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1675,2 +2209,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, StructuralName.Type type) -> body(\n-            addStructuralName(name, type),\n+        var template2 = Template.make(\"name\", \"type\", (String name, StructuralName.Type type) -> transparentScope(\n+            addStructuralName(name, type), \/\/ escapes\n@@ -1680,1 +2214,1 @@\n-        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1687,2 +2221,2 @@\n-        var template4 = Template.make(\"type\", (StructuralName.Type type) -> body(\n-            let(\"v\", structuralNames().exactOf(type).sample().name()),\n+        var template4 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n+            structuralNames().exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1694,1 +2228,1 @@\n-        var template8 = Template.make(() -> body(\n+        var template8 = Template.make(() -> scope(\n@@ -1698,2 +2232,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1714,1 +2248,1 @@\n-            ),\n+            )),\n@@ -1728,1 +2262,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1758,0 +2292,253 @@\n+    public static void testStructuralNames3() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> scope(\n+                let(\"name1\", sn.name()),\n+                \"sn1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> nameScope(\n+                \/\/ We cannot use \"let\" here (at least not easily), otherwise we get\n+                \/\/ a duplicate hashtag replacement. It would probably be better style\n+                \/\/ to use a \"let\", but we are just checking that \"nameScope\" works\n+                \/\/ for reuse of names.\n+                \"sn2: \",  sn.name(), \".\\n\",\n+                \/\/ But for testing, we still do a \"let\", just with different key.\n+                \/\/ (This is probably bad practice, we just do this for testing)\n+                let(\"name2_\" + sn.name(), sn.name()),\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                \/\/ Same issue with hashtags as with \"nameScope\".\n+                \"sn3: \",  sn.name(), \".\\n\",\n+                let(\"name3_\" + sn.name(), sn.name()),\n+                \/\/ Using the same name for each would lead to duplicates,\n+                \/\/ so we have to modify the name here.\n+                addStructuralName(\"x_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> hashtagScope(\n+                let(\"name4\", sn.name()),\n+                \"sn4: #name4.\\n\",\n+                \/\/ Same issue with duplicate names as with \"transparentScope\".\n+                addStructuralName(\"y_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> setFuelCostScope(\n+                \/\/ Same issue with hashtags as with \"nameScope\".\n+                \"sn5: \",  sn.name(), \".\\n\",\n+                let(\"name5_\" + sn.name(), sn.name()),\n+                \/\/ Same issue with duplicate names as with \"transparentScope\".\n+                addStructuralName(\"z_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            \"sn2: #name2_a #name2_b.\\n\", \/\/ hashtags escaped\n+            \"sn3: #name3_a #name3_b.\\n\", \/\/ hashtags escaped\n+            \"sn5: #name5_a #name5_b #name5_x_a #name5_x_b.\\n\", \/\/ hashtags escaped\n+            let(\"name1\", \"shouldBeOK1\"), \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\")  \/\/ hashtag did not escape\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            sn1: a.\n+            sn1: b.\n+            sn2: a.\n+            sn2: b.\n+            sn3: a.\n+            sn3: b.\n+            sn4: a.\n+            sn4: b.\n+            sn4: x_a.\n+            sn4: x_b.\n+            sn5: a.\n+            sn5: b.\n+            sn5: x_a.\n+            sn5: x_b.\n+            sn5: y_a.\n+            sn5: y_b.\n+            sn5: y_x_a.\n+            sn5: y_x_b.\n+            sn2: a b.\n+            sn3: a b.\n+            sn5: a b x_a x_b.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames4() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                let(\"name1\", list.size()),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> nameScope(\n+                let(\"name2\", list.size()),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> transparentScope(\n+                let(\"name3\", list.size()),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> hashtagScope(\n+                let(\"name4\", list.size()),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> setFuelCostScope(\n+                let(\"name5\", list.size()),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: 2.\n+            list2: 2.\n+            list3: 2.\n+            list4: 3.\n+            list5: 4.\n+            list2: 2.\n+            list3: 2.\n+            list5: 4.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames5() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> scope(\n+                let(\"name1\", c),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> nameScope(\n+                let(\"name2\", c),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> transparentScope(\n+                let(\"name3\", c),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> hashtagScope(\n+                let(\"name4\", c),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> setFuelCostScope(\n+                let(\"name5\", c),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: 2.\n+            list2: 2.\n+            list3: 2.\n+            list4: 3.\n+            list5: 4.\n+            list2: 2.\n+            list3: 2.\n+            list5: 4.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames6() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> scope(\n+                let(\"name1\", h),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> nameScope(\n+                let(\"name2\", h),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> transparentScope(\n+                let(\"name3\", h),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> hashtagScope(\n+                let(\"name4\", h),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> setFuelCostScope(\n+                let(\"name5\", h),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: true.\n+            list2: true.\n+            list3: true.\n+            list4: true.\n+            list5: true.\n+            list2: true.\n+            list3: true.\n+            list5: true.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -1761,1 +2548,1 @@\n-        var template1 = Template.make(\"item\", (MyItem item) -> body(\n+        var template1 = Template.make(\"item\", (MyItem item) -> scope(\n@@ -1767,1 +2554,1 @@\n-        var template2 = Template.make(\"list\", (List<MyItem> list) -> body(\n+        var template2 = Template.make(\"list\", (List<MyItem> list) -> scope(\n@@ -1800,0 +2587,734 @@\n+    public static void testNestedScopes1() {\n+        var listDataNames = Template.make(() -> scope(\n+            \"dataNames: {\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"name\", \"type\", (DataName dn) -> scope(\n+                \"#name #type; \"\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(\"x\", (String x) -> scope(\n+            \"$start\\n\",\n+            addDataName(\"vx\", myInt, MUTABLE),\n+            \"x: #x.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"transparentScope\" nesting essencially does nothing but create\n+            \/\/ a list of tokens. It passes through names and hashtags.\n+            \"open transparentScope:\\n\",\n+            transparentScope(\n+                \"$transparentScope\\n\",\n+                let(\"y\", \"YYY\"),\n+                addDataName(\"vy\", myInt, MUTABLE),\n+                \"x: #x.\\n\",\n+                \"y: #y.\\n\",\n+                listDataNames.asToken()\n+            ),\n+            \"close transparentScope.\\n\",\n+            \"x: #x.\\n\",\n+            \"y: #y.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"hashtagScope\" nesting makes hashtags local, but names\n+            \/\/ escape the nesting.\n+            \"open hashtagScope:\\n\",\n+            hashtagScope(\n+                \"$hashtagScope\\n\",\n+                let(\"z\", \"ZZZ1\"),\n+                \"z: #z.\\n\",\n+                addDataName(\"vz\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close hashtagScope.\\n\",\n+            let(\"z\", \"ZZZ2\"), \/\/ we can define it again outside.\n+            \"z: #z.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ We can also use hashtagScopes for loops.\n+            List.of(\"a\", \"b\", \"c\").stream().map(str -> hashtagScope(\n+                \"$hashtagScope\\n\",\n+                let(\"str\", str), \/\/ the hashtag is local to every element\n+                \"str: #str.\\n\",\n+                addDataName(\"v_\" + str, myInt, MUTABLE),\n+                listDataNames.asToken()\n+            )).toList(),\n+            \"finish str list.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"nameScope\" nesting makes names local, but hashtags\n+            \/\/ escape the nesting.\n+            \"open nameScope:\\n\",\n+            nameScope(\n+                \"$nameScope\\n\",\n+                let(\"p\", \"PPP\"),\n+                \"p: #p.\\n\",\n+                addDataName(\"vp\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close hashtagScope.\\n\",\n+            \"p: #p.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"scope\" nesting makes names and hashtags local\n+            \"open scope:\\n\",\n+            scope(\n+                \"$scope\\n\",\n+                let(\"q\", \"QQQ1\"),\n+                \"q: #q.\\n\",\n+                addDataName(\"vq\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close scope.\\n\",\n+            let(\"q\", \"QQQ2\"),\n+            \"q: #q.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"setFuelCostScope\" nesting behaves the same as \"transparentScope\", as we are not using fuel here.\n+            \"open setFuelCostScope:\\n\",\n+            setFuelCostScope(\n+                \"$setFuelCostScope\\n\",\n+                let(\"r\", \"RRR\"),\n+                \"r: #r.\\n\",\n+                addDataName(\"vr\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close setFuelCostScope.\\n\",\n+            \"r: #r.\\n\",\n+            listDataNames.asToken()\n+\n+        ));\n+\n+        String code = template.render(\"XXX\");\n+        String expected =\n+            \"\"\"\n+            start_1\n+            x: XXX.\n+            dataNames: {vx int; }\n+            open transparentScope:\n+            transparentScope_1\n+            x: XXX.\n+            y: YYY.\n+            dataNames: {vx int; vy int; }\n+            close transparentScope.\n+            x: XXX.\n+            y: YYY.\n+            dataNames: {vx int; vy int; }\n+            open hashtagScope:\n+            hashtagScope_1\n+            z: ZZZ1.\n+            dataNames: {vx int; vy int; vz int; }\n+            close hashtagScope.\n+            z: ZZZ2.\n+            dataNames: {vx int; vy int; vz int; }\n+            hashtagScope_1\n+            str: a.\n+            dataNames: {vx int; vy int; vz int; v_a int; }\n+            hashtagScope_1\n+            str: b.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; }\n+            hashtagScope_1\n+            str: c.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            finish str list.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open nameScope:\n+            nameScope_1\n+            p: PPP.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vp int; }\n+            close hashtagScope.\n+            p: PPP.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open scope:\n+            scope_1\n+            q: QQQ1.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vq int; }\n+            close scope.\n+            q: QQQ2.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open setFuelCostScope:\n+            setFuelCostScope_1\n+            r: RRR.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vr int; }\n+            close setFuelCostScope.\n+            r: RRR.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vr int; }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNestedScopes2() {\n+        var listDataNames = Template.make(() -> scope(\n+            \"dataNames: {\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"name\", \"type\", (DataName dn) -> scope(\n+                \"#name #type; \"\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \/\/ Define some global variables.\n+            List.of(\"a\", \"b\", \"c\").stream().map(str -> hashtagScope(\n+                let(\"var\", \"g_\" + str),\n+                addDataName(\"g_\" + str, myInt, MUTABLE),\n+                \"def global #var.\\n\"\n+            )).toList(),\n+            listDataNames.asToken(),\n+            scope(\n+                \"open scope:\\n\",\n+                \/\/ Define some variables.\n+                List.of(\"i\", \"j\", \"k\").stream().map(str -> hashtagScope(\n+                    let(\"var\", \"v_\" + str),\n+                    addDataName(\"v_\" + str, myInt, MUTABLE),\n+                    \"def #var.\\n\"\n+                )).toList(),\n+                listDataNames.asToken(),\n+                scope(\n+                    \"open inner scope:\\n\",\n+                    addDataName(\"v_local\", myInt, MUTABLE),\n+                    \"def v_local.\\n\",\n+                    listDataNames.asToken(),\n+                    \"close inner scope.\\n\"\n+                ),\n+                listDataNames.asToken(),\n+                \"close scope.\\n\"\n+            ),\n+            listDataNames.asToken()\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            def global g_a.\n+            def global g_b.\n+            def global g_c.\n+            dataNames: {g_a int; g_b int; g_c int; }\n+            open scope:\n+            def v_i.\n+            def v_j.\n+            def v_k.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; }\n+            open inner scope:\n+            def v_local.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; v_local int; }\n+            close inner scope.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; }\n+            close scope.\n+            dataNames: {g_a int; g_b int; g_c int; }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testTemplateScopes() {\n+        var statusTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\",\n+            let(\"fuel\", fuel()),\n+            \"fuel: #fuel\\n\"\n+        ));\n+\n+        var scopeTemplate = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            let(\"local\", \"inner scope\"),\n+            addStructuralName(\"x\", myStructuralTypeA),\n+            statusTemplate.asToken(),\n+            setFuelCost(50)\n+        ));\n+\n+        var transparentScopeTemplate = Template.make(() -> transparentScope(\n+            \"transparentScope:\\n\",\n+            let(\"local\", \"inner flag\"),\n+            addStructuralName(\"y\", myStructuralTypeA), \/\/ should escape\n+            statusTemplate.asToken(),\n+            setFuelCost(50)\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            setFuelCost(1),\n+            let(\"local\", \"root\"),\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            statusTemplate.asToken(),\n+            scopeTemplate.asToken(),\n+            statusTemplate.asToken(),\n+            transparentScopeTemplate.asToken(),\n+            statusTemplate.asToken()\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            {a}\n+            fuel: 99.0f\n+            scope:\n+            {a, x}\n+            fuel: 89.0f\n+            {a}\n+            fuel: 99.0f\n+            transparentScope:\n+            {a, y}\n+            fuel: 89.0f\n+            {a, y}\n+            fuel: 99.0f\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookAndScopes1() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var insertScopeTemplate = Template.make(\"name\", (String name) -> scope(\n+            let(\"local\", \"insert scope garbage\"),\n+            addStructuralName(name, myStructuralTypeA),\n+            \"inserted scope: #name\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var insertTransparentScopeTemplate = Template.make(\"name\", (String name) -> transparentScope(\n+            let(\"local\", \"insert transparentScope garbage\"),\n+            addStructuralName(name, myStructuralTypeA),\n+            \"inserted transparentScope: #name\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var probeTemplate = Template.make(() -> scope(\n+            \"inserted probe:\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            hook1.anchor(scope(\n+                let(\"local\", \"scope garbage\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+                \"scope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x1b\")),\n+                \"scope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"scope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x1c\")),\n+                \"scope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"scope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after scope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            \"transparentScope:\\n\",\n+            hook1.anchor(transparentScope(\n+                let(\"transparentScope2\", \"abc\"),\n+                addStructuralName(\"x2a\", myStructuralTypeA),\n+                \"transparentScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x2b\")),\n+                \"transparentScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"transparentScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x2c\")),\n+                \"transparentScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"transparentScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after transparentScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"transparentScope2: #transparentScope2\\n\",\n+\n+            \"hashtagScope:\\n\",\n+            hook1.anchor(hashtagScope(\n+                let(\"local\", \"hashtagScope garbage\"),\n+                addStructuralName(\"x3a\", myStructuralTypeA),\n+                \"hashtagScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x3b\")),\n+                \"hashtagScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"hashtagScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x3c\")),\n+                \"hashtagScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"hashtagScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after hashtagScope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            \"nameScope:\\n\",\n+            hook1.anchor(nameScope(\n+                let(\"transparentScope4\", \"abcde\"),\n+                addStructuralName(\"x4a\", myStructuralTypeA),\n+                \"nameScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x4b\")),\n+                \"nameScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"nameScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x4c\")),\n+                \"nameScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"nameScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after nameScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"transparentScope4: #transparentScope4\\n\",\n+\n+            let(\"local\", \"outer garbage\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            scope:\n+            inserted scope: x1b\n+            {x1b}\n+            inserted transparentScope: x1c\n+            {x1c}\n+            inserted probe:\n+            {x1c}\n+            scope before insert scope:\n+            {x1a}\n+            scope after insert scope:\n+            {x1a}\n+            scope before insert transparentScope:\n+            {x1a}\n+            scope after insert transparentScope:\n+            {x1c, x1a}\n+            scope insert probe.\n+            after scope:\n+            {}\n+            transparentScope:\n+            inserted scope: x2b\n+            {x2a, x2b}\n+            inserted transparentScope: x2c\n+            {x2a, x2c}\n+            inserted probe:\n+            {x2a, x2c}\n+            transparentScope before insert scope:\n+            {x2a}\n+            transparentScope after insert scope:\n+            {x2a}\n+            transparentScope before insert transparentScope:\n+            {x2a}\n+            transparentScope after insert transparentScope:\n+            {x2a, x2c}\n+            transparentScope insert probe.\n+            after transparentScope:\n+            {x2a, x2c}\n+            transparentScope2: abc\n+            hashtagScope:\n+            inserted scope: x3b\n+            {x2a, x2c, x3a, x3b}\n+            inserted transparentScope: x3c\n+            {x2a, x2c, x3a, x3c}\n+            inserted probe:\n+            {x2a, x2c, x3a, x3c}\n+            hashtagScope before insert scope:\n+            {x2a, x2c, x3a}\n+            hashtagScope after insert scope:\n+            {x2a, x2c, x3a}\n+            hashtagScope before insert transparentScope:\n+            {x2a, x2c, x3a}\n+            hashtagScope after insert transparentScope:\n+            {x2a, x2c, x3a, x3c}\n+            hashtagScope insert probe.\n+            after hashtagScope:\n+            {x2a, x2c, x3a, x3c}\n+            nameScope:\n+            inserted scope: x4b\n+            {x2a, x2c, x3a, x3c, x4b}\n+            inserted transparentScope: x4c\n+            {x2a, x2c, x3a, x3c, x4c}\n+            inserted probe:\n+            {x2a, x2c, x3a, x3c, x4c}\n+            nameScope before insert scope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope after insert scope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope before insert transparentScope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope after insert transparentScope:\n+            {x2a, x2c, x3a, x3c, x4c, x4a}\n+            nameScope insert probe.\n+            after nameScope:\n+            {x2a, x2c, x3a, x3c}\n+            transparentScope4: abcde\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookAndScopes2() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            hook1.anchor(scope(\n+                let(\"local0\", \"scope garbage\"),\n+                let(\"local1\", \"LOCAL1\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+\n+                \"scope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(scope(\n+                    let(\"local2\", \"insert scope garbage\"),\n+                    let(\"name\", \"x1b\"),\n+                    addStructuralName(\"x1b\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted scope: #name\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(transparentScope(\n+                    let(\"nameTransparentScope\", \"x1c\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1c\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted transparentScope: #nameTransparentScope\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert transparentScope:\\n\",\n+                \"nameTransparentScope: #nameTransparentScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert nameScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(nameScope(\n+                    let(\"nameNameScope\", \"x1d\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1d\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted nameScope: #nameNameScope\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert nameScope:\\n\",\n+                \"nameNameScope: #nameNameScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(hashtagScope(\n+                    let(\"local2\", \"insert hashtagScope garbage\"),\n+                    let(\"name\", \"x1e\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1e\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted hashtagScope: #name\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope insert probe.\\n\",\n+                hook1.insert(scope(\n+                    \"inserted probe:\\n\",\n+                    listNamesTemplate.asToken()\n+                ))\n+            )),\n+            \"after scope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            let(\"name\", \"name garbage\"),\n+            let(\"local0\", \"outer garbage 0\"),\n+            let(\"local1\", \"outer garbage 1\"),\n+            let(\"local2\", \"outer garbage 2\"),\n+            let(\"nameTransparentScope\", \"outer garbage nameTransparentScope\"),\n+            let(\"nameNameScope\", \"outer garbage nameNameScope\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            scope:\n+            inserted scope: x1b\n+            local1: LOCAL1\n+            {x1b}\n+            inserted transparentScope: x1c\n+            local1: LOCAL1\n+            {x1c}\n+            inserted nameScope: x1d\n+            local1: LOCAL1\n+            {x1c, x1d}\n+            inserted hashtagScope: x1e\n+            local1: LOCAL1\n+            {x1c, x1e}\n+            inserted probe:\n+            {x1c, x1e}\n+            scope before insert scope:\n+            {x1a}\n+            scope after insert scope:\n+            {x1a}\n+            scope before insert transparentScope:\n+            {x1a}\n+            scope after insert transparentScope:\n+            nameTransparentScope: x1c\n+            {x1c, x1a}\n+            scope before insert nameScope:\n+            {x1c, x1a}\n+            scope after insert nameScope:\n+            nameNameScope: x1d\n+            {x1c, x1a}\n+            scope before insert hashtagScope:\n+            {x1c, x1a}\n+            scope after insert hashtagScope:\n+            {x1c, x1e, x1a}\n+            scope insert probe.\n+            after scope:\n+            {}\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    \/\/ Analogue to testHookAndScopes2, but with \"transparentScope\" instead of \"scope\".\n+    public static void testHookAndScopes3() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"transparentScope:\\n\",\n+            hook1.anchor(transparentScope(\n+                let(\"global0\", \"transparentScope garbage\"),\n+                let(\"global1\", \"GLOBAL1\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+\n+                \"transparentScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(scope(\n+                    let(\"local2\", \"insert scope garbage\"),\n+                    let(\"name\", \"x1b\"),\n+                    addStructuralName(\"x1b\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted scope: #name\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(transparentScope(\n+                    let(\"nameTransparentScope\", \"x1c\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1c\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted transparentScope: #nameTransparentScope\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert transparentScope:\\n\",\n+                \"nameTransparentScope: #nameTransparentScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert nameScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(nameScope(\n+                    let(\"nameNameScope\", \"x1d\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1d\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted nameScope: #nameNameScope\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert nameScope:\\n\",\n+                \"nameNameScope: #nameNameScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(hashtagScope(\n+                    let(\"local2\", \"insert hashtagScope garbage\"),\n+                    let(\"name\", \"x1e\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1e\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted hashtagScope: #name\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope insert probe.\\n\",\n+                hook1.insert(scope(\n+                    \"inserted probe:\\n\",\n+                    listNamesTemplate.asToken()\n+                ))\n+            )),\n+            \"after transparentScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"\"\"\n+            global0: #global0\n+            global1: #global1\n+            nameTransparentScope: #nameTransparentScope\n+            nameNameScope: #nameNameScope\n+            \"\"\",\n+            let(\"name\", \"name garbage\"),\n+            let(\"local2\", \"outer garbage 2\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            transparentScope:\n+            inserted scope: x1b\n+            global1: GLOBAL1\n+            {x1a, x1b}\n+            inserted transparentScope: x1c\n+            global1: GLOBAL1\n+            {x1a, x1c}\n+            inserted nameScope: x1d\n+            global1: GLOBAL1\n+            {x1a, x1c, x1d}\n+            inserted hashtagScope: x1e\n+            global1: GLOBAL1\n+            {x1a, x1c, x1e}\n+            inserted probe:\n+            {x1a, x1c, x1e}\n+            transparentScope before insert scope:\n+            {x1a}\n+            transparentScope after insert scope:\n+            {x1a}\n+            transparentScope before insert transparentScope:\n+            {x1a}\n+            transparentScope after insert transparentScope:\n+            nameTransparentScope: x1c\n+            {x1a, x1c}\n+            transparentScope before insert nameScope:\n+            {x1a, x1c}\n+            transparentScope after insert nameScope:\n+            nameNameScope: x1d\n+            {x1a, x1c}\n+            transparentScope before insert hashtagScope:\n+            {x1a, x1c}\n+            transparentScope after insert hashtagScope:\n+            {x1a, x1c, x1e}\n+            transparentScope insert probe.\n+            after transparentScope:\n+            {x1a, x1c, x1e}\n+            global0: transparentScope garbage\n+            global1: GLOBAL1\n+            nameTransparentScope: x1c\n+            nameNameScope: x1d\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -1801,1 +3322,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1805,1 +3326,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1816,1 +3337,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1823,1 +3344,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1830,1 +3351,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1837,1 +3358,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1844,1 +3365,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1851,1 +3372,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1858,1 +3379,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1865,1 +3386,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1872,1 +3393,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1880,1 +3401,1 @@\n-        var template1 = Template.make(\"\", (String x) -> body(\n+        var template1 = Template.make(\"\", (String x) -> scope(\n@@ -1887,1 +3408,1 @@\n-        var template1 = Template.make(\"abc#abc\", (String x) -> body(\n+        var template1 = Template.make(\"abc#abc\", (String x) -> scope(\n@@ -1893,1 +3414,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1901,1 +3422,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1909,1 +3430,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1916,1 +3437,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1923,1 +3444,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1930,1 +3451,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1937,1 +3458,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1944,1 +3465,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1951,1 +3472,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1958,1 +3479,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1967,1 +3488,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1971,1 +3492,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1981,4 +3502,4 @@\n-    public static void testFailingSample1() {\n-        var template1 = Template.make(() -> body(\n-            \/\/ No variable added yet.\n-            let(\"v\", dataNames(MUTABLE).exactOf(myInt).sample().name()),\n+    public static void testFailingSample1a() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ No DataName added yet.\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"v\"),\n@@ -1991,2 +3512,12 @@\n-    public static void testFailingSample2() {\n-        var template1 = Template.make(() -> body(\n+    public static void testFailingSample1b() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ No StructuralName added yet.\n+            structuralNames().exactOf(myStructuralTypeA).sampleAndLetAs(\"v\"),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2a() {\n+        var template1 = Template.make(() -> scope(\n@@ -1994,1 +3525,11 @@\n-            let(\"v\", dataNames(MUTABLE).sample().name()),\n+            dataNames(MUTABLE).sampleAndLetAs(\"v\"),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2b() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ no type restriction\n+            structuralNames().sampleAndLetAs(\"v\"),\n@@ -2003,1 +3544,1 @@\n-        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> body(\n+        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> scope(\n@@ -2011,1 +3552,1 @@\n-        var template1 = Template.make(\"a\", (String _) -> body(\n+        var template1 = Template.make(\"a\", (String _) -> scope(\n@@ -2021,1 +3562,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2032,1 +3573,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2040,0 +3581,11 @@\n+    public static void testFailingHashtag5() {\n+        var template1 = Template.make(() -> scope(\n+            \"use before definition: #a\\n\",\n+            \/\/ let is a token, and is only evaluated after\n+            \/\/ the string above, and so the string above fails.\n+            let(\"a\", \"x\")\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n@@ -2042,1 +3594,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2052,1 +3604,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2062,1 +3614,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2070,1 +3622,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2078,1 +3630,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2086,1 +3638,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2094,1 +3646,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2102,1 +3654,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2110,1 +3662,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2119,1 +3671,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2128,1 +3680,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2137,1 +3689,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2146,1 +3698,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2155,1 +3707,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2164,1 +3716,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2167,1 +3719,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -2178,1 +3730,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2180,1 +3732,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -2182,1 +3734,1 @@\n-            )\n+            ))\n@@ -2191,2 +3743,2 @@\n-        var template1 = Template.make(() -> body(\n-            addDataName(\"name\", myInt, MUTABLE)\n+        var template1 = Template.make(() -> transparentScope(\n+            addDataName(\"name\", myInt, MUTABLE) \/\/ escapes\n@@ -2195,2 +3747,2 @@\n-        var template2 = Template.make(() -> body(\n-            hook1.anchor(\n+        var template2 = Template.make(() -> scope(\n+            hook1.anchor(scope(\n@@ -2199,1 +3751,1 @@\n-            )\n+            ))\n@@ -2204,0 +3756,75 @@\n+    public static void testFailingScope1() {\n+        var template = Template.make(() -> scope(\n+            transparentScope(\n+                let(\"x\", \"x1\") \/\/ escapes\n+            ),\n+            let(\"x\", \"x2\") \/\/ second definition\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope2() {\n+        var template = Template.make(() -> scope(\n+            nameScope(\n+                let(\"x\", \"x1\") \/\/ escapes\n+            ),\n+            let(\"x\", \"x2\") \/\/ second definition\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope3() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                let(\"x\", sn.name()) \/\/ leads to duplicate hashtag\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope4() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> nameScope(\n+                let(\"x\", sn.name()) \/\/ leads to duplicate hashtag\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope5() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope6() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> hashtagScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope7() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> setFuelCostScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":1917,"deletions":290,"binary":false,"changes":2207,"status":"modified"}]}