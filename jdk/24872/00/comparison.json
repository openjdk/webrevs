{"files":[{"patch":"@@ -61,1 +61,0 @@\n-#include \"runtime\/statSampler.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/statSampler.hpp\"\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/statSampler.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"runtime\/statSampler.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-  : _last_used_in_bytes(0), _object_space(m)\n-{\n+    : _object_space(m) {\n@@ -63,1 +62,1 @@\n-                                             new UsedHelper(this),\n+                                             _object_space->used_in_bytes(),\n@@ -77,17 +76,1 @@\n-  size_t new_used = _object_space->used_in_bytes();\n-  Atomic::store(&_last_used_in_bytes, new_used);\n-  _used->set_value(new_used);\n-}\n-\n-jlong SpaceCounters::UsedHelper::take_sample() {\n-  \/\/ Sampling may occur during GC, possibly while GC is updating the space.\n-  \/\/ The space can be in an inconsistent state during such an update.  We\n-  \/\/ don't want to block sampling for the duration of a GC.  Instead, skip\n-  \/\/ sampling in that case, using the last recorded value.\n-  assert(!Heap_lock->owned_by_self(), \"precondition\");\n-  if (Heap_lock->try_lock()) {\n-    size_t new_used = _counters->_object_space->used_in_bytes();\n-    Atomic::store(&_counters->_last_used_in_bytes, new_used);\n-    Heap_lock->unlock();\n-  }\n-  return Atomic::load(&_counters->_last_used_in_bytes);\n+  _used->set_value(_object_space->used_in_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/spaceCounters.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  volatile size_t    _last_used_in_bytes;\n@@ -51,2 +50,0 @@\n-  class UsedHelper;\n-\n@@ -74,10 +71,0 @@\n-class SpaceCounters::UsedHelper: public PerfLongSampleHelper {\n- private:\n-  SpaceCounters* _counters;\n-\n- public:\n-  UsedHelper(SpaceCounters* counters) : _counters(counters) { }\n-\n-  jlong take_sample() override;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/spaceCounters.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-  : _last_used_in_bytes(0), _space(s)\n-{\n+    : _space(s) {\n@@ -60,1 +59,1 @@\n-                                             new UsedHelper(this),\n+                                             _space->used(),\n@@ -78,3 +77,1 @@\n-  size_t new_used = _space->used();\n-  Atomic::store(&_last_used_in_bytes, new_used);\n-  _used->set_value(new_used);\n+  _used->set_value(_space->used());\n@@ -87,14 +84,0 @@\n-\n-jlong CSpaceCounters::UsedHelper::take_sample(){\n-  \/\/ Sampling may occur during GC, possibly while GC is updating the space.\n-  \/\/ The space can be in an inconsistent state during such an update.  We\n-  \/\/ don't want to block sampling for the duration of a GC.  Instead, skip\n-  \/\/ sampling in that case, using the last recorded value.\n-  assert(!Heap_lock->owned_by_self(), \"precondition\");\n-  if (Heap_lock->try_lock()) {\n-    size_t new_used = _counters->_space->used();\n-    Atomic::store(&_counters->_last_used_in_bytes, new_used);\n-    Heap_lock->unlock();\n-  }\n-  return Atomic::load(&_counters->_last_used_in_bytes);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/cSpaceCounters.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  volatile size_t    _last_used_in_bytes;\n@@ -51,2 +50,0 @@\n-  class UsedHelper;\n-\n@@ -67,10 +64,0 @@\n-class CSpaceCounters::UsedHelper : public PerfLongSampleHelper {\n- private:\n-  CSpaceCounters* _counters;\n-\n- public:\n-  UsedHelper(CSpaceCounters* counters) : _counters(counters) { }\n-\n-  jlong take_sample() override;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cSpaceCounters.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -538,0 +538,1 @@\n+  { \"PerfDataSamplingInterval\",     JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1723,5 +1723,0 @@\n-  product(int, PerfDataSamplingInterval, 50,                                \\\n-          \"Data sampling interval (in milliseconds)\")                       \\\n-          range(PeriodicTask::min_interval, max_jint)                       \\\n-          constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -466,4 +465,0 @@\n-  \/\/ shut down the StatSampler task\n-  StatSampler::disengage();\n-  StatSampler::destroy();\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -41,1 +43,0 @@\n-PerfDataList*   PerfDataManager::_sampled = nullptr;\n@@ -201,14 +202,0 @@\n-PerfLongVariant::PerfLongVariant(CounterNS ns, const char* namep, Units u,\n-                                 Variability v, PerfLongSampleHelper* helper)\n-                                : PerfLong(ns, namep, u, v),\n-                                  _sample_helper(helper) {\n-\n-  sample();\n-}\n-\n-void PerfLongVariant::sample() {\n-  if (_sample_helper != nullptr) {\n-    *(jlong*)_valuep = _sample_helper->take_sample();\n-  }\n-}\n-\n@@ -269,2 +256,2 @@\n-  log_debug(perf, datacreation)(\"Total = %d, Sampled = %d, Constants = %d\",\n-                                _all->length(), _sampled == nullptr ? 0 : _sampled->length(),\n+  log_debug(perf, datacreation)(\"Total = %d, Constants = %d\",\n+                                _all->length(),\n@@ -279,1 +266,0 @@\n-  delete(_sampled);\n@@ -283,1 +269,0 @@\n-  _sampled = nullptr;\n@@ -287,1 +272,1 @@\n-void PerfDataManager::add_item(PerfData* p, bool sampled) {\n+void PerfDataManager::add_item(PerfData* p) {\n@@ -309,18 +294,0 @@\n-\n-  if (sampled) {\n-    if (_sampled == nullptr) {\n-      _sampled = new PerfDataList(1);\n-    }\n-    _sampled->append(p);\n-  }\n-}\n-\n-PerfDataList* PerfDataManager::sampled() {\n-\n-  MutexLocker ml(PerfDataManager_lock);\n-\n-  if (_sampled == nullptr)\n-    return nullptr;\n-\n-  PerfDataList* clone = _sampled->clone();\n-  return clone;\n@@ -365,1 +332,1 @@\n-  add_item(p, false);\n+  add_item(p);\n@@ -383,1 +350,1 @@\n-  add_item(p, false);\n+  add_item(p);\n@@ -406,1 +373,1 @@\n-  add_item(p, false);\n+  add_item(p);\n@@ -424,1 +391,1 @@\n-  add_item(p, false);\n+  add_item(p);\n@@ -429,8 +396,4 @@\n-PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,\n-                                                        const char* name,\n-                                                        PerfData::Units u,\n-                                                        PerfSampleHelper* sh,\n-                                                        TRAPS) {\n-\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return nullptr;\n+PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,\n+                                                      const char* name,\n+                                                      PerfData::Units u,\n+                                                      jlong ival, TRAPS) {\n@@ -438,1 +401,1 @@\n-  PerfLongVariable* p = new PerfLongVariable(ns, name, u, sh);\n+  PerfLongCounter* p = new PerfLongCounter(ns, name, u, ival);\n@@ -446,1 +409,1 @@\n-  add_item(p, true);\n+  add_item(p);\n@@ -451,4 +414,7 @@\n-PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,\n-                                                      const char* name,\n-                                                      PerfData::Units u,\n-                                                      jlong ival, TRAPS) {\n+\/*\n+ * Call into java.lang.System.getProperty to check that the value of the\n+ * specified property matches\n+ *\/\n+void PerfDataManager::assert_system_property(const char* name, const char* value, TRAPS) {\n+  #ifdef ASSERT\n+    ResourceMark rm(THREAD);\n@@ -456,1 +422,2 @@\n-  PerfLongCounter* p = new PerfLongCounter(ns, name, u, ival);\n+    \/\/ setup the arguments to getProperty\n+    Handle key_str   = java_lang_String::create_from_str(name, CHECK);\n@@ -458,4 +425,20 @@\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_NULL(vmSymbols::java_lang_OutOfMemoryError());\n+    \/\/ return value\n+    JavaValue result(T_OBJECT);\n+\n+    \/\/ public static String getProperty(String key, String def);\n+    JavaCalls::call_static(&result,\n+                           vmClasses::System_klass(),\n+                           vmSymbols::getProperty_name(),\n+                           vmSymbols::string_string_signature(),\n+                           key_str,\n+                           CHECK);\n+\n+    oop value_oop = result.get_oop();\n+    assert(value_oop != nullptr, \"property must have a value\");\n+\n+    \/\/ convert Java String to utf8 string\n+    char* system_value = java_lang_String::as_utf8_string(value_oop);\n+\n+    assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty. Our value is: %s, System.getProperty is: %s\",\n+           value, system_value);\n+  #endif \/\/ ASSERT\n@@ -464,1 +447,13 @@\n-  add_item(p, false);\n+\/*\n+ * Adds a constant counter of the given property. Asserts the value does not\n+ * differ from the value retrievable from System.getProperty(name)\n+ *\/\n+void PerfDataManager::add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS) {\n+  \/\/ the property must exist\n+  assert(value != nullptr, \"property name should be have a value: %s\", name);\n+  assert_system_property(name, value, CHECK);\n+  if (value != nullptr) {\n+    \/\/ create the property counter\n+    PerfDataManager::create_string_constant(name_space, name, value, CHECK);\n+  }\n+}\n@@ -466,1 +461,7 @@\n-  return p;\n+\/*\n+ * Adds a string constant of the given property. Retrieves the value via\n+ * Arguments::get_property() and asserts the value for the does not differ from\n+ * the value retrievable from System.getProperty()\n+ *\/\n+void PerfDataManager::add_property_constant(CounterNS name_space, const char* name, TRAPS) {\n+  add_property_constant(name_space, name, Arguments::get_property(name), CHECK);\n@@ -469,5 +470,7 @@\n-PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,\n-                                                      const char* name,\n-                                                      PerfData::Units u,\n-                                                      PerfSampleHelper* sh,\n-                                                      TRAPS) {\n+\/*\n+ * Adds a string constant of the given property. Retrieves the value via\n+ * Arguments::get_property() and asserts the value for the does not differ from\n+ * the value retrievable from System.getProperty()\n+ *\/\n+void PerfDataManager::add_optional_property_constant(CounterNS name_space, const char* name, TRAPS) {\n+  const char* value = Arguments::get_property(name);\n@@ -475,2 +478,4 @@\n-  \/\/ Sampled counters not supported if UsePerfData is false\n-  if (!UsePerfData) return nullptr;\n+  if (value != nullptr) {\n+    add_property_constant(name_space, name, value, CHECK);\n+  }\n+}\n@@ -478,1 +483,28 @@\n-  PerfLongCounter* p = new PerfLongCounter(ns, name, u, sh);\n+void PerfDataManager::create_system_property_instrumentation(TRAPS) {\n+\n+  \/\/ Non-writeable, constant properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.name\", \"Java Virtual Machine Specification\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.version\", JDK_Version::java_version(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.version\", VM_Version::vm_release(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.name\", VM_Version::vm_name(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.vendor\", VM_Version::vm_vendor(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"jdk.debug\", VM_Version::jdk_debug_level(), CHECK);\n+\n+  \/\/ Get remaining property constants via Arguments::get_property,\n+  \/\/ which does a linear search over the internal system properties list.\n+\n+  \/\/ SUN_PROPERTY properties\n+  add_property_constant(SUN_PROPERTY, \"sun.boot.library.path\", CHECK);\n+\n+  \/\/ JAVA_PROPERTY properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.version\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.vendor\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.info\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.library.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.class.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.home\", CHECK);\n+\n+  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.path\", CHECK);\n+  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.upgrade.path\", CHECK);\n+  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.main\", CHECK);\n+}\n@@ -480,5 +512,1 @@\n-  if (!p->is_valid()) {\n-    \/\/ allocation of native resources failed.\n-    delete p;\n-    THROW_NULL(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n+void PerfDataManager::create_misc_perfdata() {\n@@ -486,1 +514,2 @@\n-  add_item(p, true);\n+  ResourceMark rm;\n+  EXCEPTION_MARK;\n@@ -488,1 +517,26 @@\n-  return p;\n+  \/\/ numeric constants\n+\n+  \/\/ frequency of the native high resolution timer\n+  create_constant(SUN_OS, \"hrt.frequency\", PerfData::U_Hertz,\n+    os::elapsed_frequency(), CHECK);\n+\n+  create_constant(SUN_OS, \"hrt.now\", PerfData::U_Hertz,\n+    os::elapsed_frequency(), CHECK);\n+\n+  \/\/ string constants\n+\n+  \/\/ create string instrumentation for various Java properties.\n+  create_system_property_instrumentation(CHECK);\n+\n+  \/\/ HotSpot flags (from .hotspotrc) and args (from command line)\n+  \/\/\n+  create_string_constant(JAVA_RT, \"vmFlags\", Arguments::jvm_flags(), CHECK);\n+  create_string_constant(JAVA_RT, \"vmArgs\", Arguments::jvm_args(), CHECK);\n+\n+  \/\/ java class name\/jar file and arguments to main class\n+  \/\/ note: name is coordinated with launcher and Arguments.cpp\n+  create_string_constant(SUN_RT, \"javaCommand\", Arguments::java_command(), CHECK);\n+\n+  \/\/ the Java VM Internal version string\n+  create_string_constant(SUN_RT, \"internalVersion\",\n+                         VM_Version::internal_vm_info_string(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":132,"deletions":78,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -203,33 +203,0 @@\n- * Creating a performance counter in an arbitrary name space that holds a\n- * value that is sampled by the StatSampler periodic task.\n- *\n- *    PerfDataManager::create_counter(\"foo.sampled\", PerfData::U_Events,\n- *                                    &my_jlong, CHECK);\n- *\n- *    In this example, the PerfData pointer can be ignored as the caller\n- *    is relying on the StatSampler PeriodicTask to sample the given\n- *    address at a regular interval. The interval is defined by the\n- *    PerfDataSamplingInterval global variable, and is applied on\n- *    a system wide basis, not on an per-counter basis.\n- *\n- * Creating a performance counter in an arbitrary name space that utilizes\n- * a helper object to return a value to the StatSampler via the take_sample()\n- * method.\n- *\n- *     class MyTimeSampler : public PerfLongSampleHelper {\n- *       public:\n- *         jlong take_sample() { return os::elapsed_counter(); }\n- *     };\n- *\n- *     PerfDataManager::create_counter(SUN_RT, \"helped\",\n- *                                     PerfData::U_Ticks,\n- *                                     new MyTimeSampler(), CHECK);\n- *\n- *     In this example, a subtype of PerfLongSampleHelper is instantiated\n- *     and its take_sample() method is overridden to perform whatever\n- *     operation is necessary to generate the data sample. This method\n- *     will be called by the StatSampler at a regular interval, defined\n- *     by the PerfDataSamplingInterval global variable.\n- *\n- *     As before, PerfSampleHelper is an alias for PerfLongSampleHelper.\n- *\n@@ -239,1 +206,1 @@\n- * Always-on non-sampled counters can be created independent of\n+ * Always-on counters can be created independent of\n@@ -263,1 +230,0 @@\n-  friend class StatSampler;      \/\/ for access to protected void sample()\n@@ -317,4 +283,0 @@\n-    \/\/ sample the data item given at creation time and write its value\n-    \/\/ into the its corresponding PerfMemory location.\n-    virtual void sample() = 0;\n-\n@@ -355,11 +317,0 @@\n-\/*\n- * PerfLongSampleHelper, and its alias PerfSamplerHelper, is a base class\n- * for helper classes that rely upon the StatSampler periodic task to\n- * invoke the take_sample() method and write the value returned to its\n- * appropriate location in the PerfData memory region.\n- *\/\n-class PerfLongSampleHelper : public CHeapObj<mtInternal> {\n-  public:\n-    virtual jlong take_sample() = 0;\n-};\n-\n@@ -393,4 +344,0 @@\n-  private:\n-    \/\/ hide sample() - no need to sample constants\n-    void sample() { }\n-\n@@ -416,2 +363,0 @@\n-    PerfLongSampleHelper* _sample_helper;\n-\n@@ -424,5 +369,0 @@\n-    PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,\n-                    PerfLongSampleHelper* sample_helper);\n-\n-    void sample();\n-\n@@ -454,5 +394,0 @@\n-\n-    PerfLongCounter(CounterNS ns, const char* namep, Units u,\n-                    PerfLongSampleHelper* sample_helper)\n-                   : PerfLongVariant(ns, namep, u, V_Monotonic,\n-                                     sample_helper) { }\n@@ -477,5 +412,0 @@\n-    PerfLongVariable(CounterNS ns, const char* namep, Units u,\n-                     PerfLongSampleHelper* sample_helper)\n-                    : PerfLongVariant(ns, namep, u, V_Variable,\n-                                      sample_helper) { }\n-\n@@ -524,5 +454,0 @@\n-  private:\n-\n-    \/\/ hide sample() - no need to sample constants\n-    void sample() { }\n-\n@@ -553,3 +478,0 @@\n-    \/\/ sampling of string variables are not yet supported\n-    void sample() { }\n-\n@@ -646,3 +568,0 @@\n-\n-  friend class StatSampler;   \/\/ for access to protected PerfDataList methods\n-\n@@ -651,1 +570,0 @@\n-    static PerfDataList* _sampled;\n@@ -657,7 +575,1 @@\n-    static void add_item(PerfData* p, bool sampled);\n-\n-  protected:\n-\n-    \/\/ return the list of all known PerfData items that are to be\n-    \/\/ sampled by the StatSampler.\n-    static PerfDataList* sampled();\n+    static void add_item(PerfData* p);\n@@ -665,0 +577,5 @@\n+    static void create_system_property_instrumentation(TRAPS);\n+    static void assert_system_property(const char* name, const char* value, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, TRAPS);\n+    static void add_optional_property_constant(CounterNS name_space, const char* name, TRAPS);\n@@ -666,0 +583,2 @@\n+    \/\/ Creates miscellaneous perfdata constants\n+    static void create_misc_perfdata();\n@@ -750,6 +669,0 @@\n-    static PerfLongVariable* create_long_variable(CounterNS ns,\n-                                                  const char* name,\n-                                                  PerfData::Units u,\n-                                                  PerfLongSampleHelper* sh,\n-                                                  TRAPS);\n-\n@@ -762,5 +675,0 @@\n-    static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,\n-                                                PerfData::Units u,\n-                                                PerfLongSampleHelper* sh,\n-                                                TRAPS);\n-\n@@ -786,6 +694,0 @@\n-    static PerfVariable* create_variable(CounterNS ns, const char* name,\n-                                         PerfData::Units u,\n-                                         PerfSampleHelper* sh, TRAPS) {\n-      return create_long_variable(ns, name, u, sh, THREAD);\n-    }\n-\n@@ -797,6 +699,0 @@\n-    static PerfCounter* create_counter(CounterNS ns, const char* name,\n-                                       PerfData::Units u,\n-                                       PerfSampleHelper* sh, TRAPS) {\n-      return create_long_counter(ns, name, u, sh, THREAD);\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":9,"deletions":113,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class PerfLongSampleHelper;\n@@ -40,1 +39,0 @@\n-typedef PerfLongSampleHelper PerfSampleHelper;\n","filename":"src\/hotspot\/share\/runtime\/perfDataTypes.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -69,4 +68,4 @@\n-  \/\/ Only destroy PerfData objects if we're at a safepoint and the\n-  \/\/ StatSampler is not active. Otherwise, we risk removing PerfData\n-  \/\/ objects that are currently being used by running JavaThreads\n-  \/\/ or the StatSampler. This method is invoked while we are not at\n+  \/\/ Only destroy PerfData objects if we're at a safepoint.\n+  \/\/ Otherwise, we risk removing PerfData objects\n+  \/\/ that are currently being used by running JavaThreads.\n+  \/\/ This method is invoked while we are not at\n@@ -78,1 +77,1 @@\n-  if (SafepointSynchronize::is_at_safepoint() && !StatSampler::is_active()) {\n+  if (SafepointSynchronize::is_at_safepoint()) {\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,349 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/perfData.inline.hpp\"\n-#include \"runtime\/statSampler.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-\n-\/\/ --------------------------------------------------------\n-\/\/ StatSamplerTask\n-\n-class StatSamplerTask : public PeriodicTask {\n-  public:\n-    StatSamplerTask(int interval_time) : PeriodicTask(interval_time) {}\n-    void task() { StatSampler::collect_sample(); }\n-};\n-\n-\n-\/\/----------------------------------------------------------\n-\/\/ Implementation of StatSampler\n-\n-StatSamplerTask*              StatSampler::_task   = nullptr;\n-PerfDataList*                 StatSampler::_sampled = nullptr;\n-\n-\/*\n- * the initialize method is called from the engage() method\n- * and is responsible for initializing various global variables.\n- *\/\n-void StatSampler::initialize() {\n-\n-  if (!UsePerfData) return;\n-\n-  \/\/ create performance data that could not be created prior\n-  \/\/ to vm_init_globals() or otherwise have no logical home.\n-\n-  create_misc_perfdata();\n-\n-  \/\/ get copy of the sampled list\n-  _sampled = PerfDataManager::sampled();\n-\n-}\n-\n-\/*\n- * The engage() method is called at initialization time via\n- * Thread::create_vm() to initialize the StatSampler and\n- * register it with the WatcherThread as a periodic task.\n- *\/\n-void StatSampler::engage() {\n-\n-  if (!UsePerfData) return;\n-\n-  if (!is_active()) {\n-\n-    initialize();\n-\n-    \/\/ start up the periodic task\n-    _task = new StatSamplerTask(PerfDataSamplingInterval);\n-    _task->enroll();\n-  }\n-}\n-\n-\n-\/*\n- * the disengage() method is responsible for deactivating the periodic\n- * task and, if logging was enabled, for logging the final sample. This\n- * method is called from before_exit() in java.cpp and is only called\n- * after the WatcherThread has been stopped.\n- *\/\n-void StatSampler::disengage() {\n-\n-  if (!UsePerfData) return;\n-\n-  if (!is_active())\n-    return;\n-\n-  \/\/ remove StatSamplerTask\n-  _task->disenroll();\n-  delete _task;\n-  _task = nullptr;\n-\n-  \/\/ force a final sample\n-  sample_data(_sampled);\n-}\n-\n-\/*\n- * the destroy method is responsible for releasing any resources used by\n- * the StatSampler prior to shutdown of the VM. this method is called from\n- * before_exit() in java.cpp and is only called after the WatcherThread\n- * has stopped.\n- *\/\n-void StatSampler::destroy() {\n-\n-  if (!UsePerfData) return;\n-\n-  if (_sampled != nullptr) {\n-    delete(_sampled);\n-    _sampled = nullptr;\n-  }\n-}\n-\n-\/*\n- * The sample_data() method is responsible for sampling the\n- * the data value for each PerfData instance in the given list.\n- *\/\n-void StatSampler::sample_data(PerfDataList* list) {\n-\n-  assert(list != nullptr, \"null list unexpected\");\n-\n-  for (int index = 0; index < list->length(); index++) {\n-    PerfData* item = list->at(index);\n-    item->sample();\n-  }\n-}\n-\n-\/*\n- * the collect_sample() method is the method invoked by the\n- * WatcherThread via the PeriodicTask::task() method. This method\n- * is responsible for collecting data samples from sampled\n- * PerfData instances every PerfDataSamplingInterval milliseconds.\n- * It is also responsible for logging the requested set of\n- * PerfData instances every _sample_count milliseconds. While\n- * logging data, it will output a column header after every _print_header\n- * rows of data have been logged.\n- *\/\n-void StatSampler::collect_sample() {\n-\n-  \/\/ future - check for new PerfData objects. PerfData objects might\n-  \/\/ get added to the PerfDataManager lists after we have already\n-  \/\/ built our local copies.\n-  \/\/\n-  \/\/ if (PerfDataManager::count() > previous) {\n-  \/\/   \/\/ get a new copy of the sampled list\n-  \/\/   if (_sampled != nullptr) {\n-  \/\/     delete(_sampled);\n-  \/\/     _sampled = nullptr;\n-  \/\/   }\n-  \/\/   _sampled = PerfDataManager::sampled();\n-  \/\/ }\n-\n-  assert(_sampled != nullptr, \"list not initialized\");\n-\n-  sample_data(_sampled);\n-}\n-\n-\/*\n- * Call into java.lang.System.getProperty to check that the value of the\n- * specified property matches\n- *\/\n-void StatSampler::assert_system_property(const char* name, const char* value, TRAPS) {\n-#ifdef ASSERT\n-  ResourceMark rm(THREAD);\n-\n-  \/\/ setup the arguments to getProperty\n-  Handle key_str   = java_lang_String::create_from_str(name, CHECK);\n-\n-  \/\/ return value\n-  JavaValue result(T_OBJECT);\n-\n-  \/\/ public static String getProperty(String key, String def);\n-  JavaCalls::call_static(&result,\n-                         vmClasses::System_klass(),\n-                         vmSymbols::getProperty_name(),\n-                         vmSymbols::string_string_signature(),\n-                         key_str,\n-                         CHECK);\n-\n-  oop value_oop = result.get_oop();\n-  assert(value_oop != nullptr, \"property must have a value\");\n-\n-  \/\/ convert Java String to utf8 string\n-  char* system_value = java_lang_String::as_utf8_string(value_oop);\n-\n-  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty. Our value is: %s, System.getProperty is: %s\",\n-         value, system_value);\n-#endif \/\/ ASSERT\n-}\n-\n-\/*\n- * Adds a constant counter of the given property. Asserts the value does not\n- * differ from the value retrievable from System.getProperty(name)\n- *\/\n-void StatSampler::add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS) {\n-  \/\/ the property must exist\n-  assert(value != nullptr, \"property name should be have a value: %s\", name);\n-  assert_system_property(name, value, CHECK);\n-  if (value != nullptr) {\n-    \/\/ create the property counter\n-    PerfDataManager::create_string_constant(name_space, name, value, CHECK);\n-  }\n-}\n-\n-\/*\n- * Adds a string constant of the given property. Retrieves the value via\n- * Arguments::get_property() and asserts the value for the does not differ from\n- * the value retrievable from System.getProperty()\n- *\/\n-void StatSampler::add_property_constant(CounterNS name_space, const char* name, TRAPS) {\n-  add_property_constant(name_space, name, Arguments::get_property(name), CHECK);\n-}\n-\n-\/*\n- * Adds a string constant of the given property. Retrieves the value via\n- * Arguments::get_property() and asserts the value for the does not differ from\n- * the value retrievable from System.getProperty()\n- *\/\n-void StatSampler::add_optional_property_constant(CounterNS name_space, const char* name, TRAPS) {\n-  const char* value = Arguments::get_property(name);\n-\n-  if (value != nullptr) {\n-    add_property_constant(name_space, name, value, CHECK);\n-  }\n-}\n-\n-\/*\n- * Method to create PerfStringConstants containing the values of various\n- * system properties. Constants are created from information known to HotSpot,\n- * but are initialized as-if getting the values from System.getProperty()\n- * during bootstrap.\n- *\n- * Property counters have a counter name space prefix prepended to the\n- * property name.\n- *\/\n-void StatSampler::create_system_property_instrumentation(TRAPS) {\n-\n-  \/\/ Non-writeable, constant properties\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.name\", \"Java Virtual Machine Specification\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.version\", JDK_Version::java_version(), CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.version\", VM_Version::vm_release(), CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.name\", VM_Version::vm_name(), CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.vendor\", VM_Version::vm_vendor(), CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"jdk.debug\", VM_Version::jdk_debug_level(), CHECK);\n-\n-  \/\/ Get remaining property constants via Arguments::get_property,\n-  \/\/ which does a linear search over the internal system properties list.\n-\n-  \/\/ SUN_PROPERTY properties\n-  add_property_constant(SUN_PROPERTY, \"sun.boot.library.path\", CHECK);\n-\n-  \/\/ JAVA_PROPERTY properties\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.version\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.vendor\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.vm.info\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.library.path\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.class.path\", CHECK);\n-  add_property_constant(JAVA_PROPERTY, \"java.home\", CHECK);\n-\n-  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.path\", CHECK);\n-  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.upgrade.path\", CHECK);\n-  add_optional_property_constant(JAVA_PROPERTY, \"jdk.module.main\", CHECK);\n-}\n-\n-\/*\n- * The create_misc_perfdata() method provides a place to create\n- * PerfData instances that would otherwise have no better place\n- * to exist.\n- *\/\n-void StatSampler::create_misc_perfdata() {\n-\n-  ResourceMark rm;\n-  EXCEPTION_MARK;\n-\n-  \/\/ numeric constants\n-\n-  \/\/ frequency of the native high resolution timer\n-  PerfDataManager::create_constant(SUN_OS, \"hrt.frequency\",\n-                                   PerfData::U_Hertz, os::elapsed_frequency(),\n-                                   CHECK);\n-\n-  \/\/ string constants\n-\n-  \/\/ create string instrumentation for various Java properties.\n-  create_system_property_instrumentation(CHECK);\n-\n-  \/\/ HotSpot flags (from .hotspotrc) and args (from command line)\n-  \/\/\n-  PerfDataManager::create_string_constant(JAVA_RT, \"vmFlags\",\n-                                          Arguments::jvm_flags(), CHECK);\n-  PerfDataManager::create_string_constant(JAVA_RT, \"vmArgs\",\n-                                          Arguments::jvm_args(), CHECK);\n-\n-  \/\/ java class name\/jar file and arguments to main class\n-  \/\/ note: name is coordinated with launcher and Arguments.cpp\n-  PerfDataManager::create_string_constant(SUN_RT, \"javaCommand\",\n-                                          Arguments::java_command(), CHECK);\n-\n-  \/\/ the Java VM Internal version string\n-  PerfDataManager::create_string_constant(SUN_RT, \"internalVersion\",\n-                                         VM_Version::internal_vm_info_string(),\n-                                         CHECK);\n-\n-  \/\/ create sampled instrumentation objects\n-  create_sampled_perfdata();\n-}\n-\n-\/*\n- * helper class to provide for sampling of the elapsed_counter value\n- * maintained in the OS class.\n- *\/\n-class HighResTimeSampler : public PerfSampleHelper {\n-  public:\n-    jlong take_sample() { return os::elapsed_counter(); }\n-};\n-\n-\/*\n- * the create_sampled_perdata() method provides a place to instantiate\n- * sampled PerfData instances that would otherwise have no better place\n- * to exist.\n- *\/\n-void StatSampler::create_sampled_perfdata() {\n-\n-  EXCEPTION_MARK;\n-\n-  \/\/ setup sampling of the elapsed time counter maintained in the\n-  \/\/ the os class. This counter can be used as either a time stamp\n-  \/\/ for each logged entry or as a liveness indicator for the VM.\n-  PerfSampleHelper* psh = new HighResTimeSampler();\n-  PerfDataManager::create_counter(SUN_OS, \"hrt.ticks\",\n-                                  PerfData::U_Ticks, psh, CHECK);\n-}\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":0,"deletions":349,"binary":false,"changes":349,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_STATSAMPLER_HPP\n-#define SHARE_RUNTIME_STATSAMPLER_HPP\n-\n-#include \"runtime\/perfData.hpp\"\n-#include \"runtime\/task.hpp\"\n-\n-class StatSamplerTask;\n-\n-\/*\n- * The StatSampler class is responsible for periodically updating\n- * sampled PerfData instances and writing the sampled values to the\n- * PerfData memory region.\n- *\n- * In addition it is also responsible for providing a home for\n- * PerfData instances that otherwise have no better home.\n- *\/\n-class StatSampler : AllStatic {\n-\n-  friend class StatSamplerTask;\n-\n-  private:\n-\n-    static StatSamplerTask* _task;\n-    static PerfDataList* _sampled;\n-\n-    static void collect_sample();\n-    static void create_misc_perfdata();\n-    static void create_sampled_perfdata();\n-    static void sample_data(PerfDataList* list);\n-    static void assert_system_property(const char* name, const char* value, TRAPS);\n-    static void add_property_constant(CounterNS name_space, const char* name, TRAPS);\n-    static void add_optional_property_constant(CounterNS name_space, const char* name, TRAPS);\n-    static void add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS);\n-    static void create_system_property_instrumentation(TRAPS);\n-\n-  public:\n-    \/\/ Start\/stop the sampler\n-    static void engage();\n-    static void disengage();\n-\n-    static bool is_active() { return _task != nullptr; }\n-\n-    static void initialize();\n-    static void destroy();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_STATSAMPLER_HPP\n","filename":"src\/hotspot\/share\/runtime\/statSampler.hpp","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -91,1 +92,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -852,1 +852,1 @@\n-  StatSampler::engage();\n+  PerfDataManager::create_misc_perfdata();\n@@ -906,1 +906,1 @@\n-\/\/      > stop StatSampler, watcher thread,\n+\/\/      > stop watcher thread,\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+        if (e instanceof Timestamp) {\n+            return ((Timestamp)e).getValue();\n+        }\n+\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/ExpressionExecuter.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (e instanceof Literal) {\n+        if (e instanceof Literal || e instanceof Timestamp) {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/ExpressionResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,0 +225,7 @@\n+    \/**\n+     * determine if the given word is the timestamp key word\n+     *\/\n+    private boolean isTimestamp(String word) {\n+        return word.equals(\"jstat.timestamp\");\n+    }\n+\n@@ -300,1 +307,1 @@\n-     *  Primary -> Literal | Identifier | '(' Expression ')'\n+     *  Primary -> Literal | Timestamp | Identifier | '(' Expression ')'\n@@ -318,1 +325,1 @@\n-            e = new Identifier(s);\n+            e = isTimestamp(s) ? new Timestamp() : new Identifier(s);\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/Parser.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.tools.jstat;\n+\n+public class Timestamp extends Expression {\n+\n+    public Timestamp() {\n+        super();\n+    }\n+\n+    public Object getValue() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    public String toString() {\n+        return \"jstat.timestamp\";\n+    }\n+}\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/Timestamp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-    data (sun.os.hrt.ticks\/sun.os.hrt.frequency)\n+    data ((jstat.timestamp - sun.rt.createVmBeginTime) \/ 1000)\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jstat\/resources\/jstat_options","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}