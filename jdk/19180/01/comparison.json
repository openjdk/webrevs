{"files":[{"patch":"@@ -112,1 +112,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -116,8 +115,4 @@\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ ldrw(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ ldrb(tmp1, in_progress);\n-  }\n-  __ cbzw(tmp1, done);\n+  \/\/ Is marking still active?\n+  Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ ldrb(tmp, gc_state);\n+  __ tbz(tmp, ShenandoahHeap::MARKING_BITPOS, done);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -120,7 +119,4 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ lwu(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbu(tmp1, in_progress);\n-  }\n-  __ beqz(tmp1, done);\n+  Address gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ lbu(t1, gc_state);\n+  __ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n+  __ beqz(t1, done);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  BasicType flag_type;\n+\n@@ -64,9 +64,1 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    flag_type = T_INT;\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1,\n-              \"Assumption\");\n-    \/\/ Use unsigned type T_BOOLEAN here rather than signed T_BYTE since some platforms, eg. ARM,\n-    \/\/ need to use unsigned instructions to use the large offset to load the satb_mark_queue.\n-    flag_type = T_BOOLEAN;\n-  }\n+\n@@ -74,5 +66,5 @@\n-  LIR_Address* mark_active_flag_addr =\n-    new LIR_Address(thrd,\n-                    in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()),\n-                    flag_type);\n-  \/\/ Read the marking-in-progress flag.\n+  LIR_Address* gc_state_addr =\n+          new LIR_Address(thrd,\n+                          in_bytes(ShenandoahThreadLocalData::gc_state_offset()),\n+                          T_BYTE);\n+  \/\/ Read the gc_state flag.\n@@ -80,1 +72,15 @@\n-  __ load(mark_active_flag_addr, flag_val);\n+  __ load(gc_state_addr, flag_val);\n+\n+  \/\/ Create a mask to test if the marking bit is set.\n+  \/\/ TODO: can we directly test if bit is set?\n+  LIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n+  LIR_Opr mask_reg = gen->new_register(T_INT);\n+  __ move(mask, mask_reg);\n+\n+  if (two_operand_lir_form) {\n+    __ logical_and(flag_val, mask_reg, flag_val);\n+  } else {\n+    LIR_Opr masked_flag = gen->new_register(T_INT);\n+    __ logical_and(flag_val, mask_reg, masked_flag);\n+    flag_val = masked_flag;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -983,1 +983,1 @@\n-    const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());\n+    const int gc_state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());\n@@ -991,1 +991,4 @@\n-      if (x == nullptr || x == compile->top()) continue;\n+      if (x == nullptr || x == compile->top()) {\n+        continue;\n+      }\n+\n@@ -1019,1 +1022,1 @@\n-                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n+                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == gc_state_offset) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -161,4 +161,0 @@\n-  static ByteSize satb_mark_queue_active_offset() {\n-    return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}