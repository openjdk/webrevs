{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.util.List;\n@@ -32,1 +33,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -95,1 +95,1 @@\n-    public static final RegisterArray cpuRegisters = new RegisterArray(\n+    public static final List<Register> cpuRegisters = List.of(\n@@ -141,1 +141,1 @@\n-    public static final RegisterArray simdRegisters = new RegisterArray(\n+    public static final List<Register> simdRegisters = List.of(\n@@ -150,1 +150,1 @@\n-    public static final RegisterArray allRegisters = new RegisterArray(\n+    public static final List<Register> allRegisters = List.of(\n@@ -192,14 +192,1 @@\n-    \/**\n-     * Set of flags to control code emission.\n-     *\/\n-    public enum Flag {\n-        UseCRC32,\n-        UseSIMDForMemoryOps,\n-        AvoidUnalignedAccesses,\n-        UseLSE,\n-        UseBlockZeroing\n-    }\n-\n-    private final EnumSet<Flag> flags;\n-\n-    public AArch64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+    public AArch64(EnumSet<CPUFeature> features) {\n@@ -208,1 +195,0 @@\n-        this.flags = flags;\n@@ -216,4 +202,0 @@\n-    public EnumSet<Flag> getFlags() {\n-        return flags;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.List;\n@@ -37,1 +38,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -89,1 +89,1 @@\n-    public static final Register[] cpuRegisters = {\n+    public static final List<Register> cpuRegisters = List.of(\n@@ -92,1 +92,8 @@\n-    };\n+    );\n+\n+    public static final List<Register> cpuRegistersAPX = List.of(\n+        rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi,\n+         r8,  r9, r10, r11, r12, r13, r14, r15,\n+        r16, r17, r18, r19, r20, r21, r22, r23,\n+        r24, r25, r26, r27, r28, r29, r30, r31\n+    );\n@@ -133,1 +140,1 @@\n-    public static final Register[] xmmRegistersSSE = {\n+    public static final List<Register> xmmRegistersSSE = List.of(\n@@ -136,1 +143,1 @@\n-    };\n+    );\n@@ -138,1 +145,1 @@\n-    public static final Register[] xmmRegistersAVX512 = {\n+    public static final List<Register> xmmRegistersAVX512 = List.of(\n@@ -143,1 +150,1 @@\n-    };\n+    );\n@@ -156,1 +163,1 @@\n-    public static final RegisterArray valueRegistersSSE = new RegisterArray(\n+    public static final List<Register> valueRegistersSSE = List.of(\n@@ -163,1 +170,1 @@\n-    public static final RegisterArray valueRegistersAVX512 = new RegisterArray(\n+    public static final List<Register> valueRegistersAVX512 = List.of(\n@@ -173,0 +180,21 @@\n+    public static final List<Register> valueRegistersSSEAndAPX = List.of(\n+        rax,  rcx,  rdx,   rbx,   rsp,   rbp,   rsi,   rdi,\n+        r8,   r9,   r10,   r11,   r12,   r13,   r14,   r15,\n+        r16,  r17,  r18,   r19,   r20,   r21,   r22,   r23,\n+        r24,  r25,  r26,   r27,   r28,   r29,   r30,   r31,\n+        xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+        xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15\n+    );\n+\n+    public static final List<Register> valueRegistersAVX512AndAPX = List.of(\n+        rax,  rcx,  rdx,   rbx,   rsp,   rbp,   rsi,   rdi,\n+        r8,   r9,   r10,   r11,   r12,   r13,   r14,   r15,\n+        r16,  r17,  r18,   r19,   r20,   r21,   r22,   r23,\n+        r24,  r25,  r26,   r27,   r28,   r29,   r30,   r31,\n+        xmm0, xmm1, xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+        xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+        xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+        xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31,\n+        k0, k1, k2, k3, k4, k5, k6, k7\n+    );\n+\n@@ -178,1 +206,1 @@\n-    public static final RegisterArray allRegisters = new RegisterArray(\n+    public static final List<Register> allRegisters = List.of(\n@@ -267,10 +295,0 @@\n-    \/**\n-     * Set of flags to control code emission.\n-     *\/\n-    public enum Flag {\n-        UseCountLeadingZerosInstruction,\n-        UseCountTrailingZerosInstruction\n-    }\n-\n-    private final EnumSet<Flag> flags;\n-\n@@ -281,1 +299,1 @@\n-    public AMD64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+    public AMD64(EnumSet<CPUFeature> features) {\n@@ -284,1 +302,0 @@\n-        this.flags = flags;\n@@ -308,4 +325,0 @@\n-    public EnumSet<Flag> getFlags() {\n-        return flags;\n-    }\n-\n@@ -313,2 +326,8 @@\n-    public RegisterArray getAvailableValueRegisters() {\n-        if (features.contains(CPUFeature.AVX512F)) {\n+    public List<Register> getAvailableValueRegisters() {\n+        if (features.contains(CPUFeature.APX_F)) {\n+            if (features.contains(CPUFeature.AVX512F)) {\n+                return valueRegistersAVX512AndAPX;\n+            } else {\n+                return valueRegistersSSEAndAPX;\n+            }\n+        } else if (features.contains(CPUFeature.AVX512F)) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":47,"deletions":28,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -53,1 +54,1 @@\n-    private final RegisterArray registers;\n+    private final List<Register> registers;\n@@ -82,1 +83,1 @@\n-    protected Architecture(String name, PlatformKind wordKind, ByteOrder byteOrder, boolean unalignedMemoryAccess, RegisterArray registers, int implicitMemoryBarriers,\n+    protected Architecture(String name, PlatformKind wordKind, ByteOrder byteOrder, boolean unalignedMemoryAccess, List<Register> registers, int implicitMemoryBarriers,\n@@ -147,1 +148,1 @@\n-    public RegisterArray getRegisters() {\n+    public List<Register> getRegisters() {\n@@ -155,1 +156,1 @@\n-    public RegisterArray getAvailableValueRegisters() {\n+    public List<Register> getAvailableValueRegisters() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/Architecture.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.List;\n+\n@@ -52,1 +54,1 @@\n-    private final AllocatableValue[] argumentLocations;\n+    private final List<AllocatableValue> argumentLocations;\n@@ -66,1 +68,1 @@\n-        this.argumentLocations = argumentLocations;\n+        this.argumentLocations = List.of(argumentLocations);\n@@ -83,1 +85,1 @@\n-        return argumentLocations[index];\n+        return argumentLocations.get(index);\n@@ -97,1 +99,1 @@\n-        return argumentLocations.length;\n+        return argumentLocations.size();\n@@ -103,6 +105,2 @@\n-    @SuppressFBWarnings(value = \"EI_EXPOSE_REP\", justification = \"FB false positive\")\n-    public AllocatableValue[] getArguments() {\n-        if (argumentLocations.length == 0) {\n-            return argumentLocations;\n-        }\n-        return argumentLocations.clone();\n+    public List<AllocatableValue> getArguments() {\n+        return argumentLocations;\n@@ -128,2 +126,2 @@\n-        for (int i = 0; i < argumentLocations.length; i++) {\n-            Value location = argumentLocations[i];\n+        for (int i = 0; i < argumentLocations.size(); i++) {\n+            Value location = argumentLocations.get(i);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/CallingConvention.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.code;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-\/**\n- * An immutable ordered list of registers. Only required because Java lacks immutable arrays.\n- *\/\n-public final class RegisterArray implements Iterable<Register> {\n-\n-    private final Register[] registers;\n-    private int hash;\n-\n-    public RegisterArray(Register... registers) {\n-        this.registers = registers;\n-    }\n-\n-    public RegisterArray(Collection<Register> registers) {\n-        this.registers = registers.toArray(new Register[registers.size()]);\n-    }\n-\n-    \/**\n-     * Gets the number of registers.\n-     *\/\n-    public int size() {\n-        return registers.length;\n-    }\n-\n-    \/**\n-     * Gets the register at a given index.\n-     *\n-     * @param index the index of the register to retrieve\n-     *\/\n-    public Register get(int index) {\n-        return registers[index];\n-    }\n-\n-    public void addTo(Collection<Register> collection) {\n-        collection.addAll(Arrays.asList(registers));\n-    }\n-\n-    \/**\n-     * Gets an immutable view of the registers as a list.\n-     *\/\n-    public List<Register> asList() {\n-        return Collections.unmodifiableList(Arrays.asList(registers));\n-    }\n-\n-    \/**\n-     * Gets a copy of the registers as an array.\n-     *\/\n-    public Register[] toArray() {\n-        return registers.clone();\n-    }\n-\n-    @Override\n-    public Iterator<Register> iterator() {\n-        return Arrays.asList(registers).iterator();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        if (hash == 0 && registers.length > 0) {\n-            hash = Arrays.hashCode(registers);\n-        }\n-        return hash;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj instanceof RegisterArray) {\n-            return Arrays.equals(registers, ((RegisterArray) obj).registers);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return Arrays.toString(registers);\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/RegisterArray.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    public static RegisterAttributes[] createMap(RegisterConfig registerConfig, RegisterArray registers) {\n+    public static List<RegisterAttributes> createMap(RegisterConfig registerConfig, List<Register> registers) {\n@@ -60,3 +60,3 @@\n-        List<Register> callerSaveRegisters = registerConfig.getCallerSaveRegisters().asList();\n-        List<Register> calleeSaveRegisters = registerConfig.getCalleeSaveRegisters() == null ? Collections.emptyList() : registerConfig.getCalleeSaveRegisters().asList();\n-        List<Register> allocatableRegisters = registerConfig.getAllocatableRegisters().asList();\n+        List<Register> callerSaveRegisters = registerConfig.getCallerSaveRegisters();\n+        List<Register> calleeSaveRegisters = registerConfig.getCalleeSaveRegisters() == null ? Collections.emptyList() : registerConfig.getCalleeSaveRegisters();\n+        List<Register> allocatableRegisters = registerConfig.getAllocatableRegisters();\n@@ -77,1 +77,1 @@\n-        return map;\n+        return List.of(map);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/RegisterAttributes.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.List;\n@@ -74,1 +75,1 @@\n-    RegisterArray getCallingConventionRegisters(Type type, JavaKind kind);\n+    List<Register> getCallingConventionRegisters(Type type, JavaKind kind);\n@@ -79,1 +80,1 @@\n-    RegisterArray getAllocatableRegisters();\n+    List<Register> getAllocatableRegisters();\n@@ -85,1 +86,1 @@\n-    RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers);\n+    List<Register> filterAllocatableRegisters(PlatformKind kind, List<Register> registers);\n@@ -90,1 +91,1 @@\n-    RegisterArray getCallerSaveRegisters();\n+    List<Register> getCallerSaveRegisters();\n@@ -95,1 +96,1 @@\n-    RegisterArray getCalleeSaveRegisters();\n+    List<Register> getCalleeSaveRegisters();\n@@ -111,1 +112,1 @@\n-     * @return an array where an element at index i holds the attributes of the register whose\n+     * @return a list where an element at index i holds the attributes of the register whose\n@@ -114,1 +115,1 @@\n-    RegisterAttributes[] getAttributesMap();\n+    List<RegisterAttributes> getAttributesMap();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/RegisterConfig.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,22 +55,0 @@\n-    private static EnumSet<AArch64.Flag> computeFlags(AArch64HotSpotVMConfig config) {\n-        EnumSet<AArch64.Flag> flags = EnumSet.noneOf(AArch64.Flag.class);\n-\n-        if (config.useCRC32) {\n-            flags.add(AArch64.Flag.UseCRC32);\n-        }\n-        if (config.useSIMDForMemoryOps) {\n-            flags.add(AArch64.Flag.UseSIMDForMemoryOps);\n-        }\n-        if (config.avoidUnalignedAccesses) {\n-            flags.add(AArch64.Flag.AvoidUnalignedAccesses);\n-        }\n-        if (config.useLSE) {\n-            flags.add(AArch64.Flag.UseLSE);\n-        }\n-        if (config.useBlockZeroing) {\n-            flags.add(AArch64.Flag.UseBlockZeroing);\n-        }\n-\n-        return flags;\n-    }\n-\n@@ -81,1 +59,1 @@\n-        Architecture arch = new AArch64(computeFeatures(config), computeFlags(config));\n+        Architecture arch = new AArch64(computeFeatures(config));\n@@ -116,1 +94,0 @@\n-    @SuppressWarnings(\"try\")\n@@ -118,1 +95,0 @@\n-\n@@ -128,2 +104,2 @@\n-        try (InitTimer t = timer(\"create providers\")) {\n-            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+        try (InitTimer _ = timer(\"create providers\")) {\n+            try (InitTimer _ = timer(\"create MetaAccess provider\")) {\n@@ -132,1 +108,1 @@\n-            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+            try (InitTimer _ = timer(\"create RegisterConfig\")) {\n@@ -135,1 +111,1 @@\n-            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+            try (InitTimer _ = timer(\"create CodeCache provider\")) {\n@@ -138,1 +114,1 @@\n-            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+            try (InitTimer _ = timer(\"create ConstantReflection provider\")) {\n@@ -141,1 +117,1 @@\n-            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+            try (InitTimer _ = timer(\"create StackIntrospection provider\")) {\n@@ -145,1 +121,1 @@\n-        try (InitTimer rt = timer(\"instantiate backend\")) {\n+        try (InitTimer _ = timer(\"instantiate backend\")) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -82,1 +81,1 @@\n-    private final RegisterArray allocatable;\n+    private final List<Register> allocatable;\n@@ -87,1 +86,1 @@\n-    private final RegisterArray callerSaved;\n+    private final List<Register> callerSaved;\n@@ -91,1 +90,1 @@\n-    private final RegisterAttributes[] attributesMap;\n+    private final List<RegisterAttributes> attributesMap;\n@@ -94,1 +93,1 @@\n-    public RegisterArray getAllocatableRegisters() {\n+    public List<Register> getAllocatableRegisters() {\n@@ -99,1 +98,1 @@\n-    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+    public List<Register> filterAllocatableRegisters(PlatformKind kind, List<Register> registers) {\n@@ -107,1 +106,1 @@\n-        return new RegisterArray(list);\n+        return List.copyOf(list);\n@@ -111,2 +110,2 @@\n-    public RegisterAttributes[] getAttributesMap() {\n-        return attributesMap.clone();\n+    public List<RegisterAttributes> getAttributesMap() {\n+        return attributesMap;\n@@ -115,3 +114,3 @@\n-    private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(r1, r2, r3, r4, r5, r6, r7, r0);\n-    private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(r0, r1, r2, r3, r4, r5, r6, r7);\n-    private final RegisterArray simdParameterRegisters = new RegisterArray(v0, v1, v2, v3, v4, v5, v6, v7);\n+    private final List<Register> javaGeneralParameterRegisters = List.of(r1, r2, r3, r4, r5, r6, r7, r0);\n+    private final List<Register> nativeGeneralParameterRegisters = List.of(r0, r1, r2, r3, r4, r5, r6, r7);\n+    private final List<Register> simdParameterRegisters = List.of(v0, v1, v2, v3, v4, v5, v6, v7);\n@@ -136,1 +135,1 @@\n-    private static final RegisterArray reservedRegisters = new RegisterArray(rscratch1, rscratch2, threadRegister, fp, lr, r31, zr, sp);\n+    private static final List<Register> reservedRegisters = List.of(rscratch1, rscratch2, threadRegister, fp, lr, r31, zr, sp);\n@@ -138,2 +137,2 @@\n-    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase, boolean canUsePlatformRegister) {\n-        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+    private static List<Register> initAllocatable(Architecture arch, boolean reserveForHeapBase, boolean canUsePlatformRegister) {\n+        List<Register> allRegisters = arch.getAvailableValueRegisters();\n@@ -141,1 +140,0 @@\n-        List<Register> reservedRegistersList = reservedRegisters.asList();\n@@ -145,1 +143,1 @@\n-            if (reservedRegistersList.contains(reg)) {\n+            if (reservedRegisters.contains(reg)) {\n@@ -162,1 +160,1 @@\n-        return new RegisterArray(registers);\n+        return List.of(registers);\n@@ -170,1 +168,1 @@\n-    public AArch64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {\n+    public AArch64HotSpotRegisterConfig(TargetDescription target, List<Register> allocatable) {\n@@ -175,5 +173,5 @@\n-        allocatable.addTo(callerSaveSet);\n-        simdParameterRegisters.addTo(callerSaveSet);\n-        javaGeneralParameterRegisters.addTo(callerSaveSet);\n-        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n-        callerSaved = new RegisterArray(callerSaveSet);\n+        callerSaveSet.addAll(allocatable);\n+        callerSaveSet.addAll(simdParameterRegisters);\n+        callerSaveSet.addAll(javaGeneralParameterRegisters);\n+        callerSaveSet.addAll(nativeGeneralParameterRegisters);\n+        callerSaved = List.copyOf(callerSaveSet);\n@@ -186,1 +184,1 @@\n-    public RegisterArray getCallerSaveRegisters() {\n+    public List<Register> getCallerSaveRegisters() {\n@@ -191,1 +189,1 @@\n-    public RegisterArray getCalleeSaveRegisters() {\n+    public List<Register> getCalleeSaveRegisters() {\n@@ -212,1 +210,1 @@\n-    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+    public List<Register> getCallingConventionRegisters(Type type, JavaKind kind) {\n@@ -252,1 +250,1 @@\n-    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n+    private CallingConvention callingConvention(List<Register> generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotRegisterConfig.java","additions":27,"deletions":29,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,12 +40,0 @@\n-\n-    \/\/ CPU Capabilities\n-\n-    \/*\n-     * These flags are set based on the corresponding command line flags.\n-     *\/\n-    final boolean useCRC32 = getFlag(\"UseCRC32\", Boolean.class);\n-    final boolean useSIMDForMemoryOps = getFlag(\"UseSIMDForMemoryOps\", Boolean.class);\n-    final boolean avoidUnalignedAccesses = getFlag(\"AvoidUnalignedAccesses\", Boolean.class);\n-    final boolean useLSE = getFlag(\"UseLSE\", Boolean.class);\n-    final boolean useBlockZeroing = getFlag(\"UseBlockZeroing\", Boolean.class);\n-\n@@ -53,14 +41,0 @@\n-\n-    \/*\n-     * These flags are set if the corresponding support is in the hardware.\n-     *\/\n-    final long aarch64FP = getConstant(\"VM_Version::CPU_FP\", Long.class);\n-    final long aarch64ASIMD = getConstant(\"VM_Version::CPU_ASIMD\", Long.class);\n-    final long aarch64EVTSTRM = getConstant(\"VM_Version::CPU_EVTSTRM\", Long.class);\n-    final long aarch64AES = getConstant(\"VM_Version::CPU_AES\", Long.class);\n-    final long aarch64PMULL = getConstant(\"VM_Version::CPU_PMULL\", Long.class);\n-    final long aarch64SHA1 = getConstant(\"VM_Version::CPU_SHA1\", Long.class);\n-    final long aarch64SHA2 = getConstant(\"VM_Version::CPU_SHA2\", Long.class);\n-    final long aarch64CRC32 = getConstant(\"VM_Version::CPU_CRC32\", Long.class);\n-    final long aarch64LSE = getConstant(\"VM_Version::CPU_LSE\", Long.class);\n-    final long aarch64A53MAC = getConstant(\"VM_Version::CPU_A53MAC\", Long.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotVMConfig.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import jdk.internal.util.OperatingSystem;\n@@ -52,1 +52,0 @@\n-        assert config.useSSE >= 2 : \"minimum config for x64\";\n@@ -59,2 +58,2 @@\n-        features.add(AMD64.CPUFeature.SSE);\n-        features.add(AMD64.CPUFeature.SSE2);\n+        assert features.contains(AMD64.CPUFeature.SSE) : \"minimum config for x64\";\n+        assert features.contains(AMD64.CPUFeature.SSE2) : \"minimum config for x64\";\n@@ -64,11 +63,0 @@\n-    private static EnumSet<AMD64.Flag> computeFlags(AMD64HotSpotVMConfig config) {\n-        EnumSet<AMD64.Flag> flags = EnumSet.noneOf(AMD64.Flag.class);\n-        if (config.useCountLeadingZerosInstruction) {\n-            flags.add(AMD64.Flag.UseCountLeadingZerosInstruction);\n-        }\n-        if (config.useCountTrailingZerosInstruction) {\n-            flags.add(AMD64.Flag.UseCountTrailingZerosInstruction);\n-        }\n-        return flags;\n-    }\n-\n@@ -79,1 +67,1 @@\n-        Architecture arch = new AMD64(computeFeatures(config), computeFlags(config));\n+        Architecture arch = new AMD64(computeFeatures(config));\n@@ -88,1 +76,1 @@\n-        return new AMD64HotSpotRegisterConfig(target, config.useCompressedOops, config.windowsOs);\n+        return new AMD64HotSpotRegisterConfig(target, config.useCompressedOops, OperatingSystem.isWindows());\n@@ -110,1 +98,0 @@\n-    @SuppressWarnings(\"try\")\n@@ -121,2 +108,2 @@\n-        try (InitTimer t = timer(\"create providers\")) {\n-            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+        try (InitTimer _ = timer(\"create providers\")) {\n+            try (InitTimer _ = timer(\"create MetaAccess provider\")) {\n@@ -125,1 +112,1 @@\n-            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+            try (InitTimer _ = timer(\"create RegisterConfig\")) {\n@@ -128,1 +115,1 @@\n-            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+            try (InitTimer _ = timer(\"create CodeCache provider\")) {\n@@ -131,1 +118,1 @@\n-            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+            try (InitTimer _ = timer(\"create ConstantReflection provider\")) {\n@@ -134,1 +121,1 @@\n-            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+            try (InitTimer _ = timer(\"create StackIntrospection provider\")) {\n@@ -138,1 +125,1 @@\n-        try (InitTimer rt = timer(\"instantiate backend\")) {\n+        try (InitTimer _ = timer(\"instantiate backend\")) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -72,1 +71,1 @@\n-    private final RegisterArray allocatable;\n+    private final List<Register> allocatable;\n@@ -77,1 +76,1 @@\n-    private final RegisterArray callerSaved;\n+    private final List<Register> callerSaved;\n@@ -81,1 +80,1 @@\n-    private final RegisterAttributes[] attributesMap;\n+    private final List<RegisterAttributes> attributesMap;\n@@ -84,1 +83,1 @@\n-    public RegisterArray getAllocatableRegisters() {\n+    public List<Register> getAllocatableRegisters() {\n@@ -89,1 +88,1 @@\n-    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+    public List<Register> filterAllocatableRegisters(PlatformKind kind, List<Register> registers) {\n@@ -97,1 +96,1 @@\n-        RegisterArray ret = new RegisterArray(list);\n+        List<Register> ret = List.copyOf(list);\n@@ -102,2 +101,2 @@\n-    public RegisterAttributes[] getAttributesMap() {\n-        return attributesMap.clone();\n+    public List<RegisterAttributes> getAttributesMap() {\n+        return attributesMap;\n@@ -106,4 +105,4 @@\n-    private final RegisterArray javaGeneralParameterRegisters;\n-    private final RegisterArray nativeGeneralParameterRegisters;\n-    private final RegisterArray javaXMMParameterRegisters;\n-    private final RegisterArray nativeXMMParameterRegisters;\n+    private final List<Register> javaGeneralParameterRegisters;\n+    private final List<Register> nativeGeneralParameterRegisters;\n+    private final List<Register> javaXMMParameterRegisters;\n+    private final List<Register> nativeXMMParameterRegisters;\n@@ -118,1 +117,1 @@\n-    private static final RegisterArray reservedRegisters = new RegisterArray(rsp, r15);\n+    private static final List<Register> reservedRegisters = List.of(rsp, r15);\n@@ -120,2 +119,2 @@\n-    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n-        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+    private static List<Register> initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n+        List<Register> allRegisters = arch.getAvailableValueRegisters();\n@@ -123,1 +122,0 @@\n-        List<Register> reservedRegistersList = reservedRegisters.asList();\n@@ -127,1 +125,1 @@\n-            if (reservedRegistersList.contains(reg)) {\n+            if (reservedRegisters.contains(reg)) {\n@@ -140,1 +138,1 @@\n-        return new RegisterArray(registers);\n+        return List.of(registers);\n@@ -148,1 +146,1 @@\n-    public AMD64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable, boolean windowsOS) {\n+    public AMD64HotSpotRegisterConfig(TargetDescription target, List<Register> allocatable, boolean windowsOS) {\n@@ -153,3 +151,3 @@\n-            javaGeneralParameterRegisters = new RegisterArray(rdx, r8, r9, rdi, rsi, rcx);\n-            nativeGeneralParameterRegisters = new RegisterArray(rcx, rdx, r8, r9);\n-            nativeXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3);\n+            javaGeneralParameterRegisters = List.of(rdx, r8, r9, rdi, rsi, rcx);\n+            nativeGeneralParameterRegisters = List.of(rcx, rdx, r8, r9);\n+            nativeXMMParameterRegisters = List.of(xmm0, xmm1, xmm2, xmm3);\n@@ -158,3 +156,3 @@\n-            javaGeneralParameterRegisters = new RegisterArray(rsi, rdx, rcx, r8, r9, rdi);\n-            nativeGeneralParameterRegisters = new RegisterArray(rdi, rsi, rdx, rcx, r8, r9);\n-            nativeXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);\n+            javaGeneralParameterRegisters = List.of(rsi, rdx, rcx, r8, r9, rdi);\n+            nativeGeneralParameterRegisters = List.of(rdi, rsi, rdx, rcx, r8, r9);\n+            nativeXMMParameterRegisters = List.of(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);\n@@ -163,1 +161,1 @@\n-        javaXMMParameterRegisters = new RegisterArray(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);\n+        javaXMMParameterRegisters = List.of(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);\n@@ -167,5 +165,5 @@\n-        allocatable.addTo(callerSaveSet);\n-        javaXMMParameterRegisters.addTo(callerSaveSet);\n-        callerSaveSet.addAll(javaGeneralParameterRegisters.asList());\n-        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n-        callerSaved = new RegisterArray(callerSaveSet);\n+        callerSaveSet.addAll(allocatable);\n+        callerSaveSet.addAll(javaXMMParameterRegisters);\n+        callerSaveSet.addAll(javaGeneralParameterRegisters);\n+        callerSaveSet.addAll(nativeGeneralParameterRegisters);\n+        callerSaved = List.copyOf(callerSaveSet);\n@@ -178,1 +176,1 @@\n-    public RegisterArray getCallerSaveRegisters() {\n+    public List<Register> getCallerSaveRegisters() {\n@@ -183,1 +181,1 @@\n-    public RegisterArray getCalleeSaveRegisters() {\n+    public List<Register> getCalleeSaveRegisters() {\n@@ -204,1 +202,1 @@\n-    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+    public List<Register> getCallingConventionRegisters(Type type, JavaKind kind) {\n@@ -240,1 +238,1 @@\n-    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, RegisterArray xmmParameterRegisters, boolean unified, JavaType returnType, JavaType[] parameterTypes,\n+    private CallingConvention callingConvention(List<Register> generalParameterRegisters, List<Register> xmmParameterRegisters, boolean unified, JavaType returnType, JavaType[] parameterTypes,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotRegisterConfig.java","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.vm.ci.services.Services;\n-import jdk.internal.util.OperatingSystem;\n@@ -39,4 +37,0 @@\n-    final boolean windowsOs = OperatingSystem.isWindows();\n-\n-    final boolean useCountLeadingZerosInstruction = getFlag(\"UseCountLeadingZerosInstruction\", Boolean.class);\n-    final boolean useCountTrailingZerosInstruction = getFlag(\"UseCountTrailingZerosInstruction\", Boolean.class);\n@@ -44,1 +38,0 @@\n-\n@@ -48,47 +41,0 @@\n-\n-    \/\/ CPU capabilities\n-    final int useSSE = getFlag(\"UseSSE\", Integer.class);\n-    final int useAVX = getFlag(\"UseAVX\", Integer.class);\n-\n-    \/\/ CPU feature flags\n-    final long amd64CX8 = getConstant(\"VM_Version::CPU_CX8\", Long.class);\n-    final long amd64CMOV = getConstant(\"VM_Version::CPU_CMOV\", Long.class);\n-    final long amd64FXSR = getConstant(\"VM_Version::CPU_FXSR\", Long.class);\n-    final long amd64HT = getConstant(\"VM_Version::CPU_HT\", Long.class);\n-    final long amd64MMX = getConstant(\"VM_Version::CPU_MMX\", Long.class);\n-    final long amd643DNOWPREFETCH = getConstant(\"VM_Version::CPU_3DNOW_PREFETCH\", Long.class);\n-    final long amd64SSE = getConstant(\"VM_Version::CPU_SSE\", Long.class);\n-    final long amd64SSE2 = getConstant(\"VM_Version::CPU_SSE2\", Long.class);\n-    final long amd64SSE3 = getConstant(\"VM_Version::CPU_SSE3\", Long.class);\n-    final long amd64SSSE3 = getConstant(\"VM_Version::CPU_SSSE3\", Long.class);\n-    final long amd64SSE4A = getConstant(\"VM_Version::CPU_SSE4A\", Long.class);\n-    final long amd64SSE41 = getConstant(\"VM_Version::CPU_SSE4_1\", Long.class);\n-    final long amd64SSE42 = getConstant(\"VM_Version::CPU_SSE4_2\", Long.class);\n-    final long amd64POPCNT = getConstant(\"VM_Version::CPU_POPCNT\", Long.class);\n-    final long amd64LZCNT = getConstant(\"VM_Version::CPU_LZCNT\", Long.class);\n-    final long amd64TSC = getConstant(\"VM_Version::CPU_TSC\", Long.class);\n-    final long amd64TSCINV = getConstant(\"VM_Version::CPU_TSCINV\", Long.class);\n-    final long amd64AVX = getConstant(\"VM_Version::CPU_AVX\", Long.class);\n-    final long amd64AVX2 = getConstant(\"VM_Version::CPU_AVX2\", Long.class);\n-    final long amd64AES = getConstant(\"VM_Version::CPU_AES\", Long.class);\n-    final long amd64ERMS = getConstant(\"VM_Version::CPU_ERMS\", Long.class);\n-    final long amd64CLMUL = getConstant(\"VM_Version::CPU_CLMUL\", Long.class);\n-    final long amd64BMI1 = getConstant(\"VM_Version::CPU_BMI1\", Long.class);\n-    final long amd64BMI2 = getConstant(\"VM_Version::CPU_BMI2\", Long.class);\n-    final long amd64RTM = getConstant(\"VM_Version::CPU_RTM\", Long.class);\n-    final long amd64ADX = getConstant(\"VM_Version::CPU_ADX\", Long.class);\n-    final long amd64AVX512F = getConstant(\"VM_Version::CPU_AVX512F\", Long.class);\n-    final long amd64AVX512DQ = getConstant(\"VM_Version::CPU_AVX512DQ\", Long.class);\n-    final long amd64AVX512PF = getConstant(\"VM_Version::CPU_AVX512PF\", Long.class);\n-    final long amd64AVX512ER = getConstant(\"VM_Version::CPU_AVX512ER\", Long.class);\n-    final long amd64AVX512CD = getConstant(\"VM_Version::CPU_AVX512CD\", Long.class);\n-    final long amd64AVX512BW = getConstant(\"VM_Version::CPU_AVX512BW\", Long.class);\n-    final long amd64AVX512VL = getConstant(\"VM_Version::CPU_AVX512VL\", Long.class);\n-    final long amd64SHA = getConstant(\"VM_Version::CPU_SHA\", Long.class);\n-    final long amd64FMA = getConstant(\"VM_Version::CPU_FMA\", Long.class);\n-    final long amd64PKU = getConstant(\"VM_Version::CPU_PKU\", Long.class);\n-    final long amd64OSPKE = getConstant(\"VM_Version::CPU_OSPKE\", Long.class);\n-    final long amd64CET_IBT = getConstant(\"VM_Version::CPU_CET_IBT\", Long.class);\n-    final long amd64CET_SS = getConstant(\"VM_Version::CPU_CET_SS\", Long.class);\n-    final long amd64AVX10_1 = getConstant(\"VM_Version::CPU_AVX10_1\", Long.class);\n-    final long amd64AVX10_2 = getConstant(\"VM_Version::CPU_AVX10_2\", Long.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,28 +55,0 @@\n-    private static EnumSet<RISCV64.Flag> computeFlags(RISCV64HotSpotVMConfig config) {\n-        EnumSet<RISCV64.Flag> flags = EnumSet.noneOf(RISCV64.Flag.class);\n-\n-        if (config.useConservativeFence) {\n-            flags.add(RISCV64.Flag.UseConservativeFence);\n-        }\n-        if (config.avoidUnalignedAccesses) {\n-            flags.add(RISCV64.Flag.AvoidUnalignedAccesses);\n-        }\n-        if (config.traceTraps) {\n-            flags.add(RISCV64.Flag.TraceTraps);\n-        }\n-        if (config.useRVV) {\n-            flags.add(RISCV64.Flag.UseRVV);\n-        }\n-        if (config.useRVC) {\n-            flags.add(RISCV64.Flag.UseRVC);\n-        }\n-        if (config.useZba) {\n-            flags.add(RISCV64.Flag.UseZba);\n-        }\n-        if (config.useZbb) {\n-            flags.add(RISCV64.Flag.UseZbb);\n-        }\n-\n-        return flags;\n-    }\n-\n@@ -87,1 +59,1 @@\n-        Architecture arch = new RISCV64(computeFeatures(config), computeFlags(config));\n+        Architecture arch = new RISCV64(computeFeatures(config));\n@@ -118,1 +90,0 @@\n-    @SuppressWarnings(\"try\")\n@@ -129,2 +100,2 @@\n-        try (InitTimer t = timer(\"create providers\")) {\n-            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+        try (InitTimer _ = timer(\"create providers\")) {\n+            try (InitTimer _ = timer(\"create MetaAccess provider\")) {\n@@ -133,1 +104,1 @@\n-            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+            try (InitTimer _ = timer(\"create RegisterConfig\")) {\n@@ -136,1 +107,1 @@\n-            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+            try (InitTimer _ = timer(\"create CodeCache provider\")) {\n@@ -139,1 +110,1 @@\n-            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+            try (InitTimer _ = timer(\"create ConstantReflection provider\")) {\n@@ -142,1 +113,1 @@\n-            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+            try (InitTimer _ = timer(\"create StackIntrospection provider\")) {\n@@ -146,1 +117,1 @@\n-        try (InitTimer rt = timer(\"instantiate backend\")) {\n+        try (InitTimer _ = timer(\"instantiate backend\")) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -82,1 +81,1 @@\n-    private final RegisterArray allocatable;\n+    private final List<Register> allocatable;\n@@ -87,1 +86,1 @@\n-    private final RegisterArray callerSaved;\n+    private final List<Register> callerSaved;\n@@ -91,1 +90,1 @@\n-    private final RegisterAttributes[] attributesMap;\n+    private final List<RegisterAttributes> attributesMap;\n@@ -94,1 +93,1 @@\n-    public RegisterArray getAllocatableRegisters() {\n+    public List<Register> getAllocatableRegisters() {\n@@ -99,1 +98,1 @@\n-    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+    public List<Register> filterAllocatableRegisters(PlatformKind kind, List<Register> registers) {\n@@ -107,1 +106,1 @@\n-        return new RegisterArray(list);\n+        return List.copyOf(list);\n@@ -111,2 +110,2 @@\n-    public RegisterAttributes[] getAttributesMap() {\n-        return attributesMap.clone();\n+    public List<RegisterAttributes> getAttributesMap() {\n+        return attributesMap;\n@@ -115,3 +114,3 @@\n-    private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(x11, x12, x13, x14, x15, x16, x17, x10);\n-    private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(x10, x11, x12, x13, x14, x15, x16, x17);\n-    private final RegisterArray fpParameterRegisters = new RegisterArray(f10, f11, f12, f13, f14, f15, f16, f17);\n+    private final List<Register> javaGeneralParameterRegisters = List.of(x11, x12, x13, x14, x15, x16, x17, x10);\n+    private final List<Register> nativeGeneralParameterRegisters = List.of(x10, x11, x12, x13, x14, x15, x16, x17);\n+    private final List<Register> fpParameterRegisters = List.of(f10, f11, f12, f13, f14, f15, f16, f17);\n@@ -131,1 +130,1 @@\n-    private static final RegisterArray reservedRegisters = new RegisterArray(zero, ra, sp, gp, tp, t0, t1, t2, fp);\n+    private static final List<Register> reservedRegisters =List.of(zero, ra, sp, gp, tp, t0, t1, t2, fp);\n@@ -133,2 +132,2 @@\n-    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n-        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+    private static List<Register> initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n+        List<Register> allRegisters = arch.getAvailableValueRegisters();\n@@ -136,1 +135,0 @@\n-        List<Register> reservedRegistersList = reservedRegisters.asList();\n@@ -140,1 +138,1 @@\n-            if (reservedRegistersList.contains(reg)) {\n+            if (reservedRegisters.contains(reg)) {\n@@ -155,1 +153,1 @@\n-        return new RegisterArray(registers);\n+        return List.of(registers);\n@@ -163,1 +161,1 @@\n-    public RISCV64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, List<Register> allocatable) {\n@@ -168,5 +166,5 @@\n-        allocatable.addTo(callerSaveSet);\n-        fpParameterRegisters.addTo(callerSaveSet);\n-        javaGeneralParameterRegisters.addTo(callerSaveSet);\n-        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n-        callerSaved = new RegisterArray(callerSaveSet);\n+        callerSaveSet.addAll(allocatable);\n+        callerSaveSet.addAll(fpParameterRegisters);\n+        callerSaveSet.addAll(javaGeneralParameterRegisters);\n+        callerSaveSet.addAll(nativeGeneralParameterRegisters);\n+        callerSaved = List.copyOf(callerSaveSet);\n@@ -179,1 +177,1 @@\n-    public RegisterArray getCallerSaveRegisters() {\n+    public List<Register> getCallerSaveRegisters() {\n@@ -184,1 +182,1 @@\n-    public RegisterArray getCalleeSaveRegisters() {\n+    public List<Register> getCalleeSaveRegisters() {\n@@ -203,1 +201,1 @@\n-    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+    public List<Register> getCallingConventionRegisters(Type type, JavaKind kind) {\n@@ -222,1 +220,1 @@\n-    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n+    private CallingConvention callingConvention(List<Register> generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotRegisterConfig.java","additions":27,"deletions":29,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,14 +40,0 @@\n-\n-    \/\/ CPU Capabilities\n-\n-    \/*\n-     * These flags are set based on the corresponding command line flags.\n-     *\/\n-    final boolean useConservativeFence = getFlag(\"UseConservativeFence\", Boolean.class);\n-    final boolean avoidUnalignedAccesses = getFlag(\"AvoidUnalignedAccesses\", Boolean.class);\n-    final boolean traceTraps = getFlag(\"TraceTraps\", Boolean.class);\n-    final boolean useRVV = getFlag(\"UseRVV\", Boolean.class);\n-    final boolean useRVC = getFlag(\"UseRVC\", Boolean.class);\n-    final boolean useZba = getFlag(\"UseZba\", Boolean.class);\n-    final boolean useZbb = getFlag(\"UseZbb\", Boolean.class);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.List;\n@@ -32,1 +33,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -80,1 +80,1 @@\n-    public static final RegisterArray cpuRegisters = new RegisterArray(\n+    public static final List<Register> cpuRegisters = List.of(\n@@ -125,1 +125,1 @@\n-    public static final RegisterArray fpRegisters = new RegisterArray(\n+    public static final List<Register> fpRegisters = List.of(\n@@ -134,1 +134,1 @@\n-    public static final RegisterArray allRegisters = new RegisterArray(\n+    public static final List<Register> allRegisters = List.of(\n@@ -163,16 +163,1 @@\n-    \/**\n-     * Set of flags to control code emission.\n-     *\/\n-    public enum Flag {\n-        UseConservativeFence,\n-        AvoidUnalignedAccesses,\n-        TraceTraps,\n-        UseRVV,\n-        UseRVC,\n-        UseZba,\n-        UseZbb\n-    }\n-\n-    private final EnumSet<Flag> flags;\n-\n-    public RISCV64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+    public RISCV64(EnumSet<CPUFeature> features) {\n@@ -181,1 +166,0 @@\n-        this.flags = flags;\n@@ -189,4 +173,0 @@\n-    public EnumSet<Flag> getFlags() {\n-        return flags;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/riscv64\/RISCV64.java","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.vm.ci.code.RegisterArray;\n@@ -121,2 +120,1 @@\n-        RegisterArray allRegs = arch.getAvailableValueRegisters();\n-        for (Register reg : allRegs) {\n+        for (Register reg : arch.getAvailableValueRegisters()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CodeInstallerTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.List;\n@@ -370,3 +371,3 @@\n-        AllocatableValue[] args = cc.getArguments();\n-        for (int i = 0; i < args.length; i++) {\n-            emitLoad(args[i], prim[i]);\n+        List<AllocatableValue> args = cc.getArguments();\n+        for (int i = 0; i < args.size(); i++) {\n+            emitLoad(args.get(i), prim[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -498,1 +499,1 @@\n-        AllocatableValue[] args = cc.getArguments();\n+        List<AllocatableValue> args = cc.getArguments();\n@@ -501,2 +502,2 @@\n-        for (int i = args.length - 1; i >= 0; i--) {\n-            emitLoad(args[i], prim[i]);\n+        for (int i = args.size() - 1; i >= 0; i--) {\n+            emitLoad(args.get(i), prim[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/amd64\/AMD64TestAssembler.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -230,3 +231,3 @@\n-        AllocatableValue[] args = cc.getArguments();\n-        for (int i = 0; i < args.length; i++) {\n-            emitLoad(args[i], prim[i]);\n+        List<AllocatableValue> args = cc.getArguments();\n+        for (int i = 0; i < args.size(); i++) {\n+            emitLoad(args.get(i), prim[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/riscv64\/RISCV64TestAssembler.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}