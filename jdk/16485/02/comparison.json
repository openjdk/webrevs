{"files":[{"patch":"@@ -227,2 +227,2 @@\n- * All native linker implementations operate on a subset of memory layouts. More formally, a layout {@code L}\n- * is supported by a native linker {@code NL} if:\n+ * All native linker implementations support a well-defined subset of layouts. More formally,\n+ * a layout {@code L} is supported by a native linker {@code NL} if:\n@@ -247,0 +247,16 @@\n+ * Linker implementations may optionally support additional layouts, such as <em>packed<\/em> struct layouts.\n+ * A packed struct is a struct in which there is at least one member layout {@code L} that has an alignment\n+ * constraint less strict than its natural alignment. This allows avoiding padding between member layouts,\n+ * as well as avoiding padding at the end of the struct layout. For example:\n+ * {@snippet lang = java:\n+ * \/\/ No padding between the 2 element layouts:\n+ * MemoryLayout noFieldPadding = MemoryLayout.structLayout(\n+ *         ValueLayout.JAVA_INT,\n+ *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4));\n+ *\n+ * \/\/ No padding at the end of the struct:\n+ * MemoryLayout noTrailingPadding = MemoryLayout.structLayout(\n+ *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4),\n+ *         ValueLayout.JAVA_INT);\n+ * }\n+ * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"}]}