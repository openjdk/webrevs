{"files":[{"patch":"@@ -1205,0 +1205,5 @@\n+  \/\/ Still nothing? If NMT is enabled, we can ask what it thinks...\n+  if (MemTracker::print_containing_region(addr, st)) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+\n+  bool is_dead() const { return _canary == _header_canary_dead_mark; }\n+  bool is_live() const { return _canary == _header_canary_life_mark; }\n+\n+  \/\/ Used for debugging purposes only. Check header if it could constitute a valid (life or dead) header.\n+  inline bool looks_valid() const;\n+\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,0 +119,10 @@\n+\n+\/\/ Used for debugging purposes only. Check header if it could constitute a valid (life or dead) header.\n+inline bool MallocHeader::looks_valid() const {\n+  \/\/ Note: we define these restrictions lose enough to also catch moderately corrupted blocks.\n+  \/\/ E.g. we don't check footer canary.\n+  return ( (_canary == _header_canary_life_mark NOT_LP64(&& _alt_canary == _header_alt_canary_life_mark)) ||\n+           (_canary == _header_canary_dead_mark NOT_LP64(&& _alt_canary == _header_alt_canary_dead_mark)) ) &&\n+           _size > 0 && _size < max_reasonable_malloc_size;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -193,2 +193,2 @@\n-\/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n-\/\/ print the block. Note that since there is very low risk of memory looking\n+\/\/ Given a pointer, look for the containing malloc block.\n+\/\/ Print the block. Note that since there is very low risk of memory looking\n@@ -199,15 +199,51 @@\n-  assert(MemTracker::enabled(), \"NMT must be enabled\");\n-  if (os::is_readable_pointer(p)) {\n-    const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n-    const MallocHeader* mhdr = malloc_header(p);\n-    char msg[256];\n-    address p_corrupted;\n-    if (os::is_readable_pointer(mhdr) &&\n-        mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n-      st->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n-          p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n-      if (tracking_level == NMT_detail) {\n-        NativeCallStack ncs;\n-        if (mhdr->get_stack(ncs)) {\n-          ncs.print_on(st);\n-          st->cr();\n+  if (!MemTracker::enabled()) {\n+    return false;\n+  }\n+  address addr = (address)p;\n+\n+  \/\/ Carefully feel your way upwards and try to find a malloc header. Then check if\n+  \/\/ we are within the block.\n+  const MallocHeader* candidate = (const MallocHeader*)(align_down(addr, 16));\n+  const MallocHeader* const last_candidate = candidate - 0x1001; \/\/ 4k (incl. header)\n+  while(candidate >= last_candidate) {\n+    if (!os::is_readable_pointer(candidate)) {\n+      break;\n+    }\n+    if (candidate->looks_valid()) {\n+      \/\/ fudge factor:\n+      \/\/ We don't report blocks for which p is clearly out. That would cause us to return true and possibly prevent\n+      \/\/ subsequent tests of p, see os::print_location(). But if p is just outside of the found block, this may be a\n+      \/\/ narrow oob error and we'd like to know that.\n+      const int fudge = 8;\n+      const address start_block = (address)candidate;\n+      const address start_payload = (address)(candidate + 1);\n+      const address end_payload = start_payload + candidate->size();\n+      const address end_payload_plus_fudge = end_payload + fudge;\n+      if (addr >= start_block && addr < end_payload_plus_fudge) {\n+        const char* where = nullptr;\n+        if (addr < start_payload) {\n+          where = \"into header of\";\n+        } else if (addr < end_payload) {\n+          where = \"into\";\n+        } else {\n+          where = \"just outside of\";\n+        }\n+        st->print_cr(PTR_FORMAT \" %s %s malloced block starting at \" PTR_FORMAT \", size \" SIZE_FORMAT \", tag %s\",\n+                  p2i(p), where,\n+                  (candidate->is_dead() ? \"dead\" : \"live\"),\n+                  p2i(candidate + 1), \/\/ lets print the payload start, not the header\n+                  candidate->size(), NMTUtil::flag_to_enum_name(candidate->flags()));\n+        if (MemTracker::tracking_level() == NMT_detail) {\n+          NativeCallStack ncs;\n+          if (candidate->get_stack(ncs)) {\n+            ncs.print_on(st);\n+            st->cr();\n+          }\n+        }\n+        return true;\n+        break;\n+      } else {\n+        \/\/ Break if we found a live header but the pointer had not been nearby. If this was a dead header, it may be\n+        \/\/ a remnant from an older freed block, so continue searching.\n+        if (candidate->is_live()) {\n+          return false;\n@@ -216,1 +252,0 @@\n-      return true;\n@@ -218,0 +253,1 @@\n+    candidate --;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":54,"deletions":18,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -311,2 +311,2 @@\n-  \/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n-  \/\/ print the block. Note that since there is very low risk of memory looking\n+  \/\/ Given a pointer, look for the containing malloc block.\n+  \/\/ Print the block. Note that since there is very low risk of memory looking\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,8 @@\n+\/\/ Given an unknown pointer, check if it points into a known region; print region if found\n+\/\/ and return true; false if not found.\n+bool MemTracker::print_containing_region(const void* p, outputStream* out) {\n+  return enabled() &&\n+      (MallocTracker::print_pointer_information(p, out) ||\n+       VirtualMemoryTracker::print_containing_region(p, out));\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -237,0 +237,4 @@\n+  \/\/ Given an unknown pointer, check if it points into a known region; print region if found\n+  \/\/ and return true; false if not found.\n+  static bool print_containing_region(const void* p, outputStream* out);\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,2 +682,2 @@\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n-        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::flag_to_enum_name(rgn->flag()));\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,9 +396,2 @@\n-    if (MemTracker::enabled()) {\n-      \/\/ Does it point into a known mmapped region?\n-      if (VirtualMemoryTracker::print_containing_region(p, tty)) {\n-        return;\n-      }\n-      \/\/ Does it look like the start of a malloced block?\n-      if (MallocTracker::print_pointer_information(p, tty)) {\n-        return;\n-      }\n+    if (MemTracker::print_containing_region(p, tty)) {\n+      return;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/#define LOG_PLEASE\n+#include \"testutils.hpp\"\n+\n+using ::testing::HasSubstr;\n+\n+static void test_pointer(const void* p, bool expected_return_code, const char* expected_message) {\n+  stringStream ss;\n+  const bool b = MemTracker::print_containing_region(p, &ss);\n+  LOG_HERE(\"MemTracker::print_containing_region(\" PTR_FORMAT \") yielded: %d \\\"%s\\\"\", p2i(p), b, ss.base());\n+  EXPECT_EQ(b, expected_return_code);\n+  if (b) {\n+    EXPECT_THAT(ss.base(), HasSubstr(expected_message));\n+  }\n+}\n+\n+static void test_for_c_heap(size_t sz, ssize_t offset) {\n+  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n+  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), offset);\n+  memset(c, 0, sz);\n+  if (MemTracker::enabled()) {\n+    const char* expected_string = \"into live malloced block\";\n+    if (offset < 0) {\n+      expected_string = \"into header of live malloced block\";\n+    } else if ((size_t)offset >= sz) {\n+      expected_string = \"just outside of live malloced block\";\n+    }\n+    test_pointer(c + offset, true, expected_string);\n+  } else {\n+    \/\/ NMT disabled: we should see nothing.\n+    test_pointer(c + offset, false, \"\");\n+  }\n+  FREE_C_HEAP_ARRAY(char, c);\n+}\n+\n+TEST_VM(NMT, location_printing_cheap_1) { test_for_c_heap(2 * K, 0); }              \/\/ start of payload\n+TEST_VM(NMT, location_printing_cheap_2) { test_for_c_heap(2 * K, -7); }             \/\/ into header\n+TEST_VM(NMT, location_printing_cheap_3) { test_for_c_heap(2 * K, K + 1); }          \/\/ into payload\n+TEST_VM(NMT, location_printing_cheap_4) { test_for_c_heap(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n+TEST_VM(NMT, location_printing_cheap_5) { test_for_c_heap(4, 4); }                  \/\/ just outside a very small block\n+\n+static void test_for_mmap(size_t sz, ssize_t offset) {\n+  char* addr = os::reserve_memory(sz, false, mtTest);\n+  if (MemTracker::enabled()) {\n+    test_pointer(addr + offset, true, \"in mmap'd memory region\");\n+  } else {\n+    \/\/ NMT disabled: we should see nothing.\n+    test_pointer(addr + offset, false, \"\");\n+  }\n+  os::release_memory(addr, os::vm_page_size());\n+}\n+\n+TEST_VM(NMT, location_printing_mmap_1) { test_for_mmap(os::vm_page_size(), 0);  }\n+TEST_VM(NMT, location_printing_mmap_2) { test_for_mmap(os::vm_page_size(), os::vm_page_size() - 1);  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_locationprinting.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+#ifdef LOG_PLEASE\n@@ -66,0 +67,3 @@\n+#else\n+#define LOG_HERE(s, ...)\n+#endif\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}