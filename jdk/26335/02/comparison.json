{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,2 +405,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM was unable to pop the frames.\n+     * @throws OpaqueFrameException if the target VM is unable to pop this frame\n+     * (e.g. a virtual thread is suspended, but not at an event).\n@@ -487,2 +487,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM is unable to force the method to return.\n+     * @throws OpaqueFrameException if the target VM is unable to force the method to return\n+     * (e.g. a virtual thread is suspended, but not at an event).\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,16 +398,13 @@\n-                if (thread.isVirtual()) {\n-                    \/\/ We first need to find out if the current frame is native, or if the\n-                    \/\/ previous frame is native, in which case we throw NativeMethodException\n-                    for (int i = 0; i < 2; i++) {\n-                        StackFrameImpl sf;\n-                        try {\n-                            sf = (StackFrameImpl)thread.frame(i);\n-                        } catch (IndexOutOfBoundsException e) {\n-                            \/\/ This should never happen, but we need to check for it.\n-                            break;\n-                        }\n-                        sf.validateStackFrame();\n-                        MethodImpl meth = (MethodImpl)sf.location().method();\n-                        if (meth.isNative()) {\n-                            throw new NativeMethodException();\n-                        }\n+                \/\/ We first need to find out if the current frame is native, or if the\n+                \/\/ previous frame is native, in which case we throw NativeMethodException\n+                for (int i = 0; i < 2; i++) {\n+                    StackFrame sf;\n+                    try {\n+                        sf = thread.frame(i);\n+                    } catch (IndexOutOfBoundsException e) {\n+                        \/\/ This should never happen, but we need to check for it.\n+                        break;\n+                    }\n+                    Method meth = sf.location().method();\n+                    if (meth.isNative()) {\n+                        throw new NativeMethodException();\n@@ -415,5 +412,0 @@\n-                    \/\/ No native frames involved. Must have been due to thread\n-                    \/\/ not being mounted.\n-                    throw new OpaqueFrameException();\n-                } else {\n-                    throw new NativeMethodException();\n@@ -421,0 +413,3 @@\n+                \/\/ No native frames involved. Must have been due to virtual thread\n+                \/\/ not being mounted or some other reason such as failure to deopt.\n+                throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-                if (isVirtual() && !meth.isNative()) {\n-                    throw new OpaqueFrameException();\n-                } else {\n+                if (meth.isNative()) {\n@@ -604,0 +602,2 @@\n+                } else {\n+                    throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}