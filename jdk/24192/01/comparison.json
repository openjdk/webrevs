{"files":[{"patch":"@@ -3157,1 +3157,2 @@\n-  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  Node* notified_reset_memory = reset_memory();\n@@ -3175,1 +3176,0 @@\n-  Node* commit_memory;\n@@ -3177,1 +3177,1 @@\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, MemNode::release);\n+  store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, MemNode::release);\n@@ -3179,1 +3179,1 @@\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, MemNode::release);\n+  store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, MemNode::release);\n@@ -3182,0 +3182,3 @@\n+  Node* commit_memory = reset_memory();\n+  set_all_memory(commit_memory);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ *\n+ * A successful execution is when the JTREG test executes successfully,\n+ * i.e., with no exceptions or JVM asserts.\n+ *\n+ * In JVM debug builds, C2 will assert as part of EscapeAnalysis and dump an hs_err<pid>.log:\n+ *\n+ * #\n+ * # A fatal error has been detected by the Java Runtime Environment:\n+ * #\n+ * # Internal Error (..\\open\\src\\hotspot\\share\\opto\\escape.cpp:4788)\n+ * # assert(false) failed: EA: missing memory path\n+ *\n+ * Current thread JavaThread \"C2 CompilerThread2\"\n+ * Current CompileTask:\n+ * C2:27036 1966 ! 4   java.lang.VirtualThread::run (173 bytes)\n+ *\n+ * ConnectionGraph::split_unique_types+0x2409 (escape.cpp:4788)\n+ * ConnectionGraph::compute_escape+0x11e6 (escape.cpp:397)\n+ * ConnectionGraph::do_analysis+0xf2 (escape.cpp:118)\n+ * Compile::Optimize+0x85d (compile.cpp:2381)\n+ * ...\n+ *\n+ * The error is because C2's Escape Analysis does not recognize a pattern\n+ * where one input of memory Phi node is MergeMem node, and another is RAW store.\n+ * This pattern is created by the jdk.jfr.internal.JVM.commit() intrinsic,\n+ * which is inlined because of inlining the JFR event jdk.VirtualThreadStart.\n+ *\n+ * As a result, EA complains about a strange memory graph.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8352696\n+ * @requires vm.flagless & vm.hasJFR & vm.debug\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jvm.TestJvmCommitIntrinsicAndEA\n+ *\/\n+public final class TestJvmCommitIntrinsicAndEA {\n+\n+    public static void main(String[] args) throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.VirtualThreadStart).withoutStackTrace();\n+            recording.enable(EventNames.VirtualThreadEnd).withoutStackTrace();\n+            recording.start();\n+            \/\/ execute 10_000 tasks, each in their own virtual thread\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                for (int i = 0; i < 10_000; i++) {\n+                    executor.submit(() -> { });\n+                }\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            Map<String, Integer> events = sumEvents(recording);\n+            System.err.println(events);\n+\n+            int startCount = events.getOrDefault(EventNames.VirtualThreadStart, 0);\n+            int endCount = events.getOrDefault(EventNames.VirtualThreadEnd, 0);\n+            Asserts.assertEquals(10_000, startCount, \"Expected 10000, got \" + startCount);\n+            Asserts.assertEquals(10_000, endCount, \"Expected 10000, got \" + endCount);\n+        }\n+    }\n+\n+    private static Map<String, Integer> sumEvents(Recording recording) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        return events.stream().map(RecordedEvent::getEventType)\n+                               .collect(Collectors.groupingBy(EventType::getName, Collectors.summingInt(x -> 1)));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJvmCommitIntrinsicAndEA.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}