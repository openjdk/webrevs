{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -501,1 +501,1 @@\n-    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d, byte[] kem_z) {\n+    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d_z) {\n@@ -511,1 +511,2 @@\n-        var kPkeKeyPair = generateK_PkeKeyPair(kem_d);\n+        \/\/The 1st 32-byte `d` is used in K-PKE key pair generation\n+        var kPkeKeyPair = generateK_PkeKeyPair(kem_d_z);\n@@ -530,1 +531,2 @@\n-        System.arraycopy(kem_z, 0, decapsKey,\n+        \/\/ The 2nd 32-byte `z` is copied into decapsKey\n+        System.arraycopy(kem_d_z, 32, decapsKey,\n@@ -538,0 +540,6 @@\n+    public byte[] privKeyToPubKey(byte[] decapsKey) {\n+        int pkLen = (mlKem_k * ML_KEM_N * 12) \/ 8 + 32 \/* rho *\/;\n+        int skLen = (mlKem_k * ML_KEM_N * 12) \/ 8;\n+        return Arrays.copyOfRange(decapsKey, skLen, skLen + pkLen);\n+    }\n+\n@@ -651,1 +659,2 @@\n-        mlKemG.update(seed);\n+        \/\/ Note: only the 1st 32-byte in the seed is used\n+        mlKemG.update(seed, 0, 32);\n@@ -655,0 +664,1 @@\n+        mlKemG.reset();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n@@ -32,0 +33,2 @@\n+import sun.security.util.KeyUtil;\n+import sun.security.x509.NamedX509Key;\n@@ -40,0 +43,14 @@\n+    private static final int SEED_LEN = 64;\n+\n+    public static byte[] seedToExpanded(String pname, byte[] seed) {\n+        return new ML_KEM(pname).generateKemKeyPair(seed)\n+                .decapsulationKey()\n+                .keyBytes();\n+    }\n+\n+    public static NamedX509Key privKeyToPubKey(NamedPKCS8Key npk) {\n+        return new NamedX509Key(npk.getAlgorithm(),\n+                npk.getParams().getName(),\n+                new ML_KEM(npk.getParams().getName()).privKeyToPubKey(npk.getExpanded()));\n+    }\n+\n@@ -53,2 +70,2 @@\n-        protected byte[][] implGenerateKeyPair(String name, SecureRandom random) {\n-            byte[] seed = new byte[32];\n+        protected byte[][] implGenerateKeyPair(String pname, SecureRandom random) {\n+            byte[] seed = new byte[SEED_LEN];\n@@ -57,2 +74,0 @@\n-            byte[] z = new byte[32];\n-            r.nextBytes(z);\n@@ -60,1 +75,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -62,0 +77,3 @@\n+            kp = mlKem.generateKemKeyPair(seed);\n+            var expanded = kp.decapsulationKey().keyBytes();\n+\n@@ -63,1 +81,5 @@\n-                kp = mlKem.generateKemKeyPair(seed, z);\n+                return new byte[][]{\n+                        kp.encapsulationKey().keyBytes(),\n+                        KeyUtil.writeToChoices(pname, \"mlkem\", seed, expanded, null),\n+                        expanded\n+                };\n@@ -65,2 +87,1 @@\n-                Arrays.fill(seed, (byte)0);\n-                Arrays.fill(z, (byte)0);\n+                Arrays.fill(seed, (byte) 0);\n@@ -68,4 +89,0 @@\n-            return new byte[][] {\n-                    kp.encapsulationKey().keyBytes(),\n-                    kp.decapsulationKey().keyBytes()\n-            };\n@@ -97,2 +114,50 @@\n-        public KF(String name) {\n-            super(\"ML-KEM\", name);\n+        public KF(String pname) {\n+            super(\"ML-KEM\", pname);\n+        }\n+\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            var parts = KeyUtil.splitChoices(SEED_LEN, input);\n+            if (parts[0] != null && parts[1] != null) {\n+                var calculated = seedToExpanded(pname, parts[0]);\n+                if (!Arrays.equals(parts[1], calculated)) {\n+                    throw new InvalidKeyException(\"seed and expandedKey do not match\");\n+                }\n+                Arrays.fill(calculated, (byte)0);\n+            }\n+            try {\n+                if (parts[1] != null) {\n+                    return parts[1];\n+                }\n+                return seedToExpanded(pname, parts[0]);\n+            } finally {\n+                if (parts[0] != null) {\n+                    Arrays.fill(parts[0], (byte)0);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            var nk = toNamedKey(key);\n+            if (nk instanceof NamedPKCS8Key npk) {\n+                var parts = KeyUtil.splitChoices(SEED_LEN, npk.getRawBytes());\n+                var encoding = KeyUtil.writeToChoices(npk.getParams().getName(),\n+                        \"mlkem\", parts[0], parts[1],\n+                        ML_KEM_Impls::seedToExpanded);\n+                if (parts[0] != null) Arrays.fill(parts[0], (byte)0);\n+                if (parts[1] != null) Arrays.fill(parts[1], (byte)0);\n+                if (encoding == null) {\n+                    throw new InvalidKeyException(\"key contains not enough info to translate\");\n+                }\n+                nk = new NamedPKCS8Key(\n+                        npk.getAlgorithm(),\n+                        npk.getParams().getName(),\n+                        encoding,\n+                        npk.getExpanded().clone());\n+                if (npk != key) {\n+                    npk.destroy();\n+                }\n+            }\n+            return nk;\n@@ -124,1 +189,1 @@\n-        protected byte[][] implEncapsulate(String name, byte[] encapsulationKey,\n+        protected byte[][] implEncapsulate(String pname, byte[] encapsulationKey,\n@@ -131,1 +196,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -148,1 +213,1 @@\n-        protected byte[] implDecapsulate(String name, byte[] decapsulationKey,\n+        protected byte[] implDecapsulate(String pname, byte[] decapsulationKey,\n@@ -152,1 +217,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -159,1 +224,1 @@\n-        protected int implSecretSize(String name) {\n+        protected int implSecretSize(String pname) {\n@@ -164,2 +229,2 @@\n-        protected int implEncapsulationSize(String name) {\n-            ML_KEM mlKem = new ML_KEM(name);\n+        protected int implEncapsulationSize(String pname) {\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -170,1 +235,1 @@\n-        protected Object implCheckPublicKey(String name, byte[] pk)\n+        protected Object implCheckPublicKey(String pname, byte[] pk)\n@@ -173,1 +238,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -178,1 +243,1 @@\n-        protected Object implCheckPrivateKey(String name, byte[] sk)\n+        protected Object implCheckPrivateKey(String pname, byte[] sk)\n@@ -181,1 +246,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -186,1 +251,1 @@\n-            super(\"ML-KEM\", \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n+            super(\"ML-KEM\", new KF(), \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n@@ -189,2 +254,2 @@\n-        public K(String name) {\n-            super(\"ML-KEM\", name);\n+        public K(String pname) {\n+            super(\"ML-KEM\", new KF(pname), pname);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":94,"deletions":29,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerValue;\n@@ -32,1 +30,0 @@\n-import javax.security.auth.DestroyFailedException;\n@@ -42,0 +39,1 @@\n+import java.util.Objects;\n@@ -53,0 +51,8 @@\n+\/\/\/ Besides the existing [PKCS8Key#key] field, this class contains an\n+\/\/\/ expanded format stored in [#expanded]. While `key` always represents\n+\/\/\/ the format used for encoding, the expanded format is always used\n+\/\/\/ in computations. The expanded format must be self-sufficient for\n+\/\/\/ cryptographic computations without requiring the encoding format.\n+\/\/\/\n+\/\/\/ Both fields must be present.\n+\/\/\/\n@@ -60,1 +66,1 @@\n-    private final byte[] rawBytes;\n+    private final transient byte[] expanded;\n@@ -64,3 +70,10 @@\n-    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n-    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n-    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes) {\n+    \/\/\/ Creates a `NamedPKCS8Key` from raw key bytes.\n+    \/\/\/\n+    \/\/\/ `encoded` and `expanded` won't be cloned, caller\n+    \/\/\/ must relinquish ownership.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param encoded raw key bytes, not null\n+    \/\/\/ @param expanded expanded key format, not null\n+    public NamedPKCS8Key(String fname, String pname, byte[] encoded, byte[] expanded) {\n@@ -69,0 +82,2 @@\n+        this.expanded = Objects.requireNonNull(expanded);\n+        this.key = Objects.requireNonNull(encoded);\n@@ -74,8 +89,0 @@\n-        this.rawBytes = rawBytes;\n-\n-        DerValue val = new DerValue(DerValue.tag_OctetString, rawBytes);\n-        try {\n-            this.key = val.toByteArray();\n-        } finally {\n-            val.clear();\n-        }\n@@ -84,2 +91,10 @@\n-    \/\/\/ Ctor from family name, and PKCS #8 bytes\n-    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+    \/\/\/ Creates a `NamedPKCS8Key` from family name and PKCS #8 encoding.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param encoded PKCS #8 encoding. It is copied so caller can modify\n+    \/\/\/     it after the method call.\n+    \/\/\/ @param expander a function that is able to calculate the expanded\n+    \/\/\/     format from the encoding format inside `encoded`.The\n+    \/\/\/     ownership of the result is fully granted to this object.\n+    public NamedPKCS8Key(String fname, byte[] encoded, Expander expander)\n+            throws InvalidKeyException {\n@@ -88,8 +103,4 @@\n-        try {\n-            paramSpec = new NamedParameterSpec(algid.getName());\n-            if (algid.getEncodedParams() != null) {\n-                throw new InvalidKeyException(\"algorithm identifier has params\");\n-            }\n-            rawBytes = new DerInputStream(key).getOctetString();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        this.expanded = expander.expand(algid.getName(), this.key);\n+        paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.getEncodedParams() != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n@@ -107,1 +118,1 @@\n-    \/\/\/ the content or keep a reference.\n+    \/\/\/ the content or pass the reference to untrusted application code.\n@@ -109,1 +120,7 @@\n-        return rawBytes;\n+        return key;\n+    }\n+\n+    \/\/\/ Returns the reference to the key in expanded format. Caller must not\n+    \/\/\/ modify the content or pass the reference to untrusted application code.\n+    public byte[] getExpanded() {\n+        return expanded;\n@@ -130,2 +147,1 @@\n-    public void destroy() throws DestroyFailedException {\n-        Arrays.fill(rawBytes, (byte)0);\n+    public void destroy() {\n@@ -133,0 +149,1 @@\n+        Arrays.fill(expanded, (byte)0);\n@@ -143,0 +160,6 @@\n+\n+    \/\/\/ Expands from encoding format to expanded format.\n+    public interface Expander {\n+        \/\/\/ The expand method.\n+        byte[] expand(String pname, byte[] input) throws InvalidKeyException;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":53,"deletions":30,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -571,0 +571,33 @@\n+    public ML_DSA_PublicKey privKeyToPubKey(ML_DSA_PrivateKey sk) {\n+        \/\/Sample A\n+        int[][][] keygenA = generateA(sk.rho); \/\/A is in NTT domain\n+\n+        \/\/Compute t and tr\n+        mlDsaVectorNtt(sk.s1); \/\/s1 now in NTT domain\n+        int[][] As1 = new int[mlDsa_k][ML_DSA_N];\n+        matrixVectorPointwiseMultiply(As1, keygenA, sk.s1);\n+        mlDsaVectorInverseNtt(sk.s1); \/\/take s1 out of NTT domain\n+\n+        mlDsaVectorInverseNtt(As1);\n+        int[][] t = vectorAddPos(As1, sk.s2);\n+        int[][] t0 = new int[mlDsa_k][ML_DSA_N];\n+        int[][] t1 = new int[mlDsa_k][ML_DSA_N];\n+        power2Round(t, t0, t1);\n+        if (!Arrays.deepEquals(t0, sk.t0)) {\n+            throw new IllegalArgumentException(\"t0 does not patch\");\n+        }\n+\n+        var crHash = new SHAKE256(TR_LEN);\n+\n+        ML_DSA_PublicKey pk = new ML_DSA_PublicKey(sk.rho, t1);\n+        byte[] publicKeyBytes = pkEncode(pk);\n+        crHash.update(publicKeyBytes);\n+        byte[] tr = crHash.digest();\n+        if (!Arrays.equals(tr, sk.tr)) {\n+            throw new IllegalArgumentException(\"tr does not patch\");\n+        }\n+\n+        \/\/Encode PK and SK\n+        return new ML_DSA_PublicKey(sk.rho, t1);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.util.KeyUtil;\n+import sun.security.x509.NamedX509Key;\n+\n@@ -35,0 +39,19 @@\n+    private static final int SEED_LEN = 32;\n+\n+    public static byte[] seedToExpanded(String pname, byte[] seed) {\n+        var impl = new ML_DSA(name2int(pname));\n+        var sk = impl.generateKeyPairInternal(seed).privateKey();\n+        try {\n+            return impl.skEncode(sk);\n+        } finally {\n+            sk.destroy();\n+        }\n+    }\n+\n+    public static NamedX509Key privKeyToPubKey(NamedPKCS8Key npk) {\n+        var dsa = new ML_DSA(name2int(npk.getParams().getName()));\n+        return new NamedX509Key(npk.getAlgorithm(),\n+                npk.getParams().getName(),\n+                dsa.pkEncode(dsa.privKeyToPubKey(dsa.skDecode(npk.getExpanded()))));\n+    }\n+\n@@ -46,2 +69,2 @@\n-    static int name2int(String name) {\n-        if (name.endsWith(\"44\")) {\n+    static int name2int(String pname) {\n+        if (pname.endsWith(\"44\")) {\n@@ -49,1 +72,1 @@\n-        } else if (name.endsWith(\"65\")) {\n+        } else if (pname.endsWith(\"65\")) {\n@@ -51,1 +74,1 @@\n-        } else if (name.endsWith(\"87\")) {\n+        } else if (pname.endsWith(\"87\")) {\n@@ -55,1 +78,1 @@\n-            throw new ProviderException(\"Unknown name \" + name);\n+            throw new ProviderException(\"Unknown name \" + pname);\n@@ -72,3 +95,3 @@\n-        protected byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n-            byte[] seed = new byte[32];\n-            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+        protected byte[][] implGenerateKeyPair(String pname, SecureRandom random) {\n+            byte[] seed = new byte[SEED_LEN];\n+            var r = random != null ? random : JCAUtil.getDefSecureRandom();\n@@ -76,1 +99,2 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n@@ -78,0 +102,2 @@\n+            var expanded = mlDsa.skEncode(kp.privateKey());\n+\n@@ -81,1 +107,2 @@\n-                        mlDsa.skEncode(kp.privateKey())\n+                        KeyUtil.writeToChoices(pname, \"mldsa\", seed, expanded, null),\n+                        expanded\n@@ -85,1 +112,1 @@\n-                Arrays.fill(seed, (byte)0);\n+                Arrays.fill(seed, (byte) 0);\n@@ -112,2 +139,50 @@\n-        public KF(String name) {\n-            super(\"ML-DSA\", name);\n+        public KF(String pname) {\n+            super(\"ML-DSA\", pname);\n+        }\n+\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            var parts = KeyUtil.splitChoices(SEED_LEN, input);\n+            if (parts[0] != null && parts[1] != null) {\n+                var calculated = seedToExpanded(pname, parts[0]);\n+                if (!Arrays.equals(parts[1], calculated)) {\n+                    throw new InvalidKeyException(\"seed and expandedKey do not match\");\n+                }\n+                Arrays.fill(calculated, (byte)0);\n+            }\n+            try {\n+                if (parts[1] != null) {\n+                    return parts[1];\n+                }\n+                return seedToExpanded(pname, parts[0]);\n+            } finally {\n+                if (parts[0] != null) {\n+                    Arrays.fill(parts[0], (byte)0);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            var nk = toNamedKey(key);\n+            if (nk instanceof NamedPKCS8Key npk) {\n+                var parts = KeyUtil.splitChoices(SEED_LEN, npk.getRawBytes());\n+                var encoding = KeyUtil.writeToChoices(npk.getParams().getName(),\n+                        \"mldsa\", parts[0], parts[1],\n+                        ML_DSA_Impls::seedToExpanded);\n+                if (parts[0] != null) Arrays.fill(parts[0], (byte)0);\n+                if (parts[1] != null) Arrays.fill(parts[1], (byte)0);\n+                if (encoding == null) {\n+                    throw new InvalidKeyException(\"key contains not enough info to translate\");\n+                }\n+                nk = new NamedPKCS8Key(\n+                        npk.getAlgorithm(),\n+                        npk.getParams().getName(),\n+                        encoding,\n+                        npk.getExpanded().clone());\n+                if (npk != key) {\n+                    npk.destroy();\n+                }\n+            }\n+            return nk;\n@@ -137,1 +212,1 @@\n-            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+            super(\"ML-DSA\", new KF(), \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n@@ -139,2 +214,2 @@\n-        public SIG(String name) {\n-            super(\"ML-DSA\", name);\n+        public SIG(String pname) {\n+            super(\"ML-DSA\", new KF(pname), pname);\n@@ -144,1 +219,1 @@\n-        protected byte[] implSign(String name, byte[] skBytes,\n+        protected byte[] implSign(String pname, byte[] skBytes,\n@@ -146,1 +221,1 @@\n-            var size = name2int(name);\n+            var size = name2int(pname);\n@@ -163,1 +238,1 @@\n-        protected boolean implVerify(String name, byte[] pkBytes,\n+        protected boolean implVerify(String pname, byte[] pkBytes,\n@@ -166,1 +241,1 @@\n-            var size = name2int(name);\n+            var size = name2int(pname);\n@@ -179,1 +254,1 @@\n-        protected Object implCheckPublicKey(String name, byte[] pk)\n+        protected Object implCheckPublicKey(String pname, byte[] pk)\n@@ -182,1 +257,1 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n@@ -187,1 +262,1 @@\n-        protected Object implCheckPrivateKey(String name, byte[] sk)\n+        protected Object implCheckPrivateKey(String pname, byte[] sk)\n@@ -190,1 +265,1 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":100,"deletions":25,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -54,0 +53,1 @@\n+    private final NamedKeyFactory fac;\n@@ -58,0 +58,2 @@\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n@@ -59,1 +61,1 @@\n-    protected NamedKEM(String fname, String... pnames) {\n+    protected NamedKEM(String fname, NamedKeyFactory fac, String... pnames) {\n@@ -68,0 +70,1 @@\n+        this.fac = fac;\n@@ -79,2 +82,1 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n+        var nk = (NamedX509Key) fac.toNamedKey(publicKey);\n@@ -95,3 +97,2 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n-        var sk = nk.getRawBytes();\n+        var nk = (NamedPKCS8Key) fac.toNamedKey(privateKey);\n+        var sk = nk.getExpanded();\n@@ -104,1 +105,1 @@\n-    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+    private record KeyConsumerImpl(NamedKEM kem, String pname, int sslen,\n@@ -113,1 +114,1 @@\n-            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            var ss = kem.implDecapsulate(pname, key, k2, encapsulation);\n@@ -124,1 +125,1 @@\n-            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            var enc = kem.implEncapsulate(pname, key, k2, sr);\n@@ -149,2 +150,2 @@\n-        String name = nps.getName();\n-        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+        String pname = nps.getName();\n+        return new KeyConsumerImpl(kem, pname, kem.implSecretSize(pname), kem.implEncapsulationSize(pname),\n@@ -156,1 +157,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -162,1 +163,1 @@\n-    protected abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+    protected abstract byte[][] implEncapsulate(String pname, byte[] pk, Object pk2, SecureRandom sr);\n@@ -166,1 +167,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -173,1 +174,1 @@\n-    protected abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+    protected abstract byte[] implDecapsulate(String pname, byte[] sk, Object sk2, byte[] encap)\n@@ -178,1 +179,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -181,1 +182,1 @@\n-    protected abstract int implSecretSize(String name);\n+    protected abstract int implSecretSize(String pname);\n@@ -185,1 +186,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -188,1 +189,1 @@\n-    protected abstract int implEncapsulationSize(String name);\n+    protected abstract int implEncapsulationSize(String pname);\n@@ -199,1 +200,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -203,1 +204,1 @@\n-    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+    protected Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n@@ -216,1 +217,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -220,1 +221,1 @@\n-    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+    protected Object implCheckPrivateKey(String pname, byte[] sk) throws InvalidKeyException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -61,1 +60,1 @@\n-public class NamedKeyFactory extends KeyFactorySpi {\n+public abstract class NamedKeyFactory extends KeyFactorySpi {\n@@ -81,3 +80,3 @@\n-    private String checkName(String name) throws InvalidKeyException  {\n-        for (var pname : pnames) {\n-            if (pname.equalsIgnoreCase(name)) {\n+    private String checkName(String pname) throws InvalidKeyException  {\n+        for (var n : pnames) {\n+            if (n.equalsIgnoreCase(pname)) {\n@@ -85,1 +84,1 @@\n-                return pname;\n+                return n;\n@@ -88,1 +87,1 @@\n-        throw new InvalidKeyException(\"Unsupported parameter set name: \" + name);\n+        throw new InvalidKeyException(\"Unsupported parameter set name: \" + pname);\n@@ -132,1 +131,1 @@\n-                var bytes = rks.getKeyArr();\n+                var raw = rks.getKeyArr();\n@@ -134,3 +133,3 @@\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n-                } finally {\n-                    Arrays.fill(bytes, (byte) 0);\n+                    return new NamedPKCS8Key(fname, pnames[0], raw, implExpand(pnames[0], raw));\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(\"Invalid key input\", e);\n@@ -144,1 +143,1 @@\n-                var bytes = espec.getEncoded();\n+                var raw = espec.getEncoded();\n@@ -146,3 +145,3 @@\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n-                } finally {\n-                    Arrays.fill(bytes, (byte) 0);\n+                    return new NamedPKCS8Key(fname, pnames[0], raw, implExpand(pnames[0], raw));\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(\"Invalid key input\", e);\n@@ -159,2 +158,2 @@\n-            throws InvalidKeyException, InvalidKeySpecException {\n-        var k = new NamedPKCS8Key(fname, bytes);\n+            throws InvalidKeyException {\n+        var k = new NamedPKCS8Key(fname, bytes, this::implExpand);\n@@ -166,1 +165,1 @@\n-            throws InvalidKeyException, InvalidKeySpecException {\n+            throws InvalidKeyException {\n@@ -187,1 +186,1 @@\n-            key = engineTranslateKey(key);\n+            key = toNamedKey(key);\n@@ -228,0 +227,4 @@\n+        return toNamedKey(key);\n+    }\n+\n+    protected Key toNamedKey(Key key) throws InvalidKeyException {\n@@ -245,1 +248,1 @@\n-                String name;\n+                String pname;\n@@ -251,1 +254,1 @@\n-                    name = checkName(nps.getName());\n+                    pname = checkName(nps.getName());\n@@ -255,1 +258,1 @@\n-                            name = pnames[0];\n+                            pname = pnames[0];\n@@ -260,1 +263,1 @@\n-                        name = checkName(kAlg);\n+                        pname = checkName(kAlg);\n@@ -263,0 +266,1 @@\n+                var raw = key.getEncoded();\n@@ -264,2 +268,2 @@\n-                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n-                        : new NamedX509Key(fname, name, key.getEncoded());\n+                        ? new NamedPKCS8Key(fname, pname, raw, implExpand(pname, raw))\n+                        : new NamedX509Key(fname, pname, raw);\n@@ -273,2 +277,0 @@\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n@@ -279,5 +281,1 @@\n-            try {\n-                return fromX509(key.getEncoded());\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n-            }\n+            return fromX509(key.getEncoded());\n@@ -288,0 +286,13 @@\n+\n+    \/\/\/ User-defined function to generate the expanded format of\n+    \/\/\/ a [NamedPKCS8Key] from its encoding format.\n+    \/\/\/\n+    \/\/\/ This method is called when the key factory is constructing a private\n+    \/\/\/ key. The ownership of the result is fully granted to the caller.\n+    \/\/\/\n+    \/\/\/ @param pname the parameter set name\n+    \/\/\/ @param input the encoding, could be any format\n+    \/\/\/ @return the expanded key, not null\n+    \/\/\/ @throws InvalidKeyException if `input` is invalid\n+    protected abstract byte[] implExpand(String pname, byte[] input)\n+            throws InvalidKeyException;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":44,"deletions":33,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -55,6 +54,6 @@\n-\/\/\/ An implementation must include a zero-argument public constructor that\n-\/\/\/ calls `super(fname, pnames)`, where `fname` is the family name of the\n-\/\/\/ algorithm and `pnames` are its supported parameter set names. `pnames`\n-\/\/\/ must contain at least one element. For an implementation of\n-\/\/\/ `NamedKeyPairGenerator`, the first element becomes its default parameter\n-\/\/\/ set, i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ A `NamedKeyPairGenerator` or `NamedKeyFactory` implementation must include\n+\/\/\/ a zero-argument public constructor that calls `super(fname, pnames)`, where\n+\/\/\/ `fname` is the family name of the algorithm and `pnames` are its supported\n+\/\/\/ parameter set names. `pnames` must contain at least one element. For an\n+\/\/\/ implementation of `NamedKeyPairGenerator`, the first element becomes its\n+\/\/\/ default parameter set, i.e. the parameter set used by generated keys unless\n@@ -64,0 +63,6 @@\n+\/\/\/ A `NamedKEM` or `NamedSignature` implementation must include a zero-argument\n+\/\/\/ public constructor that calls `super(fname, factory, pnames)`, where\n+\/\/\/ `fname` is the family name of the algorithm and `pnames` are its supported\n+\/\/\/ parameter set names. `pnames` must contain at least one element. `factory`\n+\/\/\/ is the `NamedKeyFactory` object that is used to translate foreign keys.\n+\/\/\/\n@@ -72,2 +77,2 @@\n-\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n-\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key in\n+\/\/\/ any format. For key generation, the only copy is the one returned in the\n@@ -87,0 +92,24 @@\n+\/\/\/ The private key, represented as a byte array when used in `NamedKEM` or\n+\/\/\/ `NamedSignature`, is referred to as its expanded format. For some\n+\/\/\/ algorithms, this format may differ from the encoding format used in a\n+\/\/\/ PKCS #8 file (i.e. the [NamedPKCS8Key#key] field). For example,\n+\/\/\/ [FIPS 204](https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.204.pdf)\n+\/\/\/ Table 2 defines the ML-DSA-65 private key as a 4032-byte array, which is\n+\/\/\/ used in the ML-DSA.Sign function in Algorithm 2, representing the\n+\/\/\/ expanded format. However, in\n+\/\/\/ [draft-ietf-lamps-dilithium-certificates-08](https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-lamps-dilithium-certificates#name-private-key-format),\n+\/\/\/ a private key can be encoded into a CHOICE of three formats, none in the\n+\/\/\/ same as the FIPS 204 format. A `NamedKeyPairGenerator` implementation\n+\/\/\/ should return both the expanded key and a preferred encoding in its\n+\/\/\/  [#implGenerateKeyPair] method.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` that must override the `implExpand` method to\n+\/\/\/ derive the expanded format from an encoding format.\n+\/\/\/ Implementations may support multiple encoding formats.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` must not modify the `key` field, ensuring that when\n+\/\/\/ re-encoded, the key retains its original encoding format.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` can choose a differnt encoding format when\n+\/\/\/ `translateKey` is called.\n+\/\/\/\n@@ -108,1 +137,1 @@\n-    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+    private final String[] pnames; \/\/ allowed parameter set names (at least one)\n@@ -110,1 +139,1 @@\n-    protected String name; \/\/ init as\n+    protected String pname; \/\/ parameter set name, if can be determined\n@@ -129,5 +158,5 @@\n-    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n-        for (var pname : pnames) {\n-            if (pname.equalsIgnoreCase(name)) {\n-                \/\/ return the stored standard name\n-                return pname;\n+    private String checkName(String pname) throws InvalidAlgorithmParameterException  {\n+        for (var n : pnames) {\n+            if (n.equalsIgnoreCase(pname)) {\n+                \/\/ return the stored standard pname\n+                return n;\n@@ -137,1 +166,1 @@\n-                \"Unsupported parameter set name: \" + name);\n+                \"Unsupported parameter set name: \" + pname);\n@@ -144,1 +173,1 @@\n-            name = checkName(spec.getName());\n+            pname = checkName(spec.getName());\n@@ -164,4 +193,4 @@\n-        String pname = name != null ? name : pnames[0];\n-        var keys = implGenerateKeyPair(pname, secureRandom);\n-        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n-                new NamedPKCS8Key(fname, pname, keys[1]));\n+        String tmpName = pname != null ? pname : pnames[0];\n+        var keys = implGenerateKeyPair(tmpName, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, tmpName, keys[0]),\n+                new NamedPKCS8Key(fname, tmpName, keys[1], keys[2]));\n@@ -174,1 +203,3 @@\n-    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @return the public key, the private key in its encoding format, and\n+    \/\/\/         the private key in its expanded format (in this order) in\n+    \/\/\/         raw bytes.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":55,"deletions":24,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.Objects;\n@@ -54,0 +53,1 @@\n+    private final NamedKeyFactory fac;\n@@ -58,1 +58,1 @@\n-    private String name;\n+    private String pname;\n@@ -68,0 +68,2 @@\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n@@ -69,1 +71,1 @@\n-    protected NamedSignature(String fname, String... pnames) {\n+    protected NamedSignature(String fname, NamedKeyFactory fac, String... pnames) {\n@@ -78,0 +80,1 @@\n+        this.fac = fac;\n@@ -83,3 +86,2 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n-        name = nk.getParams().getName();\n+        var nk = (NamedX509Key) fac.toNamedKey(publicKey);\n+        pname = nk.getParams().getName();\n@@ -87,1 +89,1 @@\n-        pk2 = implCheckPublicKey(name, pubKey);\n+        pk2 = implCheckPublicKey(pname, pubKey);\n@@ -95,5 +97,4 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n-        name = nk.getParams().getName();\n-        secKey = nk.getRawBytes();\n-        sk2 = implCheckPrivateKey(name, secKey);\n+        var nk = (NamedPKCS8Key) fac.toNamedKey(privateKey);\n+        pname = nk.getParams().getName();\n+        secKey = nk.getExpanded();\n+        sk2 = implCheckPrivateKey(pname, secKey);\n@@ -119,1 +120,1 @@\n-            return implSign(name, secKey, sk2, msg, appRandom);\n+            return implSign(pname, secKey, sk2, msg, appRandom);\n@@ -130,1 +131,1 @@\n-            return implVerify(name, pubKey, pk2, msg, sig);\n+            return implVerify(pname, pubKey, pk2, msg, sig);\n@@ -165,1 +166,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -173,1 +174,1 @@\n-    protected abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+    protected abstract byte[] implSign(String pname, byte[] sk, Object sk2,\n@@ -178,1 +179,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -186,1 +187,1 @@\n-    protected abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+    protected abstract boolean implVerify(String pname, byte[] pk, Object pk2,\n@@ -198,1 +199,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -202,1 +203,1 @@\n-    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+    protected Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n@@ -215,1 +216,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -219,1 +220,1 @@\n-    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+    protected Object implCheckPrivateKey(String pname, byte[] sk) throws InvalidKeyException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.Locale;\n+import java.util.function.BiFunction;\n@@ -460,0 +462,138 @@\n+\n+    \/**\n+     * Writes one of the ML-KEM or ML-DSA private key formats.\n+     *\n+     * For example:\n+     *  ML-KEM-1024-PrivateKey ::= CHOICE {\n+     *       seed [0] OCTET STRING (SIZE (64)),\n+     *       expandedKey OCTET STRING (SIZE (3168)),\n+     *       both SEQUENCE {\n+     *           seed OCTET STRING (SIZE (64)),\n+     *           expandedKey OCTET STRING (SIZE (3168))\n+     *           }\n+     *       }\n+     *\n+     * This method returns one of the choices depending on the system\/security\n+     * property jdk.type.pkcs8.encoding.\n+     *\n+     * @param pname parameter set name\n+     * @param type the type string in property name, \"mlkem\" or \"mldsa\"\n+     * @param seed the seed, could be null\n+     * @param expanded the expanded key, could be null\n+     * @param expand function to calculate expanded from seed, could be null\n+     *               if there is already expanded provided\n+     * @returns one of the choices, null if seed not provided but the output\n+     *          requires it. Note that the expanded key will always be\n+     *          generated even if not provided in the input\n+     *\/\n+    public static byte[] writeToChoices(\n+            String pname, String type, byte[] seed, byte[] expanded,\n+            BiFunction<String, byte[], byte[]> expand) {\n+        byte[] skOctets;\n+        var prop = SecurityProperties.getOverridableProperty(\n+                \"jdk.\" + type + \".pkcs8.encoding\");\n+        if (prop == null) prop = \"seed\";\n+\n+        \/\/ Ensures using one-byte len in DER\n+        assert seed == null || seed.length < 128;\n+        \/\/ Ensures using two-byte len in DER\n+        assert expanded == null || expanded.length > 256 && expanded.length < 60000;\n+\n+        switch (prop.toLowerCase(Locale.ROOT)) {\n+            case \"seed\" -> {\n+                if (seed == null) return null;\n+                skOctets = new byte[seed.length + 2];\n+                skOctets[0] = (byte)0x80;\n+                skOctets[1] = (byte) seed.length;\n+                System.arraycopy(seed, 0, skOctets, 2, seed.length);\n+            }\n+            case \"expandedkey\" -> {\n+                if (expanded == null) expanded = expand.apply(pname, seed);\n+                skOctets = new byte[expanded.length + 4];\n+                skOctets[0] = 0x04;\n+                writeShortLength(skOctets, 1, expanded.length);\n+                System.arraycopy(expanded, 0, skOctets, 4, expanded.length);\n+            }\n+            case \"both\" -> {\n+                if (seed == null) return null;\n+                if (expanded == null) expanded = expand.apply(pname, seed);\n+                skOctets = new byte[10 + seed.length + expanded.length];\n+                skOctets[0] = 0x30;\n+                writeShortLength(skOctets, 1, 6 + seed.length + expanded.length);\n+                skOctets[4] = 0x04;\n+                skOctets[5] = (byte)seed.length;\n+                System.arraycopy(seed, 0, skOctets, 6, seed.length);\n+                skOctets[6 + seed.length] = 0x04;\n+                writeShortLength(skOctets, 7 + seed.length, expanded.length);\n+                System.arraycopy(expanded, 0, skOctets, 10 + seed.length, expanded.length);\n+            }\n+            default -> throw new IllegalArgumentException(\"Unknown format: \" + prop);\n+        }\n+        return skOctets;\n+    }\n+\n+    \/**\n+     * Splits one of the ML-KEM or ML-DSA private key formats into\n+     * seed and expandedKey, if exists.\n+     *\n+     * @param seedLen correct seed length\n+     * @param input input bytes\n+     * @returns seed and expandedkey, each could be null if not inside\n+     *          the input. Results are newly allocated arrays\n+     * @throws InvalidKeyException if input is invalid\n+     *\/\n+    public static byte[][] splitChoices(int seedLen, byte[] input)\n+            throws InvalidKeyException {\n+        if (input.length < seedLen + 2) {\n+            throw new InvalidKeyException(\"Too short\");\n+        }\n+        return switch (input[0]) {\n+            case (byte) 0x80 -> {\n+                \/\/ 80 SEED_LEN <SEED_LEN of seed>\n+                if (input[1] != seedLen && input.length != seedLen + 2) {\n+                    throw new InvalidKeyException(\"Invalid seed\");\n+                }\n+                yield new byte[][] { Arrays.copyOfRange(input, 2, seedLen + 2), null };\n+            }\n+            case 0x04 -> {\n+                \/\/ 04 82 nn nn <nn of expandedKey>\n+                if (readShortLength(input, 1) != input.length - 4) {\n+                    throw new InvalidKeyException(\"Invalid expandedKey\");\n+                }\n+                yield new byte[][] { null, Arrays.copyOfRange(input, 4, input.length) };\n+            }\n+            case 0x30 -> {\n+                \/\/ 30 82 mm mm 04 SEED_LEN <SEED_LEN of seed> 04 82 nn nn <nn of expandedKey>\n+                if (input.length < 6 + seedLen + 4) {\n+                    throw new InvalidKeyException(\"Too short\");\n+                }\n+                if (readShortLength(input, 1) != input.length - 4\n+                        || input[4] != 0x04\n+                        || input[5] != (byte)seedLen\n+                        || input[seedLen + 6] != 0x04\n+                        || readShortLength(input, seedLen + 7)\n+                        != input.length - 10 - seedLen) {\n+                    throw new InvalidKeyException(\"Invalid both\");\n+                }\n+                yield new byte[][] {\n+                        Arrays.copyOfRange(input, 6, 6 + seedLen),\n+                        Arrays.copyOfRange(input, seedLen + 10, input.length)};\n+            }\n+            default -> throw new InvalidKeyException(\"Wrong tag: \" + input[0]);\n+        };\n+    }\n+\n+    \/\/ Reads a 2 bytes length from DER encoding\n+    private static int readShortLength(byte[] input, int from) throws InvalidKeyException {\n+        if (input[from] != (byte)0x82) {\n+            throw new InvalidKeyException(\"Unexpected length\");\n+        }\n+        return ((input[from + 1] & 0xff) << 8) + (input[from + 2] & 0xff);\n+    }\n+\n+    \/\/ Writes a 2 bytes length to DER encoding\n+    private static void writeShortLength(byte[] input, int from, int value) {\n+        input[from] = (byte)0x82;\n+        input[from + 1] = (byte) (value >> 8);\n+        input[from + 2] = (byte) (value);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,2 @@\n-    \/\/\/ Ctor from family name, and X.509 bytes\n+    \/\/\/ Ctor from family name, and X.509 bytes. Input byte array\n+    \/\/\/ is copied. Caller can modify it after the method call.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1552,0 +1552,42 @@\n+\n+#\n+# The privateKey field for newly generated ML-KEM private keys in PKCS #8\n+#\n+# draft-ietf-lamps-kyber-certificates specifies three formats for an ML-KEM\n+# private key: a 64-octet seed, an (expanded) private key, or both.\n+#\n+# This values can be \"seed\", \"expandedKey\", or \"both\" (case-insensitive).\n+# The default value is \"seed\".\n+#\n+# When a new keypair is generated, its private key encoding will be determined\n+# by this property.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# Note: This property is currently used by the SunJCE provider in the JDK\n+# Reference implementation. It is not guaranteed to be supported by other\n+# SE implementations.\n+#\n+#jdk.mlkem.pkcs8.encoding = seed\n+\n+#\n+# The privateKey field for newly generated ML-DSA private keys in PKCS #8\n+#\n+# draft-ietf-lamps-dilithium-certificates specifies three formats for an ML-DSA\n+# private key: a 32-octet seed, an (expanded) private key, or both.\n+#\n+# When a new keypair is generated, its private key encoding will be determined\n+# by this property.\n+#\n+# This values can be \"seed\", \"expandedKey\", or \"both\" (case-insensitive).\n+# The default value is \"seed\".\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# Note: This property is currently used by the SUN provider in the JDK\n+# Reference implementation. It is not guaranteed to be supported by other\n+# SE implementations.\n+#\n+#jdk.mldsa.pkcs8.encoding = seed\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8340327\n- * @modules java.base\/sun.security.ec.ed\n- *          java.base\/sun.security.ec.point\n- *          java.base\/sun.security.jca\n- *          java.base\/sun.security.provider\n- * @library \/test\/lib\n- *\/\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import sun.security.ec.ed.EdDSAOperations;\n-import sun.security.ec.ed.EdDSAParameters;\n-import sun.security.ec.point.AffinePoint;\n-import sun.security.jca.JCAUtil;\n-import sun.security.provider.NamedKeyFactory;\n-import sun.security.provider.NamedKeyPairGenerator;\n-import sun.security.provider.NamedSignature;\n-\n-import java.security.*;\n-import java.security.spec.EdDSAParameterSpec;\n-import java.security.spec.NamedParameterSpec;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public class NamedEdDSA {\n-\n-    public static class ProviderImpl extends Provider {\n-        public ProviderImpl() {\n-            super(\"Named\", \"0\", \"\");\n-            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n-            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n-            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n-            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n-            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n-            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n-            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n-            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n-            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n-        }\n-    }\n-\n-    public static class EdDSASignature extends NamedSignature {\n-        public EdDSASignature() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSASignature(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSASignature {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSASignature {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-\n-        @Override\n-        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n-            return getOps(name).sign(plain, sk, msg);\n-        }\n-\n-        @Override\n-        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n-            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n-        }\n-\n-        @Override\n-        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n-            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n-        }\n-    }\n-\n-    public static class EdDSAKeyFactory extends NamedKeyFactory {\n-        public EdDSAKeyFactory() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSAKeyFactory(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSAKeyFactory {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSAKeyFactory {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-    }\n-\n-    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n-        public EdDSAKeyPairGenerator() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSAKeyPairGenerator(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSAKeyPairGenerator {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSAKeyPairGenerator {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-\n-        @Override\n-        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n-            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n-            var op = getOps(pname);\n-            var sk = op.generatePrivate(sr);\n-            var point = op.computePublic(sk);\n-            byte[] encodedPoint = point.getY().toByteArray();\n-            reverse(encodedPoint);\n-            \/\/ array may be too large or too small, depending on the value\n-            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n-            \/\/ set the high-order bit of the encoded point\n-            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n-            encodedPoint[encodedPoint.length - 1] |= msb;\n-            return new byte[][] { encodedPoint, sk };\n-        }\n-\n-        private static void swap(byte[] arr, int i, int j) {\n-            byte tmp = arr[i];\n-            arr[i] = arr[j];\n-            arr[j] = tmp;\n-        }\n-\n-        private static void reverse(byte [] arr) {\n-            int i = 0;\n-            int j = arr.length - 1;\n-\n-            while (i < j) {\n-                swap(arr, i, j);\n-                i++;\n-                j--;\n-            }\n-        }\n-    }\n-\n-    private static EdDSAOperations getOps(String pname) {\n-        var op = switch (pname) {\n-            case \"Ed25519\" -> e2;\n-            case \"Ed448\" -> e4;\n-            default -> throw new AssertionError(\"unknown pname \" + pname);\n-        };\n-        return op;\n-    }\n-\n-    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n-    static final EdDSAOperations e2, e4;\n-    static {\n-        try {\n-            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n-            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n-        for (var p1 : ps) {\n-            for (var p2 : ps) {\n-                for (var p3 : ps) {\n-                    test(p1, p2, p3);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n-        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n-        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n-        g.initialize(NamedParameterSpec.ED448);\n-        var kp = g.generateKeyPair();\n-        var s1 = Signature.getInstance(\"EdDSA\", p2);\n-        var s2 = Signature.getInstance(\"EdDSA\", p3);\n-        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n-        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n-        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n-        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n-        \/\/ sign and verify twice to make sure the key is intact\n-        s1.initSign(sk);\n-        var sig1 = s1.sign();\n-        s1.initSign(sk);\n-        var sig2 = s1.sign();\n-        \/\/ EdDSA signing is deterministic\n-        Asserts.assertEqualsByteArray(sig1, sig2);\n-        s2.initVerify(pk);\n-        Asserts.assertTrue(s2.verify(sig1));\n-        s2.initVerify(pk);\n-        Asserts.assertTrue(s2.verify(sig2));\n-        \/\/ No parameters defined\n-        s1.setParameter(null);\n-        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n-                InvalidAlgorithmParameterException.class);\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8340327\n- * @modules java.base\/sun.security.x509\n- *          java.base\/sun.security.pkcs\n- *          java.base\/sun.security.provider\n- *          java.base\/sun.security.util\n- * @library \/test\/lib\n- *\/\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.security.SeededSecureRandom;\n-import sun.security.pkcs.NamedPKCS8Key;\n-import sun.security.provider.NamedKeyFactory;\n-import sun.security.provider.NamedKeyPairGenerator;\n-import sun.security.util.RawKeySpec;\n-import sun.security.x509.NamedX509Key;\n-\n-import java.security.*;\n-import java.security.spec.*;\n-\n-public class NamedKeyFactoryTest {\n-\n-    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n-\n-    public static void main(String[] args) throws Exception {\n-        Security.addProvider(new ProviderImpl());\n-\n-        var g = KeyPairGenerator.getInstance(\"sHA\");\n-        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n-        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n-        var kf = KeyFactory.getInstance(\"ShA\");\n-        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n-        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-\n-        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n-                InvalidAlgorithmParameterException.class); \/\/ diff pname\n-        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n-\n-        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n-        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-\n-        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n-        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n-        checkKey(pk, \"sHa\", \"ShA-256\");\n-        checkKey(sk, \"sHa\", \"SHa-256\");\n-\n-        Asserts.assertEquals(\"X.509\", pk.getFormat());\n-        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n-\n-        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n-        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-\n-        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n-        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KeySpec\n-        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n-        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n-        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n-        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n-        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var pk1 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk2 = new PublicKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk3 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n-\n-        var sk1 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk2 = new PrivateKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk3 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n-    }\n-\n-    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n-        checkKey(kp.getPrivate(), algName, toString);\n-        checkKey(kp.getPublic(), algName, toString);\n-    }\n-\n-    static void checkKey(Key k, String algName, String pname) {\n-        Asserts.assertEquals(algName, k.getAlgorithm());\n-        Asserts.assertTrue(k.toString().contains(pname));\n-        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n-            Asserts.assertEquals(pname, nps.getName());\n-        }\n-    }\n-\n-    \/\/ Provider\n-\n-    public static class ProviderImpl extends Provider {\n-        public ProviderImpl() {\n-            super(\"P\", \"1\", \"...\");\n-            put(\"KeyFactory.SHA\", KF.class.getName());\n-            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n-            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n-            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n-            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n-            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n-        }\n-    }\n-    public static class KF extends NamedKeyFactory {\n-        public KF() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-    }\n-    public static class KF1 extends NamedKeyFactory {\n-        public KF1() {\n-            super(\"SHA\", \"SHA-256\");\n-        }\n-    }\n-    public static class KF2 extends NamedKeyFactory {\n-        public KF2() {\n-            super(\"SHA\", \"SHA-512\");\n-        }\n-    }\n-    public static class KPG extends NamedKeyPairGenerator {\n-        public KPG() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-\n-        public KPG(String pname) {\n-            super(\"SHA\", pname);\n-        }\n-\n-        @Override\n-        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n-            var out = new byte[2][];\n-            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            return out;\n-        }\n-    }\n-    public static class KPG1 extends KPG {\n-        public KPG1() {\n-            super(\"SHA-256\");\n-        }\n-    }\n-    public static class KPG2 extends KPG {\n-        public KPG2() {\n-            super(\"SHA-512\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -40,0 +40,2 @@\n+ *          java.base\/sun.security.util\n+ *          java.base\/com.sun.crypto.provider\n@@ -49,0 +51,2 @@\n+ *          java.base\/sun.security.util\n+ *          java.base\/com.sun.crypto.provider\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import sun.security.util.DerOutputStream;\n@@ -71,1 +72,2 @@\n-                g.initialize(np, new FixedSecureRandom(toByteArray(c.get(\"seed\").asString())));\n+                var seed = toByteArray(c.get(\"seed\").asString());\n+                g.initialize(np, new FixedSecureRandom(seed));\n@@ -74,1 +76,0 @@\n-                var sk = f.getKeySpec(kp.getPrivate(), EncodedKeySpec.class).getEncoded();\n@@ -76,1 +77,2 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()),\n+                        ML_DSA_Impls.seedToExpanded(pname, seed));\n@@ -109,1 +111,1 @@\n-                    public byte[] getEncoded() { return toByteArray(c.get(\"sk\").asString()); }\n+                    public byte[] getEncoded() { return oct(toByteArray(c.get(\"sk\").asString())); }\n@@ -122,0 +124,4 @@\n+    static byte[] oct(byte[] in) {\n+        return new DerOutputStream().putOctetString(in).toByteArray();\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import com.sun.crypto.provider.ML_KEM_Impls;\n@@ -26,0 +27,1 @@\n+import sun.security.util.DerOutputStream;\n@@ -68,2 +70,2 @@\n-                g.initialize(np, new FixedSecureRandom(\n-                        toByteArray(c.get(\"d\").asString()), toByteArray(c.get(\"z\").asString())));\n+                var seed = toByteArray(c.get(\"d\").asString() + c.get(\"z\").asString());\n+                g.initialize(np, new FixedSecureRandom(seed));\n@@ -72,1 +74,0 @@\n-                var sk = f.getKeySpec(kp.getPrivate(), EncodedKeySpec.class).getEncoded();\n@@ -74,1 +75,3 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"dk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(\n+                        toByteArray(c.get(\"dk\").asString()),\n+                        ML_KEM_Impls.seedToExpanded(pname, seed));\n@@ -109,1 +112,1 @@\n-                    public byte[] getEncoded() { return toByteArray(t.get(\"dk\").asString()); }\n+                    public byte[] getEncoded() { return oct(toByteArray(t.get(\"dk\").asString())); }\n@@ -121,0 +124,4 @@\n+\n+    static byte[] oct(byte[] in) {\n+        return new DerOutputStream().putOctetString(in).toByteArray();\n+    }\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327 8347938 8347941\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", new EdDSAKeyFactory(), \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", new EdDSAKeyFactory(pname), pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String pname, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) {\n+            return getOps(pname).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String pname, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(pname).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n+            return getOps(pname).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            try {\n+                return new DerValue(input).getOctetString();\n+            } catch (IOException e) {\n+                throw new InvalidKeyException(e);\n+            }\n+        }\n+\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] {\n+                    encodedPoint,\n+                    new DerOutputStream().putOctetString(sk).toByteArray(),\n+                    sk};\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n+        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n+        \/\/ sign and verify twice to make sure the key is intact\n+        s1.initSign(sk);\n+        var sig1 = s1.sign();\n+        s1.initSign(sk);\n+        var sig2 = s1.sign();\n+        \/\/ EdDSA signing is deterministic\n+        Asserts.assertEqualsByteArray(sig1, sig2);\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig1));\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig2));\n+        \/\/ No parameters defined\n+        s1.setParameter(null);\n+        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedEdDSA.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327 8347938 8347941\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+    private static final byte[] RAW_SK = RAND.nBytes(16);\n+    private static final byte[] RAW_PK = RAND.nBytes(16);\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAW_PK);\n+        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAW_SK, RAW_SK);\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+        if (k instanceof NamedPKCS8Key nsk) {\n+            var raw = nsk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_SK, raw.length), raw);\n+        }\n+        if (k instanceof NamedX509Key npk) {\n+            var raw = npk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_PK, raw.length), raw);\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input) {\n+            return input;\n+        }\n+\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KF(String name) {\n+            super(\"SHA\", name);\n+        }\n+    }\n+    public static class KF1 extends KF {\n+        public KF1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[3][];\n+            out[0] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_PK, 8) : RAW_PK;\n+            out[1] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_SK, 8) : RAW_SK;\n+            out[2] = out[1];\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeyFactoryTest.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ * @summary check the Named***Key behavior\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.util.Arrays;\n+\n+public class NamedKeys {\n+    public static void main(String[] args) throws Exception {\n+\n+        var r = SeededSecureRandom.one();\n+        var raw = r.nBytes(32);\n+\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new NamedPKCS8Key(\"ML-DSA\", \"ML-DSA-44\", raw, null));\n+\n+        \/\/ Create a key using raw bytes\n+        var sk = new NamedPKCS8Key(\"ML-DSA\", \"ML-DSA-44\", raw, raw);\n+        var enc = sk.getEncoded().clone();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(sk.getRawBytes() == sk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(sk.getEncoded() != sk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(sk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new NamedPKCS8Key(\"ML-DSA\", enc, null));\n+        var sk1 = new NamedPKCS8Key(\"ML-DSA\", enc, (_, n) -> n);\n+        var sk2 = new NamedPKCS8Key(\"ML-DSA\", enc, (_, n) -> n);\n+        var raw1 = sk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != sk2.getRawBytes());\n+        Asserts.assertTrue(sk1.getEncoded() != sk2.getEncoded());\n+\n+        var encCopy = enc.clone(); \/\/ store a copy\n+        Arrays.fill(enc, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, sk1.getEncoded());\n+\n+        \/\/ Same with public key\n+        \/\/ Create a key using raw bytes\n+        var pk = new NamedX509Key(\"ML-DSA\", \"ML-DSA-44\", raw);\n+        var enc2 = pk.getEncoded().clone();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(pk.getRawBytes() == pk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(pk.getEncoded() != pk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(pk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        var pk1 = new NamedX509Key(\"ML-DSA\", enc2);\n+        var pk2 = new NamedX509Key(\"ML-DSA\", enc2);\n+        raw1 = pk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != pk2.getRawBytes());\n+        Asserts.assertTrue(pk1.getEncoded() != pk2.getEncoded());\n+\n+        encCopy = enc2.clone(); \/\/ store a copy\n+        Arrays.fill(enc2, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, pk1.getEncoded());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeys.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @summary ensure bad keys can be detected\n+ * @run main\/othervm BadPrivateKeys\n+ *\/\n+\n+import com.sun.crypto.provider.ML_KEM_Impls;\n+import jdk.test.lib.Asserts;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.ML_DSA_Impls;\n+\n+import javax.crypto.KEM;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class BadPrivateKeys {\n+\n+    public static void main(String[] args) throws Exception {\n+        badkem();\n+        baddsa();\n+    }\n+\n+    static void badkem() throws Exception {\n+        var kf = KeyFactory.getInstance(\"ML-KEM\");\n+\n+        \/\/ The first ML-KEM-512-PrivateKey example includes the both CHOICE,\n+        \/\/ i.e., both seed and expandedKey are included. The seed and expanded\n+        \/\/ values can be checked for inconsistencies.\n+        Asserts.assertThrows(InvalidKeySpecException.class,\n+                () -> readKey(kf, BAD_KEM_1));\n+\n+        \/\/ The second ML-KEM-512-PrivateKey example includes only expandedKey.\n+        \/\/ The expanded private key has a mutated s_0 and a valid public key hash,\n+        \/\/ but a pairwise consistency check would find that the public key\n+        \/\/ fails to match private.\n+        var k2 = readKey(kf, BAD_KEM_2);\n+        var pk2 = ML_KEM_Impls.privKeyToPubKey((NamedPKCS8Key) k2);\n+        var enc = KEM.getInstance(\"ML-KEM\").newEncapsulator(pk2).encapsulate();\n+        var dk = KEM.getInstance(\"ML-KEM\").newDecapsulator(k2).decapsulate(enc.encapsulation());\n+        Asserts.assertNotEqualsByteArray(enc.key().getEncoded(), dk.getEncoded());\n+\n+        \/\/ The third ML-KEM-512-PrivateKey example includes only expandedKey.\n+        \/\/ The expanded private key has a mutated H(ek); both a public key\n+        \/\/ digest check and a pairwise consistency check should fail.\n+        var k3 = readKey(kf, BAD_KEM_3);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> KEM.getInstance(\"ML-KEM\").newDecapsulator(k3));\n+\n+        \/\/ The fourth ML-KEM-512-PrivateKey example includes the both CHOICE,\n+        \/\/ i.e., both seed and expandedKey are included. There is mismatch\n+        \/\/ of the seed and expanded private key in only the z implicit rejection\n+        \/\/ secret; here the private and public vectors match and the pairwise\n+        \/\/ consistency check passes, but z is different.\n+        Asserts.assertThrows(InvalidKeySpecException.class,\n+                () -> readKey(kf, BAD_KEM_4));\n+    }\n+\n+    static void baddsa() throws Exception {\n+        var kf = KeyFactory.getInstance(\"ML-DSA\");\n+\n+        \/\/ The first ML-DSA-PrivateKey example includes the both CHOICE, i.e.,\n+        \/\/ both seed and expandedKey are included. The seed and expanded values\n+        \/\/ can be checked for inconsistencies.\n+        Asserts.assertThrows(InvalidKeySpecException.class,\n+                () -> readKey(kf, BAD_DSA_1));\n+\n+        \/\/ The second ML-DSA-PrivateKey example includes only expandedKey.\n+        \/\/ The public key fails to match the tr hash value in the private key.\n+        var k2 = readKey(kf, BAD_DSA_2);\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> ML_DSA_Impls.privKeyToPubKey((NamedPKCS8Key) k2));\n+\n+        \/\/ The third ML-DSA-PrivateKey example also includes only expandedKey.\n+        \/\/ The private s_1 and s_2 vectors imply a t vector whose private low\n+        \/\/ bits do not match the t_0 vector portion of the private key\n+        \/\/ (its high bits t_1 are the primary content of the public key).\n+        var k3 = readKey(kf, BAD_DSA_3);\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> ML_DSA_Impls.privKeyToPubKey((NamedPKCS8Key) k3));\n+    }\n+\n+    private static PrivateKey readKey(KeyFactory kf, String input) throws Exception {\n+        var pem = input.lines()\n+                .filter(s -> !s.contains(\"-----\"))\n+                .collect(Collectors.joining());\n+        return kf.generatePrivate(\n+                new PKCS8EncodedKeySpec(Base64.getMimeDecoder().decode(pem)));\n+    }\n+\n+    \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-lamps-kyber-certificates-10#name-examples-of-bad-private-key\n+    static final String BAD_KEM_1 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIGvgIBADALBglghkgBZQMEBAEEggaqMIIGpgRAAAECAwQFBgcICQoLDA0ODxAR\n+            EhMUFRYXGBkaGxwdHh8hIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4\/QASC\n+            BmDvsn6JOEO1+bZhFYaTegU33BzhWY5u8TDVVBiwaUFnGLk3E4KY1lkkOQvUIErq\n+            c6VzJCCGVwzLkAdwiCoTOZIeHEYlqwgwpJUosrxyCyFgSFL9d57oFT3+QyRXG5tG\n+            Z6yFlUbOoVEPV5ltPMMKMY3QBrartJ\/LOwD2QT6F4hF5wXkl2bU8dgwLDAJYxZhd\n+            eQNgMTo6rLojsTCL939wAcA1ks\/zfCXBJD+J8FAzBikeocuHoaM49HaPzIzm95fE\n+            co8AWycN0JG8djQHiqjfaMYpNg0ldjW82ZycuxOtenMbZsc+GLFUmWiqZjxgupeV\n+            G4+lQZpRmsKU0ptIymHRcsMUCMHicS+19miPXIOPEQvORmEOqa0e12RZkkLj6y27\n+            Uk4kZ5TB82bpqjccBB1Oq4lQ88ns0V2fYMVt5UFCoM153A8tBBNbfAPnIWrpRQHa\n+            +TdRbDHeyhTHg2\/GExQ8lhhfB4DP\/C+v+XBY4F5xMh4euYjsWXsPC5MPyX1n6aDe\n+            eYnB9q61wWkTK6indGy1clrZwQX70Ta7I8brALnFQDuUlzhqE8f51osDoBUHqCEm\n+            eh0Za60KkLtpppJFWElopV7adFlUSzNG8IIV8p2hk5PxN6gYGBcLtsrp1ruBYkLg\n+            GaZp1MWYIEiMc4nv4jOYO7yTZCRkwJN8e4wBlyr6ysU17FdsuxI7wJRHYa26pyxh\n+            6h0kg1utBI8xSTZXA4\/Ep0JZmMOdAxP97IsoF2IpPE8AlTqsKkZSSH99ZCyg2aLT\n+            5JsFAVw5wQbHuYwaUgFWM2Z4xk81IJKVbKZD4SCboXaeYRSjdkCCp0oItlz8t8cF\n+            WVw9G29Otkqcu8Y5jJzMYwSUARi5VmuIdKK4JLGshait+hvQ2xCzEEPQqbn7rIZ3\n+            ecO4uKllgS\/og7cVtb6tSFdSElRfxBLw024tYiKszHLKB0hbVzR2Gy0xKVef8Xsi\n+            CJg8GxdrunLDlrfe237IW7VX4UvBdp3V4YGG+scfw1tMV0o7FWK8+sEMd1VVhBZX\n+            q0aRqxBRo8uY5m1IG2pIYDqSZmlIRr\/zGygxEYYCeK+p2x5YyDpt2IEIoVWu8cCm\n+            loiUsRuop7njMsrudKX\/hipV3DfkmwHUtKe6BaAb2MKLprTD1T+QCyWMgpBoImQW\n+            I2F6qEbx4pGmwhssh0iF9ikVUnA7GQSpNyPpV4LuksVV28LwDBdfLJuwuIo4R5Xg\n+            1Ju86oha8Qz7xHKpQ7MKRS7l7I+D4V2Uopy\/MrLU\/Hxeg5Go663FkA+2QJ76km8y\n+            +qE8o28vM25KSgdLAnsUeIPgnIkXfGWc0Sc5ZytrscTGIcXAQsiQhxWLcz2IFylr\n+            ODGwJXVnN2Dt+a2QV46nFX8kF2LUo0OEy0j\/XEMJ8MqgmQTaNhgtLCUpCIYwS3S7\n+            Fz\/HRj\/+AzbZISXgNV5dQF700VAsjEfftEN3AcGIgWzZ5D0+waOM98MejCU5vLyF\n+            lbe4gXyv9jmgw1cI6wsGsFtIHBzwwIc8Oy+PWqNswRPIGHJWNn+ZKTaetmrspooj\n+            wme20LlsCg2asSt6gTs\/C7BWVbAZcwTuR2hadCelkhKC0zz4Jmyqhim4GMQTnEGG\n+            wYcd92UvxsLZZMaOBGUG4y1oUnmy1hoKORa2y8xCVs7saBUDaanfGivRaoTByGal\n+            EG4ugDqhfI6RG7A2CCKkfLsdNDGBuRLqYg6RZXN0ai679nnZYsJTV0m\/YV8iioKU\n+            mFhvgx4sK44rMAIKgmC+7LxHvHGra45wtjgwpg8NYH\/vcbxvYwk\/IyaOmQKGiGIA\n+            zLqF+4OEVlMQlUOxeh3spjJtm4rV2kUshji24i9h4ROPZ8DVZq4lqTfxJcsaVnJQ\n+            4HhdomaWKnJ6lEpgMreOQlyYxp2GOAJf52GdIyKsAV9y2bfWMmuHhAniYarDxz0N\n+            +6JY0Q67VTT7AVHVx1aeVh3Vg6qVi7XX447eQoMy230pwnAMSI4fARfjZwA\/5mev\n+            42xo+n6QWhj1BC8iEafPhBz\/F5BtGVQwjMSii111xw\/9+lygBlJOSR+8Gbu45oQ\/\n+            uRoNz67mpuEldXK2fWtiQmYsoAnY0qhOArxWajY+\/0pEdTMpOV105HVzD50LQ05m\n+            hHpZnF6s80FNh4KdUx3AVX9XISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+\n+            P0A=\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    static final String BAD_KEM_2 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIGeAIBADALBglghkgBZQMEBAEEggZkBIIGYHFVT9Q2NE8nhbGzsbrBhLZnkAMz\n+            bCbxWn3oeMSCXGvgPzxKSA91t0hqrTHToAUYYj\/SB6tSjdYnIUlYNa4AYsNnt0px\n+            uvEKrQ6KKQIHa+MTSL6xXMwJV83rtK\/yJnVrvGAbZWireErLrrNHAvD4aiYgIRiy\n+            KyP4NVh3bHnBTbqYM3nIA+DcwxYKEXVwMOacaRl5jYHraYqaRIOpnlpcssMcmmYX\n+            mfPMiceQcG6gQWKQRdQqg67YiGDjlMaRh+IQXSjMFOw5NZLWfdAKpD\/otOrkQUAC\n+            hmtccTxqjX0Wz3i4GdbxLp5adCM5CPCxXjxLqDKcXN2lXISSjjqoBj5aqWdkA\/kX\n+            NbEQEMf1kwkTZNyGRFvIBIQKmiFyQhJGn4p7DOCsaY64bK05p\/SCTZpRY6rCHuaA\n+            iwU8ij+ssLZ0S1Jiu8smpD9mTIcytkz8es8JlgX0HHlgYJdqxDODP+ADQ\/sYKDAK\n+            QkdBEW5LRbsnbqgRKaDbTG5gvOYREB6MYlR0kl4CImeTCKPncI0Zcqe0I+sjKFHD\n+            bS7VPT7Tu3UAY3BhpdwikvocRmwHNUaDMovsLB7Sy1yZt47KCWkDjPfDTdEYck4x\n+            yuCGIGs0MCtSD10Xet7Vs8zgKszoCOomvMByYl\/bk\/F0WKX8HU2jlDgKH1fpzGYQ\n+            lDigdfDSgT\/MShmcx22zgj8nCwBhWUGSlAQRo3\/7r64sFQFlzsXGv3PFlfuSzRUx\n+            JgfaBwd4ZSvZlEvEi8fRpTQzi60LrWZWxdUCznhQqxWHJE7rWPQ5q14IV0pxjIqs\n+            PXfHmLuhVCczvnNEjyP7cMDlNTonyIMixSGEk6+7OAhkNNbWCla6iH3UmMOrJqCH\n+            CZOBWqakCXXyGK3KFYLWT\/yGUvuzqab7wwT5GUX6Sq7yh4\/XFd9wET0jefRIhvgS\n+            yD\/ytxmmnh7HSuSxWszTrtWlPOdqewmCRxYzuXPLQKGgAV0KQk+hGkecAjAXQ20q\n+            KQDpk+taCgZ0AMf0qt8gH8T6MSZKY7rpXMjWXDmVgV5ZfRBDVc8pqlMzyTJRhp1b\n+            zb5IcST2Ari2pmwWxHYWSK12XPXYAGtRXpBafwrAdrDGLvoygVPnylcBaZ8TBfHm\n+            vG+QsOSbaTUSts6ZKouAFt38GmYsfj+WGcvYad13GvMIlszVkYrGy3dGbF53mZbW\n+            f\/mqvJdQPyx7fi0ADYZFD7GAfKTKvaRlgloxx4mht6SRqzhydl0yDQtxkg+iE8lA\n+            k0Frg7gSTmn2XmLLUADcw3qpoP\/3OXDEdy81fSQYnKb1MFVowOI3ajdipoxgXlY8\n+            XSCVcuD8dTLKKUcpU1VntfxBPF6HktJGRTbMgI+YrddGZPFBVm+QFqkKVBgpqYoE\n+            ZM5BqLtEwtT6PCwglGByjvFKGnxMm5jRIgO0zDUpFgqasteDj3\/2tTrgWqMafWRr\n+            evpsRZMlJqPDdVYZvplMIRwqMcBbNEeDbLIVC+GCna5rBMVTXP9Ubjkrp5dBFyD5\n+            JPSQpaxUlfITVtVQt4KmTBaItrZVvMeEIZekNML2Vjtbfwmni8xIgjJ4NWHRb0y6\n+            tnVUAAUHgVcMZmBLgXrRJSKUc26LAYYaS1p0UZuLb+UUiaUHI5Llh2JscTd2V10z\n+            gGocjicyr5fCaA9RZmMxxOuLvAQxxPloMtrxs8RVKPuhU\/bHixwZhwKUfM0zdyek\n+            b7U7oR3ly0GRNGhZUWy2rXJADzzyCbI2rvNaWArIfrPjD6\/WaXPKin3SZ1r0H3oX\n+            thQzzRr4D3cIhp9mVIhJeYCxrBCgzctjagDthoGzXkKRJMqANQcluF+DperDpKPM\n+            FgCQPmUpNWC5szblrw1SnawaBIEZMCy3qbzBELlIUb8CEX8ZncSFqFK3Rz8JuDGm\n+            gx1bVMC3kNIlz2u5LZRiomzbM92lEjx6rw4moLg2Ve6ii\/OoB0clAY\/WuuS2Ac9h\n+            uqtxp6PTUZejQ+dLSicsEl1UCJZCbYW3lY07OKa6mH7DciXHtEzbEt3kU5tKsII2\n+            NoPwS\/egnMXEHf6DChsWLgsyQzQ2LwhKFEZ3IzRLrdAA+NjFN8SPmY8FMHzr0e3g\n+            uBw7xZoGWhttY7JsgvEB\/2SAY7N24rtsW3RV9lWlDC\/q2t4VDvoODm82WuogISIj\n+            JCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+Pw==\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    static final String BAD_KEM_3 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIGeAIBADALBglghkgBZQMEBAEEggZkBIIGYHBVT9Q2NE8nhbGzsbrBhLZnkAMz\n+            bCbxWn3oeMSCXGvgPzxKSA91t0hqrTHToAUYYj\/SB6tSjdYnIUlYNa4AYsNnt0px\n+            uvEKrQ6KKQIHa+MTSL6xXMwJV83rtK\/yJnVrvGAbZWireErLrrNHAvD4aiYgIRiy\n+            KyP4NVh3bHnBTbqYM3nIA+DcwxYKEXVwMOacaRl5jYHraYqaRIOpnlpcssMcmmYX\n+            mfPMiceQcG6gQWKQRdQqg67YiGDjlMaRh+IQXSjMFOw5NZLWfdAKpD\/otOrkQUAC\n+            hmtccTxqjX0Wz3i4GdbxLp5adCM5CPCxXjxLqDKcXN2lXISSjjqoBj5aqWdkA\/kX\n+            NbEQEMf1kwkTZNyGRFvIBIQKmiFyQhJGn4p7DOCsaY64bK05p\/SCTZpRY6rCHuaA\n+            iwU8ij+ssLZ0S1Jiu8smpD9mTIcytkz8es8JlgX0HHlgYJdqxDODP+ADQ\/sYKDAK\n+            QkdBEW5LRbsnbqgRKaDbTG5gvOYREB6MYlR0kl4CImeTCKPncI0Zcqe0I+sjKFHD\n+            bS7VPT7Tu3UAY3BhpdwikvocRmwHNUaDMovsLB7Sy1yZt47KCWkDjPfDTdEYck4x\n+            yuCGIGs0MCtSD10Xet7Vs8zgKszoCOomvMByYl\/bk\/F0WKX8HU2jlDgKH1fpzGYQ\n+            lDigdfDSgT\/MShmcx22zgj8nCwBhWUGSlAQRo3\/7r64sFQFlzsXGv3PFlfuSzRUx\n+            JgfaBwd4ZSvZlEvEi8fRpTQzi60LrWZWxdUCznhQqxWHJE7rWPQ5q14IV0pxjIqs\n+            PXfHmLuhVCczvnNEjyP7cMDlNTonyIMixSGEk6+7OAhkNNbWCla6iH3UmMOrJqCH\n+            CZOBWqakCXXyGK3KFYLWT\/yGUvuzqab7wwT5GUX6Sq7yh4\/XFd9wET0jefRIhvgS\n+            yD\/ytxmmnh7HSuSxWszTrtWlPOdqewmCRxYzuXPLQKGgAV0KQk+hGkecAjAXQ20q\n+            KQDpk+taCgZ0AMf0qt8gH8T6MSZKY7rpXMjWXDmVgV5ZfRBDVc8pqlMzyTJRhp1b\n+            zb5IcST2Ari2pmwWxHYWSK12XPXYAGtRXpBafwrAdrDGLvoygVPnylcBaZ8TBfHm\n+            vG+QsOSbaTUSts6ZKouAFt38GmYsfj+WGcvYad13GvMIlszVkYrGy3dGbF53mZbW\n+            f\/mqvJdQPyx7fi0ADYZFD7GAfKTKvaRlgloxx4mht6SRqzhydl0yDQtxkg+iE8lA\n+            k0Frg7gSTmn2XmLLUADcw3qpoP\/3OXDEdy81fSQYnKb1MFVowOI3ajdipoxgXlY8\n+            XSCVcuD8dTLKKUcpU1VntfxBPF6HktJGRTbMgI+YrddGZPFBVm+QFqkKVBgpqYoE\n+            ZM5BqLtEwtT6PCwglGByjvFKGnxMm5jRIgO0zDUpFgqasteDj3\/2tTrgWqMafWRr\n+            evpsRZMlJqPDdVYZvplMIRwqMcBbNEeDbLIVC+GCna5rBMVTXP9Ubjkrp5dBFyD5\n+            JPSQpaxUlfITVtVQt4KmTBaItrZVvMeEIZekNML2Vjtbfwmni8xIgjJ4NWHRb0y6\n+            tnVUAAUHgVcMZmBLgXrRJSKUc26LAYYaS1p0UZuLb+UUiaUHI5Llh2JscTd2V10z\n+            gGocjicyr5fCaA9RZmMxxOuLvAQxxPloMtrxs8RVKPuhU\/bHixwZhwKUfM0zdyek\n+            b7U7oR3ly0GRNGhZUWy2rXJADzzyCbI2rvNaWArIfrPjD6\/WaXPKin3SZ1r0H3oX\n+            thQzzRr4D3cIhp9mVIhJeYCxrBCgzctjagDthoGzXkKRJMqANQcluF+DperDpKPM\n+            FgCQPmUpNWC5szblrw1SnawaBIEZMCy3qbzBELlIUb8CEX8ZncSFqFK3Rz8JuDGm\n+            gx1bVMC3kNIlz2u5LZRiomzbM92lEjx6rw4moLg2Ve6ii\/OoB0clAY\/WuuS2Ac9h\n+            uqtxp6PTUZejQ+dLSicsEl1UCJZCbYW3lY07OKa6mH7DciXHtEzbEt3kU5tKsII2\n+            NoPwS\/egnMXEHf6DChsWLgsyQzQ2LwhKFEZ3IzRLrdAA+NjFN8SPmY8FMHzr0e3g\n+            uBw7xZoGWhttY7Jsg\/EB\/2SAY7N24rtsW3RV9lWlDC\/q2t4VDvoODm82WuogISIj\n+            JCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+Pw==\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    static final String BAD_KEM_4 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIGvgIBADALBglghkgBZQMEBAEEggaqMIIGpgRAAAECAwQFBgcICQoLDA0ODxAR\n+            EhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwSC\n+            BmBwVU\/UNjRPJ4Wxs7G6wYS2Z5ADM2wm8Vp96HjEglxr4D88SkgPdbdIaq0x06AF\n+            GGI\/0gerUo3WJyFJWDWuAGLDZ7dKcbrxCq0OiikCB2vjE0i+sVzMCVfN67Sv8iZ1\n+            a7xgG2Voq3hKy66zRwLw+GomICEYsisj+DVYd2x5wU26mDN5yAPg3MMWChF1cDDm\n+            nGkZeY2B62mKmkSDqZ5aXLLDHJpmF5nzzInHkHBuoEFikEXUKoOu2Ihg45TGkYfi\n+            EF0ozBTsOTWS1n3QCqQ\/6LTq5EFAAoZrXHE8ao19Fs94uBnW8S6eWnQjOQjwsV48\n+            S6gynFzdpVyEko46qAY+WqlnZAP5FzWxEBDH9ZMJE2TchkRbyASECpohckISRp+K\n+            ewzgrGmOuGytOaf0gk2aUWOqwh7mgIsFPIo\/rLC2dEtSYrvLJqQ\/ZkyHMrZM\/HrP\n+            CZYF9Bx5YGCXasQzgz\/gA0P7GCgwCkJHQRFuS0W7J26oESmg20xuYLzmERAejGJU\n+            dJJeAiJnkwij53CNGXKntCPrIyhRw20u1T0+07t1AGNwYaXcIpL6HEZsBzVGgzKL\n+            7Cwe0stcmbeOyglpA4z3w03RGHJOMcrghiBrNDArUg9dF3re1bPM4CrM6AjqJrzA\n+            cmJf25PxdFil\/B1No5Q4Ch9X6cxmEJQ4oHXw0oE\/zEoZnMdts4I\/JwsAYVlBkpQE\n+            EaN\/+6+uLBUBZc7Fxr9zxZX7ks0VMSYH2gcHeGUr2ZRLxIvH0aU0M4utC61mVsXV\n+            As54UKsVhyRO61j0OateCFdKcYyKrD13x5i7oVQnM75zRI8j+3DA5TU6J8iDIsUh\n+            hJOvuzgIZDTW1gpWuoh91JjDqyaghwmTgVqmpAl18hityhWC1k\/8hlL7s6mm+8ME\n+            +RlF+kqu8oeP1xXfcBE9I3n0SIb4Esg\/8rcZpp4ex0rksVrM067VpTznansJgkcW\n+            M7lzy0ChoAFdCkJPoRpHnAIwF0NtKikA6ZPrWgoGdADH9KrfIB\/E+jEmSmO66VzI\n+            1lw5lYFeWX0QQ1XPKapTM8kyUYadW82+SHEk9gK4tqZsFsR2Fkitdlz12ABrUV6Q\n+            Wn8KwHawxi76MoFT58pXAWmfEwXx5rxvkLDkm2k1ErbOmSqLgBbd\/BpmLH4\/lhnL\n+            2GnddxrzCJbM1ZGKxst3Rmxed5mW1n\/5qryXUD8se34tAA2GRQ+xgHykyr2kZYJa\n+            MceJobekkas4cnZdMg0LcZIPohPJQJNBa4O4Ek5p9l5iy1AA3MN6qaD\/9zlwxHcv\n+            NX0kGJym9TBVaMDiN2o3YqaMYF5WPF0glXLg\/HUyyilHKVNVZ7X8QTxeh5LSRkU2\n+            zICPmK3XRmTxQVZvkBapClQYKamKBGTOQai7RMLU+jwsIJRgco7xShp8TJuY0SID\n+            tMw1KRYKmrLXg49\/9rU64FqjGn1ka3r6bEWTJSajw3VWGb6ZTCEcKjHAWzRHg2yy\n+            FQvhgp2uawTFU1z\/VG45K6eXQRcg+ST0kKWsVJXyE1bVULeCpkwWiLa2VbzHhCGX\n+            pDTC9lY7W38Jp4vMSIIyeDVh0W9MurZ1VAAFB4FXDGZgS4F60SUilHNuiwGGGkta\n+            dFGbi2\/lFImlByOS5YdibHE3dlddM4BqHI4nMq+XwmgPUWZjMcTri7wEMcT5aDLa\n+            8bPEVSj7oVP2x4scGYcClHzNM3cnpG+1O6Ed5ctBkTRoWVFstq1yQA888gmyNq7z\n+            WlgKyH6z4w+v1mlzyop90mda9B96F7YUM80a+A93CIafZlSISXmAsawQoM3LY2oA\n+            7YaBs15CkSTKgDUHJbhfg6Xqw6SjzBYAkD5lKTVgubM25a8NUp2sGgSBGTAst6m8\n+            wRC5SFG\/AhF\/GZ3EhahSt0c\/CbgxpoMdW1TAt5DSJc9ruS2UYqJs2zPdpRI8eq8O\n+            JqC4NlXuoovzqAdHJQGP1rrktgHPYbqrcaej01GXo0PnS0onLBJdVAiWQm2Ft5WN\n+            Ozimuph+w3Ilx7RM2xLd5FObSrCCNjaD8Ev3oJzFxB3+gwobFi4LMkM0Ni8IShRG\n+            dyM0S63QAPjYxTfEj5mPBTB869Ht4LgcO8WaBlobbWOybILxAf9kgGOzduK7bFt0\n+            VfZVpQwv6treFQ76Dg5vNlrqICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9\n+            Pj4=\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    \/\/ https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-lamps-dilithium-certificates#name-example-inconsistent-privat\n+    static final String BAD_DSA_1 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIKPgIBADALBglghkgBZQMEAxEEggoqMIIKJgQgAAECAwQFBgcICQoLDA0ODxAR\n+            EhMUFRYXGBkaGxwdHh8EggoAUQyb\/R3XN09Oiucd1YKBEGqTQS7Y+jV\/dLu0Zh7L\n+            GSHTp1\/JO4jvDmqbhRvs7BmZm+gQaMhZ1t8RXGCMFQEXDrbAVcIvYlWSSXbYlaX1\n+            TSw4WWxAPM72+XPiKl+MfCuoNjNEcJCniyK7Qc\/e2vvLLt7PkHDM5hLkKrCh8T65\n+            3DwUkDGJwoHgsDHalISCEgijtDDSKEoEByDDRELgQC5EoHEBqSwDJmQSQSQYMiQA\n+            Ii5KlmALGZAiMyBShkUbCEyTGIQZAG1TgAwQpChQBgogBgwjETLSxEDSEgIENIYj\n+            lQygtkxbSJGMEoQgGQKRGIEKJRAcoGlgkCgDxjCTBJARuJAERTLBIEzawpDZiCwY\n+            RiTKsAUjsWyKEIwEgXDLpDDYRmLBxhDIyEXBlgwEEgrkKGYcJXCcsohigGxiOEWE\n+            gEyjoA0jBw7IRiAklSkkRgVICHATIUxghCGQsg3QNoAZgE0blmEUEIUaJkCcwIij\n+            GBADAiGSMlGYCDIiOYpAEm4MJkEYGU4iAmTCMBFCFhJjFiwRo4TigCXSRmKakgAR\n+            uA2LhgBRlnHIRiQIiUEDFUChIm4kNWmAJC7CiIUEMYxawIlCRI1YxgCZMpIbISDL\n+            Am4YGXDYxiRBNnIZkGVYOG4IIAwCFCpjFoUBtCVQwmgJGVAisk3DGCokGCKbRmgQ\n+            NUIgNmLbNAWLsmxIEIoByI0hMA6MFCZCJAQLN4xDBilCSIbYGIXIpAQUtjHRNgwi\n+            gykAok1cuA1kiEXIAEgUOExiomjUBi7ZAg3MthFhOGTIMpJRyElSgAHgwDEAIgrB\n+            RGaAtIRQCDASxiikCGBKsGHKxkESyGhSsHGbAAwIR2ZhGGxRFImBRoYJOUSDAjEK\n+            kWnhIlFZRkGiBjLaBnCZMCzIJi3akpDBACDasGWCJDKDRIVcxGwAQyKJxhCjBABh\n+            hCSjQBJRIA0YMoBBNirIsCkgRwgaEkTDtpEiKYzYMmbDlhBiJnIbRWXDpmXZwGAU\n+            EAjQxG1JMoXQBg0RJEzjtAABqUUAM4BCMGBKgEmCNCBDGAgSBiaSRILKMAHhNo5b\n+            IiIkBwZUEIlLoEGYRgpMFEoKNIQgI07AFgUDRiyAtkEUkzHLJgARmG0KEg7YEGKQ\n+            NgwUAXGJBirIJmZSBFHkBkDckiHIEHFkGC7kuABSkGiLqChLJEkRJoGZiJFUNg0K\n+            mIG8aRx5dr9\/gBkPfhwZrwn4DSmTPr\/Vn01JddemyttdtkeLCZ4DW7+GKb7Z8S4f\n+            HY7JlsvtetEEMyRAS8\/INLBzTBrGWIRQqWxf3YcrxGG51NDOlvdrYH7wnySOku6m\n+            N12BMMwLEfKkmOSU747o81iHE+wiM2bPH+rG7eP6rIrB7NRY67odfeBGboLHeSdf\n+            79U3GOWczZiFB5wtZGzNoVpiExABNAydQC4OJIPvpxR0ULrErVz9y33\/zj9KIZJy\n+            +saqdCSssuX3kbavVhZQz7eytus2Aji7uSWgPb4M7FqBoFcpobHX\/jVvHD8oaBt2\n+            TOjtuObFujQUnDcztr62etukrM+IwyyLR4WCpFev9qGM+ZP9TCsLbEDu\/rVMVS81\n+            dnKlkkYhy\/pUgsGU2jg1bTD83Wib8laAlKZgXSqLBsyP2hpmU66+mX\/2gQR9rCzh\n+            gJSFDfiIGPo1nU2yelQMJ8YOniHNv8I5ZRKylmRFpDZo+QPVoXMnwTg0eF\/c3UCO\n+            PTc59SFlUpxMSPttjYLHEnPlqJnHLb\/PZMWlqfd+FE+i4GfHfKDH6RF3NUjPY0Jx\n+            I1EJ5l\/HxG+zK4c1abd6LU4fMGnnKrNKlNSF5yoq8b68GIspz\/Mnni3Z8++arXx\/\n+            hzMVayoTe6vtL0ZtyByyV26jjrxOEMpf0ZLzjkWB+Q9a+Z6QxEcTtpVlsOhnxB9w\n+            cWFz1hzdOz1ZaMv89k3iYgajdmNIHeUQdz8wwc1621onspo5YlzuruFSorrzz\/Ru\n+            yyg3iHNFmRv2SCNuWcziAFTSd8HBtInzNWmeqBeF7HW1hsCpRoR02ZV4iM+REFrj\n+            qPVHh3zqURGGSdu1y29uK6M2vjUp0w8NfyuvzbHIy2hJz3Py9kiZotfF4kOgU25D\n+            11b+\/IcaVavqBxCUAz9N4c29aBGZO8reC+X9kPWuNE8NY7e3j4YmPcWppZGfXnY9\n+            PNV0pLyhLeifev2Wk1ahcLVYLE6l\/cFE6qxmThkD8uTrZ7h75JmUqDmKNVjtJW5N\n+            YS5XSZQz4bFhsdXvpED5F5jwr2NUPpZZDkjuEKXu81ll14F4wx98g776d6LI\/zTY\n+            a06arDBhDhmeyDQZFhMtlu575XeFZGdP11IVo4UPSCQKzc\/AMxlrjNrQw2wNZJ+t\n+            6JDEJq75MS7q5C7gvPpBd3qdmbNQwLFvyCj8ohXcpqc1Lgw12BFNtm5L2JXXle\/7\n+            QmhVrMEkSwJznkd+bOqky9uPbI1Nr1fw0+NJBeqCJtxVvjngV3rE97E1RqzHFxaH\n+            QQvju+iK\/j03mKXQes6be6UWIrYz8+RhZ4jwlK2nPDklHM0+0p2sNlha3BYl+Fob\n+            uXxZug5ze+Lor7aiIiy18xn64MxZ4QBP3pFpKeW3YJKoLcJSexuJlKJ8Ky5WjnJ+\n+            skZeuWRgmW\/OYyRcKyyylrgnWv0A2oyBqe8ujjv5MD2Oi1Oq\/mxtA+a8IAQ0oqOL\n+            F00uc91QcXXoUdXnQ+ZCCeNIUg1shMyx+2v6smyMLuSFEQ3R17Br1Sgw6lu2gD0S\n+            XMYOX6h8w0Ww9ml1Huth5xm21mYiPLiejT3vPOyWrJNQ7pg4l\/0VGBTG+1zaN5fo\n+            paZzqkJijn+EH7d+G8RVLGhU0gkbplrNqDAIHAiCnO76b3CuBam2ngtjQzBPUlSU\n+            AqXPtG17rJg2B+fzgPKAgh8vuZLEaXP7\/XeNMwNe6QsNuU9gfln7Tt+pqYpwm1gH\n+            Wkqor1xYXy+1md2Ct3tLbznupLFIfQ3NVBkeDW+NVvpPvC+CF\/NefkSuzOaBPlTa\n+            itxMHENeGFxR5cf0Sp43j59iGKdWBtJBCV8uWf4qRgRG8fdbfQ+l1qAJEx4v8r4H\n+            2Hsm6eS\/CeZlEpe9fnobwS1BBNoczKSL+noqpxcmgAjbcEtZtsBXSJVBsj4OCdt3\n+            fA\/6IfpWRsNBIVR1aD2p\/a0U\/RH3FCZKDhwF2ZhBLeHEWWQOCr1v0W68\/rllFuIW\n+            YcyqOojDEup7oFhc0k4aUwdv50HJAWk3ehaPvbP+zlz84DmyVMQjXYJl9gZShi+9\n+            tFV4KJ8aZz\/kCdufmWwtLJKHIBuVkX\/hqbYO8Xg4XyWv2pZpZIGeW779l8wQE1MI\n+            2Yt6grThI3sytb+dM3JvqUW79clvJ288BqRZMJSNO2vUIo4vPqyM\/Wcuy465qS0V\n+            ns+zr0zC2uo3z3LqK57arYABNRm8CV2VxaOqH61GvYyUrA==\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    static final String BAD_DSA_2 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIKGAIBADALBglghkgBZQMEAxEEggoEBIIKANeytHJUquDbReeTDUqY0sl9jxOX\n+            0Xidr6FwJLMW6b7JOc4Pf3f421ZE3No2a\/5HNL2V9DX\/mmE6pUqkHCxpTAQzmgex\n+            +rtI9SownxGhiY+EjiMi\/+Yj7IENs77jNoWFSogmnaMg1RIL\/P6JoY4w9xFNg6pA\n+            SmRrbJlziYYNElIu4ABuI4SBkYZhmyYNEYZk1KYoIhhEgkAomBRhSKZhTEJIoZII\n+            wjgpUSRICKElwggxCMRxIBQJFINsGKeAhBBuycBwIrVkCLBhDAcEmBJEUYhpWQBG\n+            IpMgQQYuQrZMARZJFChMQahRgEYKURZRWgggAiJE3JhJ0TJR4TBl08CFkqhREqFk\n+            ADkiCUZiHMcM2Qht0AYmUkCFgEQwkQYsUMgJJMWEGpZtSpgsmQZtpEQyIKdkWjJu\n+            EbVwIJJhJBOOBIUsCkhyyKBR0wgqmSCAWCQgJAdOWRSIEKRkYMBt4LKNGxkJIDQi\n+            wCRBCUNxCiEgYaIBUiJSG4CAmjQAE5NN0zIpIhcKmJJpGhRRICchnMAgYqKBSBhp\n+            GoVNg0RpWyBBAxJCyxhGAakNDAIxg7AhWiJKyJIF2ZBpBDBqSwZK0rIBHEBAgUIy\n+            UjJyVKZAWhgQDDISksKAUhJiXIIoC7RsA0KNUxAMFAEO4TZSiIQkkQIKY0YmIAYp\n+            EcIo0CBIArNsojYJWoZIy7Rhi0ZixECCGokJEAJNJLJFIBIlJMkFiCiMycBNWUgi\n+            CiduwTRkTJBgW0RQgoZJQ4gEQ7KMYDCAoogthKRtjKYp0MaEQgZGiYhRAKmNAUmN\n+            5DgNpAaN05RxQrJsGoRhG6MoQrQoCKBxGsUx4KBMATdlJChiFCiQCRBh2UAiGzNg\n+            CQKS0CSBIAQISRhEoyItXIhEFJgIpEZhAZVkCzkKDJRQykBq0rIgwDgBgjCOE7kI\n+            kYCEFIgpwBiREjUNoCQi4gQG2cKFBCgSHMmJGAJy0kApwggS2AYqmZRxm7hoI4Qp\n+            GiKJFEUR3IJEUJZFDESEwLIEmqYFQ4YsRDJuiEQhIKhMmjBw47gtYyaIAyVJA0OM\n+            SKgJyhRyUzROEkMIG6cEWTAi2ZSA4jQigUISnDAqlDQmYQRFJCYoE0YJSjJtESgJ\n+            GLglYigRE0ENQbIRkIRMixISosaIycAwIgYG0hiOhIYwkERSEogx2SBxE8UoQwYO\n+            AzBgzKaEWCZSTIgBHvclYshf+kOs+kkhfysXLXu8FGIObZgKcaq73wxF6aIG7LFC\n+            P+4V3swXYBMAFJ2SI81ubG4fqOQfx8ZJOKtokF\/T3NpQ2HCC59DXHRvJsrhMhVI8\n+            qP5srSlK34O+FbEI\/3IdDMh7w906dZAYSw6EVmOpH8nhw8U6YdhnQgsE8JI1V1O8\n+            ZaBjaP1BKV\/QmSQTLG+R9nlkwUJnSnJcNDkUxM7PWMB0vK9FWMl795EeB6ptCTjy\n+            7iuzwajFldY16ENC\/eoB3CSyEa0vwoHPd+WREMerxUvwyG1IC5vidkcdydYDzumM\n+            \/as+n8+3A3k1YFSepEUPp7M\/uRacRLTSX7nEV\/SXkc09oD6slglYE8EFEyzNpOY+\n+            SSKM0j2KHzeFbxQtk7kNsJ+Cr4kljGOquAR6gMA2yTV+ogRvjcY1TwxSlfNCu0F9\n+            PP6wsf0zYiwp4Uy72S4TY8ZevUUEt1EjKblnDjLhssZ6VOfxpV+Ln56gToyjpwXm\n+            KjxeY3N0r7eutt3qYSzeKPAaIC16pONHItJ90\/m4mJTQGf1dTXEZ7+NyO7oQTLi7\n+            CYHgdN46\/iANqq6tgmzEXyRNv0Ma+rNO+994JHTS\/VcRj2RiFJNO2Zy6OwA+jWej\n+            g29vGfxBkQzlFj7jrpnrhNUU63YeY2hOpW+XkdLdSqxuYWi5SMgX91oiKssOjNwD\n+            zEr+j2cVfho2O3+u\/58XK5iRNnfFod0IXp7kwiBSwa9YGTEWZz3NO\/xfNLhV3MbH\n+            eIVknp5x9D1K6g9Lcsp+2gV4uhPTGmWNLQYKmmb\/ae0b55l6L7HScj04+b+r4Y+O\n+            ezzakG5Om16ULI6uspYHDr\/TZJR6lAzJeL7Wazd0nm1dzXvoxJREDiuEzs\/vuYwL\n+            7fs8QeM1nSzXGX++cgxIqmxrZGXB7mPjVpwq3HREkTcLf3gm\/gt3odGdZBAdAyuR\n+            gQa0LS73N0flYB\/kulDyPt5SHwMagX0VKUpDci6DeHhLbbDPG6norpEdkgG5zpzD\n+            AZxvXCfLmNomFEtkIlp8kysw92Hnii1Zodi4PsY0Si9t1H52VwbQC\/SnmmqSbDup\n+            HYEsjyx5erF5Zwnl0WhWd4KTUp8ChtAVw7U5lhlkKjM+nlk9bj9TU5lCCOnmozKF\n+            HX9lJSKpKLkX4n4tbUITff4uv6b7HGeybAJUUoaF9+vb4xWmjqotp2noqfQtPmAA\n+            fHEzCSaywAEtg+rU5P0e2HLM0ZciAdKwJ\/NUWsLTDNeLwddA\/sy8b8KgRGxuMOrF\n+            H1ppCYqi1EfyCFtOTkuSzMJpIdLeR4UYzQkM4meuotJ62lf9iLSXbYn7hDzcz0mn\n+            bKJnnmgBv6f7AxiW+1BilwS5kjk2u13ThTERIcrfsRmV5ZtzA0z2ftA6uBOGdkjQ\n+            JYKAh+lJqa\/Ra5XXLZmx7coleqwTL\/t6Bwmu1anA\/wX7Dyu\/KECe7XtfWAG+lkzt\n+            AZ4ct4UdOFHxApBnThn\/sAizAcSs9kGiuxQhbh1pyr9Ste8idJaw8weZqFXRF\/rT\n+            dEpvozUD6nmLUt3X7lQmYJ2\/zT8ME7Fk1sBR9+1KEZcZpxLjiNMoQCCB\/xNUtVTS\n+            wjev7TsVHEuo6fS964SZowZuJrvGnorwid7HFzHR3FKeqxfvc3RzTA\/kdUlMg4Nr\n+            3TSgO5vImRRxYGG\/uY7G5hw+1EOO3K8lJDxkcIa56nAYsNmooLAM7LAKveJJjWnC\n+            M2EBp3LL5PVxUj9RvQWILN81i4ScwUCqH68iQjoShRzg4z\/UiXWklZ+lxf5BjJOQ\n+            gZGrbnQbd7\/gLL1pjueVxGbWFWGeZEE4LG6sAYNO6atzzqgLviNceNqRvXm2+C+J\n+            l4XWhwDTk+Z1wiJNa3oa0hMgSVZ5ra7XAWe1CGZxOlMQnbe299gTBOzf2Dsxmx7y\n+            SDBrRa0p593Mhj2sVgSLXWnqF1AR92FMAKhqhjzeGHKokyh4uax+GsW9pJl7cgZP\n+            DNdfTIFOA03hGsuQE89+qSa05+qs4HDHuiGI760uQx4SI9Rd0FxNhAPC5FzuZBPs\n+            vnUn6HPkVcTmEKYYOarMC9VtJIPnjymLZqR46y9VjLr8qGvoR7rrAsWyFsjNiP6k\n+            3ySbCeZwogcDq6wksKkavEpWRmAUQroQvs\/TCZOIAFHQf1agWpN556jmvv7j8i+q\n+            EGOY93BgBuQum+HvidJcJy8RqVCVxYfXE3MihN6dvTxyF7BoniHY6w\/2lmg=\n+            -----END PRIVATE KEY-----\"\"\";\n+\n+    static final String BAD_DSA_3 = \"\"\"\n+            -----BEGIN PRIVATE KEY-----\n+            MIIKGAIBADALBglghkgBZQMEAxEEggoEBIIKANeytHJUquDbReeTDUqY0sl9jxOX\n+            0Xidr6FwJLMW6b7JOc4Pf3f421ZE3No2a\/5HNL2V9DX\/mmE6pUqkHCxpTAQymgex\n+            +rtI9SownxGhiY+EjiMi\/+Yj7IENs77jNoWFSogmnaMg1RIL\/P6JoY4w9xFNg6pA\n+            SmRrbJlziYYNElIu4ABuI4SBkYZhmyYNEYZk1KYoIhhEgkAomBRhSKZhTEJIoZII\n+            wjgpUSRICKElwggxCMRxIBQJFINsGKeAhBBuycBwIrVkCLBhDAcEmBJEUYhpWQBG\n+            IpMgQQYuQrZMARZJFChMQahRgEYKURZRWgggAiJE3JhJ0TJR4TBl08CFkqhREqFk\n+            ADkiCUZiHMcM2Qht0AYmUkCFgEQwkQYsUMgJJMWEGpZtSpgsmQZtpEQyIKdkWjJu\n+            EbVwIJJhJBOOBIUsCkhyyKBR0wgqmSCAWCQgJAdOWRSIEKRkYMBt4LKNGxkJIDQi\n+            wCRBCUNxCiEgYaIBUiJSG4CAmjQAE5NN0zIpIhcKmJJpGhRRICchnMAgYqKBSBhp\n+            GoVNg0RpWyBBAxJCyxhGAakNDAIxg7AhWiJKyJIF2ZBpBDBqSwZK0rIBHEBAgUIy\n+            UjJyVKZAWhgQDDISksKAUhJiXIIoC7RsA0KNUxAMFAEO4TZSiIQkkQIKY0YmIAYp\n+            EcIo0CBIArNsojYJWoZIy7Rhi0ZixECCGokJEAJNJLJFIBIlJMkFiCiMycBNWUgi\n+            CiduwTRkTJBgW0RQgoZJQ4gEQ7KMYDCAoogthKRtjKYp0MaEQgZGiYhRAKmNAUmN\n+            5DgNpAaN05RxQrJsGoRhG6MoQrQoCKBxGsUx4KBMATdlJChiFCiQCRBh2UAiGzNg\n+            CQKS0CSBIAQISRhEoyItXIhEFJgIpEZhAZVkCzkKDJRQykBq0rIgwDgBgjCOE7kI\n+            kYCEFIgpwBiREjUNoCQi4gQG2cKFBCgSHMmJGAJy0kApwggS2AYqmZRxm7hoI4Qp\n+            GiKJFEUR3IJEUJZFDESEwLIEmqYFQ4YsRDJuiEQhIKhMmjBw47gtYyaIAyVJA0OM\n+            SKgJyhRyUzROEkMIG6cEWTAi2ZSA4jQigUISnDAqlDQmYQRFJCYoE0YJSjJtESgJ\n+            GLglYigRE0ENQbIRkIRMixISosaIycAwIgYG0hiOhIYwkERSEogx2SBxE8UoQwYO\n+            AzBgzKaEWCZSTIgBH\/clYshf+kOs+kkhfysXLXu8FGIObZgKcaq73wxF6aIG7LFC\n+            P+4V3swXYBMAFJ2SI81ubG4fqOQfx8ZJOKtokF\/T3NpQ2HCC59DXHRvJsrhMhVI8\n+            qP5srSlK34O+FbEI\/3IdDMh7w906dZAYSw6EVmOpH8nhw8U6YdhnQgsE8JI1V1O8\n+            ZaBjaP1BKV\/QmSQTLG+R9nlkwUJnSnJcNDkUxM7PWMB0vK9FWMl795EeB6ptCTjy\n+            7iuzwajFldY16ENC\/eoB3CSyEa0vwoHPd+WREMerxUvwyG1IC5vidkcdydYDzumM\n+            \/as+n8+3A3k1YFSepEUPp7M\/uRacRLTSX7nEV\/SXkc09oD6slglYE8EFEyzNpOY+\n+            SSKM0j2KHzeFbxQtk7kNsJ+Cr4kljGOquAR6gMA2yTV+ogRvjcY1TwxSlfNCu0F9\n+            PP6wsf0zYiwp4Uy72S4TY8ZevUUEt1EjKblnDjLhssZ6VOfxpV+Ln56gToyjpwXm\n+            KjxeY3N0r7eutt3qYSzeKPAaIC16pONHItJ90\/m4mJTQGf1dTXEZ7+NyO7oQTLi7\n+            CYHgdN46\/iANqq6tgmzEXyRNv0Ma+rNO+994JHTS\/VcRj2RiFJNO2Zy6OwA+jWej\n+            g29vGfxBkQzlFj7jrpnrhNUU63YeY2hOpW+XkdLdSqxuYWi5SMgX91oiKssOjNwD\n+            zEr+j2cVfho2O3+u\/58XK5iRNnfFod0IXp7kwiBSwa9YGTEWZz3NO\/xfNLhV3MbH\n+            eIVknp5x9D1K6g9Lcsp+2gV4uhPTGmWNLQYKmmb\/ae0b55l6L7HScj04+b+r4Y+O\n+            ezzakG5Om16ULI6uspYHDr\/TZJR6lAzJeL7Wazd0nm1dzXvoxJREDiuEzs\/vuYwL\n+            7fs8QeM1nSzXGX++cgxIqmxrZGXB7mPjVpwq3HREkTcLf3gm\/gt3odGdZBAdAyuR\n+            gQa0LS73N0flYB\/kulDyPt5SHwMagX0VKUpDci6DeHhLbbDPG6norpEdkgG5zpzD\n+            AZxvXCfLmNomFEtkIlp8kysw92Hnii1Zodi4PsY0Si9t1H52VwbQC\/SnmmqSbDup\n+            HYEsjyx5erF5Zwnl0WhWd4KTUp8ChtAVw7U5lhlkKjM+nlk9bj9TU5lCCOnmozKF\n+            HX9lJSKpKLkX4n4tbUITff4uv6b7HGeybAJUUoaF9+vb4xWmjqotp2noqfQtPmAA\n+            fHEzCSaywAEtg+rU5P0e2HLM0ZciAdKwJ\/NUWsLTDNeLwddA\/sy8b8KgRGxuMOrF\n+            H1ppCYqi1EfyCFtOTkuSzMJpIdLeR4UYzQkM4meuotJ62lf9iLSXbYn7hDzcz0mn\n+            bKJnnmgBv6f7AxiW+1BilwS5kjk2u13ThTERIcrfsRmV5ZtzA0z2ftA6uBOGdkjQ\n+            JYKAh+lJqa\/Ra5XXLZmx7coleqwTL\/t6Bwmu1anA\/wX7Dyu\/KECe7XtfWAG+lkzt\n+            AZ4ct4UdOFHxApBnThn\/sAizAcSs9kGiuxQhbh1pyr9Ste8idJaw8weZqFXRF\/rT\n+            dEpvozUD6nmLUt3X7lQmYJ2\/zT8ME7Fk1sBR9+1KEZcZpxLjiNMoQCCB\/xNUtVTS\n+            wjev7TsVHEuo6fS964SZowZuJrvGnorwid7HFzHR3FKeqxfvc3RzTA\/kdUlMg4Nr\n+            3TSgO5vImRRxYGG\/uY7G5hw+1EOO3K8lJDxkcIa56nAYsNmooLAM7LAKveJJjWnC\n+            M2EBp3LL5PVxUj9RvQWILN81i4ScwUCqH68iQjoShRzg4z\/UiXWklZ+lxf5BjJOQ\n+            gZGrbnQbd7\/gLL1pjueVxGbWFWGeZEE4LG6sAYNO6atzzqgLviNceNqRvXm2+C+J\n+            l4XWhwDTk+Z1wiJNa3oa0hMgSVZ5ra7XAWe1CGZxOlMQnbe299gTBOzf2Dsxmx7y\n+            SDBrRa0p593Mhj2sVgSLXWnqF1AR92FMAKhqhjzeGHKokyh4uax+GsW9pJl7cgZP\n+            DNdfTIFOA03hGsuQE89+qSa05+qs4HDHuiGI760uQx4SI9Rd0FxNhAPC5FzuZBPs\n+            vnUn6HPkVcTmEKYYOarMC9VtJIPnjymLZqR46y9VjLr8qGvoR7rrAsWyFsjNiP6k\n+            3ySbCeZwogcDq6wksKkavEpWRmAUQroQvs\/TCZOIAFHQf1agWpN556jmvv7j8i+q\n+            EGOY93BgBuQum+HvidJcJy8RqVCVxYfXE3MihN6dvTxyF7BoniHY6w\/2lmg=\n+            -----END PRIVATE KEY-----\"\"\";\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/BadPrivateKeys.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @summary check key reading compatibility\n+ * @run main\/othervm SeedOrExpanded\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.FixedSecureRandom;\n+import jdk.test.lib.security.SeededSecureRandom;\n+\n+import javax.crypto.KEM;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+\n+public class SeedOrExpanded {\n+\n+    static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"mlkem\", \"ML-KEM-768\");\n+        test(\"mldsa\", \"ML-DSA-65\");\n+    }\n+\n+    static void test(String type, String alg) throws Exception {\n+\n+        var seed = RAND.nBytes(alg.contains(\"ML-KEM\") ? 64 : 32);\n+        var g = KeyPairGenerator.getInstance(alg);\n+\n+        \/\/ Generation\n+\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kp = g.generateKeyPair();\n+        var pk = kp.getPublic();\n+        var kDefault = kp.getPrivate();\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"seed\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kSeed = g.generateKeyPair().getPrivate();\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"expandedkey\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kExpanded = g.generateKeyPair().getPrivate();\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"both\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kBoth = g.generateKeyPair().getPrivate();\n+\n+        Asserts.assertTrue(kExpanded.getEncoded().length > kSeed.getEncoded().length);\n+        Asserts.assertTrue(kBoth.getEncoded().length > kExpanded.getEncoded().length);\n+        Asserts.assertEqualsByteArray(kSeed.getEncoded(), kDefault.getEncoded());\n+\n+        test(alg, pk, kSeed);\n+        test(alg, pk, kExpanded);\n+        test(alg, pk, kBoth);\n+\n+        var kf = KeyFactory.getInstance(alg);\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"seed\");\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kBoth)).getEncoded(),\n+                kSeed.getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kSeed)).getEncoded(),\n+                kSeed.getEncoded());\n+        Asserts.assertThrows(InvalidKeyException.class, () -> kf.translateKey(kExpanded));\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"expandedkey\");\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kBoth)).getEncoded(),\n+                kExpanded.getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kSeed)).getEncoded(),\n+                kExpanded.getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kExpanded)).getEncoded(),\n+                kExpanded.getEncoded());\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"both\");\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kBoth)).getEncoded(),\n+                kBoth.getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kSeed)).getEncoded(),\n+                kBoth.getEncoded());\n+        Asserts.assertThrows(InvalidKeyException.class, () -> kf.translateKey(kExpanded));\n+    }\n+\n+    static PrivateKey test(String alg, PublicKey pk, Key k) throws Exception {\n+        var sk = (PrivateKey) k;\n+        if (alg.contains(\"ML-KEM\")) {\n+            var kem = KEM.getInstance(\"ML-KEM\");\n+            var e = kem.newEncapsulator(pk, RAND);\n+            var enc = e.encapsulate();\n+            var k1 = kem.newDecapsulator(sk).decapsulate(enc.encapsulation());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), enc.key().getEncoded());\n+        } else {\n+            var s = Signature.getInstance(\"ML-DSA\");\n+            var rnd = RAND.nBytes(32); \/\/ randomness for signature generation\n+            var msg = RAND.nBytes(20);\n+            s.initSign(sk, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig1 = s.sign();\n+            s.initVerify(pk);\n+            s.update(msg);\n+            Asserts.assertTrue(s.verify(sig1));\n+        }\n+        return sk;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/SeedOrExpanded.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,9 @@\n+        String patchPath = System.getProperty(\"test.patch.path\");\n+        if (patchPath != null) {\n+            try (var subs = Files.newDirectoryStream(Path.of(patchPath))) {\n+                for (var sub : subs) {\n+                    var name = sub.getFileName();\n+                    cmd.add(\"--patch-module=\" + name + \"=\" + sub);\n+                }\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/Proc.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}