{"files":[{"patch":"@@ -149,2 +149,6 @@\n-                if (parts[0] != null) Arrays.fill(parts[0], (byte)0);\n-                if (parts[1] != null) Arrays.fill(parts[1], (byte)0);\n+                if (parts[0] != null) {\n+                    Arrays.fill(parts[0], (byte)0);\n+                }\n+                if (parts[1] != null) {\n+                    Arrays.fill(parts[1], (byte)0);\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -571,0 +571,8 @@\n+    private static int[][] deepClone(int[][] array) {\n+        int[][] clone = new int[array.length][];\n+        for (int i = 0; i < array.length; i++) {\n+            clone[i] = array[i].clone();\n+        }\n+        return clone;\n+    }\n+\n@@ -572,1 +580,1 @@\n-        \/\/Sample A\n+        \/\/ Sample A\n@@ -575,2 +583,5 @@\n-        \/\/Compute t and tr\n-        mlDsaVectorNtt(sk.s1); \/\/s1 now in NTT domain\n+        \/\/ Compute t and tr\n+        \/\/ make a copy of sk.s1 and modify it. Although we can also\n+        \/\/ take it out of NTT domain later, it was modified for a while.\n+        var s1 = deepClone(sk.s1);\n+        mlDsaVectorNtt(s1); \/\/s1 now in NTT domain\n@@ -578,2 +589,1 @@\n-        matrixVectorPointwiseMultiply(As1, keygenA, sk.s1);\n-        mlDsaVectorInverseNtt(sk.s1); \/\/take s1 out of NTT domain\n+        matrixVectorPointwiseMultiply(As1, keygenA, s1);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -174,2 +174,6 @@\n-                if (parts[0] != null) Arrays.fill(parts[0], (byte)0);\n-                if (parts[1] != null) Arrays.fill(parts[1], (byte)0);\n+                if (parts[0] != null) {\n+                    Arrays.fill(parts[0], (byte)0);\n+                }\n+                if (parts[1] != null) {\n+                    Arrays.fill(parts[1], (byte)0);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -495,1 +495,3 @@\n-        if (prop == null) prop = \"seed\";\n+        if (prop == null) {\n+            prop = \"seed\";\n+        }\n@@ -504,1 +506,3 @@\n-                if (seed == null) return null;\n+                if (seed == null) {\n+                    return null;\n+                }\n@@ -511,1 +515,3 @@\n-                if (expanded == null) expanded = expand.apply(pname, seed);\n+                if (expanded == null) {\n+                    expanded = expand.apply(pname, seed);\n+                }\n@@ -518,2 +524,6 @@\n-                if (seed == null) return null;\n-                if (expanded == null) expanded = expand.apply(pname, seed);\n+                if (seed == null) {\n+                    return null;\n+                }\n+                if (expanded == null) {\n+                    expanded = expand.apply(pname, seed);\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1554,1 +1554,1 @@\n-# The privateKey field for newly generated ML-KEM private keys in PKCS #8\n+# The privateKey field for newly created ML-KEM private keys in PKCS #8\n@@ -1556,2 +1556,3 @@\n-# draft-ietf-lamps-kyber-certificates specifies three formats for an ML-KEM\n-# private key: a 64-octet seed, an (expanded) private key, or both.\n+# The draft-ietf-lamps-kyber-certificates specification defines three formats\n+# for an ML-KEM private key: a 64-byte seed, an expanded private key,\n+# or a sequence containing both.\n@@ -1559,2 +1560,2 @@\n-# This values can be \"seed\", \"expandedKey\", or \"both\" (case-insensitive).\n-# The default value is \"seed\".\n+# Valid values for this property are \"seed\", \"expandedKey\", and \"both\"\n+# (case-insensitive). The default is \"seed\".\n@@ -1562,2 +1563,3 @@\n-# When a new keypair is generated, its private key encoding will be determined\n-# by this property.\n+# This property determines the encoding format used when a new keypair is\n+# generated using a KeyPairGenerator, as well as the output of the translateKey\n+# method on an existing key using a KeyFactory.\n@@ -1575,1 +1577,1 @@\n-# The privateKey field for newly generated ML-DSA private keys in PKCS #8\n+# The privateKey field for newly created ML-DSA private keys in PKCS #8\n@@ -1577,2 +1579,3 @@\n-# draft-ietf-lamps-dilithium-certificates specifies three formats for an ML-DSA\n-# private key: a 32-octet seed, an (expanded) private key, or both.\n+# The draft-ietf-lamps-dilithium-certificates specification defines three formats\n+# for an ML-DSA private key: a 32-byte seed, an expanded private key,\n+# or a sequence containing both.\n@@ -1580,2 +1583,2 @@\n-# When a new keypair is generated, its private key encoding will be determined\n-# by this property.\n+# Valid values for this property are \"seed\", \"expandedKey\", and \"both\"\n+# (case-insensitive). The default is \"seed\".\n@@ -1583,2 +1586,3 @@\n-# This values can be \"seed\", \"expandedKey\", or \"both\" (case-insensitive).\n-# The default value is \"seed\".\n+# This property determines the encoding format used when a new keypair is\n+# generated using a KeyPairGenerator, as well as the output of the translateKey\n+# method on an existing key using a KeyFactory.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"}]}