{"files":[{"patch":"@@ -501,1 +501,1 @@\n-    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d, byte[] kem_z) {\n+    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d_z) {\n@@ -511,1 +511,2 @@\n-        var kPkeKeyPair = generateK_PkeKeyPair(kem_d);\n+        \/\/The 1st 32-byte `d` is used in K-PKE key pair generation\n+        var kPkeKeyPair = generateK_PkeKeyPair(kem_d_z);\n@@ -530,1 +531,2 @@\n-        System.arraycopy(kem_z, 0, decapsKey,\n+        \/\/ The 2nd 32-byte `z` is copied into decapsKey\n+        System.arraycopy(kem_d_z, 32, decapsKey,\n@@ -538,0 +540,6 @@\n+    public byte[] privKeyToPubKey(byte[] decapsKey) {\n+        int pkLen = (mlKem_k * ML_KEM_N * 12) \/ 8 + 32 \/* rho *\/;\n+        int skLen = (mlKem_k * ML_KEM_N * 12) \/ 8;\n+        return Arrays.copyOfRange(decapsKey, skLen, skLen + pkLen);\n+    }\n+\n@@ -651,1 +659,2 @@\n-        mlKemG.update(seed);\n+        \/\/ Note: only the 1st 32-byte in the seed is used\n+        mlKemG.update(seed, 0, 32);\n@@ -655,0 +664,1 @@\n+        mlKemG.reset();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n@@ -32,0 +33,2 @@\n+import sun.security.util.KeyChoices;\n+import sun.security.x509.NamedX509Key;\n@@ -40,0 +43,14 @@\n+    private static final int SEED_LEN = 64;\n+\n+    public static byte[] seedToExpanded(String pname, byte[] seed) {\n+        return new ML_KEM(pname).generateKemKeyPair(seed)\n+                .decapsulationKey()\n+                .keyBytes();\n+    }\n+\n+    public static NamedX509Key privKeyToPubKey(NamedPKCS8Key npk) {\n+        return new NamedX509Key(npk.getAlgorithm(),\n+                npk.getParams().getName(),\n+                new ML_KEM(npk.getParams().getName()).privKeyToPubKey(npk.getExpanded()));\n+    }\n+\n@@ -53,2 +70,2 @@\n-        protected byte[][] implGenerateKeyPair(String name, SecureRandom random) {\n-            byte[] seed = new byte[32];\n+        protected byte[][] implGenerateKeyPair(String pname, SecureRandom random) {\n+            byte[] seed = new byte[SEED_LEN];\n@@ -57,2 +74,0 @@\n-            byte[] z = new byte[32];\n-            r.nextBytes(z);\n@@ -60,1 +75,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -62,0 +77,3 @@\n+            kp = mlKem.generateKemKeyPair(seed);\n+            var expanded = kp.decapsulationKey().keyBytes();\n+\n@@ -63,1 +81,7 @@\n-                kp = mlKem.generateKemKeyPair(seed, z);\n+                return new byte[][]{\n+                        kp.encapsulationKey().keyBytes(),\n+                        KeyChoices.writeToChoice(\n+                                KeyChoices.getPreferred(\"mlkem\"),\n+                                seed, expanded),\n+                        expanded\n+                };\n@@ -65,2 +89,1 @@\n-                Arrays.fill(seed, (byte)0);\n-                Arrays.fill(z, (byte)0);\n+                Arrays.fill(seed, (byte) 0);\n@@ -68,4 +91,0 @@\n-            return new byte[][] {\n-                    kp.encapsulationKey().keyBytes(),\n-                    kp.decapsulationKey().keyBytes()\n-            };\n@@ -97,2 +116,33 @@\n-        public KF(String name) {\n-            super(\"ML-KEM\", name);\n+        public KF(String pname) {\n+            super(\"ML-KEM\", pname);\n+        }\n+\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            return KeyChoices.choiceToExpanded(pname, SEED_LEN, input,\n+                    ML_KEM_Impls::seedToExpanded);\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            var nk = toNamedKey(key);\n+            if (nk instanceof NamedPKCS8Key npk) {\n+                var type = KeyChoices.getPreferred(\"mlkem\");\n+                if (KeyChoices.typeOfChoice(npk.getRawBytes()) != type) {\n+                    var encoding = KeyChoices.choiceToChoice(\n+                            type,\n+                            npk.getParams().getName(),\n+                            SEED_LEN, npk.getRawBytes(),\n+                            ML_KEM_Impls::seedToExpanded);\n+                    nk = NamedPKCS8Key.internalCreate(\n+                            npk.getAlgorithm(),\n+                            npk.getParams().getName(),\n+                            encoding,\n+                            npk.getExpanded().clone());\n+                    if (npk != key) { \/\/ npk is neither input or output\n+                        npk.destroy();\n+                    }\n+                }\n+            }\n+            return nk;\n@@ -124,1 +174,1 @@\n-        protected byte[][] implEncapsulate(String name, byte[] encapsulationKey,\n+        protected byte[][] implEncapsulate(String pname, byte[] encapsulationKey,\n@@ -131,2 +181,2 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n-            ML_KEM.ML_KEM_EncapsulateResult mlKemEncapsulateResult = null;\n+            ML_KEM mlKem = new ML_KEM(pname);\n+            ML_KEM.ML_KEM_EncapsulateResult mlKemEncapsulateResult;\n@@ -148,1 +198,1 @@\n-        protected byte[] implDecapsulate(String name, byte[] decapsulationKey,\n+        protected byte[] implDecapsulate(String pname, byte[] decapsulationKey,\n@@ -152,1 +202,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -159,1 +209,1 @@\n-        protected int implSecretSize(String name) {\n+        protected int implSecretSize(String pname) {\n@@ -164,2 +214,2 @@\n-        protected int implEncapsulationSize(String name) {\n-            ML_KEM mlKem = new ML_KEM(name);\n+        protected int implEncapsulationSize(String pname) {\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -170,1 +220,1 @@\n-        protected Object implCheckPublicKey(String name, byte[] pk)\n+        protected Object implCheckPublicKey(String pname, byte[] pk)\n@@ -173,1 +223,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -178,1 +228,1 @@\n-        protected Object implCheckPrivateKey(String name, byte[] sk)\n+        protected Object implCheckPrivateKey(String pname, byte[] sk)\n@@ -181,1 +231,1 @@\n-            ML_KEM mlKem = new ML_KEM(name);\n+            ML_KEM mlKem = new ML_KEM(pname);\n@@ -186,1 +236,1 @@\n-            super(\"ML-KEM\", \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n+            super(\"ML-KEM\", new KF());\n@@ -189,2 +239,2 @@\n-        public K(String name) {\n-            super(\"ML-KEM\", name);\n+        public K(String pname) {\n+            super(\"ML-KEM\", new KF(pname));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":80,"deletions":30,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerValue;\n@@ -32,1 +30,0 @@\n-import javax.security.auth.DestroyFailedException;\n@@ -42,0 +39,1 @@\n+import java.util.Objects;\n@@ -53,0 +51,20 @@\n+\/\/\/ Besides the existing [PKCS8Key#privKeyMaterial] field, this class optionally\n+\/\/\/ supports an expanded format stored in [#expanded]. While `privKeyMaterial`\n+\/\/\/ always represents the format used for encoding, `expanded` is always used\n+\/\/\/ in computations. The expanded format must be self-sufficient for\n+\/\/\/ cryptographic computations without requiring the encoding format.\n+\/\/\/\n+\/\/\/ 1. If only `privKeyMaterial` is present, it's also the expanded format.\n+\/\/\/ 2. If both `privKeyMaterial` and `expanded` are available, `privKeyMaterial`\n+\/\/\/    is the encoding format, and `expanded` is the expanded format.\n+\/\/\/\n+\/\/\/ If the two formats are the same, only `privKeyMaterial` is included, and\n+\/\/\/ `expanded` must be `null`. Some implementations might be tempted to put the\n+\/\/\/ same value into `privKeyMaterial` and `expanded`. However, problems can\n+\/\/\/ arise if they happen to be the same object. To avoid ambiguity, always set\n+\/\/\/ `expanded` to `null`.\n+\/\/\/\n+\/\/\/ A `NamedPKCS8Key`, when created, must include `expanded` if required, its\n+\/\/\/ `privKeyMaterial` must have already been validated for internal consistency.\n+\/\/\/ For example, seed and expanded key should match.\n+\/\/\/\n@@ -60,1 +78,1 @@\n-    private final byte[] rawBytes;\n+    private final transient byte[] expanded;\n@@ -64,3 +82,7 @@\n-    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n-    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n-    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes) {\n+    \/\/\/ Creates a `NamedPKCS8Key` from raw components.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param encoded raw key bytes, not null\n+    \/\/\/ @param expanded expanded key format, can be `null`.\n+    private NamedPKCS8Key(String fname, String pname, byte[] encoded, byte[] expanded) {\n@@ -69,0 +91,2 @@\n+        this.expanded = expanded;\n+        this.privKeyMaterial = Objects.requireNonNull(encoded);\n@@ -74,1 +98,1 @@\n-        this.rawBytes = rawBytes;\n+    }\n@@ -76,6 +100,13 @@\n-        DerValue val = new DerValue(DerValue.tag_OctetString, rawBytes);\n-        try {\n-            this.privKeyMaterial = val.toByteArray();\n-        } finally {\n-            val.clear();\n-        }\n+    \/\/\/ Creates a `NamedPKCS8Key` from raw components.\n+    \/\/\/\n+    \/\/\/ `encoded` and `expanded` won't be cloned, caller must relinquish\n+    \/\/\/ ownership. This caller must ensure `encoded` and `expanded` match\n+    \/\/\/ each other and `encoded` is valid and internally-consistent.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param encoded raw key bytes, not null\n+    \/\/\/ @param expanded expanded key format, can be `null`.\n+    public static NamedPKCS8Key internalCreate(String fname, String pname,\n+            byte[] encoded, byte[] expanded) {\n+        return new NamedPKCS8Key(fname, pname, encoded, expanded);\n@@ -84,2 +115,13 @@\n-    \/\/\/ Ctor from family name, and PKCS #8 bytes\n-    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+    \/\/\/ Creates a `NamedPKCS8Key` from family name and PKCS #8 encoding.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param encoded PKCS #8 encoding. It is copied so caller can modify\n+    \/\/\/     it after the method call.\n+    \/\/\/ @param expander a function that is able to calculate the expanded\n+    \/\/\/     format from the encoding format inside `encoded`. If it recognizes\n+    \/\/\/     the input already in expanded format, it must return `null`.\n+    \/\/\/     This argument must be `null` if the algorithm's expanded format\n+    \/\/\/     is always the same as its encoding format. Whatever the case, the\n+    \/\/\/     ownership of the result is fully granted to this object.\n+    public NamedPKCS8Key(String fname, byte[] encoded, Expander expander)\n+            throws InvalidKeyException {\n@@ -88,8 +130,6 @@\n-        try {\n-            paramSpec = new NamedParameterSpec(algid.getName());\n-            if (algid.getEncodedParams() != null) {\n-                throw new InvalidKeyException(\"algorithm identifier has params\");\n-            }\n-            rawBytes = new DerInputStream(privKeyMaterial).getOctetString();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        this.expanded = expander == null\n+                ? null\n+                : expander.expand(algid.getName(), this.privKeyMaterial);\n+        paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.getEncodedParams() != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n@@ -107,1 +147,1 @@\n-    \/\/\/ the content or keep a reference.\n+    \/\/\/ the content or pass the reference to untrusted application code.\n@@ -109,1 +149,7 @@\n-        return rawBytes;\n+        return privKeyMaterial;\n+    }\n+\n+    \/\/\/ Returns the reference to the key in expanded format. Caller must not\n+    \/\/\/ modify the content or pass the reference to untrusted application code.\n+    public byte[] getExpanded() {\n+        return expanded == null ? privKeyMaterial : expanded;\n@@ -130,2 +176,1 @@\n-    public void destroy() throws DestroyFailedException {\n-        Arrays.fill(rawBytes, (byte)0);\n+    public void destroy() {\n@@ -133,0 +178,3 @@\n+        if (expanded != null) {\n+            Arrays.fill(expanded, (byte)0);\n+        }\n@@ -143,0 +191,12 @@\n+\n+    \/\/\/ Expands from encoding format to expanded format.\n+    public interface Expander {\n+        \/\/\/ The expand method\n+        \/\/\/\n+        \/\/\/ @param pname parameter set name\n+        \/\/\/ @param input input encoding\n+        \/\/\/ @return the expanded key, `null` if `input` is already in expanded\n+        \/\/\/ @throws InvalidKeyException if `input` is invalid, for example,\n+        \/\/\/         wrong encoding, or internal inconsistency\n+        byte[] expand(String pname, byte[] input) throws InvalidKeyException;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":88,"deletions":28,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -571,0 +571,48 @@\n+    private static int[][] deepClone(int[][] array) {\n+        int[][] clone = new int[array.length][];\n+        for (int i = 0; i < array.length; i++) {\n+            clone[i] = array[i].clone();\n+        }\n+        return clone;\n+    }\n+\n+    \/\/ This is similar to the generateKeyPairInternal method. Instead of\n+    \/\/ generating from a seed, it uses stored fields inside the private key\n+    \/\/ to calculate the public key. It performs several checks during the\n+    \/\/ calculation to make sure the private key is a valid one. Otherwise,\n+    \/\/ an IllegalArgumentException is thrown.\n+    public ML_DSA_PublicKey privKeyToPubKey(ML_DSA_PrivateKey sk) {\n+        \/\/ Sample A\n+        int[][][] keygenA = generateA(sk.rho); \/\/A is in NTT domain\n+\n+        \/\/ Compute t and tr\n+        \/\/ make a copy of sk.s1 and modify it. Although we can also\n+        \/\/ take it out of NTT domain later, it was modified for a while.\n+        var s1 = deepClone(sk.s1);\n+        mlDsaVectorNtt(s1); \/\/s1 now in NTT domain\n+        int[][] As1 = integerMatrixAlloc(mlDsa_k, ML_DSA_N);\n+        matrixVectorPointwiseMultiply(As1, keygenA, s1);\n+\n+        mlDsaVectorInverseNtt(As1);\n+        int[][] t = vectorAddPos(As1, sk.s2);\n+        int[][] t0 = integerMatrixAlloc(mlDsa_k, ML_DSA_N);\n+        int[][] t1 = integerMatrixAlloc(mlDsa_k, ML_DSA_N);\n+        power2Round(t, t0, t1);\n+        if (!Arrays.deepEquals(t0, sk.t0)) {\n+            throw new IllegalArgumentException(\"t0 does not patch\");\n+        }\n+\n+        var crHash = new SHAKE256(TR_LEN);\n+\n+        ML_DSA_PublicKey pk = new ML_DSA_PublicKey(sk.rho, t1);\n+        byte[] publicKeyBytes = pkEncode(pk);\n+        crHash.update(publicKeyBytes);\n+        byte[] tr = crHash.digest();\n+        if (!Arrays.equals(tr, sk.tr)) {\n+            throw new IllegalArgumentException(\"tr does not patch\");\n+        }\n+\n+        \/\/Encode PK\n+        return new ML_DSA_PublicKey(sk.rho, t1);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.util.KeyChoices;\n+import sun.security.x509.NamedX509Key;\n+\n@@ -35,0 +39,19 @@\n+    private static final int SEED_LEN = 32;\n+\n+    public static byte[] seedToExpanded(String pname, byte[] seed) {\n+        var impl = new ML_DSA(name2int(pname));\n+        var sk = impl.generateKeyPairInternal(seed).privateKey();\n+        try {\n+            return impl.skEncode(sk);\n+        } finally {\n+            sk.destroy();\n+        }\n+    }\n+\n+    public static NamedX509Key privKeyToPubKey(NamedPKCS8Key npk) {\n+        var dsa = new ML_DSA(name2int(npk.getParams().getName()));\n+        return new NamedX509Key(npk.getAlgorithm(),\n+                npk.getParams().getName(),\n+                dsa.pkEncode(dsa.privKeyToPubKey(dsa.skDecode(npk.getExpanded()))));\n+    }\n+\n@@ -46,2 +69,2 @@\n-    static int name2int(String name) {\n-        if (name.endsWith(\"44\")) {\n+    static int name2int(String pname) {\n+        if (pname.endsWith(\"44\")) {\n@@ -49,1 +72,1 @@\n-        } else if (name.endsWith(\"65\")) {\n+        } else if (pname.endsWith(\"65\")) {\n@@ -51,1 +74,1 @@\n-        } else if (name.endsWith(\"87\")) {\n+        } else if (pname.endsWith(\"87\")) {\n@@ -55,1 +78,1 @@\n-            throw new ProviderException(\"Unknown name \" + name);\n+            throw new ProviderException(\"Unknown name \" + pname);\n@@ -72,3 +95,3 @@\n-        protected byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n-            byte[] seed = new byte[32];\n-            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+        protected byte[][] implGenerateKeyPair(String pname, SecureRandom random) {\n+            byte[] seed = new byte[SEED_LEN];\n+            var r = random != null ? random : JCAUtil.getDefSecureRandom();\n@@ -76,1 +99,2 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n@@ -78,0 +102,2 @@\n+            var expanded = mlDsa.skEncode(kp.privateKey());\n+\n@@ -81,1 +107,4 @@\n-                        mlDsa.skEncode(kp.privateKey())\n+                        KeyChoices.writeToChoice(\n+                                KeyChoices.getPreferred(\"mldsa\"),\n+                                seed, expanded),\n+                        expanded\n@@ -85,1 +114,1 @@\n-                Arrays.fill(seed, (byte)0);\n+                Arrays.fill(seed, (byte) 0);\n@@ -112,2 +141,33 @@\n-        public KF(String name) {\n-            super(\"ML-DSA\", name);\n+        public KF(String pname) {\n+            super(\"ML-DSA\", pname);\n+        }\n+\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            return KeyChoices.choiceToExpanded(pname, SEED_LEN, input,\n+                    ML_DSA_Impls::seedToExpanded);\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            var nk = toNamedKey(key);\n+            if (nk instanceof NamedPKCS8Key npk) {\n+                var type = KeyChoices.getPreferred(\"mldsa\");\n+                if (KeyChoices.typeOfChoice(npk.getRawBytes()) != type) {\n+                    var encoding = KeyChoices.choiceToChoice(\n+                            type,\n+                            npk.getParams().getName(),\n+                            SEED_LEN, npk.getRawBytes(),\n+                            ML_DSA_Impls::seedToExpanded);\n+                    nk = NamedPKCS8Key.internalCreate(\n+                            npk.getAlgorithm(),\n+                            npk.getParams().getName(),\n+                            encoding,\n+                            npk.getExpanded().clone());\n+                    if (npk != key) { \/\/ npk is neither input or output\n+                        npk.destroy();\n+                    }\n+                }\n+            }\n+            return nk;\n@@ -137,1 +197,1 @@\n-            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+            super(\"ML-DSA\", new KF());\n@@ -139,2 +199,2 @@\n-        public SIG(String name) {\n-            super(\"ML-DSA\", name);\n+        public SIG(String pname) {\n+            super(\"ML-DSA\", new KF(pname));\n@@ -144,1 +204,1 @@\n-        protected byte[] implSign(String name, byte[] skBytes,\n+        protected byte[] implSign(String pname, byte[] skBytes,\n@@ -146,1 +206,1 @@\n-            var size = name2int(name);\n+            var size = name2int(pname);\n@@ -163,1 +223,1 @@\n-        protected boolean implVerify(String name, byte[] pkBytes,\n+        protected boolean implVerify(String pname, byte[] pkBytes,\n@@ -166,1 +226,1 @@\n-            var size = name2int(name);\n+            var size = name2int(pname);\n@@ -179,1 +239,1 @@\n-        protected Object implCheckPublicKey(String name, byte[] pk)\n+        protected Object implCheckPublicKey(String pname, byte[] pk)\n@@ -182,1 +242,1 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n@@ -187,1 +247,1 @@\n-        protected Object implCheckPrivateKey(String name, byte[] sk)\n+        protected Object implCheckPrivateKey(String pname, byte[] sk)\n@@ -190,1 +250,1 @@\n-            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA mlDsa = new ML_DSA(name2int(pname));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":85,"deletions":25,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -53,1 +52,1 @@\n-    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+    private final NamedKeyFactory fac;\n@@ -58,2 +57,3 @@\n-    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n-    protected NamedKEM(String fname, String... pnames) {\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n+    protected NamedKEM(String fname, NamedKeyFactory fac) {\n@@ -63,3 +63,0 @@\n-        if (pnames == null || pnames.length == 0) {\n-            throw new AssertionError(\"pnames cannot be null or empty\");\n-        }\n@@ -67,1 +64,1 @@\n-        this.pnames = pnames;\n+        this.fac = fac;\n@@ -79,2 +76,1 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n+        var nk = (NamedX509Key) fac.toNamedKey(publicKey);\n@@ -95,3 +91,2 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n-        var sk = nk.getRawBytes();\n+        var nk = (NamedPKCS8Key) fac.toNamedKey(privateKey);\n+        var sk = nk.getExpanded();\n@@ -104,1 +99,1 @@\n-    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+    private record KeyConsumerImpl(NamedKEM kem, String pname, int sslen,\n@@ -113,1 +108,1 @@\n-            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            var ss = kem.implDecapsulate(pname, key, k2, encapsulation);\n@@ -124,1 +119,1 @@\n-            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            var enc = kem.implEncapsulate(pname, key, k2, sr);\n@@ -149,2 +144,2 @@\n-        String name = nps.getName();\n-        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+        String pname = nps.getName();\n+        return new KeyConsumerImpl(kem, pname, kem.implSecretSize(pname), kem.implEncapsulationSize(pname),\n@@ -156,1 +151,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -162,1 +157,1 @@\n-    protected abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+    protected abstract byte[][] implEncapsulate(String pname, byte[] pk, Object pk2, SecureRandom sr);\n@@ -166,1 +161,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -173,1 +168,1 @@\n-    protected abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+    protected abstract byte[] implDecapsulate(String pname, byte[] sk, Object sk2, byte[] encap)\n@@ -178,1 +173,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -181,1 +176,1 @@\n-    protected abstract int implSecretSize(String name);\n+    protected abstract int implSecretSize(String pname);\n@@ -185,1 +180,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -188,1 +183,1 @@\n-    protected abstract int implEncapsulationSize(String name);\n+    protected abstract int implEncapsulationSize(String pname);\n@@ -199,1 +194,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -203,1 +198,1 @@\n-    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+    protected Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n@@ -216,1 +211,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -220,1 +215,1 @@\n-    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+    protected Object implCheckPrivateKey(String pname, byte[] sk) throws InvalidKeyException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -61,1 +60,1 @@\n-public class NamedKeyFactory extends KeyFactorySpi {\n+public abstract class NamedKeyFactory extends KeyFactorySpi {\n@@ -81,3 +80,3 @@\n-    private String checkName(String name) throws InvalidKeyException  {\n-        for (var pname : pnames) {\n-            if (pname.equalsIgnoreCase(name)) {\n+    private String checkName(String pname) throws InvalidKeyException {\n+        for (var n : pnames) {\n+            if (n.equalsIgnoreCase(pname)) {\n@@ -85,1 +84,1 @@\n-                return pname;\n+                return n;\n@@ -88,1 +87,1 @@\n-        throw new InvalidKeyException(\"Unsupported parameter set name: \" + name);\n+        throw new InvalidKeyException(\"Unsupported parameter set name: \" + pname);\n@@ -94,5 +93,7 @@\n-        if (keySpec instanceof X509EncodedKeySpec xspec) {\n-            try {\n-                return fromX509(xspec.getEncoded());\n-            } catch (InvalidKeyException e) {\n-                throw new InvalidKeySpecException(e);\n+        return switch (keySpec) {\n+            case X509EncodedKeySpec xspec -> {\n+                try {\n+                    yield fromX509(xspec.getEncoded());\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n@@ -100,5 +101,6 @@\n-        } else if (keySpec instanceof RawKeySpec rks) {\n-            if (pnames.length == 1) {\n-                return new NamedX509Key(fname, pnames[0], rks.getKeyArr());\n-            } else {\n-                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            case RawKeySpec rks -> {\n+                if (pnames.length == 1) {\n+                    yield new NamedX509Key(fname, pnames[0], rks.getKeyArr());\n+                } else {\n+                    throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+                }\n@@ -106,6 +108,6 @@\n-        } else if (keySpec instanceof EncodedKeySpec espec\n-                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n-            if (pnames.length == 1) {\n-                return new NamedX509Key(fname, pnames[0], espec.getEncoded());\n-            } else {\n-                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            case EncodedKeySpec espec when espec.getFormat().equalsIgnoreCase(\"RAW\") -> {\n+                if (pnames.length == 1) {\n+                    yield new NamedX509Key(fname, pnames[0], espec.getEncoded());\n+                } else {\n+                    throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+                }\n@@ -113,3 +115,6 @@\n-        } else {\n-            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n-        }\n+            case null -> throw new InvalidKeySpecException(\n+                    \"keySpec must not be null\");\n+            default ->\n+                    throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                            \" not supported.\");\n+        };\n@@ -121,12 +126,3 @@\n-        if (keySpec instanceof PKCS8EncodedKeySpec pspec) {\n-            var bytes = pspec.getEncoded();\n-            try {\n-                return fromPKCS8(bytes);\n-            } catch (InvalidKeyException e) {\n-                throw new InvalidKeySpecException(e);\n-            } finally {\n-                Arrays.fill(bytes, (byte) 0);\n-            }\n-        } else if (keySpec instanceof RawKeySpec rks) {\n-            if (pnames.length == 1) {\n-                var bytes = rks.getKeyArr();\n+        return switch (keySpec) {\n+            case PKCS8EncodedKeySpec pspec -> {\n+                var bytes = pspec.getEncoded();\n@@ -134,1 +130,3 @@\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                    yield fromPKCS8(bytes);\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n@@ -138,2 +136,0 @@\n-            } else {\n-                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n@@ -141,8 +137,10 @@\n-        } else if (keySpec instanceof EncodedKeySpec espec\n-                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n-            if (pnames.length == 1) {\n-                var bytes = espec.getEncoded();\n-                try {\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n-                } finally {\n-                    Arrays.fill(bytes, (byte) 0);\n+            case RawKeySpec rks -> {\n+                if (pnames.length == 1) {\n+                    var raw = rks.getKeyArr();\n+                    try {\n+                        yield fromRaw(pnames[0], raw);\n+                    } catch (InvalidKeyException e) {\n+                        throw new InvalidKeySpecException(\"Invalid key input\", e);\n+                    }\n+                } else {\n+                    throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n@@ -150,2 +148,0 @@\n-            } else {\n-                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n@@ -153,3 +149,24 @@\n-        } else {\n-            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n-        }\n+            case EncodedKeySpec espec when espec.getFormat().equalsIgnoreCase(\"RAW\") -> {\n+                if (pnames.length == 1) {\n+                    var raw = espec.getEncoded();\n+                    try {\n+                        yield fromRaw(pnames[0], raw);\n+                    } catch (InvalidKeyException e) {\n+                        throw new InvalidKeySpecException(\"Invalid key input\", e);\n+                    }\n+                } else {\n+                    throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+                }\n+            }\n+            case null -> throw new InvalidKeySpecException(\n+                    \"keySpec must not be null\");\n+            default ->\n+                    throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                            \" not supported.\");\n+        };\n+    }\n+\n+    private PrivateKey fromRaw(String pname, byte[] raw)\n+            throws InvalidKeyException {\n+        return NamedPKCS8Key.internalCreate(\n+                fname, pname, raw, implExpand(pname, raw));\n@@ -159,2 +176,2 @@\n-            throws InvalidKeyException, InvalidKeySpecException {\n-        var k = new NamedPKCS8Key(fname, bytes);\n+            throws InvalidKeyException {\n+        var k = new NamedPKCS8Key(fname, bytes, this::implExpand);\n@@ -166,1 +183,1 @@\n-            throws InvalidKeyException, InvalidKeySpecException {\n+            throws InvalidKeyException {\n@@ -187,1 +204,1 @@\n-            key = engineTranslateKey(key);\n+            key = toNamedKey(key);\n@@ -228,0 +245,6 @@\n+        \/\/ The base toNamedKey only make sure key is translated into a NamedKey.\n+        \/\/ the key material is still the same as the input.\n+        return toNamedKey(key);\n+    }\n+\n+    protected Key toNamedKey(Key key) throws InvalidKeyException {\n@@ -245,1 +268,1 @@\n-                String name;\n+                String pname;\n@@ -251,1 +274,1 @@\n-                    name = checkName(nps.getName());\n+                    pname = checkName(nps.getName());\n@@ -255,1 +278,1 @@\n-                            name = pnames[0];\n+                            pname = pnames[0];\n@@ -260,1 +283,1 @@\n-                        name = checkName(kAlg);\n+                        pname = checkName(kAlg);\n@@ -263,0 +286,1 @@\n+                var raw = key.getEncoded();\n@@ -264,2 +288,2 @@\n-                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n-                        : new NamedX509Key(fname, name, key.getEncoded());\n+                        ? fromRaw(pname, raw)\n+                        : new NamedX509Key(fname, pname, raw);\n@@ -273,2 +297,0 @@\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n@@ -279,5 +301,1 @@\n-            try {\n-                return fromX509(key.getEncoded());\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n-            }\n+            return fromX509(key.getEncoded());\n@@ -288,0 +306,13 @@\n+\n+    \/\/\/ User-defined function to generate the expanded format of\n+    \/\/\/ a [NamedPKCS8Key] from its encoding format.\n+    \/\/\/\n+    \/\/\/ This method is called when the key factory is constructing a private\n+    \/\/\/ key. The ownership of the result is fully granted to the caller.\n+    \/\/\/\n+    \/\/\/ @param pname the parameter set name\n+    \/\/\/ @param input the encoding, could be any format\n+    \/\/\/ @return the expanded key, not null\n+    \/\/\/ @throws InvalidKeyException if `input` is invalid\n+    protected abstract byte[] implExpand(String pname, byte[] input)\n+            throws InvalidKeyException;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":103,"deletions":72,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -55,6 +54,6 @@\n-\/\/\/ An implementation must include a zero-argument public constructor that\n-\/\/\/ calls `super(fname, pnames)`, where `fname` is the family name of the\n-\/\/\/ algorithm and `pnames` are its supported parameter set names. `pnames`\n-\/\/\/ must contain at least one element. For an implementation of\n-\/\/\/ `NamedKeyPairGenerator`, the first element becomes its default parameter\n-\/\/\/ set, i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ A `NamedKeyPairGenerator` or `NamedKeyFactory` implementation must include\n+\/\/\/ a zero-argument public constructor that calls `super(fname, pnames)`, where\n+\/\/\/ `fname` is the family name of the algorithm and `pnames` are its supported\n+\/\/\/ parameter set names. `pnames` must contain at least one element. For an\n+\/\/\/ implementation of `NamedKeyPairGenerator`, the first element becomes its\n+\/\/\/ default parameter set, i.e. the parameter set used by generated keys unless\n@@ -64,0 +63,6 @@\n+\/\/\/ A `NamedKEM` or `NamedSignature` implementation must include a zero-argument\n+\/\/\/ public constructor that calls `super(fname, factory)`, where `fname` is the\n+\/\/\/ family name of the algorithm and `factory` is the `NamedKeyFactory` object\n+\/\/\/ that is used to translate foreign keys. `factory` only recognizes\n+\/\/\/ parameter sets supported by this implementation.\n+\/\/\/\n@@ -72,2 +77,2 @@\n-\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n-\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key in\n+\/\/\/ any format. For key generation, the only copy is the one returned in the\n@@ -87,0 +92,28 @@\n+\/\/\/ The private key, represented as a byte array when used in `NamedKEM` or\n+\/\/\/ `NamedSignature`, is referred to as its expanded format. For some\n+\/\/\/ algorithms, this format may differ from the encoding format used in a\n+\/\/\/ PKCS #8 file (i.e. the [NamedPKCS8Key#key] field). For example,\n+\/\/\/ [FIPS 204](https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.204.pdf)\n+\/\/\/ Table 2 defines the ML-DSA-65 private key as a 4032-byte array, which is\n+\/\/\/ used in the ML-DSA.Sign function in Algorithm 2, representing the\n+\/\/\/ expanded format. However, in\n+\/\/\/ [draft-ietf-lamps-dilithium-certificates-08](https:\/\/datatracker.ietf.org\/doc\/html\/draft-ietf-lamps-dilithium-certificates#name-private-key-format),\n+\/\/\/ a private key can be encoded into a CHOICE of three formats, none in the\n+\/\/\/ same as the FIPS 204 format. The choices are defined in\n+\/\/\/ [sun.security.util.KeyChoices]. A `NamedKeyPairGenerator` implementation\n+\/\/\/ should return both the expanded key and a preferred encoding in its\n+\/\/\/  [#implGenerateKeyPair] method.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` must override the `implExpand` method to derive\n+\/\/\/ the expanded format from an encoding format, or return `null` if there\n+\/\/\/ is no difference.\n+\/\/\/\n+\/\/\/ Implementations may support multiple encoding formats.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` must not modify the encoding when generating a key\n+\/\/\/ from a `KeySpec` object, ensuring that when re-encoded, the key retains\n+\/\/\/ its original encoding format.\n+\/\/\/\n+\/\/\/ A `NamedKeyFactory` can choose a different encoding format when\n+\/\/\/ `translateKey` is called.\n+\/\/\/\n@@ -108,1 +141,1 @@\n-    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+    private final String[] pnames; \/\/ allowed parameter set names (at least one)\n@@ -110,1 +143,1 @@\n-    protected String name; \/\/ init as\n+    protected String pname; \/\/ parameter set name, if can be determined\n@@ -129,5 +162,5 @@\n-    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n-        for (var pname : pnames) {\n-            if (pname.equalsIgnoreCase(name)) {\n-                \/\/ return the stored standard name\n-                return pname;\n+    private String checkName(String pname) throws InvalidAlgorithmParameterException {\n+        for (var n : pnames) {\n+            if (n.equalsIgnoreCase(pname)) {\n+                \/\/ return the stored standard pname\n+                return n;\n@@ -137,1 +170,1 @@\n-                \"Unsupported parameter set name: \" + name);\n+                \"Unsupported parameter set name: \" + pname);\n@@ -144,1 +177,1 @@\n-            name = checkName(spec.getName());\n+            pname = checkName(spec.getName());\n@@ -164,4 +197,5 @@\n-        String pname = name != null ? name : pnames[0];\n-        var keys = implGenerateKeyPair(pname, secureRandom);\n-        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n-                new NamedPKCS8Key(fname, pname, keys[1]));\n+        String tmpName = pname != null ? pname : pnames[0];\n+        var keys = implGenerateKeyPair(tmpName, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, tmpName, keys[0]),\n+                NamedPKCS8Key.internalCreate(fname, tmpName, keys[1],\n+                        keys.length == 2 ? null : keys[2]));\n@@ -174,1 +208,4 @@\n-    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @return the public key, the private key in its encoding format, and\n+    \/\/\/         the private key in its expanded format (in this order) in\n+    \/\/\/         raw bytes. If the expanded format of the private key is the\n+    \/\/\/         same as its encoding format, the 3rd element must be omitted.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":61,"deletions":24,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.Objects;\n@@ -53,1 +52,1 @@\n-    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+    private final NamedKeyFactory fac;\n@@ -58,1 +57,1 @@\n-    private String name;\n+    private String pname;\n@@ -68,2 +67,3 @@\n-    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n-    protected NamedSignature(String fname, String... pnames) {\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n+    protected NamedSignature(String fname, NamedKeyFactory fac) {\n@@ -73,3 +73,0 @@\n-        if (pnames == null || pnames.length == 0) {\n-            throw new AssertionError(\"pnames cannot be null or empty\");\n-        }\n@@ -77,1 +74,1 @@\n-        this.pnames = pnames;\n+        this.fac = fac;\n@@ -83,3 +80,2 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n-        name = nk.getParams().getName();\n+        var nk = (NamedX509Key) fac.toNamedKey(publicKey);\n+        pname = nk.getParams().getName();\n@@ -87,1 +83,1 @@\n-        pk2 = implCheckPublicKey(name, pubKey);\n+        pk2 = implCheckPublicKey(pname, pubKey);\n@@ -95,5 +91,4 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n-        name = nk.getParams().getName();\n-        secKey = nk.getRawBytes();\n-        sk2 = implCheckPrivateKey(name, secKey);\n+        var nk = (NamedPKCS8Key) fac.toNamedKey(privateKey);\n+        pname = nk.getParams().getName();\n+        secKey = nk.getExpanded();\n+        sk2 = implCheckPrivateKey(pname, secKey);\n@@ -119,1 +114,1 @@\n-            return implSign(name, secKey, sk2, msg, appRandom);\n+            return implSign(pname, secKey, sk2, msg, appRandom);\n@@ -130,1 +125,1 @@\n-            return implVerify(name, pubKey, pk2, msg, sig);\n+            return implVerify(pname, pubKey, pk2, msg, sig);\n@@ -137,1 +132,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @Deprecated\n@@ -144,1 +139,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @Deprecated\n@@ -165,1 +160,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -173,1 +168,1 @@\n-    protected abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+    protected abstract byte[] implSign(String pname, byte[] sk, Object sk2,\n@@ -178,1 +173,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -186,1 +181,1 @@\n-    protected abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+    protected abstract boolean implVerify(String pname, byte[] pk, Object pk2,\n@@ -198,1 +193,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -202,1 +197,1 @@\n-    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+    protected Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n@@ -215,1 +210,1 @@\n-    \/\/\/ @param name parameter name\n+    \/\/\/ @param pname parameter name\n@@ -219,1 +214,1 @@\n-    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+    protected Object implCheckPrivateKey(String pname, byte[] sk) throws InvalidKeyException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.*;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * The content of an ML-KEM or ML-DSA private key is defined as a CHOICE\n+ * among three different representations. For example:\n+ * <pre>\n+ *  ML-KEM-1024-PrivateKey ::= CHOICE {\n+ *       seed [0] OCTET STRING (SIZE (64)),\n+ *       expandedKey OCTET STRING (SIZE (3168)),\n+ *       both SEQUENCE {\n+ *           seed OCTET STRING (SIZE (64)),\n+ *           expandedKey OCTET STRING (SIZE (3168))\n+ *           }\n+ *       }\n+ * <\/pre>\n+ * This class supports reading, writing, and convert between them.\n+ *\/\n+public final class KeyChoices {\n+\n+    public enum Type { SEED, EXPANDED_KEY, BOTH }\n+\n+    private record Choice(Type type, byte[] seed, byte[] expanded) {}\n+\n+    \/**\n+     * Gets the preferred choice type for an algorithm, defined as an\n+     * overridable security property \"jdk.<name>.pkcs8.encoding\".\n+     *\n+     * @param name \"mlkem\" or \"mldsa\".\n+     * @throws IllegalArgumentException if property is invalid value\n+     * @return the type\n+     *\/\n+    public static Type getPreferred(String name) {\n+        var prop = SecurityProperties.getOverridableProperty(\n+                \"jdk.\" + name + \".pkcs8.encoding\");\n+        if (prop == null) {\n+            return Type.SEED;\n+        }\n+        return switch (prop.toLowerCase(Locale.ROOT)) {\n+            case \"seed\" -> Type.SEED;\n+            case \"expandedkey\" -> Type.EXPANDED_KEY;\n+            case \"both\" -> Type.BOTH;\n+            default -> throw new IllegalArgumentException(\"Unknown format: \" + prop);\n+        };\n+    }\n+\n+    \/**\n+     * Writes one of the ML-KEM or ML-DSA private key formats.\n+     * <p>\n+     * This method does not check the length of the inputs or whether\n+     * they match each other. The caller must make sure `seed` and\/or\n+     * `expanded` are provided if `type` requires any of them.\n+     *\n+     * @param type     preferred output choice type\n+     * @param seed     the seed, could be null\n+     * @param expanded the expanded key, could be null\n+     * @return         one of the choices\n+     *\/\n+    public static byte[] writeToChoice(Type type, byte[] seed, byte[] expanded) {\n+        byte[] skOctets;\n+        \/\/ Ensures using one-byte len in DER\n+        assert seed == null || seed.length < 128;\n+        \/\/ Ensures using two-byte len in DER\n+        assert expanded == null || expanded.length > 256 && expanded.length < 60000;\n+\n+        return switch (type) {\n+            case SEED -> {\n+                assert seed != null;\n+                skOctets = new byte[seed.length + 2];\n+                skOctets[0] = (byte)0x80;\n+                skOctets[1] = (byte) seed.length;\n+                System.arraycopy(seed, 0, skOctets, 2, seed.length);\n+                yield skOctets;\n+            }\n+            case EXPANDED_KEY -> {\n+                assert expanded != null;\n+                skOctets = new byte[expanded.length + 4];\n+                skOctets[0] = 0x04;\n+                writeShortLength(skOctets, 1, expanded.length);\n+                System.arraycopy(expanded, 0, skOctets, 4, expanded.length);\n+                yield skOctets;\n+            }\n+            case BOTH -> {\n+                assert seed != null;\n+                assert expanded != null;\n+                skOctets = new byte[10 + seed.length + expanded.length];\n+                skOctets[0] = 0x30;\n+                writeShortLength(skOctets, 1, 6 + seed.length + expanded.length);\n+                skOctets[4] = 0x04;\n+                skOctets[5] = (byte)seed.length;\n+                System.arraycopy(seed, 0, skOctets, 6, seed.length);\n+                skOctets[6 + seed.length] = 0x04;\n+                writeShortLength(skOctets, 7 + seed.length, expanded.length);\n+                System.arraycopy(expanded, 0, skOctets, 10 + seed.length, expanded.length);\n+                yield skOctets;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Gets the type of input.\n+     *\n+     * @param input input bytes\n+     * @return the type\n+     * @throws InvalidKeyException if input is invalid\n+     *\/\n+    public static Type typeOfChoice(byte[] input) throws InvalidKeyException {\n+        if (input.length < 1) {\n+            throw new InvalidKeyException(\"Empty key\");\n+        }\n+        return switch (input[0]) {\n+            case (byte) 0x80 -> Type.SEED;\n+            case 0x04 -> Type.EXPANDED_KEY;\n+            case 0x30 -> Type.BOTH;\n+            default -> throw new InvalidKeyException(\"Wrong tag: \" + input[0]);\n+        };\n+    }\n+\n+    \/**\n+     * Splits one of the ML-KEM or ML-DSA private key formats into\n+     * seed and expandedKey, if exists.\n+     *\n+     * @param seedLen correct seed length\n+     * @param input input bytes\n+     * @return a {@code Choice} object. Byte arrays inside are newly allocated\n+     * @throws InvalidKeyException if input is invalid\n+     *\/\n+    private static Choice readFromChoice(int seedLen, byte[] input)\n+            throws InvalidKeyException {\n+        if (input.length < seedLen + 2) {\n+            throw new InvalidKeyException(\"Too short\");\n+        }\n+        return switch (input[0]) {\n+            case (byte) 0x80 -> {\n+                \/\/ 80 SEED_LEN <SEED_LEN of seed>\n+                if (input[1] != seedLen && input.length != seedLen + 2) {\n+                    throw new InvalidKeyException(\"Invalid seed\");\n+                }\n+                yield new Choice(Type.SEED,\n+                        Arrays.copyOfRange(input, 2, seedLen + 2), null);\n+            }\n+            case 0x04 -> {\n+                \/\/ 04 82 nn nn <nn of expandedKey>\n+                if (readShortLength(input, 1) != input.length - 4) {\n+                    throw new InvalidKeyException(\"Invalid expandedKey\");\n+                }\n+                yield new Choice(Type.EXPANDED_KEY,\n+                        null, Arrays.copyOfRange(input, 4, input.length));\n+            }\n+            case 0x30 -> {\n+                \/\/ 30 82 mm mm 04 SEED_LEN <SEED_LEN of seed> 04 82 nn nn <nn of expandedKey>\n+                if (input.length < 6 + seedLen + 4) {\n+                    throw new InvalidKeyException(\"Too short\");\n+                }\n+                if (readShortLength(input, 1) != input.length - 4\n+                        || input[4] != 0x04\n+                        || input[5] != (byte)seedLen\n+                        || input[seedLen + 6] != 0x04\n+                        || readShortLength(input, seedLen + 7)\n+                                != input.length - 10 - seedLen) {\n+                    throw new InvalidKeyException(\"Invalid both\");\n+                }\n+                yield new Choice(Type.BOTH,\n+                        Arrays.copyOfRange(input, 6, 6 + seedLen),\n+                        Arrays.copyOfRange(input, seedLen + 10, input.length));\n+            }\n+            default -> throw new InvalidKeyException(\"Wrong tag: \" + input[0]);\n+        };\n+    }\n+\n+    \/**\n+     * Reads from any encoding and write to the specified type.\n+     *\n+     * @param type preferred output choice type\n+     * @param pname parameter set name\n+     * @param seedLen seed length\n+     * @param input the input encoding\n+     * @param expander function to calculate expanded from seed, could be null\n+     *                 if there is already expanded in input\n+     * @return the preferred encoding\n+     * @throws InvalidKeyException if input is invalid or does not have enough\n+     *                             information to generate the output\n+     *\/\n+    public static byte[] choiceToChoice(Type type, String pname,\n+            int seedLen, byte[] input,\n+            BiFunction<String, byte[], byte[]> expander)\n+            throws InvalidKeyException {\n+        var choice = readFromChoice(seedLen, input);\n+        try {\n+            if (type != Type.EXPANDED_KEY && choice.type == Type.EXPANDED_KEY) {\n+                throw new InvalidKeyException(\n+                        \"key contains not enough info to translate\");\n+            }\n+            var expanded = (choice.expanded == null && type != Type.SEED)\n+                    ? expander.apply(pname, choice.seed)\n+                    : choice.expanded;\n+            return writeToChoice(type, choice.seed, expanded);\n+        } finally {\n+            if (choice.seed != null) {\n+                Arrays.fill(choice.seed, (byte) 0);\n+            }\n+            if (choice.expanded != null) {\n+                Arrays.fill(choice.expanded, (byte) 0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reads from any choice of encoding and return the expanded format.\n+     *\n+     * @param pname parameter set name\n+     * @param seedLen seed length\n+     * @param input input encoding\n+     * @param expander function to calculate expanded from seed, could be null\n+     *                 if there is already expanded in input\n+     * @return the expanded key\n+     * @throws InvalidKeyException if input is invalid\n+     *\/\n+    public static byte[] choiceToExpanded(String pname,\n+            int seedLen, byte[] input,\n+            BiFunction<String, byte[], byte[]> expander)\n+            throws InvalidKeyException {\n+        var choice = readFromChoice(seedLen, input);\n+        if (choice.type == Type.BOTH) {\n+            var calculated = expander.apply(pname, choice.seed);\n+            if (!Arrays.equals(choice.expanded, calculated)) {\n+                throw new InvalidKeyException(\"seed and expandedKey do not match\");\n+            }\n+            Arrays.fill(calculated, (byte)0);\n+        }\n+        try {\n+            if (choice.expanded != null) {\n+                return choice.expanded;\n+            }\n+            return expander.apply(pname, choice.seed);\n+        } finally {\n+            if (choice.seed != null) {\n+                Arrays.fill(choice.seed, (byte)0);\n+            }\n+        }\n+    }\n+\n+    \/\/ Reads a 2 bytes length from DER encoding\n+    private static int readShortLength(byte[] input, int from)\n+            throws InvalidKeyException {\n+        if (input[from] != (byte)0x82) {\n+            throw new InvalidKeyException(\"Unexpected length\");\n+        }\n+        return ((input[from + 1] & 0xff) << 8) + (input[from + 2] & 0xff);\n+    }\n+\n+    \/\/ Writes a 2 bytes length to DER encoding\n+    private static void writeShortLength(byte[] input, int from, int value) {\n+        input[from] = (byte)0x82;\n+        input[from + 1] = (byte) (value >> 8);\n+        input[from + 2] = (byte) (value);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyChoices.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,2 @@\n-    \/\/\/ Ctor from family name, and X.509 bytes\n+    \/\/\/ Ctor from family name, and X.509 bytes. Input byte array\n+    \/\/\/ is copied. Caller can modify it after the method call.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1577,0 +1577,24 @@\n+\n+#\n+# Newly created ML-KEM and ML-DSA private key formats in PKCS #8\n+#\n+# The draft-ietf-lamps-kyber-certificates and draft-ietf-lamps-dilithium-certificates\n+# specifications define three formats for a private key: a seed (64 bytes for ML-KEM,\n+# 32 bytes for ML-DSA), an expanded private key, or a sequence containing both.\n+#\n+# Valid values for these properties are \"seed\", \"expandedKey\", and \"both\"\n+# (case-insensitive). The default is \"seed\".\n+#\n+# These properties determine the encoding format used when a new keypair is generated\n+# using a KeyPairGenerator, as well as the output of the translateKey method on an\n+# existing key using a ML-KEM or ML-DSA KeyFactory.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# Note: These properties are currently used by the SunJCE (for ML-KEM) and SUN\n+# (for ML-DSA) providers in the JDK Reference implementation. They are not guaranteed\n+# to be supported by other SE implementations or third-party security providers.\n+#\n+#jdk.mlkem.pkcs8.encoding = seed\n+#jdk.mldsa.pkcs8.encoding = seed\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8340327\n- * @modules java.base\/sun.security.ec.ed\n- *          java.base\/sun.security.ec.point\n- *          java.base\/sun.security.jca\n- *          java.base\/sun.security.provider\n- * @library \/test\/lib\n- *\/\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import sun.security.ec.ed.EdDSAOperations;\n-import sun.security.ec.ed.EdDSAParameters;\n-import sun.security.ec.point.AffinePoint;\n-import sun.security.jca.JCAUtil;\n-import sun.security.provider.NamedKeyFactory;\n-import sun.security.provider.NamedKeyPairGenerator;\n-import sun.security.provider.NamedSignature;\n-\n-import java.security.*;\n-import java.security.spec.EdDSAParameterSpec;\n-import java.security.spec.NamedParameterSpec;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public class NamedEdDSA {\n-\n-    public static class ProviderImpl extends Provider {\n-        public ProviderImpl() {\n-            super(\"Named\", \"0\", \"\");\n-            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n-            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n-            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n-            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n-            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n-            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n-            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n-            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n-            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n-        }\n-    }\n-\n-    public static class EdDSASignature extends NamedSignature {\n-        public EdDSASignature() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSASignature(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSASignature {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSASignature {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-\n-        @Override\n-        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n-            return getOps(name).sign(plain, sk, msg);\n-        }\n-\n-        @Override\n-        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n-            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n-        }\n-\n-        @Override\n-        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n-            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n-        }\n-    }\n-\n-    public static class EdDSAKeyFactory extends NamedKeyFactory {\n-        public EdDSAKeyFactory() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSAKeyFactory(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSAKeyFactory {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSAKeyFactory {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-    }\n-\n-    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n-        public EdDSAKeyPairGenerator() {\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n-        }\n-\n-        protected EdDSAKeyPairGenerator(String pname) {\n-            super(\"EdDSA\", pname);\n-        }\n-\n-        public static class Ed25519 extends EdDSAKeyPairGenerator {\n-            public Ed25519() {\n-                super(\"Ed25519\");\n-            }\n-        }\n-\n-        public static class Ed448 extends EdDSAKeyPairGenerator {\n-            public Ed448() {\n-                super(\"Ed448\");\n-            }\n-        }\n-\n-        @Override\n-        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n-            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n-            var op = getOps(pname);\n-            var sk = op.generatePrivate(sr);\n-            var point = op.computePublic(sk);\n-            byte[] encodedPoint = point.getY().toByteArray();\n-            reverse(encodedPoint);\n-            \/\/ array may be too large or too small, depending on the value\n-            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n-            \/\/ set the high-order bit of the encoded point\n-            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n-            encodedPoint[encodedPoint.length - 1] |= msb;\n-            return new byte[][] { encodedPoint, sk };\n-        }\n-\n-        private static void swap(byte[] arr, int i, int j) {\n-            byte tmp = arr[i];\n-            arr[i] = arr[j];\n-            arr[j] = tmp;\n-        }\n-\n-        private static void reverse(byte [] arr) {\n-            int i = 0;\n-            int j = arr.length - 1;\n-\n-            while (i < j) {\n-                swap(arr, i, j);\n-                i++;\n-                j--;\n-            }\n-        }\n-    }\n-\n-    private static EdDSAOperations getOps(String pname) {\n-        var op = switch (pname) {\n-            case \"Ed25519\" -> e2;\n-            case \"Ed448\" -> e4;\n-            default -> throw new AssertionError(\"unknown pname \" + pname);\n-        };\n-        return op;\n-    }\n-\n-    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n-    static final EdDSAOperations e2, e4;\n-    static {\n-        try {\n-            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n-            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n-        for (var p1 : ps) {\n-            for (var p2 : ps) {\n-                for (var p3 : ps) {\n-                    test(p1, p2, p3);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n-        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n-        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n-        g.initialize(NamedParameterSpec.ED448);\n-        var kp = g.generateKeyPair();\n-        var s1 = Signature.getInstance(\"EdDSA\", p2);\n-        var s2 = Signature.getInstance(\"EdDSA\", p3);\n-        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n-        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n-        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n-        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n-        \/\/ sign and verify twice to make sure the key is intact\n-        s1.initSign(sk);\n-        var sig1 = s1.sign();\n-        s1.initSign(sk);\n-        var sig2 = s1.sign();\n-        \/\/ EdDSA signing is deterministic\n-        Asserts.assertEqualsByteArray(sig1, sig2);\n-        s2.initVerify(pk);\n-        Asserts.assertTrue(s2.verify(sig1));\n-        s2.initVerify(pk);\n-        Asserts.assertTrue(s2.verify(sig2));\n-        \/\/ No parameters defined\n-        s1.setParameter(null);\n-        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n-                InvalidAlgorithmParameterException.class);\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8340327\n- * @modules java.base\/sun.security.x509\n- *          java.base\/sun.security.pkcs\n- *          java.base\/sun.security.provider\n- *          java.base\/sun.security.util\n- * @library \/test\/lib\n- *\/\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.security.SeededSecureRandom;\n-import sun.security.pkcs.NamedPKCS8Key;\n-import sun.security.provider.NamedKeyFactory;\n-import sun.security.provider.NamedKeyPairGenerator;\n-import sun.security.util.RawKeySpec;\n-import sun.security.x509.NamedX509Key;\n-\n-import java.security.*;\n-import java.security.spec.*;\n-\n-public class NamedKeyFactoryTest {\n-\n-    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n-\n-    public static void main(String[] args) throws Exception {\n-        Security.addProvider(new ProviderImpl());\n-\n-        var g = KeyPairGenerator.getInstance(\"sHA\");\n-        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n-        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n-        var kf = KeyFactory.getInstance(\"ShA\");\n-        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n-        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-\n-        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n-                InvalidAlgorithmParameterException.class); \/\/ diff pname\n-        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n-\n-        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n-        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-\n-        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n-        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n-        checkKey(pk, \"sHa\", \"ShA-256\");\n-        checkKey(sk, \"sHa\", \"SHa-256\");\n-\n-        Asserts.assertEquals(\"X.509\", pk.getFormat());\n-        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n-\n-        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n-        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-\n-        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n-        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KeySpec\n-        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n-        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n-        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n-        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n-        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var pk1 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk2 = new PublicKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk3 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n-\n-        var sk1 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk2 = new PrivateKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk3 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n-    }\n-\n-    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n-        checkKey(kp.getPrivate(), algName, toString);\n-        checkKey(kp.getPublic(), algName, toString);\n-    }\n-\n-    static void checkKey(Key k, String algName, String pname) {\n-        Asserts.assertEquals(algName, k.getAlgorithm());\n-        Asserts.assertTrue(k.toString().contains(pname));\n-        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n-            Asserts.assertEquals(pname, nps.getName());\n-        }\n-    }\n-\n-    \/\/ Provider\n-\n-    public static class ProviderImpl extends Provider {\n-        public ProviderImpl() {\n-            super(\"P\", \"1\", \"...\");\n-            put(\"KeyFactory.SHA\", KF.class.getName());\n-            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n-            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n-            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n-            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n-            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n-        }\n-    }\n-    public static class KF extends NamedKeyFactory {\n-        public KF() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-    }\n-    public static class KF1 extends NamedKeyFactory {\n-        public KF1() {\n-            super(\"SHA\", \"SHA-256\");\n-        }\n-    }\n-    public static class KF2 extends NamedKeyFactory {\n-        public KF2() {\n-            super(\"SHA\", \"SHA-512\");\n-        }\n-    }\n-    public static class KPG extends NamedKeyPairGenerator {\n-        public KPG() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-\n-        public KPG(String pname) {\n-            super(\"SHA\", pname);\n-        }\n-\n-        @Override\n-        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n-            var out = new byte[2][];\n-            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            return out;\n-        }\n-    }\n-    public static class KPG1 extends KPG {\n-        public KPG1() {\n-            super(\"SHA-256\");\n-        }\n-    }\n-    public static class KPG2 extends KPG {\n-        public KPG2() {\n-            super(\"SHA-512\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -40,0 +40,2 @@\n+ *          java.base\/sun.security.util\n+ *          java.base\/com.sun.crypto.provider\n@@ -49,0 +51,2 @@\n+ *          java.base\/sun.security.util\n+ *          java.base\/com.sun.crypto.provider\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import sun.security.util.DerOutputStream;\n@@ -71,1 +72,2 @@\n-                g.initialize(np, new FixedSecureRandom(toByteArray(c.get(\"seed\").asString())));\n+                var seed = toByteArray(c.get(\"seed\").asString());\n+                g.initialize(np, new FixedSecureRandom(seed));\n@@ -74,1 +76,0 @@\n-                var sk = f.getKeySpec(kp.getPrivate(), EncodedKeySpec.class).getEncoded();\n@@ -76,1 +77,2 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()),\n+                        ML_DSA_Impls.seedToExpanded(pname, seed));\n@@ -109,1 +111,1 @@\n-                    public byte[] getEncoded() { return toByteArray(c.get(\"sk\").asString()); }\n+                    public byte[] getEncoded() { return oct(toByteArray(c.get(\"sk\").asString())); }\n@@ -122,0 +124,4 @@\n+    static byte[] oct(byte[] in) {\n+        return new DerOutputStream().putOctetString(in).toByteArray();\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import com.sun.crypto.provider.ML_KEM_Impls;\n@@ -26,0 +27,1 @@\n+import sun.security.util.DerOutputStream;\n@@ -68,2 +70,2 @@\n-                g.initialize(np, new FixedSecureRandom(\n-                        toByteArray(c.get(\"d\").asString()), toByteArray(c.get(\"z\").asString())));\n+                var seed = toByteArray(c.get(\"d\").asString() + c.get(\"z\").asString());\n+                g.initialize(np, new FixedSecureRandom(seed));\n@@ -72,1 +74,0 @@\n-                var sk = f.getKeySpec(kp.getPrivate(), EncodedKeySpec.class).getEncoded();\n@@ -74,1 +75,3 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"dk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(\n+                        toByteArray(c.get(\"dk\").asString()),\n+                        ML_KEM_Impls.seedToExpanded(pname, seed));\n@@ -109,1 +112,1 @@\n-                    public byte[] getEncoded() { return toByteArray(t.get(\"dk\").asString()); }\n+                    public byte[] getEncoded() { return oct(toByteArray(t.get(\"dk\").asString())); }\n@@ -121,0 +124,4 @@\n+\n+    static byte[] oct(byte[] in) {\n+        return new DerOutputStream().putOctetString(in).toByteArray();\n+    }\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327 8347938 8347941\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", new EdDSAKeyFactory());\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", new EdDSAKeyFactory(pname));\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String pname, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) {\n+            return getOps(pname).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String pname, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(pname).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String pname, byte[] pk) throws InvalidKeyException {\n+            return getOps(pname).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input)\n+                throws InvalidKeyException {\n+            try {\n+                return new DerValue(input).getOctetString();\n+            } catch (IOException e) {\n+                throw new InvalidKeyException(e);\n+            }\n+        }\n+\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] {\n+                    encodedPoint,\n+                    new DerOutputStream().putOctetString(sk).toByteArray(),\n+                    sk};\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n+        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n+        \/\/ sign and verify twice to make sure the key is intact\n+        s1.initSign(sk);\n+        var sig1 = s1.sign();\n+        s1.initSign(sk);\n+        var sig2 = s1.sign();\n+        \/\/ EdDSA signing is deterministic\n+        Asserts.assertEqualsByteArray(sig1, sig2);\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig1));\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig2));\n+        \/\/ No parameters defined\n+        s1.setParameter(null);\n+        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedEdDSA.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327 8347938 8347941\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+    private static final byte[] RAW_SK = RAND.nBytes(16);\n+    private static final byte[] RAW_PK = RAND.nBytes(16);\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAW_PK);\n+        var sk = NamedPKCS8Key.internalCreate(\"sHa\", \"SHa-256\", RAW_SK, null);\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+        if (k instanceof NamedPKCS8Key nsk) {\n+            var raw = nsk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_SK, raw.length), raw);\n+        }\n+        if (k instanceof NamedX509Key npk) {\n+            var raw = npk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_PK, raw.length), raw);\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KF(String name) {\n+            super(\"SHA\", name);\n+        }\n+\n+        @Override\n+        protected byte[] implExpand(String pname, byte[] input) throws InvalidKeyException {\n+            return null;\n+        }\n+    }\n+    public static class KF1 extends KF {\n+        public KF1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_PK, 8) : RAW_PK;\n+            out[1] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_SK, 8) : RAW_SK;\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeyFactoryTest.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ * @summary check the Named***Key behavior\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.util.Arrays;\n+\n+public class NamedKeys {\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ This test uses fictional key algorithms SHA and SHA-256,\n+        \/\/ simply because they look like a family name and parameter\n+        \/\/ set name and SHA-256 already have its OID defined.\n+\n+        var r = SeededSecureRandom.one();\n+        var raw = r.nBytes(32);\n+\n+        \/\/ Create a key using raw bytes\n+        var sk = NamedPKCS8Key.internalCreate(\"SHA\", \"SHA-256\", raw, null);\n+        var enc = sk.getEncoded();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(sk.getRawBytes() == sk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(sk.getEncoded() != sk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(sk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        var sk1 = new NamedPKCS8Key(\"SHA\", enc, null);\n+        var sk2 = new NamedPKCS8Key(\"SHA\", enc, null);\n+        var raw1 = sk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != sk2.getRawBytes());\n+        Asserts.assertTrue(sk1.getEncoded() != sk2.getEncoded());\n+\n+        var encCopy = enc.clone(); \/\/ store a copy\n+        Arrays.fill(enc, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, sk1.getEncoded());\n+\n+        \/\/ Same with public key\n+        \/\/ Create a key using raw bytes\n+        raw = r.nBytes(32);\n+        var pk = new NamedX509Key(\"SHA\", \"SHA-256\", raw);\n+        enc = pk.getEncoded().clone();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(pk.getRawBytes() == pk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(pk.getEncoded() != pk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(pk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        var pk1 = new NamedX509Key(\"SHA\", enc);\n+        var pk2 = new NamedX509Key(\"SHA\", enc);\n+        raw1 = pk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != pk2.getRawBytes());\n+        Asserts.assertTrue(pk1.getEncoded() != pk2.getEncoded());\n+\n+        encCopy = enc.clone(); \/\/ store a copy\n+        Arrays.fill(enc, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, pk1.getEncoded());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeys.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @summary check key reading compatibility\n+ * @run main\/othervm SeedOrExpanded\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.FixedSecureRandom;\n+import jdk.test.lib.security.SeededSecureRandom;\n+\n+import javax.crypto.KEM;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+\n+public class SeedOrExpanded {\n+\n+    static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"mlkem\", \"ML-KEM-768\");\n+        test(\"mldsa\", \"ML-DSA-65\");\n+    }\n+\n+    static void test(String type, String alg) throws Exception {\n+\n+        var seed = RAND.nBytes(alg.contains(\"ML-KEM\") ? 64 : 32);\n+        var g = KeyPairGenerator.getInstance(alg);\n+\n+        \/\/ Generation\n+\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kp = g.generateKeyPair();\n+        var pk = kp.getPublic();\n+        var kDefault = kp.getPrivate();\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"seed\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kSeed = g.generateKeyPair().getPrivate();\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"expandedkey\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kExpanded = g.generateKeyPair().getPrivate();\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"both\");\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kBoth = g.generateKeyPair().getPrivate();\n+\n+        Asserts.assertTrue(kExpanded.getEncoded().length > kSeed.getEncoded().length);\n+        Asserts.assertTrue(kBoth.getEncoded().length > kExpanded.getEncoded().length);\n+        Asserts.assertEqualsByteArray(kSeed.getEncoded(), kDefault.getEncoded());\n+\n+        test(alg, pk, kSeed);\n+        test(alg, pk, kExpanded);\n+        test(alg, pk, kBoth);\n+\n+        var kf = KeyFactory.getInstance(alg);\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"seed\");\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kBoth)).getEncoded(),\n+                kSeed.getEncoded());\n+        Asserts.assertTrue(kf.translateKey(kSeed) == kSeed);\n+        Asserts.assertThrows(InvalidKeyException.class, () -> kf.translateKey(kExpanded));\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"expandedkey\");\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kBoth)).getEncoded(),\n+                kExpanded.getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kSeed)).getEncoded(),\n+                kExpanded.getEncoded());\n+        Asserts.assertTrue(kf.translateKey(kExpanded) == kExpanded);\n+\n+        System.setProperty(\"jdk.\" + type + \".pkcs8.encoding\", \"both\");\n+        Asserts.assertTrue(kf.translateKey(kBoth) == kBoth);\n+        Asserts.assertEqualsByteArray(\n+                test(alg, pk, kf.translateKey(kSeed)).getEncoded(),\n+                kBoth.getEncoded());\n+        Asserts.assertThrows(InvalidKeyException.class, () -> kf.translateKey(kExpanded));\n+\n+        \/\/ The following makes sure key is not mistakenly cleaned during\n+        \/\/ translations.\n+        var xk = new PrivateKey() {\n+            public String getAlgorithm() { return alg; }\n+            public String getFormat() { return \"PKCS#8\"; }\n+            public byte[] getEncoded() { return kBoth.getEncoded(); }\n+        };\n+        test(alg, pk, xk);\n+        var xk2 = (PrivateKey) kf.translateKey(xk);\n+        test(alg, pk, xk2);\n+        test(alg, pk, xk);\n+    }\n+\n+    static PrivateKey test(String alg, PublicKey pk, Key k) throws Exception {\n+        var sk = (PrivateKey) k;\n+        if (alg.contains(\"ML-KEM\")) {\n+            var kem = KEM.getInstance(\"ML-KEM\");\n+            var e = kem.newEncapsulator(pk, RAND);\n+            var enc = e.encapsulate();\n+            var k1 = kem.newDecapsulator(sk).decapsulate(enc.encapsulation());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), enc.key().getEncoded());\n+        } else {\n+            var s = Signature.getInstance(\"ML-DSA\");\n+            var rnd = RAND.nBytes(32); \/\/ randomness for signature generation\n+            var msg = RAND.nBytes(20);\n+            s.initSign(sk, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig1 = s.sign();\n+            s.initVerify(pk);\n+            s.update(msg);\n+            Asserts.assertTrue(s.verify(sig1));\n+        }\n+        return sk;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/SeedOrExpanded.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,9 @@\n+        String patchPath = System.getProperty(\"test.patch.path\");\n+        if (patchPath != null) {\n+            try (var subs = Files.newDirectoryStream(Path.of(patchPath))) {\n+                for (var sub : subs) {\n+                    var name = sub.getFileName();\n+                    cmd.add(\"--patch-module=\" + name + \"=\" + sub);\n+                }\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/Proc.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}