{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.security.ProtectionDomain;\n@@ -691,1 +690,0 @@\n-\n@@ -710,2 +708,2 @@\n-        \/\/ exported\/opened via module declaration\/descriptor\n-        if (isStaticallyExportedOrOpen(pn, other, open))\n+        \/\/ exported\/opened via module declaration\/descriptor or CLI options\n+        if (isExplicitlyExportedOrOpened(pn, other, open))\n@@ -715,1 +713,1 @@\n-        if (isReflectivelyExportedOrOpen(pn, other, open))\n+        if (isReflectivelyExportedOrOpened(pn, other, open))\n@@ -726,1 +724,1 @@\n-    private boolean isStaticallyExportedOrOpen(String pn, Module other, boolean open) {\n+    private boolean isExplicitlyExportedOrOpened(String pn, Module other, boolean open) {\n@@ -767,1 +765,1 @@\n-    private boolean isReflectivelyExportedOrOpen(String pn, Module other, boolean open) {\n+    private boolean isReflectivelyExportedOrOpened(String pn, Module other, boolean open) {\n@@ -812,1 +810,1 @@\n-        return isReflectivelyExportedOrOpen(pn, other, false);\n+        return isReflectivelyExportedOrOpened(pn, other, false);\n@@ -820,1 +818,1 @@\n-        return isReflectivelyExportedOrOpen(pn, other, true);\n+        return isReflectivelyExportedOrOpened(pn, other, true);\n@@ -1036,27 +1034,10 @@\n-        \/\/ add package name to exports if absent\n-        Map<String, Boolean> map = ReflectionData.exports\n-            .computeIfAbsent(this, other,\n-                             (m1, m2) -> new ConcurrentHashMap<>());\n-        if (open) {\n-            map.put(pn, Boolean.TRUE);  \/\/ may need to promote from FALSE to TRUE\n-        } else {\n-            map.putIfAbsent(pn, Boolean.FALSE);\n-        }\n-    }\n-\n-    \/**\n-     * Updates a module to open all packages in the given sets to all unnamed\n-     * modules.\n-     *\n-     * @apiNote Used during startup to open packages for illegal access.\n-     *\/\n-    void implAddOpensToAllUnnamed(Set<String> concealedPkgs, Set<String> exportedPkgs) {\n-        if (jdk.internal.misc.VM.isModuleSystemInited()) {\n-            throw new IllegalStateException(\"Module system already initialized\");\n-        }\n-\n-        \/\/ replace this module's openPackages map with a new map that opens\n-        \/\/ the packages to all unnamed modules.\n-        Map<String, Set<Module>> openPackages = this.openPackages;\n-        if (openPackages == null) {\n-            openPackages = HashMap.newHashMap(concealedPkgs.size() + exportedPkgs.size());\n+        if (VM.isBooted()) {\n+            \/\/ add package name to ReflectionData.exports if absent\n+            Map<String, Boolean> map = ReflectionData.exports\n+                .computeIfAbsent(this, other,\n+                                 (m1, m2) -> new ConcurrentHashMap<>());\n+            if (open) {\n+                map.put(pn, Boolean.TRUE);  \/\/ may need to promote from FALSE to TRUE\n+            } else {\n+                map.putIfAbsent(pn, Boolean.FALSE);\n+            }\n@@ -1064,12 +1045,20 @@\n-            openPackages = new HashMap<>(openPackages);\n-        }\n-        implAddOpensToAllUnnamed(concealedPkgs, openPackages);\n-        implAddOpensToAllUnnamed(exportedPkgs, openPackages);\n-        this.openPackages = openPackages;\n-    }\n-\n-    private void implAddOpensToAllUnnamed(Set<String> pkgs, Map<String, Set<Module>> openPackages) {\n-        for (String pn : pkgs) {\n-            Set<Module> prev = openPackages.putIfAbsent(pn, ALL_UNNAMED_MODULE_SET);\n-            if (prev != null) {\n-                prev.add(ALL_UNNAMED_MODULE);\n+            \/\/ export\/open packages during startup (--add-exports and --add-opens)\n+            Map<String, Set<Module>> packageToTargets = (open) ? openPackages : exportedPackages;\n+            if (packageToTargets != null) {\n+                \/\/ copy existing map\n+                packageToTargets = new HashMap<>(packageToTargets);\n+                packageToTargets.compute(pn, (_, values) -> {\n+                    var targets = new HashSet<Module>();\n+                    if (values != null) {\n+                        targets.addAll(values);\n+                    }\n+                    targets.add(other);\n+                    return targets;\n+                });\n+            } else {\n+                packageToTargets = Map.of(pn, Set.of(other));\n+            }\n+            if (open) {\n+                this.openPackages = packageToTargets;\n+            } else {\n+                this.exportedPackages = packageToTargets;\n@@ -1077,3 +1066,0 @@\n-\n-            \/\/ update VM to export the package\n-            addExportsToAllUnnamed0(this, pn);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":38,"deletions":52,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2062,3 +2062,0 @@\n-            public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n-                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -233,5 +233,0 @@\n-    \/**\n-     * Updates module m to open all packages in the given sets.\n-     *\/\n-    void addOpensToAllUnnamed(Module m, Set<String> concealedPkgs, Set<String> exportedPkgs);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}