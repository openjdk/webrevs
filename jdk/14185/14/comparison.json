{"files":[{"patch":"@@ -196,11 +196,1 @@\n-    VM_CI=\"jdk.internal.vm.ci\/share\/classes\"\n-    VM_COMPILER=\"src\/jdk.internal.vm.compiler\/share\/classes\"\n-    if test \"${root#*$VM_CI}\" != \"$root\" || test \"${root#*$VM_COMPILER}\" != \"$root\"; then\n-        for subdir in \"$root\"\/*; do\n-            if [ -d \"$subdir\" ]; then\n-                SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$subdir\"\/src\"$SOURCE_POSTFIX\"\n-            fi\n-        done\n-    else\n-        SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$root\"\"$SOURCE_POSTFIX\"\n-    fi\n+    SOURCES=$SOURCES\" $SOURCE_PREFIX\"\"$root\"\"$SOURCE_POSTFIX\"\n@@ -277,1 +267,1 @@\n-fi\n\\ No newline at end of file\n+fi\n","filename":"bin\/idea.sh","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -688,0 +688,2 @@\n+<li>To install on an apt-based Linux, try running\n+<code>sudo apt-get install     libfontconfig-dev<\/code>.<\/li>\n","filename":"doc\/building.html","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -483,0 +483,2 @@\n+  * To install on an apt-based Linux, try running `sudo apt-get install\n+    libfontconfig-dev`.\n","filename":"doc\/building.md","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,5 @@\n+test-prebuilt-with-exit-code:\n+\t@( cd $(topdir) && \\\n+\t    $(MAKE) --no-print-directory -r -R -I make\/common\/ -f make\/RunTestsPrebuilt.gmk \\\n+\t    test-prebuilt-with-exit-code CUSTOM_MAKE_DIR=$(CUSTOM_MAKE_DIR) TEST=\"$(TEST)\" )\n+\n","filename":"make\/Global.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -298,0 +298,5 @@\n+test-prebuilt-with-exit-code: test-prebuilt\n+\t@if test -f $(MAKESUPPORT_OUTPUTDIR)\/exit-with-error ; then \\\n+\t  exit 1 ; \\\n+\tfi\n+\n","filename":"make\/RunTestsPrebuilt.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-    jdk.incubator.concurrent \\\n","filename":"make\/conf\/docs-modules.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    jdk.incubator.concurrent \\\n","filename":"make\/conf\/module-loader-map.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+JVM_PrintWarningAtDynamicAgentLoad\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+    DISABLED_WARNINGS_clang_aix_DefaultProxySelector.c := deprecated-non-prototype, \\\n+    DISABLED_WARNINGS_clang_aix_NetworkInterface.c := gnu-pointer-arith, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+      DISABLED_WARNINGS_clang_aix := format-nonliteral deprecated-non-prototype, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+      sun\/awt\/screencast \\\n","filename":"make\/modules\/java.desktop\/Java.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+    LIBPIPEWIRE_HEADER_DIRS := \\\n+        $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/libpipewire\/include\n+\n@@ -203,1 +206,1 @@\n-        #\n+        $(LIBPIPEWIRE_HEADER_DIRS)\n@@ -243,0 +246,8 @@\n+        DISABLED_WARNINGS_clang_aix := deprecated-non-prototype, \\\n+        DISABLED_WARNINGS_clang_aix_awt_Taskbar.c := parentheses, \\\n+        DISABLED_WARNINGS_clang_aix_OGLPaints.c := format-nonliteral, \\\n+        DISABLED_WARNINGS_clang_aix_OGLBufImgOps.c := format-nonliteral, \\\n+        DISABLED_WARNINGS_clang_aix_gtk2_interface.c := parentheses logical-op-parentheses, \\\n+        DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses logical-op-parentheses, \\\n+        DISABLED_WARNINGS_clang_aix_sun_awt_X11_GtkFileDialogPeer.c := parentheses, \\\n+        DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n@@ -449,0 +460,1 @@\n+    ifneq ($(TOOLCHAIN_TYPE), clang)\n@@ -450,0 +462,1 @@\n+    endif\n@@ -696,0 +709,14 @@\n+  # The external libpng submitted in the jdk is a reduced version\n+  # which does not contain .png_init_filter_functions_vsx.\n+  # Therefore we need to disable PNG_POWERPC_VSX_OPT explicitly by setting\n+  # it to 0. If this define is not set, it would be automatically set to 2,\n+  # because\n+  #   \"#if defined(__PPC64__) && defined(__ALTIVEC__) && defined(__VSX__)\"\n+  # expands to true. This would results in the fact that\n+  # .png_init_filter_functions_vsx is needed in libpng.\n+  ifeq ($(call isTargetOs, aix), true)\n+    ifeq ($(TOOLCHAIN_TYPE), clang)\n+      LIBSPLASHSCREEN_CFLAGS += -DPNG_POWERPC_VSX_OPT=0\n+    endif\n+  endif\n+\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+    DISABLED_WARNINGS_clang_aix := undef, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include CopyCommon.gmk\n+\n+################################################################################\n+\n+XML_LIB_SRC := $(TOPDIR)\/src\/java.xml\/share\/conf\n+\n+$(CONF_DST_DIR)\/jaxp.properties: $(XML_LIB_SRC)\/jaxp.properties\n+\t$(call install-file)\n+\n+TARGETS := $(CONF_DST_DIR)\/jaxp.properties\n+\n+################################################################################\n","filename":"make\/modules\/java.xml\/Copy.gmk","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+    DISABLED_WARNINGS_clang_aix := missing-braces, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,5 +102,0 @@\n-NSK_GC_LOCK_MALLOC_INCLUDES := \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/gc\/lock\/malloc \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n-\n@@ -182,2 +177,0 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libMallocLocker := $(NSK_GC_LOCK_MALLOC_INCLUDES)\n-\n@@ -877,1 +870,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n@@ -1519,0 +1512,1 @@\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -ljvm -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -15021,36 +15021,0 @@\n-instruct convI2B(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpw $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpw(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct convP2B(iRegINoSp dst, iRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmp  $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmp(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -5515,0 +5515,24 @@\n+\/\/ Combined rule for VectorMaskTrueCount (VectorStoreMask) when the vector element type is not T_BYTE.\n+\n+instruct vstoremask_truecount_neon(iRegINoSp dst, vReg src, immI_gt_1 size, vReg vtmp) %{\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src size)));\n+  effect(TEMP vtmp);\n+  format %{ \"vstoremask_truecount_neon $dst, $src\\t# KILL $vtmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector mask represented as lanes with\n+    \/\/ 0\/-1 as element values.\n+    uint esize = (uint)$size$$constant;\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    Assembler::SIMD_Arrangement arrangement = Assembler::esize2arrangement(esize,\n+                                                                           \/* isQ *\/ length_in_bytes == 16);\n+    if (arrangement == __ T2D || arrangement == __ T2S) {\n+      __ addpv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      __ addv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $vtmp$$FloatRegister, __ B, 0);\n+    __ neg($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3825,0 +3825,24 @@\n+\/\/ Combined rule for VectorMaskTrueCount (VectorStoreMask) when the vector element type is not T_BYTE.\n+\n+instruct vstoremask_truecount_neon(iRegINoSp dst, vReg src, immI_gt_1 size, vReg vtmp) %{\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src size)));\n+  effect(TEMP vtmp);\n+  format %{ \"vstoremask_truecount_neon $dst, $src\\t# KILL $vtmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector mask represented as lanes with\n+    \/\/ 0\/-1 as element values.\n+    uint esize = (uint)$size$$constant;\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    Assembler::SIMD_Arrangement arrangement = Assembler::esize2arrangement(esize,\n+                                                                           \/* isQ *\/ length_in_bytes == 16);\n+    if (arrangement == __ T2D || arrangement == __ T2S) {\n+      __ addpv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      __ addv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $vtmp$$FloatRegister, __ B, 0);\n+    __ neg($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -91,0 +92,2 @@\n+\n+      post_barrier(access, access.resolved_addr(), new_value.result());\n@@ -94,1 +97,8 @@\n-  return BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  LIR_Opr result =  BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), new_value.result());\n+  }\n+\n+  return result;\n@@ -122,0 +132,1 @@\n+    post_barrier(access, access.resolved_addr(), result);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -63,1 +65,1 @@\n-        __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING);\n+        __ mov(rscratch2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n@@ -80,0 +82,7 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                       Register start, Register count, Register tmp, RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n@@ -378,0 +387,22 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  __ lsr(obj, obj, CardTable::card_shift());\n+\n+  assert(CardTable::dirty_card_val() == 0, \"must be\");\n+\n+  __ load_byte_map_base(rscratch1);\n+\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ ldrb(rscratch2, Address(obj, rscratch1));\n+    __ cbz(rscratch2, L_already_dirty);\n+    __ strb(zr, Address(obj, rscratch1));\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ strb(zr, Address(obj, rscratch1));\n+  }\n+}\n+\n@@ -414,0 +445,1 @@\n+    store_check(masm, r3);\n@@ -598,0 +630,31 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register start, Register count, Register scratch, RegSet saved_regs) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ cbz(count, L_done);\n+\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ lea(end, Address(start, count, Address::lsl(LogBytesPerHeapOop)));\n+  __ sub(end, end, BytesPerHeapOop);\n+  __ lsr(start, start, CardTable::card_shift());\n+  __ lsr(end, end, CardTable::card_shift());\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n+\n+  __ load_byte_map_base(scratch);\n+  __ add(start, start, scratch);\n+  __ bind(L_loop);\n+  __ strb(zr, Address(start, count));\n+  __ subs(count, count, 1);\n+  __ br(Assembler::GE, L_loop);\n+  __ bind(L_done);\n+}\n+\n@@ -698,1 +761,7 @@\n-  __ tbz(tmp, ShenandoahHeap::MARKING_BITPOS, done);\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    __ tbz(tmp, ShenandoahHeap::YOUNG_MARKING_BITPOS, done);\n+  } else {\n+    __ mov(rscratch2, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n+    __ tst(tmp, rscratch2);\n+    __ br(Assembler::EQ, done);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -58,0 +59,2 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n@@ -62,0 +65,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register scratch, RegSet saved_regs);\n+\n@@ -77,0 +84,2 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  NativeCall* call = NULL;\n+  NativeCall* call = nullptr;\n@@ -158,1 +158,1 @@\n-    if (nop == NULL) {\n+    if (nop == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7049,0 +7049,165 @@\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src) {\n+    __ ldp(dest0, rscratch1, Address(src, 0));     \/\/ 26 bits\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 26);  \/\/ 26 bits\n+    __ ldp(rscratch1, rscratch2, Address(src, 2 * sizeof (jlong)));\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 52);  \/\/ 12 bits\n+\n+    __ add(dest1, zr, rscratch1, Assembler::LSR, 12);     \/\/ 14 bits\n+    __ add(dest1, dest1, rscratch2, Assembler::LSL, 14);  \/\/ 26 bits\n+    __ ldr(rscratch1, Address(src, 4 * sizeof (jlong)));\n+    __ add(dest1, dest1, rscratch1, Assembler::LSL, 40);  \/\/ 24 bits\n+\n+    if (dest2->is_valid()) {\n+      __ add(dest2, zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ cmp(zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+      __ br(__ EQ, OK);\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register src) {\n+    pack_26(dest0, dest1, noreg, src);\n+  }\n+\n+  \/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+    __ mul(prod_lo, n, m);\n+    __ umulh(prod_hi, n, m);\n+  }\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n, Register m) {\n+    wide_mul(rscratch1, rscratch2, n, m);\n+    __ adds(sum_lo, sum_lo, rscratch1);\n+    __ adc(sum_hi, sum_hi, rscratch2);\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+\n+  \/\/ See https:\/\/loup-vaillant.fr\/tutorials\/poly1305-design for a\n+  \/\/ description of the tricks used to simplify and accelerate this\n+  \/\/ computation.\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    Label here;\n+    __ enter();\n+    RegSet callee_saved = RegSet::range(r19, r28);\n+    __ push(callee_saved, sp);\n+\n+    RegSetIterator<Register> regs = (RegSet::range(c_rarg0, r28) - r18_tls - rscratch1 - rscratch2).begin();\n+\n+    \/\/ Arguments\n+    const Register input_start = *regs, length = *++regs, acc_start = *++regs, r_start = *++regs;\n+\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers.  The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *++regs, R_1 = *++regs;\n+    pack_26(R_0, R_1, r_start);\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ lsr(RR_0, R_0, 2);\n+    __ add(RR_0, RR_0, RR_0, Assembler::LSL, 2);\n+    __ lsr(RR_1, R_1, 2);\n+    __ add(RR_1, RR_1, RR_1, Assembler::LSL, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    pack_26(U_0, U_1, U_2, acc_start);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+    __ br(Assembler::LT, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ldp(S_0, S_1, __ post(input_start, 2 * wordSize));\n+      __ adds(S_0, U_0, S_0);\n+      __ adcs(S_1, U_1, S_1);\n+      __ adc(S_2, U_2, zr);\n+      __ add(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n+      wide_mul(U_0, U_0HI, S_0, R_0);  wide_madd(U_0, U_0HI, S_1, RR_1); wide_madd(U_0, U_0HI, S_2, RR_0);\n+      wide_mul(U_1, U_1HI, S_0, R_1);  wide_madd(U_1, U_1HI, S_1, R_0);  wide_madd(U_1, U_1HI, S_2, RR_1);\n+      __ andr(U_2, R_0, 3);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Recycle registers S_0, S_1, S_2\n+      regs = (regs.remaining() + S_0 + S_1 + S_2).begin();\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ adds(U_1, U_0HI, U_1);\n+      __ adc(U_2, U_1HI, U_2);\n+      \/\/ Sum now in U_2:U_1:U_0.\n+      \/\/ Dead: U_0HI, U_1HI.\n+      regs = (regs.remaining() + U_0HI + U_1HI).begin();\n+\n+      \/\/ U_2:U_1:U_0 += (U_2 >> 2) * 5 in two steps\n+\n+      \/\/ First, U_2:U_1:U_0 += (U_2 >> 2)\n+      __ lsr(rscratch1, U_2, 2);\n+      __ andr(U_2, U_2, (u8)3);\n+      __ adds(U_0, U_0, rscratch1);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+      \/\/ Second, U_2:U_1:U_0 += (U_2 >> 2) << 2\n+      __ adds(U_0, U_0, rscratch1, Assembler::LSL, 2);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+\n+      __ sub(length, length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ br(~ Assembler::LT, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    __ lsr(rscratch1, U_2, 2);\n+    __ add(rscratch1, rscratch1, rscratch1, Assembler::LSL, 2); \/\/ rscratch1 = U_2 * 5\n+    __ adds(U_0, U_0, rscratch1); \/\/ U_0 += U_2 * 5\n+    __ adcs(U_1, U_1, zr);\n+    __ andr(U_2, U_2, (u1)3);\n+    __ adc(U_2, U_2, zr);\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    __ ubfiz(rscratch1, U_0, 0, 26);\n+    __ ubfx(rscratch2, U_0, 26, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start));\n+    __ ubfx(rscratch1, U_0, 52, 12);\n+    __ bfi(rscratch1, U_1, 12, 14);\n+    __ ubfx(rscratch2, U_1, 14, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start, 2 * sizeof (jlong)));\n+    __ ubfx(rscratch1, U_1, 40, 24);\n+    __ bfi(rscratch1, U_2, 24, 3);\n+    __ str(rscratch1, Address(acc_start, 4 * sizeof (jlong)));\n+\n+    __ bind(DONE);\n+    __ pop(callee_saved, sp);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8136,0 +8301,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -455,1 +455,2 @@\n-  } else if (strcmp(UseBranchProtection, \"standard\") == 0) {\n+  } else if (strcmp(UseBranchProtection, \"standard\") == 0 ||\n+             strcmp(UseBranchProtection, \"pac-ret\") == 0) {\n@@ -457,9 +458,4 @@\n-    \/\/ Enable PAC if this code has been built with branch-protection, the CPU\/OS\n-    \/\/ supports it, and incompatible preview features aren't enabled.\n-#ifdef __ARM_FEATURE_PAC_DEFAULT\n-    if (VM_Version::supports_paca() && !Arguments::enable_preview()) {\n-      _rop_protection = true;\n-    }\n-#endif\n-  } else if (strcmp(UseBranchProtection, \"pac-ret\") == 0) {\n-    _rop_protection = true;\n+    \/\/ Enable ROP-protection if\n+    \/\/ 1) this code has been built with branch-protection,\n+    \/\/ 2) the CPU\/OS supports it, and\n+    \/\/ 3) incompatible VMContinuations isn't enabled.\n@@ -468,1 +464,0 @@\n-      warning(\"ROP-protection specified, but not supported on this CPU.\");\n@@ -470,2 +465,2 @@\n-      _rop_protection = false;\n-    } else if (Arguments::enable_preview()) {\n+      warning(\"ROP-protection specified, but not supported on this CPU. Disabling ROP-protection.\");\n+    } else if (VMContinuations) {\n@@ -473,2 +468,3 @@\n-      warning(\"PAC-RET is incompatible with virtual threads preview feature.\");\n-      _rop_protection = false;\n+      warning(\"ROP-protection is incompatible with VMContinuations. Disabling ROP-protection.\");\n+    } else {\n+      _rop_protection = true;\n@@ -477,1 +473,1 @@\n-    warning(\"ROP-protection specified, but this VM was built without ROP-protection support.\");\n+    warning(\"ROP-protection specified, but this VM was built without ROP-protection support. Disabling ROP-protection.\");\n@@ -572,0 +568,4 @@\n+\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -7045,33 +7045,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{ \/\/ FIXME: can do better?\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n-instruct convP2B( iRegI dst, iRegP src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -117,20 +117,24 @@\n-  \/\/ ... and mark it unlocked.\n-  ori(Rmark, Rmark, markWord::unlocked_value);\n-\n-  \/\/ Save unlocked object header into the displaced header location on the stack.\n-  std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-\n-  \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"cas must take a zero displacement\");\n-  cmpxchgd(\/*flag=*\/CCR0,\n-           \/*current_value=*\/Rscratch,\n-           \/*compare_value=*\/Rmark,\n-           \/*exchange_value=*\/Rbox,\n-           \/*where=*\/Roop\/*+0==mark_offset_in_bytes*\/,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg,\n-           &cas_failed,\n-           \/*check without membar and ldarx first*\/true);\n-  \/\/ If compare\/exchange succeeded we found an unlocked object and we now have locked it\n-  \/\/ hence we are done.\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    fast_lock(Roop, Rmark, Rscratch, slow_int);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ ... and mark it unlocked.\n+    ori(Rmark, Rmark, markWord::unlocked_value);\n+\n+    \/\/ Save unlocked object header into the displaced header location on the stack.\n+    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n+\n+    \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"cas must take a zero displacement\");\n+    cmpxchgd(\/*flag=*\/CCR0,\n+             \/*current_value=*\/Rscratch,\n+             \/*compare_value=*\/Rmark,\n+             \/*exchange_value=*\/Rbox,\n+             \/*where=*\/Roop\/*+0==mark_offset_in_bytes*\/,\n+             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n+             noreg,\n+             &cas_failed,\n+             \/*check without membar and ldarx first*\/true);\n+    \/\/ If compare\/exchange succeeded we found an unlocked object and we now have locked it\n+    \/\/ hence we are done.\n+  }\n@@ -142,7 +146,9 @@\n-  bind(cas_failed);\n-  \/\/ We did not find an unlocked object so see if this is a recursive case.\n-  sub(Rscratch, Rscratch, R1_SP);\n-  load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-  and_(R0\/*==0?*\/, Rscratch, R0);\n-  std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-  bne(CCR0, slow_int);\n+  if (LockingMode == LM_LEGACY) {\n+    bind(cas_failed);\n+    \/\/ We did not find an unlocked object so see if this is a recursive case.\n+    sub(Rscratch, Rscratch, R1_SP);\n+    load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    and_(R0\/*==0?*\/, Rscratch, R0);\n+    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n+    bne(CCR0, slow_int);\n+  }\n@@ -151,1 +157,0 @@\n-\n@@ -164,4 +169,6 @@\n-  \/\/ Test first if it is a fast recursive unlock.\n-  ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-  cmpdi(CCR0, Rmark, 0);\n-  beq(CCR0, done);\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Test first if it is a fast recursive unlock.\n+    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n+    cmpdi(CCR0, Rmark, 0);\n+    beq(CCR0, done);\n+  }\n@@ -173,11 +180,18 @@\n-  \/\/ Check if it is still a light weight lock, this is is true if we see\n-  \/\/ the stack address of the basicLock in the markWord of the object.\n-  cmpxchgd(\/*flag=*\/CCR0,\n-           \/*current_value=*\/R0,\n-           \/*compare_value=*\/Rbox,\n-           \/*exchange_value=*\/Rmark,\n-           \/*where=*\/Roop,\n-           MacroAssembler::MemBarRel,\n-           MacroAssembler::cmpxchgx_hint_release_lock(),\n-           noreg,\n-           &slow_int);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    ld(Rmark, oopDesc::mark_offset_in_bytes(), Roop);\n+    andi_(R0, Rmark, markWord::monitor_value);\n+    bne(CCR0, slow_int);\n+    fast_unlock(Roop, Rmark, slow_int);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we see\n+    \/\/ the stack address of the basicLock in the markWord of the object.\n+    cmpxchgd(\/*flag=*\/CCR0,\n+             \/*current_value=*\/R0,\n+             \/*compare_value=*\/Rbox,\n+             \/*exchange_value=*\/Rmark,\n+             \/*where=*\/Roop,\n+             MacroAssembler::MemBarRel,\n+             MacroAssembler::cmpxchgx_hint_release_lock(),\n+             noreg,\n+             &slow_int);\n+  }\n@@ -190,1 +204,0 @@\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":57,"deletions":44,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -107,0 +107,2 @@\n+      post_barrier(access, access.resolved_addr(), new_value.result());\n+\n@@ -117,1 +119,7 @@\n-  return BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), new_value.result());\n+  }\n+\n+  return result;\n@@ -153,0 +161,2 @@\n+\n+    post_barrier(access, access.resolved_addr(), result);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_ppc.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -93,2 +94,0 @@\n-  __ block_comment(\"arraycopy_prologue (shenandoahgc) {\");\n-\n@@ -117,0 +116,1 @@\n+  __ block_comment(\"arraycopy_prologue (shenandoahgc) {\");\n@@ -133,1 +133,1 @@\n-                              : ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING;\n+                              : ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING;\n@@ -190,0 +190,10 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                       Register dst, Register count,\n+                                                       Register preserve) {\n+  if (is_reference_type(type)) {\n+    __ block_comment(\"arraycopy_epilogue (shenandoahgc) {\");\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n+    __ block_comment(\"} arraycopy_epilogue (shenandoahgc)\");\n+  }\n+}\n+\n@@ -223,1 +233,1 @@\n-  __ andi_(tmp1, tmp1, ShenandoahHeap::MARKING);\n+  __ andi_(tmp1, tmp1, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n@@ -589,0 +599,21 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register base, RegisterOrConstant ind_or_offs, Register tmp) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = ctbs->card_table();\n+  assert_different_registers(base, tmp, R0);\n+\n+  if (ind_or_offs.is_constant()) {\n+    __ add_const_optimized(base, base, ind_or_offs.as_constant(), tmp);\n+  } else {\n+    __ add(base, ind_or_offs.as_register(), base);\n+  }\n+\n+  __ load_const_optimized(tmp, (address)ct->byte_map_base(), R0);\n+  __ srdi(base, base, CardTable::card_shift());\n+  __ li(R0, CardTable::dirty_card_val());\n+  __ stbx(R0, tmp, base);\n+}\n+\n@@ -611,0 +642,5 @@\n+\n+  \/\/ No need for post barrier if storing NULL\n+  if (is_reference_type(type) && val != noreg) {\n+    store_check(masm, base, ind_or_offs, tmp1);\n+  }\n@@ -760,0 +796,36 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count, Register preserve) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = bs->card_table();\n+  assert_different_registers(addr, count, R0);\n+\n+  Label L_skip_loop, L_store_loop;\n+\n+  __ sldi_(count, count, LogBytesPerHeapOop);\n+\n+  \/\/ Zero length? Skip.\n+  __ beq(CCR0, L_skip_loop);\n+\n+  __ addi(count, count, -BytesPerHeapOop);\n+  __ add(count, addr, count);\n+  \/\/ Use two shifts to clear out those low order two bits! (Cannot opt. into 1.)\n+  __ srdi(addr, addr, CardTable::card_shift());\n+  __ srdi(count, count, CardTable::card_shift());\n+  __ subf(count, addr, count);\n+  __ add_const_optimized(addr, addr, (address)ct->byte_map_base(), R0);\n+  __ addi(count, count, 1);\n+  __ li(R0, 0);\n+  __ mtctr(count);\n+\n+  \/\/ Byte store loop\n+  __ bind(L_store_loop);\n+  __ stb(R0, 0, addr);\n+  __ addi(addr, addr, 1);\n+  __ bdnz(L_store_loop);\n+  __ bind(L_skip_loop);\n+}\n+\n@@ -895,1 +967,1 @@\n-  __ andi_(R12_tmp2, R12_tmp2, ShenandoahHeap::MARKING);\n+  __ andi_(R12_tmp2, R12_tmp2, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":78,"deletions":6,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+  void store_check(MacroAssembler* masm,\n+                   Register base, RegisterOrConstant ind_or_offs,\n+                   Register tmp);\n+\n@@ -63,0 +67,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register preserve);\n+\n@@ -103,1 +111,5 @@\n-                          Register src, Register dst, Register count, Register preserve1, Register preserve2);\n+                                  Register src, Register dst, Register count,\n+                                  Register preserve1, Register preserve2);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count,\n+                                  Register preserve);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -927,1 +927,1 @@\n-    \/\/ template code:\n+    \/\/ template code (for LM_LEGACY):\n@@ -941,1 +941,1 @@\n-    const Register displaced_header = R7_ARG5;\n+    const Register header           = R7_ARG5;\n@@ -949,1 +949,1 @@\n-    assert_different_registers(displaced_header, object_mark_addr, current_header, tmp);\n+    assert_different_registers(header, object_mark_addr, current_header, tmp);\n@@ -953,2 +953,2 @@\n-    \/\/ Load markWord from object into displaced_header.\n-    ld(displaced_header, oopDesc::mark_offset_in_bytes(), object);\n+    \/\/ Load markWord from object into header.\n+    ld(header, oopDesc::mark_offset_in_bytes(), object);\n@@ -963,2 +963,4 @@\n-    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markWord::unlocked_value);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      fast_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+      b(count_locking);\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -966,4 +968,2 @@\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n+      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+      ori(header, header, markWord::unlocked_value);\n@@ -971,2 +971,4 @@\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    std(displaced_header, mark_offset, monitor);\n+      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+      const int mark_offset = lock_offset +\n+                              BasicLock::displaced_header_offset_in_bytes();\n@@ -974,1 +976,2 @@\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n+      \/\/ Initialize the box (Must happen before we update the object mark!).\n+      std(header, mark_offset, monitor);\n@@ -976,19 +979,1 @@\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-    \/\/ CmpxchgX sets CCR0 to cmpX(current, displaced).\n-    cmpxchgd(\/*flag=*\/CCR0,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/displaced_header, \/*exchange_value=*\/monitor,\n-             \/*where=*\/object_mark_addr,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object and we have now locked it.\n-    b(count_locking);\n-    bind(cas_failed);\n+      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n@@ -996,3 +981,2 @@\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n+      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n+      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n@@ -1000,1 +984,11 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n+      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n+      \/\/ CmpxchgX sets CCR0 to cmpX(current, displaced).\n+      cmpxchgd(\/*flag=*\/CCR0,\n+               \/*current_value=*\/current_header,\n+               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n+               \/*where=*\/object_mark_addr,\n+               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n+               noreg,\n+               &cas_failed,\n+               \/*check without membar and ldarx first*\/true);\n@@ -1002,3 +996,4 @@\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    sub(current_header, current_header, R1_SP);\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object and we have now locked it.\n+      b(count_locking);\n+      bind(cas_failed);\n@@ -1006,2 +1001,3 @@\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n+      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n+      \/\/   \/\/ Simple recursive case.\n+      \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1009,6 +1005,16 @@\n-    and_(R0\/*==0?*\/, current_header, tmp);\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock.\n-    bne(CCR0, slow_case);\n-    std(R0\/*==0!*\/, mark_offset, monitor);\n-    b(count_locking);\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if owner is self by comparing the value in the markWord of object\n+      \/\/ (current_header) with the stack pointer.\n+      sub(current_header, current_header, R1_SP);\n+\n+      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n+      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n+\n+      and_(R0\/*==0?*\/, current_header, tmp);\n+      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n+      \/\/ header indicating it is a recursive lock.\n+      bne(CCR0, slow_case);\n+      std(R0\/*==0!*\/, mark_offset, monitor);\n+      b(count_locking);\n+    }\n@@ -1023,1 +1029,5 @@\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n+    } else {\n+      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+    }\n@@ -1045,1 +1055,1 @@\n-    \/\/ template code:\n+    \/\/ template code (for LM_LEGACY):\n@@ -1059,1 +1069,1 @@\n-    const Register displaced_header = R8_ARG6;\n+    const Register header           = R8_ARG6;\n@@ -1066,1 +1076,1 @@\n-    assert_different_registers(object, displaced_header, object_mark_addr, current_header);\n+    assert_different_registers(object, header, object_mark_addr, current_header);\n@@ -1068,3 +1078,4 @@\n-    \/\/ Test first if we are in the fast recursive case.\n-    ld(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n-                         BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      \/\/ Test first if we are in the fast recursive case.\n+      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n+                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n@@ -1072,3 +1083,4 @@\n-    \/\/ If the displaced header is zero, we have a recursive unlock.\n-    cmpdi(CCR0, displaced_header, 0);\n-    beq(CCR0, free_slot); \/\/ recursive unlock\n+      \/\/ If the displaced header is zero, we have a recursive unlock.\n+      cmpdi(CCR0, header, 0);\n+      beq(CCR0, free_slot); \/\/ recursive unlock\n+    }\n@@ -1084,14 +1096,35 @@\n-    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-    \/\/ We have the displaced header in displaced_header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n-    cmpxchgd(\/*flag=*\/CCR0,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/monitor, \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/object_mark_addr,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_case);\n+\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+      \/\/ must handle it.\n+      Register tmp = current_header;\n+      \/\/ First check for lock-stack underflow.\n+      lwz(tmp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+      cmplwi(CCR0, tmp, (unsigned)LockStack::start_offset());\n+      ble(CCR0, slow_case);\n+      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n+      addi(tmp, tmp, -oopSize);\n+      ldx(tmp, tmp, R16_thread);\n+      cmpd(CCR0, tmp, object);\n+      bne(CCR0, slow_case);\n+\n+      ld(header, oopDesc::mark_offset_in_bytes(), object);\n+      andi_(R0, header, markWord::monitor_value);\n+      bne(CCR0, slow_case);\n+      fast_unlock(object, header, slow_case);\n+    } else {\n+      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n+\n+      \/\/ We have the displaced header in displaced_header. If the lock is still\n+      \/\/ lightweight, it will contain the monitor address and we'll store the\n+      \/\/ displaced header back into the object's mark word.\n+      \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n+      cmpxchgd(\/*flag=*\/CCR0,\n+               \/*current_value=*\/current_header,\n+               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n+               \/*where=*\/object_mark_addr,\n+               MacroAssembler::MemBarRel,\n+               MacroAssembler::cmpxchgx_hint_release_lock(),\n+               noreg,\n+               &slow_case);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":105,"deletions":72,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2632,2 +2632,1 @@\n-  assert(flag != CCR0, \"bad condition register\");\n-  Label cont;\n+  assert(LockingMode != LM_LIGHTWEIGHT || flag == CCR0, \"bad condition register\");\n@@ -2652,1 +2651,1 @@\n-                      cont, object_has_monitor);\n+                      success, object_has_monitor);\n@@ -2661,1 +2660,5 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_MONITOR) {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path.\n+    crandc(flag, Assembler::equal, flag, Assembler::equal);\n+    b(failure);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -2686,5 +2689,0 @@\n-  } else {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  }\n@@ -2692,2 +2690,2 @@\n-  bind(cas_failed);\n-  \/\/ We did not see an unlocked object so try the fast recursive case.\n+    bind(cas_failed);\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n@@ -2695,4 +2693,4 @@\n-  \/\/ Check if the owner is self by comparing the value in the markWord of object\n-  \/\/ (current_header) with the stack pointer.\n-  sub(current_header, current_header, R1_SP);\n-  load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n+    \/\/ Check if the owner is self by comparing the value in the markWord of object\n+    \/\/ (current_header) with the stack pointer.\n+    sub(current_header, current_header, R1_SP);\n+    load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n@@ -2700,5 +2698,4 @@\n-  and_(R0\/*==0?*\/, current_header, temp);\n-  \/\/ If condition is true we are cont and hence we can store 0 as the\n-  \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-  mcrf(flag,CCR0);\n-  std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n+    and_(R0\/*==0?*\/, current_header, temp);\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -2706,1 +2703,10 @@\n-  b(cont);\n+    if (flag != CCR0) {\n+      mcrf(flag, CCR0);\n+    }\n+    beq(CCR0, success);\n+    b(failure);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    fast_lock(oop, displaced_header, temp, failure);\n+    b(success);\n+  }\n@@ -2717,1 +2723,2 @@\n-                         rtm_counters, method_data, profile_rtm, cont);\n+                         rtm_counters, method_data, profile_rtm, success);\n+    bne(flag, failure);\n@@ -2731,2 +2738,4 @@\n-  \/\/ Store a non-null value into the box.\n-  std(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box.\n+    std(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+  }\n@@ -2749,1 +2758,0 @@\n-  bind(cont);\n@@ -2752,1 +2760,0 @@\n-  bne(flag, failure);\n@@ -2762,3 +2769,2 @@\n-  assert(flag != CCR0, \"bad condition register\");\n-  Label object_has_monitor, notRecursive;\n-  Label success, failure;\n+  assert(LockingMode != LM_LIGHTWEIGHT || flag == CCR0, \"bad condition register\");\n+  Label success, failure, object_has_monitor, notRecursive;\n@@ -2779,1 +2785,1 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_LEGACY) {\n@@ -2795,1 +2801,5 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_MONITOR) {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path.\n+    crandc(flag, Assembler::equal, flag, Assembler::equal);\n+    b(failure);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -2811,3 +2821,3 @@\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    fast_unlock(oop, current_header, failure);\n+    b(success);\n@@ -2822,1 +2832,1 @@\n-    \/\/ It's inflated.\n+  \/\/ It's inflated.\n@@ -2835,2 +2845,2 @@\n-  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-\n+  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n+  \/\/ This is handled like owner thread mismatches: We take the slow path.\n@@ -2840,0 +2850,2 @@\n+  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n+\n@@ -2843,1 +2855,4 @@\n-  b(success); \/\/ flag is already EQ here.\n+  if (flag == CCR0) { \/\/ Otherwise, flag is already EQ, here.\n+    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Set CCR0 EQ\n+  }\n+  b(success);\n@@ -4413,0 +4428,1 @@\n+\/\/ Note: Must preserve CCR0 EQ (invariant).\n@@ -4421,0 +4437,1 @@\n+  crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Restore CCR0 EQ\n@@ -4426,0 +4443,1 @@\n+\/\/ Note: Must preserve CCR0 EQ (invariant).\n@@ -4434,0 +4452,1 @@\n+  crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Restore CCR0 EQ\n@@ -4438,0 +4457,128 @@\n+\n+\/\/ Function to flip between unlocked and locked state (fast locking).\n+\/\/ Branches to failed if the state is not as expected with CCR0 NE.\n+\/\/ Falls through upon success with CCR0 EQ.\n+\/\/ This requires fewer instructions and registers and is easier to use than the\n+\/\/ cmpxchg based implementation.\n+void MacroAssembler::atomically_flip_locked_state(bool is_unlock, Register obj, Register tmp, Label& failed, int semantics) {\n+  assert_different_registers(obj, tmp, R0);\n+  Label retry;\n+\n+  if (semantics & MemBarRel) {\n+    release();\n+  }\n+\n+  bind(retry);\n+  STATIC_ASSERT(markWord::locked_value == 0); \/\/ Or need to change this!\n+  if (!is_unlock) {\n+    ldarx(tmp, obj, MacroAssembler::cmpxchgx_hint_acquire_lock());\n+    xori(tmp, tmp, markWord::unlocked_value); \/\/ flip unlocked bit\n+    andi_(R0, tmp, markWord::lock_mask_in_place);\n+    bne(CCR0, failed); \/\/ failed if new header doesn't contain locked_value (which is 0)\n+  } else {\n+    ldarx(tmp, obj, MacroAssembler::cmpxchgx_hint_release_lock());\n+    andi_(R0, tmp, markWord::lock_mask_in_place);\n+    bne(CCR0, failed); \/\/ failed if old header doesn't contain locked_value (which is 0)\n+    ori(tmp, tmp, markWord::unlocked_value); \/\/ set unlocked bit\n+  }\n+  stdcx_(tmp, obj);\n+  bne(CCR0, retry);\n+\n+  if (semantics & MemBarFenceAfter) {\n+    fence();\n+  } else if (semantics & MemBarAcq) {\n+    isync();\n+  }\n+}\n+\n+\/\/ Implements fast-locking.\n+\/\/ Branches to slow upon failure to lock the object, with CCR0 NE.\n+\/\/ Falls through upon success with CCR0 EQ.\n+\/\/\n+\/\/  - obj: the object to be locked\n+\/\/  - hdr: the header, already loaded from obj, will be destroyed\n+\/\/  - t1: temporary register\n+void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Label& slow) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert_different_registers(obj, hdr, t1);\n+\n+  \/\/ Check if we would have space on lock-stack for the object.\n+  lwz(t1, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+  cmplwi(CCR0, t1, LockStack::end_offset() - 1);\n+  bgt(CCR0, slow);\n+\n+  \/\/ Quick check: Do not reserve cache line for atomic update if not unlocked.\n+  \/\/ (Similar to contention_hint in cmpxchg solutions.)\n+  xori(R0, hdr, markWord::unlocked_value); \/\/ flip unlocked bit\n+  andi_(R0, R0, markWord::lock_mask_in_place);\n+  bne(CCR0, slow); \/\/ failed if new header doesn't contain locked_value (which is 0)\n+\n+  \/\/ Note: We're not publishing anything (like the displaced header in LM_LEGACY)\n+  \/\/ to other threads at this point. Hence, no release barrier, here.\n+  \/\/ (The obj has been written to the BasicObjectLock at obj_offset() within the own thread stack.)\n+  atomically_flip_locked_state(\/* is_unlock *\/ false, obj, hdr, slow, MacroAssembler::MemBarAcq);\n+\n+  \/\/ After successful lock, push object on lock-stack\n+  stdx(obj, t1, R16_thread);\n+  addi(t1, t1, oopSize);\n+  stw(t1, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+}\n+\n+\/\/ Implements fast-unlocking.\n+\/\/ Branches to slow upon failure, with CCR0 NE.\n+\/\/ Falls through upon success, with CCR0 EQ.\n+\/\/\n+\/\/ - obj: the object to be unlocked\n+\/\/ - hdr: the (pre-loaded) header of the object, will be destroyed\n+void MacroAssembler::fast_unlock(Register obj, Register hdr, Label& slow) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert_different_registers(obj, hdr);\n+\n+#ifdef ASSERT\n+  {\n+    \/\/ Check that hdr is fast-locked.\n+    Label hdr_ok;\n+    andi_(R0, hdr, markWord::lock_mask_in_place);\n+    beq(CCR0, hdr_ok);\n+    stop(\"Header is not fast-locked\");\n+    bind(hdr_ok);\n+  }\n+  Register t1 = hdr; \/\/ Reuse in debug build.\n+  {\n+    \/\/ The following checks rely on the fact that LockStack is only ever modified by\n+    \/\/ its owning thread, even if the lock got inflated concurrently; removal of LockStack\n+    \/\/ entries after inflation will happen delayed in that case.\n+\n+    \/\/ Check for lock-stack underflow.\n+    Label stack_ok;\n+    lwz(t1, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+    cmplwi(CCR0, t1, LockStack::start_offset());\n+    bgt(CCR0, stack_ok);\n+    stop(\"Lock-stack underflow\");\n+    bind(stack_ok);\n+  }\n+  {\n+    \/\/ Check if the top of the lock-stack matches the unlocked object.\n+    Label tos_ok;\n+    addi(t1, t1, -oopSize);\n+    ldx(t1, t1, R16_thread);\n+    cmpd(CCR0, t1, obj);\n+    beq(CCR0, tos_ok);\n+    stop(\"Top of lock-stack does not match the unlocked object\");\n+    bind(tos_ok);\n+  }\n+#endif\n+\n+  \/\/ Release the lock.\n+  atomically_flip_locked_state(\/* is_unlock *\/ true, obj, hdr, slow, MacroAssembler::MemBarRel);\n+\n+  \/\/ After successful unlock, pop object from lock-stack\n+  Register t2 = hdr;\n+  lwz(t2, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+  addi(t2, t2, -oopSize);\n+#ifdef ASSERT\n+  li(R0, 0);\n+  stdx(R0, t2, R16_thread);\n+#endif\n+  stw(t2, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":185,"deletions":38,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -609,0 +609,3 @@\n+  void atomically_flip_locked_state(bool is_unlock, Register obj, Register tmp, Label& failed, int semantics);\n+  void fast_lock(Register obj, Register hdr, Register t1, Label& slow);\n+  void fast_unlock(Register obj, Register hdr, Label& slow);\n@@ -735,1 +738,1 @@\n-  void load_klass_check_null(Register dst, Register src, Label* is_null = NULL);\n+  void load_klass_check_null(Register dst, Register src, Label* is_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -12142,1 +12142,1 @@\n-instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n+instruct cmpFastLock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n@@ -12178,1 +12178,1 @@\n-instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n+instruct cmpFastUnlock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4700,1 +4700,1 @@\n-    if (UnsafeCopyMemory::_table == NULL) {\n+    if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2297,1 +2297,1 @@\n-  \/\/ The invokedynamic is unresolved iff method is NULL\n+  \/\/ The invokedynamic is unresolved iff method is null\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,0 +397,4 @@\n+    if (LockingMode != LM_LEGACY) {\n+      warning(\"UseRTMLocking requires LockingMode = 1\");\n+      FLAG_SET_DEFAULT(UseRTMLocking, false);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1402,1 +1402,0 @@\n-  INSN(vfsgnj_vv,  0b1010111, 0b001, 0b001000);\n@@ -1555,5 +1554,0 @@\n-  \/\/ Vector Floating-Point Sign-Injection Instructions\n-  INSN(vfsgnjx_vf, 0b1010111, 0b101, 0b001010);\n-  INSN(vfsgnjn_vf, 0b1010111, 0b101, 0b001001);\n-  INSN(vfsgnj_vf,  0b1010111, 0b101, 0b001000);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -979,1 +979,1 @@\n-      __ addw(dest->as_register_lo(), src->as_register(), zr); break;\n+      __ sign_extend(dest->as_register_lo(), src->as_register(), 32); break;\n@@ -985,2 +985,1 @@\n-      _masm->block_comment(\"FIXME: This coulde be no-op\");\n-      __ addw(dest->as_register(), src->as_register_lo(), zr); break;\n+      __ sign_extend(dest->as_register(), src->as_register_lo(), 32); break;\n@@ -1307,1 +1306,1 @@\n-        __ addw(Rdst, Rdst, zr);\n+        __ sign_extend(Rdst, Rdst, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1380,1 +1380,1 @@\n-  element_compare(a1, a2, result, cnt, tmp1, tmp2, v0, v2, v0, elem_size == 1, DONE);\n+  element_compare(a1, a2, result, cnt, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n@@ -1390,1 +1390,1 @@\n-\/\/ base, cnt, v0, v1 and t0 are clobbered.\n+\/\/ base, cnt, v4, v5, v6, v7 and t0 are clobbered.\n@@ -1396,1 +1396,1 @@\n-  vxor_vv(v0, v0, v0);\n+  vxor_vv(v4, v4, v4);\n@@ -1400,1 +1400,1 @@\n-  vse64_v(v0, base);\n+  vse64_v(v4, base);\n@@ -1433,1 +1433,1 @@\n-  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v0, v2, v0, elem_size == 1, DONE);\n+  element_compare(a1, a2, result, cnt1, tmp1, tmp2, v2, v4, v2, elem_size == 1, DONE);\n@@ -1469,1 +1469,1 @@\n-    element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v1, encLL, DIFFERENCE);\n+    element_compare(str1, str2, zr, cnt2, tmp1, tmp2, v2, v4, v2, encLL, DIFFERENCE);\n@@ -1474,2 +1474,2 @@\n-    VectorRegister vstr1 = encLU ? v4 : v0;\n-    VectorRegister vstr2 = encLU ? v0 : v4;\n+    VectorRegister vstr1 = encLU ? v8 : v4;\n+    VectorRegister vstr2 = encLU ? v4 : v8;\n@@ -1483,2 +1483,2 @@\n-    vmsne_vv(v0, vstr2, vstr1);\n-    vfirst_m(tmp2, v0);\n+    vmsne_vv(v4, vstr2, vstr1);\n+    vfirst_m(tmp2, v4);\n@@ -1492,0 +1492,1 @@\n+\n@@ -1510,1 +1511,1 @@\n-  vle8_v(v2, src);\n+  vle8_v(v6, src);\n@@ -1512,2 +1513,2 @@\n-  vzext_vf2(v0, v2);\n-  vse16_v(v0, dst);\n+  vzext_vf2(v4, v6);\n+  vse16_v(v4, dst);\n@@ -1523,1 +1524,2 @@\n-void C2_MacroAssembler::char_array_compress_v(Register src, Register dst, Register len, Register result, Register tmp) {\n+void C2_MacroAssembler::char_array_compress_v(Register src, Register dst, Register len,\n+                                              Register result, Register tmp) {\n@@ -1525,1 +1527,1 @@\n-  encode_iso_array_v(src, dst, len, result, tmp);\n+  encode_iso_array_v(src, dst, len, result, tmp, false);\n@@ -1531,3 +1533,15 @@\n-\/\/ result: the number of elements had been encoded.\n-void C2_MacroAssembler::encode_iso_array_v(Register src, Register dst, Register len, Register result, Register tmp) {\n-  Label loop, DIFFERENCE, DONE;\n+\/\/ Intrinsic for\n+\/\/\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/\n+\/\/ This version always returns the number of characters copied. A successful\n+\/\/ copy will complete with the post-condition: 'res' == 'len', while an\n+\/\/ unsuccessful copy will exit with the post-condition: 0 <= 'res' < 'len'.\n+\/\/\n+\/\/ Clobbers: src, dst, len, result, t0\n+void C2_MacroAssembler::encode_iso_array_v(Register src, Register dst, Register len,\n+                                           Register result, Register tmp, bool ascii) {\n+  Label loop, fail, done;\n@@ -1539,1 +1553,1 @@\n-  mv(tmp, 0xff);\n+  mv(tmp, ascii ? 0x7f : 0xff);\n@@ -1542,1 +1556,1 @@\n-  \/\/ if element > 0xff, stop\n+\n@@ -1551,1 +1565,2 @@\n-  bgez(tmp, DIFFERENCE);\n+  \/\/ fail if char > 0x7f\/0xff\n+  bgez(tmp, fail);\n@@ -1557,1 +1572,1 @@\n-  j(DONE);\n+  j(done);\n@@ -1559,1 +1574,1 @@\n-  bind(DIFFERENCE);\n+  bind(fail);\n@@ -1562,1 +1577,1 @@\n-  bind(DONE);\n+  bind(done);\n@@ -1576,3 +1591,3 @@\n-  vle8_v(v0, ary);\n-  vmslt_vx(v0, v0, zr);\n-  vfirst_m(tmp, v0);\n+  vle8_v(v4, ary);\n+  vmslt_vx(v4, v4, zr);\n+  vfirst_m(tmp, v4);\n@@ -1606,3 +1621,3 @@\n-  vlex_v(v0, str1, sew);\n-  vmseq_vx(v0, v0, ch);\n-  vfirst_m(tmp2, v0);\n+  vlex_v(v4, str1, sew);\n+  vmseq_vx(v4, v4, ch);\n+  vfirst_m(tmp2, v4);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":45,"deletions":30,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    vl1re8_v(v, t0);\n+    vl1r_v(v, t0);\n@@ -178,1 +178,1 @@\n-                         Register tmp);\n+                         Register tmp, bool ascii);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  __ beqz(obj, error);           \/\/ if klass is NULL it is broken\n+  __ beqz(obj, error);           \/\/ if klass is null it is broken\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -67,1 +68,1 @@\n-        __ andi(t0, t0, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING);\n+        __ andi(t0, t0, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n@@ -645,1 +646,1 @@\n-  __ test_bit(tmp, tmp, ShenandoahHeap::MARKING_BITPOS);\n+  __ andi(tmp, tmp, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  \/\/ Nothing to do for T_INT\n@@ -84,1 +83,1 @@\n-  addw(result, result, zr);\n+  sign_extend(result, result, 32);\n@@ -223,1 +222,1 @@\n-    addw(index, index, zr);\n+    sign_extend(index, index, 32);\n@@ -382,1 +381,1 @@\n-  addw(r, r, zr); \/\/ signed extended\n+  sign_extend(r, r, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  \/\/ Load float value from 'address'. The value is loaded onto the FPU register v0.\n+  \/\/ Load float value from 'address'. The value is loaded onto the fp register f10.\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -761,2 +761,2 @@\n-void MacroAssembler::li16u(Register Rd, int32_t imm) {\n-  lui(Rd, imm << 12);\n+void MacroAssembler::li16u(Register Rd, uint16_t imm) {\n+  lui(Rd, (uint32_t)imm << 12);\n@@ -1281,1 +1281,1 @@\n-    vl1re8_v(as_VectorRegister(regs[i]), stack);\n+    vl1r_v(as_VectorRegister(regs[i]), stack);\n@@ -1415,2 +1415,2 @@\n-static int patch_imm_in_li16u(address branch, int32_t target) {\n-  Assembler::patch(branch, 31, 12, target & 0xfffff); \/\/ patch lui only\n+static int patch_imm_in_li16u(address branch, uint16_t target) {\n+  Assembler::patch(branch, 31, 12, target); \/\/ patch lui only\n@@ -1511,1 +1511,1 @@\n-    return patch_imm_in_li16u(branch, (int32_t)imm);\n+    return patch_imm_in_li16u(branch, (uint16_t)imm);\n@@ -1645,3 +1645,1 @@\n-  \/\/ addw: The result is clipped to 32 bits, then the sign bit is extended,\n-  \/\/ and the result is stored in Rd\n-  addw(Rd, Rd, zr);\n+  sign_extend(Rd, Rd, 32);\n@@ -1652,3 +1650,1 @@\n-  \/\/ addw: The result is clipped to 32 bits, then the sign bit is extended,\n-  \/\/ and the result is stored in Rd\n-  addw(Rd, Rd, zr);\n+  sign_extend(Rd, Rd, 32);\n@@ -1659,3 +1655,1 @@\n-  \/\/ addw: The result is clipped to 32 bits, then the sign bit is extended,\n-  \/\/ and the result is stored in Rd\n-  addw(Rd, Rd, zr);\n+  sign_extend(Rd, Rd, 32);\n@@ -4422,2 +4416,1 @@\n-      \/\/ 32bits extend sign\n-      addw(dst.first()->as_Register(), src.first()->as_Register(), zr);\n+      sign_extend(dst.first()->as_Register(), src.first()->as_Register(), 32);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -696,1 +696,1 @@\n-  void li16u(Register Rd, int32_t imm);\n+  void li16u(Register Rd, uint16_t imm);\n@@ -1268,0 +1268,4 @@\n+  inline void vl1r_v(VectorRegister vd, Register rs) {\n+    vl1re8_v(vd, rs);\n+  }\n+\n@@ -1284,0 +1288,4 @@\n+  inline void vfabs_v(VectorRegister vd, VectorRegister vs, VectorMask vm = unmasked) {\n+    vfsgnjx_vv(vd, vs, vs, vm);\n+  }\n+\n@@ -1340,1 +1348,1 @@\n-        addw(Rt, Rt, zr);\n+        sign_extend(Rt, Rt, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  static const bool supports_encode_ascii_array = false;\n+  static const bool supports_encode_ascii_array = true;\n@@ -171,1 +171,1 @@\n-    return BoolTest::illegal;\n+    return is_alltrue ? BoolTest::eq : BoolTest::ne;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-    uint32_t value = *(uint32_t *) instr;\n+    uint32_t value = Assembler::ld_instr(instr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -917,0 +917,20 @@\n+\/\/ class for vector register v8\n+reg_class v8_reg(\n+    V8, V8_H, V8_J, V8_K\n+);\n+\n+\/\/ class for vector register v9\n+reg_class v9_reg(\n+    V9, V9_H, V9_J, V9_K\n+);\n+\n+\/\/ class for vector register v10\n+reg_class v10_reg(\n+    V10, V10_H, V10_J, V10_K\n+);\n+\n+\/\/ class for vector register v11\n+reg_class v11_reg(\n+    V11, V11_H, V11_J, V11_K\n+);\n+\n@@ -3631,0 +3651,40 @@\n+operand vReg_V8()\n+%{\n+  constraint(ALLOC_IN_RC(v8_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V9()\n+%{\n+  constraint(ALLOC_IN_RC(v9_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V10()\n+%{\n+  constraint(ALLOC_IN_RC(v10_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V11()\n+%{\n+  constraint(ALLOC_IN_RC(v11_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -8162,1 +8222,1 @@\n-    __ addw(as_Register($dst$$reg), as_Register($src$$reg), zr);\n+    __ sign_extend(as_Register($dst$$reg), as_Register($src$$reg), 32);\n@@ -8174,1 +8234,1 @@\n-    __ addw(as_Register($dst$$reg), as_Register($src$$reg), zr);\n+    __ sign_extend(as_Register($dst$$reg), as_Register($src$$reg), 32);\n@@ -9943,1 +10003,1 @@\n-  match(Set result (StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -9961,1 +10021,1 @@\n-  match(Set result (StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -9978,1 +10038,1 @@\n-  match(Set result (StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -9996,1 +10056,1 @@\n-  match(Set result (StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":66,"deletions":6,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-  format %{ \"vstoremask $dst, V0\" %}\n@@ -238,1 +237,1 @@\n-instruct vabsB(vReg dst, vReg src, vReg tmp) %{\n+instruct vabs(vReg dst, vReg src, vReg tmp) %{\n@@ -240,13 +239,0 @@\n-  ins_cost(VEC_COST);\n-  effect(TEMP tmp);\n-  format %{ \"vrsub.vi $tmp, 0, $src\\t#@vabsB\\n\\t\"\n-            \"vmax.vv $dst, $tmp, $src\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vrsub_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg), 0);\n-    __ vmax_vv(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsS(vReg dst, vReg src, vReg tmp) %{\n@@ -254,13 +240,0 @@\n-  ins_cost(VEC_COST);\n-  effect(TEMP tmp);\n-  format %{ \"vrsub.vi $tmp, 0, $src\\t#@vabsS\\n\\t\"\n-            \"vmax.vv $dst, $tmp, $src\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vrsub_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg), 0);\n-    __ vmax_vv(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsI(vReg dst, vReg src, vReg tmp) %{\n@@ -268,13 +241,0 @@\n-  ins_cost(VEC_COST);\n-  effect(TEMP tmp);\n-  format %{ \"vrsub.vi $tmp, 0, $src\\t#@vabsI\\n\\t\"\n-            \"vmax.vv $dst, $tmp, $src\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vrsub_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg), 0);\n-    __ vmax_vv(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsL(vReg dst, vReg src, vReg tmp) %{\n@@ -284,2 +244,1 @@\n-  format %{ \"vrsub.vi $tmp, 0, $src\\t#@vabsL\\n\\t\"\n-            \"vmax.vv $dst, $tmp, $src\" %}\n+  format %{ \"vabs $dst, $src\\t# KILL $tmp\" %}\n@@ -287,1 +246,2 @@\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -294,1 +254,1 @@\n-instruct vabsF(vReg dst, vReg src) %{\n+instruct vabs_fp(vReg dst, vReg src) %{\n@@ -296,10 +256,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsgnjx.vv $dst, $src, $src, vm\\t#@vabsF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfsgnjx_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsD(vReg dst, vReg src) %{\n@@ -308,1 +258,1 @@\n-  format %{ \"vfsgnjx.vv $dst, $src, $src, vm\\t#@vabsD\" %}\n+  format %{ \"vabs_fp $dst, $src\" %}\n@@ -310,2 +260,3 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n-    __ vfsgnjx_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfabs_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n@@ -345,2 +296,1 @@\n-    __ vfsgnjx_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n-                  as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+    __ vfabs_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n@@ -353,1 +303,1 @@\n-instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n+instruct vadd(vReg dst, vReg src1, vReg src2) %{\n@@ -355,0 +305,3 @@\n+  match(Set dst (AddVS src1 src2));\n+  match(Set dst (AddVI src1 src2));\n+  match(Set dst (AddVL src1 src2));\n@@ -356,1 +309,1 @@\n-  format %{ \"vadd.vv $dst, $src1, $src2\\t#@vaddB\" %}\n+  format %{ \"vadd $dst, $src1, $src2\" %}\n@@ -358,1 +311,2 @@\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -366,2 +320,3 @@\n-instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (AddVS src1 src2));\n+instruct vadd_fp(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVF src1 src2));\n+  match(Set dst (AddVD src1 src2));\n@@ -369,1 +324,1 @@\n-  format %{ \"vadd.vv $dst, $src1, $src2\\t#@vaddS\" %}\n+  format %{ \"vadd_fp $dst, $src1, $src2\" %}\n@@ -371,4 +326,5 @@\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vadd_vv(as_VectorRegister($dst$$reg),\n-               as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfadd_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_VectorRegister($src2$$reg));\n@@ -379,2 +335,7 @@\n-instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (AddVI src1 src2));\n+\/\/ vector add - predicated\n+\n+instruct vadd_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AddVB (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 src2) v0));\n@@ -382,1 +343,1 @@\n-  format %{ \"vadd.vv $dst, $src1, $src2\\t#@vaddI\" %}\n+  format %{ \"vadd_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -384,4 +345,5 @@\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vadd_vv(as_VectorRegister($dst$$reg),\n-               as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vadd_vv(as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($dst_src1$$reg),\n+               as_VectorRegister($src2$$reg), Assembler::v0_t);\n@@ -392,2 +354,3 @@\n-instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (AddVL src1 src2));\n+instruct vadd_fp_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (AddVF (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (AddVD (Binary dst_src1 src2) v0));\n@@ -395,1 +358,1 @@\n-  format %{ \"vadd.vv $dst, $src1, $src2\\t#@vaddL\" %}\n+  format %{ \"vadd_fp_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -397,4 +360,5 @@\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n-    __ vadd_vv(as_VectorRegister($dst$$reg),\n-               as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfadd_vv(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg), Assembler::v0_t);\n@@ -405,2 +369,7 @@\n-instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (AddVF src1 src2));\n+\/\/ vector sub\n+\n+instruct vsub(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVB src1 src2));\n+  match(Set dst (SubVS src1 src2));\n+  match(Set dst (SubVI src1 src2));\n+  match(Set dst (SubVL src1 src2));\n@@ -408,1 +377,1 @@\n-  format %{ \"vfadd.vv $dst, $src1, $src2\\t#@vaddF\" %}\n+  format %{ \"vsub $dst, $src1, $src2\" %}\n@@ -410,4 +379,4 @@\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfadd_vv(as_VectorRegister($dst$$reg),\n-                as_VectorRegister($src1$$reg),\n-                as_VectorRegister($src2$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n+               as_VectorRegister($src2$$reg));\n@@ -418,2 +387,3 @@\n-instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (AddVD src1 src2));\n+instruct vsub_fp(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVF src1 src2));\n+  match(Set dst (SubVD src1 src2));\n@@ -421,1 +391,1 @@\n-  format %{ \"vfadd.vv $dst, $src1, $src2\\t#@vaddD\" %}\n+  format %{ \"vsub_fp $dst, $src1, $src2\" %}\n@@ -423,3 +393,3 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n-    __ vfadd_vv(as_VectorRegister($dst$$reg),\n-                as_VectorRegister($src1$$reg),\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vfsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n@@ -431,1 +401,1 @@\n-\/\/ vector add - predicated\n+\/\/ vector sub - predicated\n@@ -433,5 +403,5 @@\n-instruct vadd_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n-  match(Set dst_src1 (AddVB (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (AddVS (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (AddVI (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (AddVL (Binary dst_src1 src2) v0));\n+instruct vsub_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (SubVB (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 src2) v0));\n@@ -439,1 +409,1 @@\n-  format %{ \"vadd.vv $dst_src1, $src2, $v0\\t#@vadd_masked\" %}\n+  format %{ \"vsub_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -443,2 +413,1 @@\n-    __ vadd_vv(as_VectorRegister($dst_src1$$reg),\n-               as_VectorRegister($dst_src1$$reg),\n+    __ vsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n@@ -450,3 +419,3 @@\n-instruct vadd_fp_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n-  match(Set dst_src1 (AddVF (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (AddVD (Binary dst_src1 src2) v0));\n+instruct vsub_fp_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (SubVF (Binary dst_src1 src2) v0));\n+  match(Set dst_src1 (SubVD (Binary dst_src1 src2) v0));\n@@ -454,1 +423,1 @@\n-  format %{ \"vfadd.vv $dst_src1, $src2, $v0\\t#@vadd_fp_masked\" %}\n+  format %{ \"vsub_fp_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -458,2 +427,1 @@\n-    __ vfadd_vv(as_VectorRegister($dst_src1$$reg),\n-                as_VectorRegister($dst_src1$$reg),\n+    __ vfsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n@@ -470,1 +438,1 @@\n-  format %{ \"vand.vv  $dst, $src1, $src2\\t#@vand\" %}\n+  format %{ \"vand $dst, $src1, $src2\" %}\n@@ -486,1 +454,1 @@\n-  format %{ \"vand_masked $dst_src1, $src2, $v0\" %}\n+  format %{ \"vand_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -502,1 +470,1 @@\n-  format %{ \"vor.vv  $dst, $src1, $src2\\t#@vor\" %}\n+  format %{ \"vor $dst, $src1, $src2\" %}\n@@ -518,1 +486,1 @@\n-  format %{ \"vor_masked $dst_src1, $src2, $v0\" %}\n+  format %{ \"vor_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -534,1 +502,1 @@\n-  format %{ \"vxor.vv  $dst, $src1, $src2\\t#@vxor\" %}\n+  format %{ \"vxor $dst, $src1, $src2\" %}\n@@ -550,1 +518,1 @@\n-  format %{ \"vxor_masked $dst_src1, $src2, $v0\" %}\n+  format %{ \"vxor_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -563,1 +531,1 @@\n-instruct vdivF(vReg dst, vReg src1, vReg src2) %{\n+instruct vdiv_fp(vReg dst, vReg src1, vReg src2) %{\n@@ -565,12 +533,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfdiv.vv  $dst, $src1, $src2\\t#@vdivF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfdiv_vv(as_VectorRegister($dst$$reg),\n-                as_VectorRegister($src1$$reg),\n-                as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vdivD(vReg dst, vReg src1, vReg src2) %{\n@@ -579,1 +535,1 @@\n-  format %{ \"vfdiv.vv  $dst, $src1, $src2\\t#@vdivD\" %}\n+  format %{ \"vdiv_fp $dst, $src1, $src2\" %}\n@@ -581,1 +537,2 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -595,1 +552,1 @@\n-  format %{ \"vfdiv.vv  $dst_src1, $src2, $v0\\t#@vdiv_fp_masked\" %}\n+  format %{ \"vdiv_fp_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -613,1 +570,1 @@\n-  format %{ \"vmax.vv $dst, $src1, $src2\\t#@vmax\" %}\n+  format %{ \"vmax $dst, $src1, $src2\" %}\n@@ -628,1 +585,1 @@\n-  format %{ \"vmin.vv $dst, $src1, $src2\\t#@vmin\" %}\n+  format %{ \"vmin $dst, $src1, $src2\" %}\n@@ -677,1 +634,1 @@\n-  format %{ \"vmaxF $dst, $src1, $src2\\t#@vmaxF\" %}\n+  format %{ \"vmaxF $dst, $src1, $src2\" %}\n@@ -691,1 +648,1 @@\n-  format %{ \"vmaxD $dst, $src1, $src2\\t#@vmaxD\" %}\n+  format %{ \"vmaxD $dst, $src1, $src2\" %}\n@@ -705,1 +662,1 @@\n-  format %{ \"vminF $dst, $src1, $src2\\t#@vminF\" %}\n+  format %{ \"vminF $dst, $src1, $src2\" %}\n@@ -719,1 +676,1 @@\n-  format %{ \"vminD $dst, $src1, $src2\\t#@vminD\" %}\n+  format %{ \"vminD $dst, $src1, $src2\" %}\n@@ -793,1 +750,1 @@\n-instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n+instruct vfmla(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -796,13 +753,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfmacc.vv $dst_src1, $src2, $src3\\t#@vfmlaF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfmacc_vv(as_VectorRegister($dst_src1$$reg),\n-                 as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA);\n@@ -811,1 +755,1 @@\n-  format %{ \"vfmacc.vv $dst_src1, $src2, $src3\\t#@vfmlaD\" %}\n+  format %{ \"vfmla $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -813,1 +757,2 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -827,1 +772,1 @@\n-  format %{ \"vfmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vfmadd_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -846,1 +791,1 @@\n-  format %{ \"vfnmsac.vv $dst_src1, $src2, $src3\\t#@vfmlsF\" %}\n+  format %{ \"vfmlsF $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -862,1 +807,1 @@\n-  format %{ \"vfnmsac.vv $dst_src1, $src2, $src3\\t#@vfmlsD\" %}\n+  format %{ \"vfmlsD $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -878,1 +823,1 @@\n-  format %{ \"vfnmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vfnmsub_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -897,1 +842,1 @@\n-  format %{ \"vfnmacc.vv $dst_src1, $src2, $src3\\t#@vfnmlaF\" %}\n+  format %{ \"vfnmlaF $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -913,1 +858,1 @@\n-  format %{ \"vfnmacc.vv $dst_src1, $src2, $src3\\t#@vfnmlaD\" %}\n+  format %{ \"vfnmlaD $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -929,1 +874,1 @@\n-  format %{ \"vfnmadd_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vfnmadd_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -946,1 +891,1 @@\n-  format %{ \"vfmsac.vv $dst_src1, $src2, $src3\\t#@vfnmlsF\" %}\n+  format %{ \"vfnmlsF $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -960,1 +905,1 @@\n-  format %{ \"vfmsac.vv $dst_src1, $src2, $src3\\t#@vfnmlsD\" %}\n+  format %{ \"vfnmlsD $dst_src1, $dst_src1, $src2, $src3\" %}\n@@ -976,1 +921,1 @@\n-  format %{ \"vfmsub_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vfmsub_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -989,1 +934,1 @@\n-instruct vmlaB(vReg dst_src1, vReg src2, vReg src3) %{\n+instruct vmla(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -991,12 +936,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmacc.vv $dst_src1, src2, src3\\t#@vmlaB\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vmacc_vv(as_VectorRegister($dst_src1$$reg),\n-                as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaS(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1004,12 +937,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmacc.vv $dst_src1, src2, src3\\t#@vmlaS\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vmacc_vv(as_VectorRegister($dst_src1$$reg),\n-                as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaI(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1017,12 +938,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmacc.vv $dst_src1, src2, src3\\t#@vmlaI\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vmacc_vv(as_VectorRegister($dst_src1$$reg),\n-                as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaL(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1031,1 +940,1 @@\n-  format %{ \"vmacc.vv $dst_src1, src2, src3\\t#@vmlaL\" %}\n+  format %{ \"vmla $dst_src1, $dst_src1, src2, src3\" %}\n@@ -1033,1 +942,2 @@\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1047,1 +957,1 @@\n-  format %{ \"vmla_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vmla_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -1060,1 +970,1 @@\n-instruct vmlsB(vReg dst_src1, vReg src2, vReg src3) %{\n+instruct vmls(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1062,12 +972,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vnmsac.vv $dst_src1, src2, src3\\t#@vmlsB\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vnmsac_vv(as_VectorRegister($dst_src1$$reg),\n-                 as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsS(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1075,12 +973,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vnmsac.vv $dst_src1, src2, src3\\t#@vmlsS\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vnmsac_vv(as_VectorRegister($dst_src1$$reg),\n-                 as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsI(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1088,12 +974,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vnmsac.vv $dst_src1, src2, src3\\t#@vmlsI\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vnmsac_vv(as_VectorRegister($dst_src1$$reg),\n-                 as_VectorRegister($src2$$reg), as_VectorRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsL(vReg dst_src1, vReg src2, vReg src3) %{\n@@ -1102,1 +976,1 @@\n-  format %{ \"vnmsac.vv $dst_src1, src2, src3\\t#@vmlsL\" %}\n+  format %{ \"vmls $dst_src1, $dst_src1, src2, src3\" %}\n@@ -1104,1 +978,2 @@\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1118,1 +993,1 @@\n-  format %{ \"vmls_masked $dst_src1, $src2, $src3, $v0\" %}\n+  format %{ \"vmls_masked $dst_src1, $dst_src1, $src2, $src3, $v0\" %}\n@@ -1130,1 +1005,1 @@\n-instruct vmulB(vReg dst, vReg src1, vReg src2) %{\n+instruct vmul(vReg dst, vReg src1, vReg src2) %{\n@@ -1132,11 +1007,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmul.vv $dst, $src1, $src2\\t#@vmulB\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vmul_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulS(vReg dst, vReg src1, vReg src2) %{\n@@ -1144,11 +1008,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmul.vv $dst, $src1, $src2\\t#@vmulS\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vmul_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulI(vReg dst, vReg src1, vReg src2) %{\n@@ -1156,11 +1009,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmul.vv $dst, $src1, $src2\\t#@vmulI\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vmul_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulL(vReg dst, vReg src1, vReg src2) %{\n@@ -1169,1 +1011,1 @@\n-  format %{ \"vmul.vv $dst, $src1, $src2\\t#@vmulL\" %}\n+  format %{ \"vmul $dst, $src1, $src2\" %}\n@@ -1171,1 +1013,2 @@\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1178,1 +1021,1 @@\n-instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n+instruct vmul_fp(vReg dst, vReg src1, vReg src2) %{\n@@ -1180,11 +1023,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfmul.vv $dst, $src1, $src2\\t#@vmulF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfmul_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-                as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n@@ -1193,1 +1025,1 @@\n-  format %{ \"vfmul.vv $dst, $src1, $src2\\t#@vmulD\" %}\n+  format %{ \"vmul_fp $dst, $src1, $src2\" %}\n@@ -1195,1 +1027,2 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1210,1 +1043,1 @@\n-  format %{ \"vmul.vv $dst_src1, $src2, $v0\\t#@vmul_masked\" %}\n+  format %{ \"vmul_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -1224,1 +1057,1 @@\n-  format %{ \"vmul.vv $dst_src1, $src2, $v0\\t#@vmul_fp_masked\" %}\n+  format %{ \"vmul_fp_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n@@ -1236,1 +1069,1 @@\n-instruct vnegI(vReg dst, vReg src) %{\n+instruct vneg(vReg dst, vReg src) %{\n@@ -1238,0 +1071,1 @@\n+  match(Set dst (NegVL src));\n@@ -1239,1 +1073,1 @@\n-  format %{ \"vrsub.vx $dst, $src, $src\\t#@vnegI\" %}\n+  format %{ \"vneg $dst, $src\" %}\n@@ -1248,11 +1082,0 @@\n-instruct vnegL(vReg dst, vReg src) %{\n-  match(Set dst (NegVL src));\n-  ins_cost(VEC_COST);\n-  format %{ \"vrsub.vx $dst, $src, $src\\t#@vnegL\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n-    __ vneg_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1277,1 +1100,1 @@\n-instruct vnegF(vReg dst, vReg src) %{\n+instruct vfneg(vReg dst, vReg src) %{\n@@ -1279,10 +1102,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsgnjn.vv $dst, $src, $src\\t#@vnegF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfneg_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegD(vReg dst, vReg src) %{\n@@ -1291,1 +1104,1 @@\n-  format %{ \"vfsgnjn.vv $dst, $src, $src\\t#@vnegD\" %}\n+  format %{ \"vfneg $dst, $src\" %}\n@@ -1293,1 +1106,2 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1324,3 +1138,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_andI\\n\\t\"\n-            \"vredand.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_andI $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1341,3 +1153,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_andL\\n\\t\"\n-            \"vredand.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_andL $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1398,3 +1208,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_orI\\n\\t\"\n-            \"vredor.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_orI $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1415,3 +1223,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_orL\\n\\t\"\n-            \"vredor.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_orL $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1472,3 +1278,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_xorI\\n\\t\"\n-            \"vredxor.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorI $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1489,3 +1293,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_xorL\\n\\t\"\n-            \"vredxor.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_xorL $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1546,3 +1348,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addI\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_addI $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1563,3 +1363,1 @@\n-  format %{ \"vmv.s.x $tmp, $src1\\t#@reduce_addL\\n\\t\"\n-            \"vredsum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vmv.x.s $dst, $tmp\" %}\n+  format %{ \"reduce_addL $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1575,2 +1373,2 @@\n-instruct reduce_addF(fRegF src1_dst, vReg src2, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n+instruct reduce_addF(fRegF dst, fRegF src1, vReg src2, vReg tmp) %{\n+  match(Set dst (AddReductionVF src1 src2));\n@@ -1579,3 +1377,1 @@\n-  format %{ \"vfmv.s.f $tmp, $src1_dst\\t#@reduce_addF\\n\\t\"\n-            \"vfredosum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vfmv.f.s $src1_dst, $tmp\" %}\n+  format %{ \"reduce_addF $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1584,1 +1380,1 @@\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n@@ -1587,1 +1383,1 @@\n-    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n@@ -1592,2 +1388,2 @@\n-instruct reduce_addD(fRegD src1_dst, vReg src2, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n+instruct reduce_addD(fRegD dst, fRegD src1, vReg src2, vReg tmp) %{\n+  match(Set dst (AddReductionVD src1 src2));\n@@ -1596,3 +1392,1 @@\n-  format %{ \"vfmv.s.f $tmp, $src1_dst\\t#@reduce_addD\\n\\t\"\n-            \"vfredosum.vs $tmp, $src2, $tmp\\n\\t\"\n-            \"vfmv.f.s $src1_dst, $tmp\" %}\n+  format %{ \"reduce_addD $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1601,1 +1395,1 @@\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n@@ -1604,1 +1398,1 @@\n-    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n@@ -1645,2 +1439,2 @@\n-instruct reduce_addF_masked(fRegF src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) v0));\n+instruct reduce_addF_masked(fRegF dst, fRegF src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (AddReductionVF (Binary src1 src2) v0));\n@@ -1649,1 +1443,1 @@\n-  format %{ \"reduce_addF_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_addF_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1652,1 +1446,1 @@\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n@@ -1655,1 +1449,1 @@\n-    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n@@ -1660,2 +1454,2 @@\n-instruct reduce_addD_masked(fRegD src1_dst, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n-  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) v0));\n+instruct reduce_addD_masked(fRegD dst, fRegD src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (AddReductionVD (Binary src1 src2) v0));\n@@ -1664,1 +1458,1 @@\n-  format %{ \"reduce_addD_masked $src1_dst, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_addD_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1667,1 +1461,1 @@\n-    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1_dst$$FloatRegister);\n+    __ vfmv_s_f(as_VectorRegister($tmp$$reg), $src1$$FloatRegister);\n@@ -1670,1 +1464,1 @@\n-    __ vfmv_f_s($src1_dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n+    __ vfmv_f_s($dst$$FloatRegister, as_VectorRegister($tmp$$reg));\n@@ -1822,1 +1616,1 @@\n-  format %{ \"reduce_maxF $dst, $src1, $src2, $tmp1, $tmp2\" %}\n+  format %{ \"vreduce_maxF $dst, $src1, $src2, $tmp1, $tmp2\" %}\n@@ -1837,1 +1631,1 @@\n-  format %{ \"reduce_maxD $dst, $src1, $src2, $tmp1, $tmp2\" %}\n+  format %{ \"vreduce_maxD $dst, $src1, $src2, $tmp1, $tmp2\" %}\n@@ -1888,1 +1682,1 @@\n-  format %{ \"reduce_minF $dst, $src1, $src2, $tmp1, $tmp2\" %}\n+  format %{ \"vreduce_minF $dst, $src1, $src2, $tmp1, $tmp2\" %}\n@@ -1903,1 +1697,1 @@\n-  format %{ \"reduce_minD $dst, $src1, $src2, $tmp1, $tmp2\" %}\n+  format %{ \"vreduce_minD $dst, $src1, $src2, $tmp1, $tmp2\" %}\n@@ -1949,1 +1743,1 @@\n-instruct replicateB(vReg dst, iRegIorL2I src) %{\n+instruct replicate(vReg dst, iRegIorL2I src) %{\n@@ -1951,10 +1745,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmv.v.x  $dst, $src\\t#@replicateB\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS(vReg dst, iRegIorL2I src) %{\n@@ -1962,10 +1746,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmv.v.x  $dst, $src\\t#@replicateS\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI(vReg dst, iRegIorL2I src) %{\n@@ -1974,1 +1748,1 @@\n-  format %{ \"vmv.v.x  $dst, $src\\t#@replicateI\" %}\n+  format %{ \"replicate $dst, $src\" %}\n@@ -1976,1 +1750,2 @@\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -1985,1 +1760,1 @@\n-  format %{ \"vmv.v.x  $dst, $src\\t#@replicateL\" %}\n+  format %{ \"replicateL $dst, $src\" %}\n@@ -1993,1 +1768,1 @@\n-instruct replicateB_imm5(vReg dst, immI5 con) %{\n+instruct replicate_imm5(vReg dst, immI5 con) %{\n@@ -1995,10 +1770,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmv.v.i  $dst, $con\\t#@replicateB_imm5\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vmv_v_i(as_VectorRegister($dst$$reg), $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS_imm5(vReg dst, immI5 con) %{\n@@ -2006,10 +1771,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vmv.v.i  $dst, $con\\t#@replicateS_imm5\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vmv_v_i(as_VectorRegister($dst$$reg), $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI_imm5(vReg dst, immI5 con) %{\n@@ -2018,1 +1773,1 @@\n-  format %{ \"vmv.v.i  $dst, $con\\t#@replicateI_imm5\" %}\n+  format %{ \"replicate_imm5 $dst, $con\" %}\n@@ -2020,1 +1775,2 @@\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length_in_bytes(this));\n@@ -2029,1 +1785,1 @@\n-  format %{ \"vmv.v.i  $dst, $con\\t#@replicateL_imm5\" %}\n+  format %{ \"replicateL_imm5 $dst, $con\" %}\n@@ -2040,1 +1796,1 @@\n-  format %{ \"vfmv.v.f  $dst, $src\\t#@replicateF\" %}\n+  format %{ \"replicateF $dst, $src\" %}\n@@ -2051,1 +1807,1 @@\n-  format %{ \"vfmv.v.f  $dst, $src\\t#@replicateD\" %}\n+  format %{ \"replicateD $dst, $src\" %}\n@@ -2448,1 +2204,1 @@\n-  format %{ \"vsra.vi $dst, $src, $shift\\t#@vasrB_imm\" %}\n+  format %{ \"vasrB_imm $dst, $src, $shift\" %}\n@@ -2466,1 +2222,1 @@\n-  format %{ \"vsra.vi $dst, $src, $shift\\t#@vasrS_imm\" %}\n+  format %{ \"vasrS_imm $dst, $src, $shift\" %}\n@@ -2484,1 +2240,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vasrI_imm\" %}\n+  format %{ \"vasrI_imm $dst, $src, $shift\" %}\n@@ -2502,1 +2258,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vasrL_imm\" %}\n+  format %{ \"vasrL_imm $dst, $src, $shift\" %}\n@@ -2586,1 +2342,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vlsrB_imm\" %}\n+  format %{ \"vlsrB_imm $dst, $src, $shift\" %}\n@@ -2608,1 +2364,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vlsrS_imm\" %}\n+  format %{ \"vlsrS_imm $dst, $src, $shift\" %}\n@@ -2630,1 +2386,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vlsrI_imm\" %}\n+  format %{ \"vlsrI_imm $dst, $src, $shift\" %}\n@@ -2648,1 +2404,1 @@\n-  format %{ \"vsrl.vi $dst, $src, $shift\\t#@vlsrL_imm\" %}\n+  format %{ \"vlsrL_imm $dst, $src, $shift\" %}\n@@ -2740,1 +2496,1 @@\n-  format %{ \"vsll.vi $dst, $src, $shift\\t#@vlslB_imm\" %}\n+  format %{ \"vlslB_imm $dst, $src, $shift\" %}\n@@ -2757,1 +2513,1 @@\n-  format %{ \"vsll.vi $dst, $src, $shift\\t#@vlslS_imm\" %}\n+  format %{ \"vlslS_imm $dst, $src, $shift\" %}\n@@ -2774,1 +2530,1 @@\n-  format %{ \"vsll.vi $dst, $src, $shift\\t#@vlslI_imm\" %}\n+  format %{ \"vlslI_imm $dst, $src, $shift\" %}\n@@ -2787,1 +2543,1 @@\n-  format %{ \"vsll.vi $dst, $src, $shift\\t#@vlslL_imm\" %}\n+  format %{ \"vlslL_imm $dst, $src, $shift\" %}\n@@ -2875,1 +2631,1 @@\n-instruct vsqrtF(vReg dst, vReg src) %{\n+instruct vsqrt_fp(vReg dst, vReg src) %{\n@@ -2877,10 +2633,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsqrt.v $dst, $src\\t#@vsqrtF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfsqrt_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD(vReg dst, vReg src) %{\n@@ -2889,1 +2635,1 @@\n-  format %{ \"vfsqrt.v $dst, $src\\t#@vsqrtD\" %}\n+  format %{ \"vsqrt_fp $dst, $src\" %}\n@@ -2891,1 +2637,2 @@\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n@@ -2899,1 +2646,1 @@\n-instruct vsqrtF_masked(vReg dst_src, vRegMask_V0 v0) %{\n+instruct vsqrt_fp_masked(vReg dst_src, vRegMask_V0 v0) %{\n@@ -2901,11 +2648,0 @@\n-  ins_cost(VEC_COST);\n-  format %{ \"vsqrtF_masked $dst_src, $v0\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n-                Assembler::v0_t);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD_masked(vReg dst_src, vRegMask_V0 v0) %{\n@@ -2914,92 +2650,1 @@\n-  format %{ \"vsqrtD_masked $dst_src, $v0\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n-    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n-                Assembler::v0_t);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub\n-\n-instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vsub.vv $dst, $src1, $src2\\t#@vsubB\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n-    __ vsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vsub.vv $dst, $src1, $src2\\t#@vsubS\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n-    __ vsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vsub.vv $dst, $src1, $src2\\t#@vsubI\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n-    __ vsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vsub.vv $dst, $src1, $src2\\t#@vsubL\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n-    __ vsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-               as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsub.vv $dst, $src1, $src2\\t@vsubF\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_FLOAT, Matcher::vector_length(this));\n-    __ vfsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-                as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsub.vv $dst, $src1, $src2\\t#@vsubD\" %}\n-  ins_encode %{\n-    __ vsetvli_helper(T_DOUBLE, Matcher::vector_length(this));\n-    __ vfsub_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src1$$reg),\n-                as_VectorRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub - predicated\n-\n-instruct vsub_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n-  match(Set dst_src1 (SubVB (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (SubVS (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (SubVI (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (SubVL (Binary dst_src1 src2) v0));\n-  ins_cost(VEC_COST);\n-  format %{ \"vsub.vv $dst_src1, $src2, $v0\\t#@vsub_masked\" %}\n+  format %{ \"vsqrt_fp_masked $dst_src, $dst_src, $v0\" %}\n@@ -3009,16 +2654,2 @@\n-    __ vsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n-               as_VectorRegister($src2$$reg), Assembler::v0_t);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsub_fp_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n-  match(Set dst_src1 (SubVF (Binary dst_src1 src2) v0));\n-  match(Set dst_src1 (SubVD (Binary dst_src1 src2) v0));\n-  ins_cost(VEC_COST);\n-  format %{ \"vfsub.vv $dst_src1, $src2, $v0\\t#@vsub_fp_masked\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    __ vfsub_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n-                as_VectorRegister($src2$$reg), Assembler::v0_t);\n+    __ vfsqrt_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+                Assembler::v0_t);\n@@ -3030,2 +2661,2 @@\n-                         iRegI_R10 result, vReg_V1 v1,\n-                         vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, rFlagsReg cr)\n+                         iRegI_R10 result, vReg_V2 v2,\n+                         vReg_V3 v3, vReg_V4 v4, vReg_V5 v5, rFlagsReg cr)\n@@ -3035,1 +2666,1 @@\n-  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP v1, TEMP v2, TEMP v3, TEMP v0, KILL cr);\n+  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP v2, TEMP v3, TEMP v4, TEMP v5, KILL cr);\n@@ -3047,2 +2678,2 @@\n-                         iRegI_R10 result, vReg_V1 v1,\n-                         vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, rFlagsReg cr)\n+                         iRegI_R10 result, vReg_V2 v2,\n+                         vReg_V3 v3, vReg_V4 v4, vReg_V5 v5, rFlagsReg cr)\n@@ -3052,1 +2683,1 @@\n-  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP v1, TEMP v2, TEMP v3, TEMP v0, KILL cr);\n+  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP v2, TEMP v3, TEMP v4, TEMP v5, KILL cr);\n@@ -3064,1 +2695,1 @@\n-                        vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, iRegP_R28 tmp, rFlagsReg cr)\n+                        vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5, iRegP_R28 tmp, rFlagsReg cr)\n@@ -3068,1 +2699,1 @@\n-  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP v1, TEMP v2, TEMP v3, TEMP v0, KILL cr);\n+  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP v2, TEMP v3, TEMP v4, TEMP v5, KILL cr);\n@@ -3079,1 +2710,1 @@\n-                        vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, iRegP_R28 tmp, rFlagsReg cr)\n+                        vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5, iRegP_R28 tmp, rFlagsReg cr)\n@@ -3083,1 +2714,1 @@\n-  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP v1, TEMP v2, TEMP v3, TEMP v0, KILL cr);\n+  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP v2, TEMP v3, TEMP v4, TEMP v5, KILL cr);\n@@ -3094,2 +2725,2 @@\n-                          iRegI_R10 result, vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n-                          vRegMask_V0 v0, iRegP_R28 tmp1, iRegL_R29 tmp2)\n+                          iRegI_R10 result, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n+                          iRegP_R28 tmp1, iRegL_R29 tmp2)\n@@ -3098,1 +2729,1 @@\n-  match(Set result(StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -3100,1 +2731,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v0);\n+         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n@@ -3113,2 +2744,2 @@\n-                          iRegI_R10 result, vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n-                          vRegMask_V0 v0, iRegP_R28 tmp1, iRegL_R29 tmp2)\n+                          iRegI_R10 result, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n+                          iRegP_R28 tmp1, iRegL_R29 tmp2)\n@@ -3117,1 +2748,1 @@\n-  match(Set result(StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -3119,1 +2750,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v0);\n+         TEMP v2, TEMP v3, TEMP v4, TEMP v5);\n@@ -3132,3 +2763,3 @@\n-                           iRegI_R10 result, vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4,\n-                           vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n-                           vRegMask_V0 v0, iRegP_R28 tmp1, iRegL_R29 tmp2)\n+                           iRegI_R10 result, vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n+                           vReg_V8 v8, vReg_V9 v9, vReg_V10 v10, vReg_V11 v11,\n+                           iRegP_R28 tmp1, iRegL_R29 tmp2)\n@@ -3137,1 +2768,1 @@\n-  match(Set result(StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -3139,1 +2770,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v0);\n+         TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9, TEMP v10, TEMP v11);\n@@ -3151,3 +2782,3 @@\n-                           iRegI_R10 result, vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vReg_V4 v4,\n-                           vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n-                           vRegMask_V0 v0, iRegP_R28 tmp1, iRegL_R29 tmp2)\n+                           iRegI_R10 result, vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7,\n+                           vReg_V8 v8, vReg_V9 v9, vReg_V10 v10, vReg_V11 v11,\n+                           iRegP_R28 tmp1, iRegL_R29 tmp2)\n@@ -3156,1 +2787,1 @@\n-  match(Set result(StrComp(Binary str1 cnt1)(Binary str2 cnt2)));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n@@ -3158,1 +2789,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v0);\n+         TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9, TEMP v10, TEMP v11);\n@@ -3172,1 +2803,1 @@\n-                         vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, iRegLNoSp tmp)\n+                         vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7, iRegLNoSp tmp)\n@@ -3176,1 +2807,1 @@\n-  effect(TEMP v1, TEMP v2, TEMP v3, TEMP v0, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len);\n+  effect(TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len);\n@@ -3189,1 +2820,1 @@\n-  predicate(UseRVV);\n+  predicate(UseRVV && !((EncodeISOArrayNode*)n)->is_ascii());\n@@ -3192,1 +2823,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP tmp, TEMP v0);\n+         TEMP v0, TEMP v1, TEMP v2, TEMP v3, TEMP tmp);\n@@ -3194,1 +2825,1 @@\n-  format %{ \"Encode array $src,$dst,$len -> $result\" %}\n+  format %{ \"Encode ISO array $src, $dst, $len -> $result # KILL $src, $dst, $len, $tmp, V0-V3\" %}\n@@ -3197,1 +2828,1 @@\n-                          $result$$Register, $tmp$$Register);\n+                          $result$$Register, $tmp$$Register, false \/* ascii *\/);\n@@ -3199,1 +2830,17 @@\n-  ins_pipe( pipe_class_memory );\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct vencode_ascii_array(iRegP_R12 src, iRegP_R11 dst, iRegI_R13 len, iRegI_R10 result,\n+                             vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, iRegLNoSp tmp)\n+%{\n+  predicate(UseRVV && ((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP_DEF result, USE_KILL src, USE_KILL dst, USE_KILL len,\n+         TEMP v0, TEMP v1, TEMP v2, TEMP v3, TEMP tmp);\n+\n+  format %{ \"Encode ASCII array $src, $dst, $len -> $result # KILL $src, $dst, $len, $tmp, V0-V3\" %}\n+  ins_encode %{\n+    __ encode_iso_array_v($src$$Register, $dst$$Register, $len$$Register,\n+                          $result$$Register, $tmp$$Register, true \/* ascii *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n@@ -3209,1 +2856,1 @@\n-         TEMP v1, TEMP v2, TEMP v3, TEMP tmp, TEMP v0);\n+         TEMP v0, TEMP v1, TEMP v2, TEMP v3, TEMP tmp);\n@@ -3216,1 +2863,1 @@\n-  ins_pipe( pipe_slow );\n+  ins_pipe(pipe_class_memory);\n@@ -3220,1 +2867,1 @@\n-                          vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0, iRegLNoSp tmp)\n+                          vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7, iRegLNoSp tmp)\n@@ -3224,1 +2871,1 @@\n-  effect(TEMP_DEF result, USE_KILL ary, USE_KILL len, TEMP v1, TEMP v2, TEMP v3, TEMP tmp, TEMP v0);\n+  effect(TEMP_DEF result, USE_KILL ary, USE_KILL len, TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP tmp);\n@@ -3231,1 +2878,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_memory);\n@@ -3236,1 +2883,1 @@\n-                               vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0)\n+                               vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7)\n@@ -3241,1 +2888,1 @@\n-         TEMP tmp1, TEMP tmp2, TEMP v1, TEMP v2, TEMP v3, TEMP v0);\n+         TEMP tmp1, TEMP tmp2, TEMP v4, TEMP v5, TEMP v6, TEMP v7);\n@@ -3256,1 +2903,1 @@\n-                               vReg_V1 v1, vReg_V2 v2, vReg_V3 v3, vRegMask_V0 v0)\n+                               vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7)\n@@ -3261,1 +2908,1 @@\n-         TEMP tmp1, TEMP tmp2, TEMP v1, TEMP v2, TEMP v3, TEMP v0);\n+         TEMP tmp1, TEMP tmp2, TEMP v4, TEMP v5, TEMP v6, TEMP v7);\n@@ -3276,1 +2923,1 @@\n-                             vReg_V1 vReg1, vReg_V2 vReg2, vReg_V3 vReg3, vRegMask_V0 v0)\n+                             vReg_V4 v4, vReg_V5 v5, vReg_V6 v6, vReg_V7 v7)\n@@ -3280,1 +2927,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP vReg1, TEMP vReg2, TEMP vReg3, TEMP v0);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP v4, TEMP v5, TEMP v6, TEMP v7);\n@@ -3455,1 +3102,1 @@\n-  format %{ \"vmaskcast $dst_src\\t# do nothing\" %}\n+  format %{ \"vmaskcast $dst_src, $dst_src\\t# do nothing\" %}\n@@ -3490,1 +3137,1 @@\n-  format %{ \"vmerge_vvm $dst, $src1, $src2, v0\\t#@vector blend\" %}\n+  format %{ \"vblend $dst, $src1, $src2, v0\" %}\n@@ -3766,1 +3413,1 @@\n-  format %{ \"# reinterpret $dst_src\\t# do nothing\" %}\n+  format %{ \"# reinterpret $dst_src, $dst_src\\t# do nothing\" %}\n@@ -3801,1 +3448,1 @@\n-  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  format %{ \"vmask_reinterpret_same_esize $dst_src, $dst_src\\t# do nothing\" %}\n@@ -4284,0 +3931,107 @@\n+%}\n+\n+\/\/ ------------------------------ VectorTest -----------------------------------\n+\n+\/\/ anytrue\n+\n+\/\/ Not matched. Condition is negated and value zero is moved to the right side in CMoveINode::Ideal.\n+\n+\/\/ instruct cmovI_vtest_anytrue(iRegINoSp dst, cmpOp cop, vRegMask op1, vRegMask op2, immI0 zero, immI_1 one) %{\n+\/\/   predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne &&\n+\/\/             static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::ne);\n+\/\/   match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary zero one)));\n+\/\/   format %{ \"CMove $dst, (vectortest $cop $op1 $op2), zero, one\\t#@cmovI_vtest_anytrue\"  %}\n+\/\/   ins_encode %{\n+\/\/     BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+\/\/     uint vector_length = Matcher::vector_length(this, $op1);\n+\/\/     __ vsetvli_helper(bt, vector_length);\n+\/\/     __ vcpop_m($dst$$Register, as_VectorRegister($op1$$reg));\n+\/\/     __ snez($dst$$Register, $dst$$Register);\n+\/\/   %}\n+\/\/   ins_pipe(pipe_slow);\n+\/\/ %}\n+\n+instruct cmovI_vtest_anytrue_negate(iRegINoSp dst, cmpOp cop, vRegMask op1, vRegMask op2, immI0 zero, immI_1 one) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq &&\n+            static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary one zero)));\n+  format %{ \"CMove $dst, (vectortest $cop $op1 $op2), zero, one\\t#@cmovI_vtest_anytrue_negate\"  %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+    uint vector_length = Matcher::vector_length(this, $op1);\n+    __ vsetvli_helper(bt, vector_length);\n+    __ vcpop_m($dst$$Register, as_VectorRegister($op1$$reg));\n+    __ snez($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+\/\/ Not matched. Condition is negated and value zero is moved to the right side in CMoveINode::Ideal.\n+\n+\/\/ instruct cmovI_vtest_alltrue(iRegINoSp dst, cmpOp cop, vRegMask op1, vRegMask op2, immI0 zero, immI_1 one) %{\n+\/\/   predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq &&\n+\/\/             static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::overflow);\n+\/\/   match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary zero one)));\n+\/\/   format %{ \"CMove $dst, (vectortest $cop $op1 $op2), zero, one\\t#@cmovI_vtest_alltrue\"  %}\n+\/\/   ins_encode %{\n+\/\/     BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+\/\/     uint vector_length = Matcher::vector_length(this, $op1);\n+\/\/     __ vsetvli_helper(bt, vector_length);\n+\/\/     __ vcpop_m($dst$$Register, as_VectorRegister($op1$$reg));\n+\/\/     __ sub($dst$$Register, $dst$$Register, vector_length);\n+\/\/     __ seqz($dst$$Register, $dst$$Register);\n+\/\/   %}\n+\/\/   ins_pipe(pipe_slow);\n+\/\/ %}\n+\n+instruct cmovI_vtest_alltrue_negate(iRegINoSp dst, cmpOp cop, vRegMask op1, vRegMask op2, immI0 zero, immI_1 one) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne &&\n+            static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::overflow);\n+  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary one zero)));\n+  format %{ \"CMove $dst, (vectortest $cop $op1 $op2), zero, one\\t#@cmovI_vtest_alltrue_negate\"  %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+    uint vector_length = Matcher::vector_length(this, $op1);\n+    __ vsetvli_helper(bt, vector_length);\n+    __ vcpop_m($dst$$Register, as_VectorRegister($op1$$reg));\n+    __ sub($dst$$Register, $dst$$Register, vector_length);\n+    __ seqz($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ anytrue\n+\n+instruct vtest_anytrue_branch(cmpOpEqNe cop, vRegMask op1, vRegMask op2, label lbl) %{\n+  predicate(static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::ne);\n+  match(If cop (VectorTest op1 op2));\n+  effect(USE lbl);\n+  format %{ \"b$cop (vectortest ne $op1, $op2) $lbl\\t#@vtest_anytrue_branch\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $op1);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+    __ vsetvli_helper(bt, vector_length);\n+    __ vcpop_m(t0, as_VectorRegister($op1$$reg));\n+    __ enc_cmpEqNe_imm0_branch($cop$$cmpcode, t0, *($lbl$$label), \/* is_far *\/ true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+instruct vtest_alltrue_branch(cmpOpEqNe cop, vRegMask op1, vRegMask op2, label lbl) %{\n+  predicate(static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::overflow);\n+  match(If cop (VectorTest op1 op2));\n+  effect(USE lbl);\n+  format %{ \"b$cop (vectortest overflow $op1, $op2) $lbl\\t#@vtest_alltrue_branch\" %}\n+  ins_encode %{\n+    uint vector_length = Matcher::vector_length(this, $op1);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $op1);\n+    __ vsetvli_helper(bt, vector_length);\n+    __ vcpop_m(t0, as_VectorRegister($op1$$reg));\n+    __ sub(t0, t0, vector_length);\n+    __ enc_cmpEqNe_imm0_branch($cop$$cmpcode, t0, *($lbl$$label), \/* is_far *\/ true);\n+  %}\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":375,"deletions":621,"binary":false,"changes":996,"status":"modified"},{"patch":"@@ -1630,1 +1630,0 @@\n-    __ addw(t0, t0, zr);\n@@ -2482,1 +2481,1 @@\n-  __ addiw(c_rarg1, j_rarg0, 0);\n+  __ sign_extend(c_rarg1, j_rarg0, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -918,1 +918,4 @@\n-    __ slli(vl, vl, (int)sew);\n+    if (sew != Assembler::e8) {\n+      \/\/ when sew == e8 (e.g., elem size is 1 byte), slli R, R, 0 is a nop and unnecessary\n+      __ slli(vl, vl, sew);\n+    }\n@@ -930,1 +933,4 @@\n-      __ slli(t0, t0, sew);\n+      if (sew != Assembler::e8) {\n+        \/\/ when sew == e8 (e.g., elem size is 1 byte), slli R, R, 0 is a nop and unnecessary\n+        __ slli(t0, t0, sew);\n+      }\n@@ -1780,3 +1786,2 @@\n-    \/\/ i.e. sign bit set\n-    __ test_bit(t0, src_pos, 31);\n-    __ bnez(t0, L_failed);\n+    __ sign_extend(t0, src_pos, 32);\n+    __ bltz(t0, L_failed);\n@@ -1788,3 +1793,2 @@\n-    \/\/ i.e. sign bit set\n-    __ test_bit(t0, dst_pos, 31);\n-    __ bnez(t0, L_failed);\n+    __ sign_extend(t0, dst_pos, 32);\n+    __ bltz(t0, L_failed);\n@@ -1798,4 +1802,2 @@\n-    __ addw(scratch_length, length, zr);    \/\/ length (elements count, 32-bits value)\n-    \/\/ i.e. sign bit set\n-    __ test_bit(t0, scratch_length, 31);\n-    __ bnez(t0, L_failed);\n+    __ sign_extend(scratch_length, length, 32);    \/\/ length (elements count, 32-bits value)\n+    __ bltz(scratch_length, L_failed);\n@@ -1840,2 +1842,1 @@\n-    __ test_bit(t0, lh, 31);\n-    __ beqz(t0, L_failed);\n+    __ bgez(lh, L_failed);\n@@ -1866,1 +1867,1 @@\n-    const Register x22_elsize = lh;   \/\/ element size\n+    const Register x30_elsize = lh;   \/\/ element size\n@@ -1891,1 +1892,1 @@\n-    __ test_bit(t0, x22_elsize, 1);\n+    __ test_bit(t0, x30_elsize, 1);\n@@ -1893,1 +1894,1 @@\n-    __ test_bit(t0, x22_elsize, 0);\n+    __ test_bit(t0, x30_elsize, 0);\n@@ -1897,1 +1898,1 @@\n-    __ addw(count, scratch_length, zr); \/\/ length\n+    __ sign_extend(count, scratch_length, 32); \/\/ length\n@@ -1903,1 +1904,1 @@\n-    __ addw(count, scratch_length, zr); \/\/ length\n+    __ sign_extend(count, scratch_length, 32); \/\/ length\n@@ -1907,1 +1908,1 @@\n-    __ test_bit(t0, x22_elsize, 0);\n+    __ test_bit(t0, x30_elsize, 0);\n@@ -1911,1 +1912,1 @@\n-    __ addw(count, scratch_length, zr); \/\/ length\n+    __ sign_extend(count, scratch_length, 32); \/\/ length\n@@ -1919,2 +1920,2 @@\n-      __ andi(lh, lh, Klass::_lh_log2_element_size_mask); \/\/ lh -> x22_elsize\n-      __ addw(lh, lh, zr);\n+      __ andi(lh, lh, Klass::_lh_log2_element_size_mask); \/\/ lh -> x30_elsize\n+      __ sign_extend(lh, lh, 32);\n@@ -1922,1 +1923,1 @@\n-      __ beq(x22_elsize, t0, L);\n+      __ beq(x30_elsize, t0, L);\n@@ -1930,1 +1931,1 @@\n-    __ addw(count, scratch_length, zr); \/\/ length\n+    __ sign_extend(count, scratch_length, 32); \/\/ length\n@@ -1950,1 +1951,1 @@\n-    __ addw(count, scratch_length, zr); \/\/ length\n+    __ sign_extend(count, scratch_length, 32); \/\/ length\n@@ -1973,1 +1974,1 @@\n-      __ addw(count, length, zr);           \/\/ length (reloaded)\n+      __ sign_extend(count, length, 32);      \/\/ length (reloaded)\n@@ -2806,1 +2807,1 @@\n-    __ addw(haystack_len, haystack_len, zr);\n+    __ sign_extend(haystack_len, haystack_len, 32);\n@@ -4019,1 +4020,1 @@\n-    if (UnsafeCopyMemory::_table == NULL) {\n+    if (UnsafeCopyMemory::_table == nullptr) {\n@@ -4077,1 +4078,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  _initial_stubs_code_size      = 19000,\n+  _initial_stubs_code_size      = 10000,\n@@ -42,2 +42,2 @@\n-  _compiler_stubs_code_size     = 128000,\n-  _final_stubs_code_size        = 128000\n+  _compiler_stubs_code_size     = 15000 ZGC_ONLY(+5000),\n+  _final_stubs_code_size        = 20000 ZGC_ONLY(+10000)\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -707,1 +707,1 @@\n-  __ addw(index, index, zr);\n+  __ sign_extend(index, index, 32);\n@@ -725,1 +725,1 @@\n-  __ addw(x10, x10, zr); \/\/ signed extended\n+  __ sign_extend(x10, x10, 32);\n@@ -1546,1 +1546,1 @@\n-      __ addw(x10, x10, zr);\n+      __ sign_extend(x10, x10, 32);\n@@ -1770,1 +1770,1 @@\n-  __ addw(x10, x10, zr);\n+  __ sign_extend(x10, x10, 32);\n@@ -1804,1 +1804,1 @@\n-  __ addw(x10, x10, zr);\n+  __ sign_extend(x10, x10, 32);\n@@ -2446,1 +2446,1 @@\n-  __ addw(x10, x10, zr); \/\/ signed extended\n+  __ sign_extend(x10, x10, 32);\n@@ -3046,1 +3046,1 @@\n-      __ addw(x10, x10, zr); \/\/ signed extended\n+      __ sign_extend(x10, x10, 32);\n@@ -3093,1 +3093,1 @@\n-      __ addw(x10, x10, zr); \/\/ signed extended\n+      __ sign_extend(x10, x10, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5891,15 +5891,0 @@\n-void Assembler::sete(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x94, (0xC0 | encode));\n-}\n-\n-void Assembler::setl(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x9C, (0xC0 | encode));\n-}\n-\n-void Assembler::setne(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | encode));\n-}\n-\n@@ -12409,4 +12394,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | dst->encoding()));\n-}\n-\n@@ -12417,5 +12398,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  int enc = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | enc));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2090,4 +2090,0 @@\n-  void sete(Register dst);\n-  void setl(Register dst);\n-  void setne(Register dst);\n-\n@@ -2241,2 +2237,0 @@\n-  void set_byte_if_not_zero(Register dst); \/\/ sets reg to 1 if not zero, otherwise 0\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2837,1 +2837,1 @@\n-    __ set_byte_if_not_zero(dest);\n+    __ setb(Assembler::notZero, dest);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+  __ jcc(Assembler::zero, error); \/\/ if klass is null it is broken\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    __ jcc(Assembler::equal, L_already_dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -90,0 +91,2 @@\n+\n+      post_barrier(access, access.resolved_addr(), new_value.result());\n@@ -93,1 +96,8 @@\n-  return BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), new_value.result());\n+  }\n+\n+  return result;\n@@ -123,0 +133,1 @@\n+    post_barrier(access, access.resolved_addr(), result);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -123,0 +125,23 @@\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+      bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+      bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+\n+      \/\/ We need to save the original element count because the array copy stub\n+      \/\/ will destroy the value and we need it for the card marking barrier.\n+#ifdef _LP64\n+      if (!checkcast) {\n+        if (!obj_int) {\n+          \/\/ Save count for barrier\n+          __ movptr(r11, count);\n+        } else if (disjoint) {\n+          \/\/ Save dst in r11 in the disjoint case\n+          __ movq(r11, dst);\n+        }\n+      }\n+#else\n+      if (disjoint) {\n+        __ mov(rdx, dst);          \/\/ save 'to'\n+      }\n+#endif\n+    }\n@@ -143,1 +168,1 @@\n-      Label done;\n+      Label L_done;\n@@ -146,1 +171,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -154,1 +179,1 @@\n-        flags = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING;\n+        flags = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING;\n@@ -157,1 +182,1 @@\n-      __ jcc(Assembler::zero, done);\n+      __ jcc(Assembler::zero, L_done);\n@@ -177,1 +202,1 @@\n-      __ bind(done);\n+      __ bind(L_done);\n@@ -184,0 +209,29 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                       Register src, Register dst, Register count) {\n+  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+  bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+  Register tmp = rax;\n+\n+  if (is_reference_type(type)) {\n+#ifdef _LP64\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        count = r11;\n+      } else if (disjoint) {\n+        \/\/ Use the saved dst in the disjoint case\n+        dst = r11;\n+      }\n+    } else {\n+      tmp = rscratch1;\n+    }\n+#else\n+    if (disjoint) {\n+      __ mov(dst, rdx); \/\/ restore 'to'\n+    }\n+#endif\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n+  }\n+}\n+\n@@ -227,1 +281,1 @@\n-  __ testb(gc_state, ShenandoahHeap::MARKING);\n+  __ testb(gc_state, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n@@ -593,0 +647,45 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  \/\/ Does a store check for the oop in register obj. The content of\n+  \/\/ register obj is destroyed afterwards.\n+\n+  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = ctbs->card_table();\n+\n+  __ shrptr(obj, CardTable::card_shift());\n+\n+  Address card_addr;\n+\n+  \/\/ The calculation for byte_map_base is as follows:\n+  \/\/ byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);\n+  \/\/ So this essentially converts an address to a displacement and it will\n+  \/\/ never need to be relocated. On 64-bit however the value may be too\n+  \/\/ large for a 32-bit displacement.\n+  intptr_t byte_map_base = (intptr_t)ct->byte_map_base();\n+  if (__ is_simm32(byte_map_base)) {\n+    card_addr = Address(noreg, obj, Address::times_1, byte_map_base);\n+  } else {\n+    \/\/ By doing it as an ExternalAddress 'byte_map_base' could be converted to a rip-relative\n+    \/\/ displacement and done in a single instruction given favorable mapping and a\n+    \/\/ smarter version of as_Address. However, 'ExternalAddress' generates a relocation\n+    \/\/ entry and that entry is not properly handled by the relocation code.\n+    AddressLiteral cardtable((address)byte_map_base, relocInfo::none);\n+    Address index(noreg, obj, Address::times_1);\n+    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+  }\n+\n+  int dirty = CardTable::dirty_card_val();\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ cmpb(card_addr, dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n+    __ movb(card_addr, dirty);\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ movb(card_addr, dirty);\n+  }\n+}\n+\n@@ -634,0 +733,1 @@\n+      \/\/ TODO: store_check missing in upstream\n@@ -635,0 +735,1 @@\n+      store_check(masm, tmp1);\n@@ -830,0 +931,59 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n+#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n+\n+#define TIMES_OOP (UseCompressedOops ? Address::times_4 : Address::times_8)\n+\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register addr, Register count,\n+                                                                     Register tmp) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  CardTable* ct = bs->card_table();\n+  intptr_t disp = (intptr_t) ct->byte_map_base();\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+  assert_different_registers(addr, end);\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ testl(count, count);\n+  __ jccb(Assembler::zero, L_done);\n+\n+#ifdef _LP64\n+  __ leaq(end, Address(addr, count, TIMES_OOP, 0));  \/\/ end == addr+count*oop_size\n+  __ subptr(end, BytesPerHeapOop); \/\/ end - 1 to make inclusive\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end, CardTable::card_shift());\n+  __ subptr(end, addr); \/\/ end --> cards count\n+\n+  __ mov64(tmp, disp);\n+  __ addptr(addr, tmp);\n+\n+  __ BIND(L_loop);\n+  __ movb(Address(addr, count, Address::times_1), 0);\n+  __ decrement(count);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n+#else\n+  __ lea(end, Address(addr, count, Address::times_ptr, -wordSize));\n+  __ shrptr(addr, CardTable::card_shift());\n+  __ shrptr(end,  CardTable::card_shift());\n+  __ subptr(end, addr); \/\/ end --> count\n+\n+  __ BIND(L_loop);\n+  Address cardtable(addr, count, Address::times_1, disp);\n+  __ movb(cardtable, 0);\n+  __ decrement(count);\n+  __ jccb(Assembler::greaterEqual, L_loop);\n+#endif\n+\n+  __ BIND(L_done);\n+}\n+\n@@ -945,1 +1105,1 @@\n-  __ testb(gc_state, ShenandoahHeap::MARKING);\n+  __ testb(gc_state, ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":167,"deletions":7,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -61,0 +62,6 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register addr, Register count,\n+                                        Register tmp);\n+\n@@ -77,0 +84,2 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-         \" last_sp != nullptr\");\n+         \" last_sp isn't null\");\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    if (nop == NULL) {\n+    if (nop == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4303,0 +4303,119 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register scan_temp,\n+                                                  Register temp_reg2,\n+                                                  Register receiver,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  assert_different_registers(recv_klass, method_result, holder_klass, resolved_klass, scan_temp, temp_reg2, receiver);\n+  Register temp_itbl_klass = method_result;\n+  Register temp_reg = (temp_reg2 == noreg ? recv_klass : temp_reg2); \/\/ reuse recv_klass register on 32-bit x86 impl\n+\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int vte_size = vtableEntry::size_in_bytes();\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+  Address::ScaleFactor times_vte_scale = Address::times_ptr;\n+  assert(vte_size == wordSize, \"adjust times_vte_scale\");\n+\n+  Label L_loop_scan_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  \/\/ temp_itbl_klass = recv_klass.itable[0]\n+  \/\/ scan_temp = &recv_klass.itable[0] + step\n+  movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  movptr(temp_itbl_klass, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset));\n+  lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset + scan_step));\n+  xorptr(temp_reg, temp_reg);\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  cmpptr(holder_klass, resolved_klass);\n+  jccb(Assembler::notEqual, L_loop_scan_resolved_entry);\n+  testptr(temp_itbl_klass, temp_itbl_klass);\n+  jccb(Assembler::zero, L_no_such_interface);\n+  cmpptr(holder_klass, temp_itbl_klass);\n+  jccb(Assembler::equal, L_holder_found);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_scan_holder;\n+  bind(L_scan_holder);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_holder_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_scan_holder);\n+\n+  jmpb(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/        \/\/ Also check if we have met a holder klass\n+  \/\/        holder_tmp = itable[index-step-ioffset];\n+  \/\/     }\n+  \/\/     if (tmp == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  \/\/\n+  Label L_loop_scan_resolved;\n+  bind(L_loop_scan_resolved);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    bind(L_loop_scan_resolved_entry);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    cmovl(Assembler::equal, temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+    cmpptr(resolved_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_resolved_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_loop_scan_resolved);\n+\n+  jmpb(L_no_such_interface);\n+\n+  Label L_ready;\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  testptr(temp_reg, temp_reg);\n+  jccb(Assembler::zero, L_scan_holder);\n+  jmpb(L_ready);\n+\n+  bind(L_holder_found);\n+  movl(temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+\n+  \/\/ Finally, temp_reg contains holder_klass vtable offset\n+  bind(L_ready);\n+  assert(itableMethodEntry::size() * wordSize == wordSize, \"adjust the scaling in the code below\");\n+  if (temp_reg2 == noreg) { \/\/ recv_klass register is clobbered for 32-bit x86 impl\n+    load_klass(scan_temp, receiver, noreg);\n+    movptr(method_result, Address(scan_temp, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  } else {\n+    movptr(method_result, Address(recv_klass, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -606,0 +606,10 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register scan_temp,\n+                                    Register temp_reg2,\n+                                    Register receiver,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  \/\/ Most registers are in use; we'll use rax, rbx, rsi, rdi\n+  \/\/ Most registers are in use; we'll use rax, rbx, rcx, rdx, rsi, rdi\n@@ -186,2 +186,5 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n-  const Register temp_reg           = rdi;\n+  const Register resolved_klass_reg = rdi; \/\/ resolved interface klass (REFC)\n+  const Register temp_reg           = rdx;\n+  const Register method             = rbx;\n+  const Register icholder_reg       = rax;\n+  const Register receiver           = rcx;\n@@ -189,1 +192,0 @@\n-  const Register icholder_reg = rax;\n@@ -201,0 +203,1 @@\n+  __ push(rdx); \/\/ temp_reg\n@@ -203,11 +206,0 @@\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n@@ -215,8 +207,9 @@\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, rcx, noreg); \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n-\n+  __ lookup_interface_method_stub(recv_klass_reg, \/\/ input\n+                                  holder_klass_reg, \/\/ input\n+                                  resolved_klass_reg, \/\/ input\n+                                  method, \/\/ output\n+                                  temp_reg,\n+                                  noreg,\n+                                  receiver, \/\/ input (x86_32 only: to restore recv_klass value)\n+                                  itable_index,\n+                                  L_no_such_interface);\n@@ -229,1 +222,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = lookupSize + index_dependent_slop;\n@@ -249,0 +242,1 @@\n+  __ pop(rdx);\n@@ -258,0 +252,1 @@\n+  __ pop(rdx);\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r14; \/\/ resolved interface klass (REFC)\n@@ -180,0 +180,3 @@\n+  const Register temp_reg2          = r13;\n+  const Register method             = rbx;\n+  const Register icholder_reg       = rax;\n@@ -181,1 +184,0 @@\n-  const Register icholder_reg = rax;\n@@ -195,11 +197,0 @@\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n@@ -207,7 +198,9 @@\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, j_rarg0, temp_reg);   \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n+  __ lookup_interface_method_stub(recv_klass_reg, \/\/ input\n+                                  holder_klass_reg, \/\/ input\n+                                  resolved_klass_reg, \/\/ input\n+                                  method, \/\/ output\n+                                  temp_reg,\n+                                  temp_reg2,\n+                                  noreg,\n+                                  itable_index,\n+                                  L_no_such_interface);\n@@ -221,1 +214,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = lookupSize + index_dependent_slop;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -8096,1 +8096,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8119,1 +8119,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8141,1 +8141,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8163,1 +8163,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8185,1 +8185,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8206,1 +8206,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -10629,34 +10629,0 @@\n-\/\/ Convert Int to Boolean\n-instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n@@ -10675,1 +10641,1 @@\n-    __ setl($dst$$Register);\n+    __ setb(Assembler::less, $dst$$Register);\n@@ -12831,1 +12797,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -12857,1 +12823,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -12883,1 +12849,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -3005,0 +3005,6 @@\n+\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfrEvents.hpp\"\n+#endif\n@@ -104,0 +107,1 @@\n+  #include <mach\/task_info.h>\n@@ -2456,0 +2460,28 @@\n+\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {\n+#ifdef __APPLE__\n+  mach_task_basic_info info;\n+  mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;\n+\n+  kern_return_t ret = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count);\n+  if (ret == KERN_SUCCESS) {\n+    \/\/ Send the RSS JFR event\n+    EventResidentSetSize event;\n+    event.set_size(info.resident_size);\n+    event.set_peak(info.resident_size_max);\n+    event.commit();\n+  } else {\n+    \/\/ Log a warning\n+    static bool first_warning = true;\n+    if (first_warning) {\n+      log_warning(jfr)(\"Error fetching RSS values: task_info failed\");\n+      first_warning = false;\n+    }\n+  }\n+\n+#endif \/\/ __APPLE__\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,4 +49,5 @@\n-  long _total_cpu_nanos;\n-  long _total_csr_nanos;\n-  long _jvm_user_nanos;\n-  long _jvm_system_nanos;\n+#ifdef __APPLE__\n+  uint64_t _total_cpu_nanos;\n+  uint64_t _total_csr_nanos;\n+  uint64_t _jvm_user_nanos;\n+  uint64_t _jvm_system_nanos;\n@@ -58,1 +59,1 @@\n-  bool now_in_nanos(long* resultp) {\n+  bool now_in_nanos(uint64_t* resultp) {\n@@ -68,0 +69,1 @@\n+#endif\n@@ -86,0 +88,1 @@\n+#ifdef __APPLE__\n@@ -94,0 +97,1 @@\n+#endif\n@@ -161,2 +165,2 @@\n-  long jvm_user_nanos = absolutetime_info->total_user;\n-  long jvm_system_nanos = absolutetime_info->total_system;\n+  uint64_t jvm_user_nanos = absolutetime_info->total_user;\n+  uint64_t jvm_system_nanos = absolutetime_info->total_system;\n@@ -164,1 +168,1 @@\n-  long total_cpu_nanos;\n+  uint64_t total_cpu_nanos;\n@@ -172,1 +176,6 @@\n-  }\n+  } else {\n+    uint64_t delta_nanos = active_processor_count * (total_cpu_nanos - _total_cpu_nanos);\n+    if (delta_nanos == 0) {\n+      \/\/ Avoid division by zero\n+      return OS_ERR;\n+    }\n@@ -174,4 +183,2 @@\n-  long delta_nanos = active_processor_count * (total_cpu_nanos - _total_cpu_nanos);\n-  if (delta_nanos == 0) {\n-    \/\/ Avoid division by zero\n-    return OS_ERR;\n+    *pjvmUserLoad = normalize((double)(jvm_user_nanos - _jvm_user_nanos)\/delta_nanos);\n+    *pjvmKernelLoad = normalize((double)(jvm_system_nanos - _jvm_system_nanos)\/delta_nanos);\n@@ -180,3 +187,0 @@\n-  *pjvmUserLoad = normalize((double)(jvm_user_nanos - _jvm_user_nanos)\/delta_nanos);\n-  *pjvmKernelLoad = normalize((double)(jvm_system_nanos - _jvm_system_nanos)\/delta_nanos);\n-\n@@ -212,1 +216,1 @@\n-  long total_csr_nanos;\n+  uint64_t total_csr_nanos;\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -80,0 +80,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfrEvents.hpp\"\n+#endif\n@@ -930,0 +933,9 @@\n+  \/\/ Add an additional page to the stack size to reduce its chances of getting large page aligned\n+  \/\/ so that the stack does not get backed by a transparent huge page.\n+  size_t default_large_page_size = os::Linux::default_large_page_size();\n+  if (default_large_page_size != 0 &&\n+      stack_size >= default_large_page_size &&\n+      is_aligned(stack_size, default_large_page_size)) {\n+    stack_size += os::vm_page_size();\n+  }\n+\n@@ -2464,0 +2476,22 @@\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {\n+  os::Linux::meminfo_t info;\n+  if (os::Linux::query_process_memory_info(&info)) {\n+    \/\/ Send the RSS JFR event\n+    EventResidentSetSize event;\n+    event.set_size(info.vmrss * K);\n+    event.set_peak(info.vmhwm * K);\n+    event.commit();\n+  } else {\n+    \/\/ Log a warning\n+    static bool first_warning = true;\n+    if (first_warning) {\n+      log_warning(jfr)(\"Error fetching RSS values: query_process_memory_info failed\");\n+      first_warning = false;\n+    }\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -3748,2 +3782,5 @@\n-  \/\/ 1) Handle the case where we do not want to use huge pages and hence\n-  \/\/    there is no need to scan the OS for related info\n+  \/\/ Always initialize the default large page size even if large pages are not being used.\n+  size_t default_large_page_size = scan_default_large_page_size();\n+  os::Linux::_default_large_page_size = default_large_page_size;\n+\n+  \/\/ 1) Handle the case where we do not want to use huge pages\n@@ -3767,3 +3804,1 @@\n-  \/\/ 2) Scan OS info\n-  size_t default_large_page_size = scan_default_large_page_size();\n-  os::Linux::_default_large_page_size = default_large_page_size;\n+  \/\/ 2) check if large pages are configured\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfrEvents.hpp\"\n+#endif\n@@ -6025,0 +6028,27 @@\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {\n+  PROCESS_MEMORY_COUNTERS_EX pmex;\n+  ZeroMemory(&pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));\n+  pmex.cb = sizeof(pmex);\n+\n+  BOOL ret = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &pmex, sizeof(pmex));\n+  if (ret != 0) {\n+    \/\/ Send the RSS JFR event\n+    EventResidentSetSize event;\n+    event.set_size(pmex.WorkingSetSize);\n+    event.set_peak(pmex.PeakWorkingSetSize);\n+    event.commit();\n+  } else {\n+    \/\/ Log a warning\n+    static bool first_warning = true;\n+    if (first_warning) {\n+      log_warning(jfr)(\"Error fetching RSS values: GetProcessMemoryInfo failed\");\n+      first_warning = false;\n+    }\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-define_pd_global(intx, ThreadStackSize,          2048); \/\/ 0 => use system default\n-define_pd_global(intx, VMThreadStackSize,        2048);\n@@ -36,1 +34,11 @@\n-define_pd_global(intx, CompilerThreadStackSize,  2048);\n+\/\/ Set default stack sizes < 2MB so as to prevent stacks from getting\n+\/\/ large-page aligned and backed by THPs on systems where 2MB is the\n+\/\/ default huge page size. For non-JavaThreads, glibc may add an additional\n+\/\/ guard page to the total stack size, so to keep the default sizes same\n+\/\/ for all the following flags, we set them to 2 pages less than 2MB. On\n+\/\/ systems where 2MB is the default large page size, 4KB is most commonly\n+\/\/ the regular page size.\n+define_pd_global(intx, ThreadStackSize,          2040); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        2040);\n+\n+define_pd_global(intx, CompilerThreadStackSize,  2040);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/globals_linux_aarch64.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != nullptr;) {\n@@ -305,1 +305,1 @@\n-  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != nullptr;) {\n@@ -368,1 +368,1 @@\n-  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != nullptr;) {\n@@ -393,1 +393,1 @@\n-  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != NULL;) {\n+  for (pipeline->_reslist.reset(); (resource = pipeline->_reslist.iter()) != nullptr;) {\n@@ -1009,1 +1009,1 @@\n-  for (_pipeline->_reslist.reset(); (resource = _pipeline->_reslist.iter()) != NULL;) {\n+  for (_pipeline->_reslist.reset(); (resource = _pipeline->_reslist.iter()) != nullptr;) {\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1253,0 +1253,1 @@\n+  clear();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,0 +187,4 @@\n+  RegSetIterator<RegImpl>& operator=(const RegSetIterator<RegImpl>& mit) {\n+    _regs= mit._regs;\n+    return *this;\n+  }\n@@ -197,0 +201,4 @@\n+\n+  AbstractRegSet<RegImpl> remaining() const {\n+    return _regs;\n+  }\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,3 +126,3 @@\n-            case Bytecodes::_ladd: set_constant(a + b); return;\n-            case Bytecodes::_lsub: set_constant(a - b); return;\n-            case Bytecodes::_lmul: set_constant(a * b); return;\n+            case Bytecodes::_ladd: set_constant(java_add(a, b)); return;\n+            case Bytecodes::_lsub: set_constant(java_subtract(a, b)); return;\n+            case Bytecodes::_lmul: set_constant(java_multiply(a, b)); return;\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2248,1 +2248,1 @@\n-    int key = x->lo_key();\n+    int low = x->lo_key();\n@@ -2250,2 +2250,3 @@\n-    C1SwitchRange* range = new C1SwitchRange(key, sux);\n-    for (int i = 0; i < len; i++, key++) {\n+    C1SwitchRange* range = new C1SwitchRange(low, sux);\n+    for (int i = 0; i < len; i++) {\n+      int key = low + i;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-  assert(ent != NULL, \"sanity\");\n+  assert(ent != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  int hash() { return ident() * 31; } \/\/ ???\n+  uint hash() { return ident() * 31; } \/\/ ???\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-int ciObject::hash() {\n+uint ciObject::hash() {\n","filename":"src\/hotspot\/share\/ci\/ciObject.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  int hash();\n+  uint hash();\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  _unloading_next(nullptr),\n@@ -303,0 +304,40 @@\n+void ClassLoaderData::demote_strong_roots() {\n+  \/\/ The oop handle area contains strong roots that the GC traces from. We are about\n+  \/\/ to demote them to strong native oops that the GC does *not* trace from. Conceptually,\n+  \/\/ we are retiring a rather normal strong root, and creating a strong non-root handle,\n+  \/\/ which happens to reuse the same address as the normal strong root had.\n+  \/\/ Unless we invoke the right barriers, the GC might not notice that a strong root\n+  \/\/ has been pulled from the system, and is left unprocessed by the GC. There can be\n+  \/\/ several consequences:\n+  \/\/ 1. A concurrently marking snapshot-at-the-beginning GC might assume that the contents\n+  \/\/    of all strong roots get processed by the GC in order to keep them alive. Without\n+  \/\/    barriers, some objects might not be kept alive.\n+  \/\/ 2. A concurrently relocating GC might assume that after moving an object, a subsequent\n+  \/\/    tracing from all roots can fix all the pointers in the system, which doesn't play\n+  \/\/    well with roots racingly being pulled.\n+  \/\/ 3. A concurrent GC using colored pointers, might assume that tracing the object graph\n+  \/\/    from roots results in all pointers getting some particular color, which also doesn't\n+  \/\/    play well with roots being pulled out from the system concurrently.\n+\n+  class TransitionRootsOopClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ By loading the strong root with the access API, we can use the right barriers to\n+      \/\/ store the oop as a strong non-root handle, that happens to reuse the same memory\n+      \/\/ address as the strong root. The barriered store ensures that:\n+      \/\/ 1. The concurrent SATB marking properties are satisfied as the store will keep\n+      \/\/    the oop alive.\n+      \/\/ 2. The concurrent object movement properties are satisfied as we store the address\n+      \/\/    of the new location of the object, if any.\n+      \/\/ 3. The colors if any will be stored as the new good colors.\n+      oop obj = NativeAccess<>::oop_load(p); \/\/ Load the strong root\n+      NativeAccess<>::oop_store(p, obj); \/\/ Store the strong non-root\n+    }\n+\n+    virtual void do_oop(narrowOop* p) {\n+      ShouldNotReachHere();\n+    }\n+  } cl;\n+  oops_do(&cl, ClassLoaderData::_claim_none, false \/* clear_mod_oops *\/);\n+}\n+\n@@ -318,0 +359,8 @@\n+    if (_keep_alive == 1) {\n+      \/\/ When the keep_alive counter is 1, the oop handle area is a strong root,\n+      \/\/ acting as input to the GC tracing. Such strong roots are part of the\n+      \/\/ snapshot-at-the-beginning, and can not just be pulled out from the\n+      \/\/ system when concurrent GCs are running at the same time, without\n+      \/\/ invoking the right barriers.\n+      demote_strong_roots();\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -156,1 +156,23 @@\n-  ClassLoaderData* _next; \/\/\/ Next loader_datas created\n+  \/\/\n+  \/\/ The ClassLoaderDataGraph maintains two lists to keep track of CLDs.\n+  \/\/\n+  \/\/ The first list [_head, _next] is where new CLDs are registered. The CLDs\n+  \/\/ are only inserted at the _head, and the _next pointers are only rewritten\n+  \/\/ from unlink_next() which unlinks one unloading CLD by setting _next to\n+  \/\/ _next->_next. This allows GCs to concurrently walk the list while the CLDs\n+  \/\/ are being concurrently unlinked.\n+  \/\/\n+  \/\/ The second list [_unloading_head, _unloading_next] is where dead CLDs get\n+  \/\/ moved to during class unloading. See: ClassLoaderDataGraph::do_unloading().\n+  \/\/ This list is never modified while other threads are iterating over it.\n+  \/\/\n+  \/\/ After all dead CLDs have been moved to the unloading list, there's a\n+  \/\/ synchronization point (handshake) to ensure that all threads reading these\n+  \/\/ CLDs finish their work. This ensures that we don't have a use-after-free\n+  \/\/ when we later delete the CLDs.\n+  \/\/\n+  \/\/ And finally, when no threads are using the unloading CLDs anymore, we\n+  \/\/ remove them from the class unloading list and delete them. See:\n+  \/\/ ClassLoaderDataGraph::purge();\n+  ClassLoaderData* _next;\n+  ClassLoaderData* _unloading_next;\n@@ -163,2 +185,6 @@\n-  void set_next(ClassLoaderData* next) { Atomic::store(&_next, next); }\n-  ClassLoaderData* next() const        { return Atomic::load(&_next); }\n+  void set_next(ClassLoaderData* next);\n+  ClassLoaderData* next() const;\n+  void unlink_next();\n+\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n@@ -197,0 +223,2 @@\n+  void demote_strong_roots();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,0 +36,23 @@\n+inline void ClassLoaderData::set_next(ClassLoaderData* next) {\n+  assert(this->next() == nullptr, \"only link once\");\n+  Atomic::store(&_next, next);\n+}\n+\n+inline ClassLoaderData* ClassLoaderData::next() const {\n+  return Atomic::load(&_next);\n+}\n+\n+inline void ClassLoaderData::unlink_next() {\n+  assert(next()->is_unloading(), \"only remove unloading clds\");\n+  Atomic::store(&_next, _next->_next);\n+}\n+\n+inline void ClassLoaderData::set_unloading_next(ClassLoaderData* unloading_next) {\n+  assert(this->unloading_next() == nullptr, \"only link once\");\n+  _unloading_next = unloading_next;\n+}\n+\n+inline ClassLoaderData* ClassLoaderData::unloading_next() const {\n+  return _unloading_next;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderData.inline.hpp\"\n@@ -203,1 +204,1 @@\n-\/\/ GC root of class loader data created.\n+\/\/ List head of all class loader data.\n@@ -205,1 +206,1 @@\n-ClassLoaderData* ClassLoaderDataGraph::_unloading = nullptr;\n+ClassLoaderData* ClassLoaderDataGraph::_unloading_head = nullptr;\n@@ -271,10 +272,1 @@\n-void ClassLoaderDataGraph::cld_unloading_do(CLDClosure* cl) {\n-  assert_is_safepoint_or_gc();\n-  for (ClassLoaderData* cld = _unloading; cld != nullptr; cld = cld->next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cl->do_cld(cld);\n-  }\n-}\n-\n-\/\/ These are functions called by the GC, which require all of the CLDs, including the\n-\/\/ unloading ones.\n+\/\/ These are functions called by the GC, which require all of the CLDs, including not yet unlinked CLDs.\n@@ -433,1 +425,1 @@\n-  for (ClassLoaderData* cld = _unloading; cld != nullptr; cld = cld->next()) {\n+  for (ClassLoaderData* cld = _unloading_head; cld != nullptr; cld = cld->unloading_next()) {\n@@ -504,1 +496,0 @@\n-  ClassLoaderData* data = _head;\n@@ -510,2 +501,1 @@\n-  data = _head;\n-  while (data != nullptr) {\n+  for (ClassLoaderData* data = _head; data != nullptr; data = data->next()) {\n@@ -514,1 +504,0 @@\n-      data = data->next();\n@@ -516,12 +505,0 @@\n-      continue;\n-    }\n-    seen_dead_loader = true;\n-    loaders_removed++;\n-    ClassLoaderData* dead = data;\n-    dead->unload();\n-    data = data->next();\n-    \/\/ Remove from loader list.\n-    \/\/ This class loader data will no longer be found\n-    \/\/ in the ClassLoaderDataGraph.\n-    if (prev != nullptr) {\n-      prev->set_next(data);\n@@ -529,3 +506,15 @@\n-      assert(dead == _head, \"sanity check\");\n-      \/\/ The GC might be walking this concurrently\n-      Atomic::store(&_head, data);\n+      \/\/ Found dead CLD.\n+      loaders_removed++;\n+      seen_dead_loader = true;\n+      data->unload();\n+\n+      \/\/ Move dead CLD to unloading list.\n+      if (prev != nullptr) {\n+        prev->unlink_next();\n+      } else {\n+        assert(data == _head, \"sanity check\");\n+        \/\/ The GC might be walking this concurrently\n+        Atomic::store(&_head, data->next());\n+      }\n+      data->set_unloading_next(_unloading_head);\n+      _unloading_head = data;\n@@ -533,2 +522,0 @@\n-    dead->set_next(_unloading);\n-    _unloading = dead;\n@@ -566,2 +553,2 @@\n-  ClassLoaderData* list = _unloading;\n-  _unloading = nullptr;\n+  ClassLoaderData* list = _unloading_head;\n+  _unloading_head = nullptr;\n@@ -572,1 +559,1 @@\n-    next = purge_me->next();\n+    next = purge_me->unloading_next();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  \/\/ All CLDs (except the null CLD) can be reached by walking _head->_next->...\n+  \/\/ All CLDs (except unlinked CLDs) can be reached by walking _head->_next->...\n@@ -46,1 +46,2 @@\n-  static ClassLoaderData* _unloading;\n+  \/\/ All unlinked CLDs\n+  static ClassLoaderData* _unloading_head;\n@@ -70,1 +71,1 @@\n-  \/\/ Iteration through CLDG inside a safepoint; GC support\n+  \/\/ Iteration through CLDG; GC support\n@@ -72,1 +73,0 @@\n-  static void cld_unloading_do(CLDClosure* cl);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -228,6 +228,1 @@\n-    int old_val = 0;\n-    int new_val = 0;\n-    do {\n-      old_val = Atomic::load(&_defined_by_cds_in_class_path);\n-      new_val = old_val | ((int)1 << idx);\n-    } while (Atomic::cmpxchg(&_defined_by_cds_in_class_path, old_val, new_val) != old_val);\n+    Atomic::fetch_then_or(&_defined_by_cds_in_class_path, ((int)1 << idx));\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  static oop init_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop init_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+  template(java_lang_ScopedValue,                     \"java\/lang\/ScopedValue\")                    \\\n+  template(java_lang_ScopedValue_Carrier,             \"java\/lang\/ScopedValue$Carrier\")            \\\n@@ -160,2 +162,0 @@\n-  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n-  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    assert(_cached_value != nullptr, \"must be non-nullptr\");\n+    assert(_cached_value != nullptr, \"must be non-null\");\n@@ -342,1 +342,1 @@\n-  \/\/ Returns NULL if CodeBuffer::expand fails\n+  \/\/ Returns null if CodeBuffer::expand fails\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  \/\/ If _first is nullptr we have no more compile jobs. There are two reasons for\n+  \/\/ If _first is null we have no more compile jobs. There are two reasons for\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,4 +213,0 @@\n-  \/\/ print compiler name if requested\n-  if (CIPrintCompilerName) {\n-    tty->print(\"%s:\", CompileBroker::compiler_name(comp_level()));\n-  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-    if (EnableJVMCI) {\n+    if (EnableJVMCI || UseJVMCICompiler) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  develop(bool, CIPrintCompilerName, false,                                 \\\n+  product(bool, CIPrintCompilerName, false, DIAGNOSTIC,                     \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                                               PhaseTransform* phase,\n+                                               PhaseValues* phase,\n@@ -306,1 +306,1 @@\n-                                                PhaseTransform* phase, Node* store,\n+                                                PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                                 PhaseTransform* phase,\n+                                 PhaseValues* phase,\n@@ -64,1 +64,1 @@\n-                                  PhaseTransform* phase, Node* store,\n+                                  PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,7 +147,7 @@\n-  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(thread);\n-  assert(!queue.is_active(), \"SATB queue should not be active\");\n-  assert(queue.buffer() == nullptr, \"SATB queue should not have a buffer\");\n-  assert(queue.index() == 0, \"SATB queue index should be zero\");\n-  \/\/ Can't assert that the DCQ is empty.  There is early execution on\n-  \/\/ the main thread, before it gets added to the threads list, which\n-  \/\/ is where this is called.  That execution may enqueue dirty cards.\n+  SATBMarkQueue& satbq = G1ThreadLocalData::satb_mark_queue(thread);\n+  assert(!satbq.is_active(), \"SATB queue should not be active\");\n+  assert(satbq.buffer() == nullptr, \"SATB queue should not have a buffer\");\n+  assert(satbq.index() == 0, \"SATB queue index should be zero\");\n+  G1DirtyCardQueue& dirtyq = G1ThreadLocalData::dirty_card_queue(thread);\n+  assert(dirtyq.buffer() == nullptr, \"Dirty Card queue should not have a buffer\");\n+  assert(dirtyq.index() == 0, \"Dirty Card queue index should be zero\");\n@@ -158,1 +158,1 @@\n-  queue.set_active(_satb_mark_queue_set.is_active());\n+  satbq.set_active(_satb_mark_queue_set.is_active());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  G1BarrierSet::dirty_card_queue_set().flush_queue(*this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-  bool is_valid_gen() const            { return (type() >= Young && type() <= Old); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  assert(UseG1GC || UseParallelGC || UseSerialGC,\n+  assert(UseG1GC || UseParallelGC || UseSerialGC || UseShenandoahGC,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -45,0 +46,9 @@\n+  if (UseShenandoahGC) {\n+#if INCLUDE_SHENANDOAHGC\n+    if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+      return Shenandoah;\n+    }\n+#endif\n+    return NA;\n+  }\n+\n@@ -52,5 +62,0 @@\n-\n-  if (UseShenandoahGC) {\n-    return NA;\n-  }\n-\n@@ -69,0 +74,9 @@\n+  if (UseShenandoahGC) {\n+#if INCLUDE_SHENANDOAHGC\n+    if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+      return Shenandoah;\n+    }\n+#endif\n+    return NA;\n+  }\n+\n@@ -76,5 +90,0 @@\n-\n-  if (UseShenandoahGC) {\n-    return Shenandoah;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfiguration.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+const char* VM_GC_Operation::cause() const {\n+  return GCCause::to_string(_gc_cause);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,0 +140,2 @@\n+  virtual const char* cause() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,6 +281,1 @@\n-                                              bool is_tlab,\n-                                              bool* gc_overhead_limit_was_exceeded) {\n-  \/\/ In general gc_overhead_limit_was_exceeded should be false so\n-  \/\/ set it so here and reset it to true only if the gc time\n-  \/\/ limit is being exceeded as checked below.\n-  *gc_overhead_limit_was_exceeded = false;\n+                                              bool is_tlab) {\n@@ -368,17 +363,0 @@\n-      \/\/ Allocation has failed and a collection\n-      \/\/ has been done.  If the gc time limit was exceeded the\n-      \/\/ this time, return null so that an out-of-memory\n-      \/\/ will be thrown.  Clear gc_overhead_limit_exceeded\n-      \/\/ so that the overhead exceeded does not persist.\n-\n-      const bool limit_exceeded = size_policy()->gc_overhead_limit_exceeded();\n-      const bool softrefs_clear = soft_ref_policy()->all_soft_refs_clear();\n-\n-      if (limit_exceeded && softrefs_clear) {\n-        *gc_overhead_limit_was_exceeded = true;\n-        size_policy()->set_gc_overhead_limit_exceeded(false);\n-        if (op.result() != nullptr) {\n-          CollectedHeap::fill_with_object(op.result(), size);\n-        }\n-        return nullptr;\n-      }\n@@ -421,2 +399,1 @@\n-                           false \/* is_tlab *\/,\n-                           gc_overhead_limit_was_exceeded);\n+                           false \/* is_tlab *\/);\n@@ -938,1 +915,0 @@\n-  bool gc_overhead_limit_was_exceeded;\n@@ -940,2 +916,1 @@\n-                                       true \/* is_tlab *\/,\n-                                       &gc_overhead_limit_was_exceeded);\n+                                       true \/* is_tlab *\/);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -379,2 +379,1 @@\n-                              bool is_tlab,\n-                              bool* gc_overhead_limit_was_exceeded);\n+                              bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -216,3 +216,5 @@\n-  \/\/ Keep alloc_frac as float and not double to avoid the double to float conversion\n-  float alloc_frac = desired_size() * target_refills() \/ (float) capacity;\n-  _allocation_fraction.sample(alloc_frac);\n+  if (capacity > 0) {\n+    \/\/ Keep alloc_frac as float and not double to avoid the double to float conversion\n+    float alloc_frac = desired_size() * target_refills() \/ (float)capacity;\n+    _allocation_fraction.sample(alloc_frac);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -90,3 +90,0 @@\n-  \/\/ Make parsable and release it.\n-  void reset();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -196,0 +198,10 @@\n+\n+  if (access.is_oop()) {\n+    DecoratorSet decorators = access.decorators();\n+    bool is_array = (decorators & IS_ARRAY) != 0;\n+    bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+\n+    bool precise = is_array || on_anonymous;\n+    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n+    post_barrier(access, post_addr, value);\n+  }\n@@ -294,0 +306,61 @@\n+\n+void ShenandoahBarrierSetC1::post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val) {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  DecoratorSet decorators = access.decorators();\n+  LIRGenerator* gen = access.gen();\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  if (!in_heap) {\n+    return;\n+  }\n+\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n+  CardTable* ct = ctbs->card_table();\n+  LIR_Const* card_table_base = new LIR_Const(ct->byte_map_base());\n+  if (addr->is_address()) {\n+    LIR_Address* address = addr->as_address_ptr();\n+    \/\/ ptr cannot be an object because we use this barrier for array card marks\n+    \/\/ and addr can point in the middle of an array.\n+    LIR_Opr ptr = gen->new_pointer_register();\n+    if (!address->index()->is_valid() && address->disp() == 0) {\n+      __ move(address->base(), ptr);\n+    } else {\n+      assert(address->disp() != max_jint, \"lea doesn't support patched addresses!\");\n+      __ leal(addr, ptr);\n+    }\n+    addr = ptr;\n+  }\n+  assert(addr->is_register(), \"must be a register at this point\");\n+\n+  LIR_Opr tmp = gen->new_pointer_register();\n+  if (two_operand_lir_form) {\n+    __ move(addr, tmp);\n+    __ unsigned_shift_right(tmp, CardTable::card_shift(), tmp);\n+  } else {\n+    __ unsigned_shift_right(addr, CardTable::card_shift(), tmp);\n+  }\n+\n+  LIR_Address* card_addr;\n+  if (gen->can_inline_as_constant(card_table_base)) {\n+    card_addr = new LIR_Address(tmp, card_table_base->as_jint(), T_BYTE);\n+  } else {\n+    card_addr = new LIR_Address(tmp, gen->load_constant(card_table_base), T_BYTE);\n+  }\n+\n+  LIR_Opr dirty = LIR_OprFact::intConst(CardTable::dirty_card_val());\n+  if (UseCondCardMark) {\n+    LIR_Opr cur_value = gen->new_register(T_INT);\n+    __ move(card_addr, cur_value);\n+\n+    LabelObj* L_already_dirty = new LabelObj();\n+    __ cmp(lir_cond_equal, cur_value, dirty);\n+    __ branch(lir_cond_equal, L_already_dirty->label());\n+    __ move(dirty, card_addr);\n+    __ branch_destination(L_already_dirty->label());\n+  } else {\n+    __ move(dirty, card_addr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -247,0 +247,2 @@\n+  void post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -36,0 +37,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -100,1 +102,1 @@\n-bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -243,1 +245,1 @@\n-  marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));\n+  marking = __ AndI(ld, __ ConI(ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING));\n@@ -312,1 +314,1 @@\n-bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {\n+bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseValues* phase, Node* n) {\n@@ -324,1 +326,1 @@\n-      cmpx->in(1)->in(2) == phase->intcon(ShenandoahHeap::MARKING)) {\n+      cmpx->in(1)->in(2) == phase->intcon(ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING)) {\n@@ -453,0 +455,86 @@\n+Node* ShenandoahBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n+  CardTable::CardValue* card_table_base = ctbs->card_table()->byte_map_base();\n+  if (card_table_base != nullptr) {\n+    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n+  } else {\n+    return kit->null();\n+  }\n+}\n+\n+void ShenandoahBarrierSetC2::post_barrier(GraphKit* kit,\n+                                          Node* ctl,\n+                                          Node* oop_store,\n+                                          Node* obj,\n+                                          Node* adr,\n+                                          uint  adr_idx,\n+                                          Node* val,\n+                                          BasicType bt,\n+                                          bool use_precise) const {\n+  if (!ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  \/\/ No store check needed if we're storing a null.\n+  if (val != nullptr && val->is_Con()) {\n+    \/\/ must be either an oop or NULL\n+    const Type* t = val->bottom_type();\n+    if (t == TypePtr::NULL_PTR || t == Type::TOP)\n+      return;\n+  }\n+\n+  if (ReduceInitialCardMarks && obj == kit->just_allocated_object(kit->control())) {\n+    \/\/ We can skip marks on a freshly-allocated object in Eden.\n+    \/\/ Keep this code in sync with new_deferred_store_barrier() in runtime.cpp.\n+    \/\/ That routine informs GC to take appropriate compensating steps,\n+    \/\/ upon a slow-path allocation, so as to make this card-mark\n+    \/\/ elision safe.\n+    return;\n+  }\n+\n+  if (!use_precise) {\n+    \/\/ All card marks for a (non-array) instance are in one place:\n+    adr = obj;\n+  }\n+  \/\/ (Else it's an array (or unknown), and we want more precise card marks.)\n+  assert(adr != nullptr, \"\");\n+\n+  IdealKit ideal(kit, true);\n+\n+  \/\/ Convert the pointer to an int prior to doing math on it\n+  Node* cast = __ CastPX(__ ctrl(), adr);\n+\n+  \/\/ Divide by card size\n+  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift()) );\n+\n+  \/\/ Combine card table base and card offset\n+  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset );\n+\n+  \/\/ Get the alias_index for raw card-mark memory\n+  int adr_type = Compile::AliasIdxRaw;\n+  Node*   zero = __ ConI(0); \/\/ Dirty card value\n+\n+  if (UseCondCardMark) {\n+    \/\/ The classic GC reference write barrier is typically implemented\n+    \/\/ as a store into the global card mark table.  Unfortunately\n+    \/\/ unconditional stores can result in false sharing and excessive\n+    \/\/ coherence traffic as well as false transactional aborts.\n+    \/\/ UseCondCardMark enables MP \"polite\" conditional card mark\n+    \/\/ stores.  In theory we could relax the load from ctrl() to\n+    \/\/ no_ctrl, but that doesn't buy much latitude.\n+    Node* card_val = __ load( __ ctrl(), card_adr, TypeInt::BYTE, T_BYTE, adr_type);\n+    __ if_then(card_val, BoolTest::ne, zero);\n+  }\n+\n+  \/\/ Smash zero into card\n+  __ store(__ ctrl(), card_adr, zero, T_BYTE, adr_type, MemNode::unordered);\n+\n+  if (UseCondCardMark) {\n+    __ end_if();\n+  }\n+\n+  \/\/ Final sync IdealKit and GraphKit.\n+  kit->final_sync(ideal);\n+}\n+\n@@ -516,0 +604,9 @@\n+\n+    Node* result = BarrierSetC2::store_at_resolved(access, val);\n+\n+    bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+    bool is_array = (decorators & IS_ARRAY) != 0;\n+    bool use_precise = is_array || anonymous;\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 adr, adr_idx, val.node(), access.type(), use_precise);\n+    return result;\n@@ -526,0 +623,1 @@\n+    return BarrierSetC2::store_at_resolved(access, val);\n@@ -527,1 +625,0 @@\n-  return BarrierSetC2::store_at_resolved(access, val);\n@@ -598,1 +695,1 @@\n-                                                   Node* new_val, const Type* value_type) const {\n+                                                             Node* new_val, const Type* value_type) const {\n@@ -640,0 +737,2 @@\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n@@ -695,0 +794,2 @@\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 access.addr().node(), access.alias_idx(), new_val, T_OBJECT, true);\n@@ -711,0 +812,2 @@\n+    post_barrier(kit, kit->control(), access.raw_access(), access.base(),\n+                 access.addr().node(), access.alias_idx(), val, T_OBJECT, true);\n@@ -841,1 +944,1 @@\n-      flags |= ShenandoahHeap::MARKING;\n+      flags |= ShenandoahHeap::YOUNG_MARKING;\n@@ -909,3 +1012,19 @@\n-void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {\n-  if (is_shenandoah_wb_pre_call(n)) {\n-    shenandoah_eliminate_wb_pre(n, &macro->igvn());\n+void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {\n+  if (is_shenandoah_wb_pre_call(node)) {\n+    shenandoah_eliminate_wb_pre(node, &macro->igvn());\n+  }\n+  if (node->Opcode() == Op_CastP2X && ShenandoahHeap::heap()->mode()->is_generational()) {\n+    Node* shift = node->unique_out();\n+    Node* addp = shift->unique_out();\n+    for (DUIterator_Last jmin, j = addp->last_outs(jmin); j >= jmin; --j) {\n+      Node* mem = addp->last_out(j);\n+      if (UseCondCardMark && mem->is_Load()) {\n+        assert(mem->Opcode() == Op_LoadB, \"unexpected code shape\");\n+        \/\/ The load is checking if the card has been written so\n+        \/\/ replace it with zero to fold the test.\n+        macro->replace_node(mem, macro->intcon(0));\n+        continue;\n+      }\n+      assert(mem->is_Store(), \"store required\");\n+      macro->replace_node(mem, mem->in(MemNode::Memory));\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":129,"deletions":10,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -78,0 +78,12 @@\n+  Node* byte_map_base_node(GraphKit* kit) const;\n+\n+  void post_barrier(GraphKit* kit,\n+                    Node* ctl,\n+                    Node* store,\n+                    Node* obj,\n+                    Node* adr,\n+                    uint adr_idx,\n+                    Node* val,\n+                    BasicType bt,\n+                    bool use_precise) const;\n+\n@@ -97,1 +109,1 @@\n-  static bool is_shenandoah_marking_if(PhaseTransform *phase, Node* n);\n+  static bool is_shenandoah_marking_if(PhaseValues* phase, Node* n);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -1486,1 +1487,1 @@\n-    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::MARKING);\n+    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, (ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -32,0 +34,2 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -57,2 +61,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics() :\n-  ShenandoahHeuristics(),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation),\n@@ -61,1 +65,2 @@\n-  _last_trigger(OTHER) { }\n+  _last_trigger(OTHER),\n+  _available(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor) { }\n@@ -69,0 +74,2 @@\n+  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -87,4 +94,16 @@\n-  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n-  size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n-  size_t free_target = (capacity \/ 100 * ShenandoahMinFreeThreshold) + max_cset;\n-  size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n+  \/\/ In generational mode, the sort order within the data array is not strictly descending amounts of garbage.  In\n+  \/\/ particular, regions that have reached tenure age will be sorted into this array before younger regions that contain\n+  \/\/ more garbage.  This represents one of the reasons why we keep looking at regions even after we decide, for example,\n+  \/\/ to exclude one of the regions because it might require evacuation of too much live data.\n+  \/\/ TODO: Split it in the separate methods for clarity.\n+  bool is_generational = heap->mode()->is_generational();\n+  bool is_global = _generation->is_global();\n+  size_t capacity = heap->young_generation()->max_capacity();\n+\n+  \/\/ cur_young_garbage represents the amount of memory to be reclaimed from young-gen.  In the case that live objects\n+  \/\/ are known to be promoted out of young-gen, we count this as cur_young_garbage because this memory is reclaimed\n+  \/\/ from young-gen and becomes available to serve future young-gen allocation requests.\n+  size_t cur_young_garbage = 0;\n+\n+  \/\/ Better select garbage-first regions\n+  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n@@ -92,2 +111,105 @@\n-  log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n-                     SIZE_FORMAT \"%s, Max CSet: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n+  if (is_generational) {\n+    for (size_t idx = 0; idx < size; idx++) {\n+      ShenandoahHeapRegion* r = data[idx]._region;\n+      if (cset->is_preselected(r->index())) {\n+        assert(r->age() >= InitialTenuringThreshold, \"Preselected regions must have tenure age\");\n+        \/\/ Entire region will be promoted, This region does not impact young-gen or old-gen evacuation reserve.\n+        \/\/ This region has been pre-selected and its impact on promotion reserve is already accounted for.\n+\n+        \/\/ r->used() is r->garbage() + r->get_live_data_bytes()\n+        \/\/ Since all live data in this region is being evacuated from young-gen, it is as if this memory\n+        \/\/ is garbage insofar as young-gen is concerned.  Counting this as garbage reduces the need to\n+        \/\/ reclaim highly utilized young-gen regions just for the sake of finding min_garbage to reclaim\n+        \/\/ within youn-gen memory.\n+\n+        cur_young_garbage += r->garbage();\n+        cset->add_region(r);\n+      }\n+    }\n+    if (is_global) {\n+      size_t max_young_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t young_cur_cset = 0;\n+      size_t max_old_cset    = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahOldEvacWaste);\n+      size_t old_cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_young_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for GLOBAL. Max Young Evacuation: \" SIZE_FORMAT\n+                         \"%s, Max Old Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_young_cset),    proper_unit_for_byte_size(max_young_cset),\n+                         byte_size_in_proper_unit(max_old_cset),    proper_unit_for_byte_size(max_old_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        if (cset->is_preselected(r->index())) {\n+          continue;\n+        }\n+        bool add_region = false;\n+        if (r->is_old()) {\n+          size_t new_cset = old_cur_cset + r->get_live_data_bytes();\n+          if ((new_cset <= max_old_cset) && (r->garbage() > garbage_threshold)) {\n+            add_region = true;\n+            old_cur_cset = new_cset;\n+          }\n+        } else if (r->age() < InitialTenuringThreshold) {\n+          size_t new_cset = young_cur_cset + r->get_live_data_bytes();\n+          size_t region_garbage = r->garbage();\n+          size_t new_garbage = cur_young_garbage + region_garbage;\n+          bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+          if ((new_cset <= max_young_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+            add_region = true;\n+            young_cur_cset = new_cset;\n+            cur_young_garbage = new_garbage;\n+          }\n+        }\n+        \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n+        \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects.\n+\n+        if (add_region) {\n+          cset->add_region(r);\n+        }\n+      }\n+    } else {\n+      \/\/ This is young-gen collection or a mixed evacuation.  If this is mixed evacuation, the old-gen candidate regions\n+      \/\/ have already been added.\n+      size_t max_cset    = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+      size_t cur_cset = 0;\n+      size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+      size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+      log_info(gc, ergo)(\"Adaptive CSet Selection for YOUNG. Max Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n+                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+\n+      for (size_t idx = 0; idx < size; idx++) {\n+        ShenandoahHeapRegion* r = data[idx]._region;\n+        if (cset->is_preselected(r->index())) {\n+          continue;\n+        }\n+        if  (r->age() < InitialTenuringThreshold) {\n+          size_t new_cset = cur_cset + r->get_live_data_bytes();\n+          size_t region_garbage = r->garbage();\n+          size_t new_garbage = cur_young_garbage + region_garbage;\n+          bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+          assert(r->is_young(), \"Only young candidates expected in the data array\");\n+          if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+            cur_cset = new_cset;\n+            cur_young_garbage = new_garbage;\n+            cset->add_region(r);\n+          }\n+        }\n+        \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n+        \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects or because\n+        \/\/ they are to be promoted in place.\n+      }\n+    }\n+  } else {\n+    \/\/ Traditional Shenandoah (non-generational)\n+    size_t capacity    = ShenandoahHeap::heap()->max_capacity();\n+    size_t max_cset    = (size_t)((1.0 * capacity \/ 100 * ShenandoahEvacReserve) \/ ShenandoahEvacWaste);\n+    size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+    size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+\n+    log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n+                     SIZE_FORMAT \"%s, Max Evacuation: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n@@ -99,2 +221,2 @@\n-  \/\/ Better select garbage-first regions\n-  QuickSort::sort<RegionData>(data, (int)size, compare_by_garbage, false);\n+    size_t cur_cset = 0;\n+    size_t cur_garbage = 0;\n@@ -102,2 +224,2 @@\n-  size_t cur_cset = 0;\n-  size_t cur_garbage = 0;\n+    for (size_t idx = 0; idx < size; idx++) {\n+      ShenandoahHeapRegion* r = data[idx]._region;\n@@ -105,2 +227,2 @@\n-  for (size_t idx = 0; idx < size; idx++) {\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+      size_t new_cset    = cur_cset + r->get_live_data_bytes();\n+      size_t new_garbage = cur_garbage + r->garbage();\n@@ -108,2 +230,3 @@\n-    size_t new_cset    = cur_cset + r->get_live_data_bytes();\n-    size_t new_garbage = cur_garbage + r->garbage();\n+      if (new_cset > max_cset) {\n+        break;\n+      }\n@@ -111,8 +234,5 @@\n-    if (new_cset > max_cset) {\n-      break;\n-    }\n-\n-    if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n-      cset->add_region(r);\n-      cur_cset = new_cset;\n-      cur_garbage = new_garbage;\n+      if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n+        cset->add_region(r);\n+        cur_cset = new_cset;\n+        cur_garbage = new_garbage;\n+      }\n@@ -121,0 +241,10 @@\n+\n+  size_t collected_old = cset->get_old_bytes_reserved_for_evacuation();\n+  size_t collected_promoted = cset->get_young_bytes_to_be_promoted();\n+  size_t collected_young = cset->get_young_bytes_reserved_for_evacuation();\n+\n+  log_info(gc, ergo)(\"Chosen CSet evacuates young: \" SIZE_FORMAT \"%s (of which at least: \" SIZE_FORMAT \"%s are to be promoted), \"\n+                     \"old: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(collected_young),    proper_unit_for_byte_size(collected_young),\n+                     byte_size_in_proper_unit(collected_promoted), proper_unit_for_byte_size(collected_promoted),\n+                     byte_size_in_proper_unit(collected_old),      proper_unit_for_byte_size(collected_old));\n@@ -128,2 +258,2 @@\n-void ShenandoahAdaptiveHeuristics::record_success_concurrent() {\n-  ShenandoahHeuristics::record_success_concurrent();\n+void ShenandoahAdaptiveHeuristics::record_success_concurrent(bool abbreviated) {\n+  ShenandoahHeuristics::record_success_concurrent(abbreviated);\n@@ -131,1 +261,1 @@\n-  size_t available = ShenandoahHeap::heap()->free_set()->available();\n+  size_t available = MIN2(_generation->available(), ShenandoahHeap::heap()->free_set()->available());\n@@ -133,1 +263,0 @@\n-  _available.add(available);\n@@ -135,2 +264,10 @@\n-  if (_available.sd() > 0) {\n-    z_score = (available - _available.avg()) \/ _available.sd();\n+  double available_sd = _available.sd();\n+  if (available_sd > 0) {\n+    double available_avg = _available.avg();\n+    z_score = (double(available) - available_avg) \/ available_sd;\n+    log_debug(gc, ergo)(\"%s Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n+                        _generation->name(),\n+                        byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                        z_score,\n+                        byte_size_in_proper_unit(available_avg), proper_unit_for_byte_size(available_avg),\n+                        byte_size_in_proper_unit(available_sd),  proper_unit_for_byte_size(available_sd));\n@@ -139,5 +276,1 @@\n-  log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n-                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                      z_score,\n-                      byte_size_in_proper_unit(_available.avg()), proper_unit_for_byte_size(_available.avg()),\n-                      byte_size_in_proper_unit(_available.sd()), proper_unit_for_byte_size(_available.sd()));\n+  _available.add(double(available));\n@@ -198,6 +331,19 @@\n-bool ShenandoahAdaptiveHeuristics::should_start_gc() {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n-  size_t allocated = heap->bytes_allocated_since_gc_start();\n+\/\/ Return a conservative estimate of how much memory can be allocated before we need to start GC. The estimate is based\n+\/\/ on memory that is currently available within young generation plus all of the memory that will be added to the young\n+\/\/ generation at the end of the current cycle (as represented by young_regions_to_be_reclaimed) and on the anticipated\n+\/\/ amount of time required to perform a GC.\n+size_t ShenandoahAdaptiveHeuristics::bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_reclaimed) {\n+  assert(_generation->is_young(), \"Only meaningful for young-gen heuristic\");\n+\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t usage = _generation->used();\n+  size_t available = (capacity > usage)? capacity - usage: 0;\n+  size_t allocated = _generation->bytes_allocated_since_gc_start();\n+\n+  size_t available_young_collected = ShenandoahHeap::heap()->collection_set()->get_young_available_bytes_collected();\n+  size_t anticipated_available =\n+    available + young_regions_to_be_reclaimed * ShenandoahHeapRegion::region_size_bytes() - available_young_collected;\n+  size_t allocation_headroom = anticipated_available;\n+  size_t spike_headroom = capacity * ShenandoahAllocSpikeFactor \/ 100;\n+  size_t penalties      = capacity * _gc_time_penalties \/ 100;\n@@ -205,3 +351,76 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  double rate = _allocation_rate.sample(allocated);\n+\n+  \/\/ At what value of available, would avg and spike triggers occur?\n+  \/\/  if allocation_headroom < avg_cycle_time * avg_alloc_rate, then we experience avg trigger\n+  \/\/  if allocation_headroom < avg_cycle_time * rate, then we experience spike trigger if is_spiking\n+  \/\/\n+  \/\/ allocation_headroom =\n+  \/\/     0, if penalties > available or if penalties + spike_headroom > available\n+  \/\/     available - penalties - spike_headroom, otherwise\n+  \/\/\n+  \/\/ so we trigger if available - penalties - spike_headroom < avg_cycle_time * avg_alloc_rate, which is to say\n+  \/\/                  available < avg_cycle_time * avg_alloc_rate + penalties + spike_headroom\n+  \/\/            or if available < penalties + spike_headroom\n+  \/\/\n+  \/\/ since avg_cycle_time * avg_alloc_rate > 0, the first test is sufficient to test both conditions\n+  \/\/\n+  \/\/ thus, evac_slack_avg is MIN2(0,  available - avg_cycle_time * avg_alloc_rate + penalties + spike_headroom)\n+  \/\/\n+  \/\/ similarly, evac_slack_spiking is MIN2(0, available - avg_cycle_time * rate + penalties + spike_headroom)\n+  \/\/ but evac_slack_spiking is only relevant if is_spiking, as defined below.\n+\n+  double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n+\n+  \/\/ TODO: Consider making conservative adjustments to avg_cycle_time, such as: (avg_cycle_time *= 2) in cases where\n+  \/\/ we expect a longer-than-normal GC duration.  This includes mixed evacuations, evacuation that perform promotion\n+  \/\/ including promotion in place, and OLD GC bootstrap cycles.  It has been observed that these cycles sometimes\n+  \/\/ require twice or more the duration of \"normal\" GC cycles.  We have experimented with this approach.  While it\n+  \/\/ does appear to reduce the frequency of degenerated cycles due to late triggers, it also has the effect of reducing\n+  \/\/ evacuation slack so that there is less memory available to be transferred to OLD.  The result is that we\n+  \/\/ throttle promotion and it takes too long to move old objects out of the young generation.\n+\n+  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+  size_t evac_slack_avg;\n+  if (anticipated_available > avg_cycle_time * avg_alloc_rate + penalties + spike_headroom) {\n+    evac_slack_avg = anticipated_available - (avg_cycle_time * avg_alloc_rate + penalties + spike_headroom);\n+  } else {\n+    \/\/ we have no slack because it's already time to trigger\n+    evac_slack_avg = 0;\n+  }\n+\n+  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n+  size_t evac_slack_spiking;\n+  if (is_spiking) {\n+    if (anticipated_available > avg_cycle_time * rate + penalties + spike_headroom) {\n+      evac_slack_spiking = anticipated_available - (avg_cycle_time * rate + penalties + spike_headroom);\n+    } else {\n+      \/\/ we have no slack because it's already time to trigger\n+      evac_slack_spiking = 0;\n+    }\n+  } else {\n+    evac_slack_spiking = evac_slack_avg;\n+  }\n+\n+  size_t threshold = min_free_threshold();\n+  size_t evac_min_threshold = (anticipated_available > threshold)? anticipated_available - threshold: 0;\n+  return MIN3(evac_slack_spiking, evac_slack_avg, evac_min_threshold);\n+}\n+\n+bool ShenandoahAdaptiveHeuristics::should_start_gc() {\n+  size_t capacity = _generation->soft_max_capacity();\n+  size_t available = _generation->soft_available();\n+  size_t allocated = _generation->bytes_allocated_since_gc_start();\n+\n+  log_debug(gc)(\"should_start_gc (%s)? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n+                \", allocated: \" SIZE_FORMAT,\n+                _generation->name(), available, capacity, allocated);\n+\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when deciding whether to start a GC.\n+  size_t usable = ShenandoahHeap::heap()->free_set()->available();\n+  if (usable < available) {\n+    log_debug(gc)(\"Usable (\" SIZE_FORMAT \"%s) is less than available (\" SIZE_FORMAT \"%s)\",\n+                  byte_size_in_proper_unit(usable),    proper_unit_for_byte_size(usable),\n+                  byte_size_in_proper_unit(available), proper_unit_for_byte_size(available));\n+    available = usable;\n+  }\n@@ -213,16 +432,8 @@\n-  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n-  if (available < min_threshold) {\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n-    return true;\n-  }\n-\n-  const size_t max_learn = ShenandoahLearningSteps;\n-  if (_gc_times_learned < max_learn) {\n-    size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n-    if (available < init_threshold) {\n-      log_info(gc)(\"Trigger: Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n-                   _gc_times_learned + 1, max_learn,\n-                   byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),\n-                   byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));\n+  \/\/ OLD generation is maintained to be as small as possible.  Depletion-of-free-pool triggers do not apply to old generation.\n+  if (!_generation->is_old()) {\n+    size_t min_threshold = min_free_threshold();\n+    if (available < min_threshold) {\n+      log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                   _generation->name(),\n+                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                   byte_size_in_proper_unit(min_threshold),       proper_unit_for_byte_size(min_threshold));\n@@ -231,1 +442,0 @@\n-  }\n@@ -233,4 +443,13 @@\n-  \/\/ Check if allocation headroom is still okay. This also factors in:\n-  \/\/   1. Some space to absorb allocation spikes\n-  \/\/   2. Accumulated penalties from Degenerated and Full GC\n-  size_t allocation_headroom = available;\n+    \/\/ Check if we need to learn a bit about the application\n+    const size_t max_learn = ShenandoahLearningSteps;\n+    if (_gc_times_learned < max_learn) {\n+      size_t init_threshold = capacity \/ 100 * ShenandoahInitFreeThreshold;\n+      if (available < init_threshold) {\n+        log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\"\n+                     SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                     _generation->name(), _gc_times_learned + 1, max_learn,\n+                     byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n+                     byte_size_in_proper_unit(init_threshold),      proper_unit_for_byte_size(init_threshold));\n+        return true;\n+      }\n+    }\n@@ -238,2 +457,28 @@\n-  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+    \/\/  Rationale:\n+    \/\/    The idea is that there is an average allocation rate and there are occasional abnormal bursts (or spikes) of\n+    \/\/    allocations that exceed the average allocation rate.  What do these spikes look like?\n+    \/\/\n+    \/\/    1. At certain phase changes, we may discard large amounts of data and replace it with large numbers of newly\n+    \/\/       allocated objects.  This \"spike\" looks more like a phase change.  We were in steady state at M bytes\/sec\n+    \/\/       allocation rate and now we're in a \"reinitialization phase\" that looks like N bytes\/sec.  We need the \"spike\"\n+    \/\/       accomodation to give us enough runway to recalibrate our \"average allocation rate\".\n+    \/\/\n+    \/\/   2. The typical workload changes.  \"Suddenly\", our typical workload of N TPS increases to N+delta TPS.  This means\n+    \/\/       our average allocation rate needs to be adjusted.  Once again, we need the \"spike\" accomodation to give us\n+    \/\/       enough runway to recalibrate our \"average allocation rate\".\n+    \/\/\n+    \/\/    3. Though there is an \"average\" allocation rate, a given workload's demand for allocation may be very bursty.  We\n+    \/\/       allocate a bunch of LABs during the 5 ms that follow completion of a GC, then we perform no more allocations for\n+    \/\/       the next 150 ms.  It seems we want the \"spike\" to represent the maximum divergence from average within the\n+    \/\/       period of time between consecutive evaluation of the should_start_gc() service.  Here's the thinking:\n+    \/\/\n+    \/\/       a) Between now and the next time I ask whether should_start_gc(), we might experience a spike representing\n+    \/\/          the anticipated burst of allocations.  If that would put us over budget, then we should start GC immediately.\n+    \/\/       b) Between now and the anticipated depletion of allocation pool, there may be two or more bursts of allocations.\n+    \/\/          If there are more than one of these bursts, we can \"approximate\" that these will be separated by spans of\n+    \/\/          time with very little or no allocations so the \"average\" allocation rate should be a suitable approximation\n+    \/\/          of how this will behave.\n+    \/\/\n+    \/\/    For cases 1 and 2, we need to \"quickly\" recalibrate the average allocation rate whenever we detect a change\n+    \/\/    in operation mode.  We want some way to decide that the average rate has changed.  Make average allocation rate\n+    \/\/    computations an independent effort.\n@@ -241,2 +486,0 @@\n-  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-  allocation_headroom -= MIN2(allocation_headroom, penalties);\n@@ -244,18 +487,3 @@\n-  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n-  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n-  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n-                 avg_cycle_time * 1000,\n-                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n-                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n-                 _margin_of_error_sd);\n-\n-    log_info(gc, ergo)(\"Free headroom: \" SIZE_FORMAT \"%s (free) - \" SIZE_FORMAT \"%s (spike) - \" SIZE_FORMAT \"%s (penalties) = \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n-                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n-                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n-                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n-\n-    _last_trigger = RATE;\n-    return true;\n-  }\n+    \/\/ Check if allocation headroom is still okay. This also factors in:\n+    \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n+    \/\/   2. Accumulated penalties from Degenerated and Full GC\n@@ -263,10 +491,44 @@\n-  bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n-  if (is_spiking && avg_cycle_time > allocation_headroom \/ rate) {\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n-                 avg_cycle_time * 1000,\n-                 byte_size_in_proper_unit(rate), proper_unit_for_byte_size(rate),\n-                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n-                 _spike_threshold_sd);\n-    _last_trigger = SPIKE;\n-    return true;\n-  }\n+    size_t allocation_headroom = available;\n+    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+\n+    allocation_headroom -= MIN2(allocation_headroom, penalties);\n+    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+\n+    double avg_cycle_time = _gc_cycle_time_history->davg() + (_margin_of_error_sd * _gc_cycle_time_history->dsd());\n+    double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+    log_debug(gc)(\"%s: average GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n+                  _generation->name(),\n+                  avg_cycle_time * 1000, byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n+\n+    if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+\n+      log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n+                   \" to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+                   _generation->name(), avg_cycle_time * 1000,\n+                   byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n+                   byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                   _margin_of_error_sd);\n+\n+      log_info(gc, ergo)(\"Free headroom: \" SIZE_FORMAT \"%s (free) - \" SIZE_FORMAT \"%s (spike) - \"\n+                         SIZE_FORMAT \"%s (penalties) = \" SIZE_FORMAT \"%s\",\n+                         byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n+                         byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n+                         byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n+                         byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n+\n+      _last_trigger = RATE;\n+      return true;\n+    }\n+\n+    bool is_spiking = _allocation_rate.is_spiking(rate, _spike_threshold_sd);\n+    if (is_spiking && avg_cycle_time > allocation_headroom \/ rate) {\n+      log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s)\"\n+                   \" to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                   _generation->name(), avg_cycle_time * 1000,\n+                   byte_size_in_proper_unit(rate), proper_unit_for_byte_size(rate),\n+                   byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                   _spike_threshold_sd);\n+      _last_trigger = SPIKE;\n+      return true;\n+    }\n@@ -274,0 +536,33 @@\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    if (heap->mode()->is_generational()) {\n+      \/\/ Get through promotions and mixed evacuations as quickly as possible.  These cycles sometimes require significantly\n+      \/\/ more time than traditional young-generation cycles so start them up as soon as possible.  This is a \"mitigation\"\n+      \/\/ for the reality that old-gen and young-gen activities are not truly \"concurrent\".  If there is old-gen work to\n+      \/\/ be done, we start up the young-gen GC threads so they can do some of this old-gen work.  As implemented, promotion\n+      \/\/ gets priority over old-gen marking.\n+\n+      size_t promo_potential = heap->get_promotion_potential();\n+      size_t promo_in_place_potential = heap->get_promotion_in_place_potential();\n+      ShenandoahOldHeuristics* old_heuristics = (ShenandoahOldHeuristics*) heap->old_generation()->heuristics();\n+      size_t mixed_candidates = old_heuristics->unprocessed_old_collection_candidates();\n+      if (promo_potential > 0) {\n+        \/\/ Detect unsigned arithmetic underflow\n+        assert(promo_potential < heap->capacity(), \"Sanity\");\n+        log_info(gc)(\"Trigger (%s): expedite promotion of \" SIZE_FORMAT \"%s\",\n+                     _generation->name(), byte_size_in_proper_unit(promo_potential), proper_unit_for_byte_size(promo_potential));\n+        return true;\n+      } else if (promo_in_place_potential > 0) {\n+        \/\/ Detect unsigned arithmetic underflow\n+        assert(promo_in_place_potential < heap->capacity(), \"Sanity\");\n+        log_info(gc)(\"Trigger (%s): expedite promotion in place of \" SIZE_FORMAT \"%s\", _generation->name(),\n+                     byte_size_in_proper_unit(promo_in_place_potential),\n+                     proper_unit_for_byte_size(promo_in_place_potential));\n+        return true;\n+      } else if (mixed_candidates > 0) {\n+        \/\/ We need to run young GC in order to open up some free heap regions so we can finish mixed evacuations.\n+        log_info(gc)(\"Trigger (%s): expedite mixed evacuation of \" SIZE_FORMAT \" regions\",\n+                     _generation->name(), mixed_candidates);\n+        return true;\n+      }\n+    }\n+  }\n@@ -357,4 +652,0 @@\n-double ShenandoahAllocationRate::instantaneous_rate(size_t allocated) const {\n-  return instantaneous_rate(os::elapsedTime(), allocated);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":393,"deletions":102,"binary":false,"changes":495,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -39,1 +40,0 @@\n-  double instantaneous_rate(size_t allocated) const;\n@@ -42,1 +42,0 @@\n-\n@@ -56,1 +55,1 @@\n-  ShenandoahAdaptiveHeuristics();\n+  ShenandoahAdaptiveHeuristics(ShenandoahGeneration* generation);\n@@ -65,1 +64,1 @@\n-  void record_success_concurrent();\n+  void record_success_concurrent(bool abbreviated);\n@@ -75,0 +74,2 @@\n+  virtual size_t bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_recycled);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,1 +35,6 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics() : ShenandoahHeuristics() {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n+\n+  assert(!ShenandoahHeap::heap()->mode()->is_generational(),\n+         \"Aggressive heuristics is not available in generational mode\");\n+\n@@ -51,0 +57,2 @@\n+  \/\/ Note that there is no bound on collection set size. If we try to collect too much memory,\n+  \/\/ we'll get an allocation failure during collection and slide to degenerated GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,1 +33,1 @@\n-  ShenandoahAggressiveHeuristics();\n+  ShenandoahAggressiveHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,1 +36,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics() : ShenandoahHeuristics() {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n@@ -48,5 +50,4 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t usage        = _generation->used();\n+  size_t available    = (capacity > usage)? capacity - usage: 0;\n@@ -59,1 +60,1 @@\n-  size_t min_threshold = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+  size_t min_threshold = min_free_threshold();\n@@ -68,1 +69,1 @@\n-  size_t bytes_allocated = heap->bytes_allocated_since_gc_start();\n+  size_t bytes_allocated = _generation->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahCompactHeuristics();\n+  ShenandoahCompactHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -32,0 +35,2 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -33,0 +38,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -36,0 +42,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -37,0 +44,1 @@\n+\/\/ sort by decreasing garbage (so most garbage comes first)\n@@ -38,1 +46,1 @@\n-  if (a._garbage > b._garbage)\n+  if (a._u._garbage > b._u._garbage)\n@@ -40,1 +48,1 @@\n-  else if (a._garbage < b._garbage)\n+  else if (a._u._garbage < b._u._garbage)\n@@ -45,1 +53,11 @@\n-ShenandoahHeuristics::ShenandoahHeuristics() :\n+\/\/ sort by increasing live (so least live comes first)\n+int ShenandoahHeuristics::compare_by_live(RegionData a, RegionData b) {\n+  if (a._u._live_data < b._u._live_data)\n+    return -1;\n+  else if (a._u._live_data > b._u._live_data)\n+    return 1;\n+  else return 0;\n+}\n+\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahGeneration* generation) :\n+  _generation(generation),\n@@ -49,0 +67,1 @@\n+  _guaranteed_gc_interval(0),\n@@ -53,1 +72,1 @@\n-  _gc_time_history(new TruncatedSeq(10, ShenandoahAdaptiveDecayFactor)),\n+  _gc_cycle_time_history(new TruncatedSeq(Moving_Average_Samples, ShenandoahAdaptiveDecayFactor)),\n@@ -71,2 +90,159 @@\n-void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n-  assert(collection_set->count() == 0, \"Must be empty\");\n+typedef struct {\n+  ShenandoahHeapRegion* _region;\n+  size_t _live_data;\n+} AgedRegionData;\n+\n+static int compare_by_aged_live(AgedRegionData a, AgedRegionData b) {\n+  if (a._live_data < b._live_data)\n+    return -1;\n+  else if (a._live_data > b._live_data)\n+    return 1;\n+  else return 0;\n+}\n+\n+\/\/ Preselect for inclusion into the collection set regions whose age is at or above tenure age which contain more than\n+\/\/ ShenandoahOldGarbageThreshold amounts of garbage.  We identify these regions by setting the appropriate entry of\n+\/\/ candidate_regions_for_promotion_by_copy[] to true.  All entries are initialized to false before calling this\n+\/\/ function.\n+\/\/\n+\/\/ During the subsequent selection of the collection set, we give priority to these promotion set candidates.\n+\/\/ Without this prioritization, we found that the aged regions tend to be ignored because they typically have\n+\/\/ much less garbage and much more live data than the recently allocated \"eden\" regions.  When aged regions are\n+\/\/ repeatedly excluded from the collection set, the amount of live memory within the young generation tends to\n+\/\/ accumulate and this has the undesirable side effect of causing young-generation collections to require much more\n+\/\/ CPU and wall-clock time.\n+\/\/\n+\/\/ A second benefit of treating aged regions differently than other regions during collection set selection is\n+\/\/ that this allows us to more accurately budget memory to hold the results of evacuation.  Memory for evacuation\n+\/\/ of aged regions must be reserved in the old generations.  Memory for evacuation of all other regions must be\n+\/\/ reserved in the young generation.\n+\/\/\n+\/\/ A side effect performed by this function is to tally up the number of regions and the number of live bytes\n+\/\/ that we plan to promote-in-place during the current GC cycle.  This information, which is stored with\n+\/\/ an invocation of heap->set_promotion_in_place_potential(), feeds into subsequent decisions about when to\n+\/\/ trigger the next GC and may identify special work to be done during this GC cycle if we choose to abbreviate it.\n+\/\/\n+\/\/ Returns bytes of old-gen memory consumed by selected aged regions\n+size_t ShenandoahHeuristics::select_aged_regions(size_t old_available, size_t num_regions,\n+                                                 bool candidate_regions_for_promotion_by_copy[]) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->mode()->is_generational(), \"Only in generational mode\");\n+  ShenandoahMarkingContext* const ctx = heap->marking_context();\n+  size_t old_consumed = 0;\n+  size_t promo_potential = 0;\n+  size_t anticipated_promote_in_place_live = 0;\n+\n+  heap->clear_promotion_in_place_potential();\n+  heap->clear_promotion_potential();\n+  size_t candidates = 0;\n+  size_t candidates_live = 0;\n+  size_t old_garbage_threshold = (ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold) \/ 100;\n+  size_t promote_in_place_regions = 0;\n+  size_t promote_in_place_live = 0;\n+  size_t promote_in_place_pad = 0;\n+  size_t anticipated_candidates = 0;\n+  size_t anticipated_promote_in_place_regions = 0;\n+\n+  \/\/ Sort the promotion-eligible regions according to live-data-bytes so that we can first reclaim regions that require\n+  \/\/ less evacuation effort.  This prioritizes garbage first, expanding the allocation pool before we begin the work of\n+  \/\/ reclaiming regions that require more effort.\n+  AgedRegionData* sorted_regions = (AgedRegionData*) alloca(num_regions * sizeof(AgedRegionData));\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->is_empty() || !r->has_live() || !r->is_young() || !r->is_regular()) {\n+      continue;\n+    }\n+    if (r->age() >= InitialTenuringThreshold) {\n+      r->save_top_before_promote();\n+      if ((r->garbage() < old_garbage_threshold)) {\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        HeapWord* original_top = r->top();\n+        if (tams == original_top) {\n+          \/\/ Fill the remnant memory within this region to assure no allocations prior to promote in place.  Otherwise,\n+          \/\/ newly allocated objects will not be parseable when promote in place tries to register them.  Furthermore, any\n+          \/\/ new allocations would not necessarily be eligible for promotion.  This addresses both issues.\n+          size_t remnant_size = r->free() \/ HeapWordSize;\n+          if (remnant_size > ShenandoahHeap::min_fill_size()) {\n+            ShenandoahHeap::fill_with_object(original_top, remnant_size);\n+            r->set_top(r->end());\n+            promote_in_place_pad += remnant_size * HeapWordSize;\n+          } else {\n+            \/\/ Since the remnant is so small that it cannot be filled, we don't have to worry about any accidental\n+            \/\/ allocations occuring within this region before the region is promoted in place.\n+          }\n+          promote_in_place_regions++;\n+          promote_in_place_live += r->get_live_data_bytes();\n+        }\n+        \/\/ Else, we do not promote this region (either in place or by copy) because it has received new allocations.\n+\n+        \/\/ During evacuation, we exclude from promotion regions for which age > tenure threshold, garbage < garbage-threshold,\n+        \/\/  and get_top_before_promote() != tams\n+      } else {\n+        \/\/ After sorting and selecting best candidates below, we may decide to exclude this promotion-eligible region\n+        \/\/ from the current collection sets.  If this happens, we will consider this region as part of the anticipated\n+        \/\/ promotion potential for the next GC pass.\n+        size_t live_data = r->get_live_data_bytes();\n+        candidates_live += live_data;\n+        sorted_regions[candidates]._region = r;\n+        sorted_regions[candidates++]._live_data = live_data;\n+      }\n+    } else {\n+      \/\/ We only anticipate to promote regular regions if garbage() is above threshold.  Tenure-aged regions with less\n+      \/\/ garbage are promoted in place.  These take a different path to old-gen.  Note that certain regions that are\n+      \/\/ excluded from anticipated promotion because their garbage content is too low (causing us to anticipate that\n+      \/\/ the region would be promoted in place) may be eligible for evacuation promotion by the time promotion takes\n+      \/\/ place during a subsequent GC pass because more garbage is found within the region between now and then.  This\n+      \/\/ should not happen if we are properly adapting the tenure age.  The theory behind adaptive tenuring threshold\n+      \/\/ is to choose the youngest age that demonstrates no \"significant\" futher loss of population since the previous\n+      \/\/ age.  If not this, we expect the tenure age to demonstrate linear population decay for at least two population\n+      \/\/ samples, whereas we expect to observe exponetial population decay for ages younger than the tenure age.\n+      \/\/\n+      \/\/ In the case that certain regions which were anticipated to be promoted in place need to be promoted by\n+      \/\/ evacuation, it may be the case that there is not sufficient reserve within old-gen to hold evacuation of\n+      \/\/ these regions.  The likely outcome is that these regions will not be selected for evacuation or promotion\n+      \/\/ in the current cycle and we will anticipate that they will be promoted in the next cycle.  This will cause\n+      \/\/ us to reserve more old-gen memory so that these objects can be promoted in the subsequent cycle.\n+      \/\/\n+      \/\/ TODO:\n+      \/\/   If we are auto-tuning the tenure age and regions that were anticipated to be promoted in place end up\n+      \/\/   being promoted by evacuation, this event should feed into the tenure-age-selection heuristic so that\n+      \/\/   the tenure age can be increased.\n+      if (heap->is_aging_cycle() && (r->age() + 1 == InitialTenuringThreshold)) {\n+        if (r->garbage() >= old_garbage_threshold) {\n+          anticipated_candidates++;\n+          promo_potential += r->get_live_data_bytes();\n+        }\n+        else {\n+          anticipated_promote_in_place_regions++;\n+          anticipated_promote_in_place_live += r->get_live_data_bytes();\n+        }\n+      }\n+    }\n+    \/\/ Note that we keep going even if one region is excluded from selection.\n+    \/\/ Subsequent regions may be selected if they have smaller live data.\n+  }\n+  \/\/ Sort in increasing order according to live data bytes.  Note that candidates represents the number of regions\n+  \/\/ that qualify to be promoted by evacuation.\n+  if (candidates > 0) {\n+    QuickSort::sort<AgedRegionData>(sorted_regions, candidates, compare_by_aged_live, false);\n+    for (size_t i = 0; i < candidates; i++) {\n+      size_t region_live_data = sorted_regions[i]._live_data;\n+      size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n+      if (old_consumed + promotion_need <= old_available) {\n+        ShenandoahHeapRegion* region = sorted_regions[i]._region;\n+        old_consumed += promotion_need;\n+        candidate_regions_for_promotion_by_copy[region->index()] = true;\n+      } else {\n+        \/\/ We rejected this promotable region from the collection set because we had no room to hold its copy.\n+        \/\/ Add this region to promo potential for next GC.\n+        promo_potential += region_live_data;\n+      }\n+      \/\/ We keep going even if one region is excluded from selection because we need to accumulate all eligible\n+      \/\/ regions that are not preselected into promo_potential\n+    }\n+  }\n+  heap->set_pad_for_promote_in_place(promote_in_place_pad);\n+  heap->set_promotion_potential(promo_potential);\n+  heap->set_promotion_in_place_potential(anticipated_promote_in_place_live);\n+  return old_consumed;\n+}\n@@ -74,0 +250,1 @@\n+void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) {\n@@ -75,0 +252,5 @@\n+  bool is_generational = heap->mode()->is_generational();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  assert(collection_set->count() == 0, \"Must be empty\");\n+  assert(!is_generational || !_generation->is_old(), \"Old GC invokes ShenandoahOldHeuristics::choose_collection_set()\");\n@@ -86,0 +268,1 @@\n+  size_t preselected_candidates = 0;\n@@ -95,1 +278,9 @@\n-  ShenandoahMarkingContext* const ctx = heap->complete_marking_context();\n+  size_t old_garbage_threshold = (region_size_bytes * ShenandoahOldGarbageThreshold) \/ 100;\n+  \/\/ This counts number of humongous regions that we intend to promote in this cycle.\n+  size_t humongous_regions_promoted = 0;\n+  \/\/ This counts bytes of memory used by hunongous regions to be promoted in place.\n+  size_t humongous_bytes_promoted = 0;\n+  \/\/ This counts number of regular regions that will be promoted in place.\n+  size_t regular_regions_promoted_in_place = 0;\n+  \/\/ This counts bytes of memory used by regular regions to be promoted in place.\n+  size_t regular_regions_promoted_usage = 0;\n@@ -99,1 +290,3 @@\n-\n+    if (is_generational && !in_generation(region)) {\n+      continue;\n+    }\n@@ -102,1 +295,0 @@\n-\n@@ -113,0 +305,2 @@\n+        assert(!_generation->is_old(), \"OLD is handled elsewhere\");\n+        bool is_candidate;\n@@ -114,3 +308,27 @@\n-        candidates[cand_idx]._region = region;\n-        candidates[cand_idx]._garbage = garbage;\n-        cand_idx++;\n+        if (is_generational && collection_set->is_preselected(i)) {\n+          \/\/ If !is_generational, we cannot ask if is_preselected.  If is_preselected, we know\n+          \/\/   region->age() >= InitialTenuringThreshold).\n+          is_candidate = true;\n+          preselected_candidates++;\n+          \/\/ Set garbage value to maximum value to force this into the sorted collection set.\n+          garbage = region_size_bytes;\n+        } else if (is_generational && region->is_young() && (region->age() >= InitialTenuringThreshold)) {\n+          \/\/ Note that for GLOBAL GC, region may be OLD, and OLD regions do not qualify for pre-selection\n+\n+          \/\/ This region is old enough to be promoted but it was not preselected, either because its garbage is below\n+          \/\/ ShenandoahOldGarbageThreshold so it will be promoted in place, or because there is not sufficient room\n+          \/\/ in old gen to hold the evacuated copies of this region's live data.  In both cases, we choose not to\n+          \/\/ place this region into the collection set.\n+          if (region->garbage_before_padded_for_promote() < old_garbage_threshold) {\n+            regular_regions_promoted_in_place++;\n+            regular_regions_promoted_usage += region->used_before_promote();\n+          }\n+          is_candidate = false;\n+        } else {\n+          is_candidate = true;\n+        }\n+        if (is_candidate) {\n+          candidates[cand_idx]._region = region;\n+          candidates[cand_idx]._u._garbage = garbage;\n+          cand_idx++;\n+        }\n@@ -122,1 +340,1 @@\n-      bool bm_live = ctx->is_marked(cast_to_oop(region->bottom()));\n+      bool bm_live = heap->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n@@ -133,0 +351,7 @@\n+      } else {\n+        if (region->is_young() && region->age() >= InitialTenuringThreshold) {\n+          oop obj = cast_to_oop(region->bottom());\n+          size_t humongous_regions = ShenandoahHeapRegion::required_regions(obj->size() * HeapWordSize);\n+          humongous_regions_promoted += humongous_regions;\n+          humongous_bytes_promoted += obj->size() * HeapWordSize;\n+        }\n@@ -140,0 +365,8 @@\n+  heap->reserve_promotable_humongous_regions(humongous_regions_promoted);\n+  heap->reserve_promotable_humongous_usage(humongous_bytes_promoted);\n+  heap->reserve_promotable_regular_regions(regular_regions_promoted_in_place);\n+  heap->reserve_promotable_regular_usage(regular_regions_promoted_usage);\n+  log_info(gc, ergo)(\"Planning to promote in place \" SIZE_FORMAT \" humongous regions and \" SIZE_FORMAT\n+                     \" regular regions, spanning a total of \" SIZE_FORMAT \" used bytes\",\n+                     humongous_regions_promoted, regular_regions_promoted_in_place,\n+                     humongous_regions_promoted * ShenandoahHeapRegion::region_size_bytes() + regular_regions_promoted_usage);\n@@ -150,0 +383,10 @@\n+  collection_set->set_immediate_trash(immediate_garbage);\n+\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  bool doing_promote_in_place = (humongous_regions_promoted + regular_regions_promoted_in_place > 0);\n+  if (doing_promote_in_place || (preselected_candidates > 0) || (immediate_percent <= ShenandoahImmediateThreshold)) {\n+    if (old_heuristics != nullptr) {\n+      old_heuristics->prime_collection_set(collection_set);\n+    } else {\n+      \/\/ This is a global collection and does not need to prime cset\n+    }\n@@ -151,1 +394,1 @@\n-  if (immediate_percent <= ShenandoahImmediateThreshold) {\n+    \/\/ Call the subclasses to add young-gen regions into the collection set.\n@@ -153,0 +396,4 @@\n+  } else {\n+    \/\/ We are going to skip evacuation and update refs because we reclaimed\n+    \/\/ sufficient amounts of immediate garbage.\n+    heap->shenandoah_policy()->record_abbreviated_cycle();\n@@ -155,1 +402,3 @@\n-  size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n+  if (collection_set->has_old_regions()) {\n+    heap->shenandoah_policy()->record_mixed_cycle();\n+  }\n@@ -157,0 +406,1 @@\n+  size_t cset_percent = (total_garbage == 0) ? 0 : (collection_set->garbage() * 100 \/ total_garbage);\n@@ -161,2 +411,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions, \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \" SIZE_FORMAT \" regions\",\n@@ -171,0 +421,1 @@\n+                     immediate_regions,\n@@ -174,1 +425,17 @@\n-                     cset_percent);\n+                     cset_percent,\n+                     collection_set->count());\n+\n+  if (collection_set->garbage() > 0) {\n+    size_t young_evac_bytes   = collection_set->get_young_bytes_reserved_for_evacuation();\n+    size_t promote_evac_bytes = collection_set->get_young_bytes_to_be_promoted();\n+    size_t old_evac_bytes     = collection_set->get_old_bytes_reserved_for_evacuation();\n+    size_t total_evac_bytes   = young_evac_bytes + promote_evac_bytes + old_evac_bytes;\n+    log_info(gc, ergo)(\"Evacuation Targets: YOUNG: \" SIZE_FORMAT \"%s, \"\n+                       \"PROMOTE: \" SIZE_FORMAT \"%s, \"\n+                       \"OLD: \" SIZE_FORMAT \"%s, \"\n+                       \"TOTAL: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(young_evac_bytes),   proper_unit_for_byte_size(young_evac_bytes),\n+                       byte_size_in_proper_unit(promote_evac_bytes), proper_unit_for_byte_size(promote_evac_bytes),\n+                       byte_size_in_proper_unit(old_evac_bytes),     proper_unit_for_byte_size(old_evac_bytes),\n+                       byte_size_in_proper_unit(total_evac_bytes),   proper_unit_for_byte_size(total_evac_bytes));\n+  }\n@@ -193,1 +460,1 @@\n-  if (ShenandoahGuaranteedGCInterval > 0) {\n+  if (_guaranteed_gc_interval > 0) {\n@@ -195,3 +462,3 @@\n-    if (last_time_ms > ShenandoahGuaranteedGCInterval) {\n-      log_info(gc)(\"Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   last_time_ms, ShenandoahGuaranteedGCInterval);\n+    if (last_time_ms > _guaranteed_gc_interval) {\n+      log_info(gc)(\"Trigger (%s): Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   _generation->name(), last_time_ms, _guaranteed_gc_interval);\n@@ -211,1 +478,1 @@\n-          \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range before adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -223,1 +490,1 @@\n-          \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n+         \"In range after adjustment: \" INTX_FORMAT, _gc_time_penalties);\n@@ -226,1 +493,1 @@\n-void ShenandoahHeuristics::record_success_concurrent() {\n+void ShenandoahHeuristics::record_success_concurrent(bool abbreviated) {\n@@ -230,2 +497,4 @@\n-  _gc_time_history->add(time_since_last_gc());\n-  _gc_times_learned++;\n+  if (!(abbreviated && ShenandoahAdaptiveIgnoreShortCycles)) {\n+    _gc_cycle_time_history->add(elapsed_cycle_time());\n+    _gc_times_learned++;\n+  }\n@@ -257,0 +526,4 @@\n+  reset_gc_learning();\n+}\n+\n+void ShenandoahHeuristics::reset_gc_learning() {\n@@ -288,1 +561,7 @@\n-double ShenandoahHeuristics::time_since_last_gc() const {\n+size_t ShenandoahHeuristics::bytes_of_allocation_runway_before_gc_trigger(size_t young_regions_to_be_recycled) {\n+  assert(false, \"Only implemented for young Adaptive Heuristics\");\n+  return 0;\n+}\n+\n+\n+double ShenandoahHeuristics::elapsed_cycle_time() const {\n@@ -291,0 +570,15 @@\n+\n+bool ShenandoahHeuristics::in_generation(ShenandoahHeapRegion* region) {\n+  return _generation->is_global()\n+          || (_generation->is_young() && region->is_young())\n+          || (_generation->is_old()   && region->is_old());\n+}\n+\n+size_t ShenandoahHeuristics::min_free_threshold() {\n+  assert(!_generation->is_old(), \"min_free_threshold is only relevant to young GC\");\n+  size_t min_free_threshold = ShenandoahMinFreeThreshold;\n+  \/\/ Note that soft_max_capacity() \/ 100 * min_free_threshold is smaller than max_capacity() \/ 100 * min_free_threshold.\n+  \/\/ We want to behave conservatively here, so use max_capacity().  By returning a larger value, we cause the GC to\n+  \/\/ trigger when the remaining amount of free shrinks below the larger threshold.\n+  return _generation->max_capacity() \/ 100 * min_free_threshold;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":322,"deletions":28,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n@@ -60,0 +60,2 @@\n+class ShenandoahGeneration;\n+class ShenandoahOldHeuristics;\n@@ -67,0 +69,2 @@\n+  static const uint Moving_Average_Samples = 10; \/\/ Number of samples to store in moving averages\n+\n@@ -69,1 +73,4 @@\n-    size_t _garbage;\n+    union {\n+      size_t _garbage;          \/\/ Not used by old-gen heuristics.\n+      size_t _live_data;        \/\/ Only used for old-gen heuristics, which prioritizes retention of _live_data over garbage reclaim\n+    } _u;\n@@ -72,0 +79,14 @@\n+  ShenandoahGeneration* _generation;\n+\n+  \/\/ Depending on generation mode, region data represents the results of the relevant\n+  \/\/ most recently completed marking pass:\n+  \/\/   - in GLOBAL mode, global marking pass\n+  \/\/   - in OLD mode,    old-gen marking pass\n+  \/\/   - in YOUNG mode,  young-gen marking pass\n+  \/\/\n+  \/\/ Note that there is some redundancy represented in region data because\n+  \/\/ each instance is an array large enough to hold all regions. However,\n+  \/\/ any region in young-gen is not in old-gen. And any time we are\n+  \/\/ making use of the GLOBAL data, there is no need to maintain the\n+  \/\/ YOUNG or OLD data. Consider this redundancy of data structure to\n+  \/\/ have negligible cost unless proven otherwise.\n@@ -77,0 +98,2 @@\n+  size_t _guaranteed_gc_interval;\n+\n@@ -82,1 +105,1 @@\n-  TruncatedSeq* _gc_time_history;\n+  TruncatedSeq* _gc_cycle_time_history;\n@@ -89,0 +112,12 @@\n+  \/\/ Compare by live is used to prioritize compaction of old-gen regions.  With old-gen compaction, the goal is\n+  \/\/ to tightly pack long-lived objects into available regions.  In most cases, there has not been an accumulation\n+  \/\/ of garbage within old-gen regions.  The more likely opportunity will be to combine multiple sparsely populated\n+  \/\/ old-gen regions which may have been promoted in place into a smaller number of densely packed old-gen regions.\n+  \/\/ This improves subsequent allocation efficiency and reduces the likelihood of allocation failure (including\n+  \/\/ humongous allocation failure) due to fragmentation of the available old-gen allocation pool\n+  static int compare_by_live(RegionData a, RegionData b);\n+\n+  \/\/ TODO: We need to enhance this API to give visibility to accompanying old-gen evacuation effort.\n+  \/\/ In the case that the old-gen evacuation effort is small or zero, the young-gen heuristics\n+  \/\/ should feel free to dedicate increased efforts to young-gen evacuation.\n+\n@@ -95,0 +130,4 @@\n+  bool in_generation(ShenandoahHeapRegion* region);\n+\n+  size_t min_free_threshold();\n+\n@@ -96,1 +135,1 @@\n-  ShenandoahHeuristics();\n+  ShenandoahHeuristics(ShenandoahGeneration* generation);\n@@ -103,0 +142,8 @@\n+  void set_guaranteed_gc_interval(size_t guaranteed_gc_interval) {\n+    _guaranteed_gc_interval = guaranteed_gc_interval;\n+  }\n+\n+  uint degenerated_cycles_in_a_row() {\n+    return _degenerated_cycles_in_a_row;\n+  }\n+\n@@ -111,1 +158,1 @@\n-  virtual void record_success_concurrent();\n+  virtual void record_success_concurrent(bool abbreviated);\n@@ -121,1 +168,5 @@\n-  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set);\n+  virtual void reset_gc_learning();\n+\n+  virtual size_t select_aged_regions(size_t old_available, size_t num_regions, bool candidate_regions_for_promotion_by_copy[]);\n+\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics);\n@@ -132,1 +183,3 @@\n-  double time_since_last_gc() const;\n+  virtual size_t bytes_of_allocation_runway_before_gc_trigger(size_t region_to_be_recycled);\n+\n+  double elapsed_cycle_time() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":60,"deletions":7,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,625 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectionSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+#define BYTES_FORMAT    SIZE_FORMAT \"%s\"\n+#define FORMAT_BYTES(b) byte_size_in_proper_unit(b), proper_unit_for_byte_size(b)\n+\n+uint ShenandoahOldHeuristics::NOT_FOUND = -1U;\n+\n+ShenandoahOldHeuristics::ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahHeuristics* trigger_heuristic) :\n+  ShenandoahHeuristics(generation),\n+  _first_pinned_candidate(NOT_FOUND),\n+  _last_old_collection_candidate(0),\n+  _next_old_collection_candidate(0),\n+  _last_old_region(0),\n+  _trigger_heuristic(trigger_heuristic),\n+  _old_generation(generation),\n+  _promotion_failed(false),\n+  _cannot_expand_trigger(false),\n+  _fragmentation_trigger(false),\n+  _growth_trigger(false)\n+{\n+  assert(_generation->is_old(), \"This service only available for old-gc heuristics\");\n+}\n+\n+bool ShenandoahOldHeuristics::prime_collection_set(ShenandoahCollectionSet* collection_set) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    return false;\n+  }\n+\n+  _first_pinned_candidate = NOT_FOUND;\n+\n+  uint included_old_regions = 0;\n+  size_t evacuated_old_bytes = 0;\n+  size_t collected_old_bytes = 0;\n+\n+  \/\/ If a region is put into the collection set, then this region's free (not yet used) bytes are no longer\n+  \/\/ \"available\" to hold the results of other evacuations.  This may cause a decrease in the remaining amount\n+  \/\/ of memory that can still be evacuated.  We address this by reducing the evacuation budget by the amount\n+  \/\/ of live memory in that region and by the amount of unallocated memory in that region if the evacuation\n+  \/\/ budget is constrained by availability of free memory.\n+  size_t old_evacuation_budget = (size_t) ((double) heap->get_old_evac_reserve() \/ ShenandoahOldEvacWaste);\n+  size_t unfragmented_available = _old_generation->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n+  size_t fragmented_available;\n+  size_t excess_fragmented_available;\n+\n+  if (unfragmented_available > old_evacuation_budget) {\n+    unfragmented_available = old_evacuation_budget;\n+    fragmented_available = 0;\n+    excess_fragmented_available = 0;\n+  } else {\n+    assert(_old_generation->available() > old_evacuation_budget, \"Cannot budget more than is available\");\n+    fragmented_available = _old_generation->available() - unfragmented_available;\n+    assert(fragmented_available + unfragmented_available >= old_evacuation_budget, \"Budgets do not add up\");\n+    if (fragmented_available + unfragmented_available > old_evacuation_budget) {\n+      excess_fragmented_available = (fragmented_available + unfragmented_available) - old_evacuation_budget;\n+      fragmented_available -= excess_fragmented_available;\n+    }\n+  }\n+\n+  size_t remaining_old_evacuation_budget = old_evacuation_budget;\n+  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+               byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+               unprocessed_old_collection_candidates());\n+\n+  size_t lost_evacuation_capacity = 0;\n+\n+  \/\/ The number of old-gen regions that were selected as candidates for collection at the end of the most recent old-gen\n+  \/\/ concurrent marking phase and have not yet been collected is represented by unprocessed_old_collection_candidates().\n+  \/\/ Candidate regions are ordered according to increasing amount of live data.  If there is not sufficient room to\n+  \/\/ evacuate region N, then there is no need to even consider evacuating region N+1.\n+  while (unprocessed_old_collection_candidates() > 0) {\n+    \/\/ Old collection candidates are sorted in order of decreasing garbage contained therein.\n+    ShenandoahHeapRegion* r = next_old_collection_candidate();\n+    if (r == nullptr) {\n+      break;\n+    }\n+\n+    \/\/ If region r is evacuated to fragmented memory (to free memory within a partially used region), then we need\n+    \/\/ to decrease the capacity of the fragmented memory by the scaled loss.\n+\n+    size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    size_t lost_available = r->free();\n+\n+    if ((lost_available > 0) && (excess_fragmented_available > 0)) {\n+      if (lost_available < excess_fragmented_available) {\n+        excess_fragmented_available -= lost_available;\n+        lost_evacuation_capacity -= lost_available;\n+        lost_available  = 0;\n+      } else {\n+        lost_available -= excess_fragmented_available;\n+        lost_evacuation_capacity -= excess_fragmented_available;\n+        excess_fragmented_available = 0;\n+      }\n+    }\n+    size_t scaled_loss = (size_t) ((double) lost_available \/ ShenandoahOldEvacWaste);\n+    if ((lost_available > 0) && (fragmented_available > 0)) {\n+      if (scaled_loss + live_data_for_evacuation < fragmented_available) {\n+        fragmented_available -= scaled_loss;\n+        scaled_loss = 0;\n+      } else {\n+        \/\/ We will have to allocate this region's evacuation memory from unfragmented memory, so don't bother\n+        \/\/ to decrement scaled_loss\n+      }\n+    }\n+    if (scaled_loss > 0) {\n+      \/\/ We were not able to account for the lost free memory within fragmented memory, so we need to take this\n+      \/\/ allocation out of unfragmented memory.  Unfragmented memory does not need to account for loss of free.\n+      if (live_data_for_evacuation > unfragmented_available) {\n+        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        break;\n+      } else {\n+        unfragmented_available -= live_data_for_evacuation;\n+      }\n+    } else {\n+      \/\/ Since scaled_loss == 0, we have accounted for the loss of free memory, so we can allocate from either\n+      \/\/ fragmented or unfragmented available memory.  Use up the fragmented memory budget first.\n+      size_t evacuation_need = live_data_for_evacuation;\n+\n+      if (evacuation_need > fragmented_available) {\n+        evacuation_need -= fragmented_available;\n+        fragmented_available = 0;\n+      } else {\n+        fragmented_available -= evacuation_need;\n+        evacuation_need = 0;\n+      }\n+      if (evacuation_need > unfragmented_available) {\n+        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        break;\n+      } else {\n+        unfragmented_available -= evacuation_need;\n+        \/\/ dead code: evacuation_need == 0;\n+      }\n+    }\n+    collection_set->add_region(r);\n+    included_old_regions++;\n+    evacuated_old_bytes += live_data_for_evacuation;\n+    collected_old_bytes += r->garbage();\n+    consume_old_collection_candidate();\n+  }\n+\n+  if (_first_pinned_candidate != NOT_FOUND) {\n+    \/\/ Need to deal with pinned regions\n+    slide_pinned_regions_to_front();\n+  }\n+  decrease_unprocessed_old_collection_candidates_live_memory(evacuated_old_bytes);\n+  if (included_old_regions > 0) {\n+    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" SIZE_FORMAT \"%s, reclaiming: \" SIZE_FORMAT \"%s)\",\n+                 included_old_regions,\n+                 byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes),\n+                 byte_size_in_proper_unit(collected_old_bytes), proper_unit_for_byte_size(collected_old_bytes));\n+  }\n+\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    \/\/ We have added the last of our collection candidates to a mixed collection.\n+    \/\/ Any triggers that occurred during mixed evacuations may no longer be valid.  They can retrigger if appropriate.\n+    clear_triggers();\n+    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+  } else if (included_old_regions == 0) {\n+    \/\/ We have candidates, but none were included for evacuation - are they all pinned?\n+    \/\/ or did we just not have enough room for any of them in this collection set?\n+    \/\/ We don't want a region with a stuck pin to prevent subsequent old collections, so\n+    \/\/ if they are all pinned we transition to a state that will allow us to make these uncollected\n+    \/\/ (pinned) regions parseable.\n+    if (all_candidates_are_pinned()) {\n+      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n+      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+    } else {\n+      log_info(gc)(\"No regions selected for mixed collection. \"\n+                   \"Old evacuation budget: \" BYTES_FORMAT \", Remaining evacuation budget: \" BYTES_FORMAT\n+                   \", Lost capacity: \" BYTES_FORMAT\n+                   \", Next candidate: \" UINT32_FORMAT \", Last candidate: \" UINT32_FORMAT,\n+                   FORMAT_BYTES(heap->get_old_evac_reserve()),\n+                   FORMAT_BYTES(remaining_old_evacuation_budget),\n+                   FORMAT_BYTES(lost_evacuation_capacity),\n+                   _next_old_collection_candidate, _last_old_collection_candidate);\n+    }\n+  }\n+\n+  return (included_old_regions > 0);\n+}\n+\n+bool ShenandoahOldHeuristics::all_candidates_are_pinned() {\n+#ifdef ASSERT\n+  if (uint(os::random()) % 100 < ShenandoahCoalesceChance) {\n+    return true;\n+  }\n+#endif\n+\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; ++i) {\n+    ShenandoahHeapRegion* region = _region_data[i]._region;\n+    if (!region->is_pinned()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void ShenandoahOldHeuristics::slide_pinned_regions_to_front() {\n+  \/\/ Find the first unpinned region to the left of the next region that\n+  \/\/ will be added to the collection set. These regions will have been\n+  \/\/ added to the cset, so we can use them to hold pointers to regions\n+  \/\/ that were pinned when the cset was chosen.\n+  \/\/ [ r p r p p p r r ]\n+  \/\/     ^         ^ ^\n+  \/\/     |         | | pointer to next region to add to a mixed collection is here.\n+  \/\/     |         | first r to the left should be in the collection set now.\n+  \/\/     | first pinned region, we don't need to look past this\n+  uint write_index = NOT_FOUND;\n+  for (uint search = _next_old_collection_candidate - 1; search > _first_pinned_candidate; --search) {\n+    ShenandoahHeapRegion* region = _region_data[search]._region;\n+    if (!region->is_pinned()) {\n+      write_index = search;\n+      assert(region->is_cset(), \"Expected unpinned region to be added to the collection set.\");\n+      break;\n+    }\n+  }\n+\n+  \/\/ If we could not find an unpinned region, it means there are no slots available\n+  \/\/ to move up the pinned regions. In this case, we just reset our next index in the\n+  \/\/ hopes that some of these regions will become unpinned before the next mixed\n+  \/\/ collection. We may want to bailout of here instead, as it should be quite\n+  \/\/ rare to have so many pinned regions and may indicate something is wrong.\n+  if (write_index == NOT_FOUND) {\n+    assert(_first_pinned_candidate != NOT_FOUND, \"Should only be here if there are pinned regions.\");\n+    _next_old_collection_candidate = _first_pinned_candidate;\n+    return;\n+  }\n+\n+  \/\/ Find pinned regions to the left and move their pointer into a slot\n+  \/\/ that was pointing at a region that has been added to the cset (or was pointing\n+  \/\/ to a pinned region that we've already moved up). We are done when the leftmost\n+  \/\/ pinned region has been slid up.\n+  \/\/ [ r p r x p p p r ]\n+  \/\/         ^       ^\n+  \/\/         |       | next region for mixed collections\n+  \/\/         | Write pointer is here. We know this region is already in the cset\n+  \/\/         | so we can clobber it with the next pinned region we find.\n+  for (int32_t search = (int32_t)write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n+    RegionData& skipped = _region_data[search];\n+    if (skipped._region->is_pinned()) {\n+      RegionData& available_slot = _region_data[write_index];\n+      available_slot._region = skipped._region;\n+      available_slot._u._live_data = skipped._u._live_data;\n+      --write_index;\n+    }\n+  }\n+\n+  \/\/ Update to read from the leftmost pinned region. Plus one here because we decremented\n+  \/\/ the write index to hold the next found pinned region. We are just moving it back now\n+  \/\/ to point to the first pinned region.\n+  _next_old_collection_candidate = write_index + 1;\n+}\n+\n+\/\/ Both arguments are don't cares for old-gen collections\n+void ShenandoahOldHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set,\n+                                                    ShenandoahOldHeuristics* old_heuristics) {\n+  assert(collection_set == nullptr, \"Expect null\");\n+  assert(old_heuristics == nullptr, \"Expect null\");\n+  \/\/ Old-gen doesn't actually choose a collection set to be evacuated by its own gang of worker tasks.\n+  \/\/ Instead, it computes the set of regions to be evacuated by subsequent young-gen evacuation passes.\n+  prepare_for_old_collections();\n+}\n+\n+void ShenandoahOldHeuristics::prepare_for_old_collections() {\n+  assert(_generation->is_old(), \"This service only available for old-gc heuristics\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  size_t cand_idx = 0;\n+  size_t total_garbage = 0;\n+  size_t num_regions = heap->num_regions();\n+  size_t immediate_garbage = 0;\n+  size_t immediate_regions = 0;\n+  size_t live_data = 0;\n+\n+  RegionData* candidates = _region_data;\n+  for (size_t i = 0; i < num_regions; i++) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (!in_generation(region)) {\n+      continue;\n+    }\n+\n+    size_t garbage = region->garbage();\n+    size_t live_bytes = region->get_live_data_bytes();\n+    total_garbage += garbage;\n+    live_data += live_bytes;\n+\n+    if (region->is_regular() || region->is_pinned()) {\n+      if (!region->has_live()) {\n+        assert(!region->is_pinned(), \"Pinned region should have live (pinned) objects.\");\n+        region->make_trash_immediate();\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+      } else {\n+        region->begin_preemptible_coalesce_and_fill();\n+        candidates[cand_idx]._region = region;\n+        candidates[cand_idx]._u._live_data = live_bytes;\n+        cand_idx++;\n+      }\n+    } else if (region->is_humongous_start()) {\n+      if (!region->has_live()) {\n+        \/\/ The humongous object is dead, we can just return this region and the continuations\n+        \/\/ immediately to the freeset - no evacuations are necessary here. The continuations\n+        \/\/ will be made into trash by this method, so they'll be skipped by the 'is_regular'\n+        \/\/ check above, but we still need to count the start region.\n+        immediate_regions++;\n+        immediate_garbage += garbage;\n+        size_t region_count = heap->trash_humongous_region_at(region);\n+        log_debug(gc)(\"Trashed \" SIZE_FORMAT \" regions for humongous object.\", region_count);\n+      }\n+    } else if (region->is_trash()) {\n+      \/\/ Count humongous objects made into trash here.\n+      immediate_regions++;\n+      immediate_garbage += garbage;\n+    }\n+  }\n+\n+  _old_generation->set_live_bytes_after_last_mark(live_data);\n+\n+  \/\/ TODO: Consider not running mixed collects if we recovered some threshold percentage of memory from immediate garbage.\n+  \/\/ This would be similar to young and global collections shortcutting evacuation, though we'd probably want a separate\n+  \/\/ threshold for the old generation.\n+\n+  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first.  We sort by live-data.\n+  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n+  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n+  \/\/ in old-gen.\n+  QuickSort::sort<RegionData>(candidates, cand_idx, compare_by_live, false);\n+\n+  \/\/ Any old-gen region that contains (ShenandoahOldGarbageThreshold (default value 25)% garbage or more is to be\n+  \/\/ added to the list of candidates for subsequent mixed evacuations.\n+  \/\/\n+  \/\/ TODO: allow ShenandoahOldGarbageThreshold to be determined adaptively, by heuristics.\n+\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ The convention is to collect regions that have more than this amount of garbage.\n+  const size_t garbage_threshold = region_size_bytes * ShenandoahOldGarbageThreshold \/ 100;\n+\n+  \/\/ Englightened interpretation: collect regions that have less than this amount of live.\n+  const size_t live_threshold = region_size_bytes - garbage_threshold;\n+\n+  size_t candidates_garbage = 0;\n+  _last_old_region = (uint)cand_idx;\n+  _last_old_collection_candidate = (uint)cand_idx;\n+  _next_old_collection_candidate = 0;\n+\n+  size_t unfragmented = 0;\n+\n+  for (size_t i = 0; i < cand_idx; i++) {\n+    size_t live = candidates[i]._u._live_data;\n+    if (live > live_threshold) {\n+      \/\/ Candidates are sorted in increasing order of live data, so no regions after this will be below the threshold.\n+      _last_old_collection_candidate = (uint)i;\n+      break;\n+    }\n+    size_t region_garbage = candidates[i]._region->garbage();\n+    size_t region_free = candidates[i]._region->free();\n+    candidates_garbage += region_garbage;\n+    unfragmented += region_free;\n+  }\n+\n+  \/\/ Note that we do not coalesce and fill occupied humongous regions\n+  \/\/ HR: humongous regions, RR: regular regions, CF: coalesce and fill regions\n+  size_t collectable_garbage = immediate_garbage + candidates_garbage;\n+  size_t old_candidates = _last_old_collection_candidate;\n+  log_info(gc)(\"Old-Gen Collectable Garbage: \" SIZE_FORMAT \"%s \"\n+               \"consolidated with free: \" SIZE_FORMAT \"%s, over \" SIZE_FORMAT \" regions, \"\n+               \"Old-Gen Immediate Garbage: \" SIZE_FORMAT \"%s over \" SIZE_FORMAT \" regions.\",\n+               byte_size_in_proper_unit(collectable_garbage), proper_unit_for_byte_size(collectable_garbage),\n+               byte_size_in_proper_unit(unfragmented),        proper_unit_for_byte_size(unfragmented), old_candidates,\n+               byte_size_in_proper_unit(immediate_garbage),   proper_unit_for_byte_size(immediate_garbage), immediate_regions);\n+  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n+  set_unprocessed_old_collection_candidates_live_memory(mixed_evac_live);\n+  if (unprocessed_old_collection_candidates() == 0) {\n+    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+  } else {\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_EVAC);\n+  }\n+}\n+\n+size_t ShenandoahOldHeuristics::unprocessed_old_collection_candidates_live_memory() const {\n+  return _live_bytes_in_unprocessed_candidates;\n+}\n+\n+void ShenandoahOldHeuristics::set_unprocessed_old_collection_candidates_live_memory(size_t initial_live) {\n+  _live_bytes_in_unprocessed_candidates = initial_live;\n+}\n+\n+void ShenandoahOldHeuristics::decrease_unprocessed_old_collection_candidates_live_memory(size_t evacuated_live) {\n+  assert(evacuated_live <= _live_bytes_in_unprocessed_candidates, \"Cannot evacuate more than was present\");\n+  _live_bytes_in_unprocessed_candidates -= evacuated_live;\n+}\n+\n+\n+\/\/ TODO: Unused?\n+uint ShenandoahOldHeuristics::last_old_collection_candidate_index() {\n+  return _last_old_collection_candidate;\n+}\n+\n+uint ShenandoahOldHeuristics::unprocessed_old_collection_candidates() {\n+  return _last_old_collection_candidate - _next_old_collection_candidate;\n+}\n+\n+ShenandoahHeapRegion* ShenandoahOldHeuristics::next_old_collection_candidate() {\n+  while (_next_old_collection_candidate < _last_old_collection_candidate) {\n+    ShenandoahHeapRegion* next = _region_data[_next_old_collection_candidate]._region;\n+    if (!next->is_pinned()) {\n+      return next;\n+    } else {\n+      assert(next->is_pinned(), \"sanity\");\n+      if (_first_pinned_candidate == NOT_FOUND) {\n+        _first_pinned_candidate = _next_old_collection_candidate;\n+      }\n+    }\n+\n+    _next_old_collection_candidate++;\n+  }\n+  return nullptr;\n+}\n+\n+void ShenandoahOldHeuristics::consume_old_collection_candidate() {\n+  _next_old_collection_candidate++;\n+}\n+\n+uint ShenandoahOldHeuristics::last_old_region_index() const {\n+  return _last_old_region;\n+}\n+\n+unsigned int ShenandoahOldHeuristics::get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer) {\n+  uint end = _last_old_region;\n+  uint index = _next_old_collection_candidate;\n+  while (index < end) {\n+    *buffer++ = _region_data[index++]._region;\n+  }\n+  return (_last_old_region - _next_old_collection_candidate);\n+}\n+\n+void ShenandoahOldHeuristics::abandon_collection_candidates() {\n+  _last_old_collection_candidate = 0;\n+  _next_old_collection_candidate = 0;\n+  _last_old_region = 0;\n+}\n+\n+void ShenandoahOldHeuristics::handle_promotion_failure() {\n+  _promotion_failed = true;\n+}\n+\n+void ShenandoahOldHeuristics::record_cycle_start() {\n+  _trigger_heuristic->record_cycle_start();\n+}\n+\n+void ShenandoahOldHeuristics::record_cycle_end() {\n+  _trigger_heuristic->record_cycle_end();\n+  clear_triggers();\n+}\n+\n+void ShenandoahOldHeuristics::trigger_old_has_grown() {\n+  _growth_trigger = true;\n+}\n+\n+\n+void ShenandoahOldHeuristics::clear_triggers() {\n+  \/\/ Clear any triggers that were set during mixed evacuations.  Conditions may be different now that this phase has finished.\n+  _promotion_failed = false;\n+  _cannot_expand_trigger = false;\n+  _fragmentation_trigger = false;\n+  _growth_trigger = false;\n+ }\n+\n+bool ShenandoahOldHeuristics::should_start_gc() {\n+  \/\/ Cannot start a new old-gen GC until previous one has finished.\n+  \/\/\n+  \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n+  if (!_old_generation->can_start_gc()) {\n+    return false;\n+  }\n+\n+  if (_cannot_expand_trigger) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t old_gen_capacity = _old_generation->max_capacity();\n+    size_t heap_capacity = heap->capacity();\n+    double percent = 100.0 * ((double) old_gen_capacity) \/ heap_capacity;\n+    log_info(gc)(\"Trigger (OLD): Expansion failure, current size: \" SIZE_FORMAT \"%s which is %.1f%% of total heap size\",\n+                 byte_size_in_proper_unit(old_gen_capacity), proper_unit_for_byte_size(old_gen_capacity), percent);\n+    return true;\n+  }\n+\n+  if (_fragmentation_trigger) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t used = _old_generation->used();\n+    size_t used_regions_size = _old_generation->used_regions_size();\n+    size_t used_regions = _old_generation->used_regions();\n+    assert(used_regions_size > used_regions, \"Cannot have more used than used regions\");\n+    size_t fragmented_free = used_regions_size - used;\n+    double percent = 100.0 * ((double) fragmented_free) \/ used_regions_size;\n+    log_info(gc)(\"Trigger (OLD): Old has become fragmented: \"\n+                 SIZE_FORMAT \"%s available bytes spread between \" SIZE_FORMAT \" regions (%.1f%% free)\",\n+                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free), used_regions, percent);\n+    return true;\n+  }\n+\n+  if (_growth_trigger) {\n+    \/\/ Growth may be falsely triggered during mixed evacuations, before the mixed-evacuation candidates have been\n+    \/\/ evacuated.  Before acting on a false trigger, we check to confirm the trigger condition is still satisfied.\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t current_usage = _old_generation->used();\n+    size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n+    if (current_usage > trigger_threshold) {\n+      size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n+      double percent_growth = 100.0 * ((double) current_usage - live_at_previous_old) \/ live_at_previous_old;\n+      log_info(gc)(\"Trigger (OLD): Old has overgrown, live at end of previous OLD marking: \"\n+                   SIZE_FORMAT \"%s, current usage: \" SIZE_FORMAT \"%s, percent growth: %.1f%%\",\n+                   byte_size_in_proper_unit(live_at_previous_old), proper_unit_for_byte_size(live_at_previous_old),\n+                   byte_size_in_proper_unit(current_usage), proper_unit_for_byte_size(current_usage), percent_growth);\n+      return true;\n+    } else {\n+      _growth_trigger = false;\n+    }\n+  }\n+\n+  \/\/ Otherwise, defer to configured heuristic for gc trigger.\n+  return _trigger_heuristic->should_start_gc();\n+}\n+\n+bool ShenandoahOldHeuristics::should_degenerate_cycle() {\n+  return _trigger_heuristic->should_degenerate_cycle();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_concurrent(bool abbreviated) {\n+  \/\/ Forget any triggers that occured while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  _trigger_heuristic->record_success_concurrent(abbreviated);\n+}\n+\n+void ShenandoahOldHeuristics::record_success_degenerated() {\n+  \/\/ Forget any triggers that occured while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  _trigger_heuristic->record_success_degenerated();\n+}\n+\n+void ShenandoahOldHeuristics::record_success_full() {\n+  \/\/ Forget any triggers that occured while OLD GC was ongoing.  If we really need to start another, it will retrigger.\n+  clear_triggers();\n+  _trigger_heuristic->record_success_full();\n+}\n+\n+void ShenandoahOldHeuristics::record_allocation_failure_gc() {\n+  _trigger_heuristic->record_allocation_failure_gc();\n+}\n+\n+void ShenandoahOldHeuristics::record_requested_gc() {\n+  _trigger_heuristic->record_requested_gc();\n+}\n+\n+void ShenandoahOldHeuristics::reset_gc_learning() {\n+  _trigger_heuristic->reset_gc_learning();\n+}\n+\n+bool ShenandoahOldHeuristics::can_unload_classes() {\n+  return _trigger_heuristic->can_unload_classes();\n+}\n+\n+bool ShenandoahOldHeuristics::can_unload_classes_normal() {\n+  return _trigger_heuristic->can_unload_classes_normal();\n+}\n+\n+bool ShenandoahOldHeuristics::should_unload_classes() {\n+  return _trigger_heuristic->should_unload_classes();\n+}\n+\n+const char* ShenandoahOldHeuristics::name() {\n+  static char name[128];\n+  jio_snprintf(name, sizeof(name), \"%s (OLD)\", _trigger_heuristic->name());\n+  return name;\n+}\n+\n+bool ShenandoahOldHeuristics::is_diagnostic() {\n+  return false;\n+}\n+\n+bool ShenandoahOldHeuristics::is_experimental() {\n+  return true;\n+}\n+\n+void ShenandoahOldHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* set,\n+                                                                    ShenandoahHeuristics::RegionData* data,\n+                                                                    size_t data_size, size_t free) {\n+  ShouldNotReachHere();\n+}\n+\n+\n+#undef BYTES_FORMAT\n+#undef FORMAT_BYTES\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":625,"deletions":0,"binary":false,"changes":625,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n+\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+class ShenandoahCollectionSet;\n+class ShenandoahHeapRegion;\n+class ShenandoahOldGeneration;\n+\n+class ShenandoahOldHeuristics : public ShenandoahHeuristics {\n+\n+private:\n+\n+  static uint NOT_FOUND;\n+\n+  \/\/ After final marking of the old generation, this heuristic will select\n+  \/\/ a set of candidate regions to be included in subsequent mixed collections.\n+  \/\/ The regions are sorted into a `_region_data` array (declared in base\n+  \/\/ class) in decreasing order of garbage. The heuristic will give priority\n+  \/\/ to regions containing more garbage.\n+\n+  \/\/ The following members are used to keep track of which candidate regions\n+  \/\/ have yet to be added to a mixed collection. There is also some special\n+  \/\/ handling for pinned regions, described further below.\n+\n+  \/\/ Pinned regions may not be included in the collection set. Any old regions\n+  \/\/ which were pinned at the time when old regions were added to the mixed\n+  \/\/ collection will have been skipped. These regions are still contain garbage,\n+  \/\/ so we want to include them at the start of the list of candidates for the\n+  \/\/ _next_ mixed collection cycle. This variable is the index of the _first_\n+  \/\/ old region which is pinned when the mixed collection set is formed.\n+  uint _first_pinned_candidate;\n+\n+  \/\/ This is the index of the last region which is above the garbage threshold.\n+  \/\/ No regions after this will be considered for inclusion in a mixed collection\n+  \/\/ set.\n+  uint _last_old_collection_candidate;\n+\n+  \/\/ This index points to the first candidate in line to be added to the mixed\n+  \/\/ collection set. It is updated as regions are added to the collection set.\n+  uint _next_old_collection_candidate;\n+\n+  \/\/ This is the last index in the array of old regions which were active at\n+  \/\/ the end of old final mark.\n+  uint _last_old_region;\n+\n+  \/\/ How much live data must be evacuated from within the unprocessed mixed evacuation candidates?\n+  size_t _live_bytes_in_unprocessed_candidates;\n+\n+  \/\/ This can be the 'static' or 'adaptive' heuristic.\n+  ShenandoahHeuristics* _trigger_heuristic;\n+\n+  \/\/ Keep a pointer to our generation that we can use without down casting a protected member from the base class.\n+  ShenandoahOldGeneration* _old_generation;\n+\n+  \/\/ Flag is set when promotion failure is detected (by gc thread), and cleared when\n+  \/\/ old generation collection begins (by control thread).\n+  volatile bool _promotion_failed;\n+\n+  \/\/ Flags are set when promotion failure is detected (by gc thread), and cleared when\n+  \/\/ old generation collection begins (by control thread).  Flags are set and cleared at safepoints.\n+  bool _cannot_expand_trigger;\n+  bool _fragmentation_trigger;\n+  bool _growth_trigger;\n+\n+ protected:\n+  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set, RegionData* data, size_t data_size,\n+                                                     size_t free) override;\n+\n+public:\n+  ShenandoahOldHeuristics(ShenandoahOldGeneration* generation, ShenandoahHeuristics* trigger_heuristic);\n+\n+  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set, ShenandoahOldHeuristics* old_heuristics) override;\n+\n+  \/\/ Prepare for evacuation of old-gen regions by capturing the mark results of a recently completed concurrent mark pass.\n+  void prepare_for_old_collections();\n+\n+  \/\/ Return true iff the collection set is primed with at least one old-gen region.\n+  bool prime_collection_set(ShenandoahCollectionSet* set);\n+\n+  \/\/ How many old-collection candidates have not yet been processed?\n+  uint unprocessed_old_collection_candidates();\n+\n+  \/\/ How much live memory must be evacuated from within old-collection candidates that have not yet been processed?\n+  size_t unprocessed_old_collection_candidates_live_memory() const;\n+\n+  void set_unprocessed_old_collection_candidates_live_memory(size_t initial_live);\n+\n+  void decrease_unprocessed_old_collection_candidates_live_memory(size_t evacuated_live);\n+\n+  \/\/ How many old or hidden collection candidates have not yet been processed?\n+  uint last_old_collection_candidate_index();\n+\n+  \/\/ Return the next old-collection candidate in order of decreasing amounts of garbage.  (We process most-garbage regions\n+  \/\/ first.)  This does not consume the candidate.  If the candidate is selected for inclusion in a collection set, then\n+  \/\/ the candidate is consumed by invoking consume_old_collection_candidate().\n+  ShenandoahHeapRegion* next_old_collection_candidate();\n+\n+  \/\/ Adjust internal state to reflect that one fewer old-collection candidate remains to be processed.\n+  void consume_old_collection_candidate();\n+\n+  \/\/ How many old-collection regions were identified at the end of the most recent old-gen mark to require their\n+  \/\/ unmarked objects to be coalesced and filled?\n+  uint last_old_region_index() const;\n+\n+  \/\/ Fill in buffer with all of the old-collection regions that were identified at the end of the most recent old-gen\n+  \/\/ mark to require their unmarked objects to be coalesced and filled.  The buffer array must have at least\n+  \/\/ last_old_region_index() entries, or memory may be corrupted when this function overwrites the\n+  \/\/ end of the array.\n+  unsigned int get_coalesce_and_fill_candidates(ShenandoahHeapRegion** buffer);\n+\n+  \/\/ If a GLOBAL gc occurs, it will collect the entire heap which invalidates any collection candidates being\n+  \/\/ held by this heuristic for supplying mixed collections.\n+  void abandon_collection_candidates();\n+\n+  \/\/ Promotion failure does not currently trigger old-gen collections.  Often, promotion failures occur because\n+  \/\/ old-gen is sized too small rather than because it is necessary to collect old gen.  We keep the method\n+  \/\/ here in case we decide to feed this signal to sizing or triggering heuristics in the future.\n+  void handle_promotion_failure();\n+\n+  void trigger_cannot_expand() { _cannot_expand_trigger = true; };\n+  void trigger_old_is_fragmented() { _fragmentation_trigger = true; }\n+  void trigger_old_has_grown();\n+\n+  void clear_triggers();\n+\n+  virtual void record_cycle_start() override;\n+\n+  virtual void record_cycle_end() override;\n+\n+  virtual bool should_start_gc() override;\n+\n+  virtual bool should_degenerate_cycle() override;\n+\n+  virtual void record_success_concurrent(bool abbreviated) override;\n+\n+  virtual void record_success_degenerated() override;\n+\n+  virtual void record_success_full() override;\n+\n+  virtual void record_allocation_failure_gc() override;\n+\n+  virtual void record_requested_gc() override;\n+\n+  virtual void reset_gc_learning() override;\n+\n+  virtual bool can_unload_classes() override;\n+\n+  virtual bool can_unload_classes_normal() override;\n+\n+  virtual bool should_unload_classes() override;\n+\n+  virtual const char* name() override;\n+\n+  virtual bool is_diagnostic() override;\n+\n+  virtual bool is_experimental() override;\n+\n+ private:\n+  void slide_pinned_regions_to_front();\n+  bool all_candidates_are_pinned();\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHOLDHEURISTICS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -32,0 +32,3 @@\n+  ShenandoahPassiveHeuristics(ShenandoahGeneration* generation)\n+    : ShenandoahHeuristics(generation) {}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,1 +31,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,1 +36,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics() : ShenandoahHeuristics() {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahGeneration* generation) :\n+  ShenandoahHeuristics(generation) {\n@@ -43,5 +45,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _generation->max_capacity();\n+  size_t capacity     = _generation->soft_max_capacity();\n+  size_t available    = _generation->available();\n@@ -53,1 +53,1 @@\n-  size_t threshold_available = capacity \/ 100 * ShenandoahMinFreeThreshold;\n+  size_t threshold_available = min_free_threshold();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  ShenandoahStaticHeuristics();\n+  ShenandoahStaticHeuristics(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+\n+void ShenandoahGenerationalMode::initialize_flags() const {\n+  if (ClassUnloading) {\n+    FLAG_SET_DEFAULT(ShenandoahSuspendibleWorkers, true);\n+    FLAG_SET_DEFAULT(VerifyBeforeExit, false);\n+  }\n+\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(GCTimeRatio, 70);\n+  SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 0);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);\n+  SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);\n+\n+  \/\/ This helps most multi-core hardware hosts, enable by default\n+  SHENANDOAH_ERGO_ENABLE_FLAG(UseCondCardMark);\n+\n+  \/\/ Final configuration checks\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahLoadRefBarrier);\n+  SHENANDOAH_CHECK_FLAG_UNSET(ShenandoahIUBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahSATBBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCASBarrier);\n+  SHENANDOAH_CHECK_FLAG_SET(ShenandoahCloneBarrier);\n+}\n+\n+ShenandoahHeuristics* ShenandoahGenerationalMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n+  if (ShenandoahGCHeuristics == nullptr) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n+  }\n+\n+  if (strcmp(ShenandoahGCHeuristics, \"adaptive\") != 0) {\n+    vm_exit_during_initialization(\"Generational mode requires the (default) adaptive heuristic\");\n+  }\n+\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n+  vm_exit_during_initialization(\"Shenandoah Generational GC is not supported on this platform.\");\n+#endif\n+\n+  return new ShenandoahAdaptiveHeuristics(generation);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n+#define SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n+\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+\n+class ShenandoahGenerationalMode : public ShenandoahMode {\n+public:\n+  virtual void initialize_flags() const;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n+  virtual const char* name()     { return \"Generational\"; }\n+  virtual bool is_diagnostic()   { return false; }\n+  virtual bool is_experimental() { return true; }\n+  virtual bool is_generational() { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_MODE_SHENANDOAHGENERATIONALMODE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -26,4 +26,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -65,17 +62,0 @@\n-\n-ShenandoahHeuristics* ShenandoahIUMode::initialize_heuristics() const {\n-  if (ShenandoahGCHeuristics == nullptr) {\n-    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n-  }\n-  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-    return new ShenandoahAggressiveHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-    return new ShenandoahStaticHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-    return new ShenandoahAdaptiveHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-    return new ShenandoahCompactHeuristics();\n-  }\n-  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+\n+ShenandoahHeuristics* ShenandoahMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n+  if (ShenandoahGCHeuristics == nullptr) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n+  }\n+\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveHeuristics(generation);\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactHeuristics(generation);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n+  }\n+\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,2 @@\n+#include \"runtime\/java.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -30,0 +33,1 @@\n+class ShenandoahGeneration;\n@@ -31,0 +35,1 @@\n+class ShenandoahOldHeuristics;\n@@ -51,1 +56,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const = 0;\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n@@ -55,0 +60,1 @@\n+  virtual bool is_generational() { return false; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahMode.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -58,1 +58,1 @@\n-ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics() const {\n+ShenandoahHeuristics* ShenandoahPassiveMode::initialize_heuristics(ShenandoahGeneration* generation) const {\n@@ -62,1 +62,1 @@\n-  return new ShenandoahPassiveHeuristics();\n+  return new ShenandoahPassiveHeuristics(generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n-\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahGeneration* generation) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -53,17 +50,0 @@\n-\n-ShenandoahHeuristics* ShenandoahSATBMode::initialize_heuristics() const {\n-  if (ShenandoahGCHeuristics == nullptr) {\n-    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n-  }\n-  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-    return new ShenandoahAggressiveHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-    return new ShenandoahStaticHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-    return new ShenandoahAdaptiveHeuristics();\n-  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-    return new ShenandoahCompactHeuristics();\n-  }\n-  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n+\n+enum ShenandoahAffiliation {\n+  FREE,\n+  YOUNG_GENERATION,\n+  OLD_GENERATION,\n+};\n+\n+inline const char* shenandoah_affiliation_code(ShenandoahAffiliation type) {\n+  switch(type) {\n+    case FREE:\n+      return \"F\";\n+    case YOUNG_GENERATION:\n+      return \"Y\";\n+    case OLD_GENERATION:\n+      return \"O\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"?\";\n+  }\n+}\n+\n+inline const char* shenandoah_affiliation_name(ShenandoahAffiliation type) {\n+  switch (type) {\n+    case FREE:\n+      return \"FREE\";\n+    case YOUNG_GENERATION:\n+      return \"YOUNG\";\n+    case OLD_GENERATION:\n+      return \"OLD\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"?\";\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHAFFILIATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAffiliation.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n@@ -34,1 +36,1 @@\n-    _alloc_shared_gc,   \/\/ Allocate common, outside of GCLAB\n+    _alloc_shared_gc,   \/\/ Allocate common, outside of GCLAB\/PLAB\n@@ -37,0 +39,1 @@\n+    _alloc_plab,        \/\/ Allocate PLAB\n@@ -50,0 +53,2 @@\n+      case _alloc_plab:\n+        return \"PLAB\";\n@@ -57,0 +62,1 @@\n+  \/\/ When ShenandoahElasticTLAB is enabled, the request cannot be made smaller than _min_size.\n@@ -58,0 +64,2 @@\n+\n+  \/\/ The size of the request in words.\n@@ -59,0 +67,2 @@\n+\n+  \/\/ The allocation may be increased for padding or decreased to fit in the remaining space of a region.\n@@ -60,0 +70,8 @@\n+\n+  \/\/ For a humongous object, the _waste is the amount of free memory in the last region.\n+  \/\/ For other requests, the _waste will be non-zero if the request enountered one or more regions\n+  \/\/ with less memory than _min_size. This waste does not contribute to the used memory for\n+  \/\/ the heap, but it does contribute to the allocation rate for heuristics.\n+  size_t _waste;\n+\n+  \/\/ This is the type of the request.\n@@ -61,0 +79,4 @@\n+\n+  \/\/ This is the generation which the request is targeting.\n+  ShenandoahAffiliation const _affiliation;\n+\n@@ -62,0 +84,1 @@\n+  \/\/ Check that this is set before being read.\n@@ -65,1 +88,1 @@\n-  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n+  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation) :\n@@ -67,1 +90,1 @@\n-          _actual_size(0), _alloc_type(_alloc_type)\n+          _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation)\n@@ -75,1 +98,1 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab, ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -79,1 +102,5 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab, ShenandoahAffiliation::YOUNG_GENERATION);\n+  }\n+\n+  static inline ShenandoahAllocRequest for_plab(size_t min_size, size_t requested_size) {\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_plab, ShenandoahAffiliation::OLD_GENERATION);\n@@ -82,2 +109,2 @@\n-  static inline ShenandoahAllocRequest for_shared_gc(size_t requested_size) {\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc);\n+  static inline ShenandoahAllocRequest for_shared_gc(size_t requested_size, ShenandoahAffiliation affiliation) {\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc, affiliation);\n@@ -87,1 +114,1 @@\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared);\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared, ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -90,1 +117,1 @@\n-  inline size_t size() {\n+  inline size_t size() const {\n@@ -94,1 +121,1 @@\n-  inline Type type() {\n+  inline Type type() const {\n@@ -98,1 +125,1 @@\n-  inline const char* type_string() {\n+  inline const char* type_string() const {\n@@ -102,1 +129,1 @@\n-  inline size_t min_size() {\n+  inline size_t min_size() const {\n@@ -107,1 +134,1 @@\n-  inline size_t actual_size() {\n+  inline size_t actual_size() const {\n@@ -120,1 +147,9 @@\n-  inline bool is_mutator_alloc() {\n+  inline size_t waste() const {\n+    return _waste;\n+  }\n+\n+  inline void set_waste(size_t v) {\n+    _waste = v;\n+  }\n+\n+  inline bool is_mutator_alloc() const {\n@@ -126,0 +161,1 @@\n+      case _alloc_plab:\n@@ -134,1 +170,1 @@\n-  inline bool is_gc_alloc() {\n+  inline bool is_gc_alloc() const {\n@@ -140,0 +176,1 @@\n+      case _alloc_plab:\n@@ -148,1 +185,1 @@\n-  inline bool is_lab_alloc() {\n+  inline bool is_lab_alloc() const {\n@@ -152,0 +189,1 @@\n+      case _alloc_plab:\n@@ -161,0 +199,16 @@\n+\n+  bool is_old() const {\n+    return _affiliation == OLD_GENERATION;\n+  }\n+\n+  bool is_young() const {\n+    return _affiliation == YOUNG_GENERATION;\n+  }\n+\n+  ShenandoahAffiliation affiliation() const {\n+    return _affiliation;\n+  }\n+\n+  const char* affiliation_name() const {\n+    return shenandoah_affiliation_name(_affiliation);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocRequest.hpp","additions":70,"deletions":16,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -72,0 +73,7 @@\n+  \/\/ We use this as the time period for tracking minimum mutator utilization (MMU).\n+  \/\/ In generational mode, the MMU is used as a signal to adjust the size of the\n+  \/\/ young generation.\n+  if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {\n+    FLAG_SET_DEFAULT(GCPauseIntervalMillis, 5000);\n+  }\n+\n@@ -181,0 +189,2 @@\n+  CardTable::initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  if (heap->mode()->is_generational() && !obj->is_forwarded()) {\n+    msg.append(\"  age: %d\\n\", obj->age());\n+  }\n@@ -388,1 +391,1 @@\n-  ShenandoahMessageBuffer msg(\"Must ba at a Shenandoah safepoint or held %s lock\", lock->name());\n+  ShenandoahMessageBuffer msg(\"Must be at a Shenandoah safepoint or held %s lock\", lock->name());\n@@ -428,0 +431,17 @@\n+\n+\/\/ Unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM thread\n+\/\/ TODO: This should be more aptly named. Nothing in this method checks we are actually in Full GC.\n+void ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(const char* file, int line) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  if (heap->lock()->owned_by_self()) {\n+    return;\n+  }\n+\n+  if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {\n+    return;\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Heap lock must be owned by current thread, or be at safepoint\");\n+  report_vm_error(file, line, msg.buffer());\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -75,0 +76,1 @@\n+  static void assert_heaplocked_or_fullgc_safepoint(const char* file, int line);\n@@ -166,0 +168,8 @@\n+\n+#define shenandoah_assert_heaplocked_or_fullgc_safepoint() \\\n+                    ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(__FILE__, __LINE__)\n+#define shenandoah_assert_control_or_vm_thread() \\\n+                    assert(Thread::current()->is_VM_thread() || Thread::current() == ShenandoahHeap::heap()->control_thread(), \"Expected control thread or vm thread\")\n+\n+#define shenandoah_assert_generational() \\\n+                    assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Must be in generational mode here.\")\n@@ -216,0 +226,3 @@\n+#define shenandoah_assert_heaplocked_or_fullgc_safepoint()\n+#define shenandoah_assert_control_or_vm_thread()\n+#define shenandoah_assert_generational()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,1 +45,1 @@\n-ShenandoahBarrierSet::ShenandoahBarrierSet(ShenandoahHeap* heap) :\n+ShenandoahBarrierSet::ShenandoahBarrierSet(ShenandoahHeap* heap, MemRegion heap_region) :\n@@ -55,0 +56,4 @@\n+  if (heap->mode()->is_generational()) {\n+    _card_table = new ShenandoahCardTable(heap_region);\n+    _card_table->initialize();\n+  }\n@@ -127,0 +132,9 @@\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    \/\/ CAUTION: retire_plab may register the remnant filler object with the remembered set scanner without a lock.\n+    \/\/ This is safe iff it is assured that each PLAB is a whole-number multiple of card-mark memory size and each\n+    \/\/ PLAB is aligned with the start of each card's memory range.\n+    \/\/ TODO: Assert this in retire_plab?\n+    if (plab != nullptr) {\n+      _heap->retire_plab(plab);\n+    }\n+\n@@ -145,0 +159,21 @@\n+\n+void ShenandoahBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n+  if (!_heap->mode()->is_generational()) {\n+    return;\n+  }\n+\n+  HeapWord* end = (HeapWord*)((char*) start + (count * heapOopSize));\n+  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n+  \/\/ so we need to conservatively align the first downward (this is not\n+  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n+  \/\/ if you will, aesthetics) and the second upward (this is essential for\n+  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n+  \/\/ this write.\n+  HeapWord* aligned_start = align_down(start, HeapWordSize);\n+  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n+  \/\/ If compressed oops were not being used, these should already be aligned\n+  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n+         \"Expected heap word alignment of start and end\");\n+  _heap->card_scan()->mark_range_as_dirty(aligned_start, (aligned_end - aligned_start));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -37,0 +39,1 @@\n+  ShenandoahCardTable* _card_table;\n@@ -41,1 +44,1 @@\n-  ShenandoahBarrierSet(ShenandoahHeap* heap);\n+  ShenandoahBarrierSet(ShenandoahHeap* heap, MemRegion heap_region);\n@@ -49,0 +52,4 @@\n+  inline ShenandoahCardTable* card_table() {\n+    return _card_table;\n+  }\n+\n@@ -114,0 +121,5 @@\n+  template <DecoratorSet decorators, typename T>\n+  void write_ref_field_post(T* field);\n+\n+  void write_ref_array(HeapWord* start, size_t count);\n+\n@@ -116,1 +128,1 @@\n-  inline void arraycopy_marking(T* src, T* dst, size_t count);\n+  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -39,0 +41,2 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n@@ -106,0 +110,1 @@\n+      _heap->is_in_active_generation(obj) &&\n@@ -113,0 +118,1 @@\n+      _heap->is_in_active_generation(obj) &&\n@@ -182,0 +188,8 @@\n+template <DecoratorSet decorators, typename T>\n+inline void ShenandoahBarrierSet::write_ref_field_post(T* field) {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    volatile CardTable::CardValue* byte = card_table()->byte_for(field);\n+    *byte = CardTable::dirty_card_val();\n+  }\n+}\n+\n@@ -245,1 +259,4 @@\n-  shenandoah_assert_marked_if(nullptr, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress());\n+  shenandoah_assert_marked_if(nullptr, value,\n+                              !CompressedOops::is_null(value) &&\n+                              ShenandoahHeap::heap()->is_evacuation_in_progress() &&\n+                              !(ShenandoahHeap::heap()->is_gc_generation_young() && ShenandoahHeap::heap()->heap_region_containing(value)->is_old()));\n@@ -266,0 +283,2 @@\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  bs->write_ref_field_post<decorators>(addr);\n@@ -286,1 +305,3 @@\n-  return bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n+  oop result = bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n+  return result;\n@@ -294,1 +315,4 @@\n-  return bs->oop_cmpxchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+  auto addr = AccessInternal::oop_field_addr<decorators>(base, offset);\n+  oop result = bs->oop_cmpxchg(resolved_decorators, addr, compare_value, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n+  return result;\n@@ -310,1 +334,3 @@\n-  return bs->oop_xchg(decorators, addr, new_value);\n+  oop result = bs->oop_xchg(decorators, addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n+  return result;\n@@ -318,1 +344,4 @@\n-  return bs->oop_xchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+  auto addr = AccessInternal::oop_field_addr<decorators>(base, offset);\n+  oop result = bs->oop_xchg(resolved_decorators, addr, new_value);\n+  bs->write_ref_field_post<decorators>(addr);\n+  return result;\n@@ -335,0 +364,3 @@\n+  T* src = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n+  T* dst = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n+\n@@ -336,4 +368,4 @@\n-  bs->arraycopy_barrier(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),\n-                        arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),\n-                        length);\n-  return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n+  bs->arraycopy_barrier(src, dst, length);\n+  bool result = Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);\n+  bs->write_ref_array((HeapWord*) dst, length);\n+  return result;\n@@ -344,1 +376,3 @@\n-  assert(HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n+  \/\/ We allow forwarding in young generation and marking in old generation\n+  \/\/ to happen simultaneously.\n+  assert(_heap->mode()->is_generational() || HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n@@ -364,1 +398,1 @@\n-      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n@@ -377,3 +411,6 @@\n-  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count);\n-  } else if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n+  if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n+    arraycopy_marking(src, dst, count, false);\n+    return;\n+  }\n+\n+  if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n@@ -384,0 +421,11 @@\n+\n+  if (_heap->mode()->is_generational()) {\n+    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n+    \/\/ TODO: Could we optimize here by checking that dst is in an old region?\n+    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n+      \/\/ Note that we can't do the arraycopy marking using the 'src' array when\n+      \/\/ SATB mode is enabled (so we can't do this as part of the iteration for\n+      \/\/ evacuation or update references).\n+      arraycopy_marking(src, dst, count, true);\n+    }\n+  }\n@@ -387,1 +435,1 @@\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n@@ -389,3 +437,48 @@\n-  T* array = ShenandoahSATBBarrier ? dst : src;\n-  if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(array))) {\n-    arraycopy_work<T, false, false, true>(array, count);\n+  \/*\n+   * Note that an old-gen object is considered live if it is live at the start of OLD marking or if it is promoted\n+   * following the start of OLD marking.\n+   *\n+   * 1. Every object promoted following the start of OLD marking will be above TAMS within its old-gen region\n+   * 2. Every object live at the start of OLD marking will be referenced from a \"root\" or it will be referenced from\n+   *    another live OLD-gen object.  With regards to old-gen, roots include stack locations and all of live young-gen.\n+   *    All root references to old-gen are identified during a bootstrap young collection.  All references from other\n+   *    old-gen objects will be marked during the traversal of all old objects, or will be marked by the SATB barrier.\n+   *\n+   * During old-gen marking (which is interleaved with young-gen collections), call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in old-gen and it is below TAMS within its old-gen region\n+   * 2. Do not call arraycopy_work for any array residing in young-gen because young-gen collection is idle at this time\n+   *\n+   * During young-gen marking, call arraycopy_work() if:\n+   *\n+   * 1. The overwritten array resides in young-gen and is below TAMS within its young-gen region\n+   * 2. Additionally, if array resides in old-gen, regardless of its relationship to TAMS because this old-gen array\n+   *    may hold references to young-gen\n+   *\/\n+  if (ShenandoahSATBBarrier) {\n+    T* array = dst;\n+    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n+    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n+    if (is_old_marking) {\n+      \/\/ Generational, old marking\n+      assert(_heap->mode()->is_generational(), \"Invariant\");\n+      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (_heap->mode()->is_generational()) {\n+      \/\/ Generational, young marking\n+      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n+        arraycopy_work<T, false, false, true>(array, count);\n+      }\n+    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n+      \/\/ Non-generational, marking\n+      arraycopy_work<T, false, false, true>(array, count);\n+    }\n+  } else {\n+    \/\/ Incremental Update mode, marking\n+    T* array = src;\n+    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n+    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n+    if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n+      arraycopy_work<T, false, false, true>(array, count);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":111,"deletions":18,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -107,0 +107,4 @@\n+  \/\/ We only need to handle YOUNG_MARKING here because the clone barrier\n+  \/\/ is only invoked during marking if Shenandoah is in incremental update\n+  \/\/ mode. OLD_MARKING should only happen when Shenandoah is in generational\n+  \/\/ mode, which uses the SATB write barrier.\n@@ -108,1 +112,1 @@\n-  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+  if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved. *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+#ifndef PRODUCT\n+void ShenandoahCardStats::log() const {\n+  if (ShenandoahEnableCardStats) {\n+    log_info(gc,remset)(\"Card stats: dirty \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" clean \" SIZE_FORMAT \" (max run: \" SIZE_FORMAT \"),\"\n+      \" dirty scans\/objs \" SIZE_FORMAT,\n+      _dirty_card_cnt, _max_dirty_run,\n+      _clean_card_cnt, _max_clean_run,\n+      _dirty_scan_obj_cnt);\n+  }\n+}\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+\n+enum CardStatType {\n+  DIRTY_RUN           = 0,\n+  CLEAN_RUN           = 1,\n+  DIRTY_CARDS         = 2,\n+  CLEAN_CARDS         = 3,\n+  MAX_DIRTY_RUN       = 4,\n+  MAX_CLEAN_RUN       = 5,\n+  DIRTY_SCAN_OBJS     = 6,\n+  ALTERNATIONS        = 7,\n+  MAX_CARD_STAT_TYPE  = 8\n+};\n+\n+enum CardStatLogType {\n+  CARD_STAT_SCAN_RS       = 0,\n+  CARD_STAT_UPDATE_REFS   = 1,\n+  MAX_CARD_STAT_LOG_TYPE  = 2\n+};\n+\n+class ShenandoahCardStats: public CHeapObj<mtGC> {\n+private:\n+  size_t _cards_in_cluster;\n+  HdrSeq* _local_card_stats;\n+\n+  size_t _dirty_card_cnt;\n+  size_t _clean_card_cnt;\n+\n+  size_t _max_dirty_run;\n+  size_t _max_clean_run;\n+\n+  size_t _dirty_scan_obj_cnt;\n+\n+  size_t _alternation_cnt;\n+\n+public:\n+  ShenandoahCardStats(size_t cards_in_cluster, HdrSeq* card_stats) :\n+    _cards_in_cluster(cards_in_cluster),\n+    _local_card_stats(card_stats),\n+    _dirty_card_cnt(0),\n+    _clean_card_cnt(0),\n+    _max_dirty_run(0),\n+    _max_clean_run(0),\n+    _dirty_scan_obj_cnt(0),\n+    _alternation_cnt(0)\n+  { }\n+\n+  ~ShenandoahCardStats() {\n+    record();\n+   }\n+\n+   void record() {\n+    if (ShenandoahEnableCardStats) {\n+      \/\/ Update global stats for distribution of dirty\/clean cards as a percentage of chunk\n+      _local_card_stats[DIRTY_CARDS].add(percent_of(_dirty_card_cnt, _cards_in_cluster));\n+      _local_card_stats[CLEAN_CARDS].add(percent_of(_clean_card_cnt, _cards_in_cluster));\n+\n+      \/\/ Update global stats for max dirty\/clean run distribution as a percentage of chunk\n+      _local_card_stats[MAX_DIRTY_RUN].add(percent_of(_max_dirty_run, _cards_in_cluster));\n+      _local_card_stats[MAX_CLEAN_RUN].add(percent_of(_max_clean_run, _cards_in_cluster));\n+\n+      \/\/ Update global stats for dirty obj scan counts\n+      _local_card_stats[DIRTY_SCAN_OBJS].add(_dirty_scan_obj_cnt);\n+\n+      \/\/ Update global stats for alternation counts\n+      _local_card_stats[ALTERNATIONS].add(_alternation_cnt);\n+    }\n+  }\n+\n+public:\n+  inline void record_dirty_run(size_t len) {\n+    if (ShenandoahEnableCardStats) {\n+      _alternation_cnt++;\n+      if (len > _max_dirty_run) {\n+        _max_dirty_run = len;\n+      }\n+      _dirty_card_cnt += len;\n+      assert(len <= _cards_in_cluster, \"Error\");\n+      _local_card_stats[DIRTY_RUN].add(percent_of(len, _cards_in_cluster));\n+    }\n+  }\n+\n+  inline void record_clean_run(size_t len) {\n+    if (ShenandoahEnableCardStats) {\n+      _alternation_cnt++;\n+      if (len > _max_clean_run) {\n+        _max_clean_run = len;\n+      }\n+      _clean_card_cnt += len;\n+      assert(len <= _cards_in_cluster, \"Error\");\n+      _local_card_stats[CLEAN_RUN].add(percent_of(len, _cards_in_cluster));\n+    }\n+  }\n+\n+  inline void record_scan_obj_cnt(size_t i) {\n+    if (ShenandoahEnableCardStats) {\n+      _dirty_scan_obj_cnt += i;\n+    }\n+  }\n+\n+  void log() const PRODUCT_RETURN;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCARDSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"runtime\/init.hpp\"\n+#include \"services\/memTracker.hpp\"\n+\n+void ShenandoahCardTable::initialize() {\n+  size_t num_cards = cards_required(_whole_heap.word_size());\n+\n+  \/\/ each card takes 1 byte; + 1 for the guard card\n+  size_t num_bytes = num_cards + 1;\n+  const size_t granularity = os::vm_allocation_granularity();\n+  _byte_map_size = align_up(num_bytes, MAX2(_page_size, granularity));\n+\n+  HeapWord* low_bound  = _whole_heap.start();\n+  HeapWord* high_bound = _whole_heap.end();\n+\n+  \/\/ TODO: Why rs_align is 0 on page_size == os::vm_page_size?\n+  \/\/ ReservedSpace constructor would assert rs_align >= os::vm_page_size().\n+  const size_t rs_align = _page_size == os::vm_page_size() ? 0 : MAX2(_page_size, granularity);\n+\n+  ReservedSpace write_space(_byte_map_size, rs_align, _page_size);\n+  initialize(write_space);\n+\n+  \/\/ The assembler store_check code will do an unsigned shift of the oop,\n+  \/\/ then add it to _byte_map_base, i.e.\n+  \/\/\n+  \/\/   _byte_map = _byte_map_base + (uintptr_t(low_bound) >> card_shift)\n+  _byte_map = (CardValue*) write_space.base();\n+  _byte_map_base = _byte_map - (uintptr_t(low_bound) >> _card_shift);\n+  assert(byte_for(low_bound) == &_byte_map[0], \"Checking start of map\");\n+  assert(byte_for(high_bound-1) <= &_byte_map[last_valid_index()], \"Checking end of map\");\n+\n+  CardValue* guard_card = &_byte_map[num_cards];\n+  assert(is_aligned(guard_card, _page_size), \"must be on its own OS page\");\n+  _guard_region = MemRegion((HeapWord*)guard_card, _page_size);\n+\n+  _write_byte_map = _byte_map;\n+  _write_byte_map_base = _byte_map_base;\n+\n+  ReservedSpace read_space(_byte_map_size, rs_align, _page_size);\n+  initialize(read_space);\n+\n+  _read_byte_map = (CardValue*) read_space.base();\n+  _read_byte_map_base = _read_byte_map - (uintptr_t(low_bound) >> card_shift());\n+  assert(read_byte_for(low_bound) == &_read_byte_map[0], \"Checking start of map\");\n+  assert(read_byte_for(high_bound-1) <= &_read_byte_map[last_valid_index()], \"Checking end of map\");\n+\n+  _covered[0] = _whole_heap;\n+\n+  log_trace(gc, barrier)(\"ShenandoahCardTable::ShenandoahCardTable:\");\n+  log_trace(gc, barrier)(\"    &_write_byte_map[0]: \" INTPTR_FORMAT \"  &_write_byte_map[_last_valid_index]: \" INTPTR_FORMAT,\n+                         p2i(&_write_byte_map[0]), p2i(&_write_byte_map[last_valid_index()]));\n+  log_trace(gc, barrier)(\"    _write_byte_map_base: \" INTPTR_FORMAT, p2i(_write_byte_map_base));\n+  log_trace(gc, barrier)(\"    &_read_byte_map[0]: \" INTPTR_FORMAT \"  &_read_byte_map[_last_valid_index]: \" INTPTR_FORMAT,\n+                  p2i(&_read_byte_map[0]), p2i(&_read_byte_map[last_valid_index()]));\n+  log_trace(gc, barrier)(\"    _read_byte_map_base: \" INTPTR_FORMAT, p2i(_read_byte_map_base));\n+\n+  \/\/ TODO: As currently implemented, we do not swap pointers between _read_byte_map and _write_byte_map\n+  \/\/ because the mutator write barrier hard codes the address of the _write_byte_map_base.  Instead,\n+  \/\/ the current implementation simply copies contents of _write_byte_map onto _read_byte_map and cleans\n+  \/\/ the entirety of _write_byte_map at the init_mark safepoint.\n+  \/\/\n+  \/\/ If we choose to modify the mutator write barrier so that we can swap _read_byte_map_base and\n+  \/\/ _write_byte_map_base pointers, we may also have to figure out certain details about how the\n+  \/\/ _guard_region is implemented so that we can replicate the read and write versions of this region.\n+  \/\/\n+  \/\/ Alternatively, we may switch to a SATB-based write barrier and replace the direct card-marking\n+  \/\/ remembered set with something entirely different.\n+}\n+\n+void ShenandoahCardTable::initialize(const ReservedSpace& card_table) {\n+  MemTracker::record_virtual_memory_type((address)card_table.base(), mtGC);\n+\n+  os::trace_page_sizes(\"Card Table\", _byte_map_size, _byte_map_size,\n+                       _page_size, card_table.base(), card_table.size());\n+  if (!card_table.is_reserved()) {\n+    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n+  }\n+  os::commit_memory_or_exit(card_table.base(), _byte_map_size, card_table.alignment(), false,\n+                            \"Cannot commit memory for card table\");\n+}\n+\n+bool ShenandoahCardTable::is_in_young(const void* obj) const {\n+  return ShenandoahHeap::heap()->is_in_young(obj);\n+}\n+\n+CardValue* ShenandoahCardTable::read_byte_for(const void* p) {\n+    CardValue* result = &_read_byte_map_base[uintptr_t(p) >> _card_shift];\n+    assert(result >= _read_byte_map && result < _read_byte_map + _byte_map_size,\n+           \"out of bounds accessor for card marking array\");\n+    return result;\n+}\n+\n+size_t ShenandoahCardTable::last_valid_index() {\n+  return CardTable::last_valid_index();\n+}\n+\n+\/\/ TODO: This service is not currently used because we are not able to swap _read_byte_map_base and\n+\/\/ _write_byte_map_base pointers.  If we were able to do so, we would invoke clear_read_table \"immediately\"\n+\/\/ following the end of concurrent remembered set scanning so that this read card table would be ready\n+\/\/ to serve as the new write card table at the time these pointer values were next swapped.\n+\/\/\n+\/\/ In the current implementation, the write-table is cleared immediately after its contents is copied to\n+\/\/ the read table, obviating the need for this service.\n+void ShenandoahCardTable::clear_read_table() {\n+  for (size_t i = 0; i < _byte_map_size; i++) {\n+    _read_byte_map[i] = clean_card;\n+  }\n+}\n+\n+\/\/ TODO: This service is not currently used because the mutator write barrier implementation hard codes the\n+\/\/ location of the _write_byte_may_base.  If we change the mutator's write barrier implementation, then we\n+\/\/ may use this service to exchange the roles of the read-card-table and write-card-table.\n+void ShenandoahCardTable::swap_card_tables() {\n+  shenandoah_assert_safepoint();\n+\n+  CardValue* save_value = _read_byte_map;\n+  _read_byte_map = _write_byte_map;\n+  _write_byte_map = save_value;\n+\n+  save_value = _read_byte_map_base;\n+  _read_byte_map_base = _write_byte_map_base;\n+  _write_byte_map_base = save_value;\n+\n+  \/\/ update the superclass instance variables\n+  _byte_map = _write_byte_map;\n+  _byte_map_base = _write_byte_map_base;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n+\n+#include \"gc\/g1\/g1RegionToSpaceMapper.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class ShenandoahCardTable: public CardTable {\n+  friend class VMStructs;\n+\n+protected:\n+  \/\/ We maintain two copies of the card table to facilitate concurrent remembered set scanning\n+  \/\/ and concurrent clearing of stale remembered set information.  During the init_mark safepoint,\n+  \/\/ we copy the contents of _write_byte_map to _read_byte_map and clear _write_byte_map.\n+  \/\/\n+  \/\/ Concurrent remembered set scanning reads from _read_byte_map while concurrent mutator write\n+  \/\/ barriers are overwriting cards of the _write_byte_map with DIRTY codes.  Concurrent remembered\n+  \/\/ set scanning also overwrites cards of the _write_byte_map with DIRTY codes whenever it discovers\n+  \/\/ interesting pointers.\n+  \/\/\n+  \/\/ During a concurrent update-references phase, we scan the _write_byte_map concurrently to find\n+  \/\/ all old-gen references that may need to be updated.\n+  \/\/\n+  \/\/ In a future implementation, we may swap the values of _read_byte_map and _write_byte_map during\n+  \/\/ the init-mark safepoint to avoid the need for bulk STW copying and initialization.  Doing so\n+  \/\/ requires a change to the implementation of mutator write barriers as the address of the card\n+  \/\/ table is currently in-lined and hard-coded.\n+  CardValue* _read_byte_map;\n+  CardValue* _write_byte_map;\n+  CardValue* _read_byte_map_base;\n+  CardValue* _write_byte_map_base;\n+\n+public:\n+  ShenandoahCardTable(MemRegion whole_heap) : CardTable(whole_heap) { }\n+\n+  virtual void initialize();\n+\n+  virtual bool is_in_young(const void* obj) const;\n+\n+  CardValue* read_byte_for(const void* p);\n+\n+  size_t last_valid_index();\n+\n+  void clear_read_table();\n+\n+  \/\/ Exchange the roles of the read and write card tables.\n+  void swap_card_tables();\n+\n+  CardValue* read_byte_map() {\n+    return _read_byte_map;\n+  }\n+\n+  CardValue* write_byte_map() {\n+    return _write_byte_map;\n+  }\n+\n+  CardValue* read_byte_map_base() {\n+    return _read_byte_map_base;\n+  }\n+\n+  CardValue* write_byte_map_base() {\n+    return _write_byte_map_base;\n+  }\n+\n+private:\n+  void initialize(const ReservedSpace& card_table);\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHCARDTABLE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -51,1 +52,1 @@\n-  return _mark_context->is_marked(obj);\n+  return _mark_context->is_marked_or_old(obj);\n@@ -63,1 +64,1 @@\n-  return _mark_context->is_marked(obj);\n+  return _mark_context->is_marked_or_old(obj);\n@@ -91,1 +92,1 @@\n-  assert(!ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress() || !ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -43,0 +44,1 @@\n+  _has_old_regions(false),\n@@ -45,0 +47,1 @@\n+  _live(0),\n@@ -46,0 +49,1 @@\n+  _old_garbage(0),\n@@ -86,0 +90,2 @@\n+  assert(!r->is_humongous(), \"Only add regular regions to the collection set\");\n+\n@@ -87,0 +93,17 @@\n+  size_t live    = r->get_live_data_bytes();\n+  size_t garbage = r->garbage();\n+  size_t free    = r->free();\n+  if (r->is_young()) {\n+    _young_region_count++;\n+    _young_bytes_to_evacuate += live;\n+    _young_available_bytes_collected += free;\n+    if (r->age() >= InitialTenuringThreshold) {\n+      _young_bytes_to_promote += live;\n+    }\n+  } else if (r->is_old()) {\n+    _old_region_count++;\n+    _old_bytes_to_evacuate += live;\n+    _old_garbage += garbage;\n+    _old_available_bytes_collected += free;\n+  }\n+\n@@ -88,1 +111,2 @@\n-  _garbage += r->garbage();\n+  _has_old_regions |= r->is_old();\n+  _garbage += garbage;\n@@ -90,1 +114,1 @@\n-\n+  _live += live;\n@@ -97,0 +121,1 @@\n+\n@@ -106,0 +131,1 @@\n+  _old_garbage = 0;\n@@ -107,0 +133,1 @@\n+  _live = 0;\n@@ -110,0 +137,12 @@\n+\n+  _young_region_count = 0;\n+  _young_bytes_to_evacuate = 0;\n+  _young_bytes_to_promote = 0;\n+\n+  _old_region_count = 0;\n+  _old_bytes_to_evacuate = 0;\n+\n+  _young_available_bytes_collected = 0;\n+  _old_available_bytes_collected = 0;\n+\n+  _has_old_regions = false;\n@@ -153,1 +192,5 @@\n-  out->print_cr(\"Collection Set : \" SIZE_FORMAT \"\", count());\n+  out->print_cr(\"Collection Set: Regions: \"\n+                SIZE_FORMAT \", Garbage: \" SIZE_FORMAT \"%s, Live: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s\", count(),\n+                byte_size_in_proper_unit(garbage()), proper_unit_for_byte_size(garbage()),\n+                byte_size_in_proper_unit(live()),    proper_unit_for_byte_size(live()),\n+                byte_size_in_proper_unit(used()),    proper_unit_for_byte_size(used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -46,0 +47,1 @@\n+  bool                  _has_old_regions;\n@@ -48,0 +50,1 @@\n+  size_t                _live;\n@@ -49,0 +52,21 @@\n+  size_t                _immediate_trash;\n+\n+  size_t                _young_bytes_to_evacuate;\n+  size_t                _young_bytes_to_promote;\n+  size_t                _old_bytes_to_evacuate;\n+\n+  size_t                _young_region_count;\n+  size_t                _old_region_count;\n+\n+  \/\/ How many bytes of old garbage are present in a mixed collection set?\n+  size_t                _old_garbage;\n+\n+  \/\/ Points to array identifying which tenure-age regions have been preselected\n+  \/\/ for inclusion in collection set. This field is only valid during brief\n+  \/\/ spans of time while collection set is being constructed.\n+  bool*                 _preselected_regions;\n+\n+  \/\/ When a region having memory available to be allocated is added to the collection set, the region's available memory\n+  \/\/ should be subtracted from what's available.\n+  size_t                _young_available_bytes_collected;\n+  size_t                _old_available_bytes_collected;\n@@ -80,2 +104,33 @@\n-  size_t used()      const { return _used; }\n-  size_t garbage()   const { return _garbage;   }\n+  inline size_t get_immediate_trash();\n+  inline void set_immediate_trash(size_t immediate_trash);\n+\n+  \/\/ This represents total amount of work to be performed by evacuation, including evacuations to young, to old,\n+  \/\/ and promotions from young to old.  This equals get_young_bytes_reserved_for_evacuation() plus\n+  \/\/ get_old_bytes_reserved_for_evacuation().\n+  \/\/ TODO: Seems unused.\n+  inline size_t get_bytes_reserved_for_evacuation();\n+\n+  \/\/ It is not known how many of these bytes will be promoted.\n+  inline size_t get_young_bytes_reserved_for_evacuation();\n+  inline size_t get_old_bytes_reserved_for_evacuation();\n+\n+  inline size_t get_young_bytes_to_be_promoted();\n+\n+  size_t get_young_available_bytes_collected() { return _young_available_bytes_collected; }\n+\n+  size_t get_old_available_bytes_collected() { return _old_available_bytes_collected; }\n+\n+  inline size_t get_old_region_count();\n+  inline size_t get_young_region_count();\n+\n+  inline size_t get_old_garbage();\n+\n+  void establish_preselected(bool *preselected) { _preselected_regions = preselected; }\n+  void abandon_preselected() { _preselected_regions = nullptr; }\n+  bool is_preselected(size_t region_idx) { return (_preselected_regions != nullptr) && _preselected_regions[region_idx]; }\n+\n+  bool has_old_regions() const { return _has_old_regions; }\n+  size_t used()          const { return _used; }\n+  size_t live()          const { return _live; }\n+  size_t garbage()       const { return _garbage; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -56,0 +57,36 @@\n+void ShenandoahCollectionSet::set_immediate_trash(size_t immediate_trash) {\n+  _immediate_trash = immediate_trash;\n+}\n+\n+size_t ShenandoahCollectionSet::get_immediate_trash() {\n+  return _immediate_trash;\n+}\n+\n+size_t ShenandoahCollectionSet::get_old_bytes_reserved_for_evacuation() {\n+  return _old_bytes_to_evacuate;\n+}\n+\n+size_t ShenandoahCollectionSet::get_young_bytes_reserved_for_evacuation() {\n+  return _young_bytes_to_evacuate - _young_bytes_to_promote;\n+}\n+\n+size_t ShenandoahCollectionSet::get_young_bytes_to_be_promoted() {\n+  return _young_bytes_to_promote;\n+}\n+\n+size_t ShenandoahCollectionSet::get_bytes_reserved_for_evacuation() {\n+  return _young_bytes_to_evacuate + _old_bytes_to_evacuate;\n+}\n+\n+size_t ShenandoahCollectionSet::get_old_region_count() {\n+  return _old_region_count;\n+}\n+\n+size_t ShenandoahCollectionSet::get_young_region_count() {\n+  return _young_region_count;\n+}\n+\n+size_t ShenandoahCollectionSet::get_old_garbage() {\n+  return _old_garbage;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,4 @@\n+  _mixed_gcs(0),\n+  _abbreviated_cycles(0),\n+  _success_old_gcs(0),\n+  _interrupted_old_gcs(0),\n@@ -78,0 +83,1 @@\n+  ShenandoahHeap::heap()->record_upgrade_to_full();\n@@ -85,0 +91,16 @@\n+void ShenandoahCollectorPolicy::record_mixed_cycle() {\n+  _mixed_gcs++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_abbreviated_cycle() {\n+  _abbreviated_cycles++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_success_old() {\n+  _success_old_gcs++;\n+}\n+\n+void ShenandoahCollectorPolicy::record_interrupted_old() {\n+  _interrupted_old_gcs++;\n+}\n+\n@@ -109,0 +131,6 @@\n+\/\/ This may be called by mutator threads.  We declare _success_full_gcs volatile to force the value not to be cached\n+\/\/ in a local register or variable by a mutator thread that is checking this value in a loop.\n+size_t ShenandoahCollectorPolicy::get_fullgc_count() {\n+  return _success_full_gcs + _alloc_failure_degenerated_upgrade_to_full;\n+}\n+\n@@ -113,1 +141,2 @@\n-  out->print_cr(\"to avoid Degenerated and Full GC cycles.\");\n+  out->print_cr(\"to avoid Degenerated and Full GC cycles. Abbreviated cycles are those which found\");\n+  out->print_cr(\"enough regions with no live objects to skip evacuation.\");\n@@ -116,1 +145,1 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" successful concurrent GCs\",         _success_concurrent_gcs);\n+  out->print_cr(SIZE_FORMAT_W(5) \" Successful Concurrent GCs\",         _success_concurrent_gcs);\n@@ -121,0 +150,5 @@\n+  out->print_cr(SIZE_FORMAT_W(5) \" Completed Old GCs\",                 _success_old_gcs);\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" mixed\",                        _mixed_gcs);\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" interruptions\",                _interrupted_old_gcs);\n+  out->cr();\n+\n@@ -132,0 +166,3 @@\n+  out->print_cr(SIZE_FORMAT_W(5) \" Abbreviated GCs\",                   _abbreviated_cycles);\n+  out->cr();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -42,0 +43,4 @@\n+  size_t _mixed_gcs;\n+  size_t _abbreviated_cycles;\n+  size_t _success_old_gcs;\n+  size_t _interrupted_old_gcs;\n@@ -43,1 +48,1 @@\n-  size_t _success_full_gcs;\n+  volatile size_t _success_full_gcs;\n@@ -45,1 +50,1 @@\n-  size_t _alloc_failure_degenerated_upgrade_to_full;\n+  volatile size_t _alloc_failure_degenerated_upgrade_to_full;\n@@ -51,0 +56,1 @@\n+  size_t _cycle_counter;\n@@ -54,1 +60,0 @@\n-\n@@ -57,2 +62,0 @@\n-  size_t _cycle_counter;\n-\n@@ -66,0 +69,2 @@\n+  void record_mixed_cycle();\n+  void record_abbreviated_cycle();\n@@ -67,0 +72,2 @@\n+  void record_success_old();\n+  void record_interrupted_old();\n@@ -84,0 +91,2 @@\n+  size_t get_fullgc_count();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,0 +35,3 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -88,3 +92,6 @@\n-ShenandoahConcurrentGC::ShenandoahConcurrentGC() :\n-  _mark(),\n-  _degen_point(ShenandoahDegenPoint::_degenerated_unset) {\n+ShenandoahConcurrentGC::ShenandoahConcurrentGC(ShenandoahGeneration* generation, bool do_old_gc_bootstrap) :\n+  _mark(generation),\n+  _degen_point(ShenandoahDegenPoint::_degenerated_unset),\n+  _abbreviated(false),\n+  _do_old_gc_bootstrap(do_old_gc_bootstrap),\n+  _generation(generation) {\n@@ -97,4 +104,0 @@\n-void ShenandoahConcurrentGC::cancel() {\n-  ShenandoahConcurrentMark::cancel();\n-}\n-\n@@ -103,0 +106,2 @@\n+  heap->start_conc_gc();\n+\n@@ -113,0 +118,10 @@\n+\n+    \/\/ Reset task queue stats here, rather than in mark_concurrent_roots,\n+    \/\/ because remembered set scan will `push` oops into the queues and\n+    \/\/ resetting after this happens will lose those counts.\n+    TASKQUEUE_STATS_ONLY(_mark.task_queues()->reset_taskqueue_stats());\n+\n+    \/\/ Concurrent remembered set scanning\n+    entry_scan_remembered_set();\n+    \/\/ TODO: When RS scanning yields, we will need a check_cancellation_and_abort() degeneration point here.\n+\n@@ -115,1 +130,1 @@\n-    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_outside_cycle)) return false;\n+    if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_roots)) return false;\n@@ -125,0 +140,13 @@\n+  \/\/ If GC was cancelled before final mark, then the safepoint operation will do nothing\n+  \/\/ and the concurrent mark will still be in progress. In this case it is safe to resume\n+  \/\/ the degenerated cycle from the marking phase. On the other hand, if the GC is cancelled\n+  \/\/ after final mark (but before this check), then the final mark safepoint operation\n+  \/\/ will have finished the mark (setting concurrent mark in progress to false). Final mark\n+  \/\/ will also have setup state (in concurrent stack processing) that will not be safe to\n+  \/\/ resume from the marking phase in the degenerated cycle. That is, if the cancellation\n+  \/\/ occurred after final mark, we must resume the degenerated cycle after the marking phase.\n+  if (_generation->is_concurrent_mark_in_progress() && check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_mark)) {\n+    assert(!heap->is_concurrent_weak_root_in_progress(), \"Weak roots should not be in progress when concurrent mark is in progress\");\n+    return false;\n+  }\n+\n@@ -137,1 +165,2 @@\n-  \/\/ the space. This would be the last action if there is nothing to evacuate.\n+  \/\/ the space. This would be the last action if there is nothing to evacuate.  Note that\n+  \/\/ we will not age young-gen objects in the case that we skip evacuation.\n@@ -158,0 +187,6 @@\n+  \/\/ Global marking has completed. We need to fill in any unmarked objects in the old generation\n+  \/\/ so that subsequent remembered set scans will not walk pointers into reclaimed memory.\n+  if (!heap->cancelled_gc() && heap->mode()->is_generational() && _generation->is_global()) {\n+    entry_global_coalesce_and_fill();\n+  }\n+\n@@ -180,0 +215,1 @@\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n@@ -181,0 +217,1 @@\n+    _abbreviated = true;\n@@ -183,0 +220,51 @@\n+  \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n+  \/\/ abbreviated cycle.\n+  if (heap->mode()->is_generational()) {\n+    bool success;\n+    size_t region_xfer;\n+    const char* region_destination;\n+    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+    ShenandoahGeneration* old_gen = heap->old_generation();\n+    {\n+      ShenandoahHeapLocker locker(heap->lock());\n+\n+      size_t old_region_surplus = heap->get_old_region_surplus();\n+      size_t old_region_deficit = heap->get_old_region_deficit();\n+      if (old_region_surplus) {\n+        success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n+        region_destination = \"young\";\n+        region_xfer = old_region_surplus;\n+      } else if (old_region_deficit) {\n+        success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n+        region_destination = \"old\";\n+        region_xfer = old_region_deficit;\n+        if (!success) {\n+          ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n+        }\n+      } else {\n+        region_destination = \"none\";\n+        region_xfer = 0;\n+        success = true;\n+      }\n+      heap->set_old_region_surplus(0);\n+      heap->set_old_region_deficit(0);\n+\n+      size_t old_usage_before_evac = heap->capture_old_usage(0);\n+      size_t old_usage_now = old_gen->used();\n+      size_t promoted_bytes = old_usage_now - old_usage_before_evac;\n+      heap->set_previous_promotion(promoted_bytes);\n+      heap->set_young_evac_reserve(0);\n+      heap->set_old_evac_reserve(0);\n+      heap->reset_old_evac_expended();\n+      heap->set_promoted_reserve(0);\n+    }\n+\n+    \/\/ Report outside the heap lock\n+    size_t young_available = young_gen->available();\n+    size_t old_available = old_gen->available();\n+    log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                       SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                       success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n+                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  }\n@@ -305,0 +393,17 @@\n+void ShenandoahConcurrentGC::entry_scan_remembered_set() {\n+  if (_generation->is_young()) {\n+    ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+    TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+    const char* msg = \"Concurrent remembered set scanning\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::init_scan_rset);\n+    EventMark em(\"%s\", msg);\n+\n+    ShenandoahWorkerScope scope(heap->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_rs_scanning(),\n+                                msg);\n+\n+    heap->try_inject_alloc_failure();\n+    _generation->scan_remembered_set(true \/* is_concurrent *\/);\n+  }\n+}\n+\n@@ -478,0 +583,15 @@\n+void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  const char* msg = \"Coalescing and filling old regions in global collect\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  op_global_coalesce_and_fill();\n+}\n+\n@@ -483,2 +603,1 @@\n-\n-  heap->prepare_gc();\n+  _generation->prepare_gc();\n@@ -497,1 +616,2 @@\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n+      \/\/ reset, so it is very likely we don't need to do another write here.  Since most regions\n+      \/\/ are not \"active\", this path is relatively rare.\n@@ -519,2 +639,2 @@\n-  assert(heap->marking_context()->is_bitmap_clear(), \"need clear marking bitmap\");\n-  assert(!heap->marking_context()->is_complete(), \"should not be complete\");\n+  assert(_generation->is_bitmap_clear(), \"need clear marking bitmap\");\n+  assert(!_generation->is_mark_complete(), \"should not be complete\");\n@@ -523,0 +643,22 @@\n+\n+  if (heap->mode()->is_generational()) {\n+    if (_generation->is_young() || (_generation->is_global() && ShenandoahVerify)) {\n+      \/\/ The current implementation of swap_remembered_set() copies the write-card-table\n+      \/\/ to the read-card-table. The remembered sets are also swapped for GLOBAL collections\n+      \/\/ so that the verifier works with the correct copy of the card table when verifying.\n+      \/\/ TODO: This path should not really depend on ShenandoahVerify.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_swap_rset);\n+      _generation->swap_remembered_set();\n+    }\n+\n+    if (_generation->is_global()) {\n+      heap->cancel_old_gc();\n+    } else if (heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ Purge the SATB buffers, transferring any valid, old pointers to the\n+      \/\/ old generation mark queue. Any pointers in a young region will be\n+      \/\/ abandoned.\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_transfer_satb);\n+      heap->transfer_old_pointers_from_satb();\n+    }\n+  }\n+\n@@ -531,1 +673,1 @@\n-  heap->set_concurrent_mark_in_progress(true);\n+  _generation->set_concurrent_mark_in_progress(true);\n@@ -535,1 +677,6 @@\n-  {\n+  if (_do_old_gc_bootstrap) {\n+    \/\/ Update region state for both young and old regions\n+    \/\/ TODO: We should be able to pull this out of the safepoint for the bootstrap\n+    \/\/ cycle. The top of an old region will only move when a GC cycle evacuates\n+    \/\/ objects into it. When we start an old cycle, we know that nothing can touch\n+    \/\/ the top of old regions.\n@@ -539,0 +686,5 @@\n+  } else {\n+    \/\/ Update region state for only young regions\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_region_states);\n+    ShenandoahInitMarkUpdateRegionStateClosure cl;\n+    _generation->parallel_heap_region_iterate(&cl);\n@@ -542,1 +694,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n@@ -548,0 +700,1 @@\n+\n@@ -585,1 +738,26 @@\n-    heap->prepare_regions_and_collection_set(true \/*concurrent*\/);\n+    \/\/ The collection set is chosen by prepare_regions_and_collection_set().\n+    \/\/\n+    \/\/ TODO: Under severe memory overload conditions that can be checked here, we may want to limit\n+    \/\/ the inclusion of old-gen candidates within the collection set.  This would allow us to prioritize efforts on\n+    \/\/ evacuating young-gen,  This remediation is most appropriate when old-gen availability is very high (so there\n+    \/\/ are negligible negative impacts from delaying completion of old-gen evacuation) and when young-gen collections\n+    \/\/ are \"under duress\" (as signalled by very low availability of memory within young-gen, indicating that\/ young-gen\n+    \/\/ collections are not triggering frequently enough).\n+    _generation->prepare_regions_and_collection_set(true \/*concurrent*\/);\n+\n+    \/\/ Upon return from prepare_regions_and_collection_set(), certain parameters have been established to govern the\n+    \/\/ evacuation efforts that are about to begin.  In particular:\n+    \/\/\n+    \/\/ heap->get_promoted_reserve() represents the amount of memory within old-gen's available memory that has\n+    \/\/   been set aside to hold objects promoted from young-gen memory.  This represents an estimated percentage\n+    \/\/   of the live young-gen memory within the collection set.  If there is more data ready to be promoted than\n+    \/\/   can fit within this reserve, the promotion of some objects will be deferred until a subsequent evacuation\n+    \/\/   pass.\n+    \/\/\n+    \/\/ heap->get_old_evac_reserve() represents the amount of memory within old-gen's available memory that has been\n+    \/\/  set aside to hold objects evacuated from the old-gen collection set.\n+    \/\/\n+    \/\/ heap->get_young_evac_reserve() represents the amount of memory within young-gen's available memory that has\n+    \/\/  been set aside to hold objects evacuated from the young-gen collection set.  Conservatively, this value\n+    \/\/  equals the entire amount of live young-gen memory within the collection set, even though some of this memory\n+    \/\/  will likely be promoted.\n@@ -590,21 +768,45 @@\n-    if (!heap->collection_set()->is_empty()) {\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_before_evacuation();\n-      }\n-\n-      heap->set_evacuation_in_progress(true);\n-      \/\/ From here on, we need to update references.\n-      heap->set_has_forwarded_objects(true);\n-\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n-      \/\/ Arm nmethods\/stack for concurrent processing\n-      ShenandoahCodeRoots::arm_nmethods();\n-      ShenandoahStackWatermark::change_epoch_id();\n-\n-      if (ShenandoahPacing) {\n-        heap->pacer()->setup_for_evac();\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGeneration* young_gen = heap->young_generation();\n+      size_t humongous_regions_promoted = heap->get_promotable_humongous_regions();\n+      size_t regular_regions_promoted_in_place = heap->get_regular_regions_promoted_in_place();\n+      if (!heap->collection_set()->is_empty() || (humongous_regions_promoted + regular_regions_promoted_in_place > 0)) {\n+        \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n+        \/\/ Concurrent evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n+\n+        LogTarget(Debug, gc, cset) lt;\n+        if (lt.is_enabled()) {\n+          ResourceMark rm;\n+          LogStream ls(lt);\n+          heap->collection_set()->print_on(&ls);\n+        }\n+\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_before_evacuation();\n+        }\n+        \/\/ TODO: we do not need to run update-references following evacuation if collection_set->is_empty().\n+\n+        heap->set_evacuation_in_progress(true);\n+        \/\/ From here on, we need to update references.\n+        heap->set_has_forwarded_objects(true);\n+\n+        \/\/ Verify before arming for concurrent processing.\n+        \/\/ Otherwise, verification can trigger stack processing.\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_during_evacuation();\n+        }\n+\n+        \/\/ Arm nmethods\/stack for concurrent processing\n+        ShenandoahCodeRoots::arm_nmethods();\n+        ShenandoahStackWatermark::change_epoch_id();\n+\n+        if (ShenandoahPacing) {\n+          heap->pacer()->setup_for_evac();\n+        }\n+      } else {\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_after_concmark();\n+        }\n+\n+        if (VerifyAfterGC) {\n+          Universe::verify();\n+        }\n@@ -613,6 +815,38 @@\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_after_concmark();\n-      }\n-\n-      if (VerifyAfterGC) {\n-        Universe::verify();\n+      \/\/ Not is_generational()\n+      if (!heap->collection_set()->is_empty()) {\n+        LogTarget(Info, gc, ergo) lt;\n+        if (lt.is_enabled()) {\n+          ResourceMark rm;\n+          LogStream ls(lt);\n+          heap->collection_set()->print_on(&ls);\n+        }\n+\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_before_evacuation();\n+        }\n+\n+        heap->set_evacuation_in_progress(true);\n+        \/\/ From here on, we need to update references.\n+        heap->set_has_forwarded_objects(true);\n+\n+        \/\/ Verify before arming for concurrent processing.\n+        \/\/ Otherwise, verification can trigger stack processing.\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_during_evacuation();\n+        }\n+\n+        \/\/ Arm nmethods\/stack for concurrent processing\n+        ShenandoahCodeRoots::arm_nmethods();\n+        ShenandoahStackWatermark::change_epoch_id();\n+\n+        if (ShenandoahPacing) {\n+          heap->pacer()->setup_for_evac();\n+        }\n+      } else {\n+        if (ShenandoahVerify) {\n+          heap->verifier()->verify_after_concmark();\n+        }\n+\n+        if (VerifyAfterGC) {\n+          Universe::verify();\n+        }\n@@ -640,0 +874,1 @@\n+  ShenandoahThreadLocalData::enable_plab_promotions(thread);\n@@ -653,0 +888,3 @@\n+    Thread* worker_thread = Thread::current();\n+    ShenandoahThreadLocalData::enable_plab_promotions(worker_thread);\n+\n@@ -677,1 +915,1 @@\n-  heap->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n+  _generation->ref_processor()->process_references(ShenandoahPhaseTimings::conc_weak_refs, heap->workers(), true \/* concurrent *\/);\n@@ -704,2 +942,9 @@\n-      shenandoah_assert_correct(p, obj);\n-      ShenandoahHeap::atomic_clear_oop(p, obj);\n+      if (_heap->is_in_active_generation(obj)) {\n+        \/\/ TODO: This worries me. Here we are asserting that an unmarked from-space object is 'correct'.\n+        \/\/ Normally, I would call this a bogus assert, but there seems to be a legitimate use-case for\n+        \/\/ accessing from-space objects during class unloading. However, the from-space object may have\n+        \/\/ been \"filled\". We've made no effort to prevent old generation classes being unloaded by young\n+        \/\/ gen (and vice-versa).\n+        shenandoah_assert_correct(p, obj);\n+        ShenandoahHeap::atomic_clear_oop(p, obj);\n+      }\n@@ -931,1 +1176,3 @@\n-\n+  if (ShenandoahVerify) {\n+    heap->verifier()->verify_before_updaterefs();\n+  }\n@@ -976,1 +1223,1 @@\n-    heap->clear_cancelled_gc();\n+    heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n@@ -984,0 +1231,18 @@\n+  if (heap->mode()->is_generational() && heap->is_concurrent_old_mark_in_progress()) {\n+    \/\/ When the SATB barrier is left on to support concurrent old gen mark, it may pick up writes to\n+    \/\/ objects in the collection set. After those objects are evacuated, the pointers in the\n+    \/\/ SATB are no longer safe. Once we have finished update references, we are guaranteed that\n+    \/\/ no more writes to the collection set are possible.\n+    \/\/\n+    \/\/ This will transfer any old pointers in _active_ regions from the SATB to the old gen\n+    \/\/ mark queues. All other pointers will be discarded. This would also discard any pointers\n+    \/\/ in old regions that were included in a mixed evacuation. We aren't using the SATB filter\n+    \/\/ methods here because we cannot control when they execute. If the SATB filter runs _after_\n+    \/\/ a region has been recycled, we will not be able to detect the bad pointer.\n+    \/\/\n+    \/\/ We are not concerned about skipping this step in abbreviated cycles because regions\n+    \/\/ with no live objects cannot have been written to and so cannot have entries in the SATB\n+    \/\/ buffers.\n+    heap->transfer_old_pointers_from_satb();\n+  }\n+\n@@ -989,0 +1254,4 @@\n+  \/\/ Aging_cycle is only relevant during evacuation cycle for individual objects and during final mark for\n+  \/\/ entire regions.  Both of these relevant operations occur before final update refs.\n+  heap->set_aging_cycle(false);\n+\n@@ -1001,0 +1270,19 @@\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->is_aging_cycle()) {\n+    ShenandoahMarkingContext* ctx = heap->complete_marking_context();\n+\n+    for (size_t i = 0; i < heap->num_regions(); i++) {\n+      ShenandoahHeapRegion *r = heap->get_region(i);\n+      if (r->is_active() && r->is_young()) {\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        HeapWord* top = r->top();\n+        if (top > tams) {\n+          r->reset_age();\n+        } else {\n+          r->increment_age();\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1008,0 +1296,4 @@\n+void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n+  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n+}\n+\n@@ -1020,1 +1312,1 @@\n-    return \"Pause Init Mark (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Init Mark\", \" (unload classes)\");\n@@ -1022,1 +1314,1 @@\n-    return \"Pause Init Mark\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Init Mark\", \"\");\n@@ -1028,1 +1320,3 @@\n-  assert(!heap->has_forwarded_objects(), \"Should not have forwarded objects here\");\n+  assert(!heap->has_forwarded_objects() || heap->is_concurrent_old_mark_in_progress(),\n+         \"Should not have forwarded objects during final mark, unless old gen concurrent mark is running\");\n+\n@@ -1030,1 +1324,1 @@\n-    return \"Pause Final Mark (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Final Mark\", \" (unload classes)\");\n@@ -1032,1 +1326,1 @@\n-    return \"Pause Final Mark\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Final Mark\", \"\");\n@@ -1038,1 +1332,2 @@\n-  assert(!heap->has_forwarded_objects(), \"Should not have forwarded objects here\");\n+  assert(!heap->has_forwarded_objects() || heap->is_concurrent_old_mark_in_progress(),\n+         \"Should not have forwarded objects concurrent mark, unless old gen concurrent mark is running\");\n@@ -1040,1 +1335,1 @@\n-    return \"Concurrent marking (unload classes)\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Concurrent marking\", \" (unload classes)\");\n@@ -1042,1 +1337,1 @@\n-    return \"Concurrent marking\";\n+    SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Concurrent marking\", \"\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":353,"deletions":58,"binary":false,"changes":411,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,2 @@\n+class ShenandoahGeneration;\n+\n@@ -45,0 +48,3 @@\n+protected:\n+  ShenandoahConcurrentMark    _mark;\n+\n@@ -46,2 +52,6 @@\n-  ShenandoahConcurrentMark  _mark;\n-  ShenandoahDegenPoint      _degen_point;\n+  ShenandoahDegenPoint        _degen_point;\n+  bool                        _abbreviated;\n+  const bool                  _do_old_gc_bootstrap;\n+\n+protected:\n+  ShenandoahGeneration* const _generation;\n@@ -50,1 +60,1 @@\n-  ShenandoahConcurrentGC();\n+  ShenandoahConcurrentGC(ShenandoahGeneration* generation, bool do_old_gc_bootstrap);\n@@ -53,0 +63,1 @@\n+  bool abbreviated() const { return _abbreviated; }\n@@ -54,2 +65,0 @@\n-  \/\/ Cancel ongoing concurrent GC\n-  static void cancel();\n@@ -60,0 +69,2 @@\n+\n+protected:\n@@ -61,0 +72,3 @@\n+  void vmop_entry_final_roots();\n+\n+private:\n@@ -63,1 +77,0 @@\n-  void vmop_entry_final_roots();\n@@ -77,0 +90,3 @@\n+  void entry_scan_remembered_set();\n+\n+protected:\n@@ -84,0 +100,2 @@\n+\n+private:\n@@ -88,0 +106,1 @@\n+  void entry_global_coalesce_and_fill();\n@@ -94,1 +113,0 @@\n-  void op_final_mark();\n@@ -108,0 +126,3 @@\n+  void op_global_coalesce_and_fill();\n+protected:\n+  virtual void op_final_mark();\n@@ -109,0 +130,1 @@\n+private:\n@@ -117,0 +139,1 @@\n+protected:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -42,0 +44,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -47,0 +50,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -59,1 +63,2 @@\n-    ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahWorkerTimingsTracker timer(ShenandoahPhaseTimings::conc_mark, ShenandoahPhaseTimings::ParallelMark, worker_id, true);\n@@ -61,2 +66,1 @@\n-    ShenandoahObjToScanQueue* q = _cm->get_queue(worker_id);\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -65,1 +69,1 @@\n-    _cm->mark_loop(worker_id, _terminator, rp,\n+    _cm->mark_loop(GENERATION, worker_id, _terminator, rp,\n@@ -95,0 +99,1 @@\n+template<ShenandoahGenerationType GENERATION>\n@@ -110,1 +115,0 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n@@ -112,0 +116,1 @@\n+    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -116,0 +121,1 @@\n+      ShenandoahObjToScanQueue* old_q = _cm->get_old_queue(worker_id);\n@@ -117,1 +123,1 @@\n-      ShenandoahSATBBufferClosure cl(q);\n+      ShenandoahSATBBufferClosure<GENERATION> cl(q, old_q);\n@@ -122,1 +128,1 @@\n-      ShenandoahMarkRefsClosure             mark_cl(q, rp);\n+      ShenandoahMarkRefsClosure<GENERATION> mark_cl(q, rp, old_q);\n@@ -127,1 +133,1 @@\n-    _cm->mark_loop(worker_id, _terminator, rp,\n+    _cm->mark_loop(GENERATION, worker_id, _terminator, rp,\n@@ -135,2 +141,2 @@\n-ShenandoahConcurrentMark::ShenandoahConcurrentMark() :\n-  ShenandoahMark() {}\n+ShenandoahConcurrentMark::ShenandoahConcurrentMark(ShenandoahGeneration* generation) :\n+  ShenandoahMark(generation) {}\n@@ -139,0 +145,1 @@\n+template<ShenandoahGenerationType GENERATION>\n@@ -144,0 +151,1 @@\n+  ShenandoahObjToScanQueueSet* const  _old_queue_set;\n@@ -148,0 +156,1 @@\n+                                    ShenandoahObjToScanQueueSet* old,\n@@ -154,4 +163,6 @@\n-ShenandoahMarkConcurrentRootsTask::ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,\n-                                                                     ShenandoahReferenceProcessor* rp,\n-                                                                     ShenandoahPhaseTimings::Phase phase,\n-                                                                     uint nworkers) :\n+template<ShenandoahGenerationType GENERATION>\n+ShenandoahMarkConcurrentRootsTask<GENERATION>::ShenandoahMarkConcurrentRootsTask(ShenandoahObjToScanQueueSet* qs,\n+                                                                                 ShenandoahObjToScanQueueSet* old,\n+                                                                                 ShenandoahReferenceProcessor* rp,\n+                                                                                 ShenandoahPhaseTimings::Phase phase,\n+                                                                                 uint nworkers) :\n@@ -161,0 +172,1 @@\n+  _old_queue_set(old),\n@@ -165,1 +177,2 @@\n-void ShenandoahMarkConcurrentRootsTask::work(uint worker_id) {\n+template<ShenandoahGenerationType GENERATION>\n+void ShenandoahMarkConcurrentRootsTask<GENERATION>::work(uint worker_id) {\n@@ -168,1 +181,3 @@\n-  ShenandoahMarkRefsClosure cl(q, _rp);\n+  ShenandoahObjToScanQueue* old_q = (_old_queue_set == nullptr) ?\n+          nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahMarkRefsClosure<GENERATION> cl(q, _rp, old_q);\n@@ -176,2 +191,0 @@\n-  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n-\n@@ -179,5 +192,31 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n-  task_queues()->reserve(workers->active_workers());\n-  ShenandoahMarkConcurrentRootsTask task(task_queues(), rp, ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n-\n-  workers->run_task(&task);\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  _generation->reserve_task_queues(workers->active_workers());\n+  switch (_generation->type()) {\n+    case YOUNG: {\n+      ShenandoahMarkConcurrentRootsTask<YOUNG> task(task_queues(), old_task_queues(), rp,\n+                                                    ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_GEN: {\n+      assert(old_task_queues() == nullptr, \"Global mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL_GEN> task(task_queues(), nullptr, rp,\n+                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_NON_GEN: {\n+      assert(old_task_queues() == nullptr, \"Non-generational mark should not have old gen mark queues\");\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL_NON_GEN> task(task_queues(), nullptr, rp,\n+                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      workers->run_task(&task);\n+      break;\n+    }\n+    case OLD: {\n+      \/\/ We use a YOUNG generation cycle to bootstrap concurrent old marking.\n+      ShouldNotReachHere();\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -208,3 +247,28 @@\n-    TaskTerminator terminator(nworkers, task_queues());\n-    ShenandoahConcurrentMarkingTask task(this, &terminator);\n-    workers->run_task(&task);\n+    switch (_generation->type()) {\n+      case YOUNG: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<YOUNG> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case OLD: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<OLD> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case GLOBAL_GEN: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<GLOBAL_GEN> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      case GLOBAL_NON_GEN: {\n+        TaskTerminator terminator(nworkers, task_queues());\n+        ShenandoahConcurrentMarkingTask<GLOBAL_NON_GEN> task(this, &terminator);\n+        workers->run_task(&task);\n+        break;\n+      }\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -237,3 +301,2 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->set_concurrent_mark_in_progress(false);\n-  heap->mark_complete_marking_context();\n+  _generation->set_concurrent_mark_in_progress(false);\n+  _generation->set_mark_complete();\n@@ -259,2 +322,0 @@\n-  ShenandoahFinalMarkingTask task(this, &terminator, ShenandoahStringDedup::is_enabled());\n-  heap->workers()->run_task(&task);\n@@ -262,2 +323,24 @@\n-  assert(task_queues()->is_empty(), \"Should be empty\");\n-}\n+  switch (_generation->type()) {\n+    case YOUNG:{\n+      ShenandoahFinalMarkingTask<YOUNG> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case OLD:{\n+      ShenandoahFinalMarkingTask<OLD> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_GEN:{\n+      ShenandoahFinalMarkingTask<GLOBAL_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    case GLOBAL_NON_GEN:{\n+      ShenandoahFinalMarkingTask<GLOBAL_NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+      heap->workers()->run_task(&task);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -266,4 +349,1 @@\n-void ShenandoahConcurrentMark::cancel() {\n-  clear();\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n-  rp->abandon_partial_discovery();\n+  assert(task_queues()->is_empty(), \"Should be empty\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":117,"deletions":37,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -31,0 +32,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -32,0 +34,1 @@\n+class ShenandoahGeneration;\n@@ -34,2 +37,2 @@\n-  friend class ShenandoahConcurrentMarkingTask;\n-  friend class ShenandoahFinalMarkingTask;\n+  template <ShenandoahGenerationType GENERATION> friend class ShenandoahConcurrentMarkingTask;\n+  template <ShenandoahGenerationType GENERATION> friend class ShenandoahFinalMarkingTask;\n@@ -38,1 +41,2 @@\n-  ShenandoahConcurrentMark();\n+  ShenandoahConcurrentMark(ShenandoahGeneration* generation);\n+\n@@ -41,0 +45,1 @@\n+\n@@ -43,0 +48,1 @@\n+\n@@ -46,2 +52,0 @@\n-  static void cancel();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -33,0 +35,4 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -38,0 +44,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n@@ -43,0 +50,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -51,2 +59,4 @@\n-  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint - 2, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint - 2, \"ShenandoahRequestedGC_lock\", true),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahControlGC_lock\", true),\n+  _regulator_lock(Mutex::nosafepoint - 2, \"ShenandoahRegulatorGC_lock\", true),\n@@ -55,0 +65,1 @@\n+  _requested_generation(select_global_generation()),\n@@ -56,1 +67,3 @@\n-  _allocs_seen(0) {\n+  _degen_generation(nullptr),\n+  _allocs_seen(0),\n+  _mode(none) {\n@@ -84,0 +97,1 @@\n+  ShenandoahGenerationType generation = select_global_generation();\n@@ -85,1 +99,0 @@\n-  int sleep = ShenandoahControlIntervalMin;\n@@ -88,1 +101,1 @@\n-  double last_sleep_adjust_time = os::elapsedTime();\n+  uint age_period = 0;\n@@ -97,1 +110,7 @@\n-  ShenandoahHeuristics* heuristics = heap->heuristics();\n+\n+  \/\/ Heuristics are notified of allocation failures here and other outcomes\n+  \/\/ of the cycle. They're also used here to control whether the Nth consecutive\n+  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n+  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n+  ShenandoahHeuristics* global_heuristics = heap->global_generation()->heuristics();\n+  bool old_bootstrap_requested = false;\n@@ -104,1 +123,1 @@\n-    bool implicit_gc_requested = is_gc_requested && !is_explicit_gc(requested_gc_cause);\n+    bool implicit_gc_requested = is_gc_requested && is_implicit_gc(requested_gc_cause);\n@@ -113,1 +132,1 @@\n-    GCMode mode = none;\n+    set_gc_mode(none);\n@@ -127,1 +146,13 @@\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle()) {\n+      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n+        _degen_generation = heap->mode()->is_generational() ?\n+                heap->young_generation() : heap->global_generation();\n+      } else {\n+        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n+      }\n+\n+      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n+      generation = _degen_generation->type();\n+      bool old_gen_evacuation_failed = heap->clear_old_evacuation_failure();\n+\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() && !old_gen_evacuation_failed) {\n@@ -130,1 +161,1 @@\n-        mode = stw_degenerated;\n+        set_gc_mode(stw_degenerated);\n@@ -134,1 +165,2 @@\n-        mode = stw_full;\n+        generation = select_global_generation();\n+        set_gc_mode(stw_full);\n@@ -136,1 +168,0 @@\n-\n@@ -139,0 +170,1 @@\n+      generation = select_global_generation();\n@@ -141,1 +173,1 @@\n-      heuristics->record_requested_gc();\n+      global_heuristics->record_requested_gc();\n@@ -145,1 +177,1 @@\n-        mode = default_mode;\n+        set_gc_mode(default_mode);\n@@ -147,1 +179,1 @@\n-        heap->set_unload_classes(heuristics->can_unload_classes());\n+        heap->set_unload_classes(global_heuristics->can_unload_classes());\n@@ -150,1 +182,1 @@\n-        mode = stw_full;\n+        set_gc_mode(stw_full);\n@@ -154,0 +186,1 @@\n+      generation = select_global_generation();\n@@ -156,1 +189,1 @@\n-      heuristics->record_requested_gc();\n+      global_heuristics->record_requested_gc();\n@@ -160,1 +193,1 @@\n-        mode = default_mode;\n+        set_gc_mode(default_mode);\n@@ -163,1 +196,1 @@\n-        heap->set_unload_classes(heuristics->can_unload_classes());\n+        heap->set_unload_classes(global_heuristics->can_unload_classes());\n@@ -166,1 +199,1 @@\n-        mode = stw_full;\n+        set_gc_mode(stw_full);\n@@ -169,5 +202,30 @@\n-      \/\/ Potential normal cycle: ask heuristics if it wants to act\n-      if (heuristics->should_start_gc()) {\n-        mode = default_mode;\n-        cause = default_cause;\n-      }\n+      \/\/ We should only be here if the regulator requested a cycle or if\n+      \/\/ there is an old generation mark in progress.\n+      if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+        if (_requested_generation == OLD && heap->doing_mixed_evacuations()) {\n+          \/\/ If a request to start an old cycle arrived while an old cycle was running, but _before_\n+          \/\/ it chose any regions for evacuation we don't want to start a new old cycle. Rather, we want\n+          \/\/ the heuristic to run a young collection so that we can evacuate some old regions.\n+          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n+          generation = YOUNG;\n+        } else if (_requested_generation == OLD && !old_bootstrap_requested) {\n+          \/\/ Arrange to perform a young GC immediately followed by a bootstrap OLD GC.  OLD GC typically requires more\n+          \/\/ than twice the time required for YOUNG GC, so we run a YOUNG GC to replenish the YOUNG allocation pool before\n+          \/\/ we start the longer OLD GC effort.\n+          old_bootstrap_requested = true;\n+          generation = YOUNG;\n+        } else {\n+          \/\/ if (old_bootstrap_requested && (_requested_generation == OLD)), this starts the bootstrap GC that\n+          \/\/  immediately follows the preparatory young GC.\n+          \/\/ But we will abandon the planned bootstrap GC if a GLOBAL GC has been now been requested.\n+          generation = _requested_generation;\n+          old_bootstrap_requested = false;\n+        }\n+        \/\/ preemption was requested or this is a regular cycle\n+        cause = GCCause::_shenandoah_concurrent_gc;\n+        set_gc_mode(default_mode);\n+\n+        \/\/ Don't start a new old marking if there is one already in progress\n+        if (generation == OLD && heap->is_concurrent_old_mark_in_progress()) {\n+          set_gc_mode(servicing_old);\n+        }\n@@ -175,2 +233,22 @@\n-      \/\/ Ask policy if this cycle wants to process references or unload classes\n-      heap->set_unload_classes(heuristics->should_unload_classes());\n+        if (generation == select_global_generation()) {\n+          heap->set_unload_classes(global_heuristics->should_unload_classes());\n+        } else {\n+          heap->set_unload_classes(false);\n+        }\n+\n+        \/\/ Don't want to spin in this loop and start a cycle every time, so\n+        \/\/ clear requested gc cause. This creates a race with callers of the\n+        \/\/ blocking 'request_gc' method, but there it loops and resets the\n+        \/\/ '_requested_gc_cause' until a full cycle is completed.\n+        _requested_gc_cause = GCCause::_no_gc;\n+      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_prepare_for_old_mark_in_progress()) {\n+        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n+        \/\/ mixed evacuation in progress, so resume working on that.\n+        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n+                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n+                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n+\n+        cause = GCCause::_shenandoah_concurrent_gc;\n+        generation = OLD;\n+        set_gc_mode(servicing_old);\n+      }\n@@ -180,2 +258,2 @@\n-    \/\/ either implicit or explicit GC request,  or we are requested to do so unconditionally.\n-    if (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs) {\n+    \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n+    if (generation == select_global_generation() && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n@@ -185,1 +263,1 @@\n-    bool gc_requested = (mode != none);\n+    bool gc_requested = (_mode != none);\n@@ -205,4 +283,16 @@\n-\n-      switch (mode) {\n-        case concurrent_normal:\n-          service_concurrent_normal_cycle(cause);\n+      \/\/ In case this is a degenerated cycle, remember whether original cycle was aging.\n+      bool was_aging_cycle = heap->is_aging_cycle();\n+      heap->set_aging_cycle(false);\n+\n+      switch (_mode) {\n+        case concurrent_normal: {\n+          \/\/ At this point:\n+          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n+          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n+          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n+          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n+          if (age_period-- == 0) {\n+             heap->set_aging_cycle(true);\n+             age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n+          service_concurrent_normal_cycle(heap, generation, cause);\n@@ -210,2 +300,7 @@\n-        case stw_degenerated:\n-          service_stw_degenerated_cycle(cause, degen_point);\n+        }\n+        case stw_degenerated: {\n+          heap->set_aging_cycle(was_aging_cycle);\n+          if (!service_stw_degenerated_cycle(cause, degen_point)) {\n+            \/\/ The degenerated GC was upgraded to a Full GC\n+            generation = select_global_generation();\n+          }\n@@ -213,1 +308,6 @@\n-        case stw_full:\n+        }\n+        case stw_full: {\n+          if (age_period-- == 0) {\n+            heap->set_aging_cycle(true);\n+            age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n@@ -216,0 +316,7 @@\n+        }\n+        case servicing_old: {\n+          assert(generation == OLD, \"Expected old generation here\");\n+          GCIdMark gc_id_mark;\n+          service_concurrent_old_cycle(heap, cause);\n+          break;\n+        }\n@@ -255,7 +362,2 @@\n-        heuristics->clear_metaspace_oom();\n-      }\n-\n-      \/\/ Commit worker statistics to cycle data\n-      heap->phase_timings()->flush_par_workers_to_cycle();\n-      if (ShenandoahPacing) {\n-        heap->pacer()->flush_stats_to_cycle();\n+        assert(generation == select_global_generation(), \"Only unload classes during GLOBAL cycle\");\n+        global_heuristics->clear_metaspace_oom();\n@@ -264,15 +366,1 @@\n-      \/\/ Print GC stats for current cycle\n-      {\n-        LogTarget(Info, gc, stats) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          LogStream ls(lt);\n-          heap->phase_timings()->print_cycle_on(&ls);\n-          if (ShenandoahPacing) {\n-            heap->pacer()->print_cycle_on(&ls);\n-          }\n-        }\n-      }\n-\n-      \/\/ Commit statistics to globals\n-      heap->phase_timings()->flush_cycle_to_global();\n+      process_phase_timings(heap);\n@@ -314,8 +402,14 @@\n-    \/\/ Wait before performing the next action. If allocation happened during this wait,\n-    \/\/ we exit sooner, to let heuristics re-evaluate new conditions. If we are at idle,\n-    \/\/ back off exponentially.\n-    if (_heap_changed.try_unset()) {\n-      sleep = ShenandoahControlIntervalMin;\n-    } else if ((current - last_sleep_adjust_time) * 1000 > ShenandoahControlIntervalAdjustPeriod){\n-      sleep = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, sleep * 2));\n-      last_sleep_adjust_time = current;\n+    \/\/ Don't wait around if there was an allocation failure - start the next cycle immediately.\n+    if (!is_alloc_failure_gc()) {\n+      if (old_bootstrap_requested) {\n+        _requested_generation = OLD;\n+        _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+      } else {\n+        \/\/ The timed wait is necessary because this thread has a responsibility to send\n+        \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n+        MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n+        lock.wait(ShenandoahControlIntervalMax);\n+      }\n+    } else {\n+      \/\/ in case of alloc_failure, abandon any plans to do immediate OLD Bootstrap\n+      old_bootstrap_requested = false;\n@@ -323,1 +417,0 @@\n-    os::naked_short_sleep(sleep);\n@@ -332,0 +425,224 @@\n+void ShenandoahControlThread::process_phase_timings(const ShenandoahHeap* heap) {\n+  \/\/ Commit worker statistics to cycle data\n+  heap->phase_timings()->flush_par_workers_to_cycle();\n+  if (ShenandoahPacing) {\n+    heap->pacer()->flush_stats_to_cycle();\n+  }\n+\n+  ShenandoahCycleStats evac_stats = heap->evac_tracker()->flush_cycle_to_global();\n+\n+  \/\/ Print GC stats for current cycle\n+  {\n+    LogTarget(Info, gc, stats) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      heap->phase_timings()->print_cycle_on(&ls);\n+      ShenandoahEvacuationTracker::print_evacuations_on(&ls, &evac_stats.workers,\n+                                                        &evac_stats.mutators);\n+      if (ShenandoahPacing) {\n+        heap->pacer()->print_cycle_on(&ls);\n+      }\n+    }\n+  }\n+\n+  \/\/ Commit statistics to globals\n+  heap->phase_timings()->flush_cycle_to_global();\n+}\n+\n+\/\/ Young and old concurrent cycles are initiated by the regulator. Implicit\n+\/\/ and explicit GC requests are handled by the controller thread and always\n+\/\/ run a global cycle (which is concurrent by default, but may be overridden\n+\/\/ by command line options). Old cycles always degenerate to a global cycle.\n+\/\/ Young cycles are degenerated to complete the young cycle.  Young\n+\/\/ and old degen may upgrade to Full GC.  Full GC may also be\n+\/\/ triggered directly by a System.gc() invocation.\n+\/\/\n+\/\/\n+\/\/      +-----+ Idle +-----+-----------+---------------------+\n+\/\/      |         +        |           |                     |\n+\/\/      |         |        |           |                     |\n+\/\/      |         |        v           |                     |\n+\/\/      |         |  Bootstrap Old +-- | ------------+       |\n+\/\/      |         |   +                |             |       |\n+\/\/      |         |   |                |             |       |\n+\/\/      |         v   v                v             v       |\n+\/\/      |    Resume Old <----------+ Young +--> Young Degen  |\n+\/\/      |     +  +   ^                            +  +       |\n+\/\/      v     |  |   |                            |  |       |\n+\/\/   Global <-+  |   +----------------------------+  |       |\n+\/\/      +        |                                   |       |\n+\/\/      |        v                                   v       |\n+\/\/      +--->  Global Degen +--------------------> Full <----+\n+\/\/\n+void ShenandoahControlThread::service_concurrent_normal_cycle(ShenandoahHeap* heap,\n+                                                              const ShenandoahGenerationType generation,\n+                                                              GCCause::Cause cause) {\n+  GCIdMark gc_id_mark;\n+  ShenandoahGeneration* the_generation = nullptr;\n+  switch (generation) {\n+    case YOUNG: {\n+      \/\/ Run a young cycle. This might or might not, have interrupted an ongoing\n+      \/\/ concurrent mark in the old generation. We need to think about promotions\n+      \/\/ in this case. Promoted objects should be above the TAMS in the old regions\n+      \/\/ they end up in, but we have to be sure we don't promote into any regions\n+      \/\/ that are in the cset.\n+      log_info(gc, ergo)(\"Start GC cycle (YOUNG)\");\n+      the_generation = heap->young_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n+      break;\n+    }\n+    case OLD: {\n+      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n+      the_generation = heap->old_generation();\n+      service_concurrent_old_cycle(heap, cause);\n+      break;\n+    }\n+    case GLOBAL_GEN: {\n+      log_info(gc, ergo)(\"Start GC cycle (GLOBAL)\");\n+      the_generation = heap->global_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n+      break;\n+    }\n+    case GLOBAL_NON_GEN: {\n+      log_info(gc, ergo)(\"Start GC cycle\");\n+      the_generation = heap->global_generation();\n+      service_concurrent_cycle(the_generation, cause, false);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ShenandoahControlThread::service_concurrent_old_cycle(ShenandoahHeap* heap, GCCause::Cause &cause) {\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  ShenandoahOldGeneration::State original_state = old_generation->state();\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  switch (original_state) {\n+    case ShenandoahOldGeneration::WAITING_FOR_FILL:\n+    case ShenandoahOldGeneration::IDLE: {\n+      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress\");\n+      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty\");\n+    }\n+    case ShenandoahOldGeneration::FILLING: {\n+      _allow_old_preemption.set();\n+      ShenandoahGCSession session(cause, old_generation);\n+      old_generation->prepare_gc();\n+      _allow_old_preemption.unset();\n+\n+      if (heap->is_prepare_for_old_mark_in_progress()) {\n+        \/\/ Coalescing threads detected the cancellation request and aborted. Stay\n+        \/\/ in this state so control thread may resume the coalescing work.\n+        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress\");\n+        return;\n+      }\n+\n+      \/\/ It is possible for a young generation request to preempt this nascent old\n+      \/\/ collection cycle _after_ we've finished making the old regions parseable (filling),\n+      \/\/ but _before_ we have unset the preemption flag. It is also possible for an\n+      \/\/ allocation failure to occur after the threads have finished filling. We must\n+      \/\/ check if we have been cancelled before we start a bootstrap cycle.\n+      if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n+        if (heap->cancelled_gc()) {\n+          \/\/ If this was a preemption request, the cancellation would have been cleared\n+          \/\/ so that we run a concurrent young cycle. If the cancellation is still set,\n+          \/\/ then this is an allocation failure and we need to run a degenerated cycle.\n+          \/\/ If this is a preemption request, we're just going to fall through and run\n+          \/\/ the bootstrap cycle to start the old generation cycle (the bootstrap cycle is\n+          \/\/ a concurrent young cycle - which is what we're being asked to do in that case).\n+          \/\/ If the cycle is cancelled for any other reason, we return from here and let\n+          \/\/ the control thread return to the top of its decision loop.\n+          log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n+          return;\n+        }\n+      }\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n+    }\n+    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n+      \/\/ Configure the young generation's concurrent mark to put objects in\n+      \/\/ old regions into the concurrent mark queues associated with the old\n+      \/\/ generation. The young cycle will run as normal except that rather than\n+      \/\/ ignore old references it will mark and enqueue them in the old concurrent\n+      \/\/ task queues but it will not traverse them.\n+      set_gc_mode(bootstrapping_old);\n+      young_generation->set_old_gen_task_queues(old_generation->task_queues());\n+      ShenandoahGCSession session(cause, young_generation);\n+      service_concurrent_cycle(heap, young_generation, cause, true);\n+      process_phase_timings(heap);\n+      if (heap->cancelled_gc()) {\n+        \/\/ Young generation bootstrap cycle has failed. Concurrent mark for old generation\n+        \/\/ is going to resume after degenerated bootstrap cycle completes.\n+        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n+        return;\n+      }\n+\n+      \/\/ Reset the degenerated point. Normally this would happen at the top\n+      \/\/ of the control loop, but here we have just completed a young cycle\n+      \/\/ which has bootstrapped the old concurrent marking.\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+      \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n+      \/\/ and init mark for the concurrent mark. All of that work will have been\n+      \/\/ done by the bootstrapping young cycle.\n+      set_gc_mode(servicing_old);\n+      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+    case ShenandoahOldGeneration::MARKING: {\n+      ShenandoahGCSession session(cause, old_generation);\n+      bool marking_complete = resume_concurrent_old_cycle(old_generation, cause);\n+      if (marking_complete) {\n+        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n+        if (original_state == ShenandoahOldGeneration::MARKING) {\n+          heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), true,\n+                                                            heap->collection_set()->has_old_regions());\n+          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n+        }\n+      } else if (original_state == ShenandoahOldGeneration::MARKING) {\n+        heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), false,\n+                                                          heap->collection_set()->has_old_regions());\n+        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n+  }\n+}\n+\n+bool ShenandoahControlThread::resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause) {\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n+  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ We can only tolerate being cancelled during concurrent marking or during preparation for mixed\n+  \/\/ evacuation. This flag here (passed by reference) is used to control precisely where the regulator\n+  \/\/ is allowed to cancel a GC.\n+  ShenandoahOldGC gc(generation, _allow_old_preemption);\n+  if (gc.collect(cause)) {\n+    generation->record_success_concurrent(false);\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    \/\/ It's possible the gc cycle was cancelled after the last time\n+    \/\/ the collection checked for cancellation. In which case, the\n+    \/\/ old gc cycle is still completed, and we have to deal with this\n+    \/\/ cancellation. We set the degeneration point to be outside\n+    \/\/ the cycle because if this is an allocation failure, that is\n+    \/\/ what must be done (there is no degenerated old cycle). If the\n+    \/\/ cancellation was due to a heuristic wanting to start a young\n+    \/\/ cycle, then we are not actually going to a degenerated cycle,\n+    \/\/ so the degenerated point doesn't matter here.\n+    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n+    if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+      heap->shenandoah_policy()->record_interrupted_old();\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -351,1 +668,1 @@\n-void ShenandoahControlThread::service_concurrent_normal_cycle(GCCause::Cause cause) {\n+void ShenandoahControlThread::service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool do_old_gc_bootstrap) {\n@@ -387,1 +704,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -390,3 +706,2 @@\n-  GCIdMark gc_id_mark;\n-  ShenandoahGCSession session(cause);\n-\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGCSession session(cause, generation);\n@@ -395,1 +710,8 @@\n-  ShenandoahConcurrentGC gc;\n+  service_concurrent_cycle(heap, generation, cause, do_old_gc_bootstrap);\n+}\n+\n+void ShenandoahControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n+                                                       ShenandoahGeneration* generation,\n+                                                       GCCause::Cause& cause,\n+                                                       bool do_old_gc_bootstrap) {\n+  ShenandoahConcurrentGC gc(generation, do_old_gc_bootstrap);\n@@ -398,2 +720,1 @@\n-    heap->heuristics()->record_success_concurrent();\n-    heap->shenandoah_policy()->record_success_concurrent();\n+    generation->record_success_concurrent(gc.abbreviated());\n@@ -403,0 +724,4 @@\n+    assert(!generation->is_old(), \"Old GC takes a different control path\");\n+    \/\/ Concurrent young-gen collection degenerates to young\n+    \/\/ collection.  Same for global collections.\n+    _degen_generation = generation;\n@@ -404,0 +729,26 @@\n+  const char* msg;\n+  if (heap->mode()->is_generational()) {\n+    if (heap->cancelled_gc()) {\n+      msg = (generation->is_young()) ? \"At end of Interrupted Concurrent Young GC\" :\n+                                       \"At end of Interrupted Concurrent Bootstrap GC\";\n+    } else {\n+      msg = (generation->is_young()) ? \"At end of Concurrent Young GC\" :\n+                                       \"At end of Concurrent Bootstrap GC\";\n+      \/\/ We only record GC results if GC was successful\n+      ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+      if (generation->is_young()) {\n+        if (heap->collection_set()->has_old_regions()) {\n+          bool mixed_is_done = (heap->old_heuristics()->unprocessed_old_collection_candidates() == 0);\n+          mmu_tracker->record_mixed(generation, get_gc_id(), mixed_is_done);\n+        } else {\n+          mmu_tracker->record_young(generation, get_gc_id());\n+        }\n+      } else {\n+        mmu_tracker->record_bootstrap(generation, get_gc_id(), heap->collection_set()->has_old_regions());\n+      }\n+    }\n+  } else {\n+    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n+                                 \"At end of GC\";\n+  }\n+  heap->log_heap_status(msg);\n@@ -408,7 +759,5 @@\n-  if (heap->cancelled_gc()) {\n-    assert (is_alloc_failure_gc() || in_graceful_shutdown(), \"Cancel GC either for alloc failure GC, or gracefully exiting\");\n-    if (!in_graceful_shutdown()) {\n-      assert (_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n-              \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n-      _degen_point = point;\n-    }\n+  if (!heap->cancelled_gc()) {\n+    return false;\n+  }\n+\n+  if (in_graceful_shutdown()) {\n@@ -417,0 +766,24 @@\n+\n+  assert(_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n+         \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n+\n+  if (is_alloc_failure_gc()) {\n+    _degen_point = point;\n+    return true;\n+  }\n+\n+  if (_preemption_requested.is_set()) {\n+    assert(_requested_generation == YOUNG, \"Only young GCs may preempt old.\");\n+    _preemption_requested.unset();\n+\n+    \/\/ Old generation marking is only cancellable during concurrent marking.\n+    \/\/ Once final mark is complete, the code does not check again for cancellation.\n+    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n+    \/\/ make it to this case. The calling code is responsible for forcing a\n+    \/\/ cancellation due to allocation failure into a degenerated cycle.\n+    _degen_point = point;\n+    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n+    return true;\n+  }\n+\n+  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n@@ -425,0 +798,2 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n@@ -426,1 +801,1 @@\n-  ShenandoahGCSession session(cause);\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -431,2 +806,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->heuristics()->record_success_full();\n+  heap->global_generation()->heuristics()->record_success_full();\n@@ -436,2 +810,4 @@\n-void ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point) {\n-  assert (point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+bool ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n+                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -440,1 +816,1 @@\n-  ShenandoahGCSession session(cause);\n+  ShenandoahGCSession session(cause, _degen_generation);\n@@ -442,1 +818,1 @@\n-  ShenandoahDegenGC gc(point);\n+  ShenandoahDegenGC gc(point, _degen_generation);\n@@ -445,2 +821,13 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->heuristics()->record_success_degenerated();\n+  assert(heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n+  if (_degen_generation->is_global()) {\n+    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n+    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  } else {\n+    assert(_degen_generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING && !gc.upgraded_to_full()) {\n+      old->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+  }\n+\n+  _degen_generation->heuristics()->record_success_degenerated();\n@@ -448,0 +835,1 @@\n+  return !gc.upgraded_to_full();\n@@ -478,0 +866,5 @@\n+bool ShenandoahControlThread::is_implicit_gc(GCCause::Cause cause) const {\n+  return !is_explicit_gc(cause) &&\n+          (cause != GCCause::_shenandoah_concurrent_gc);\n+}\n+\n@@ -500,0 +893,40 @@\n+bool ShenandoahControlThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n+  if (_preemption_requested.is_set() || _gc_requested.is_set() || ShenandoahHeap::heap()->cancelled_gc()) {\n+    \/\/ Ignore subsequent requests from the heuristics\n+    return false;\n+  }\n+\n+  if (_mode == none) {\n+    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+    _requested_generation = generation;\n+    notify_control_thread();\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    ml.wait();\n+    return true;\n+  }\n+\n+  if (preempt_old_marking(generation)) {\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n+    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+    _requested_generation = generation;\n+    _preemption_requested.set();\n+    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n+    notify_control_thread();\n+\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    ml.wait();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void ShenandoahControlThread::notify_control_thread() {\n+  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _control_lock.notify();\n+}\n+\n+bool ShenandoahControlThread::preempt_old_marking(ShenandoahGenerationType generation) {\n+  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n+}\n+\n@@ -519,1 +952,1 @@\n-\n+    notify_control_thread();\n@@ -537,1 +970,0 @@\n-\n@@ -603,4 +1035,0 @@\n-  \/\/ Notify that something had changed.\n-  if (_heap_changed.is_unset()) {\n-    _heap_changed.set();\n-  }\n@@ -641,0 +1069,29 @@\n+\n+const char* ShenandoahControlThread::gc_mode_name(ShenandoahControlThread::GCMode mode) {\n+  switch (mode) {\n+    case none:              return \"idle\";\n+    case concurrent_normal: return \"normal\";\n+    case stw_degenerated:   return \"degenerated\";\n+    case stw_full:          return \"full\";\n+    case servicing_old:     return \"old\";\n+    case bootstrapping_old: return \"bootstrap\";\n+    default:                return \"unknown\";\n+  }\n+}\n+\n+void ShenandoahControlThread::set_gc_mode(ShenandoahControlThread::GCMode new_mode) {\n+  if (_mode != new_mode) {\n+    log_info(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n+    _mode = new_mode;\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+}\n+\n+ShenandoahGenerationType ShenandoahControlThread::select_global_generation() {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    return GLOBAL_GEN;\n+  } else {\n+    return GLOBAL_NON_GEN;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":555,"deletions":98,"binary":false,"changes":653,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -60,7 +61,0 @@\n-  typedef enum {\n-    none,\n-    concurrent_normal,\n-    stw_degenerated,\n-    stw_full\n-  } GCMode;\n-\n@@ -69,1 +63,1 @@\n-  \/\/ to make complete explicit cycle for for demanding customers.\n+  \/\/ to make complete explicit cycle for demanding customers.\n@@ -72,0 +66,2 @@\n+  Monitor _control_lock;\n+  Monitor _regulator_lock;\n@@ -76,0 +72,9 @@\n+  typedef enum {\n+    none,\n+    concurrent_normal,\n+    stw_degenerated,\n+    stw_full,\n+    bootstrapping_old,\n+    servicing_old\n+  } GCMode;\n+\n@@ -79,0 +84,2 @@\n+  size_t get_gc_id();\n+\n@@ -80,0 +87,2 @@\n+  ShenandoahSharedFlag _allow_old_preemption;\n+  ShenandoahSharedFlag _preemption_requested;\n@@ -82,0 +91,1 @@\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n@@ -83,1 +93,0 @@\n-  ShenandoahSharedFlag _heap_changed;\n@@ -87,0 +96,1 @@\n+  ShenandoahGenerationType _requested_generation;\n@@ -88,0 +98,1 @@\n+  ShenandoahGeneration* _degen_generation;\n@@ -94,0 +105,2 @@\n+  volatile GCMode _mode;\n+  shenandoah_padding(3);\n@@ -95,0 +108,1 @@\n+  \/\/ Returns true if the cycle has been cancelled or degenerated.\n@@ -96,1 +110,4 @@\n-  void service_concurrent_normal_cycle(GCCause::Cause cause);\n+\n+  \/\/ Returns true if the old generation marking completed (i.e., final mark executed for old generation).\n+  bool resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause);\n+  void service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool reset_old_bitmap_specially);\n@@ -98,1 +115,4 @@\n-  void service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point);\n+\n+  \/\/ Return true if degenerated cycle finishes normally.  Return false if the degenerated cycle transformed itself\n+  \/\/ into a full GC.\n+  bool service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point);\n@@ -101,0 +121,1 @@\n+  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n@@ -102,0 +123,1 @@\n+  \/\/ Notify threads waiting for GC to complete.\n@@ -103,0 +125,1 @@\n+  \/\/ True if allocation failure flag has been set.\n@@ -107,1 +130,0 @@\n-  size_t get_gc_id();\n@@ -116,0 +138,1 @@\n+  bool is_implicit_gc(GCCause::Cause cause) const;\n@@ -117,0 +140,4 @@\n+  \/\/ Returns true if the old generation marking was interrupted to allow a young cycle.\n+  bool preempt_old_marking(ShenandoahGenerationType generation);\n+\n+  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n@@ -119,0 +146,2 @@\n+  void process_phase_timings(const ShenandoahHeap* heap);\n+\n@@ -133,0 +162,2 @@\n+  \/\/ Return true if the request to start a concurrent GC for the given generation succeeded.\n+  bool request_concurrent_gc(ShenandoahGenerationType generation);\n@@ -145,0 +176,24 @@\n+\n+  void service_concurrent_normal_cycle(ShenandoahHeap* heap,\n+                                       const ShenandoahGenerationType generation,\n+                                       GCCause::Cause cause);\n+\n+  void service_concurrent_old_cycle(ShenandoahHeap* heap,\n+                                    GCCause::Cause &cause);\n+\n+  void set_gc_mode(GCMode new_mode);\n+  GCMode gc_mode() {\n+    return _mode;\n+  }\n+\n+  static ShenandoahGenerationType select_global_generation();\n+\n+ private:\n+  static const char* gc_mode_name(GCMode mode);\n+  void notify_control_thread();\n+\n+  void service_concurrent_cycle(ShenandoahHeap* heap,\n+                                ShenandoahGeneration* generation,\n+                                GCCause::Cause &cause,\n+                                bool do_old_gc_bootstrap);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":67,"deletions":12,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -40,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -45,1 +49,1 @@\n-ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point) :\n+ShenandoahDegenGC::ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation) :\n@@ -47,1 +51,3 @@\n-  _degen_point(degen_point) {\n+  _degen_point(degen_point),\n+  _generation(generation),\n+  _upgraded_to_full(false) {\n@@ -52,0 +58,8 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational()) {\n+    bool is_bootstrap_gc = heap->is_concurrent_old_mark_in_progress() && _generation->is_young();\n+    heap->mmu_tracker()->record_degenerated(_generation, GCId::current(), is_bootstrap_gc,\n+                                            !heap->collection_set()->has_old_regions());\n+    const char* msg = is_bootstrap_gc? \"At end of Degenerated Boostrap Old GC\": \"At end of Degenerated GC\";\n+    heap->log_heap_status(msg);\n+  }\n@@ -67,1 +81,0 @@\n-\n@@ -82,1 +95,17 @@\n-  heap->clear_cancelled_gc();\n+  heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n+\n+#ifdef ASSERT\n+  if (heap->mode()->is_generational()) {\n+    if (_generation->is_global()) {\n+      \/\/ We can only get to a degenerated global cycle _after_ a concurrent global cycle\n+      \/\/ has been cancelled. In which case, we expect the concurrent global cycle to have\n+      \/\/ cancelled the old gc already.\n+      assert(!heap->is_old_gc_active(), \"Old GC should not be active during global cycle\");\n+    }\n+\n+    if (!heap->is_concurrent_old_mark_in_progress()) {\n+      \/\/ If we are not marking the old generation, there should be nothing in the old mark queues\n+      assert(heap->old_generation()->task_queues()->is_empty(), \"Old gen task queues should be empty\");\n+    }\n+  }\n+#endif\n@@ -98,1 +127,0 @@\n-      \/\/\n@@ -100,4 +128,7 @@\n-      \/\/ Degenerated from concurrent root mark, reset the flag for STW mark\n-      if (heap->is_concurrent_mark_in_progress()) {\n-        ShenandoahConcurrentMark::cancel();\n-        heap->set_concurrent_mark_in_progress(false);\n+      if (heap->is_concurrent_old_mark_in_progress()) {\n+        \/\/ We have come straight into a degenerated cycle without running a concurrent cycle\n+        \/\/ first and the SATB barrier is enabled to support concurrent old marking. The SATB buffer\n+        \/\/ may hold a mix of old and young pointers. The old pointers need to be transferred\n+        \/\/ to the old generation mark queues and the young pointers are _not_ part of this\n+        \/\/ snapshot, so they must be dropped here.\n+        heap->transfer_old_pointers_from_satb();\n@@ -108,1 +139,33 @@\n-      heap->set_unload_classes(heap->heuristics()->can_unload_classes());\n+      heap->set_unload_classes(_generation->heuristics()->can_unload_classes() &&\n+                                (!heap->mode()->is_generational() || _generation->is_global()));\n+\n+      if (heap->mode()->is_generational() &&\n+            (_generation->is_young() || (_generation->is_global() && ShenandoahVerify))) {\n+        \/\/ Swap remembered sets for young, or if the verifier will run during a global collect\n+        \/\/ TODO: This path should not depend on ShenandoahVerify\n+        _generation->swap_remembered_set();\n+      }\n+\n+    case _degenerated_roots:\n+      \/\/ Degenerated from concurrent root mark, reset the flag for STW mark\n+      if (!heap->mode()->is_generational()) {\n+        if (heap->is_concurrent_mark_in_progress()) {\n+          heap->cancel_concurrent_mark();\n+        }\n+      } else {\n+        if (_generation->is_concurrent_mark_in_progress()) {\n+          \/\/ We want to allow old generation marking to be punctuated by young collections\n+          \/\/ (even if they have degenerated). If this is a global cycle, we'd have cancelled\n+          \/\/ the entire old gc before coming into this switch.\n+          _generation->cancel_marking();\n+        }\n+      }\n+\n+      if (_degen_point == ShenandoahDegenPoint::_degenerated_roots) {\n+        \/\/ We only need this if the concurrent cycle has already swapped the card tables.\n+        \/\/ Marking will use the 'read' table, but interesting pointers may have been\n+        \/\/ recorded in the 'write' table in the time between the cancelled concurrent cycle\n+        \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n+        \/\/ used to scan the remembered set during the STW mark which follows here.\n+        _generation->merge_write_table();\n+      }\n@@ -130,0 +193,5 @@\n+\n+      if (heap->mode()->is_generational() && _generation->is_global()) {\n+        op_global_coalesce_and_fill();\n+      }\n+\n@@ -134,0 +202,21 @@\n+        if (_degen_point == _degenerated_evac) {\n+          \/\/ Degeneration under oom-evac protocol allows the mutator LRB to expose\n+          \/\/ references to from-space objects. This is okay, in theory, because we\n+          \/\/ will come to the safepoint here to complete the evacuations and update\n+          \/\/ the references. However, if the from-space reference is written to a\n+          \/\/ region that was EC during final mark or was recycled after final mark\n+          \/\/ it will not have TAMS or UWM updated. Such a region is effectively\n+          \/\/ skipped during update references which can lead to crashes and corruption\n+          \/\/ if the from-space reference is accessed.\n+          if (UseTLAB) {\n+            heap->labs_make_parsable();\n+          }\n+\n+          for (size_t i = 0; i < heap->num_regions(); i++) {\n+            ShenandoahHeapRegion* r = heap->get_region(i);\n+            if (r->is_active() && r->top() > r->get_update_watermark()) {\n+              r->set_update_watermark_at_safepoint(r->top());\n+            }\n+          }\n+        }\n+\n@@ -151,1 +240,0 @@\n-\n@@ -191,0 +279,35 @@\n+      \/\/ We defer generation resizing actions until after cset regions have been recycled.\n+      if (heap->mode()->is_generational()) {\n+        size_t old_region_surplus = heap->get_old_region_surplus();\n+        size_t old_region_deficit = heap->get_old_region_deficit();\n+        bool success;\n+        size_t region_xfer;\n+        const char* region_destination;\n+        if (old_region_surplus) {\n+          region_xfer = old_region_surplus;\n+          region_destination = \"young\";\n+          success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n+        } else if (old_region_deficit) {\n+          region_xfer = old_region_surplus;\n+          region_destination = \"old\";\n+          success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n+          if (!success) {\n+            ((ShenandoahOldHeuristics *) heap->old_generation()->heuristics())->trigger_cannot_expand();\n+          }\n+        } else {\n+          region_destination = \"none\";\n+          region_xfer = 0;\n+          success = true;\n+        }\n+\n+        size_t young_available = heap->young_generation()->available();\n+        size_t old_available = heap->old_generation()->available();\n+        log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                           SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                           success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n+                           byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                           byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+\n+        heap->set_old_region_surplus(0);\n+        heap->set_old_region_deficit(0);\n+      }\n@@ -196,0 +319,9 @@\n+  if (heap->mode()->is_generational()) {\n+    \/\/ In case degeneration interrupted concurrent evacuation or update references, we need to clean up transient state.\n+    \/\/ Otherwise, these actions have no effect.\n+    heap->set_young_evac_reserve(0);\n+    heap->set_old_evac_reserve(0);\n+    heap->reset_old_evac_expended();\n+    heap->set_promoted_reserve(0);\n+  }\n+\n@@ -218,1 +350,1 @@\n-  ShenandoahHeap::heap()->prepare_gc();\n+  _generation->prepare_gc();\n@@ -222,1 +354,1 @@\n-  assert(!ShenandoahHeap::heap()->is_concurrent_mark_in_progress(), \"Should be reset\");\n+  assert(!_generation->is_concurrent_mark_in_progress(), \"Should be reset\");\n@@ -224,2 +356,1 @@\n-  ShenandoahSTWMark mark(false \/*full gc*\/);\n-  mark.clear();\n+  ShenandoahSTWMark mark(_generation, false \/*full gc*\/);\n@@ -230,1 +361,1 @@\n-  ShenandoahConcurrentMark mark;\n+  ShenandoahConcurrentMark mark(_generation);\n@@ -242,0 +373,1 @@\n+\n@@ -243,1 +375,1 @@\n-  heap->prepare_regions_and_collection_set(false \/*concurrent*\/);\n+  _generation->prepare_regions_and_collection_set(false \/*concurrent*\/);\n@@ -255,1 +387,10 @@\n-  if (!heap->collection_set()->is_empty()) {\n+  size_t humongous_regions_promoted = heap->get_promotable_humongous_regions();\n+  size_t regular_regions_promoted_in_place = heap->get_regular_regions_promoted_in_place();\n+  if (!heap->collection_set()->is_empty() || (humongous_regions_promoted + regular_regions_promoted_in_place > 0)) {\n+    \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n+    \/\/ Degenerated evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n+\n+    if (ShenandoahVerify) {\n+      heap->verifier()->verify_before_evacuation();\n+    }\n+\n@@ -277,0 +418,4 @@\n+void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n+  ShenandoahHeap::heap()->coalesce_and_fill_old_regions();\n+}\n+\n@@ -327,3 +472,1 @@\n-  log_info(gc)(\"Cannot finish degeneration, upgrading to Full GC\");\n-  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n-\n+  upgrade_to_full();\n@@ -335,1 +478,1 @@\n-  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n+  upgrade_to_full();\n@@ -341,0 +484,1 @@\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -343,1 +487,1 @@\n-      return \"Pause Degenerated GC (<UNSET>)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (<UNSET>)\");\n@@ -345,1 +489,3 @@\n-      return \"Pause Degenerated GC (Outside of Cycle)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (Outside of Cycle)\");\n+    case _degenerated_roots:\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (Roots)\");\n@@ -347,1 +493,1 @@\n-      return \"Pause Degenerated GC (Mark)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (Mark)\");\n@@ -349,1 +495,1 @@\n-      return \"Pause Degenerated GC (Evacuation)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (Evacuation)\");\n@@ -351,1 +497,1 @@\n-      return \"Pause Degenerated GC (Update Refs)\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (Update Refs)\");\n@@ -354,1 +500,1 @@\n-      return \"ERROR\";\n+      SHENANDOAH_RETURN_EVENT_MESSAGE(heap, _generation->type(), \"Pause Degenerated GC\", \" (?)\");\n@@ -357,0 +503,10 @@\n+\n+void ShenandoahDegenGC::upgrade_to_full() {\n+  log_info(gc)(\"Degenerate GC upgrading to Full GC\");\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n+  _upgraded_to_full = true;\n+}\n+\n+bool ShenandoahDegenGC::upgraded_to_full() {\n+  return _upgraded_to_full;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":184,"deletions":28,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -36,0 +37,2 @@\n+  ShenandoahGeneration* _generation;\n+  bool _upgraded_to_full;\n@@ -38,1 +41,1 @@\n-  ShenandoahDegenGC(ShenandoahDegenPoint degen_point);\n+  ShenandoahDegenGC(ShenandoahDegenPoint degen_point, ShenandoahGeneration* generation);\n@@ -40,0 +43,1 @@\n+  bool upgraded_to_full();\n@@ -51,0 +55,1 @@\n+  void op_global_coalesce_and_fill();\n@@ -61,0 +66,2 @@\n+  void upgrade_to_full();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRootProcessor.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n+  : _evacuations_completed(0), _bytes_completed(0),\n+    _evacuations_attempted(0), _bytes_attempted(0),\n+    _age_table(false) {}\n+\n+void ShenandoahEvacuationStats::begin_evacuation(size_t bytes) {\n+  ++_evacuations_attempted;\n+  _bytes_attempted += bytes;\n+}\n+\n+void ShenandoahEvacuationStats::end_evacuation(size_t bytes, uint age) {\n+  ++_evacuations_completed;\n+  _bytes_completed += bytes;\n+  if (age > 0) {\n+    _age_table.add(age, bytes >> LogBytesPerWord);\n+  }\n+}\n+\n+void ShenandoahEvacuationStats::accumulate(const ShenandoahEvacuationStats* other) {\n+  _evacuations_completed += other->_evacuations_completed;\n+  _bytes_completed += other->_bytes_completed;\n+  _evacuations_attempted += other->_evacuations_attempted;\n+  _bytes_attempted += other->_bytes_attempted;\n+\n+  _age_table.merge(&other->_age_table);\n+}\n+\n+void ShenandoahEvacuationStats::reset() {\n+  _evacuations_completed = _evacuations_attempted = 0;\n+  _bytes_completed = _bytes_attempted = 0;\n+  _age_table.clear();\n+}\n+\n+void ShenandoahEvacuationStats::print_on(outputStream* st) {\n+  size_t abandoned_size = _bytes_attempted - _bytes_completed;\n+  size_t abandoned_count = _evacuations_attempted - _evacuations_completed;\n+  st->print_cr(\"Evacuated \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects, \"\n+            \"abandoned \" SIZE_FORMAT \"%s across \" SIZE_FORMAT \" objects.\",\n+            byte_size_in_proper_unit(_bytes_completed), proper_unit_for_byte_size(_bytes_completed),\n+            _evacuations_completed,\n+            byte_size_in_proper_unit(abandoned_size),   proper_unit_for_byte_size(abandoned_size),\n+            abandoned_count);\n+  _age_table.print_on(st, InitialTenuringThreshold);\n+}\n+\n+void ShenandoahEvacuationTracker::print_global_on(outputStream* st) {\n+  print_evacuations_on(st, &_workers_global, &_mutators_global);\n+}\n+\n+void ShenandoahEvacuationTracker::print_evacuations_on(outputStream* st,\n+                                                       ShenandoahEvacuationStats* workers,\n+                                                       ShenandoahEvacuationStats* mutators) {\n+  st->print(\"Workers: \");\n+  workers->print_on(st);\n+  st->cr();\n+  st->print(\"Mutators: \");\n+  mutators->print_on(st);\n+  st->cr();\n+\n+  AgeTable young_region_ages(false), old_region_ages(false);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (uint i = 0; i < heap->num_regions(); ++i) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->age() > 0 && r->age() < AgeTable::table_size) {\n+      if (r->is_young()) {\n+        young_region_ages.add(r->age(), r->get_live_data_words());\n+      } else {\n+        assert(r->is_old(), \"Sanity\");\n+        old_region_ages.add(r->age(), r->get_live_data_words());\n+      }\n+    }\n+  }\n+  st->print(\"Young regions: \");\n+  young_region_ages.print_on(st, InitialTenuringThreshold);\n+  st->cr();\n+  st->print(\"Old regions: \");\n+  old_region_ages.print_on(st, InitialTenuringThreshold);\n+}\n+\n+class ShenandoahStatAggregator : public ThreadClosure {\n+public:\n+  ShenandoahEvacuationStats* _target;\n+  explicit ShenandoahStatAggregator(ShenandoahEvacuationStats* target) : _target(target) {}\n+  virtual void do_thread(Thread* thread) override {\n+    ShenandoahEvacuationStats* local = ShenandoahThreadLocalData::evacuation_stats(thread);\n+    _target->accumulate(local);\n+    local->reset();\n+  }\n+};\n+\n+ShenandoahCycleStats ShenandoahEvacuationTracker::flush_cycle_to_global() {\n+  ShenandoahEvacuationStats mutators, workers;\n+\n+  ThreadsListHandle java_threads_iterator;\n+  ShenandoahStatAggregator aggregate_mutators(&mutators);\n+  java_threads_iterator.list()->threads_do(&aggregate_mutators);\n+\n+  ShenandoahStatAggregator aggregate_workers(&workers);\n+  ShenandoahHeap::heap()->gc_threads_do(&aggregate_workers);\n+\n+  _mutators_global.accumulate(&mutators);\n+  _workers_global.accumulate(&workers);\n+\n+  return {workers, mutators};\n+}\n+\n+void ShenandoahEvacuationTracker::begin_evacuation(Thread* thread, size_t bytes) {\n+  ShenandoahThreadLocalData::begin_evacuation(thread, bytes);\n+}\n+\n+void ShenandoahEvacuationTracker::end_evacuation(Thread* thread, size_t bytes, uint age) {\n+  ShenandoahThreadLocalData::end_evacuation(thread, bytes, age);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n+\n+#include \"gc\/shared\/ageTable.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class ShenandoahEvacuationStats : public CHeapObj<mtGC> {\n+private:\n+  size_t _evacuations_completed;\n+  size_t _bytes_completed;\n+  size_t _evacuations_attempted;\n+  size_t _bytes_attempted;\n+\n+  AgeTable _age_table;\n+\n+public:\n+  ShenandoahEvacuationStats();\n+  void begin_evacuation(size_t bytes);\n+  void end_evacuation(size_t bytes, uint age);\n+\n+  void print_on(outputStream* st);\n+  void accumulate(const ShenandoahEvacuationStats* other);\n+  void reset();\n+};\n+\n+struct ShenandoahCycleStats {\n+  ShenandoahEvacuationStats workers;\n+  ShenandoahEvacuationStats mutators;\n+};\n+\n+class ShenandoahEvacuationTracker : public CHeapObj<mtGC> {\n+private:\n+  ShenandoahEvacuationStats _workers_global;\n+  ShenandoahEvacuationStats _mutators_global;\n+\n+public:\n+  void begin_evacuation(Thread* thread, size_t bytes);\n+  void end_evacuation(Thread* thread, size_t bytes, uint age);\n+\n+  void print_global_on(outputStream* st);\n+  static void print_evacuations_on(outputStream* st,\n+                                   ShenandoahEvacuationStats* workers,\n+                                   ShenandoahEvacuationStats* mutators);\n+\n+  ShenandoahCycleStats flush_cycle_to_global();\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHEVACTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,2 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -31,0 +34,3 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -35,0 +41,366 @@\n+ShenandoahSetsOfFree::ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set) :\n+    _max(max_regions),\n+    _free_set(free_set),\n+    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes())\n+{\n+  _membership = NEW_C_HEAP_ARRAY(ShenandoahFreeMemoryType, max_regions, mtGC);\n+  clear_internal();\n+}\n+\n+ShenandoahSetsOfFree::~ShenandoahSetsOfFree() {\n+  FREE_C_HEAP_ARRAY(ShenandoahFreeMemoryType, _membership);\n+}\n+\n+\n+void ShenandoahSetsOfFree::clear_internal() {\n+  for (size_t idx = 0; idx < _max; idx++) {\n+    _membership[idx] = NotFree;\n+  }\n+\n+  for (size_t idx = 0; idx < NumFreeSets; idx++) {\n+    _leftmosts[idx] = _max;\n+    _rightmosts[idx] = 0;\n+    _leftmosts_empty[idx] = _max;\n+    _rightmosts_empty[idx] = 0;\n+    _capacity_of[idx] = 0;\n+    _used_by[idx] = 0;\n+  }\n+\n+  _left_to_right_bias[Mutator] = true;\n+  _left_to_right_bias[Collector] = false;\n+  _left_to_right_bias[OldCollector] = false;\n+\n+  _region_counts[Mutator] = 0;\n+  _region_counts[Collector] = 0;\n+  _region_counts[OldCollector] = 0;\n+  _region_counts[NotFree] = _max;\n+}\n+\n+void ShenandoahSetsOfFree::clear_all() {\n+  clear_internal();\n+}\n+\n+void ShenandoahSetsOfFree::increase_used(ShenandoahFreeMemoryType which_set, size_t bytes) {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"Set must correspond to a valid freeset\");\n+  _used_by[which_set] += bytes;\n+  assert (_used_by[which_set] <= _capacity_of[which_set],\n+          \"Must not use (\" SIZE_FORMAT \") more than capacity (\" SIZE_FORMAT \") after increase by \" SIZE_FORMAT,\n+          _used_by[which_set], _capacity_of[which_set], bytes);\n+}\n+\n+inline void ShenandoahSetsOfFree::shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx) {\n+  if (idx == _leftmosts[set]) {\n+    while ((_leftmosts[set] < _max) && !in_free_set(_leftmosts[set], set)) {\n+      _leftmosts[set]++;\n+    }\n+    if (_leftmosts_empty[set] < _leftmosts[set]) {\n+      \/\/ This gets us closer to where we need to be; we'll scan further when leftmosts_empty is requested.\n+      _leftmosts_empty[set] = _leftmosts[set];\n+    }\n+  }\n+  if (idx == _rightmosts[set]) {\n+    while (_rightmosts[set] > 0 && !in_free_set(_rightmosts[set], set)) {\n+      _rightmosts[set]--;\n+    }\n+    if (_rightmosts_empty[set] > _rightmosts[set]) {\n+      \/\/ This gets us closer to where we need to be; we'll scan further when rightmosts_empty is requested.\n+      _rightmosts_empty[set] = _rightmosts[set];\n+    }\n+  }\n+}\n+\n+inline void ShenandoahSetsOfFree::expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t region_capacity) {\n+  if (region_capacity == _region_size_bytes) {\n+    if (_leftmosts_empty[set] > idx) {\n+      _leftmosts_empty[set] = idx;\n+    }\n+    if (_rightmosts_empty[set] < idx) {\n+      _rightmosts_empty[set] = idx;\n+    }\n+  }\n+  if (_leftmosts[set] > idx) {\n+    _leftmosts[set] = idx;\n+  }\n+  if (_rightmosts[set] < idx) {\n+    _rightmosts[set] = idx;\n+  }\n+}\n+\n+void ShenandoahSetsOfFree::remove_from_free_sets(size_t idx) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  ShenandoahFreeMemoryType orig_set = membership(idx);\n+  assert (orig_set > NotFree && orig_set < NumFreeSets, \"Cannot remove from free sets if not already free\");\n+  _membership[idx] = NotFree;\n+  shrink_bounds_if_touched(orig_set, idx);\n+\n+  _region_counts[orig_set]--;\n+  _region_counts[NotFree]++;\n+}\n+\n+\n+void ShenandoahSetsOfFree::make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t region_capacity) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (_membership[idx] == NotFree, \"Cannot make free if already free\");\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  _membership[idx] = which_set;\n+  _capacity_of[which_set] += region_capacity;\n+  expand_bounds_maybe(which_set, idx, region_capacity);\n+\n+  _region_counts[NotFree]--;\n+  _region_counts[which_set]++;\n+}\n+\n+void ShenandoahSetsOfFree::move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t region_capacity) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert ((new_set > NotFree) && (new_set < NumFreeSets), \"New set must be valid\");\n+  ShenandoahFreeMemoryType orig_set = _membership[idx];\n+  assert ((orig_set > NotFree) && (orig_set < NumFreeSets), \"Cannot move free unless already free\");\n+  \/\/ Expected transitions:\n+  \/\/  During rebuild: Mutator => Collector\n+  \/\/                  Mutator empty => Collector\n+  \/\/  During flip_to_gc:\n+  \/\/                  Mutator empty => Collector\n+  \/\/                  Mutator empty => Old Collector\n+  \/\/ At start of update refs:\n+  \/\/                  Collector => Mutator\n+  \/\/                  OldCollector Empty => Mutator\n+  assert (((region_capacity <= _region_size_bytes) &&\n+           ((orig_set == Mutator) && (new_set == Collector)) ||\n+           ((orig_set == Collector) && (new_set == Mutator))) ||\n+          ((region_capacity == _region_size_bytes) &&\n+           ((orig_set == Mutator) && (new_set == Collector)) ||\n+           ((orig_set == OldCollector) && (new_set == Mutator)) ||\n+           (new_set == OldCollector)), \"Unexpected movement between sets\");\n+\n+  _membership[idx] = new_set;\n+  _capacity_of[orig_set] -= region_capacity;\n+  shrink_bounds_if_touched(orig_set, idx);\n+\n+  _capacity_of[new_set] += region_capacity;\n+  expand_bounds_maybe(new_set, idx, region_capacity);\n+\n+  _region_counts[orig_set]--;\n+  _region_counts[new_set]++;\n+}\n+\n+inline ShenandoahFreeMemoryType ShenandoahSetsOfFree::membership(size_t idx) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  return _membership[idx];\n+}\n+\n+  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n+  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n+inline bool ShenandoahSetsOfFree::in_free_set(size_t idx, ShenandoahFreeMemoryType test_set) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  if (_membership[idx] == test_set) {\n+    assert (test_set == NotFree || _free_set->alloc_capacity(idx) > 0, \"Free regions must have alloc capacity\");\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+inline size_t ShenandoahSetsOfFree::leftmost(ShenandoahFreeMemoryType which_set) const {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  size_t idx = _leftmosts[which_set];\n+  if (idx >= _max) {\n+    return _max;\n+  } else {\n+    assert (in_free_set(idx, which_set), \"left-most region must be free\");\n+    return idx;\n+  }\n+}\n+\n+inline size_t ShenandoahSetsOfFree::rightmost(ShenandoahFreeMemoryType which_set) const {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  size_t idx = _rightmosts[which_set];\n+  assert ((_leftmosts[which_set] == _max) || in_free_set(idx, which_set), \"right-most region must be free\");\n+  return idx;\n+}\n+\n+size_t ShenandoahSetsOfFree::leftmost_empty(ShenandoahFreeMemoryType which_set) {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  for (size_t idx = _leftmosts_empty[which_set]; idx < _max; idx++) {\n+    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+      _leftmosts_empty[which_set] = idx;\n+      return idx;\n+    }\n+  }\n+  _leftmosts_empty[which_set] = _max;\n+  _rightmosts_empty[which_set] = 0;\n+  return _max;\n+}\n+\n+inline size_t ShenandoahSetsOfFree::rightmost_empty(ShenandoahFreeMemoryType which_set) {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  for (intptr_t idx = _rightmosts_empty[which_set]; idx >= 0; idx--) {\n+    if ((membership(idx) == which_set) && (_free_set->alloc_capacity(idx) == _region_size_bytes)) {\n+      _rightmosts_empty[which_set] = idx;\n+      return idx;\n+    }\n+  }\n+  _leftmosts_empty[which_set] = _max;\n+  _rightmosts_empty[which_set] = 0;\n+  return 0;\n+}\n+\n+inline bool ShenandoahSetsOfFree::alloc_from_left_bias(ShenandoahFreeMemoryType which_set) {\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+  return _left_to_right_bias[which_set];\n+}\n+\n+void ShenandoahSetsOfFree::establish_alloc_bias(ShenandoahFreeMemoryType which_set) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  shenandoah_assert_heaplocked();\n+  assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+\n+  size_t middle = (_leftmosts[which_set] + _rightmosts[which_set]) \/ 2;\n+  size_t available_in_first_half = 0;\n+  size_t available_in_second_half = 0;\n+\n+  for (size_t index = _leftmosts[which_set]; index < middle; index++) {\n+    if (in_free_set(index, which_set)) {\n+      ShenandoahHeapRegion* r = heap->get_region(index);\n+      available_in_first_half += r->free();\n+    }\n+  }\n+  for (size_t index = middle; index <= _rightmosts[which_set]; index++) {\n+    if (in_free_set(index, which_set)) {\n+      ShenandoahHeapRegion* r = heap->get_region(index);\n+      available_in_second_half += r->free();\n+    }\n+  }\n+\n+  \/\/ We desire to first consume the sparsely distributed regions in order that the remaining regions are densely packed.\n+  \/\/ Densely packing regions reduces the effort to search for a region that has sufficient memory to satisfy a new allocation\n+  \/\/ request.  Regions become sparsely distributed following a Full GC, which tends to slide all regions to the front of the\n+  \/\/ heap rather than allowing survivor regions to remain at the high end of the heap where we intend for them to congregate.\n+\n+  \/\/ TODO: In the future, we may modify Full GC so that it slides old objects to the end of the heap and young objects to the\n+  \/\/ front of the heap. If this is done, we can always search survivor Collector and OldCollector regions right to left.\n+  _left_to_right_bias[which_set] = (available_in_second_half > available_in_first_half);\n+}\n+\n+#ifdef ASSERT\n+void ShenandoahSetsOfFree::assert_bounds() {\n+\n+  size_t leftmosts[NumFreeSets];\n+  size_t rightmosts[NumFreeSets];\n+  size_t empty_leftmosts[NumFreeSets];\n+  size_t empty_rightmosts[NumFreeSets];\n+\n+  for (int i = 0; i < NumFreeSets; i++) {\n+    leftmosts[i] = _max;\n+    empty_leftmosts[i] = _max;\n+    rightmosts[i] = 0;\n+    empty_rightmosts[i] = 0;\n+  }\n+\n+  for (size_t i = 0; i < _max; i++) {\n+    ShenandoahFreeMemoryType set = membership(i);\n+    switch (set) {\n+      case NotFree:\n+        break;\n+\n+      case Mutator:\n+      case Collector:\n+      case OldCollector:\n+      {\n+        size_t capacity = _free_set->alloc_capacity(i);\n+        bool is_empty = (capacity == _region_size_bytes);\n+        assert(capacity > 0, \"free regions must have allocation capacity\");\n+        if (i < leftmosts[set]) {\n+          leftmosts[set] = i;\n+        }\n+        if (is_empty && (i < empty_leftmosts[set])) {\n+          empty_leftmosts[set] = i;\n+        }\n+        if (i > rightmosts[set]) {\n+          rightmosts[set] = i;\n+        }\n+        if (is_empty && (i > empty_rightmosts[set])) {\n+          empty_rightmosts[set] = i;\n+        }\n+        break;\n+      }\n+\n+      case NumFreeSets:\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+\n+  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n+  assert (leftmost(Mutator) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Mutator),  _max);\n+  assert (rightmost(Mutator) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Mutator),  _max);\n+\n+  assert (leftmost(Mutator) == _max || in_free_set(leftmost(Mutator), Mutator),\n+          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Mutator));\n+  assert (leftmost(Mutator) == _max || in_free_set(rightmost(Mutator), Mutator),\n+          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Mutator));\n+\n+  \/\/ If Mutator set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n+  size_t beg_off = leftmosts[Mutator];\n+  size_t end_off = rightmosts[Mutator];\n+  assert (beg_off >= leftmost(Mutator),\n+          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Mutator));\n+  assert (end_off <= rightmost(Mutator),\n+          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Mutator));\n+\n+  beg_off = empty_leftmosts[Mutator];\n+  end_off = empty_rightmosts[Mutator];\n+  assert (beg_off >= leftmost_empty(Mutator),\n+          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Mutator));\n+  assert (end_off <= rightmost_empty(Mutator),\n+          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Mutator));\n+\n+  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n+  assert (leftmost(Collector) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(Collector),  _max);\n+  assert (rightmost(Collector) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(Collector),  _max);\n+\n+  assert (leftmost(Collector) == _max || in_free_set(leftmost(Collector), Collector),\n+          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(Collector));\n+  assert (leftmost(Collector) == _max || in_free_set(rightmost(Collector), Collector),\n+          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(Collector));\n+\n+  \/\/ If Collector set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n+  beg_off = leftmosts[Collector];\n+  end_off = rightmosts[Collector];\n+  assert (beg_off >= leftmost(Collector),\n+          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(Collector));\n+  assert (end_off <= rightmost(Collector),\n+          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(Collector));\n+\n+  beg_off = empty_leftmosts[Collector];\n+  end_off = empty_rightmosts[Collector];\n+  assert (beg_off >= leftmost_empty(Collector),\n+          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(Collector));\n+  assert (end_off <= rightmost_empty(Collector),\n+          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(Collector));\n+\n+  \/\/ Performance invariants. Failing these would not break the free set, but performance would suffer.\n+  assert (leftmost(OldCollector) <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, leftmost(OldCollector),  _max);\n+  assert (rightmost(OldCollector) < _max, \"rightmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, rightmost(OldCollector),  _max);\n+\n+  assert (leftmost(OldCollector) == _max || in_free_set(leftmost(OldCollector), OldCollector),\n+          \"leftmost region should be free: \" SIZE_FORMAT,  leftmost(OldCollector));\n+  assert (leftmost(OldCollector) == _max || in_free_set(rightmost(OldCollector), OldCollector),\n+          \"rightmost region should be free: \" SIZE_FORMAT, rightmost(OldCollector));\n+\n+  \/\/ If OldCollector set is empty, leftmosts will both equal max, rightmosts will both equal zero.  Likewise for empty region sets.\n+  beg_off = leftmosts[OldCollector];\n+  end_off = rightmosts[OldCollector];\n+  assert (beg_off >= leftmost(OldCollector),\n+          \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost(OldCollector));\n+  assert (end_off <= rightmost(OldCollector),\n+          \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost(OldCollector));\n+\n+  beg_off = empty_leftmosts[OldCollector];\n+  end_off = empty_rightmosts[OldCollector];\n+  assert (beg_off >= leftmost_empty(OldCollector),\n+          \"free empty regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, leftmost_empty(OldCollector));\n+  assert (end_off <= rightmost_empty(OldCollector),\n+          \"free empty regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, rightmost_empty(OldCollector));\n+}\n+#endif\n+\n@@ -37,3 +409,1 @@\n-  _mutator_free_bitmap(max_regions, mtGC),\n-  _collector_free_bitmap(max_regions, mtGC),\n-  _max(max_regions)\n+  _free_sets(max_regions, this)\n@@ -44,1 +414,5 @@\n-void ShenandoahFreeSet::increase_used(size_t num_bytes) {\n+\/\/ This allocates from a region within the old_collector_set.  If affiliation equals OLD, the allocation must be taken\n+\/\/ from a region that is_old().  Otherwise, affiliation should be FREE, in which case this will put a previously unaffiliated\n+\/\/ region into service.\n+HeapWord* ShenandoahFreeSet::allocate_old_with_affiliation(ShenandoahAffiliation affiliation,\n+                                                           ShenandoahAllocRequest& req, bool& in_new_region) {\n@@ -46,1 +420,0 @@\n-  _used += num_bytes;\n@@ -48,2 +421,36 @@\n-  assert(_used <= _capacity, \"must not use more than we have: used: \" SIZE_FORMAT\n-         \", capacity: \" SIZE_FORMAT \", num_bytes: \" SIZE_FORMAT, _used, _capacity, num_bytes);\n+  size_t rightmost =\n+    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.rightmost_empty(OldCollector): _free_sets.rightmost(OldCollector);\n+  size_t leftmost =\n+    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.leftmost_empty(OldCollector): _free_sets.leftmost(OldCollector);\n+  if (_free_sets.alloc_from_left_bias(OldCollector)) {\n+    \/\/ This mode picks up stragglers left by a full GC\n+    for (size_t idx = leftmost; idx <= rightmost; idx++) {\n+      if (_free_sets.in_free_set(idx, OldCollector)) {\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        assert(r->is_trash() || !r->is_affiliated() || r->is_old(), \"old_collector_set region has bad affiliation\");\n+        if (r->affiliation() == affiliation) {\n+          HeapWord* result = try_allocate_in(r, req, in_new_region);\n+          if (result != nullptr) {\n+            return result;\n+          }\n+        }\n+      }\n+    }\n+  } else {\n+    \/\/ This mode picks up stragglers left by a previous concurrent GC\n+    for (size_t count = rightmost + 1; count > leftmost; count--) {\n+      \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+      size_t idx = count - 1;\n+      if (_free_sets.in_free_set(idx, OldCollector)) {\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        assert(r->is_trash() || !r->is_affiliated() || r->is_old(), \"old_collector_set region has bad affiliation\");\n+        if (r->affiliation() == affiliation) {\n+          HeapWord* result = try_allocate_in(r, req, in_new_region);\n+          if (result != nullptr) {\n+            return result;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n@@ -52,4 +459,9 @@\n-bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {\n-  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n-          idx, _max, _mutator_leftmost, _mutator_rightmost);\n-  return _mutator_free_bitmap.at(idx);\n+void ShenandoahFreeSet::add_old_collector_free_region(ShenandoahHeapRegion* region) {\n+  shenandoah_assert_heaplocked();\n+  size_t idx = region->index();\n+  size_t capacity = alloc_capacity(region);\n+  assert(_free_sets.membership(idx) == NotFree, \"Regions promoted in place should not be in any free set\");\n+  if (capacity >= PLAB::min_size() * HeapWordSize) {\n+    _free_sets.make_free(idx, OldCollector, capacity);\n+    _heap->augment_promo_reserve(capacity);\n+  }\n@@ -58,4 +470,23 @@\n-bool ShenandoahFreeSet::is_collector_free(size_t idx) const {\n-  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n-          idx, _max, _collector_leftmost, _collector_rightmost);\n-  return _collector_free_bitmap.at(idx);\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(ShenandoahAffiliation affiliation,\n+                                                       ShenandoahAllocRequest& req, bool& in_new_region) {\n+  shenandoah_assert_heaplocked();\n+  size_t rightmost =\n+    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.rightmost_empty(Collector): _free_sets.rightmost(Collector);\n+  size_t leftmost =\n+    (affiliation == ShenandoahAffiliation::FREE)? _free_sets.leftmost_empty(Collector): _free_sets.leftmost(Collector);\n+  for (size_t c = rightmost + 1; c > leftmost; c--) {\n+    \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+    size_t idx = c - 1;\n+    if (_free_sets.in_free_set(idx, Collector)) {\n+      ShenandoahHeapRegion* r = _heap->get_region(idx);\n+      if (r->affiliation() == affiliation) {\n+        HeapWord* result = try_allocate_in(r, req, in_new_region);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+    }\n+  }\n+  log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT,\n+                      shenandoah_affiliation_name(affiliation), p2i(&req));\n+  return nullptr;\n@@ -65,0 +496,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -77,0 +510,27 @@\n+  \/\/ Overwrite with non-zero (non-NULL) values only if necessary for allocation bookkeeping.\n+\n+  bool allow_new_region = true;\n+  if (_heap->mode()->is_generational()) {\n+    switch (req.affiliation()) {\n+      case ShenandoahAffiliation::OLD_GENERATION:\n+        \/\/ Note: unsigned result from free_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->old_generation()->free_unaffiliated_regions() <= 0) {\n+          allow_new_region = false;\n+        }\n+        break;\n+\n+      case ShenandoahAffiliation::YOUNG_GENERATION:\n+        \/\/ Note: unsigned result from free_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->young_generation()->free_unaffiliated_regions() <= 0) {\n+          allow_new_region = false;\n+        }\n+        break;\n+\n+      case ShenandoahAffiliation::FREE:\n+        fatal(\"Should request affiliation\");\n+\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+  }\n@@ -80,1 +540,0 @@\n-\n@@ -82,4 +541,7 @@\n-      for (size_t idx = _mutator_leftmost; idx <= _mutator_rightmost; idx++) {\n-        if (is_mutator_free(idx)) {\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-          if (result != nullptr) {\n+      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        if (_free_sets.in_free_set(idx, Mutator) && (allow_new_region || r->is_affiliated())) {\n+          \/\/ try_allocate_in() increases used if the allocation is successful.\n+          HeapWord* result;\n+          size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+          if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n@@ -90,1 +552,0 @@\n-\n@@ -95,2 +556,5 @@\n-    case ShenandoahAllocRequest::_alloc_shared_gc: {\n-      \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+      \/\/ GCLABs are for evacuation so we must be in evacuation phase.  If this allocation is successful, increment\n+      \/\/ the relevant evac_expended rather than used value.\n+\n+    case ShenandoahAllocRequest::_alloc_plab:\n+      \/\/ PLABs always reside in old-gen and are only allocated during evacuation phase.\n@@ -98,5 +562,31 @@\n-      \/\/ Fast-path: try to allocate in the collector view first\n-      for (size_t c = _collector_rightmost + 1; c > _collector_leftmost; c--) {\n-        size_t idx = c - 1;\n-        if (is_collector_free(idx)) {\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+    case ShenandoahAllocRequest::_alloc_shared_gc: {\n+      if (!_heap->mode()->is_generational()) {\n+        \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+        \/\/ Fast-path: try to allocate in the collector view first\n+        for (size_t c = _free_sets.rightmost(Collector) + 1; c > _free_sets.leftmost(Collector); c--) {\n+          size_t idx = c - 1;\n+          if (_free_sets.in_free_set(idx, Collector)) {\n+            HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+            if (result != nullptr) {\n+              return result;\n+            }\n+          }\n+        }\n+      } else {\n+        \/\/ First try to fit into a region that is already in use in the same generation.\n+        HeapWord* result;\n+        if (req.is_old()) {\n+          result = allocate_old_with_affiliation(req.affiliation(), req, in_new_region);\n+        } else {\n+          result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n+        }\n+        if (result != nullptr) {\n+          return result;\n+        }\n+        if (allow_new_region) {\n+          \/\/ Then try a free region that is dedicated to GC allocations.\n+          if (req.is_old()) {\n+            result = allocate_old_with_affiliation(FREE, req, in_new_region);\n+          } else {\n+            result = allocate_with_affiliation(FREE, req, in_new_region);\n+          }\n@@ -108,1 +598,0 @@\n-\n@@ -114,10 +603,35 @@\n-      \/\/ Try to steal the empty region from the mutator view\n-      for (size_t c = _mutator_rightmost + 1; c > _mutator_leftmost; c--) {\n-        size_t idx = c - 1;\n-        if (is_mutator_free(idx)) {\n-          ShenandoahHeapRegion* r = _heap->get_region(idx);\n-          if (can_allocate_from(r)) {\n-            flip_to_gc(r);\n-            HeapWord *result = try_allocate_in(r, req, in_new_region);\n-            if (result != nullptr) {\n-              return result;\n+      if (!allow_new_region && req.is_old() && (_heap->young_generation()->free_unaffiliated_regions() > 0)) {\n+        \/\/ This allows us to flip a mutator region to old_collector\n+        allow_new_region = true;\n+      }\n+\n+      \/\/ We should expand old-gen if this can prevent an old-gen evacuation failure.  We don't care so much about\n+      \/\/ promotion failures since they can be mitigated in a subsequent GC pass.  Would be nice to know if this\n+      \/\/ allocation request is for evacuation or promotion.  Individual threads limit their use of PLAB memory for\n+      \/\/ promotions, so we already have an assurance that any additional memory set aside for old-gen will be used\n+      \/\/ only for old-gen evacuations.\n+\n+      \/\/ Also TODO:\n+      \/\/ if (GC is idle (out of cycle) and mutator allocation fails and there is memory reserved in Collector\n+      \/\/ or OldCollector sets, transfer a region of memory so that we can satisfy the allocation request, and\n+      \/\/ immediately trigger the start of GC.  Is better to satisfy the allocation than to trigger out-of-cycle\n+      \/\/ allocation failure (even if this means we have a little less memory to handle evacuations during the\n+      \/\/ subsequent GC pass).\n+\n+      if (allow_new_region) {\n+        \/\/ Try to steal an empty region from the mutator view.\n+        for (size_t c = _free_sets.rightmost_empty(Mutator) + 1; c > _free_sets.leftmost_empty(Mutator); c--) {\n+          size_t idx = c - 1;\n+          if (_free_sets.in_free_set(idx, Mutator)) {\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n+            if (can_allocate_from(r)) {\n+              if (req.is_old()) {\n+                flip_to_old_gc(r);\n+              } else {\n+                flip_to_gc(r);\n+              }\n+              HeapWord *result = try_allocate_in(r, req, in_new_region);\n+              if (result != nullptr) {\n+                log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n+                return result;\n+              }\n@@ -132,1 +646,0 @@\n-\n@@ -138,1 +651,0 @@\n-\n@@ -142,2 +654,51 @@\n-HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest& req, bool& in_new_region) {\n-  assert (!has_no_alloc_capacity(r), \"Performance: should avoid full regions on this path: \" SIZE_FORMAT, r->index());\n+\/\/ This work method takes an argument corresponding to the number of bytes\n+\/\/ free in a region, and returns the largest amount in heapwords that can be allocated\n+\/\/ such that both of the following conditions are satisfied:\n+\/\/\n+\/\/ 1. it is a multiple of card size\n+\/\/ 2. any remaining shard may be filled with a filler object\n+\/\/\n+\/\/ The idea is that the allocation starts and ends at card boundaries. Because\n+\/\/ a region ('s end) is card-aligned, the remainder shard that must be filled is\n+\/\/ at the start of the free space.\n+\/\/\n+\/\/ This is merely a helper method to use for the purpose of such a calculation.\n+size_t get_usable_free_words(size_t free_bytes) {\n+  \/\/ e.g. card_size is 512, card_shift is 9, min_fill_size() is 8\n+  \/\/      free is 514\n+  \/\/      usable_free is 512, which is decreased to 0\n+  size_t usable_free = (free_bytes \/ CardTable::card_size()) << CardTable::card_shift();\n+  assert(usable_free <= free_bytes, \"Sanity check\");\n+  if ((free_bytes != usable_free) && (free_bytes - usable_free < ShenandoahHeap::min_fill_size() * HeapWordSize)) {\n+    \/\/ After aligning to card multiples, the remainder would be smaller than\n+    \/\/ the minimum filler object, so we'll need to take away another card's\n+    \/\/ worth to construct a filler object.\n+    if (usable_free >= CardTable::card_size()) {\n+      usable_free -= CardTable::card_size();\n+    } else {\n+      assert(usable_free == 0, \"usable_free is a multiple of card_size and card_size > min_fill_size\");\n+    }\n+  }\n+\n+  return usable_free \/ HeapWordSize;\n+}\n+\n+\/\/ Given a size argument, which is a multiple of card size, a request struct\n+\/\/ for a PLAB, and an old region, return a pointer to the allocated space for\n+\/\/ a PLAB which is card-aligned and where any remaining shard in the region\n+\/\/ has been suitably filled by a filler object.\n+\/\/ It is assumed (and assertion-checked) that such an allocation is always possible.\n+HeapWord* ShenandoahFreeSet::allocate_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r) {\n+  assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+  assert(r->is_old(), \"All PLABs reside in old-gen\");\n+  assert(!req.is_mutator_alloc(), \"PLABs should not be allocated by mutators.\");\n+  assert(size % CardTable::card_size_in_words() == 0, \"size must be multiple of card table size, was \" SIZE_FORMAT, size);\n+\n+  HeapWord* result = r->allocate_aligned(size, req, CardTable::card_size());\n+  assert(result != nullptr, \"Allocation cannot fail\");\n+  assert(r->top() <= r->end(), \"Allocation cannot span end of region\");\n+  assert(req.actual_size() == size, \"Should not have needed to adjust size for PLAB.\");\n+  assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+\n+  return result;\n+}\n@@ -145,2 +706,3 @@\n-  if (_heap->is_concurrent_weak_root_in_progress() &&\n-      r->is_trash()) {\n+HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest& req, bool& in_new_region) {\n+  assert (has_alloc_capacity(r), \"Performance: should avoid full regions on this path: \" SIZE_FORMAT, r->index());\n+  if (_heap->is_concurrent_weak_root_in_progress() && r->is_trash()) {\n@@ -151,0 +713,16 @@\n+  if (!r->is_affiliated()) {\n+    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n+    r->set_affiliation(req.affiliation());\n+    if (r->is_old()) {\n+      \/\/ Any OLD region allocated during concurrent coalesce-and-fill does not need to be coalesced and filled because\n+      \/\/ all objects allocated within this region are above TAMS (and thus are implicitly marked).  In case this is an\n+      \/\/ OLD region and concurrent preparation for mixed evacuations visits this region before the start of the next\n+      \/\/ old-gen concurrent mark (i.e. this region is allocated following the start of old-gen concurrent mark but before\n+      \/\/ concurrent preparations for mixed evacuations are completed), we mark this region as not requiring any\n+      \/\/ coalesce-and-fill processing.\n+      r->end_preemptible_coalesce_and_fill();\n+      _heap->clear_cards_for(r);\n+      _heap->old_generation()->increment_affiliated_region_count();\n+    } else {\n+      _heap->young_generation()->increment_affiliated_region_count();\n+    }\n@@ -152,1 +730,7 @@\n-  in_new_region = r->is_empty();\n+    assert(ctx->top_at_mark_start(r) == r->bottom(), \"Newly established allocation region starts with TAMS equal to bottom\");\n+    assert(ctx->is_bitmap_clear_range(ctx->top_bitmap(r), r->end()), \"Bitmap above top_bitmap() must be clear\");\n+  } else if (r->affiliation() != req.affiliation()) {\n+    assert(_heap->mode()->is_generational(), \"Request for %s from %s region should only happen in generational mode.\",\n+           req.affiliation_name(), r->affiliation_name());\n+    return nullptr;\n+  }\n@@ -154,0 +738,1 @@\n+  in_new_region = r->is_empty();\n@@ -155,1 +740,0 @@\n-  size_t size = req.size();\n@@ -157,0 +741,6 @@\n+  if (in_new_region) {\n+    log_debug(gc, free)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+                       r->index(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(&req));\n+  }\n+\n+  \/\/ req.size() is in words, r->free() is in bytes.\n@@ -158,3 +748,33 @@\n-    size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n-    if (size > free) {\n-      size = free;\n+    if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+      assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n+      assert(_free_sets.in_free_set(r->index(), OldCollector), \"PLABS must be allocated in old_collector_free regions\");\n+      \/\/ Need to assure that plabs are aligned on multiple of card region.\n+      \/\/ Since we have Elastic TLABs, align sizes up. They may be decreased to fit in the usable\n+      \/\/ memory remaining in the region (which will also be aligned to cards).\n+      size_t adjusted_size = align_up(req.size(), CardTable::card_size_in_words());\n+      size_t adjusted_min_size = align_up(req.min_size(), CardTable::card_size_in_words());\n+      size_t usable_free = get_usable_free_words(r->free());\n+\n+      if (adjusted_size > usable_free) {\n+        adjusted_size = usable_free;\n+      }\n+\n+      if (adjusted_size >= adjusted_min_size) {\n+        result = allocate_aligned_plab(adjusted_size, req, r);\n+      }\n+      \/\/ Otherwise, leave result == nullptr because the adjusted size is smaller than min size.\n+    } else {\n+      \/\/ This is a GCLAB or a TLAB allocation\n+      size_t adjusted_size = req.size();\n+      size_t free = align_down(r->free() >> LogHeapWordSize, MinObjAlignment);\n+      if (adjusted_size > free) {\n+        adjusted_size = free;\n+      }\n+      if (adjusted_size >= req.min_size()) {\n+        result = r->allocate(adjusted_size, req);\n+        assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, adjusted_size);\n+        req.set_actual_size(adjusted_size);\n+      } else {\n+        log_trace(gc, free)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                           \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n+      }\n@@ -162,3 +782,7 @@\n-    if (size >= req.min_size()) {\n-      result = r->allocate(size, req.type());\n-      assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, size);\n+  } else if (req.is_lab_alloc() && req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+\n+    \/\/ inelastic PLAB\n+    size_t size = req.size();\n+    size_t usable_free = get_usable_free_words(r->free());\n+    if (size <= usable_free) {\n+      result = allocate_aligned_plab(size, req, r);\n@@ -167,1 +791,6 @@\n-    result = r->allocate(size, req.type());\n+    size_t size = req.size();\n+    result = r->allocate(size, req);\n+    if (result != nullptr) {\n+      \/\/ Record actual allocation size\n+      req.set_actual_size(size);\n+    }\n@@ -170,0 +799,1 @@\n+  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n@@ -173,7 +803,12 @@\n-      increase_used(size * HeapWordSize);\n-    }\n-\n-    \/\/ Record actual allocation size\n-    req.set_actual_size(size);\n-\n-    if (req.is_gc_alloc()) {\n+      assert(req.is_young(), \"Mutator allocations always come from young generation.\");\n+      _free_sets.increase_used(Mutator, req.actual_size() * HeapWordSize);\n+    } else {\n+      assert(req.is_gc_alloc(), \"Should be gc_alloc since req wasn't mutator alloc\");\n+\n+      \/\/ For GC allocations, we advance update_watermark because the objects relocated into this memory during\n+      \/\/ evacuation are not updated during evacuation.  For both young and old regions r, it is essential that all\n+      \/\/ PLABs be made parsable at the end of evacuation.  This is enabled by retiring all plabs at end of evacuation.\n+      \/\/ TODO: Making a PLAB parsable involves placing a filler object in its remnant memory but does not require\n+      \/\/ that the PLAB be disabled for all future purposes.  We may want to introduce a new service to make the\n+      \/\/ PLABs parsable while still allowing the PLAB to serve future allocation requests that arise during the\n+      \/\/ next evacuation pass.\n@@ -181,0 +816,4 @@\n+      if (r->is_old()) {\n+        assert(req.type() != ShenandoahAllocRequest::_alloc_gclab, \"old-gen allocations use PLAB or shared allocation\");\n+        \/\/ for plabs, we'll sort the difference between evac and promotion usage when we retire the plab\n+      }\n@@ -184,2 +823,2 @@\n-  if (result == nullptr || has_no_alloc_capacity(r)) {\n-    \/\/ Region cannot afford this or future allocations. Retire it.\n+  if (result == nullptr || alloc_capacity(r) < PLAB::min_size() * HeapWordSize) {\n+    \/\/ Region cannot afford this and is likely to not afford future allocations. Retire it.\n@@ -188,3 +827,2 @@\n-    \/\/ fit, but the next small one would, we are risking to inflate scan times when lots of\n-    \/\/ almost-full regions precede the fully-empty region where we want allocate the entire TLAB.\n-    \/\/ TODO: Record first fully-empty region, and use that for large allocations\n+    \/\/ fit but the next small one would, we are risking to inflate scan times when lots of\n+    \/\/ almost-full regions precede the fully-empty region where we want to allocate the entire TLAB.\n@@ -193,0 +831,1 @@\n+    size_t idx = r->index();\n@@ -196,2 +835,3 @@\n-        increase_used(waste);\n-        _heap->notify_mutator_alloc_words(waste >> LogHeapWordSize, true);\n+        _free_sets.increase_used(Mutator, waste);\n+        \/\/ This one request could cause several regions to be \"retired\", so we must accumulate the waste\n+        req.set_waste((waste >> LogHeapWordSize) + req.waste());\n@@ -199,0 +839,4 @@\n+      assert(_free_sets.membership(idx) == Mutator, \"Must be mutator free: \" SIZE_FORMAT, idx);\n+    } else {\n+      assert(_free_sets.membership(idx) == Collector || _free_sets.membership(idx) == OldCollector,\n+             \"Must be collector or old-collector free: \" SIZE_FORMAT, idx);\n@@ -200,9 +844,3 @@\n-\n-    size_t num = r->index();\n-    _collector_free_bitmap.clear_bit(num);\n-    _mutator_free_bitmap.clear_bit(num);\n-    \/\/ Touched the bounds? Need to update:\n-    if (touches_bounds(num)) {\n-      adjust_bounds();\n-    }\n-    assert_bounds();\n+    \/\/ This region is no longer considered free (in any set)\n+    _free_sets.remove_from_free_sets(idx);\n+    _free_sets.assert_bounds();\n@@ -213,32 +851,0 @@\n-bool ShenandoahFreeSet::touches_bounds(size_t num) const {\n-  return num == _collector_leftmost || num == _collector_rightmost || num == _mutator_leftmost || num == _mutator_rightmost;\n-}\n-\n-void ShenandoahFreeSet::recompute_bounds() {\n-  \/\/ Reset to the most pessimistic case:\n-  _mutator_rightmost = _max - 1;\n-  _mutator_leftmost = 0;\n-  _collector_rightmost = _max - 1;\n-  _collector_leftmost = 0;\n-\n-  \/\/ ...and adjust from there\n-  adjust_bounds();\n-}\n-\n-void ShenandoahFreeSet::adjust_bounds() {\n-  \/\/ Rewind both mutator bounds until the next bit.\n-  while (_mutator_leftmost < _max && !is_mutator_free(_mutator_leftmost)) {\n-    _mutator_leftmost++;\n-  }\n-  while (_mutator_rightmost > 0 && !is_mutator_free(_mutator_rightmost)) {\n-    _mutator_rightmost--;\n-  }\n-  \/\/ Rewind both collector bounds until the next bit.\n-  while (_collector_leftmost < _max && !is_collector_free(_collector_leftmost)) {\n-    _collector_leftmost++;\n-  }\n-  while (_collector_rightmost > 0 && !is_collector_free(_collector_rightmost)) {\n-    _collector_rightmost--;\n-  }\n-}\n-\n@@ -251,3 +857,13 @@\n-  \/\/ No regions left to satisfy allocation, bye.\n-  if (num > mutator_count()) {\n-    return nullptr;\n+  assert(req.is_young(), \"Humongous regions always allocated in YOUNG\");\n+  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n+\n+  \/\/ Check if there are enough regions left to satisfy allocation.\n+  if (_heap->mode()->is_generational()) {\n+    size_t avail_young_regions = generation->free_unaffiliated_regions();\n+    if (num > _free_sets.count(Mutator) || (num > avail_young_regions)) {\n+      return nullptr;\n+    }\n+  } else {\n+    if (num > _free_sets.count(Mutator)) {\n+      return nullptr;\n+    }\n@@ -259,1 +875,1 @@\n-  size_t beg = _mutator_leftmost;\n+  size_t beg = _free_sets.leftmost(Mutator);\n@@ -263,1 +879,1 @@\n-    if (end >= _max) {\n+    if (end >= _free_sets.max()) {\n@@ -270,1 +886,1 @@\n-    if (!is_mutator_free(end) || !can_allocate_from(_heap->get_region(end))) {\n+    if (!_free_sets.in_free_set(end, Mutator) || !can_allocate_from(_heap->get_region(end))) {\n@@ -285,0 +901,1 @@\n+  ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n@@ -308,0 +925,2 @@\n+    r->set_affiliation(req.affiliation());\n+    r->set_update_watermark(r->bottom());\n@@ -310,1 +929,2 @@\n-    _mutator_free_bitmap.clear_bit(r->index());\n+    \/\/ While individual regions report their true use, all humongous regions are marked used in the free set.\n+    _free_sets.remove_from_free_sets(r->index());\n@@ -312,0 +932,1 @@\n+  _heap->young_generation()->increase_affiliated_region_count(num);\n@@ -313,4 +934,4 @@\n-  \/\/ While individual regions report their true use, all humongous regions are\n-  \/\/ marked used in the free set.\n-  increase_used(ShenandoahHeapRegion::region_size_bytes() * num);\n-\n+  size_t total_humongous_size = ShenandoahHeapRegion::region_size_bytes() * num;\n+  _free_sets.increase_used(Mutator, total_humongous_size);\n+  _free_sets.assert_bounds();\n+  req.set_actual_size(words_size);\n@@ -318,7 +939,1 @@\n-    \/\/ Record this remainder as allocation waste\n-    _heap->notify_mutator_alloc_words(ShenandoahHeapRegion::region_size_words() - remainder, true);\n-  }\n-\n-  \/\/ Allocated at left\/rightmost? Move the bounds appropriately.\n-  if (beg == _mutator_leftmost || end == _mutator_rightmost) {\n-    adjust_bounds();\n+    req.set_waste(ShenandoahHeapRegion::region_size_words() - remainder);\n@@ -326,3 +941,0 @@\n-  assert_bounds();\n-\n-  req.set_actual_size(words_size);\n@@ -332,1 +944,4 @@\n-bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {\n+\/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n+\/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n+\/\/ concurrent weak root processing is in progress.\n+bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) const {\n@@ -336,1 +951,11 @@\n-size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {\n+bool ShenandoahFreeSet::can_allocate_from(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return can_allocate_from(r);\n+}\n+\n+size_t ShenandoahFreeSet::alloc_capacity(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return alloc_capacity(r);\n+}\n+\n+size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) const {\n@@ -345,1 +970,10 @@\n-bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) {\n+bool ShenandoahFreeSet::has_alloc_capacity(ShenandoahHeapRegion *r) const {\n+  return alloc_capacity(r) > 0;\n+}\n+\n+bool ShenandoahFreeSet::has_alloc_capacity(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return alloc_capacity(r) > 0;\n+}\n+\n+bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) const {\n@@ -351,1 +985,0 @@\n-    _heap->decrease_used(r->used());\n@@ -370,1 +1003,1 @@\n-void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {\n+void ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n@@ -373,1 +1006,2 @@\n-  assert(_mutator_free_bitmap.at(idx), \"Should be in mutator view\");\n+  assert(_free_sets.in_free_set(idx, Mutator), \"Should be in mutator view\");\n+  \/\/ Note: can_allocate_from(r) means r is entirely empty\n@@ -376,4 +1010,8 @@\n-  _mutator_free_bitmap.clear_bit(idx);\n-  _collector_free_bitmap.set_bit(idx);\n-  _collector_leftmost = MIN2(idx, _collector_leftmost);\n-  _collector_rightmost = MAX2(idx, _collector_rightmost);\n+  size_t region_capacity = alloc_capacity(r);\n+  _free_sets.move_to_set(idx, OldCollector, region_capacity);\n+  _free_sets.assert_bounds();\n+  _heap->generation_sizer()->force_transfer_to_old(1);\n+  _heap->augment_old_evac_reserve(region_capacity);\n+  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n+  \/\/ to recycle trash before attempting to allocate anything in the region.\n+}\n@@ -381,1 +1019,2 @@\n-  _capacity -= alloc_capacity(r);\n+void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {\n+  size_t idx = r->index();\n@@ -383,4 +1022,9 @@\n-  if (touches_bounds(idx)) {\n-    adjust_bounds();\n-  }\n-  assert_bounds();\n+  assert(_free_sets.in_free_set(idx, Mutator), \"Should be in mutator view\");\n+  assert(can_allocate_from(r), \"Should not be allocated\");\n+\n+  size_t region_capacity = alloc_capacity(r);\n+  _free_sets.move_to_set(idx, Collector, region_capacity);\n+  _free_sets.assert_bounds();\n+\n+  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n+  \/\/ to recycle trash before attempting to allocate anything in the region.\n@@ -395,8 +1039,1 @@\n-  _mutator_free_bitmap.clear();\n-  _collector_free_bitmap.clear();\n-  _mutator_leftmost = _max;\n-  _mutator_rightmost = 0;\n-  _collector_leftmost = _max;\n-  _collector_rightmost = 0;\n-  _capacity = 0;\n-  _used = 0;\n+  _free_sets.clear_all();\n@@ -405,3 +1042,6 @@\n-void ShenandoahFreeSet::rebuild() {\n-  shenandoah_assert_heaplocked();\n-  clear();\n+\/\/ This function places all is_old() regions that have allocation capacity into the old_collector set.  It places\n+\/\/ all other regions (not is_old()) that have allocation capacity into the mutator_set.  Subsequently, we will\n+\/\/ move some of the mutator regions into the collector set or old_collector set with the intent of packing\n+\/\/ old_collector memory into the highest (rightmost) addresses of the heap and the collector memory into the\n+\/\/ next highest addresses of the heap, with mutator memory consuming the lowest addresses of the heap.\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions) {\n@@ -409,0 +1049,2 @@\n+  old_cset_regions = 0;\n+  young_cset_regions = 0;\n@@ -411,0 +1053,9 @@\n+    if (region->is_trash()) {\n+      \/\/ Trashed regions represent regions that had been in the collection set but have not yet been \"cleaned up\".\n+      if (region->is_old()) {\n+        old_cset_regions++;\n+      } else {\n+        assert(region->is_young(), \"Trashed region should be old or young\");\n+        young_cset_regions++;\n+      }\n+    }\n@@ -412,1 +1063,22 @@\n-      assert(!region->is_cset(), \"Shouldn't be adding those to the free set\");\n+      assert(!region->is_cset(), \"Shouldn't be adding cset regions to the free set\");\n+      assert(_free_sets.in_free_set(idx, NotFree), \"We are about to make region free; it should not be free already\");\n+\n+      \/\/ Do not add regions that would almost surely fail allocation\n+      if (alloc_capacity(region) < PLAB::min_size() * HeapWordSize) continue;\n+\n+      if (region->is_old()) {\n+        _free_sets.make_free(idx, OldCollector, alloc_capacity(region));\n+        log_debug(gc, free)(\n+          \"  Adding Region \" SIZE_FORMAT  \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to old collector set\",\n+          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n+          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n+      } else {\n+        _free_sets.make_free(idx, Mutator, alloc_capacity(region));\n+        log_debug(gc, free)(\n+          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator set\",\n+          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n+          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n+      }\n+    }\n+  }\n+}\n@@ -414,2 +1086,20 @@\n-      \/\/ Do not add regions that would surely fail allocation\n-      if (has_no_alloc_capacity(region)) continue;\n+\/\/ Move no more than cset_regions from the existing Collector and OldCollector free sets to the Mutator free set.\n+\/\/ This is called from outside the heap lock.\n+void ShenandoahFreeSet::move_collector_sets_to_mutator(size_t max_xfer_regions) {\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t collector_empty_xfer = 0;\n+  size_t collector_not_empty_xfer = 0;\n+  size_t old_collector_empty_xfer = 0;\n+\n+  \/\/ Process empty regions within the Collector free set\n+  if ((max_xfer_regions > 0) && (_free_sets.leftmost_empty(Collector) <= _free_sets.rightmost_empty(Collector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    for (size_t idx = _free_sets.leftmost_empty(Collector);\n+         (max_xfer_regions > 0) && (idx <= _free_sets.rightmost_empty(Collector)); idx++) {\n+      if (_free_sets.in_free_set(idx, Collector) && can_allocate_from(idx)) {\n+        _free_sets.move_to_set(idx, Mutator, region_size_bytes);\n+        max_xfer_regions--;\n+        collector_empty_xfer += region_size_bytes;\n+      }\n+    }\n+  }\n@@ -417,2 +1107,17 @@\n-      _capacity += alloc_capacity(region);\n-      assert(_used <= _capacity, \"must not use more than we have\");\n+  \/\/ Process empty regions within the OldCollector free set\n+  size_t old_collector_regions = 0;\n+  if ((max_xfer_regions > 0) && (_free_sets.leftmost_empty(OldCollector) <= _free_sets.rightmost_empty(OldCollector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    for (size_t idx = _free_sets.leftmost_empty(OldCollector);\n+         (max_xfer_regions > 0) && (idx <= _free_sets.rightmost_empty(OldCollector)); idx++) {\n+      if (_free_sets.in_free_set(idx, OldCollector) && can_allocate_from(idx)) {\n+        _free_sets.move_to_set(idx, Mutator, region_size_bytes);\n+        max_xfer_regions--;\n+        old_collector_empty_xfer += region_size_bytes;\n+        old_collector_regions++;\n+      }\n+    }\n+    if (old_collector_regions > 0) {\n+      _heap->generation_sizer()->transfer_to_young(old_collector_regions);\n+    }\n+  }\n@@ -420,2 +1125,10 @@\n-      assert(!is_mutator_free(idx), \"We are about to add it, it shouldn't be there already\");\n-      _mutator_free_bitmap.set_bit(idx);\n+  \/\/ If there are any non-empty regions within Collector set, we can also move them to the Mutator free set\n+  if ((max_xfer_regions > 0) && (_free_sets.leftmost(Collector) <= _free_sets.rightmost(Collector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    for (size_t idx = _free_sets.leftmost(Collector); (max_xfer_regions > 0) && (idx <= _free_sets.rightmost(Collector)); idx++) {\n+      size_t alloc_capacity = this->alloc_capacity(idx);\n+      if (_free_sets.in_free_set(idx, Collector) && (alloc_capacity > 0)) {\n+        _free_sets.move_to_set(idx, Mutator, alloc_capacity);\n+        max_xfer_regions--;\n+        collector_not_empty_xfer += alloc_capacity;\n+      }\n@@ -425,3 +1138,8 @@\n-  \/\/ Evac reserve: reserve trailing space for evacuations\n-  size_t to_reserve = _heap->max_capacity() \/ 100 * ShenandoahEvacReserve;\n-  size_t reserved = 0;\n+  size_t collector_xfer = collector_empty_xfer + collector_not_empty_xfer;\n+  size_t total_xfer = collector_xfer + old_collector_empty_xfer;\n+  log_info(gc, free)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free set from Collector Reserve (\"\n+                     SIZE_FORMAT \"%s) and from Old Collector Reserve (\" SIZE_FORMAT \"%s)\",\n+                     byte_size_in_proper_unit(total_xfer), proper_unit_for_byte_size(total_xfer),\n+                     byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer),\n+                     byte_size_in_proper_unit(old_collector_empty_xfer), proper_unit_for_byte_size(old_collector_empty_xfer));\n+}\n@@ -429,2 +1147,0 @@\n-  for (size_t idx = _heap->num_regions() - 1; idx > 0; idx--) {\n-    if (reserved >= to_reserve) break;\n@@ -432,7 +1148,87 @@\n-    ShenandoahHeapRegion* region = _heap->get_region(idx);\n-    if (_mutator_free_bitmap.at(idx) && can_allocate_from(region)) {\n-      _mutator_free_bitmap.clear_bit(idx);\n-      _collector_free_bitmap.set_bit(idx);\n-      size_t ac = alloc_capacity(region);\n-      _capacity -= ac;\n-      reserved += ac;\n+\/\/ Overwrite arguments to represent the amount of memory in each generation that is about to be recycled\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions) {\n+  shenandoah_assert_heaplocked();\n+  \/\/ This resets all state information, removing all regions from all sets.\n+  clear();\n+  log_debug(gc, free)(\"Rebuilding FreeSet\");\n+\n+  \/\/ This places regions that have alloc_capacity into the old_collector set if they identify as is_old() or the\n+  \/\/ mutator set otherwise.\n+  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions);\n+}\n+\n+void ShenandoahFreeSet::rebuild(size_t young_cset_regions, size_t old_cset_regions) {\n+  shenandoah_assert_heaplocked();\n+  size_t young_reserve, old_reserve;\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  size_t old_capacity = _heap->old_generation()->max_capacity();\n+  size_t old_available = _heap->old_generation()->available();\n+  size_t old_unaffiliated_regions = _heap->old_generation()->free_unaffiliated_regions();\n+  size_t young_capacity = _heap->young_generation()->max_capacity();\n+  size_t young_available = _heap->young_generation()->available();\n+  size_t young_unaffiliated_regions = _heap->young_generation()->free_unaffiliated_regions();\n+\n+  old_unaffiliated_regions += old_cset_regions;\n+  old_available += old_cset_regions * region_size_bytes;\n+  young_unaffiliated_regions += young_cset_regions;\n+  young_available += young_cset_regions * region_size_bytes;\n+\n+  \/\/ Consult old-region surplus and deficit to make adjustments to current generation capacities and availability.\n+  \/\/ The generation region transfers take place after we rebuild.\n+  size_t old_region_surplus = _heap->get_old_region_surplus();\n+  size_t old_region_deficit = _heap->get_old_region_deficit();\n+\n+  if (old_region_surplus > 0) {\n+    size_t xfer_bytes = old_region_surplus * region_size_bytes;\n+    assert(old_region_surplus <= old_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n+    old_capacity -= xfer_bytes;\n+    old_available -= xfer_bytes;\n+    old_unaffiliated_regions -= old_region_surplus;\n+    young_capacity += xfer_bytes;\n+    young_available += xfer_bytes;\n+    young_unaffiliated_regions += old_region_surplus;\n+  } else if (old_region_deficit > 0) {\n+    size_t xfer_bytes = old_region_deficit * region_size_bytes;\n+    assert(old_region_deficit <= young_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n+    old_capacity += xfer_bytes;\n+    old_available += xfer_bytes;\n+    old_unaffiliated_regions += old_region_deficit;\n+    young_capacity -= xfer_bytes;;\n+    young_available -= xfer_bytes;\n+    young_unaffiliated_regions -= old_region_deficit;\n+  }\n+\n+  \/\/ Evac reserve: reserve trailing space for evacuations, with regions reserved for old evacuations placed to the right\n+  \/\/ of regions reserved of young evacuations.\n+  if (!_heap->mode()->is_generational()) {\n+    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n+    old_reserve = 0;\n+  } else {\n+    \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n+    \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+    \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons for\n+    \/\/ each PLAB's available memory.\n+    if (_heap->has_evacuation_reserve_quantities()) {\n+      \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n+      young_reserve = _heap->get_young_evac_reserve();\n+      old_reserve = _heap->get_promoted_reserve() + _heap->get_old_evac_reserve();\n+      assert(old_reserve <= old_available,\n+             \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n+             _heap->get_promoted_reserve(), _heap->get_old_evac_reserve(), old_available);\n+    } else {\n+      \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n+      young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n+      \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n+      \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n+      \/\/ unaffiliated regions.\n+      old_reserve = old_available;\n+    }\n+  }\n+  if (old_reserve > _free_sets.capacity_of(OldCollector)) {\n+    \/\/ Old available regions that have less than PLAB::min_size() of available memory are not placed into the OldCollector\n+    \/\/ free set.  Because of this, old_available may not have enough memory to represent the intended reserve.  Adjust\n+    \/\/ the reserve downward to account for this possibility. This loss is part of the reason why the original budget\n+    \/\/ was adjusted with ShenandoahOldEvacWaste and ShenandoahOldPromoWaste multipliers.\n+    if (old_reserve > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+      old_reserve = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n@@ -441,0 +1237,3 @@\n+  if (young_reserve > young_unaffiliated_regions * region_size_bytes) {\n+    young_reserve = young_unaffiliated_regions * region_size_bytes;\n+  }\n@@ -442,2 +1241,37 @@\n-  recompute_bounds();\n-  assert_bounds();\n+  reserve_regions(young_reserve, old_reserve);\n+  _free_sets.establish_alloc_bias(OldCollector);\n+  _free_sets.assert_bounds();\n+  log_status();\n+}\n+\n+\/\/ Having placed all regions that have allocation capacity into the mutator set if they identify as is_young()\n+\/\/ or into the old collector set if they identify as is_old(), move some of these regions from the mutator set\n+\/\/ into the collector set or old collector set in order to assure that the memory available for allocations within\n+\/\/ the collector set is at least to_reserve, and the memory available for allocations within the old collector set\n+\/\/ is at least to_reserve_old.\n+void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old) {\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    size_t idx = i - 1;\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (_free_sets.in_free_set(idx, Mutator)) {\n+      assert (!r->is_old(), \"mutator_is_free regions should not be affiliated OLD\");\n+      size_t ac = alloc_capacity(r);\n+      assert (ac > 0, \"Membership in free set implies has capacity\");\n+\n+      \/\/ OLD regions that have available memory are already in the old_collector free set\n+      if ((_free_sets.capacity_of(OldCollector) < to_reserve_old) && (r->is_trash() || !r->is_affiliated())) {\n+        _free_sets.move_to_set(idx, OldCollector, alloc_capacity(r));\n+        log_debug(gc, free)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to old_collector_free\", idx);\n+      } else if (_free_sets.capacity_of(Collector) < to_reserve) {\n+        \/\/ Note: In a previous implementation, regions were only placed into the survivor space (collector_is_free) if\n+        \/\/ they were entirely empty.  I'm not sure I understand the rational for that.  That alternative behavior would\n+        \/\/ tend to mix survivor objects with ephemeral objects, making it more difficult to reclaim the memory for the\n+        \/\/ ephemeral objects.  It also delays aging of regions, causing promotion in place to be delayed.\n+        _free_sets.move_to_set(idx, Collector, ac);\n+        log_debug(gc)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to collector_free\", idx);\n+      } else {\n+        \/\/ We've satisfied both to_reserve and to_reserved_old\n+        break;\n+      }\n+    }\n+  }\n@@ -449,1 +1283,91 @@\n-  LogTarget(Info, gc, ergo) lt;\n+#ifdef ASSERT\n+  \/\/ Dump of the FreeSet details is only enabled if assertions are enabled\n+  {\n+#define BUFFER_SIZE 80\n+    size_t retired_old = 0;\n+    size_t retired_old_humongous = 0;\n+    size_t retired_young = 0;\n+    size_t retired_young_humongous = 0;\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t retired_young_waste = 0;\n+    size_t retired_old_waste = 0;\n+    size_t consumed_collector = 0;\n+    size_t consumed_old_collector = 0;\n+    size_t consumed_mutator = 0;\n+    size_t available_old = 0;\n+    size_t available_young = 0;\n+    size_t available_mutator = 0;\n+    size_t available_collector = 0;\n+    size_t available_old_collector = 0;\n+\n+    char buffer[BUFFER_SIZE];\n+    for (uint i = 0; i < BUFFER_SIZE; i++) {\n+      buffer[i] = '\\0';\n+    }\n+    log_info(gc, free)(\"FreeSet map legend:\"\n+                       \" M:mutator_free C:collector_free O:old_collector_free\"\n+                       \" H:humongous ~:retired old _:retired young\");\n+    log_info(gc, free)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n+                       \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"], \"\n+                       \"old collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"] allocates from %s\",\n+                       _free_sets.leftmost(Mutator), _free_sets.rightmost(Mutator),\n+                       _free_sets.leftmost(Collector), _free_sets.rightmost(Collector),\n+                       _free_sets.leftmost(OldCollector), _free_sets.rightmost(OldCollector),\n+                       _free_sets.alloc_from_left_bias(OldCollector)? \"left to right\": \"right to left\");\n+\n+    for (uint i = 0; i < _heap->num_regions(); i++) {\n+      ShenandoahHeapRegion *r = _heap->get_region(i);\n+      uint idx = i % 64;\n+      if ((i != 0) && (idx == 0)) {\n+        log_info(gc, free)(\" %6u: %s\", i-64, buffer);\n+      }\n+      if (_free_sets.in_free_set(i, Mutator)) {\n+        assert(!r->is_old(), \"Old regions should not be in mutator_free set\");\n+        size_t capacity = alloc_capacity(r);\n+        available_mutator += capacity;\n+        consumed_mutator += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'M': 'm';\n+      } else if (_free_sets.in_free_set(i, Collector)) {\n+        assert(!r->is_old(), \"Old regions should not be in collector_free set\");\n+        size_t capacity = alloc_capacity(r);\n+        available_collector += capacity;\n+        consumed_collector += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'C': 'c';\n+      } else if (_free_sets.in_free_set(i, OldCollector)) {\n+        size_t capacity = alloc_capacity(r);\n+        available_old_collector += capacity;\n+        consumed_old_collector += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'O': 'o';\n+      } else if (r->is_humongous()) {\n+        if (r->is_old()) {\n+          buffer[idx] = 'H';\n+          retired_old_humongous += region_size_bytes;\n+        } else {\n+          buffer[idx] = 'h';\n+          retired_young_humongous += region_size_bytes;\n+        }\n+      } else {\n+        if (r->is_old()) {\n+          buffer[idx] = '~';\n+          retired_old_waste += alloc_capacity(r);\n+          retired_old += region_size_bytes;\n+        } else {\n+          buffer[idx] = '_';\n+          retired_young_waste += alloc_capacity(r);\n+          retired_young += region_size_bytes;\n+        }\n+      }\n+    }\n+    uint remnant = _heap->num_regions() % 64;\n+    if (remnant > 0) {\n+      buffer[remnant] = '\\0';\n+    } else {\n+      remnant = 64;\n+    }\n+    log_info(gc, free)(\" %6u: %s\", (uint) (_heap->num_regions() - remnant), buffer);\n+    size_t total_young = retired_young + retired_young_humongous;\n+    size_t total_old = retired_old + retired_old_humongous;\n+  }\n+#endif\n+\n+  LogTarget(Info, gc, free) lt;\n@@ -464,2 +1388,2 @@\n-      for (size_t idx = _mutator_leftmost; idx <= _mutator_rightmost; idx++) {\n-        if (is_mutator_free(idx)) {\n+      for (size_t idx = _free_sets.leftmost(Mutator); idx <= _free_sets.rightmost(Mutator); idx++) {\n+        if (_free_sets.in_free_set(idx, Mutator)) {\n@@ -468,1 +1392,0 @@\n-\n@@ -470,1 +1393,0 @@\n-\n@@ -481,1 +1403,0 @@\n-\n@@ -484,1 +1405,0 @@\n-\n@@ -493,0 +1413,4 @@\n+      assert(free == total_free, \"Sum of free within mutator regions (\" SIZE_FORMAT\n+             \") should match mutator capacity (\" SIZE_FORMAT \") minus mutator used (\" SIZE_FORMAT \")\",\n+             total_free, capacity(), used());\n+\n@@ -509,2 +1433,2 @@\n-      if (mutator_count() > 0) {\n-        frag_int = (100 * (total_used \/ mutator_count()) \/ ShenandoahHeapRegion::region_size_bytes());\n+      if (_free_sets.count(Mutator) > 0) {\n+        frag_int = (100 * (total_used \/ _free_sets.count(Mutator)) \/ ShenandoahHeapRegion::region_size_bytes());\n@@ -515,0 +1439,2 @@\n+      ls.print(\"Used: \" SIZE_FORMAT \"%s, Mutator Free: \" SIZE_FORMAT,\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), _free_sets.count(Mutator));\n@@ -520,0 +1446,1 @@\n+      size_t total_used = 0;\n@@ -521,2 +1448,2 @@\n-      for (size_t idx = _collector_leftmost; idx <= _collector_rightmost; idx++) {\n-        if (is_collector_free(idx)) {\n+      for (size_t idx = _free_sets.leftmost(Collector); idx <= _free_sets.rightmost(Collector); idx++) {\n+        if (_free_sets.in_free_set(idx, Collector)) {\n@@ -527,0 +1454,1 @@\n+          total_used += r->used();\n@@ -529,0 +1457,5 @@\n+      ls.print(\" Collector Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s; Used: \" SIZE_FORMAT \"%s\",\n+               byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n+               byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+    }\n@@ -530,1 +1463,15 @@\n-      ls.print_cr(\"Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s\",\n+    if (_heap->mode()->is_generational()) {\n+      size_t max = 0;\n+      size_t total_free = 0;\n+      size_t total_used = 0;\n+\n+      for (size_t idx = _free_sets.leftmost(OldCollector); idx <= _free_sets.rightmost(OldCollector); idx++) {\n+        if (_free_sets.in_free_set(idx, OldCollector)) {\n+          ShenandoahHeapRegion *r = _heap->get_region(idx);\n+          size_t free = alloc_capacity(r);\n+          max = MAX2(max, free);\n+          total_free += free;\n+          total_used += r->used();\n+        }\n+      }\n+      ls.print_cr(\" Old Collector Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s; Used: \" SIZE_FORMAT \"%s\",\n@@ -532,1 +1479,2 @@\n-                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));\n+                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n+                  byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n@@ -539,1 +1487,0 @@\n-  assert_bounds();\n@@ -541,0 +1488,1 @@\n+  \/\/ Allocation request is known to satisfy all memory budgeting constraints.\n@@ -547,0 +1495,1 @@\n+      case ShenandoahAllocRequest::_alloc_plab:\n@@ -565,2 +1514,2 @@\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (index < _max && is_mutator_free(index)) {\n+  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n+    if (index < _free_sets.max() && _free_sets.in_free_set(index, Mutator)) {\n@@ -579,3 +1528,3 @@\n-  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", mutator_count());\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n+  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Mutator));\n+  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n+    if (_free_sets.in_free_set(index, Mutator)) {\n@@ -585,3 +1534,3 @@\n-  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", collector_count());\n-  for (size_t index = _collector_leftmost; index <= _collector_rightmost; index++) {\n-    if (is_collector_free(index)) {\n+  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _free_sets.count(Collector));\n+  for (size_t index = _free_sets.leftmost(Collector); index <= _free_sets.rightmost(Collector); index++) {\n+    if (_free_sets.in_free_set(index, Collector)) {\n@@ -591,0 +1540,8 @@\n+  if (_heap->mode()->is_generational()) {\n+    out->print_cr(\"Old Collector Free Set: \" SIZE_FORMAT \"\", _free_sets.count(OldCollector));\n+    for (size_t index = _free_sets.leftmost(OldCollector); index <= _free_sets.rightmost(OldCollector); index++) {\n+      if (_free_sets.in_free_set(index, OldCollector)) {\n+        _heap->get_region(index)->print_on(out);\n+      }\n+    }\n+  }\n@@ -619,2 +1576,2 @@\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n+  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n+    if (_free_sets.in_free_set(index, Mutator)) {\n@@ -657,2 +1614,2 @@\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n+  for (size_t index = _free_sets.leftmost(Mutator); index <= _free_sets.rightmost(Mutator); index++) {\n+    if (_free_sets.in_free_set(index, Mutator)) {\n@@ -683,27 +1640,0 @@\n-#ifdef ASSERT\n-void ShenandoahFreeSet::assert_bounds() const {\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance\n-  \/\/ would suffer.\n-  assert (_mutator_leftmost <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, _mutator_leftmost,  _max);\n-  assert (_mutator_rightmost < _max, \"rightmost in bounds: \" SIZE_FORMAT \" < \" SIZE_FORMAT, _mutator_rightmost, _max);\n-\n-  assert (_mutator_leftmost == _max || is_mutator_free(_mutator_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _mutator_leftmost);\n-  assert (_mutator_rightmost == 0   || is_mutator_free(_mutator_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _mutator_rightmost);\n-\n-  size_t beg_off = _mutator_free_bitmap.find_first_set_bit(0);\n-  size_t end_off = _mutator_free_bitmap.find_first_set_bit(_mutator_rightmost + 1);\n-  assert (beg_off >= _mutator_leftmost, \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, _mutator_leftmost);\n-  assert (end_off == _max,      \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, _mutator_rightmost);\n-\n-  assert (_collector_leftmost <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, _collector_leftmost,  _max);\n-  assert (_collector_rightmost < _max, \"rightmost in bounds: \" SIZE_FORMAT \" < \" SIZE_FORMAT, _collector_rightmost, _max);\n-\n-  assert (_collector_leftmost == _max || is_collector_free(_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _collector_leftmost);\n-  assert (_collector_rightmost == 0   || is_collector_free(_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _collector_rightmost);\n-\n-  beg_off = _collector_free_bitmap.find_first_set_bit(0);\n-  end_off = _collector_free_bitmap.find_first_set_bit(_collector_rightmost + 1);\n-  assert (beg_off >= _collector_leftmost, \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, _collector_leftmost);\n-  assert (end_off == _max,      \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, _collector_rightmost);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1160,"deletions":230,"binary":false,"changes":1390,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,114 @@\n+enum ShenandoahFreeMemoryType : uint8_t {\n+  NotFree,\n+  Mutator,\n+  Collector,\n+  OldCollector,\n+  NumFreeSets\n+};\n+\n+class ShenandoahSetsOfFree {\n+\n+private:\n+  size_t _max;                  \/\/ The maximum number of heap regions\n+  ShenandoahFreeSet* _free_set;\n+  size_t _region_size_bytes;\n+  ShenandoahFreeMemoryType* _membership;\n+  size_t _leftmosts[NumFreeSets];\n+  size_t _rightmosts[NumFreeSets];\n+  size_t _leftmosts_empty[NumFreeSets];\n+  size_t _rightmosts_empty[NumFreeSets];\n+  size_t _capacity_of[NumFreeSets];\n+  size_t _used_by[NumFreeSets];\n+  bool _left_to_right_bias[NumFreeSets];\n+  size_t _region_counts[NumFreeSets];\n+\n+  inline void shrink_bounds_if_touched(ShenandoahFreeMemoryType set, size_t idx);\n+  inline void expand_bounds_maybe(ShenandoahFreeMemoryType set, size_t idx, size_t capacity);\n+\n+  \/\/ Restore all state variables to initial default state.\n+  void clear_internal();\n+\n+public:\n+  ShenandoahSetsOfFree(size_t max_regions, ShenandoahFreeSet* free_set);\n+  ~ShenandoahSetsOfFree();\n+\n+  \/\/ Make all regions NotFree and reset all bounds\n+  void clear_all();\n+\n+  \/\/ Remove or retire region idx from all free sets.  Requires that idx is in a free set.  This does not affect capacity.\n+  void remove_from_free_sets(size_t idx);\n+\n+  \/\/ Place region idx into free set which_set.  Requires that idx is currently NotFree.\n+  void make_free(size_t idx, ShenandoahFreeMemoryType which_set, size_t region_capacity);\n+\n+  \/\/ Place region idx into free set new_set.  Requires that idx is currently not NotFree.\n+  void move_to_set(size_t idx, ShenandoahFreeMemoryType new_set, size_t region_capacity);\n+\n+  \/\/ Returns the ShenandoahFreeMemoryType affiliation of region idx, or NotFree if this region is not currently free.  This does\n+  \/\/ not enforce that free_set membership implies allocation capacity.\n+  inline ShenandoahFreeMemoryType membership(size_t idx) const;\n+\n+  \/\/ Returns true iff region idx is in the test_set free_set.  Before returning true, asserts that the free\n+  \/\/ set is not empty.  Requires that test_set != NotFree or NumFreeSets.\n+  inline bool in_free_set(size_t idx, ShenandoahFreeMemoryType which_set) const;\n+\n+  \/\/ The following four methods return the left-most and right-most bounds on ranges of regions representing\n+  \/\/ the requested set.  The _empty variants represent bounds on the range that holds completely empty\n+  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.  A\n+  \/\/ return value of -1 from leftmost() or leftmost_empty() denotes that the corresponding set is empty.\n+  \/\/ In other words:\n+  \/\/   if the requested which_set is empty:\n+  \/\/     leftmost() and leftmost_empty() return _max, rightmost() and rightmost_empty() return 0\n+  \/\/   otherwise, expect the following:\n+  \/\/     0 <= leftmost <= leftmost_empty <= rightmost_empty <= rightmost < _max\n+  inline size_t leftmost(ShenandoahFreeMemoryType which_set) const;\n+  inline size_t rightmost(ShenandoahFreeMemoryType which_set) const;\n+  size_t leftmost_empty(ShenandoahFreeMemoryType which_set);\n+  size_t rightmost_empty(ShenandoahFreeMemoryType which_set);\n+\n+  inline void increase_used(ShenandoahFreeMemoryType which_set, size_t bytes);\n+\n+  inline size_t capacity_of(ShenandoahFreeMemoryType which_set) const {\n+    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+    return _capacity_of[which_set];\n+  }\n+\n+  inline size_t used_by(ShenandoahFreeMemoryType which_set) const {\n+    assert (which_set > NotFree && which_set < NumFreeSets, \"selected free set must be valid\");\n+    return _used_by[which_set];\n+  }\n+\n+  inline size_t max() const { return _max; }\n+\n+  inline size_t count(ShenandoahFreeMemoryType which_set) const { return _region_counts[which_set]; }\n+\n+  \/\/ Return true iff regions for allocation from this set should be peformed left to right.  Otherwise, allocate\n+  \/\/ from right to left.\n+  inline bool alloc_from_left_bias(ShenandoahFreeMemoryType which_set);\n+\n+  \/\/ Determine whether we prefer to allocate from left to right or from right to left for this free-set.\n+  void establish_alloc_bias(ShenandoahFreeMemoryType which_set);\n+\n+  \/\/ Assure leftmost, rightmost, leftmost_empty, and rightmost_empty bounds are valid for all free sets.\n+  \/\/ Valid bounds honor all of the following (where max is the number of heap regions):\n+  \/\/   if the set is empty, leftmost equals max and rightmost equals 0\n+  \/\/   Otherwise (the set is not empty):\n+  \/\/     0 <= leftmost < max and 0 <= rightmost < max\n+  \/\/     the region at leftmost is in the set\n+  \/\/     the region at rightmost is in the set\n+  \/\/     rightmost >= leftmost\n+  \/\/     for every idx that is in the set {\n+  \/\/       idx >= leftmost &&\n+  \/\/       idx <= rightmost\n+  \/\/     }\n+  \/\/   if the set has no empty regions, leftmost_empty equals max and rightmost_empty equals 0\n+  \/\/   Otherwise (the region has empty regions):\n+  \/\/     0 <= lefmost_empty < max and 0 <= rightmost_empty < max\n+  \/\/     rightmost_empty >= leftmost_empty\n+  \/\/     for every idx that is in the set and is empty {\n+  \/\/       idx >= leftmost &&\n+  \/\/       idx <= rightmost\n+  \/\/     }\n+  void assert_bounds() NOT_DEBUG_RETURN;\n+};\n+\n@@ -34,3 +149,1 @@\n-  CHeapBitMap _mutator_free_bitmap;\n-  CHeapBitMap _collector_free_bitmap;\n-  size_t _max;\n+  ShenandoahSetsOfFree _free_sets;\n@@ -38,4 +151,1 @@\n-  \/\/ Left-most and right-most region indexes. There are no free regions outside\n-  \/\/ of [left-most; right-most] index intervals\n-  size_t _mutator_leftmost, _mutator_rightmost;\n-  size_t _collector_leftmost, _collector_rightmost;\n+  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -43,2 +153,1 @@\n-  size_t _capacity;\n-  size_t _used;\n+  HeapWord* allocate_aligned_plab(size_t size, ShenandoahAllocRequest& req, ShenandoahHeapRegion* r);\n@@ -46,1 +155,3 @@\n-  void assert_bounds() const NOT_DEBUG_RETURN;\n+  \/\/ Satisfy young-generation or single-generation collector allocation request req by finding memory that matches\n+  \/\/ affiliation, which either equals req.affiliation or FREE.  We know req.is_young().\n+  HeapWord* allocate_with_affiliation(ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -48,2 +159,3 @@\n-  bool is_mutator_free(size_t idx) const;\n-  bool is_collector_free(size_t idx) const;\n+  \/\/ Satisfy allocation request req by finding memory that matches affiliation, which either equals req.affiliation\n+  \/\/ or FREE. We know req.is_old().\n+  HeapWord* allocate_old_with_affiliation(ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -51,1 +163,6 @@\n-  HeapWord* try_allocate_in(ShenandoahHeapRegion* region, ShenandoahAllocRequest& req, bool& in_new_region);\n+  \/\/ While holding the heap lock, allocate memory for a single object which is to be entirely contained\n+  \/\/ within a single HeapRegion as characterized by req.  The req.size() value is known to be less than or\n+  \/\/ equal to ShenandoahHeapRegion::humongous_threshold_words().  The caller of allocate_single is responsible\n+  \/\/ for registering the resulting object and setting the remembered set card values as appropriate.  The\n+  \/\/ most common case is that we are allocating a PLAB in which case object registering and card dirtying\n+  \/\/ is managed after the PLAB is divided into individual objects.\n@@ -56,0 +173,3 @@\n+  void flip_to_old_gc(ShenandoahHeapRegion* r);\n+\n+  void adjust_bounds_for_additional_old_collector_free_region(size_t idx);\n@@ -61,0 +181,1 @@\n+  \/\/ Used of free set represents the amount of is_mutator_free set that has been consumed since most recent rebuild.\n@@ -64,3 +185,0 @@\n-  size_t collector_count() const { return _collector_free_bitmap.count_one_bits(); }\n-  size_t mutator_count()   const { return _mutator_free_bitmap.count_one_bits();   }\n-\n@@ -69,3 +187,5 @@\n-  bool can_allocate_from(ShenandoahHeapRegion *r);\n-  size_t alloc_capacity(ShenandoahHeapRegion *r);\n-  bool has_no_alloc_capacity(ShenandoahHeapRegion *r);\n+  bool can_allocate_from(ShenandoahHeapRegion *r) const;\n+  bool can_allocate_from(size_t idx) const;\n+  bool has_alloc_capacity(size_t idx) const;\n+  bool has_alloc_capacity(ShenandoahHeapRegion *r) const;\n+  bool has_no_alloc_capacity(ShenandoahHeapRegion *r) const;\n@@ -76,0 +196,3 @@\n+  size_t alloc_capacity(ShenandoahHeapRegion *r) const;\n+  size_t alloc_capacity(size_t idx) const;\n+\n@@ -77,1 +200,5 @@\n-  void rebuild();\n+  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void rebuild(size_t young_cset_regions, size_t old_cset_regions);\n+  void move_collector_sets_to_mutator(size_t cset_regions);\n+\n+  void add_old_collector_free_region(ShenandoahHeapRegion* region);\n@@ -83,5 +210,5 @@\n-  size_t capacity()  const { return _capacity; }\n-  size_t used()      const { return _used;     }\n-  size_t available() const {\n-    assert(_used <= _capacity, \"must use less than capacity\");\n-    return _capacity - _used;\n+  inline size_t capacity()  const { return _free_sets.capacity_of(Mutator); }\n+  inline size_t used()      const { return _free_sets.used_by(Mutator);     }\n+  inline size_t available() const {\n+    assert(used() <= capacity(), \"must use less than capacity\");\n+    return capacity() - used();\n@@ -97,0 +224,3 @@\n+\n+  void find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions);\n+  void reserve_regions(size_t young_reserve, size_t old_reserve);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":155,"deletions":25,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -38,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -46,0 +48,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -54,0 +57,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -65,0 +69,63 @@\n+\/\/ After Full GC is done, reconstruct the remembered set by iterating over OLD regions,\n+\/\/ registering all objects between bottom() and top(), and setting remembered set cards to\n+\/\/ DIRTY if they hold interesting pointers.\n+class ShenandoahReconstructRememberedSetTask : public WorkerTask {\n+private:\n+  ShenandoahRegionIterator _regions;\n+\n+public:\n+  ShenandoahReconstructRememberedSetTask() :\n+    WorkerTask(\"Shenandoah Reset Bitmap\") { }\n+\n+  void work(uint worker_id) {\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahHeapRegion* r = _regions.next();\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    RememberedScanner* scanner = heap->card_scan();\n+    ShenandoahSetRememberedCardsToDirtyClosure dirty_cards_for_interesting_pointers;\n+\n+    while (r != nullptr) {\n+      if (r->is_old() && r->is_active()) {\n+        HeapWord* obj_addr = r->bottom();\n+        if (r->is_humongous_start()) {\n+          \/\/ First, clear the remembered set\n+          oop obj = cast_to_oop(obj_addr);\n+          size_t size = obj->size();\n+\n+          \/\/ First, clear the remembered set for all spanned humongous regions\n+          size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+          size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n+          scanner->reset_remset(r->bottom(), region_span);\n+          size_t region_index = r->index();\n+          ShenandoahHeapRegion* humongous_region = heap->get_region(region_index);\n+          while (num_regions-- != 0) {\n+            scanner->reset_object_range(humongous_region->bottom(), humongous_region->end());\n+            region_index++;\n+            humongous_region = heap->get_region(region_index);\n+          }\n+\n+          \/\/ Then register the humongous object and DIRTY relevant remembered set cards\n+          scanner->register_object_without_lock(obj_addr);\n+          obj->oop_iterate(&dirty_cards_for_interesting_pointers);\n+        } else if (!r->is_humongous()) {\n+          \/\/ First, clear the remembered set\n+          scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n+          scanner->reset_object_range(r->bottom(), r->end());\n+\n+          \/\/ Then iterate over all objects, registering object and DIRTYing relevant remembered set cards\n+          HeapWord* t = r->top();\n+          while (obj_addr < t) {\n+            oop obj = cast_to_oop(obj_addr);\n+            size_t size = obj->size();\n+            scanner->register_object_without_lock(obj_addr);\n+            obj_addr += obj->oop_iterate_size(&dirty_cards_for_interesting_pointers);\n+          }\n+        } \/\/ else, ignore humongous continuation region\n+      }\n+      \/\/ else, this region is FREE or YOUNG or inactive and we can ignore it.\n+      \/\/ TODO: Assert this.\n+      r = _regions.next();\n+    }\n+  }\n+};\n+\n@@ -102,0 +169,1 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -109,0 +177,15 @@\n+  if (heap->mode()->is_generational()) {\n+    heap->mmu_tracker()->record_full(heap->global_generation(), GCId::current());\n+    heap->log_heap_status(\"At end of Full GC\");\n+\n+    \/\/ Since we allow temporary violation of these constraints during Full GC, we want to enforce that the assertions are\n+    \/\/ made valid by the time Full GC completes.\n+    assert(heap->old_generation()->used_regions_size() <= heap->old_generation()->max_capacity(),\n+           \"Old generation affiliated regions must be less than capacity\");\n+    assert(heap->young_generation()->used_regions_size() <= heap->young_generation()->max_capacity(),\n+           \"Young generation affiliated regions must be less than capacity\");\n+\n+    assert((heap->young_generation()->used() + heap->young_generation()->get_humongous_waste())\n+           <= heap->young_generation()->used_regions_size(), \"Young consumed can be no larger than span of affiliated regions\");\n+    assert((heap->old_generation()->used() + heap->old_generation()->get_humongous_waste())\n+           <= heap->old_generation()->used_regions_size(), \"Old consumed can be no larger than span of affiliated regions\");\n@@ -110,0 +193,1 @@\n+  }\n@@ -121,0 +205,13 @@\n+  \/\/ Since we may arrive here from degenerated GC failure of either young or old, establish generation as GLOBAL.\n+  heap->set_gc_generation(heap->global_generation());\n+\n+  if (heap->mode()->is_generational()) {\n+    \/\/ No need for old_gen->increase_used() as this was done when plabs were allocated.\n+    heap->set_young_evac_reserve(0);\n+    heap->set_old_evac_reserve(0);\n+    heap->reset_old_evac_expended();\n+    heap->set_promoted_reserve(0);\n+\n+    \/\/ Full GC supersedes any marking or coalescing in old generation.\n+    heap->cancel_old_gc();\n+  }\n@@ -164,1 +261,1 @@\n-    \/\/ b. Cancel concurrent mark, if in progress\n+    \/\/ b. Cancel all concurrent marks, if in progress\n@@ -166,2 +263,1 @@\n-      ShenandoahConcurrentGC::cancel();\n-      heap->set_concurrent_mark_in_progress(false);\n+      heap->cancel_concurrent_mark();\n@@ -177,1 +273,1 @@\n-    heap->reset_mark_bitmap();\n+    heap->global_generation()->reset_mark_bitmap();\n@@ -179,1 +275,1 @@\n-    assert(!heap->marking_context()->is_complete(), \"sanity\");\n+    assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n@@ -182,1 +278,1 @@\n-    ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -195,0 +291,1 @@\n+    \/\/ TODO: Do we need to explicitly retire PLABs?\n@@ -231,0 +328,2 @@\n+\n+    phase5_epilog();\n@@ -235,0 +334,1 @@\n+    \/\/ TODO: Merge with phase5_epilog?\n@@ -237,0 +337,6 @@\n+\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_reconstruct_remembered_set);\n+      ShenandoahReconstructRememberedSetTask task;\n+      heap->workers()->run_task(&task);\n+    }\n@@ -255,0 +361,1 @@\n+  \/\/ Humongous regions are promoted on demand and are accounted for by normal Full GC mechanisms.\n@@ -273,2 +380,4 @@\n-    _ctx->capture_top_at_mark_start(r);\n-    r->clear_live_data();\n+    if (r->affiliation() != FREE) {\n+      _ctx->capture_top_at_mark_start(r);\n+      r->clear_live_data();\n+    }\n@@ -276,0 +385,2 @@\n+\n+  bool is_thread_safe() { return true; }\n@@ -285,1 +396,1 @@\n-  heap->heap_region_iterate(&cl);\n+  heap->parallel_heap_region_iterate(&cl);\n@@ -287,1 +398,1 @@\n-  heap->set_unload_classes(heap->heuristics()->can_unload_classes());\n+  heap->set_unload_classes(heap->global_generation()->heuristics()->can_unload_classes());\n@@ -289,1 +400,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -293,1 +404,1 @@\n-  ShenandoahSTWMark mark(true \/*full_gc*\/);\n+  ShenandoahSTWMark mark(heap->global_generation(), true \/*full_gc*\/);\n@@ -298,0 +409,229 @@\n+class ShenandoahPrepareForCompactionTask : public WorkerTask {\n+private:\n+  PreservedMarksSet*        const _preserved_marks;\n+  ShenandoahHeap*           const _heap;\n+  ShenandoahHeapRegionSet** const _worker_slices;\n+  size_t                    const _num_workers;\n+\n+public:\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n+                                     ShenandoahHeapRegionSet **worker_slices,\n+                                     size_t num_workers);\n+\n+  static bool is_candidate_region(ShenandoahHeapRegion* r) {\n+    \/\/ Empty region: get it into the slice to defragment the slice itself.\n+    \/\/ We could have skipped this without violating correctness, but we really\n+    \/\/ want to compact all live regions to the start of the heap, which sometimes\n+    \/\/ means moving them into the fully empty regions.\n+    if (r->is_empty()) return true;\n+\n+    \/\/ Can move the region, and this is not the humongous region. Humongous\n+    \/\/ moves are special cased here, because their moves are handled separately.\n+    return r->is_stw_move_allowed() && !r->is_humongous();\n+  }\n+\n+  void work(uint worker_id);\n+};\n+\n+class ShenandoahPrepareForGenerationalCompactionObjectClosure : public ObjectClosure {\n+private:\n+  PreservedMarks*          const _preserved_marks;\n+  ShenandoahHeap*          const _heap;\n+\n+  \/\/ _empty_regions is a thread-local list of heap regions that have been completely emptied by this worker thread's\n+  \/\/ compaction efforts.  The worker thread that drives these efforts adds compacted regions to this list if the\n+  \/\/ region has not been compacted onto itself.\n+  GrowableArray<ShenandoahHeapRegion*>& _empty_regions;\n+  int _empty_regions_pos;\n+  ShenandoahHeapRegion*          _old_to_region;\n+  ShenandoahHeapRegion*          _young_to_region;\n+  ShenandoahHeapRegion*          _from_region;\n+  ShenandoahAffiliation          _from_affiliation;\n+  HeapWord*                      _old_compact_point;\n+  HeapWord*                      _young_compact_point;\n+  uint                           _worker_id;\n+\n+public:\n+  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n+                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                          ShenandoahHeapRegion* old_to_region,\n+                                                          ShenandoahHeapRegion* young_to_region, uint worker_id) :\n+      _preserved_marks(preserved_marks),\n+      _heap(ShenandoahHeap::heap()),\n+      _empty_regions(empty_regions),\n+      _empty_regions_pos(0),\n+      _old_to_region(old_to_region),\n+      _young_to_region(young_to_region),\n+      _from_region(nullptr),\n+      _old_compact_point((old_to_region != nullptr)? old_to_region->bottom(): nullptr),\n+      _young_compact_point((young_to_region != nullptr)? young_to_region->bottom(): nullptr),\n+      _worker_id(worker_id) {}\n+\n+  void set_from_region(ShenandoahHeapRegion* from_region) {\n+    _from_region = from_region;\n+    _from_affiliation = from_region->affiliation();\n+    if (_from_region->has_live()) {\n+      if (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION) {\n+        if (_old_to_region == nullptr) {\n+          _old_to_region = from_region;\n+          _old_compact_point = from_region->bottom();\n+        }\n+      } else {\n+        assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION, \"from_region must be OLD or YOUNG\");\n+        if (_young_to_region == nullptr) {\n+          _young_to_region = from_region;\n+          _young_compact_point = from_region->bottom();\n+        }\n+      }\n+    } \/\/ else, we won't iterate over this _from_region so we don't need to set up to region to hold copies\n+  }\n+\n+  void finish() {\n+    finish_old_region();\n+    finish_young_region();\n+  }\n+\n+  void finish_old_region() {\n+    if (_old_to_region != nullptr) {\n+      log_debug(gc)(\"Planned compaction into Old Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT \" tabulated by worker %u\",\n+                    _old_to_region->index(), _old_compact_point - _old_to_region->bottom(), _worker_id);\n+      _old_to_region->set_new_top(_old_compact_point);\n+      _old_to_region = nullptr;\n+    }\n+  }\n+\n+  void finish_young_region() {\n+    if (_young_to_region != nullptr) {\n+      log_debug(gc)(\"Worker %u planned compaction into Young Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT,\n+                    _worker_id, _young_to_region->index(), _young_compact_point - _young_to_region->bottom());\n+      _young_to_region->set_new_top(_young_compact_point);\n+      _young_to_region = nullptr;\n+    }\n+  }\n+\n+  bool is_compact_same_region() {\n+    return (_from_region == _old_to_region) || (_from_region == _young_to_region);\n+  }\n+\n+  int empty_regions_pos() {\n+    return _empty_regions_pos;\n+  }\n+\n+  void do_object(oop p) {\n+    assert(_from_region != nullptr, \"must set before work\");\n+    assert((_from_region->bottom() <= cast_from_oop<HeapWord*>(p)) && (cast_from_oop<HeapWord*>(p) < _from_region->top()),\n+           \"Object must reside in _from_region\");\n+    assert(_heap->complete_marking_context()->is_marked(p), \"must be marked\");\n+    assert(!_heap->complete_marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n+\n+    size_t obj_size = p->size();\n+    uint from_region_age = _from_region->age();\n+    uint object_age = p->age();\n+\n+    bool promote_object = false;\n+    if ((_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION) &&\n+        (from_region_age + object_age >= InitialTenuringThreshold)) {\n+      if ((_old_to_region != nullptr) && (_old_compact_point + obj_size > _old_to_region->end())) {\n+        finish_old_region();\n+        _old_to_region = nullptr;\n+      }\n+      if (_old_to_region == nullptr) {\n+        if (_empty_regions_pos < _empty_regions.length()) {\n+          ShenandoahHeapRegion* new_to_region = _empty_regions.at(_empty_regions_pos);\n+          _empty_regions_pos++;\n+          new_to_region->set_affiliation(OLD_GENERATION);\n+          _old_to_region = new_to_region;\n+          _old_compact_point = _old_to_region->bottom();\n+          promote_object = true;\n+        }\n+        \/\/ Else this worker thread does not yet have any empty regions into which this aged object can be promoted so\n+        \/\/ we leave promote_object as false, deferring the promotion.\n+      } else {\n+        promote_object = true;\n+      }\n+    }\n+\n+    if (promote_object || (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION)) {\n+      assert(_old_to_region != nullptr, \"_old_to_region should not be nullptr when evacuating to OLD region\");\n+      if (_old_compact_point + obj_size > _old_to_region->end()) {\n+        ShenandoahHeapRegion* new_to_region;\n+\n+        log_debug(gc)(\"Worker %u finishing old region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+                      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _old_to_region->index(),\n+                      p2i(_old_compact_point), obj_size, p2i(_old_compact_point + obj_size), p2i(_old_to_region->end()));\n+\n+        \/\/ Object does not fit.  Get a new _old_to_region.\n+        finish_old_region();\n+        if (_empty_regions_pos < _empty_regions.length()) {\n+          new_to_region = _empty_regions.at(_empty_regions_pos);\n+          _empty_regions_pos++;\n+          new_to_region->set_affiliation(OLD_GENERATION);\n+        } else {\n+          \/\/ If we've exhausted the previously selected _old_to_region, we know that the _old_to_region is distinct\n+          \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+          \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+          new_to_region = _from_region;\n+        }\n+\n+        assert(new_to_region != _old_to_region, \"must not reuse same OLD to-region\");\n+        assert(new_to_region != nullptr, \"must not be nullptr\");\n+        _old_to_region = new_to_region;\n+        _old_compact_point = _old_to_region->bottom();\n+      }\n+\n+      \/\/ Object fits into current region, record new location:\n+      assert(_old_compact_point + obj_size <= _old_to_region->end(), \"must fit\");\n+      shenandoah_assert_not_forwarded(nullptr, p);\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      p->forward_to(cast_to_oop(_old_compact_point));\n+      _old_compact_point += obj_size;\n+    } else {\n+      assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION,\n+             \"_from_region must be OLD_GENERATION or YOUNG_GENERATION\");\n+      assert(_young_to_region != nullptr, \"_young_to_region should not be nullptr when compacting YOUNG _from_region\");\n+\n+      \/\/ After full gc compaction, all regions have age 0.  Embed the region's age into the object's age in order to preserve\n+      \/\/ tenuring progress.\n+      if (_heap->is_aging_cycle()) {\n+        _heap->increase_object_age(p, from_region_age + 1);\n+      } else {\n+        _heap->increase_object_age(p, from_region_age);\n+      }\n+\n+      if (_young_compact_point + obj_size > _young_to_region->end()) {\n+        ShenandoahHeapRegion* new_to_region;\n+\n+        log_debug(gc)(\"Worker %u finishing young region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+                      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _young_to_region->index(),\n+                      p2i(_young_compact_point), obj_size, p2i(_young_compact_point + obj_size), p2i(_young_to_region->end()));\n+\n+        \/\/ Object does not fit.  Get a new _young_to_region.\n+        finish_young_region();\n+        if (_empty_regions_pos < _empty_regions.length()) {\n+          new_to_region = _empty_regions.at(_empty_regions_pos);\n+          _empty_regions_pos++;\n+          new_to_region->set_affiliation(YOUNG_GENERATION);\n+        } else {\n+          \/\/ If we've exhausted the previously selected _young_to_region, we know that the _young_to_region is distinct\n+          \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+          \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+          new_to_region = _from_region;\n+        }\n+\n+        assert(new_to_region != _young_to_region, \"must not reuse same OLD to-region\");\n+        assert(new_to_region != nullptr, \"must not be nullptr\");\n+        _young_to_region = new_to_region;\n+        _young_compact_point = _young_to_region->bottom();\n+      }\n+\n+      \/\/ Object fits into current region, record new location:\n+      assert(_young_compact_point + obj_size <= _young_to_region->end(), \"must fit\");\n+      shenandoah_assert_not_forwarded(nullptr, p);\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      p->forward_to(cast_to_oop(_young_compact_point));\n+      _young_compact_point += obj_size;\n+    }\n+  }\n+};\n+\n+\n@@ -326,0 +666,1 @@\n+    assert(!_heap->mode()->is_generational(), \"Generational GC should use different Closure\");\n@@ -371,5 +712,0 @@\n-class ShenandoahPrepareForCompactionTask : public WorkerTask {\n-private:\n-  PreservedMarksSet*        const _preserved_marks;\n-  ShenandoahHeap*           const _heap;\n-  ShenandoahHeapRegionSet** const _worker_slices;\n@@ -377,2 +713,3 @@\n-public:\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n+ShenandoahPrepareForCompactionTask::ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n+                                                                       ShenandoahHeapRegionSet **worker_slices,\n+                                                                       size_t num_workers) :\n@@ -380,2 +717,12 @@\n-    _preserved_marks(preserved_marks),\n-    _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {\n+    _preserved_marks(preserved_marks), _heap(ShenandoahHeap::heap()),\n+    _worker_slices(worker_slices), _num_workers(num_workers) { }\n+\n+\n+void ShenandoahPrepareForCompactionTask::work(uint worker_id) {\n+  ShenandoahParallelWorkerSession worker_session(worker_id);\n+  ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];\n+  ShenandoahHeapRegionSetIterator it(slice);\n+  ShenandoahHeapRegion* from_region = it.next();\n+  \/\/ No work?\n+  if (from_region == nullptr) {\n+    return;\n@@ -384,6 +731,3 @@\n-  static bool is_candidate_region(ShenandoahHeapRegion* r) {\n-    \/\/ Empty region: get it into the slice to defragment the slice itself.\n-    \/\/ We could have skipped this without violating correctness, but we really\n-    \/\/ want to compact all live regions to the start of the heap, which sometimes\n-    \/\/ means moving them into the fully empty regions.\n-    if (r->is_empty()) return true;\n+  \/\/ Sliding compaction. Walk all regions in the slice, and compact them.\n+  \/\/ Remember empty regions and reuse them as needed.\n+  ResourceMark rm;\n@@ -391,4 +735,1 @@\n-    \/\/ Can move the region, and this is not the humongous region. Humongous\n-    \/\/ moves are special cased here, because their moves are handled separately.\n-    return r->is_stw_move_allowed() && !r->is_humongous();\n-  }\n+  GrowableArray<ShenandoahHeapRegion*> empty_regions((int)_heap->num_regions());\n@@ -396,8 +737,21 @@\n-  void work(uint worker_id) {\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n-    ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];\n-    ShenandoahHeapRegionSetIterator it(slice);\n-    ShenandoahHeapRegion* from_region = it.next();\n-    \/\/ No work?\n-    if (from_region == nullptr) {\n-       return;\n+  if (_heap->mode()->is_generational()) {\n+    ShenandoahHeapRegion* old_to_region = (from_region->is_old())? from_region: nullptr;\n+    ShenandoahHeapRegion* young_to_region = (from_region->is_young())? from_region: nullptr;\n+    ShenandoahPrepareForGenerationalCompactionObjectClosure cl(_preserved_marks->get(worker_id),\n+                                                               empty_regions,\n+                                                               old_to_region, young_to_region,\n+                                                               worker_id);\n+    while (from_region != nullptr) {\n+      assert(is_candidate_region(from_region), \"Sanity\");\n+      log_debug(gc)(\"Worker %u compacting %s Region \" SIZE_FORMAT \" which had used \" SIZE_FORMAT \" and %s live\",\n+                    worker_id, from_region->affiliation_name(),\n+                    from_region->index(), from_region->used(), from_region->has_live()? \"has\": \"does not have\");\n+      cl.set_from_region(from_region);\n+      if (from_region->has_live()) {\n+        _heap->marked_object_iterate(from_region, &cl);\n+      }\n+      \/\/ Compacted the region to somewhere else? From-region is empty then.\n+      if (!cl.is_compact_same_region()) {\n+        empty_regions.append(from_region);\n+      }\n+      from_region = it.next();\n@@ -405,0 +759,1 @@\n+    cl.finish();\n@@ -406,6 +761,6 @@\n-    \/\/ Sliding compaction. Walk all regions in the slice, and compact them.\n-    \/\/ Remember empty regions and reuse them as needed.\n-    ResourceMark rm;\n-\n-    GrowableArray<ShenandoahHeapRegion*> empty_regions((int)_heap->num_regions());\n-\n+    \/\/ Mark all remaining regions as empty\n+    for (int pos = cl.empty_regions_pos(); pos < empty_regions.length(); ++pos) {\n+      ShenandoahHeapRegion* r = empty_regions.at(pos);\n+      r->set_new_top(r->bottom());\n+    }\n+  } else {\n@@ -413,1 +768,0 @@\n-\n@@ -416,1 +770,0 @@\n-\n@@ -436,1 +789,1 @@\n-};\n+}\n@@ -455,0 +808,1 @@\n+  log_debug(gc)(\"Full GC calculating target humongous objects from end \" SIZE_FORMAT, to_end);\n@@ -497,0 +851,1 @@\n+      \/\/ Leave affiliation unchanged\n@@ -521,0 +876,6 @@\n+    if (!r->is_affiliated()) {\n+      \/\/ Ignore free regions\n+      \/\/ TODO: change iterators so they do not process FREE regions.\n+      return;\n+    }\n+\n@@ -525,1 +886,3 @@\n-               \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n+               r->affiliation_name(),  r->index());\n+        log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n@@ -529,1 +892,1 @@\n-               \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+               \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n@@ -534,1 +897,1 @@\n-             \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+             \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n@@ -537,0 +900,1 @@\n+        log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n@@ -685,0 +1049,5 @@\n+\/\/ TODO:\n+\/\/  Consider compacting old-gen objects toward the high end of memory and young-gen objects towards the low-end\n+\/\/  of memory.  As currently implemented, all regions are compacted toward the low-end of memory.  This creates more\n+\/\/  fragmentation of the heap, because old-gen regions get scattered among low-address regions such that it becomes\n+\/\/  more difficult to find contiguous regions for humongous objects.\n@@ -712,1 +1081,4 @@\n-    ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices);\n+    size_t num_workers = heap->max_workers();\n+\n+    ResourceMark rm;\n+    ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices, num_workers);\n@@ -786,0 +1158,7 @@\n+      if (r->is_pinned() && r->is_old() && r->is_active() && !r->is_humongous()) {\n+        \/\/ Pinned regions are not compacted so they may still hold unmarked objects with\n+        \/\/ reference to reclaimed memory. Remembered set scanning will crash if it attempts\n+        \/\/ to iterate the oops in these objects.\n+        r->begin_preemptible_coalesce_and_fill();\n+        r->oop_fill_and_coalesce_without_cancel();\n+      }\n@@ -886,0 +1265,17 @@\n+static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n@@ -889,1 +1285,3 @@\n-  size_t _live;\n+  bool _is_generational;\n+  size_t _young_regions, _young_usage, _young_humongous_waste;\n+  size_t _old_regions, _old_usage, _old_humongous_waste;\n@@ -892,1 +1290,9 @@\n-  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0) {\n+  ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()),\n+                                   _is_generational(_heap->mode()->is_generational()),\n+                                   _young_regions(0),\n+                                   _young_usage(0),\n+                                   _young_humongous_waste(0),\n+                                   _old_regions(0),\n+                                   _old_usage(0),\n+                                   _old_humongous_waste(0)\n+  {\n@@ -912,0 +1318,4 @@\n+      if (!_is_generational) {\n+        r->make_young_maybe();\n+      }\n+      \/\/ else, generational mode compaction has already established affiliation.\n@@ -924,0 +1334,6 @@\n+    } else {\n+      if (r->is_old()) {\n+        account_for_region(r, _old_regions, _old_usage, _old_humongous_waste);\n+      } else if (r->is_young()) {\n+        account_for_region(r, _young_regions, _young_usage, _young_humongous_waste);\n+      }\n@@ -925,1 +1341,0 @@\n-\n@@ -928,1 +1343,0 @@\n-    _live += live;\n@@ -931,2 +1345,15 @@\n-  size_t get_live() {\n-    return _live;\n+  void update_generation_usage() {\n+    if (_is_generational) {\n+      _heap->old_generation()->establish_usage(_old_regions, _old_usage, _old_humongous_waste);\n+      _heap->young_generation()->establish_usage(_young_regions, _young_usage, _young_humongous_waste);\n+    } else {\n+      assert(_old_regions == 0, \"Old regions only expected in generational mode\");\n+      assert(_old_usage == 0, \"Old usage only expected in generational mode\");\n+      assert(_old_humongous_waste == 0, \"Old humongous waste only expected in generational mode\");\n+    }\n+\n+    \/\/ In generational mode, global usage should be the sum of young and old. This is also true\n+    \/\/ for non-generational modes except that there are no old regions.\n+    _heap->global_generation()->establish_usage(_old_regions + _young_regions,\n+                                                _old_usage + _young_usage,\n+                                                _old_humongous_waste + _young_humongous_waste);\n@@ -941,1 +1368,1 @@\n-  \/\/ sliding costs. We may consider doing this in parallel in future.\n+  \/\/ sliding costs. We may consider doing this in parallel in the future.\n@@ -963,2 +1390,7 @@\n-      Copy::aligned_conjoint_words(r->bottom(), heap->get_region(new_start)->bottom(), words_size);\n-      ContinuationGCSupport::relativize_stack_chunk(cast_to_oop<HeapWord*>(r->bottom()));\n+      ContinuationGCSupport::relativize_stack_chunk(cast_to_oop<HeapWord*>(heap->get_region(old_start)->bottom()));\n+      log_debug(gc)(\"Full GC compaction moves humongous object from region \" SIZE_FORMAT \" to region \" SIZE_FORMAT,\n+                    old_start, new_start);\n+\n+      Copy::aligned_conjoint_words(heap->get_region(old_start)->bottom(),\n+                                   heap->get_region(new_start)->bottom(),\n+                                   words_size);\n@@ -970,0 +1402,1 @@\n+        ShenandoahAffiliation original_affiliation = r->affiliation();\n@@ -972,0 +1405,1 @@\n+          \/\/ Leave humongous region affiliation unchanged.\n@@ -979,1 +1413,1 @@\n-            r->make_humongous_start_bypass();\n+            r->make_humongous_start_bypass(original_affiliation);\n@@ -981,1 +1415,1 @@\n-            r->make_humongous_cont_bypass();\n+            r->make_humongous_cont_bypass(original_affiliation);\n@@ -1047,0 +1481,5 @@\n+}\n+\n+void ShenandoahFullGC::phase5_epilog() {\n+  GCTraceTime(Info, gc, phases) time(\"Phase 5: Full GC epilog\", _gc_timer);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -1059,1 +1498,0 @@\n-\n@@ -1062,1 +1500,15 @@\n-    heap->set_used(post_compact.get_live());\n+    post_compact.update_generation_usage();\n+    if (heap->mode()->is_generational()) {\n+      size_t old_usage = heap->old_generation()->used_regions_size();\n+      size_t old_capacity = heap->old_generation()->max_capacity();\n+\n+      assert(old_usage % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old usage must aligh with region size\");\n+      assert(old_capacity % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old capacity must aligh with region size\");\n+\n+      if (old_capacity > old_usage) {\n+        size_t excess_old_regions = (old_capacity - old_usage) \/ ShenandoahHeapRegion::region_size_bytes();\n+        heap->generation_sizer()->transfer_to_young(excess_old_regions);\n+      } else if (old_capacity < old_usage) {\n+        size_t old_regions_deficit = (old_usage - old_capacity) \/ ShenandoahHeapRegion::region_size_bytes();\n+        heap->generation_sizer()->transfer_to_old(old_regions_deficit);\n+      }\n@@ -1064,0 +1516,4 @@\n+      log_info(gc)(\"FullGC done: young usage: \" SIZE_FORMAT \"%s, old usage: \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(heap->young_generation()->used()), proper_unit_for_byte_size(heap->young_generation()->used()),\n+                   byte_size_in_proper_unit(heap->old_generation()->used()),   proper_unit_for_byte_size(heap->old_generation()->used()));\n+    }\n@@ -1065,2 +1521,5 @@\n-    heap->free_set()->rebuild();\n-  }\n+    size_t young_cset_regions, old_cset_regions;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+\n+    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+    \/\/ no longer have objects separated by age into distinct regions.\n@@ -1068,1 +1527,54 @@\n-  heap->clear_cancelled_gc();\n+    \/\/ TODO: Do we need to fix FullGC so that it maintains aged segregation of objects into distinct regions?\n+    \/\/       A partial solution would be to remember how many objects are of tenure age following Full GC, but\n+    \/\/       this is probably suboptimal, because most of these objects will not reside in a region that will be\n+    \/\/       selected for the next evacuation phase.\n+\n+    \/\/ In case this Full GC resulted from degeneration, clear the tally on anticipated promotion.\n+    heap->clear_promotion_potential();\n+    heap->clear_promotion_in_place_potential();\n+\n+    if (heap->mode()->is_generational()) {\n+      \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n+      heap->adjust_generation_sizes_for_next_cycle(0, 0, 0);\n+    }\n+    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n+\n+    \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n+    \/\/ abbreviated cycle.\n+    if (heap->mode()->is_generational()) {\n+      bool success;\n+      size_t region_xfer;\n+      const char* region_destination;\n+      ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+      ShenandoahGeneration* old_gen = heap->old_generation();\n+\n+      size_t old_region_surplus = heap->get_old_region_surplus();\n+      size_t old_region_deficit = heap->get_old_region_deficit();\n+      if (old_region_surplus) {\n+        success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n+        region_destination = \"young\";\n+        region_xfer = old_region_surplus;\n+      } else if (old_region_deficit) {\n+        success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n+        region_destination = \"old\";\n+        region_xfer = old_region_deficit;\n+        if (!success) {\n+          ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n+        }\n+      } else {\n+        region_destination = \"none\";\n+        region_xfer = 0;\n+        success = true;\n+      }\n+      heap->set_old_region_surplus(0);\n+      heap->set_old_region_deficit(0);\n+      size_t young_available = young_gen->available();\n+      size_t old_available = old_gen->available();\n+      log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                         SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                         success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n+                         byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                         byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+    }\n+    heap->clear_cancelled_gc(true \/* clear oom handler *\/);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":580,"deletions":68,"binary":false,"changes":648,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  void phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+    case _degenerated_roots:\n+      return \"Roots\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    _degenerated_roots,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,777 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTaskqueue.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+ private:\n+  ShenandoahHeap* _heap;\n+  ShenandoahMarkingContext* const _ctx;\n+ public:\n+  ShenandoahResetUpdateRegionStateClosure() :\n+    _heap(ShenandoahHeap::heap()),\n+    _ctx(_heap->marking_context()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (_heap->is_bitmap_slice_committed(r)) {\n+      _ctx->clear_bitmap(r);\n+    }\n+\n+    if (r->is_active()) {\n+      \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n+      \/\/ anyway to capture any updates that happened since now.\n+      _ctx->capture_top_at_mark_start(r);\n+      r->clear_live_data();\n+    }\n+  }\n+\n+  bool is_thread_safe() override { return true; }\n+};\n+\n+class ShenandoahResetBitmapTask : public ShenandoahHeapRegionClosure {\n+ private:\n+  ShenandoahHeap* _heap;\n+  ShenandoahMarkingContext* const _ctx;\n+ public:\n+  ShenandoahResetBitmapTask() :\n+    _heap(ShenandoahHeap::heap()),\n+    _ctx(_heap->marking_context()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* region) {\n+    if (_heap->is_bitmap_slice_committed(region)) {\n+      _ctx->clear_bitmap(region);\n+    }\n+  }\n+\n+  bool is_thread_safe() { return true; }\n+};\n+\n+class ShenandoahMergeWriteTable: public ShenandoahHeapRegionClosure {\n+ private:\n+  ShenandoahHeap* _heap;\n+  RememberedScanner* _scanner;\n+ public:\n+  ShenandoahMergeWriteTable() : _heap(ShenandoahHeap::heap()), _scanner(_heap->card_scan()) {}\n+\n+  virtual void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (r->is_old()) {\n+      _scanner->merge_write_table(r->bottom(), ShenandoahHeapRegion::region_size_words());\n+    }\n+  }\n+\n+  virtual bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n+class ShenandoahSquirrelAwayCardTable: public ShenandoahHeapRegionClosure {\n+ private:\n+  ShenandoahHeap* _heap;\n+  RememberedScanner* _scanner;\n+ public:\n+  ShenandoahSquirrelAwayCardTable() :\n+    _heap(ShenandoahHeap::heap()),\n+    _scanner(_heap->card_scan()) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* region) {\n+    if (region->is_old()) {\n+      _scanner->reset_remset(region->bottom(), ShenandoahHeapRegion::region_size_words());\n+    }\n+  }\n+\n+  bool is_thread_safe() { return true; }\n+};\n+\n+void ShenandoahGeneration::confirm_heuristics_mode() {\n+  if (_heuristics->is_diagnostic() && !UnlockDiagnosticVMOptions) {\n+    vm_exit_during_initialization(\n+            err_msg(\"Heuristics \\\"%s\\\" is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.\",\n+                    _heuristics->name()));\n+  }\n+  if (_heuristics->is_experimental() && !UnlockExperimentalVMOptions) {\n+    vm_exit_during_initialization(\n+            err_msg(\"Heuristics \\\"%s\\\" is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.\",\n+                    _heuristics->name()));\n+  }\n+}\n+\n+ShenandoahHeuristics* ShenandoahGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _heuristics = gc_mode->initialize_heuristics(this);\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedGCInterval);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n+size_t ShenandoahGeneration::bytes_allocated_since_gc_start() {\n+  return Atomic::load(&_bytes_allocated_since_gc_start);\n+}\n+\n+void ShenandoahGeneration::reset_bytes_allocated_since_gc_start() {\n+  Atomic::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+}\n+\n+void ShenandoahGeneration::increase_allocated(size_t bytes) {\n+  Atomic::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n+}\n+\n+void ShenandoahGeneration::log_status(const char *msg) const {\n+  typedef LogTarget(Info, gc, ergo) LogGcInfo;\n+\n+  if (!LogGcInfo::is_enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Not under a lock here, so read each of these once to make sure\n+  \/\/ byte size in proper unit and proper unit for byte size are consistent.\n+  size_t v_used = used();\n+  size_t v_used_regions = used_regions_size();\n+  size_t v_soft_max_capacity = soft_max_capacity();\n+  size_t v_max_capacity = max_capacity();\n+  size_t v_available = available();\n+  size_t v_humongous_waste = get_humongous_waste();\n+  LogGcInfo::print(\"%s: %s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n+                   \"humongous waste: \" SIZE_FORMAT \"%s, soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \"%s, \"\n+                   \"available: \" SIZE_FORMAT \"%s\", msg, name(),\n+                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n+                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n+                   byte_size_in_proper_unit(v_humongous_waste),   proper_unit_for_byte_size(v_humongous_waste),\n+                   byte_size_in_proper_unit(v_soft_max_capacity), proper_unit_for_byte_size(v_soft_max_capacity),\n+                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n+                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available));\n+}\n+\n+void ShenandoahGeneration::reset_mark_bitmap() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+\n+  set_mark_incomplete();\n+\n+  ShenandoahResetBitmapTask task;\n+  parallel_heap_region_iterate(&task);\n+}\n+\n+\/\/ The ideal is to swap the remembered set so the safepoint effort is no more than a few pointer manipulations.\n+\/\/ However, limitations in the implementation of the mutator write-barrier make it difficult to simply change the\n+\/\/ location of the card table.  So the interim implementation of swap_remembered_set will copy the write-table\n+\/\/ onto the read-table and will then clear the write-table.\n+void ShenandoahGeneration::swap_remembered_set() {\n+  \/\/ Must be sure that marking is complete before we swap remembered set.\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+  shenandoah_assert_safepoint();\n+\n+  \/\/ TODO: Eventually, we want replace this with a constant-time exchange of pointers.\n+  ShenandoahSquirrelAwayCardTable task;\n+  heap->old_generation()->parallel_heap_region_iterate(&task);\n+}\n+\n+\/\/ If a concurrent cycle fails _after_ the card table has been swapped we need to update the read card\n+\/\/ table with any writes that have occurred during the transition to the degenerated cycle. Without this,\n+\/\/ newly created objects which are only referenced by old objects could be lost when the remembered set\n+\/\/ is scanned during the degenerated mark.\n+void ShenandoahGeneration::merge_write_table() {\n+  \/\/ This should only happen for degenerated cycles\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->assert_gc_workers(heap->workers()->active_workers());\n+  shenandoah_assert_safepoint();\n+\n+  ShenandoahMergeWriteTable task;\n+  heap->old_generation()->parallel_heap_region_iterate(&task);\n+}\n+\n+void ShenandoahGeneration::prepare_gc() {\n+  \/\/ Invalidate the marking context\n+  set_mark_incomplete();\n+\n+  \/\/ Capture Top At Mark Start for this generation (typically young) and reset mark bitmap.\n+  ShenandoahResetUpdateRegionStateClosure cl;\n+  parallel_heap_region_iterate(&cl);\n+}\n+\n+void ShenandoahGeneration::compute_evacuation_budgets(ShenandoahHeap* heap, bool* preselected_regions,\n+                                                      ShenandoahCollectionSet* collection_set,\n+                                                      size_t &consumed_by_advance_promotion) {\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t regions_available_to_loan = 0;\n+  size_t minimum_evacuation_reserve = ShenandoahOldCompactionReserve * region_size_bytes;\n+  size_t old_regions_loaned_for_young_evac = 0;\n+  consumed_by_advance_promotion = 0;\n+\n+  ShenandoahGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  size_t old_evacuation_reserve = 0;\n+  size_t num_regions = heap->num_regions();\n+\n+  \/\/ During initialization and phase changes, it is more likely that fewer objects die young and old-gen\n+  \/\/ memory is not yet full (or is in the process of being replaced).  During these times especially, it\n+  \/\/ is beneficial to loan memory from old-gen to young-gen during the evacuation and update-refs phases\n+  \/\/ of execution.\n+\n+  \/\/ Calculate EvacuationReserve before PromotionReserve.  Evacuation is more critical than promotion.\n+  \/\/ If we cannot evacuate old-gen, we will not be able to reclaim old-gen memory.  Promotions are less\n+  \/\/ critical.  If we cannot promote, there may be degradation of young-gen memory because old objects\n+  \/\/ accumulate there until they can be promoted.  This increases the young-gen marking and evacuation work.\n+\n+  \/\/ Do not fill up old-gen memory with promotions.  Reserve some amount of memory for compaction purposes.\n+  size_t young_evac_reserve_max = 0;\n+\n+  \/\/ First priority is to reclaim the easy garbage out of young-gen.\n+\n+  \/\/ maximum_young_evacuation_reserve is upper bound on memory to be evacuated out of young\n+  size_t maximum_young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  size_t young_evacuation_reserve = maximum_young_evacuation_reserve;\n+  size_t excess_young;\n+  if (young_generation->available() > young_evacuation_reserve) {\n+    excess_young = young_generation->available() - young_evacuation_reserve;\n+  } else {\n+    young_evacuation_reserve = young_generation->available();\n+    excess_young = 0;\n+  }\n+  size_t unaffiliated_young = young_generation->free_unaffiliated_regions() * region_size_bytes;\n+  if (excess_young > unaffiliated_young) {\n+    excess_young = unaffiliated_young;\n+  } else {\n+    \/\/ round down to multiple of region size\n+    excess_young \/= region_size_bytes;\n+    excess_young *= region_size_bytes;\n+  }\n+  \/\/ excess_young is available to be transferred to OLD.  Assume that OLD will not request any more than had\n+  \/\/ already been set aside for its promotion and evacuation needs at the end of previous GC.  No need to\n+  \/\/ hold back memory for allocation runway.\n+\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+\n+  \/\/ maximum_old_evacuation_reserve is an upper bound on memory evacuated from old and evacuated to old (promoted).\n+  size_t maximum_old_evacuation_reserve =\n+    maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent \/ (100 - ShenandoahOldEvacRatioPercent);\n+  \/\/ Here's the algebra:\n+  \/\/  TotalEvacuation = OldEvacuation + YoungEvacuation\n+  \/\/  OldEvacuation = TotalEvacuation * (ShenandoahOldEvacRatioPercent\/100)\n+  \/\/  OldEvacuation = YoungEvacuation * (ShenandoahOldEvacRatioPercent\/100)\/(1 - ShenandoahOldEvacRatioPercent\/100)\n+  \/\/  OldEvacuation = YoungEvacuation * ShenandoahOldEvacRatioPercent\/(100 - ShenandoahOldEvacRatioPercent)\n+\n+  if (maximum_old_evacuation_reserve > old_generation->available()) {\n+    maximum_old_evacuation_reserve = old_generation->available();\n+  }\n+\n+  \/\/ Second priority is to reclaim garbage out of old-gen if there are old-gen collection candidates.  Third priority\n+  \/\/ is to promote as much as we have room to promote.  However, if old-gen memory is in short supply, this means young\n+  \/\/ GC is operating under \"duress\" and was unable to transfer the memory that we would normally expect.  In this case,\n+  \/\/ old-gen will refrain from compacting itself in order to allow a quicker young-gen cycle (by avoiding the update-refs\n+  \/\/ through ALL of old-gen).  If there is some memory available in old-gen, we will use this for promotions as promotions\n+  \/\/ do not add to the update-refs burden of GC.\n+\n+  size_t old_promo_reserve;\n+  if (old_heuristics->unprocessed_old_collection_candidates() > 0) {\n+    \/\/ We reserved all old-gen memory at end of previous GC to hold anticipated evacuations to old-gen.  If this is\n+    \/\/ mixed evacuation, reserve all of this memory for compaction of old-gen and do not promote.  Prioritize compaction\n+    \/\/ over promotion in order to defragment OLD so that it will be better prepared to efficiently receive promoted memory.\n+    old_evacuation_reserve = maximum_old_evacuation_reserve;\n+    old_promo_reserve = 0;\n+  } else {\n+    \/\/ Make all old-evacuation memory for promotion, but if we can't use it all for promotion, we'll allow some evacuation.\n+    old_evacuation_reserve = 0;\n+    old_promo_reserve = maximum_old_evacuation_reserve;\n+  }\n+\n+  \/\/ We see too many old-evacuation failures if we force ourselves to evacuate into regions that are not initially empty.\n+  \/\/ So we limit the old-evacuation reserve to unfragmented memory.  Even so, old-evacuation is free to fill in nooks and\n+  \/\/ crannies within existing partially used regions and it generally tries to do so.\n+  size_t old_free_regions = old_generation->free_unaffiliated_regions();\n+  size_t old_free_unfragmented = old_free_regions * region_size_bytes;\n+  if (old_evacuation_reserve > old_free_unfragmented) {\n+    size_t delta = old_evacuation_reserve - old_free_unfragmented;\n+    old_evacuation_reserve -= delta;\n+\n+    \/\/ Let promo consume fragments of old-gen memory.\n+    old_promo_reserve += delta;\n+  }\n+  collection_set->establish_preselected(preselected_regions);\n+  consumed_by_advance_promotion = _heuristics->select_aged_regions(old_promo_reserve, num_regions, preselected_regions);\n+  assert(consumed_by_advance_promotion <= maximum_old_evacuation_reserve, \"Cannot promote more than available old-gen memory\");\n+  if (consumed_by_advance_promotion < old_promo_reserve) {\n+    \/\/ If we're in a global collection, this memory can be used for old evacuations\n+    old_evacuation_reserve += old_promo_reserve - consumed_by_advance_promotion;\n+  }\n+  heap->set_young_evac_reserve(young_evacuation_reserve);\n+  heap->set_old_evac_reserve(old_evacuation_reserve);\n+  heap->set_promoted_reserve(consumed_by_advance_promotion);\n+\n+  \/\/ There is no need to expand OLD because all memory used here was set aside at end of previous GC\n+}\n+\n+\/\/ Having chosen the collection set, adjust the budgets for generational mode based on its composition.  Note\n+\/\/ that young_generation->available() now knows about recently discovered immediate garbage.\n+\n+void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* heap, ShenandoahCollectionSet* collection_set,\n+                                                     size_t consumed_by_advance_promotion) {\n+  \/\/ We may find that old_evacuation_reserve and\/or loaned_for_young_evacuation are not fully consumed, in which case we may\n+  \/\/  be able to increase regions_available_to_loan\n+\n+  \/\/ The role of adjust_evacuation_budgets() is to compute the correct value of regions_available_to_loan and to make\n+  \/\/ effective use of this memory, including the remnant memory within these regions that may result from rounding loan to\n+  \/\/ integral number of regions.  Excess memory that is available to be loaned is applied to an allocation supplement,\n+  \/\/ which allows mutators to allocate memory beyond the current capacity of young-gen on the promise that the loan\n+  \/\/ will be repaid as soon as we finish updating references for the recently evacuated collection set.\n+\n+  \/\/ We cannot recalculate regions_available_to_loan by simply dividing old_generation->available() by region_size_bytes\n+  \/\/ because the available memory may be distributed between many partially occupied regions that are already holding old-gen\n+  \/\/ objects.  Memory in partially occupied regions is not \"available\" to be loaned.  Note that an increase in old-gen\n+  \/\/ available that results from a decrease in memory consumed by old evacuation is not necessarily available to be loaned\n+  \/\/ to young-gen.\n+\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+\n+  \/\/ Preselected regions have been inserted into the collection set, so we no longer need the preselected array.\n+  collection_set->abandon_preselected();\n+\n+  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  size_t old_evacuated_committed = (size_t) (ShenandoahOldEvacWaste * old_evacuated);\n+  size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n+\n+  if (old_evacuated_committed > old_evacuation_reserve) {\n+    \/\/ This should only happen due to round-off errors when enforcing ShenandoahOldEvacWaste\n+    assert(old_evacuated_committed <= (33 * old_evacuation_reserve) \/ 32,\n+           \"Round-off errors should be less than 3.125%%, committed: \" SIZE_FORMAT \", reserved: \" SIZE_FORMAT,\n+           old_evacuated_committed, old_evacuation_reserve);\n+    old_evacuated_committed = old_evacuation_reserve;\n+    \/\/ Leave old_evac_reserve as previously configured\n+  } else if (old_evacuated_committed < old_evacuation_reserve) {\n+    \/\/ This happens if the old-gen collection consumes less than full budget.\n+    old_evacuation_reserve = old_evacuated_committed;\n+    heap->set_old_evac_reserve(old_evacuation_reserve);\n+  }\n+\n+  size_t young_advance_promoted = collection_set->get_young_bytes_to_be_promoted();\n+  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * young_advance_promoted);\n+\n+  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n+  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n+\n+  assert(young_evacuated_reserve_used <= young_generation->available(), \"Cannot evacuate more than is available in young\");\n+  heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+\n+  size_t old_available = old_generation->available();\n+  \/\/ Now that we've established the collection set, we know how much memory is really required by old-gen for evacuation\n+  \/\/ and promotion reserves.  Try shrinking OLD now in case that gives us a bit more runway for mutator allocations during\n+  \/\/ evac and update phases.\n+  size_t old_consumed = old_evacuated_committed + young_advance_promoted_reserve_used;\n+  assert(old_available >= old_consumed, \"Cannot consume more than is available\");\n+  size_t excess_old = old_available - old_consumed;\n+  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+  assert(old_available >= unaffiliated_old, \"Unaffiliated old is a subset of old available\");\n+\n+  \/\/ Make sure old_evac_committed is unaffiliated\n+  if (old_evacuated_committed > 0) {\n+    if (unaffiliated_old > old_evacuated_committed) {\n+      size_t giveaway = unaffiliated_old - old_evacuated_committed;\n+      size_t giveaway_regions = giveaway \/ region_size_bytes;  \/\/ round down\n+      if (giveaway_regions > 0) {\n+        excess_old = MIN2(excess_old, giveaway_regions * region_size_bytes);\n+      } else {\n+        excess_old = 0;\n+      }\n+    } else {\n+      excess_old = 0;\n+    }\n+  }\n+\n+  \/\/ If we find that OLD has excess regions, give them back to YOUNG now to reduce likelihood we run out of allocation\n+  \/\/ runway during evacuation and update-refs.\n+  size_t regions_to_xfer = 0;\n+  if (excess_old > unaffiliated_old) {\n+    \/\/ we can give back unaffiliated_old (all of unaffiliated is excess)\n+    if (unaffiliated_old_regions > 0) {\n+      regions_to_xfer = unaffiliated_old_regions;\n+    }\n+  } else if (unaffiliated_old_regions > 0) {\n+    \/\/ excess_old < unaffiliated old: we can give back MIN(excess_old\/region_size_bytes, unaffiliated_old_regions)\n+    size_t excess_regions = excess_old \/ region_size_bytes;\n+    size_t regions_to_xfer = MIN2(excess_regions, unaffiliated_old_regions);\n+  }\n+\n+  if (regions_to_xfer > 0) {\n+    bool result = heap->generation_sizer()->transfer_to_young(regions_to_xfer);\n+    assert(excess_old > regions_to_xfer * region_size_bytes, \"Cannot xfer more than excess old\");\n+    excess_old -= regions_to_xfer * region_size_bytes;\n+    log_info(gc, ergo)(\"%s transferred \" SIZE_FORMAT \" excess regions to young before start of evacuation\",\n+                       result? \"Successfully\": \"Unsuccessfully\", regions_to_xfer);\n+  }\n+\n+  \/\/ Add in the excess_old memory to hold unanticipated promotions, if any.  If there are more unanticipated\n+  \/\/ promotions than fit in reserved memory, they will be deferred until a future GC pass.\n+  size_t total_promotion_reserve = young_advance_promoted_reserve_used + excess_old;\n+  heap->set_promoted_reserve(total_promotion_reserve);\n+  heap->reset_promoted_expended();\n+}\n+\n+void ShenandoahGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahCollectionSet* collection_set = heap->collection_set();\n+\n+  assert(!heap->is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n+  assert(!is_old(), \"Only YOUNG and GLOBAL GC perform evacuations\");\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_update_region_states :\n+                            ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n+    ShenandoahFinalMarkUpdateRegionStateClosure cl(complete_marking_context());\n+    parallel_heap_region_iterate(&cl);\n+\n+    if (is_young()) {\n+      \/\/ We always need to update the watermark for old regions. If there\n+      \/\/ are mixed collections pending, we also need to synchronize the\n+      \/\/ pinned status for old regions. Since we are already visiting every\n+      \/\/ old region here, go ahead and sync the pin status too.\n+      ShenandoahFinalMarkUpdateRegionStateClosure old_cl(nullptr);\n+      heap->old_generation()->parallel_heap_region_iterate(&old_cl);\n+    }\n+  }\n+\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n+                            ShenandoahPhaseTimings::degen_gc_choose_cset);\n+\n+    collection_set->clear();\n+    ShenandoahHeapLocker locker(heap->lock());\n+    if (heap->mode()->is_generational()) {\n+      size_t consumed_by_advance_promotion;\n+      bool* preselected_regions = (bool*) alloca(heap->num_regions() * sizeof(bool));\n+      for (unsigned int i = 0; i < heap->num_regions(); i++) {\n+        preselected_regions[i] = false;\n+      }\n+\n+      \/\/ TODO: young_available can include available (between top() and end()) within each young region that is not\n+      \/\/ part of the collection set.  Making this memory available to the young_evacuation_reserve allows a larger\n+      \/\/ young collection set to be chosen when available memory is under extreme pressure.  Implementing this \"improvement\"\n+      \/\/ is tricky, because the incremental construction of the collection set actually changes the amount of memory\n+      \/\/ available to hold evacuated young-gen objects.  As currently implemented, the memory that is available within\n+      \/\/ non-empty regions that are not selected as part of the collection set can be allocated by the mutator while\n+      \/\/ GC is evacuating and updating references.\n+\n+      \/\/ Budgeting parameters to compute_evacuation_budgets are passed by reference.\n+      compute_evacuation_budgets(heap, preselected_regions, collection_set, consumed_by_advance_promotion);\n+      _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n+      if (!collection_set->is_empty()) {\n+        \/\/ only make use of evacuation budgets when we are evacuating\n+        adjust_evacuation_budgets(heap, collection_set, consumed_by_advance_promotion);\n+      }\n+    } else {\n+      _heuristics->choose_collection_set(collection_set, heap->old_heuristics());\n+    }\n+  }\n+\n+  \/\/ Freeset construction uses reserve quantities if they are valid\n+  heap->set_evacuation_reserve_quantities(true);\n+  {\n+    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_rebuild_freeset :\n+                            ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t young_cset_regions, old_cset_regions;\n+\n+    \/\/ We are preparing for evacuation.  At this time, we ignore cset region tallies.\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n+  }\n+  heap->set_evacuation_reserve_quantities(false);\n+}\n+\n+bool ShenandoahGeneration::is_bitmap_clear() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* context = heap->marking_context();\n+  size_t num_regions = heap->num_regions();\n+  for (size_t idx = 0; idx < num_regions; idx++) {\n+    ShenandoahHeapRegion* r = heap->get_region(idx);\n+    if (contains(r) && r->is_affiliated()) {\n+      if (heap->is_bitmap_slice_committed(r) && (context->top_at_mark_start(r) > r->bottom()) &&\n+          !context->is_bitmap_clear_range(r->bottom(), r->end())) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool ShenandoahGeneration::is_mark_complete() {\n+  return _is_marking_complete.is_set();\n+}\n+\n+void ShenandoahGeneration::set_mark_complete() {\n+  _is_marking_complete.set();\n+}\n+\n+void ShenandoahGeneration::set_mark_incomplete() {\n+  _is_marking_complete.unset();\n+}\n+\n+ShenandoahMarkingContext* ShenandoahGeneration::complete_marking_context() {\n+  assert(is_mark_complete(), \"Marking must be completed.\");\n+  return ShenandoahHeap::heap()->marking_context();\n+}\n+\n+void ShenandoahGeneration::cancel_marking() {\n+  log_info(gc)(\"Cancel marking: %s\", name());\n+  if (is_concurrent_mark_in_progress()) {\n+    set_mark_incomplete();\n+  }\n+  _task_queues->clear();\n+  ref_processor()->abandon_partial_discovery();\n+  set_concurrent_mark_in_progress(false);\n+}\n+\n+ShenandoahGeneration::ShenandoahGeneration(ShenandoahGenerationType type,\n+                                           uint max_workers,\n+                                           size_t max_capacity,\n+                                           size_t soft_max_capacity) :\n+  _type(type),\n+  _task_queues(new ShenandoahObjToScanQueueSet(max_workers)),\n+  _ref_processor(new ShenandoahReferenceProcessor(MAX2(max_workers, 1U))),\n+  _collection_thread_time_s(0.0),\n+  _affiliated_region_count(0), _humongous_waste(0), _used(0), _bytes_allocated_since_gc_start(0),\n+  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _heuristics(nullptr) {\n+  _is_marking_complete.set();\n+  assert(max_workers > 0, \"At least one queue\");\n+  for (uint i = 0; i < max_workers; ++i) {\n+    ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();\n+    _task_queues->register_queue(i, task_queue);\n+  }\n+}\n+\n+ShenandoahGeneration::~ShenandoahGeneration() {\n+  for (uint i = 0; i < _task_queues->size(); ++i) {\n+    ShenandoahObjToScanQueue* q = _task_queues->queue(i);\n+    delete q;\n+  }\n+  delete _task_queues;\n+}\n+\n+void ShenandoahGeneration::reserve_task_queues(uint workers) {\n+  _task_queues->reserve(workers);\n+}\n+\n+ShenandoahObjToScanQueueSet* ShenandoahGeneration::old_gen_task_queues() const {\n+  return nullptr;\n+}\n+\n+void ShenandoahGeneration::scan_remembered_set(bool is_concurrent) {\n+  assert(is_young(), \"Should only scan remembered set for young generation.\");\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  uint nworkers = heap->workers()->active_workers();\n+  reserve_task_queues(nworkers);\n+\n+  ShenandoahReferenceProcessor* rp = ref_processor();\n+  ShenandoahRegionChunkIterator work_list(nworkers);\n+  ShenandoahScanRememberedTask task(task_queues(), old_gen_task_queues(), rp, &work_list, is_concurrent);\n+  heap->assert_gc_workers(nworkers);\n+  heap->workers()->run_task(&task);\n+  if (ShenandoahEnableCardStats) {\n+    assert(heap->card_scan() != nullptr, \"Not generational\");\n+    heap->card_scan()->log_card_stats(nworkers, CARD_STAT_SCAN_RS);\n+  }\n+}\n+\n+size_t ShenandoahGeneration::increment_affiliated_region_count() {\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n+  _affiliated_region_count++;\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::decrement_affiliated_region_count() {\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n+  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n+  \/\/ a coherent value.\n+  _affiliated_region_count--;\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used + _humongous_waste <= _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n+         \"used + humongous cannot exceed regions\");\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::increase_affiliated_region_count(size_t delta) {\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  _affiliated_region_count += delta;\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::decrease_affiliated_region_count(size_t delta) {\n+  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  assert(_affiliated_region_count > delta, \"Affiliated region count cannot be negative\");\n+\n+  _affiliated_region_count -= delta;\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used + _humongous_waste <= _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n+         \"used + humongous cannot exceed regions\");\n+  return _affiliated_region_count;\n+}\n+\n+void ShenandoahGeneration::establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste) {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"must be at a safepoint\");\n+  _affiliated_region_count = num_regions;\n+  _used = num_bytes;\n+  _humongous_waste = humongous_waste;\n+}\n+\n+void ShenandoahGeneration::increase_used(size_t bytes) {\n+  Atomic::add(&_used, bytes);\n+}\n+\n+void ShenandoahGeneration::increase_humongous_waste(size_t bytes) {\n+  if (bytes > 0) {\n+    Atomic::add(&_humongous_waste, bytes);\n+  }\n+}\n+\n+void ShenandoahGeneration::decrease_humongous_waste(size_t bytes) {\n+  if (bytes > 0) {\n+    assert(ShenandoahHeap::heap()->is_full_gc_in_progress() || (_humongous_waste >= bytes),\n+           \"Waste (\" SIZE_FORMAT \") cannot be negative (after subtracting \" SIZE_FORMAT \")\", _humongous_waste, bytes);\n+    Atomic::sub(&_humongous_waste, bytes);\n+  }\n+}\n+\n+void ShenandoahGeneration::decrease_used(size_t bytes) {\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used >= bytes), \"cannot reduce bytes used by generation below zero\");\n+  Atomic::sub(&_used, bytes);\n+}\n+\n+size_t ShenandoahGeneration::used_regions() const {\n+  return _affiliated_region_count;\n+}\n+\n+size_t ShenandoahGeneration::free_unaffiliated_regions() const {\n+  size_t result = max_capacity() \/ ShenandoahHeapRegion::region_size_bytes();\n+  if (_affiliated_region_count > result) {\n+    result = 0;\n+  } else {\n+    result -= _affiliated_region_count;\n+  }\n+  return result;\n+}\n+\n+size_t ShenandoahGeneration::used_regions_size() const {\n+  return _affiliated_region_count * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGeneration::available() const {\n+  size_t in_use = used() + get_humongous_waste();\n+  size_t capacity = max_capacity();\n+  return in_use > capacity ? 0 : capacity - in_use;\n+}\n+\n+size_t ShenandoahGeneration::soft_available() const {\n+  size_t in_use = used() + get_humongous_waste();\n+  size_t soft_capacity = soft_max_capacity();\n+  return in_use > soft_capacity ? 0 : soft_capacity - in_use;\n+}\n+\n+void ShenandoahGeneration::increase_capacity(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  \/\/ We do not enforce that new capacity >= heap->max_size_for(this).  The maximum generation size is treated as a rule of thumb\n+  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n+  \/\/ in place.\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_max_capacity + increment <= ShenandoahHeap::heap()->max_capacity()), \"Generation cannot be larger than heap size\");\n+  assert(increment % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n+  _max_capacity += increment;\n+\n+  \/\/ This detects arithmetic wraparound on _used\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() >= _used),\n+         \"Affiliated regions must hold more than what is currently used\");\n+}\n+\n+void ShenandoahGeneration::decrease_capacity(size_t decrement) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  \/\/ We do not enforce that new capacity >= heap->min_size_for(this).  The minimum generation size is treated as a rule of thumb\n+  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n+  \/\/ in place.\n+  assert(decrement % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n+  assert(_max_capacity >= decrement, \"Generation capacity cannot be negative\");\n+\n+  _max_capacity -= decrement;\n+\n+  \/\/ This detects arithmetic wraparound on _used\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() >= _used),\n+         \"Affiliated regions must hold more than what is currently used\");\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_used <= _max_capacity), \"Cannot use more than capacity\");\n+  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n+  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+         (_affiliated_region_count * ShenandoahHeapRegion::region_size_bytes() <= _max_capacity),\n+         \"Cannot use more than capacity\");\n+}\n+\n+void ShenandoahGeneration::record_success_concurrent(bool abbreviated) {\n+  heuristics()->record_success_concurrent(abbreviated);\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_success_concurrent();\n+}\n+\n+void ShenandoahGeneration::record_success_degenerated() {\n+  heuristics()->record_success_degenerated();\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_success_degenerated();\n+}\n+\n+void ShenandoahGeneration::add_collection_time(double time_seconds) {\n+  shenandoah_assert_control_or_vm_thread();\n+  _collection_thread_time_s += time_seconds;\n+}\n+\n+double ShenandoahGeneration::reset_collection_time() {\n+  double t = _collection_thread_time_s;\n+  _collection_thread_time_s = 0.0;\n+  return t;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":777,"deletions":0,"binary":false,"changes":777,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+\n+class ShenandoahHeapRegion;\n+class ShenandoahHeapRegionClosure;\n+class ShenandoahReferenceProcessor;\n+class ShenandoahHeap;\n+class ShenandoahMode;\n+\n+class ShenandoahGeneration : public CHeapObj<mtGC> {\n+  friend class VMStructs;\n+private:\n+  ShenandoahGenerationType const _type;\n+\n+  \/\/ Marking task queues and completeness\n+  ShenandoahObjToScanQueueSet* _task_queues;\n+  ShenandoahSharedFlag _is_marking_complete;\n+\n+  ShenandoahReferenceProcessor* const _ref_processor;\n+\n+  double _collection_thread_time_s;\n+\n+  size_t _affiliated_region_count;\n+\n+  \/\/ How much free memory is left in the last region of humongous objects.\n+  \/\/ This is _not_ included in used, but it _is_ deducted from available,\n+  \/\/ which gives the heuristics a more accurate view of how much memory remains\n+  \/\/ for allocation. This figure is also included the heap status logging.\n+  \/\/ The units are bytes. The value is only changed on a safepoint or under the\n+  \/\/ heap lock.\n+  size_t _humongous_waste;\n+\n+protected:\n+  \/\/ Usage\n+\n+  volatile size_t _used;\n+  volatile size_t _bytes_allocated_since_gc_start;\n+  size_t _max_capacity;\n+  size_t _soft_max_capacity;\n+\n+  ShenandoahHeuristics* _heuristics;\n+\n+private:\n+  \/\/ Compute evacuation budgets prior to choosing collection set.\n+  void compute_evacuation_budgets(ShenandoahHeap* heap,\n+                                  bool* preselected_regions,\n+                                  ShenandoahCollectionSet* collection_set,\n+                                  size_t& consumed_by_advance_promotion);\n+\n+  \/\/ Adjust evacuation budgets after choosing collection set.\n+  void adjust_evacuation_budgets(ShenandoahHeap* heap,\n+                                 ShenandoahCollectionSet* collection_set,\n+                                 size_t consumed_by_advance_promotion);\n+\n+ public:\n+  ShenandoahGeneration(ShenandoahGenerationType type,\n+                       uint max_workers,\n+                       size_t max_capacity,\n+                       size_t soft_max_capacity);\n+  ~ShenandoahGeneration();\n+\n+  bool is_young() const  { return _type == YOUNG; }\n+  bool is_old() const    { return _type == OLD; }\n+  bool is_global() const { return _type == GLOBAL_GEN || _type == GLOBAL_NON_GEN; }\n+\n+  inline ShenandoahGenerationType type() const { return _type; }\n+\n+  inline ShenandoahHeuristics* heuristics() const { return _heuristics; }\n+\n+  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n+\n+  virtual const char* name() const = 0;\n+\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode);\n+\n+  virtual size_t soft_max_capacity() const { return _soft_max_capacity; }\n+  virtual size_t max_capacity() const      { return _max_capacity; }\n+  virtual size_t used_regions() const;\n+  virtual size_t used_regions_size() const;\n+  virtual size_t free_unaffiliated_regions() const;\n+  virtual size_t used() const { return _used; }\n+  virtual size_t available() const;\n+\n+  \/\/ Returns the memory available based on the _soft_ max heap capacity (soft_max_heap - used).\n+  \/\/ The soft max heap size may be adjusted lower than the max heap size to cause the trigger\n+  \/\/ to believe it has less memory available than is _really_ available. Lowering the soft\n+  \/\/ max heap size will cause the adaptive heuristic to run more frequent cycles.\n+  size_t soft_available() const;\n+\n+  size_t bytes_allocated_since_gc_start();\n+  void reset_bytes_allocated_since_gc_start();\n+  void increase_allocated(size_t bytes);\n+\n+  \/\/ These methods change the capacity of the region by adding or subtracting the given number of bytes from the current\n+  \/\/ capacity.\n+  void increase_capacity(size_t increment);\n+  void decrease_capacity(size_t decrement);\n+\n+  void set_soft_max_capacity(size_t soft_max_capacity) {\n+    _soft_max_capacity = soft_max_capacity;\n+  }\n+\n+  void log_status(const char* msg) const;\n+\n+  \/\/ Used directly by FullGC\n+  void reset_mark_bitmap();\n+\n+  \/\/ Used by concurrent and degenerated GC to reset remembered set.\n+  void swap_remembered_set();\n+\n+  \/\/ Update the read cards with the state of the write table (write table is not cleared).\n+  void merge_write_table();\n+\n+  \/\/ Called before init mark, expected to prepare regions for marking.\n+  virtual void prepare_gc();\n+\n+  \/\/ Called during final mark, chooses collection set, rebuilds free set.\n+  virtual void prepare_regions_and_collection_set(bool concurrent);\n+\n+  \/\/ Cancel marking (used by Full collect and when cancelling cycle).\n+  virtual void cancel_marking();\n+\n+  \/\/ Return true if this region is affiliated with this generation.\n+  virtual bool contains(ShenandoahHeapRegion* region) const = 0;\n+\n+  \/\/ Return true if this object is affiliated with this generation.\n+  virtual bool contains(oop obj) const = 0;\n+\n+  \/\/ Apply closure to all regions affiliated with this generation.\n+  virtual void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) = 0;\n+\n+  \/\/ Apply closure to all regions affiliated with this generation (single threaded).\n+  virtual void heap_region_iterate(ShenandoahHeapRegionClosure* cl) = 0;\n+\n+  \/\/ This is public to support cancellation of marking when a Full cycle is started.\n+  virtual void set_concurrent_mark_in_progress(bool in_progress) = 0;\n+\n+  \/\/ Check the bitmap only for regions belong to this generation.\n+  bool is_bitmap_clear();\n+\n+  \/\/ We need to track the status of marking for different generations.\n+  bool is_mark_complete();\n+  void set_mark_complete();\n+  void set_mark_incomplete();\n+\n+  ShenandoahMarkingContext* complete_marking_context();\n+\n+  \/\/ Task queues\n+  ShenandoahObjToScanQueueSet* task_queues() const { return _task_queues; }\n+  virtual void reserve_task_queues(uint workers);\n+  virtual ShenandoahObjToScanQueueSet* old_gen_task_queues() const;\n+\n+  \/\/ Scan remembered set at start of concurrent young-gen marking.\n+  void scan_remembered_set(bool is_concurrent);\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t increment_affiliated_region_count();\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t decrement_affiliated_region_count();\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t increase_affiliated_region_count(size_t delta);\n+\n+  \/\/ Return the updated value of affiliated_region_count\n+  size_t decrease_affiliated_region_count(size_t delta);\n+\n+  void establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste);\n+\n+  void increase_used(size_t bytes);\n+  void decrease_used(size_t bytes);\n+\n+  void increase_humongous_waste(size_t bytes);\n+  void decrease_humongous_waste(size_t bytes);\n+  size_t get_humongous_waste() const { return _humongous_waste; }\n+\n+  virtual bool is_concurrent_mark_in_progress() = 0;\n+  void confirm_heuristics_mode();\n+\n+  virtual void record_success_concurrent(bool abbreviated);\n+  virtual void record_success_degenerated();\n+\n+  \/\/ Record the total on-cpu time a thread has spent collecting this\n+  \/\/ generation. This is only called by the control thread (at the start\n+  \/\/ of a collection) and by the VM thread at the end of the collection,\n+  \/\/ so there are no locking concerns.\n+  virtual void add_collection_time(double time_seconds);\n+\n+  \/\/ This returns the accumulated collection time and resets it to zero.\n+  \/\/ This is used to decide which generation should be resized.\n+  double reset_collection_time();\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONTYPE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONTYPE_HPP\n+\n+enum ShenandoahGenerationType {\n+    GLOBAL_NON_GEN,  \/\/ Global, non-generational\n+    GLOBAL_GEN,      \/\/ Global, generational\n+    YOUNG,           \/\/ Young,  generational\n+    OLD              \/\/ Old,    generational\n+};\n+\n+inline const char* shenandoah_generation_name(ShenandoahGenerationType mode) {\n+  switch (mode) {\n+    case GLOBAL_NON_GEN:\n+      return \"\";\n+    case GLOBAL_GEN:\n+      return \"Global\";\n+    case OLD:\n+      return \"Old\";\n+    case YOUNG:\n+      return \"Young\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"?\";\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONTYPE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationType.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+\n+const char* ShenandoahGlobalGeneration::name() const {\n+  return \"GLOBAL\";\n+}\n+\n+size_t ShenandoahGlobalGeneration::max_capacity() const {\n+  return ShenandoahHeap::heap()->max_capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::used_regions() const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->mode()->is_generational(), \"Region usage accounting is only for generational mode\");\n+  return heap->old_generation()->used_regions() + heap->young_generation()->used_regions();\n+}\n+\n+size_t ShenandoahGlobalGeneration::used_regions_size() const {\n+  return ShenandoahHeap::heap()->capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::soft_max_capacity() const {\n+  return ShenandoahHeap::heap()->soft_max_capacity();\n+}\n+\n+size_t ShenandoahGlobalGeneration::available() const {\n+  return ShenandoahHeap::heap()->free_set()->available();\n+}\n+\n+void ShenandoahGlobalGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (in_progress && heap->mode()->is_generational()) {\n+    \/\/ Global collection has preempted an old generation mark. This is fine\n+    \/\/ because the global generation includes the old generation, but we\n+    \/\/ want the global collect to start from a clean slate and we don't want\n+    \/\/ any stale state in the old generation.\n+    heap->cancel_old_gc();\n+  }\n+\n+  heap->set_concurrent_young_mark_in_progress(in_progress);\n+}\n+\n+bool ShenandoahGlobalGeneration::contains(ShenandoahHeapRegion* region) const {\n+  return true;\n+}\n+\n+void ShenandoahGlobalGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(cl);\n+}\n+\n+void ShenandoahGlobalGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahHeap::heap()->heap_region_iterate(cl);\n+}\n+\n+bool ShenandoahGlobalGeneration::is_concurrent_mark_in_progress() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  return heap->is_concurrent_mark_in_progress();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+\n+\/\/ A \"generation\" that represents the whole heap.\n+class ShenandoahGlobalGeneration : public ShenandoahGeneration {\n+public:\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL_GEN : GLOBAL_NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+\n+public:\n+  virtual const char* name() const override;\n+\n+  virtual size_t max_capacity() const override;\n+  virtual size_t soft_max_capacity() const override;\n+  virtual size_t used_regions() const override;\n+  virtual size_t used_regions_size() const override;\n+  virtual size_t available() const override;\n+\n+  virtual void set_concurrent_mark_in_progress(bool in_progress) override;\n+\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+\n+  bool contains(oop obj) const override {\n+    \/\/ TODO: Should this assert is_in()?\n+    return true;\n+  }\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool is_concurrent_mark_in_progress() override;\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHGLOBALGENERATION_HPP\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -38,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n@@ -45,0 +48,1 @@\n+#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n@@ -46,0 +50,1 @@\n+#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n@@ -55,0 +60,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -61,0 +67,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -68,0 +75,2 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp\"\n@@ -71,0 +80,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -75,0 +86,2 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+\n@@ -162,3 +175,0 @@\n-  \/\/ Now we know the number of regions, initialize the heuristics.\n-  initialize_heuristics();\n-\n@@ -180,0 +190,3 @@\n+  \/\/ Now we know the number of regions and heap sizes, initialize the heuristics.\n+  initialize_heuristics_generations();\n+\n@@ -214,0 +227,25 @@\n+  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n+\n+  \/\/\n+  \/\/ After reserving the Java heap, create the card table, barriers, and workers, in dependency order\n+  \/\/\n+  if (mode()->is_generational()) {\n+    ShenandoahDirectCardMarkRememberedSet *rs;\n+    ShenandoahCardTable* card_table = ShenandoahBarrierSet::barrier_set()->card_table();\n+    size_t card_count = card_table->cards_required(heap_rs.size() \/ HeapWordSize);\n+    rs = new ShenandoahDirectCardMarkRememberedSet(ShenandoahBarrierSet::barrier_set()->card_table(), card_count);\n+    _card_scan = new ShenandoahScanRemembered<ShenandoahDirectCardMarkRememberedSet>(rs);\n+  }\n+\n+  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n+  if (_workers == nullptr) {\n+    vm_exit_during_initialization(\"Failed necessary allocation.\");\n+  } else {\n+    _workers->initialize_workers();\n+  }\n+\n+  if (ParallelGCThreads > 1) {\n+    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\", ParallelGCThreads);\n+    _safepoint_workers->initialize_workers();\n+  }\n+\n@@ -257,1 +295,1 @@\n-  _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions, _max_workers);\n+  _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);\n@@ -320,0 +358,1 @@\n+  _affiliations = NEW_C_HEAP_ARRAY(uint8_t, _num_regions, mtGC);\n@@ -325,0 +364,1 @@\n+\n@@ -336,0 +376,2 @@\n+\n+      _affiliations[i] = ShenandoahAffiliation::FREE;\n@@ -340,0 +382,1 @@\n+    size_t young_cset_regions, old_cset_regions;\n@@ -341,1 +384,3 @@\n-    _free_set->rebuild();\n+    \/\/ We are initializing free set.  We ignore cset region tallies.\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+    _free_set->rebuild(young_cset_regions, old_cset_regions);\n@@ -403,0 +448,1 @@\n+  _regulator_thread = new ShenandoahRegulatorThread(_control_thread);\n@@ -409,1 +455,31 @@\n-void ShenandoahHeap::initialize_mode() {\n+size_t ShenandoahHeap::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return _generation_sizer.max_young_size();\n+    case OLD:\n+      return max_capacity() - _generation_sizer.min_young_size();\n+    case GLOBAL_GEN:\n+    case GLOBAL_NON_GEN:\n+      return max_capacity();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahHeap::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return _generation_sizer.min_young_size();\n+    case OLD:\n+      return max_capacity() - _generation_sizer.max_young_size();\n+    case GLOBAL_GEN:\n+    case GLOBAL_NON_GEN:\n+      return min_capacity();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+void ShenandoahHeap::initialize_heuristics_generations() {\n@@ -417,0 +493,2 @@\n+    } else if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+      _gc_mode = new ShenandoahGenerationalMode();\n@@ -434,1 +512,0 @@\n-}\n@@ -436,3 +513,9 @@\n-void ShenandoahHeap::initialize_heuristics() {\n-  assert(_gc_mode != nullptr, \"Must be initialized\");\n-  _heuristics = _gc_mode->initialize_heuristics();\n+  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n+  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n+  \/\/ _actual_ capacity of young + old = total.\n+  _generation_sizer.heap_size_changed(max_capacity());\n+  size_t initial_capacity_young = _generation_sizer.max_young_size();\n+  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n+  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n@@ -440,10 +523,6 @@\n-  if (_heuristics->is_diagnostic() && !UnlockDiagnosticVMOptions) {\n-    vm_exit_during_initialization(\n-            err_msg(\"Heuristics \\\"%s\\\" is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.\",\n-                    _heuristics->name()));\n-  }\n-  if (_heuristics->is_experimental() && !UnlockExperimentalVMOptions) {\n-    vm_exit_during_initialization(\n-            err_msg(\"Heuristics \\\"%s\\\" is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.\",\n-                    _heuristics->name()));\n-  }\n+  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_young, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, initial_capacity_old);\n+  _global_generation = new ShenandoahGlobalGeneration(_gc_mode->is_generational(), _max_workers, max_capacity(), max_capacity());\n+  _global_generation->initialize_heuristics(_gc_mode);\n+  _young_generation->initialize_heuristics(_gc_mode);\n+  _old_generation->initialize_heuristics(_gc_mode);\n@@ -459,0 +538,2 @@\n+  _gc_generation(nullptr),\n+  _prepare_for_old_mark(false),\n@@ -460,1 +541,2 @@\n-  _used(0),\n+  _promotion_potential(0),\n+  _promotion_in_place_potential(0),\n@@ -462,2 +544,1 @@\n-  _bytes_allocated_since_gc_start(0),\n-  _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),\n+  _max_workers(MAX3(ConcGCThreads, ParallelGCThreads, 1U)),\n@@ -469,0 +550,1 @@\n+  _affiliations(nullptr),\n@@ -470,0 +552,12 @@\n+  _promoted_reserve(0),\n+  _old_evac_reserve(0),\n+  _old_evac_expended(0),\n+  _young_evac_reserve(0),\n+  _captured_old_usage(0),\n+  _previous_promotion(0),\n+  _upgraded_to_full(false),\n+  _has_evacuation_reserve_quantities(false),\n+  _cancel_requested_time(0),\n+  _young_generation(nullptr),\n+  _global_generation(nullptr),\n+  _old_generation(nullptr),\n@@ -471,0 +565,1 @@\n+  _regulator_thread(nullptr),\n@@ -472,2 +567,0 @@\n-  _gc_mode(nullptr),\n-  _heuristics(nullptr),\n@@ -478,0 +571,3 @@\n+  _evac_tracker(new ShenandoahEvacuationTracker()),\n+  _mmu_tracker(),\n+  _generation_sizer(&_mmu_tracker),\n@@ -480,0 +576,2 @@\n+  _young_gen_memory_pool(nullptr),\n+  _old_gen_memory_pool(nullptr),\n@@ -485,1 +583,2 @@\n-  _ref_processor(new ShenandoahReferenceProcessor(MAX2(_max_workers, 1U))),\n+  _old_regions_surplus(0),\n+  _old_regions_deficit(0),\n@@ -493,1 +592,2 @@\n-  _collection_set(nullptr)\n+  _collection_set(nullptr),\n+  _card_scan(nullptr)\n@@ -495,17 +595,0 @@\n-  \/\/ Initialize GC mode early, so we can adjust barrier support\n-  initialize_mode();\n-  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));\n-\n-  _max_workers = MAX2(_max_workers, 1U);\n-  _workers = new ShenandoahWorkerThreads(\"Shenandoah GC Threads\", _max_workers);\n-  if (_workers == nullptr) {\n-    vm_exit_during_initialization(\"Failed necessary allocation.\");\n-  } else {\n-    _workers->initialize_workers();\n-  }\n-\n-  if (ParallelGCThreads > 1) {\n-    _safepoint_workers = new ShenandoahWorkerThreads(\"Safepoint Cleanup Thread\",\n-                                                ParallelGCThreads);\n-    _safepoint_workers->initialize_workers();\n-  }\n@@ -518,29 +601,0 @@\n-class ShenandoahResetBitmapTask : public WorkerTask {\n-private:\n-  ShenandoahRegionIterator _regions;\n-\n-public:\n-  ShenandoahResetBitmapTask() :\n-    WorkerTask(\"Shenandoah Reset Bitmap\") {}\n-\n-  void work(uint worker_id) {\n-    ShenandoahHeapRegion* region = _regions.next();\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahMarkingContext* const ctx = heap->marking_context();\n-    while (region != nullptr) {\n-      if (heap->is_bitmap_slice_committed(region)) {\n-        ctx->clear_bitmap(region);\n-      }\n-      region = _regions.next();\n-    }\n-  }\n-};\n-\n-void ShenandoahHeap::reset_mark_bitmap() {\n-  assert_gc_workers(_workers->active_workers());\n-  mark_incomplete_marking_context();\n-\n-  ShenandoahResetBitmapTask task;\n-  _workers->run_task(&task);\n-}\n-\n@@ -561,1 +615,2 @@\n-  if (is_concurrent_mark_in_progress())        st->print(\"marking, \");\n+  if (is_concurrent_old_mark_in_progress())    st->print(\"old marking, \");\n+  if (is_concurrent_young_mark_in_progress())  st->print(\"young marking, \");\n@@ -596,0 +651,1 @@\n+    st->cr();\n@@ -611,0 +667,2 @@\n+  _mmu_tracker.initialize();\n+\n@@ -624,2 +682,0 @@\n-  _heuristics->initialize();\n-\n@@ -629,0 +685,17 @@\n+\n+ShenandoahOldHeuristics* ShenandoahHeap::old_heuristics() {\n+  return (ShenandoahOldHeuristics*) _old_generation->heuristics();\n+}\n+\n+bool ShenandoahHeap::doing_mixed_evacuations() {\n+  return _old_generation->state() == ShenandoahOldGeneration::WAITING_FOR_EVAC;\n+}\n+\n+bool ShenandoahHeap::is_old_bitmap_stable() const {\n+  return _old_generation->is_mark_complete();\n+}\n+\n+bool ShenandoahHeap::is_gc_generation_young() const {\n+  return _gc_generation != nullptr && _gc_generation->is_young();\n+}\n+\n@@ -630,1 +703,1 @@\n-  return Atomic::load(&_used);\n+  return global_generation()->used();\n@@ -647,2 +720,43 @@\n-void ShenandoahHeap::increase_used(size_t bytes) {\n-  Atomic::add(&_used, bytes, memory_order_relaxed);\n+\/\/ For tracking usage based on allocations, it should be the case that:\n+\/\/ * The sum of regions::used == heap::used\n+\/\/ * The sum of a generation's regions::used == generation::used\n+\/\/ * The sum of a generation's humongous regions::free == generation::humongous_waste\n+\/\/ These invariants are checked by the verifier on GC safepoints.\n+\/\/\n+\/\/ Additional notes:\n+\/\/ * When a mutator's allocation request causes a region to be retired, the\n+\/\/   free memory left in that region is considered waste. It does not contribute\n+\/\/   to the usage, but it _does_ contribute to allocation rate.\n+\/\/ * The bottom of a PLAB must be aligned on card size. In some cases this will\n+\/\/   require padding in front of the PLAB (a filler object). Because this padding\n+\/\/   is included in the region's used memory we include the padding in the usage\n+\/\/   accounting as waste.\n+\/\/ * Mutator allocations are used to compute an allocation rate. They are also\n+\/\/   sent to the Pacer for those purposes.\n+\/\/ * There are three sources of waste:\n+\/\/  1. The padding used to align a PLAB on card size\n+\/\/  2. Region's free is less than minimum TLAB size and is retired\n+\/\/  3. The unused portion of memory in the last region of a humongous object\n+void ShenandoahHeap::increase_used(const ShenandoahAllocRequest& req) {\n+  size_t actual_bytes = req.actual_size() * HeapWordSize;\n+  size_t wasted_bytes = req.waste() * HeapWordSize;\n+  ShenandoahGeneration* generation = generation_for(req.affiliation());\n+\n+  if (req.is_gc_alloc()) {\n+    assert(wasted_bytes == 0 || req.type() == ShenandoahAllocRequest::_alloc_plab, \"Only PLABs have waste\");\n+    increase_used(generation, actual_bytes + wasted_bytes);\n+  } else {\n+    assert(req.is_mutator_alloc(), \"Expected mutator alloc here\");\n+    \/\/ padding and actual size both count towards allocation counter\n+    generation->increase_allocated(actual_bytes + wasted_bytes);\n+\n+    \/\/ only actual size counts toward usage for mutator allocations\n+    increase_used(generation, actual_bytes);\n+\n+    \/\/ notify pacer of both actual size and waste\n+    notify_mutator_alloc_words(req.actual_size(), req.waste());\n+\n+    if (wasted_bytes > 0 && req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+      increase_humongous_waste(generation,wasted_bytes);\n+    }\n+  }\n@@ -651,2 +765,5 @@\n-void ShenandoahHeap::set_used(size_t bytes) {\n-  Atomic::store(&_used, bytes);\n+void ShenandoahHeap::increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->increase_humongous_waste(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->increase_humongous_waste(bytes);\n+  }\n@@ -655,3 +772,5 @@\n-void ShenandoahHeap::decrease_used(size_t bytes) {\n-  assert(used() >= bytes, \"never decrease heap size by more than we've left\");\n-  Atomic::sub(&_used, bytes, memory_order_relaxed);\n+void ShenandoahHeap::decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->decrease_humongous_waste(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->decrease_humongous_waste(bytes);\n+  }\n@@ -660,2 +779,5 @@\n-void ShenandoahHeap::increase_allocated(size_t bytes) {\n-  Atomic::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n+void ShenandoahHeap::increase_used(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->increase_used(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->increase_used(bytes);\n+  }\n@@ -664,4 +786,4 @@\n-void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {\n-  size_t bytes = words * HeapWordSize;\n-  if (!waste) {\n-    increase_used(bytes);\n+void ShenandoahHeap::decrease_used(ShenandoahGeneration* generation, size_t bytes) {\n+  generation->decrease_used(bytes);\n+  if (!generation->is_global()) {\n+    global_generation()->decrease_used(bytes);\n@@ -669,1 +791,3 @@\n-  increase_allocated(bytes);\n+}\n+\n+void ShenandoahHeap::notify_mutator_alloc_words(size_t words, size_t waste) {\n@@ -672,2 +796,2 @@\n-    if (waste) {\n-      pacer()->claim_for_alloc(words, true);\n+    if (waste > 0) {\n+      pacer()->claim_for_alloc(waste, true);\n@@ -709,6 +833,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -742,0 +860,69 @@\n+    regulator_thread()->notify_heap_changed();\n+  }\n+}\n+\n+void ShenandoahHeap::handle_old_evacuation(HeapWord* obj, size_t words, bool promotion) {\n+  \/\/ Only register the copy of the object that won the evacuation race.\n+  card_scan()->register_object_without_lock(obj);\n+\n+  \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n+  \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n+  \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n+  \/\/ that hold interesting pointers right now.\n+  card_scan()->mark_range_as_dirty(obj, words);\n+\n+  if (promotion) {\n+    \/\/ This evacuation was a promotion, track this as allocation against old gen\n+    old_generation()->increase_allocated(words * HeapWordSize);\n+  }\n+}\n+\n+void ShenandoahHeap::handle_old_evacuation_failure() {\n+  if (_old_gen_oom_evac.try_set()) {\n+    log_info(gc)(\"Old gen evac failure.\");\n+  }\n+}\n+\n+void ShenandoahHeap::handle_promotion_failure() {\n+  old_heuristics()->handle_promotion_failure();\n+}\n+\n+void ShenandoahHeap::report_promotion_failure(Thread* thread, size_t size) {\n+  \/\/ We squelch excessive reports to reduce noise in logs.\n+  const size_t MaxReportsPerEpoch = 4;\n+  static size_t last_report_epoch = 0;\n+  static size_t epoch_report_count = 0;\n+\n+  size_t promotion_reserve;\n+  size_t promotion_expended;\n+\n+  size_t gc_id = control_thread()->get_gc_id();\n+\n+  if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n+    {\n+      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n+      ShenandoahHeapLocker locker(lock());\n+      promotion_reserve = get_promoted_reserve();\n+      promotion_expended = get_promoted_expended();\n+    }\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n+    const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n+    ShenandoahGeneration* old_gen = old_generation();\n+    size_t old_capacity = old_gen->max_capacity();\n+    size_t old_usage = old_gen->used();\n+    size_t old_free_regions = old_gen->free_unaffiliated_regions();\n+\n+    log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n+                       \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT\n+                       \", old capacity: \" SIZE_FORMAT \", old_used: \" SIZE_FORMAT \", old unaffiliated regions: \" SIZE_FORMAT,\n+                       size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n+                       words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n+                       old_capacity, old_usage, old_free_regions);\n+\n+    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n+      log_info(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n+    } else if (gc_id != last_report_epoch) {\n+      last_report_epoch = gc_id;;\n+      epoch_report_count = 1;\n+    }\n@@ -751,0 +938,8 @@\n+\n+  \/\/ Limit growth of GCLABs to ShenandoahMaxEvacLABRatio * the minimum size.  This enables more equitable distribution of\n+  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n+  if (ShenandoahMaxEvacLABRatio > 0) {\n+    log_debug(gc, free)(\"Allocate new gclab: \" SIZE_FORMAT \", \" SIZE_FORMAT, new_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n+    new_size = MIN2(new_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n+  }\n+\n@@ -762,0 +957,1 @@\n+    log_debug(gc, free)(\"New gclab size (\" SIZE_FORMAT \") is too small for \" SIZE_FORMAT, new_size, size);\n@@ -794,0 +990,260 @@\n+\/\/ Establish a new PLAB and allocate size HeapWords within it.\n+HeapWord* ShenandoahHeap::allocate_from_plab_slow(Thread* thread, size_t size, bool is_promotion) {\n+  \/\/ New object should fit the PLAB size\n+  size_t min_size = MAX2(size, PLAB::min_size());\n+\n+  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.\n+  size_t cur_size = ShenandoahThreadLocalData::plab_size(thread);\n+  if (cur_size == 0) {\n+    cur_size = PLAB::min_size();\n+  }\n+  size_t future_size = cur_size * 2;\n+  \/\/ Limit growth of PLABs to ShenandoahMaxEvacLABRatio * the minimum size.  This enables more equitable distribution of\n+  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n+  if (ShenandoahMaxEvacLABRatio > 0) {\n+    future_size = MIN2(future_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n+  }\n+  future_size = MIN2(future_size, PLAB::max_size());\n+  future_size = MAX2(future_size, PLAB::min_size());\n+\n+  size_t unalignment = future_size % CardTable::card_size_in_words();\n+  if (unalignment != 0) {\n+    future_size = future_size - unalignment + CardTable::card_size_in_words();\n+  }\n+\n+  \/\/ Record new heuristic value even if we take any shortcut. This captures\n+  \/\/ the case when moderately-sized objects always take a shortcut. At some point,\n+  \/\/ heuristics should catch up with them.  Note that the requested cur_size may\n+  \/\/ not be honored, but we remember that this is the preferred size.\n+  ShenandoahThreadLocalData::set_plab_size(thread, future_size);\n+  if (cur_size < size) {\n+    \/\/ The PLAB to be allocated is still not large enough to hold the object. Fall back to shared allocation.\n+    \/\/ This avoids retiring perfectly good PLABs in order to represent a single large object allocation.\n+    return nullptr;\n+  }\n+\n+  \/\/ Retire current PLAB, and allocate a new one.\n+  PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+  if (plab->words_remaining() < PLAB::min_size()) {\n+    \/\/ Retire current PLAB, and allocate a new one.\n+    \/\/ CAUTION: retire_plab may register the remnant filler object with the remembered set scanner without a lock.  This\n+    \/\/ is safe iff it is assured that each PLAB is a whole-number multiple of card-mark memory size and each PLAB is\n+    \/\/ aligned with the start of a card's memory range.\n+    retire_plab(plab, thread);\n+\n+    size_t actual_size = 0;\n+    \/\/ allocate_new_plab resets plab_evacuated and plab_promoted and disables promotions if old-gen available is\n+    \/\/ less than the remaining evacuation need.  It also adjusts plab_preallocated and expend_promoted if appropriate.\n+    HeapWord* plab_buf = allocate_new_plab(min_size, cur_size, &actual_size);\n+    if (plab_buf == nullptr) {\n+      if (min_size == PLAB::min_size()) {\n+        \/\/ Disable plab promotions for this thread because we cannot even allocate a plab of minimal size.  This allows us\n+        \/\/ to fail faster on subsequent promotion attempts.\n+        ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+      }\n+      return NULL;\n+    } else {\n+      ShenandoahThreadLocalData::enable_plab_retries(thread);\n+    }\n+    assert (size <= actual_size, \"allocation should fit\");\n+    if (ZeroTLAB) {\n+      \/\/ ..and clear it.\n+      Copy::zero_to_words(plab_buf, actual_size);\n+    } else {\n+      \/\/ ...and zap just allocated object.\n+#ifdef ASSERT\n+      \/\/ Skip mangling the space corresponding to the object header to\n+      \/\/ ensure that the returned space is not considered parsable by\n+      \/\/ any concurrent GC thread.\n+      size_t hdr_size = oopDesc::header_size();\n+      Copy::fill_to_words(plab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);\n+#endif \/\/ ASSERT\n+    }\n+    plab->set_buf(plab_buf, actual_size);\n+    if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+      return nullptr;\n+    }\n+    return plab->allocate(size);\n+  } else {\n+    \/\/ If there's still at least min_size() words available within the current plab, don't retire it.  Let's gnaw\n+    \/\/ away on this plab as long as we can.  Meanwhile, return nullptr to force this particular allocation request\n+    \/\/ to be satisfied with a shared allocation.  By packing more promotions into the previously allocated PLAB, we\n+    \/\/ reduce the likelihood of evacuation failures, and we we reduce the need for downsizing our PLABs.\n+    return nullptr;\n+  }\n+}\n+\n+\/\/ TODO: It is probably most efficient to register all objects (both promotions and evacuations) that were allocated within\n+\/\/ this plab at the time we retire the plab.  A tight registration loop will run within both code and data caches.  This change\n+\/\/ would allow smaller and faster in-line implementation of alloc_from_plab().  Since plabs are aligned on card-table boundaries,\n+\/\/ this object registration loop can be performed without acquiring a lock.\n+void ShenandoahHeap::retire_plab(PLAB* plab, Thread* thread) {\n+  \/\/ We don't enforce limits on plab_evacuated.  We let it consume all available old-gen memory in order to reduce\n+  \/\/ probability of an evacuation failure.  We do enforce limits on promotion, to make sure that excessive promotion\n+  \/\/ does not result in an old-gen evacuation failure.  Note that a failed promotion is relatively harmless.  Any\n+  \/\/ object that fails to promote in the current cycle will be eligible for promotion in a subsequent cycle.\n+\n+  \/\/ When the plab was instantiated, its entirety was treated as if the entire buffer was going to be dedicated to\n+  \/\/ promotions.  Now that we are retiring the buffer, we adjust for the reality that the plab is not entirely promotions.\n+  \/\/  1. Some of the plab may have been dedicated to evacuations.\n+  \/\/  2. Some of the plab may have been abandoned due to waste (at the end of the plab).\n+  size_t not_promoted =\n+    ShenandoahThreadLocalData::get_plab_preallocated_promoted(thread) - ShenandoahThreadLocalData::get_plab_promoted(thread);\n+  ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+  ShenandoahThreadLocalData::reset_plab_evacuated(thread);\n+  ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, 0);\n+  if (not_promoted > 0) {\n+    unexpend_promoted(not_promoted);\n+  }\n+  size_t waste = plab->waste();\n+  HeapWord* top = plab->top();\n+  plab->retire();\n+  if (top != nullptr && plab->waste() > waste && is_in_old(top)) {\n+    \/\/ If retiring the plab created a filler object, then we\n+    \/\/ need to register it with our card scanner so it can\n+    \/\/ safely walk the region backing the plab.\n+    log_debug(gc)(\"retire_plab() is registering remnant of size \" SIZE_FORMAT \" at \" PTR_FORMAT,\n+                  plab->waste() - waste, p2i(top));\n+    card_scan()->register_object_without_lock(top);\n+  }\n+}\n+\n+void ShenandoahHeap::retire_plab(PLAB* plab) {\n+  Thread* thread = Thread::current();\n+  retire_plab(plab, thread);\n+}\n+\n+void ShenandoahHeap::cancel_old_gc() {\n+  shenandoah_assert_safepoint();\n+  assert(_old_generation != nullptr, \"Should only have mixed collections in generation mode.\");\n+  log_info(gc)(\"Terminating old gc cycle.\");\n+\n+  \/\/ Stop marking\n+  old_generation()->cancel_marking();\n+  \/\/ Stop coalescing undead objects\n+  set_prepare_for_old_mark_in_progress(false);\n+  \/\/ Stop tracking old regions\n+  old_heuristics()->abandon_collection_candidates();\n+  \/\/ Remove old generation access to young generation mark queues\n+  young_generation()->set_old_gen_task_queues(nullptr);\n+  \/\/ Transition to IDLE now.\n+  _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+}\n+\n+bool ShenandoahHeap::is_old_gc_active() {\n+  return _old_generation->state() != ShenandoahOldGeneration::IDLE;\n+}\n+\n+void ShenandoahHeap::coalesce_and_fill_old_regions() {\n+  class ShenandoahGlobalCoalesceAndFill : public ShenandoahHeapRegionClosure {\n+   public:\n+    virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n+      \/\/ old region is not in the collection set and was not immediately trashed\n+      if (region->is_old() && region->is_active() && !region->is_humongous()) {\n+        \/\/ Reset the coalesce and fill boundary because this is a global collect\n+        \/\/ and cannot be preempted by young collects. We want to be sure the entire\n+        \/\/ region is coalesced here and does not resume from a previously interrupted\n+        \/\/ or completed coalescing.\n+        region->begin_preemptible_coalesce_and_fill();\n+        region->oop_fill_and_coalesce();\n+      }\n+    }\n+\n+    virtual bool is_thread_safe() override {\n+      return true;\n+    }\n+  };\n+  ShenandoahGlobalCoalesceAndFill coalesce;\n+  parallel_heap_region_iterate(&coalesce);\n+}\n+\n+\/\/ xfer_limit is the maximum we're able to transfer from young to old\n+void ShenandoahHeap::adjust_generation_sizes_for_next_cycle(\n+  size_t xfer_limit, size_t young_cset_regions, size_t old_cset_regions) {\n+\n+  \/\/ Make sure old-generation is large enough, but no larger, than is necessary to hold mixed evacuations\n+  \/\/ and promotions if we anticipate either.\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t promo_load = get_promotion_potential();\n+  \/\/ The free set will reserve this amount of memory to hold young evacuations\n+  size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  size_t old_reserve = 0;\n+  size_t mixed_candidates = old_heuristics()->unprocessed_old_collection_candidates();\n+  bool doing_mixed = (mixed_candidates > 0);\n+  bool doing_promotions = promo_load > 0;\n+\n+  \/\/ round down\n+  size_t max_old_region_xfer = xfer_limit \/ region_size_bytes;\n+\n+  \/\/ We can limit the reserve to the size of anticipated promotions\n+  size_t max_old_reserve = young_reserve * ShenandoahOldEvacRatioPercent \/ (100 - ShenandoahOldEvacRatioPercent);\n+  \/\/ Here's the algebra:\n+  \/\/  TotalEvacuation = OldEvacuation + YoungEvacuation\n+  \/\/  OldEvacuation = TotalEvacuation*(ShenandoahOldEvacRatioPercent\/100)\n+  \/\/  OldEvacuation = YoungEvacuation * (ShenandoahOldEvacRatioPercent\/100)\/(1 - ShenandoahOldEvacRatioPercent\/100)\n+  \/\/  OldEvacuation = YoungEvacuation * ShenandoahOldEvacRatioPercent\/(100 - ShenandoahOldEvacRatioPercent)\n+\n+  size_t reserve_for_mixed, reserve_for_promo;\n+  if (doing_mixed) {\n+    assert(old_generation()->available() >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n+           \"Unaffiliated available must be less than total available\");\n+\n+    \/\/ We want this much memory to be unfragmented in order to reliably evacuate old.  This is conservative because we\n+    \/\/ may not evacuate the entirety of unprocessed candidates in a single mixed evacuation.\n+    size_t max_evac_need = (size_t)\n+      (old_heuristics()->unprocessed_old_collection_candidates_live_memory() * ShenandoahOldEvacWaste);\n+    size_t old_fragmented_available =\n+      old_generation()->available() - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n+    reserve_for_mixed = max_evac_need + old_fragmented_available;\n+    if (reserve_for_mixed > max_old_reserve) {\n+      reserve_for_mixed = max_old_reserve;\n+    }\n+  } else {\n+    reserve_for_mixed = 0;\n+  }\n+\n+  size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n+  if (doing_promotions) {\n+    \/\/ We're only promoting and we have a maximum bound on the amount to be promoted\n+    reserve_for_promo = (size_t) (promo_load * ShenandoahPromoEvacWaste);\n+    if (reserve_for_promo > available_for_promotions) {\n+      reserve_for_promo = available_for_promotions;\n+    }\n+  } else {\n+    reserve_for_promo = 0;\n+  }\n+  old_reserve = reserve_for_mixed + reserve_for_promo;\n+  assert(old_reserve <= max_old_reserve, \"cannot reserve more than max for old evacuations\");\n+  size_t old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n+  size_t young_available = young_generation()->available() + young_cset_regions * region_size_bytes;\n+  size_t old_region_deficit = 0;\n+  size_t old_region_surplus = 0;\n+  if (old_available >= old_reserve) {\n+    size_t old_excess = old_available - old_reserve;\n+    size_t excess_regions = old_excess \/ region_size_bytes;\n+    size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n+    size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n+    if (unaffiliated_old_regions < excess_regions) {\n+      \/\/ We'll give only unaffiliated old to young, which is known to be less than the excess.\n+      old_region_surplus = unaffiliated_old_regions;\n+    } else {\n+      \/\/ unaffiliated_old_regions > excess_regions, so we only give away the excess.\n+      old_region_surplus = excess_regions;\n+    }\n+  } else {\n+    \/\/ We need to request transfer from YOUNG.  Ignore that this will directly impact young_generation()->max_capacity(),\n+    \/\/ indirectly impacting young_reserve and old_reserve.  These computations are conservative.\n+    size_t old_need = old_reserve - old_available;\n+    \/\/ Round up the number of regions needed from YOUNG\n+    old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n+  }\n+  if (old_region_deficit > max_old_region_xfer) {\n+    \/\/ If we're running short on young-gen memory, limit the xfer.  Old-gen collection activities will be curtailed\n+    \/\/ if the budget is smaller than desired.\n+    old_region_deficit = max_old_region_xfer;\n+  }\n+  set_old_region_surplus(old_region_surplus);\n+  set_old_region_deficit(old_region_deficit);\n+}\n+\n+\/\/ Called from stubs in JIT code or interpreter\n@@ -798,1 +1254,1 @@\n-  HeapWord* res = allocate_memory(req);\n+  HeapWord* res = allocate_memory(req, false);\n@@ -811,1 +1267,20 @@\n-  HeapWord* res = allocate_memory(req);\n+  HeapWord* res = allocate_memory(req, false);\n+  if (res != nullptr) {\n+    *actual_size = req.actual_size();\n+  } else {\n+    *actual_size = 0;\n+  }\n+  return res;\n+}\n+\n+HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size,\n+                                            size_t word_size,\n+                                            size_t* actual_size) {\n+  size_t words_in_card = CardTable::card_size_in_words();\n+  size_t align_mask = ~(words_in_card - 1);\n+  min_size = (min_size + words_in_card - 1) & align_mask;\n+  word_size = (word_size + words_in_card - 1) & align_mask;\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_plab(min_size, word_size);\n+  \/\/ Note that allocate_memory() sets a thread-local flag to prohibit further promotions by this thread\n+  \/\/ if we are at risk of infringing on the old-gen evacuation budget.\n+  HeapWord* res = allocate_memory(req, false);\n@@ -820,1 +1295,3 @@\n-HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest& req) {\n+\/\/ is_promotion is true iff this allocation is known for sure to hold the result of young-gen evacuation\n+\/\/ to old-gen.  plab allocates are not known as such, since they may hold old-gen evacuations.\n+HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest& req, bool is_promotion) {\n@@ -832,1 +1309,1 @@\n-      result = allocate_memory_under_lock(req, in_new_region);\n+      result = allocate_memory_under_lock(req, in_new_region, is_promotion);\n@@ -843,2 +1320,1 @@\n-    \/\/ Full GC, which means we want to try more than ShenandoahFullGCThreshold times.\n-\n+    \/\/ Full GC.\n@@ -846,1 +1322,1 @@\n-\n+    size_t original_fullgc_count = shenandoah_policy()->get_fullgc_count();\n@@ -850,1 +1326,1 @@\n-      result = allocate_memory_under_lock(req, in_new_region);\n+      result = allocate_memory_under_lock(req, in_new_region, is_promotion);\n@@ -852,2 +1328,2 @@\n-\n-    while (result == nullptr && tries <= ShenandoahFullGCThreshold) {\n+    while (result == nullptr &&\n+           ((shenandoah_policy()->get_fullgc_count() == original_fullgc_count) || (tries <= ShenandoahOOMGCRetries))) {\n@@ -856,1 +1332,1 @@\n-      result = allocate_memory_under_lock(req, in_new_region);\n+      result = allocate_memory_under_lock(req, in_new_region, is_promotion);\n@@ -858,1 +1334,0 @@\n-\n@@ -861,1 +1336,1 @@\n-    result = allocate_memory_under_lock(req, in_new_region);\n+    result = allocate_memory_under_lock(req, in_new_region, is_promotion);\n@@ -868,0 +1343,5 @@\n+    regulator_thread()->notify_heap_changed();\n+  }\n+\n+  if (result == nullptr) {\n+    req.set_actual_size(0);\n@@ -870,0 +1350,4 @@\n+  \/\/ This is called regardless of the outcome of the allocation to account\n+  \/\/ for any waste created by retiring regions with this request.\n+  increase_used(req);\n+\n@@ -879,2 +1363,0 @@\n-      notify_mutator_alloc_words(actual, false);\n-\n@@ -887,2 +1369,0 @@\n-    } else {\n-      increase_used(actual*HeapWordSize);\n@@ -895,3 +1375,182 @@\n-HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest& req, bool& in_new_region) {\n-  ShenandoahHeapLocker locker(lock());\n-  return _free_set->allocate(req, in_new_region);\n+HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest& req, bool& in_new_region, bool is_promotion) {\n+  bool try_smaller_lab_size = false;\n+  size_t smaller_lab_size;\n+  {\n+    \/\/ promotion_eligible pertains only to PLAB allocations, denoting that the PLAB is allowed to allocate for promotions.\n+    bool promotion_eligible = false;\n+    bool allow_allocation = true;\n+    bool plab_alloc = false;\n+    size_t requested_bytes = req.size() * HeapWordSize;\n+    HeapWord* result = nullptr;\n+    ShenandoahHeapLocker locker(lock());\n+    Thread* thread = Thread::current();\n+\n+    if (mode()->is_generational()) {\n+      if (req.affiliation() == YOUNG_GENERATION) {\n+        if (req.is_mutator_alloc()) {\n+          size_t young_words_available = young_generation()->available() \/ HeapWordSize;\n+          if (ShenandoahElasticTLAB && req.is_lab_alloc() && (req.min_size() < young_words_available)) {\n+            \/\/ Allow ourselves to try a smaller lab size even if requested_bytes <= young_available.  We may need a smaller\n+            \/\/ lab size because young memory has become too fragmented.\n+            try_smaller_lab_size = true;\n+            smaller_lab_size = (young_words_available < req.size())? young_words_available: req.size();\n+          } else if (req.size() > young_words_available) {\n+            \/\/ Can't allocate because even min_size() is larger than remaining young_available\n+            log_info(gc, ergo)(\"Unable to shrink %s alloc request of minimum size: \" SIZE_FORMAT\n+                               \", young words available: \" SIZE_FORMAT, req.type_string(),\n+                               HeapWordSize * (req.is_lab_alloc()? req.min_size(): req.size()), young_words_available);\n+            return nullptr;\n+          }\n+        }\n+      } else {                    \/\/ reg.affiliation() == OLD_GENERATION\n+        assert(req.type() != ShenandoahAllocRequest::_alloc_gclab, \"GCLAB pertains only to young-gen memory\");\n+        if (req.type() ==  ShenandoahAllocRequest::_alloc_plab) {\n+          plab_alloc = true;\n+          size_t promotion_avail = get_promoted_reserve();\n+          size_t promotion_expended = get_promoted_expended();\n+          if (promotion_expended + requested_bytes > promotion_avail) {\n+            promotion_avail = 0;\n+            if (get_old_evac_reserve() == 0) {\n+              \/\/ There are no old-gen evacuations in this pass.  There's no value in creating a plab that cannot\n+              \/\/ be used for promotions.\n+              allow_allocation = false;\n+            }\n+          } else {\n+            promotion_avail = promotion_avail - (promotion_expended + requested_bytes);\n+            promotion_eligible = true;\n+          }\n+        } else if (is_promotion) {\n+          \/\/ This is a shared alloc for promotion\n+          size_t promotion_avail = get_promoted_reserve();\n+          size_t promotion_expended = get_promoted_expended();\n+          if (promotion_expended + requested_bytes > promotion_avail) {\n+            promotion_avail = 0;\n+          } else {\n+            promotion_avail = promotion_avail - (promotion_expended + requested_bytes);\n+          }\n+          if (promotion_avail == 0) {\n+            \/\/ We need to reserve the remaining memory for evacuation.  Reject this allocation.  The object will be\n+            \/\/ evacuated to young-gen memory and promoted during a future GC pass.\n+            return nullptr;\n+          }\n+          \/\/ Else, we'll allow the allocation to proceed.  (Since we hold heap lock, the tested condition remains true.)\n+        } else {\n+          \/\/ This is a shared allocation for evacuation.  Memory has already been reserved for this purpose.\n+        }\n+      }\n+    } \/\/ This ends the is_generational() block\n+\n+    \/\/ First try the original request.  If TLAB request size is greater than available, allocate() will attempt to downsize\n+    \/\/ request to fit within available memory.\n+    result = (allow_allocation)? _free_set->allocate(req, in_new_region): nullptr;\n+    if (result != nullptr) {\n+      if (req.is_old()) {\n+        ShenandoahThreadLocalData::reset_plab_promoted(thread);\n+        if (req.is_gc_alloc()) {\n+          bool disable_plab_promotions = false;\n+          if (req.type() ==  ShenandoahAllocRequest::_alloc_plab) {\n+            if (promotion_eligible) {\n+              size_t actual_size = req.actual_size() * HeapWordSize;\n+              \/\/ The actual size of the allocation may be larger than the requested bytes (due to alignment on card boundaries).\n+              \/\/ If this puts us over our promotion budget, we need to disable future PLAB promotions for this thread.\n+              if (get_promoted_expended() + actual_size <= get_promoted_reserve()) {\n+                \/\/ Assume the entirety of this PLAB will be used for promotion.  This prevents promotion from overreach.\n+                \/\/ When we retire this plab, we'll unexpend what we don't really use.\n+                ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+                expend_promoted(actual_size);\n+                assert(get_promoted_expended() <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+                ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, actual_size);\n+              } else {\n+                disable_plab_promotions = true;\n+              }\n+            } else {\n+              disable_plab_promotions = true;\n+            }\n+            if (disable_plab_promotions) {\n+              \/\/ Disable promotions in this thread because entirety of this PLAB must be available to hold old-gen evacuations.\n+              ShenandoahThreadLocalData::disable_plab_promotions(thread);\n+              ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, 0);\n+            }\n+          } else if (is_promotion) {\n+            \/\/ Shared promotion.  Assume size is requested_bytes.\n+            expend_promoted(requested_bytes);\n+            assert(get_promoted_expended() <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+          }\n+        }\n+\n+        \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+        \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+        \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+        \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+        \/\/\n+        \/\/ objects being \"concurrently\" allocated:\n+        \/\/    [-----a------][-----b-----][--------------c------------------]\n+        \/\/            [---- card table memory range --------------]\n+        \/\/\n+        \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that allocation of object a\n+        \/\/   wants to set the starts-object, first-start, and last-start attributes of the preceding card region.\n+        \/\/   allocation of object b wants to set the starts-object, first-start, and last-start attributes of this card region.\n+        \/\/   allocation of object c also wants to set the starts-object, first-start, and last-start attributes of this\n+        \/\/   card region.\n+        \/\/\n+        \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as\n+        \/\/ last-start representing object b while first-start represents object c.  This is why we need to require all\n+        \/\/ register_object() invocations to be \"mutually exclusive\" with respect to each card's memory range.\n+        ShenandoahHeap::heap()->card_scan()->register_object(result);\n+      }\n+    } else {\n+      \/\/ The allocation failed.  If this was a plab allocation, We've already retired it and no longer have a plab.\n+      if (req.is_old() && req.is_gc_alloc() && (req.type() == ShenandoahAllocRequest::_alloc_plab)) {\n+        \/\/ We don't need to disable PLAB promotions because there is no PLAB.  We leave promotions enabled because\n+        \/\/ this allows the surrounding infrastructure to retry alloc_plab_slow() with a smaller PLAB size.\n+        ShenandoahThreadLocalData::set_plab_preallocated_promoted(thread, 0);\n+      }\n+    }\n+    if ((result != nullptr) || !try_smaller_lab_size) {\n+      return result;\n+    }\n+    \/\/ else, fall through to try_smaller_lab_size\n+  } \/\/ This closes the block that holds the heap lock, releasing the lock.\n+\n+  \/\/ We failed to allocate the originally requested lab size.  Let's see if we can allocate a smaller lab size.\n+  if (req.size() == smaller_lab_size) {\n+    \/\/ If we were already trying to allocate min size, no value in attempting to repeat the same.  End the recursion.\n+    return nullptr;\n+  }\n+\n+  \/\/ We arrive here if the tlab allocation request can be resized to fit within young_available\n+  assert((req.affiliation() == YOUNG_GENERATION) && req.is_lab_alloc() && req.is_mutator_alloc() &&\n+         (smaller_lab_size < req.size()), \"Only shrink allocation request size for TLAB allocations\");\n+\n+  \/\/ By convention, ShenandoahAllocationRequest is primarily read-only.  The only mutable instance data is represented by\n+  \/\/ actual_size(), which is overwritten with the size of the allocaion when the allocation request is satisfied.  We use a\n+  \/\/ recursive call here rather than introducing new methods to mutate the existing ShenandoahAllocationRequest argument.\n+  \/\/ Mutation of the existing object might result in astonishing results if calling contexts assume the content of immutable\n+  \/\/ fields remain constant.  The original TLAB allocation request was for memory that exceeded the current capacity.  We'll\n+  \/\/ attempt to allocate a smaller TLAB.  If this is successful, we'll update actual_size() of our incoming\n+  \/\/ ShenandoahAllocRequest.  If the recursive request fails, we'll simply return nullptr.\n+\n+  \/\/ Note that we've relinquished the HeapLock and some other thread may perform additional allocation before our recursive\n+  \/\/ call reacquires the lock.  If that happens, we will need another recursive call to further reduce the size of our request\n+  \/\/ for each time another thread allocates young memory during the brief intervals that the heap lock is available to\n+  \/\/ interfering threads.  We expect this interference to be rare.  The recursion bottoms out when young_available is\n+  \/\/ smaller than req.min_size().  The inner-nested call to allocate_memory_under_lock() uses the same min_size() value\n+  \/\/ as this call, but it uses a preferred size() that is smaller than our preferred size, and is no larger than what we most\n+  \/\/ recently saw as the memory currently available within the young generation.\n+\n+  \/\/ TODO: At the expense of code clarity, we could rewrite this recursive solution to use iteration.  We need at most one\n+  \/\/ extra instance of the ShenandoahAllocRequest, which we can re-initialize multiple times inside a loop, with one iteration\n+  \/\/ of the loop required for each time the existing solution would recurse.  An iterative solution would be more efficient\n+  \/\/ in CPU time and stack memory utilization.  The expectation is that it is very rare that we would recurse more than once\n+  \/\/ so making this change is not currently seen as a high priority.\n+\n+  ShenandoahAllocRequest smaller_req = ShenandoahAllocRequest::for_tlab(req.min_size(), smaller_lab_size);\n+\n+  \/\/ Note that shrinking the preferred size gets us past the gatekeeper that checks whether there's available memory to\n+  \/\/ satisfy the allocation request.  The reality is the actual TLAB size is likely to be even smaller, because it will\n+  \/\/ depend on how much memory is available within mutator regions that are not yet fully used.\n+  HeapWord* result = allocate_memory_under_lock(smaller_req, in_new_region, is_promotion);\n+  if (result != nullptr) {\n+    req.set_actual_size(smaller_req.actual_size());\n+  }\n+  return result;\n@@ -903,1 +1562,1 @@\n-  return allocate_memory(req);\n+  return allocate_memory(req, false);\n@@ -912,2 +1571,2 @@\n-  if (heuristics()->can_unload_classes()) {\n-    ShenandoahHeuristics* h = heuristics();\n+  ShenandoahHeuristics* h = global_generation()->heuristics();\n+  if (h->can_unload_classes()) {\n@@ -992,0 +1651,1 @@\n+\n@@ -997,0 +1657,79 @@\n+      if (_sh->check_cancelled_gc_and_yield(_concurrent)) {\n+        break;\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Unlike ShenandoahEvacuationTask, this iterates over all regions rather than just the collection set.\n+\/\/ This is needed in order to promote humongous start regions if age() >= tenure threshold.\n+class ShenandoahGenerationalEvacuationTask : public WorkerTask {\n+private:\n+  ShenandoahHeap* const _sh;\n+  ShenandoahRegionIterator *_regions;\n+  bool _concurrent;\n+public:\n+  ShenandoahGenerationalEvacuationTask(ShenandoahHeap* sh,\n+                                       ShenandoahRegionIterator* iterator,\n+                                       bool concurrent) :\n+    WorkerTask(\"Shenandoah Evacuation\"),\n+    _sh(sh),\n+    _regions(iterator),\n+    _concurrent(concurrent)\n+  {}\n+\n+  void work(uint worker_id) {\n+    if (_concurrent) {\n+      ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahEvacOOMScope oom_evac_scope;\n+      do_work();\n+    } else {\n+      ShenandoahParallelWorkerSession worker_session(worker_id);\n+      ShenandoahEvacOOMScope oom_evac_scope;\n+      do_work();\n+    }\n+  }\n+\n+private:\n+  void do_work() {\n+    ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);\n+    ShenandoahHeapRegion* r;\n+    ShenandoahMarkingContext* const ctx = ShenandoahHeap::heap()->marking_context();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t old_garbage_threshold = (region_size_bytes * ShenandoahOldGarbageThreshold) \/ 100;\n+    while ((r = _regions->next()) != nullptr) {\n+      log_debug(gc)(\"GenerationalEvacuationTask do_work(), looking at %s region \" SIZE_FORMAT \", (age: %d) [%s, %s, %s]\",\n+                    r->is_old()? \"old\": r->is_young()? \"young\": \"free\", r->index(), r->age(),\n+                    r->is_active()? \"active\": \"inactive\",\n+                    r->is_humongous()? (r->is_humongous_start()? \"humongous_start\": \"humongous_continuation\"): \"regular\",\n+                    r->is_cset()? \"cset\": \"not-cset\");\n+\n+      if (r->is_cset()) {\n+        assert(r->has_live(), \"Region \" SIZE_FORMAT \" should have been reclaimed early\", r->index());\n+        _sh->marked_object_iterate(r, &cl);\n+        if (ShenandoahPacing) {\n+          _sh->pacer()->report_evac(r->used() >> LogHeapWordSize);\n+        }\n+      } else if (r->is_young() && r->is_active() && (r->age() >= InitialTenuringThreshold)) {\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        if (r->is_humongous_start()) {\n+          \/\/ We promote humongous_start regions along with their affiliated continuations during evacuation rather than\n+          \/\/ doing this work during a safepoint.  We cannot put humongous regions into the collection set because that\n+          \/\/ triggers the load-reference barrier (LRB) to copy on reference fetch.\n+          r->promote_humongous();\n+        } else if (r->is_regular() && (r->garbage_before_padded_for_promote() < old_garbage_threshold) && (r->get_top_before_promote() == tams)) {\n+          \/\/ Likewise, we cannot put promote-in-place regions into the collection set because that would also trigger\n+          \/\/ the LRB to copy on reference fetch.\n+          r->promote_in_place();\n+        }\n+        \/\/ Aged humongous continuation regions are handled with their start region.  If an aged regular region has\n+        \/\/ more garbage than ShenandoahOldGarbageTrheshold, we'll promote by evacuation.  If there is room for evacuation\n+        \/\/ in this cycle, the region will be in the collection set.  If there is not room, the region will be promoted\n+        \/\/ by evacuation in some future GC cycle.\n+\n+        \/\/ If an aged regular region has received allocations during the current cycle, we do not promote because the\n+        \/\/ newly allocated objects do not have appropriate age; this region's age will be reset to zero at end of cycle.\n+      }\n+      \/\/ else, region is free, or OLD, or not in collection set, or humongous_continuation,\n+      \/\/ or is young humongous_start that is too young to be promoted\n@@ -1006,2 +1745,8 @@\n-  ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n-  workers()->run_task(&task);\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahRegionIterator regions;\n+    ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent);\n+    workers()->run_task(&task);\n+  } else {\n+    ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n+    workers()->run_task(&task);\n+  }\n@@ -1024,4 +1769,7 @@\n-  st->print_cr(\"EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned\");\n-  st->print_cr(\"BTE=bottom\/top\/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data\");\n-  st->print_cr(\"R=root, CP=critical pins, TAMS=top-at-mark-start, UWM=update watermark\");\n-  st->print_cr(\"SN=alloc sequence number\");\n+  st->print_cr(\"Region state: EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HP=pinned humongous start\");\n+  st->print_cr(\"              HC=humongous continuation, CS=collection set, TR=trash, P=pinned, CSP=pinned collection set\");\n+  st->print_cr(\"BTE=bottom\/top\/end, TAMS=top-at-mark-start\");\n+  st->print_cr(\"UWM=update watermark, U=used\");\n+  st->print_cr(\"T=TLAB allocs, G=GCLAB allocs\");\n+  st->print_cr(\"S=shared allocs, L=live data\");\n+  st->print_cr(\"CP=critical pins\");\n@@ -1034,1 +1782,1 @@\n-void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {\n+size_t ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {\n@@ -1054,0 +1802,1 @@\n+  return required_regions;\n@@ -1063,0 +1812,4 @@\n+\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+    assert(plab->words_remaining() == 0, \"PLAB should not need retirement\");\n@@ -1078,0 +1831,11 @@\n+\n+    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+    assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+\n+    \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n+    \/\/  1. We need to make the plab memory parseable by remembered-set scanning.\n+    \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n+    ShenandoahHeap::heap()->retire_plab(plab, thread);\n+    if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n+      ShenandoahThreadLocalData::set_plab_size(thread, 0);\n+    }\n@@ -1135,0 +1899,31 @@\n+class ShenandoahTagGCLABClosure : public ThreadClosure {\n+public:\n+  void do_thread(Thread* thread) {\n+    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n+    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n+    if (gclab->words_remaining() > 0) {\n+      ShenandoahHeapRegion* r = ShenandoahHeap::heap()->heap_region_containing(gclab->allocate(0));\n+      r->set_young_lab_flag();\n+    }\n+  }\n+};\n+\n+void ShenandoahHeap::set_young_lab_region_flags() {\n+  if (!UseTLAB) {\n+    return;\n+  }\n+  for (size_t i = 0; i < _num_regions; i++) {\n+    _regions[i]->clear_young_lab_flags();\n+  }\n+  ShenandoahTagGCLABClosure cl;\n+  workers()->threads_do(&cl);\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n+    cl.do_thread(t);\n+    ThreadLocalAllocBuffer& tlab = t->tlab();\n+    if (tlab.end() != nullptr) {\n+      ShenandoahHeapRegion* r = heap_region_containing(tlab.start());\n+      r->set_young_lab_flag();\n+    }\n+  }\n+}\n+\n@@ -1138,3 +1933,7 @@\n-    \/\/ With Elastic TLABs, return the max allowed size, and let the allocation path\n-    \/\/ figure out the safe size for current allocation.\n-    return ShenandoahHeapRegion::max_tlab_size_bytes();\n+    if (mode()->is_generational()) {\n+      return MIN2(ShenandoahHeapRegion::max_tlab_size_bytes(), young_generation()->available());\n+    } else {\n+      \/\/ With Elastic TLABs, return the max allowed size, and let the allocation path\n+      \/\/ figure out the safe size for current allocation.\n+      return ShenandoahHeapRegion::max_tlab_size_bytes();\n+    }\n@@ -1183,0 +1982,4 @@\n+  if (_shenandoah_policy->is_at_shutdown()) {\n+    return;\n+  }\n+\n@@ -1184,0 +1987,1 @@\n+  tcl->do_thread(_regulator_thread);\n@@ -1204,0 +2008,3 @@\n+\n+    evac_tracker()->print_global_on(&ls);\n+\n@@ -1205,0 +2012,18 @@\n+    ls.cr();\n+  }\n+}\n+\n+void ShenandoahHeap::on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  set_gc_cause(cause);\n+  set_gc_generation(generation);\n+\n+  shenandoah_policy()->record_cycle_start();\n+  generation->heuristics()->record_cycle_start();\n+}\n+\n+void ShenandoahHeap::on_cycle_end(ShenandoahGeneration* generation) {\n+  generation->heuristics()->record_cycle_end();\n+  if (mode()->is_generational() && (generation->is_global() || upgraded_to_full())) {\n+    \/\/ If we just completed a GLOBAL GC, claim credit for completion of young-gen and old-gen GC as well\n+    young_generation()->heuristics()->record_cycle_end();\n+    old_generation()->heuristics()->record_cycle_end();\n@@ -1206,0 +2031,1 @@\n+  set_gc_cause(GCCause::_no_gc);\n@@ -1529,23 +2355,0 @@\n-class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-    if (r->is_active()) {\n-      \/\/ Check if region needs updating its TAMS. We have updated it already during concurrent\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n-      if (_ctx->top_at_mark_start(r) != r->top()) {\n-        _ctx->capture_top_at_mark_start(r);\n-      }\n-    } else {\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should already have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n@@ -1567,99 +2370,0 @@\n-class ShenandoahResetUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahResetUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (r->is_active()) {\n-      \/\/ Reset live data and set TAMS optimistically. We would recheck these under the pause\n-      \/\/ anyway to capture any updates that happened since now.\n-      r->clear_live_data();\n-      _ctx->capture_top_at_mark_start(r);\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::prepare_gc() {\n-  reset_mark_bitmap();\n-\n-  ShenandoahResetUpdateRegionStateClosure cl;\n-  parallel_heap_region_iterate(&cl);\n-}\n-\n-class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-  ShenandoahHeapLock* const _lock;\n-\n-public:\n-  ShenandoahFinalMarkUpdateRegionStateClosure() :\n-    _ctx(ShenandoahHeap::heap()->complete_marking_context()), _lock(ShenandoahHeap::heap()->lock()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (r->is_active()) {\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-\n-      \/\/ We are about to select the collection set, make sure it knows about\n-      \/\/ current pinning status. Also, this allows trashing more regions that\n-      \/\/ now have their pinning status dropped.\n-      if (r->is_pinned()) {\n-        if (r->pin_count() == 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_unpinned();\n-        }\n-      } else {\n-        if (r->pin_count() > 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_pinned();\n-        }\n-      }\n-\n-      \/\/ Remember limit for updating refs. It's guaranteed that we get no\n-      \/\/ from-space-refs written from here on.\n-      r->set_update_watermark_at_safepoint(r->top());\n-    } else {\n-      assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-void ShenandoahHeap::prepare_regions_and_collection_set(bool concurrent) {\n-  assert(!is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_update_region_states :\n-                                         ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n-    ShenandoahFinalMarkUpdateRegionStateClosure cl;\n-    parallel_heap_region_iterate(&cl);\n-\n-    assert_pinned_region_status();\n-  }\n-\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::choose_cset :\n-                                         ShenandoahPhaseTimings::degen_gc_choose_cset);\n-    ShenandoahHeapLocker locker(lock());\n-    _collection_set->clear();\n-    heuristics()->choose_collection_set(_collection_set);\n-  }\n-\n-  {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_rebuild_freeset :\n-                                         ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n-    ShenandoahHeapLocker locker(lock());\n-    _free_set->rebuild();\n-  }\n-}\n-\n@@ -1676,1 +2380,1 @@\n-  ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n+  active_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n@@ -1707,4 +2411,48 @@\n-void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {\n-  assert(!has_forwarded_objects(), \"Not expected before\/after mark phase\");\n-  set_gc_state_mask(MARKING, in_progress);\n-  ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);\n+void ShenandoahHeap::set_evacuation_reserve_quantities(bool is_valid) {\n+  _has_evacuation_reserve_quantities = is_valid;\n+}\n+\n+void ShenandoahHeap::set_concurrent_young_mark_in_progress(bool in_progress) {\n+  if (has_forwarded_objects()) {\n+    set_gc_state_mask(YOUNG_MARKING | UPDATEREFS, in_progress);\n+  } else {\n+    set_gc_state_mask(YOUNG_MARKING, in_progress);\n+  }\n+\n+  manage_satb_barrier(in_progress);\n+}\n+\n+void ShenandoahHeap::set_concurrent_old_mark_in_progress(bool in_progress) {\n+  if (has_forwarded_objects()) {\n+    set_gc_state_mask(OLD_MARKING | UPDATEREFS, in_progress);\n+  } else {\n+    set_gc_state_mask(OLD_MARKING, in_progress);\n+  }\n+\n+  manage_satb_barrier(in_progress);\n+}\n+\n+void ShenandoahHeap::set_prepare_for_old_mark_in_progress(bool in_progress) {\n+  \/\/ Unlike other set-gc-state functions, this may happen outside safepoint.\n+  \/\/ Is only set and queried by control thread, so no coherence issues.\n+  _prepare_for_old_mark = in_progress;\n+}\n+\n+void ShenandoahHeap::set_aging_cycle(bool in_progress) {\n+  _is_aging_cycle.set_cond(in_progress);\n+}\n+\n+void ShenandoahHeap::manage_satb_barrier(bool active) {\n+  if (is_concurrent_mark_in_progress()) {\n+    \/\/ Ignore request to deactivate barrier while concurrent mark is in progress.\n+    \/\/ Do not attempt to re-activate the barrier if it is already active.\n+    if (active && !ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n+  } else {\n+    \/\/ No concurrent marking is in progress so honor request to deactivate,\n+    \/\/ but only if the barrier is already active.\n+    if (!active && ShenandoahBarrierSet::satb_mark_queue_set().is_active()) {\n+      ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(active, !active);\n+    }\n+  }\n@@ -1743,0 +2491,8 @@\n+void ShenandoahHeap::cancel_concurrent_mark() {\n+  _young_generation->cancel_marking();\n+  _old_generation->cancel_marking();\n+  _global_generation->cancel_marking();\n+\n+  ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+}\n+\n@@ -1748,0 +2504,4 @@\n+    _cancel_requested_time = os::elapsedTime();\n+    if (cause == GCCause::_shenandoah_upgrade_to_full_gc) {\n+      _upgraded_to_full = true;\n+    }\n@@ -1758,1 +2518,1 @@\n-  \/\/ Step 0. Notify policy to disable event recording.\n+  \/\/ Step 1. Notify policy to disable event recording and prevent visiting gc threads during shutdown\n@@ -1761,1 +2521,4 @@\n-  \/\/ Step 1. Notify control thread that we are in shutdown.\n+  \/\/ Step 2. Stop requesting collections.\n+  regulator_thread()->stop();\n+\n+  \/\/ Step 3. Notify control thread that we are in shutdown.\n@@ -1766,1 +2529,1 @@\n-  \/\/ Step 2. Notify GC workers that we are cancelling GC.\n+  \/\/ Step 4. Notify GC workers that we are cancelling GC.\n@@ -1769,1 +2532,1 @@\n-  \/\/ Step 3. Wait until GC worker exits normally.\n+  \/\/ Step 5. Wait until GC worker exits normally.\n@@ -1863,4 +2626,0 @@\n-address ShenandoahHeap::cancelled_gc_addr() {\n-  return (address) ShenandoahHeap::heap()->_cancelled_gc.addr_of();\n-}\n-\n@@ -1871,4 +2630,0 @@\n-size_t ShenandoahHeap::bytes_allocated_since_gc_start() {\n-  return Atomic::load(&_bytes_allocated_since_gc_start);\n-}\n-\n@@ -1876,1 +2631,6 @@\n-  Atomic::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+  if (mode()->is_generational()) {\n+    young_generation()->reset_bytes_allocated_since_gc_start();\n+    old_generation()->reset_bytes_allocated_since_gc_start();\n+  }\n+\n+  global_generation()->reset_bytes_allocated_since_gc_start();\n@@ -1940,2 +2700,4 @@\n-    assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n-           \"Region \" SIZE_FORMAT \" pinning status is inconsistent\", i);\n+    if (active_generation()->contains(r)) {\n+      assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n+             \"Region \" SIZE_FORMAT \" pinning status is inconsistent\", i);\n+    }\n@@ -2001,0 +2763,2 @@\n+  ShenandoahRegionChunkIterator* _work_chunks;\n+\n@@ -2002,1 +2766,2 @@\n-  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions) :\n+  explicit ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions,\n+                                        ShenandoahRegionChunkIterator* work_chunks) :\n@@ -2005,1 +2770,3 @@\n-    _regions(regions) {\n+    _regions(regions),\n+    _work_chunks(work_chunks)\n+  {\n@@ -2012,1 +2779,1 @@\n-      do_work<ShenandoahConcUpdateRefsClosure>();\n+      do_work<ShenandoahConcUpdateRefsClosure>(worker_id);\n@@ -2015,1 +2782,1 @@\n-      do_work<ShenandoahSTWUpdateRefsClosure>();\n+      do_work<ShenandoahSTWUpdateRefsClosure>(worker_id);\n@@ -2021,1 +2788,1 @@\n-  void do_work() {\n+  void do_work(uint worker_id) {\n@@ -2023,0 +2790,10 @@\n+    if (CONCURRENT && (worker_id == 0)) {\n+      \/\/ We ask the first worker to replenish the Mutator free set by moving regions previously reserved to hold the\n+      \/\/ results of evacuation.  These reserves are no longer necessary because evacuation has completed.\n+      size_t cset_regions = _heap->collection_set()->count();\n+      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled, because\n+      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+      _heap->free_set()->move_collector_sets_to_mutator(cset_regions);\n+    }\n+    \/\/ If !CONCURRENT, there's no value in expanding Mutator free set\n+\n@@ -2024,1 +2801,4 @@\n-    ShenandoahMarkingContext* const ctx = _heap->complete_marking_context();\n+    \/\/ We update references for global, old, and young collections.\n+    assert(_heap->active_generation()->is_mark_complete(), \"Expected complete marking\");\n+    ShenandoahMarkingContext* const ctx = _heap->marking_context();\n+    bool is_mixed = _heap->collection_set()->has_old_regions();\n@@ -2028,0 +2808,3 @@\n+\n+      log_debug(gc)(\"ShenandoahUpdateHeapRefsTask::do_work(%u) looking at region \" SIZE_FORMAT, worker_id, r->index());\n+      bool region_progress = false;\n@@ -2029,1 +2812,31 @@\n-        _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n+        if (!_heap->mode()->is_generational() || r->is_young()) {\n+          _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n+          region_progress = true;\n+        } else if (r->is_old()) {\n+          if (_heap->active_generation()->is_global()) {\n+            \/\/ Note that GLOBAL collection is not as effectively balanced as young and mixed cycles.  This is because\n+            \/\/ concurrent GC threads are parceled out entire heap regions of work at a time and there\n+            \/\/ is no \"catchup phase\" consisting of remembered set scanning, during which parcels of work are smaller\n+            \/\/ and more easily distributed more fairly across threads.\n+\n+            \/\/ TODO: Consider an improvement to load balance GLOBAL GC.\n+            _heap->marked_object_oop_iterate(r, &cl, update_watermark);\n+            region_progress = true;\n+          }\n+          \/\/ Otherwise, this is an old region in a young or mixed cycle.  Process it during a second phase, below.\n+          \/\/ Don't bother to report pacing progress in this case.\n+        } else {\n+          \/\/ Because updating of references runs concurrently, it is possible that a FREE inactive region transitions\n+          \/\/ to a non-free active region while this loop is executing.  Whenever this happens, the changing of a region's\n+          \/\/ active status may propagate at a different speed than the changing of the region's affiliation.\n+\n+          \/\/ When we reach this control point, it is because a race has allowed a region's is_active() status to be seen\n+          \/\/ by this thread before the region's affiliation() is seen by this thread.\n+\n+          \/\/ It's ok for this race to occur because the newly transformed region does not have any references to be\n+          \/\/ updated.\n+\n+          assert(r->get_update_watermark() == r->bottom(),\n+                 \"%s Region \" SIZE_FORMAT \" is_active but not recognized as YOUNG or OLD so must be newly transitioned from FREE\",\n+                 r->affiliation_name(), r->index());\n+        }\n@@ -2031,1 +2844,1 @@\n-      if (ShenandoahPacing) {\n+      if (region_progress && ShenandoahPacing) {\n@@ -2039,0 +2852,114 @@\n+\n+    if (_heap->mode()->is_generational() && !_heap->active_generation()->is_global()) {\n+      \/\/ Since this is generational and not GLOBAL, we have to process the remembered set.  There's no remembered\n+      \/\/ set processing if not in generational mode or if GLOBAL mode.\n+\n+      \/\/ After this thread has exhausted its traditional update-refs work, it continues with updating refs within remembered set.\n+      \/\/ The remembered set workload is better balanced between threads, so threads that are \"behind\" can catch up with other\n+      \/\/ threads during this phase, allowing all threads to work more effectively in parallel.\n+      struct ShenandoahRegionChunk assignment;\n+      RememberedScanner* scanner = _heap->card_scan();\n+\n+      while (!_heap->check_cancelled_gc_and_yield(CONCURRENT) && _work_chunks->next(&assignment)) {\n+        \/\/ Keep grabbing next work chunk to process until finished, or asked to yield\n+        ShenandoahHeapRegion* r = assignment._r;\n+        if (r->is_active() && !r->is_cset() && r->is_old()) {\n+          HeapWord* start_of_range = r->bottom() + assignment._chunk_offset;\n+          HeapWord* end_of_range = r->get_update_watermark();\n+          if (end_of_range > start_of_range + assignment._chunk_size) {\n+            end_of_range = start_of_range + assignment._chunk_size;\n+          }\n+\n+          \/\/ Old region in a young cycle or mixed cycle.\n+          if (is_mixed) {\n+            \/\/ TODO: For mixed evac, consider building an old-gen remembered set that allows restricted updating\n+            \/\/ within old-gen HeapRegions.  This remembered set can be constructed by old-gen concurrent marking\n+            \/\/ and augmented by card marking.  For example, old-gen concurrent marking can remember for each old-gen\n+            \/\/ card which other old-gen regions it refers to: none, one-other specifically, multiple-other non-specific.\n+            \/\/ Update-references when _mixed_evac processess each old-gen memory range that has a traditional DIRTY\n+            \/\/ card or if the \"old-gen remembered set\" indicates that this card holds pointers specifically to an\n+            \/\/ old-gen region in the most recent collection set, or if this card holds pointers to other non-specific\n+            \/\/ old-gen heap regions.\n+\n+            if (r->is_humongous()) {\n+              if (start_of_range < end_of_range) {\n+                \/\/ Need to examine both dirty and clean cards during mixed evac.\n+                r->oop_iterate_humongous_slice(&cl, false, start_of_range, assignment._chunk_size, true);\n+              }\n+            } else {\n+              \/\/ Since this is mixed evacuation, old regions that are candidates for collection have not been coalesced\n+              \/\/ and filled.  Use mark bits to find objects that need to be updated.\n+              \/\/\n+              \/\/ Future TODO: establish a second remembered set to identify which old-gen regions point to other old-gen\n+              \/\/ regions which are in the collection set for a particular mixed evacuation.\n+              if (start_of_range < end_of_range) {\n+                HeapWord* p = nullptr;\n+                size_t card_index = scanner->card_index_for_addr(start_of_range);\n+                \/\/ In case last object in my range spans boundary of my chunk, I may need to scan all the way to top()\n+                ShenandoahObjectToOopBoundedClosure<T> objs(&cl, start_of_range, r->top());\n+\n+                \/\/ Any object that begins in a previous range is part of a different scanning assignment.  Any object that\n+                \/\/ starts after end_of_range is also not my responsibility.  (Either allocated during evacuation, so does\n+                \/\/ not hold pointers to from-space, or is beyond the range of my assigned work chunk.)\n+\n+                \/\/ Find the first object that begins in my range, if there is one.\n+                p = start_of_range;\n+                oop obj = cast_to_oop(p);\n+                HeapWord* tams = ctx->top_at_mark_start(r);\n+                if (p >= tams) {\n+                  \/\/ We cannot use ctx->is_marked(obj) to test whether an object begins at this address.  Instead,\n+                  \/\/ we need to use the remembered set crossing map to advance p to the first object that starts\n+                  \/\/ within the enclosing card.\n+\n+                  while (true) {\n+                    HeapWord* first_object = scanner->first_object_in_card(card_index);\n+                    if (first_object != nullptr) {\n+                      p = first_object;\n+                      break;\n+                    } else if (scanner->addr_for_card_index(card_index + 1) < end_of_range) {\n+                      card_index++;\n+                    } else {\n+                      \/\/ Force the loop that follows to immediately terminate.\n+                      p = end_of_range;\n+                      break;\n+                    }\n+                  }\n+                  obj = cast_to_oop(p);\n+                  \/\/ Note: p may be >= end_of_range\n+                } else if (!ctx->is_marked(obj)) {\n+                  p = ctx->get_next_marked_addr(p, tams);\n+                  obj = cast_to_oop(p);\n+                  \/\/ If there are no more marked objects before tams, this returns tams.\n+                  \/\/ Note that tams is either >= end_of_range, or tams is the start of an object that is marked.\n+                }\n+                while (p < end_of_range) {\n+                  \/\/ p is known to point to the beginning of marked object obj\n+                  objs.do_object(obj);\n+                  HeapWord* prev_p = p;\n+                  p += obj->size();\n+                  if (p < tams) {\n+                    p = ctx->get_next_marked_addr(p, tams);\n+                    \/\/ If there are no more marked objects before tams, this returns tams.  Note that tams is\n+                    \/\/ either >= end_of_range, or tams is the start of an object that is marked.\n+                  }\n+                  assert(p != prev_p, \"Lack of forward progress\");\n+                  obj = cast_to_oop(p);\n+                }\n+              }\n+            }\n+          } else {\n+            \/\/ This is a young evac..\n+            if (start_of_range < end_of_range) {\n+              size_t cluster_size =\n+                CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+              size_t clusters = assignment._chunk_size \/ cluster_size;\n+              assert(clusters * cluster_size == assignment._chunk_size, \"Chunk assignment must align on cluster boundaries\");\n+              scanner->process_region_slice(r, assignment._chunk_offset, clusters, end_of_range, &cl, true, worker_id);\n+            }\n+          }\n+          if (ShenandoahPacing && (start_of_range < end_of_range)) {\n+            _heap->pacer()->report_updaterefs(pointer_delta(end_of_range, start_of_range));\n+          }\n+        }\n+      }\n+    }\n@@ -2044,0 +2971,2 @@\n+  uint nworkers = workers()->active_workers();\n+  ShenandoahRegionChunkIterator work_list(nworkers);\n@@ -2046,1 +2975,1 @@\n-    ShenandoahUpdateHeapRefsTask<true> task(&_update_refs_iterator);\n+    ShenandoahUpdateHeapRefsTask<true> task(&_update_refs_iterator, &work_list);\n@@ -2049,1 +2978,1 @@\n-    ShenandoahUpdateHeapRefsTask<false> task(&_update_refs_iterator);\n+    ShenandoahUpdateHeapRefsTask<false> task(&_update_refs_iterator, &work_list);\n@@ -2052,0 +2981,3 @@\n+  if (ShenandoahEnableCardStats && card_scan()!=nullptr) { \/\/ generational check proxy\n+    card_scan()->log_card_stats(nworkers, CARD_STAT_UPDATE_REFS);\n+  }\n@@ -2054,1 +2986,0 @@\n-\n@@ -2057,0 +2988,1 @@\n+  ShenandoahMarkingContext* _ctx;\n@@ -2058,0 +2990,1 @@\n+  bool _is_generational;\n@@ -2060,1 +2993,3 @@\n-  ShenandoahFinalUpdateRefsUpdateRegionStateClosure() : _lock(ShenandoahHeap::heap()->lock()) {}\n+  ShenandoahFinalUpdateRefsUpdateRegionStateClosure(\n+    ShenandoahMarkingContext* ctx) : _ctx(ctx), _lock(ShenandoahHeap::heap()->lock()),\n+                                     _is_generational(ShenandoahHeap::heap()->mode()->is_generational()) { }\n@@ -2063,0 +2998,21 @@\n+\n+    \/\/ Maintenance of region age must follow evacuation in order to account for evacuation allocations within survivor\n+    \/\/ regions.  We consult region age during the subsequent evacuation to determine whether certain objects need to\n+    \/\/ be promoted.\n+    if (_is_generational && r->is_young()) {\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+\n+      \/\/ Allocations move the watermark when top moves.  However compacting\n+      \/\/ objects will sometimes lower top beneath the watermark, after which,\n+      \/\/ attempts to read the watermark will assert out (watermark should not be\n+      \/\/ higher than top).\n+      if (top > tams) {\n+        \/\/ There have been allocations in this region since the start of the cycle.\n+        \/\/ Any objects new to this region must not assimilate elevated age.\n+        r->reset_age();\n+      } else if (ShenandoahHeap::heap()->is_aging_cycle()) {\n+        r->increment_age();\n+      }\n+    }\n+\n@@ -2065,1 +3021,0 @@\n-\n@@ -2092,1 +3047,1 @@\n-    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl;\n+    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl (active_generation()->complete_marking_context());\n@@ -2107,6 +3062,52 @@\n-  {\n-    ShenandoahGCPhase phase(concurrent ?\n-                            ShenandoahPhaseTimings::final_update_refs_rebuild_freeset :\n-                            ShenandoahPhaseTimings::degen_gc_final_update_refs_rebuild_freeset);\n-    ShenandoahHeapLocker locker(lock());\n-    _free_set->rebuild();\n+  ShenandoahGCPhase phase(concurrent ?\n+                          ShenandoahPhaseTimings::final_update_refs_rebuild_freeset :\n+                          ShenandoahPhaseTimings::degen_gc_final_update_refs_rebuild_freeset);\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  ShenandoahHeapLocker locker(lock());\n+  size_t young_cset_regions, old_cset_regions;\n+  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions);\n+\n+  if (mode()->is_generational()) {\n+    assert(verify_generation_usage(true, old_generation()->used_regions(),\n+                                   old_generation()->used(), old_generation()->get_humongous_waste(),\n+                                   true, young_generation()->used_regions(),\n+                                   young_generation()->used(), young_generation()->get_humongous_waste()),\n+           \"Generation accounts are inaccurate\");\n+\n+    \/\/ The computation of bytes_of_allocation_runway_before_gc_trigger is quite conservative so consider all of this\n+    \/\/ available for transfer to old. Note that transfer of humongous regions does not impact available.\n+    size_t allocation_runway = young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    adjust_generation_sizes_for_next_cycle(allocation_runway, young_cset_regions, old_cset_regions);\n+\n+    \/\/ Total old_available may have been expanded to hold anticipated promotions.  We trigger if the fragmented available\n+    \/\/ memory represents more than 16 regions worth of data.  Note that fragmentation may increase when we promote regular\n+    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.  Fragmentation\n+    \/\/ will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n+    \/\/\n+    \/\/ We consider old-gen to have excessive fragmentation if more than 12.5% of old-gen is free memory that resides\n+    \/\/ within partially consumed regions of memory.\n+  }\n+  \/\/ Rebuild free set based on adjusted generation sizes.\n+  _free_set->rebuild(young_cset_regions, old_cset_regions);\n+\n+  if (mode()->is_generational()) {\n+    size_t old_available = old_generation()->available();\n+    size_t old_unaffiliated_available = old_generation()->free_unaffiliated_regions() * region_size_bytes;\n+    size_t old_fragmented_available;\n+    assert(old_available >= old_unaffiliated_available, \"unaffiliated available is a subset of total available\");\n+    old_fragmented_available = old_available - old_unaffiliated_available;\n+\n+    size_t old_capacity = old_generation()->max_capacity();\n+    size_t heap_capacity = capacity();\n+    if ((old_capacity > heap_capacity \/ 8) && (old_fragmented_available > old_capacity \/ 8)) {\n+      ((ShenandoahOldHeuristics *) old_generation()->heuristics())->trigger_old_is_fragmented();\n+    }\n+\n+    size_t old_used = old_generation()->used() + old_generation()->get_humongous_waste();\n+    size_t trigger_threshold = old_generation()->usage_trigger_threshold();\n+    \/\/ Detects unsigned arithmetic underflow\n+    assert(old_used < ShenandoahHeap::heap()->capacity(), \"Old used must be less than heap capacity\");\n+\n+    if (old_used > trigger_threshold) {\n+      ((ShenandoahOldHeuristics *) old_generation()->heuristics())->trigger_old_has_grown();\n+    }\n@@ -2118,0 +3119,1 @@\n+  st->cr();\n@@ -2226,3 +3228,12 @@\n-  _memory_pool = new ShenandoahMemoryPool(this);\n-  _cycle_memory_manager.add_pool(_memory_pool);\n-  _stw_memory_manager.add_pool(_memory_pool);\n+  if (mode()->is_generational()) {\n+    _young_gen_memory_pool = new ShenandoahYoungGenMemoryPool(this);\n+    _old_gen_memory_pool = new ShenandoahOldGenMemoryPool(this);\n+    _cycle_memory_manager.add_pool(_young_gen_memory_pool);\n+    _cycle_memory_manager.add_pool(_old_gen_memory_pool);\n+    _stw_memory_manager.add_pool(_young_gen_memory_pool);\n+    _stw_memory_manager.add_pool(_old_gen_memory_pool);\n+  } else {\n+    _memory_pool = new ShenandoahMemoryPool(this);\n+    _cycle_memory_manager.add_pool(_memory_pool);\n+    _stw_memory_manager.add_pool(_memory_pool);\n+  }\n@@ -2240,1 +3251,6 @@\n-  memory_pools.append(_memory_pool);\n+  if (mode()->is_generational()) {\n+    memory_pools.append(_young_gen_memory_pool);\n+    memory_pools.append(_old_gen_memory_pool);\n+  } else {\n+    memory_pools.append(_memory_pool);\n+  }\n@@ -2245,1 +3261,1 @@\n-  return _memory_pool->get_memory_usage();\n+  return MemoryUsage(_initial_size, used(), committed(), max_capacity());\n@@ -2283,0 +3299,1 @@\n+\n@@ -2310,0 +3327,104 @@\n+\n+void ShenandoahHeap::transfer_old_pointers_from_satb() {\n+  _old_generation->transfer_pointers_from_satb();\n+}\n+\n+template<>\n+void ShenandoahGenerationRegionClosure<YOUNG>::heap_region_do(ShenandoahHeapRegion* region) {\n+  \/\/ Visit young and free regions\n+  if (!region->is_old()) {\n+    _cl->heap_region_do(region);\n+  }\n+}\n+\n+template<>\n+void ShenandoahGenerationRegionClosure<OLD>::heap_region_do(ShenandoahHeapRegion* region) {\n+  \/\/ Visit old and free regions\n+  if (!region->is_young()) {\n+    _cl->heap_region_do(region);\n+  }\n+}\n+\n+template<>\n+void ShenandoahGenerationRegionClosure<GLOBAL_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n+  _cl->heap_region_do(region);\n+}\n+\n+template<>\n+void ShenandoahGenerationRegionClosure<GLOBAL_NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n+  _cl->heap_region_do(region);\n+}\n+\n+bool ShenandoahHeap::verify_generation_usage(bool verify_old, size_t old_regions, size_t old_bytes, size_t old_waste,\n+                                             bool verify_young, size_t young_regions, size_t young_bytes, size_t young_waste) {\n+  size_t tally_old_regions = 0;\n+  size_t tally_old_bytes = 0;\n+  size_t tally_old_waste = 0;\n+  size_t tally_young_regions = 0;\n+  size_t tally_young_bytes = 0;\n+  size_t tally_young_waste = 0;\n+\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion* r = get_region(i);\n+    if (r->is_old()) {\n+      tally_old_regions++;\n+      tally_old_bytes += r->used();\n+      if (r->is_humongous()) {\n+        ShenandoahHeapRegion* start = r->humongous_start_region();\n+        HeapWord* obj_addr = start->bottom();\n+        oop obj = cast_to_oop(obj_addr);\n+        size_t word_size = obj->size();\n+        HeapWord* end_addr = obj_addr + word_size;\n+        if (end_addr <= r->end()) {\n+          tally_old_waste += (r->end() - end_addr) * HeapWordSize;\n+        }\n+      }\n+    } else if (r->is_young()) {\n+      tally_young_regions++;\n+      tally_young_bytes += r->used();\n+      if (r->is_humongous()) {\n+        ShenandoahHeapRegion* start = r->humongous_start_region();\n+        HeapWord* obj_addr = start->bottom();\n+        oop obj = cast_to_oop(obj_addr);\n+        size_t word_size = obj->size();\n+        HeapWord* end_addr = obj_addr + word_size;\n+        if (end_addr <= r->end()) {\n+          tally_young_waste += (r->end() - end_addr) * HeapWordSize;\n+        }\n+      }\n+    }\n+  }\n+  if (verify_young &&\n+      ((young_regions != tally_young_regions) || (young_bytes != tally_young_bytes) || (young_waste != tally_young_waste))) {\n+    return false;\n+  } else if (verify_old &&\n+             ((old_regions != tally_old_regions) || (old_bytes != tally_old_bytes) || (old_waste != tally_old_waste))) {\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n+ShenandoahGeneration* ShenandoahHeap::generation_for(ShenandoahAffiliation affiliation) const {\n+  if (!mode()->is_generational()) {\n+    return global_generation();\n+  } else if (affiliation == YOUNG_GENERATION) {\n+    return young_generation();\n+  } else if (affiliation == OLD_GENERATION) {\n+    return old_generation();\n+  }\n+\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+void ShenandoahHeap::log_heap_status(const char* msg) const {\n+  if (mode()->is_generational()) {\n+    young_generation()->log_status(msg);\n+    old_generation()->log_status(msg);\n+  } else {\n+    global_generation()->log_status(msg);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1420,"deletions":299,"binary":false,"changes":1719,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -36,0 +37,3 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n@@ -39,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n@@ -46,0 +51,1 @@\n+class PLAB;\n@@ -48,0 +54,1 @@\n+class ShenandoahRegulatorThread;\n@@ -50,0 +57,3 @@\n+class ShenandoahGeneration;\n+class ShenandoahYoungGeneration;\n+class ShenandoahOldGeneration;\n@@ -51,0 +61,1 @@\n+class ShenandoahOldHeuristics;\n@@ -52,1 +63,0 @@\n-class ShenandoahMode;\n@@ -62,0 +72,1 @@\n+class ShenandoahMode;\n@@ -111,0 +122,10 @@\n+template<ShenandoahGenerationType GENERATION>\n+class ShenandoahGenerationRegionClosure : public ShenandoahHeapRegionClosure {\n+ public:\n+  explicit ShenandoahGenerationRegionClosure(ShenandoahHeapRegionClosure* cl) : _cl(cl) {}\n+  void heap_region_do(ShenandoahHeapRegion* r);\n+  virtual bool is_thread_safe() { return _cl->is_thread_safe(); }\n+ private:\n+  ShenandoahHeapRegionClosure* _cl;\n+};\n+\n@@ -128,0 +149,1 @@\n+  friend class ShenandoahOldGC;\n@@ -136,0 +158,4 @@\n+  ShenandoahGeneration* _gc_generation;\n+\n+  \/\/ true iff we are concurrently coalescing and filling old-gen HeapRegions\n+  bool _prepare_for_old_mark;\n@@ -142,0 +168,15 @@\n+  ShenandoahGeneration* active_generation() const {\n+    \/\/ last or latest generation might be a better name here.\n+    return _gc_generation;\n+  }\n+\n+  void set_gc_generation(ShenandoahGeneration* generation) {\n+    _gc_generation = generation;\n+  }\n+\n+  ShenandoahOldHeuristics* old_heuristics();\n+\n+  bool doing_mixed_evacuations();\n+  bool is_old_bitmap_stable() const;\n+  bool is_gc_generation_young() const;\n+\n@@ -153,2 +194,1 @@\n-  void initialize_mode();\n-  void initialize_heuristics();\n+  void initialize_heuristics_generations();\n@@ -168,0 +208,3 @@\n+  bool verify_generation_usage(bool verify_old, size_t old_regions, size_t old_bytes, size_t old_waste,\n+                               bool verify_young, size_t young_regions, size_t young_bytes, size_t young_waste);\n+\n@@ -178,0 +221,8 @@\n+           size_t _promotion_potential;\n+           size_t _promotion_in_place_potential;\n+           size_t _pad_for_promote_in_place;    \/\/ bytes of filler\n+           size_t _promotable_humongous_regions;\n+           size_t _promotable_humongous_usage;\n+           size_t _regular_regions_promoted_in_place;\n+           size_t _regular_usage_promoted_in_place;\n+\n@@ -180,1 +231,0 @@\n-  volatile size_t _used;\n@@ -182,1 +232,0 @@\n-  volatile size_t _bytes_allocated_since_gc_start;\n@@ -185,0 +234,2 @@\n+  void increase_used(const ShenandoahAllocRequest& req);\n+\n@@ -186,3 +237,4 @@\n-  void increase_used(size_t bytes);\n-  void decrease_used(size_t bytes);\n-  void set_used(size_t bytes);\n+  void increase_used(ShenandoahGeneration* generation, size_t bytes);\n+  void decrease_used(ShenandoahGeneration* generation, size_t bytes);\n+  void increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n+  void decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n@@ -192,1 +244,0 @@\n-  void increase_allocated(size_t bytes);\n@@ -194,1 +245,0 @@\n-  size_t bytes_allocated_since_gc_start();\n@@ -230,0 +280,1 @@\n+  uint8_t* _affiliations;       \/\/ Holds array of enum ShenandoahAffiliation, including FREE status in non-generational mode\n@@ -247,0 +298,2 @@\n+  inline ShenandoahMmuTracker* const mmu_tracker() { return &_mmu_tracker; };\n+\n@@ -261,2 +314,2 @@\n-    \/\/ Heap is under marking: needs SATB barriers.\n-    MARKING_BITPOS    = 1,\n+    \/\/ Young regions are under marking: needs SATB barriers.\n+    YOUNG_MARKING_BITPOS    = 1,\n@@ -272,0 +325,3 @@\n+\n+    \/\/ Old regions are under marking, still need SATB barriers.\n+    OLD_MARKING_BITPOS = 5\n@@ -277,1 +333,1 @@\n-    MARKING       = 1 << MARKING_BITPOS,\n+    YOUNG_MARKING = 1 << YOUNG_MARKING_BITPOS,\n@@ -281,0 +337,1 @@\n+    OLD_MARKING   = 1 << OLD_MARKING_BITPOS\n@@ -291,0 +348,43 @@\n+  \/\/ TODO: Revisit the following comment.  It may not accurately represent the true behavior when evacuations fail due to\n+  \/\/ difficulty finding memory to hold evacuated objects.\n+  \/\/\n+  \/\/ Note that the typical total expenditure on evacuation is less than the associated evacuation reserve because we generally\n+  \/\/ reserve ShenandoahEvacWaste (> 1.0) times the anticipated evacuation need.  In the case that there is an excessive amount\n+  \/\/ of waste, it may be that one thread fails to grab a new GCLAB, this does not necessarily doom the associated evacuation\n+  \/\/ effort.  If this happens, the requesting thread blocks until some other thread manages to evacuate the offending object.\n+  \/\/ Only after \"all\" threads fail to evacuate an object do we consider the evacuation effort to have failed.\n+\n+  \/\/ How many full-gc cycles have been completed?\n+  volatile size_t _completed_fullgc_cycles;\n+\n+  size_t _promoted_reserve;            \/\/ Bytes reserved within old-gen to hold the results of promotion\n+  volatile size_t _promoted_expended;  \/\/ Bytes of old-gen memory expended on promotions\n+\n+  \/\/ Allocation of old GCLABs (aka PLABs) assures that _old_evac_expended + request-size < _old_evac_reserved.  If the allocation\n+  \/\/  is authorized, increment _old_evac_expended by request size.  This allocation ignores old_gen->available().\n+\n+  size_t _old_evac_reserve;            \/\/ Bytes reserved within old-gen to hold evacuated objects from old-gen collection set\n+  volatile size_t _old_evac_expended;  \/\/ Bytes of old-gen memory expended on old-gen evacuations\n+\n+  size_t _young_evac_reserve;          \/\/ Bytes reserved within young-gen to hold evacuated objects from young-gen collection set\n+\n+  size_t _captured_old_usage;          \/\/ What was old usage (bytes) when last captured?\n+\n+  size_t _previous_promotion;          \/\/ Bytes promoted during previous evacuation\n+\n+  bool _upgraded_to_full;\n+\n+  \/\/ At the end of final mark, but before we begin evacuating, heuristics calculate how much memory is required to\n+  \/\/ hold the results of evacuating to young-gen and to old-gen.  These quantitites, stored in _promoted_reserve,\n+  \/\/ _old_evac_reserve, and _young_evac_reserve, are consulted prior to rebuilding the free set (ShenandoahFreeSet)\n+  \/\/ in preparation for evacuation.  When the free set is rebuilt, we make sure to reserve sufficient memory in the\n+  \/\/ collector and old_collector sets to hold if _has_evacuation_reserve_quantities is true.  The other time we\n+  \/\/ rebuild the freeset is at the end of GC, as we prepare to idle GC until the next trigger.  In this case,\n+  \/\/ _has_evacuation_reserve_quantities is false because we don't yet know how much memory will need to be evacuated\n+  \/\/ in the next GC cycle.  When _has_evacuation_reserve_quantities is false, the free set rebuild operation reserves\n+  \/\/ for the collector and old_collector sets based on alternative mechanisms, such as ShenandoahEvacReserve,\n+  \/\/ ShenandoahOldEvacReserve, and ShenandoahOldCompactionReserve.  In a future planned enhancement, the reserve\n+  \/\/ for old_collector set when not _has_evacuation_reserve_quantities is based in part on anticipated promotion as\n+  \/\/ determined by analysis of live data found during the previous GC pass which is one less than the current tenure age.\n+  bool _has_evacuation_reserve_quantities;\n+\n@@ -298,1 +398,3 @@\n-  void set_concurrent_mark_in_progress(bool in_progress);\n+  void set_evacuation_reserve_quantities(bool is_valid);\n+  void set_concurrent_young_mark_in_progress(bool in_progress);\n+  void set_concurrent_old_mark_in_progress(bool in_progress);\n@@ -307,0 +409,3 @@\n+  void set_prepare_for_old_mark_in_progress(bool cond);\n+  void set_aging_cycle(bool cond);\n+\n@@ -310,0 +415,1 @@\n+  inline bool has_evacuation_reserve_quantities() const;\n@@ -311,0 +417,2 @@\n+  inline bool is_concurrent_young_mark_in_progress() const;\n+  inline bool is_concurrent_old_mark_in_progress() const;\n@@ -321,0 +429,53 @@\n+  inline bool is_prepare_for_old_mark_in_progress() const;\n+  inline bool is_aging_cycle() const;\n+  inline bool upgraded_to_full() { return _upgraded_to_full; }\n+  inline void start_conc_gc() { _upgraded_to_full = false; }\n+  inline void record_upgrade_to_full() { _upgraded_to_full = true; }\n+\n+  inline size_t capture_old_usage(size_t usage);\n+  inline void set_previous_promotion(size_t promoted_bytes);\n+  inline size_t get_previous_promotion() const;\n+\n+  inline void clear_promotion_potential() { _promotion_potential = 0; };\n+  inline void set_promotion_potential(size_t val) { _promotion_potential = val; };\n+  inline size_t get_promotion_potential() { return _promotion_potential; };\n+\n+  inline void clear_promotion_in_place_potential() { _promotion_in_place_potential = 0; };\n+  inline void set_promotion_in_place_potential(size_t val) { _promotion_in_place_potential = val; };\n+  inline size_t get_promotion_in_place_potential() { return _promotion_in_place_potential; };\n+\n+  inline void set_pad_for_promote_in_place(size_t pad) { _pad_for_promote_in_place = pad; }\n+  inline size_t get_pad_for_promote_in_place() { return _pad_for_promote_in_place; }\n+\n+  inline void reserve_promotable_humongous_regions(size_t region_count) { _promotable_humongous_regions = region_count; }\n+  inline void reserve_promotable_humongous_usage(size_t bytes) { _promotable_humongous_usage = bytes; }\n+  inline void reserve_promotable_regular_regions(size_t region_count) { _regular_regions_promoted_in_place = region_count; }\n+  inline void reserve_promotable_regular_usage(size_t used_bytes) { _regular_usage_promoted_in_place = used_bytes; }\n+\n+  inline size_t get_promotable_humongous_regions() { return _promotable_humongous_regions; }\n+  inline size_t get_promotable_humongous_usage() { return _promotable_humongous_usage; }\n+  inline size_t get_regular_regions_promoted_in_place() { return _regular_regions_promoted_in_place; }\n+  inline size_t get_regular_usage_promoted_in_place() { return _regular_usage_promoted_in_place; }\n+\n+  \/\/ Returns previous value\n+  inline size_t set_promoted_reserve(size_t new_val);\n+  inline size_t get_promoted_reserve() const;\n+  inline void augment_promo_reserve(size_t increment);\n+\n+  inline void reset_promoted_expended();\n+  inline size_t expend_promoted(size_t increment);\n+  inline size_t unexpend_promoted(size_t decrement);\n+  inline size_t get_promoted_expended();\n+\n+  \/\/ Returns previous value\n+  inline size_t set_old_evac_reserve(size_t new_val);\n+  inline size_t get_old_evac_reserve() const;\n+  inline void augment_old_evac_reserve(size_t increment);\n+\n+  inline void reset_old_evac_expended();\n+  inline size_t expend_old_evac(size_t increment);\n+  inline size_t get_old_evac_expended();\n+\n+  \/\/ Returns previous value\n+  inline size_t set_young_evac_reserve(size_t new_val);\n+  inline size_t get_young_evac_reserve() const;\n@@ -323,0 +484,2 @@\n+  void manage_satb_barrier(bool active);\n+\n@@ -333,0 +496,1 @@\n+  double _cancel_requested_time;\n@@ -334,0 +498,5 @@\n+\n+  \/\/ Returns true if cancel request was successfully communicated.\n+  \/\/ Returns false if some other thread already communicated cancel\n+  \/\/ request.  A true return value does not mean GC has been\n+  \/\/ cancelled, only that the process of cancelling GC has begun.\n@@ -337,2 +506,0 @@\n-  static address cancelled_gc_addr();\n-\n@@ -342,1 +509,1 @@\n-  inline void clear_cancelled_gc();\n+  inline void clear_cancelled_gc(bool clear_oom_handler = true);\n@@ -344,0 +511,1 @@\n+  void cancel_concurrent_mark();\n@@ -353,3 +521,0 @@\n-  \/\/ Reset bitmap, prepare regions for new GC cycle\n-  void prepare_gc();\n-  void prepare_regions_and_collection_set(bool concurrent);\n@@ -357,1 +522,0 @@\n-  void prepare_evacuation(bool concurrent);\n@@ -369,1 +533,0 @@\n-  void rebuild_free_set(bool concurrent);\n@@ -374,0 +537,1 @@\n+  void rebuild_free_set(bool concurrent);\n@@ -380,0 +544,4 @@\n+  ShenandoahYoungGeneration* _young_generation;\n+  ShenandoahGeneration*      _global_generation;\n+  ShenandoahOldGeneration*   _old_generation;\n+\n@@ -381,0 +549,1 @@\n+  ShenandoahRegulatorThread* _regulator_thread;\n@@ -383,1 +552,0 @@\n-  ShenandoahHeuristics*      _heuristics;\n@@ -388,1 +556,4 @@\n-  ShenandoahPhaseTimings*    _phase_timings;\n+  ShenandoahPhaseTimings*       _phase_timings;\n+  ShenandoahEvacuationTracker*  _evac_tracker;\n+  ShenandoahMmuTracker          _mmu_tracker;\n+  ShenandoahGenerationSizer     _generation_sizer;\n@@ -390,1 +561,1 @@\n-  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n+  ShenandoahRegulatorThread* regulator_thread()        { return _regulator_thread;  }\n@@ -393,0 +564,10 @@\n+  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n+  ShenandoahYoungGeneration* young_generation()  const { return _young_generation;  }\n+  ShenandoahGeneration*      global_generation() const { return _global_generation; }\n+  ShenandoahOldGeneration*   old_generation()    const { return _old_generation;    }\n+  ShenandoahGeneration*      generation_for(ShenandoahAffiliation affiliation) const;\n+  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n+\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n@@ -395,1 +576,0 @@\n-  ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }\n@@ -399,1 +579,5 @@\n-  ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }\n+  ShenandoahPhaseTimings*      phase_timings()   const { return _phase_timings;     }\n+  ShenandoahEvacuationTracker* evac_tracker()    const { return  _evac_tracker;     }\n+\n+  void on_cycle_start(GCCause::Cause cause, ShenandoahGeneration* generation);\n+  void on_cycle_end(ShenandoahGeneration* generation);\n@@ -408,0 +592,3 @@\n+  MemoryPool*                  _young_gen_memory_pool;\n+  MemoryPool*                  _old_gen_memory_pool;\n+\n@@ -416,1 +603,1 @@\n-  ShenandoahMonitoringSupport* monitoring_support()          { return _monitoring_support;    }\n+  ShenandoahMonitoringSupport* monitoring_support() const    { return _monitoring_support;    }\n@@ -427,8 +614,0 @@\n-\/\/ ---------- Reference processing\n-\/\/\n-private:\n-  ShenandoahReferenceProcessor* const _ref_processor;\n-\n-public:\n-  ShenandoahReferenceProcessor* ref_processor() { return _ref_processor; }\n-\n@@ -438,0 +617,1 @@\n+  ShenandoahSharedFlag  _is_aging_cycle;\n@@ -453,0 +633,3 @@\n+  inline void assert_lock_for_affiliation(ShenandoahAffiliation orig_affiliation,\n+                                          ShenandoahAffiliation new_affiliation);\n+\n@@ -466,1 +649,12 @@\n-  bool is_in(const void* p) const override;\n+  inline bool is_in(const void* p) const override;\n+\n+  inline bool is_in_active_generation(oop obj) const;\n+  inline bool is_in_young(const void* p) const;\n+  inline bool is_in_old(const void* p) const;\n+  inline bool is_old(oop pobj) const;\n+\n+  inline ShenandoahAffiliation region_affiliation(const ShenandoahHeapRegion* r);\n+  inline void set_affiliation(ShenandoahHeapRegion* r, ShenandoahAffiliation new_affiliation);\n+\n+  inline ShenandoahAffiliation region_affiliation(size_t index);\n+  inline void set_affiliation(size_t index, ShenandoahAffiliation new_affiliation);\n@@ -520,1 +714,6 @@\n-  HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest& request, bool& in_new_region);\n+  \/\/ How many bytes to transfer between old and young after we have finished recycling collection set regions?\n+  size_t _old_regions_surplus;\n+  size_t _old_regions_deficit;\n+\n+  HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest& request, bool& in_new_region, bool is_promotion);\n+\n@@ -525,0 +724,4 @@\n+  inline HeapWord* allocate_from_plab(Thread* thread, size_t size, bool is_promotion);\n+  HeapWord* allocate_from_plab_slow(Thread* thread, size_t size, bool is_promotion);\n+  HeapWord* allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size);\n+\n@@ -526,1 +729,1 @@\n-  HeapWord* allocate_memory(ShenandoahAllocRequest& request);\n+  HeapWord* allocate_memory(ShenandoahAllocRequest& request, bool is_promotion);\n@@ -532,1 +735,1 @@\n-  void notify_mutator_alloc_words(size_t words, bool waste);\n+  void notify_mutator_alloc_words(size_t words, size_t waste);\n@@ -546,0 +749,8 @@\n+  void set_young_lab_region_flags();\n+\n+  inline void set_old_region_surplus(size_t surplus) { _old_regions_surplus = surplus; };\n+  inline void set_old_region_deficit(size_t deficit) { _old_regions_deficit = deficit; };\n+\n+  inline size_t get_old_region_surplus() { return _old_regions_surplus; };\n+  inline size_t get_old_region_deficit() { return _old_regions_deficit; };\n+\n@@ -570,2 +781,0 @@\n-  inline void mark_complete_marking_context();\n-  inline void mark_incomplete_marking_context();\n@@ -582,2 +791,0 @@\n-  void reset_mark_bitmap();\n-\n@@ -603,0 +810,5 @@\n+  ShenandoahSharedFlag _old_gen_oom_evac;\n+\n+  inline oop try_evacuate_object(oop src, Thread* thread, ShenandoahHeapRegion* from_region, ShenandoahAffiliation target_gen);\n+  void handle_old_evacuation(HeapWord* obj, size_t words, bool promotion);\n+  void handle_old_evacuation_failure();\n@@ -605,0 +817,3 @@\n+  void handle_promotion_failure();\n+  void report_promotion_failure(Thread* thread, size_t size);\n+\n@@ -615,1 +830,1 @@\n-  \/\/ Evacuates object src. Returns the evacuated object, either evacuated\n+  \/\/ Evacuates or promotes object src. Returns the evacuated object, either evacuated\n@@ -623,0 +838,20 @@\n+  inline bool clear_old_evacuation_failure();\n+\n+\/\/ ---------- Generational support\n+\/\/\n+private:\n+  RememberedScanner* _card_scan;\n+\n+public:\n+  inline RememberedScanner* card_scan() { return _card_scan; }\n+  void clear_cards_for(ShenandoahHeapRegion* region);\n+  void dirty_cards(HeapWord* start, HeapWord* end);\n+  void clear_cards(HeapWord* start, HeapWord* end);\n+  void mark_card_as_dirty(void* location);\n+  void retire_plab(PLAB* plab);\n+  void retire_plab(PLAB* plab, Thread* thread);\n+  void cancel_old_gc();\n+  bool is_old_gc_active();\n+  void coalesce_and_fill_old_regions();\n+  void adjust_generation_sizes_for_next_cycle(size_t old_xfer_limit, size_t young_cset_regions, size_t old_cset_regions);\n+\n@@ -644,1 +879,8 @@\n-  void trash_humongous_region_at(ShenandoahHeapRegion *r);\n+  size_t trash_humongous_region_at(ShenandoahHeapRegion *r);\n+\n+  static inline void increase_object_age(oop obj, uint additional_age);\n+  static inline uint get_object_age(oop obj);\n+\n+  void transfer_old_pointers_from_satb();\n+\n+  void log_heap_status(const char *msg) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":288,"deletions":46,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -45,0 +46,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -46,0 +48,2 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -255,1 +259,1 @@\n-inline void ShenandoahHeap::clear_cancelled_gc() {\n+inline void ShenandoahHeap::clear_cancelled_gc(bool clear_oom_handler) {\n@@ -257,1 +261,9 @@\n-  _oom_evac_handler.clear();\n+  if (_cancel_requested_time > 0) {\n+    double cancel_time = os::elapsedTime() - _cancel_requested_time;\n+    log_info(gc)(\"GC cancellation took %.3fs\", cancel_time);\n+    _cancel_requested_time = 0;\n+  }\n+\n+  if (clear_oom_handler) {\n+    _oom_evac_handler.clear();\n+  }\n@@ -274,1 +286,0 @@\n-  \/\/ Otherwise...\n@@ -278,0 +289,32 @@\n+inline HeapWord* ShenandoahHeap::allocate_from_plab(Thread* thread, size_t size, bool is_promotion) {\n+  assert(UseTLAB, \"TLABs should be enabled\");\n+\n+  PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+  HeapWord* obj;\n+\n+  if (plab == nullptr) {\n+    assert(!thread->is_Java_thread() && !thread->is_Worker_thread(), \"Performance: thread should have PLAB: %s\", thread->name());\n+    \/\/ No PLABs in this thread, fallback to shared allocation\n+    return nullptr;\n+  } else if (is_promotion && !ShenandoahThreadLocalData::allow_plab_promotions(thread)) {\n+    return nullptr;\n+  }\n+  \/\/ if plab->word_size() <= 0, thread's plab not yet initialized for this pass, so allow_plab_promotions() is not trustworthy\n+  obj = plab->allocate(size);\n+  if ((obj == nullptr) && (plab->words_remaining() < PLAB::min_size())) {\n+    \/\/ allocate_from_plab_slow will establish allow_plab_promotions(thread) for future invocations\n+    obj = allocate_from_plab_slow(thread, size, is_promotion);\n+  }\n+  \/\/ if plab->words_remaining() >= PLAB::min_size(), just return nullptr so we can use a shared allocation\n+  if (obj == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (is_promotion) {\n+    ShenandoahThreadLocalData::add_to_plab_promoted(thread, size * HeapWordSize);\n+  } else {\n+    ShenandoahThreadLocalData::add_to_plab_evacuated(thread, size * HeapWordSize);\n+  }\n+  return obj;\n+}\n+\n@@ -279,1 +322,2 @@\n-  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n+  assert(thread == Thread::current(), \"Expected thread parameter to be current thread.\");\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(thread)) {\n@@ -287,1 +331,2 @@\n-  size_t size = p->size();\n+  ShenandoahHeapRegion* r = heap_region_containing(p);\n+  assert(!r->is_humongous(), \"never evacuate humongous objects\");\n@@ -289,1 +334,21 @@\n-  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n+  ShenandoahAffiliation target_gen = r->affiliation();\n+  if (mode()->is_generational() && ShenandoahHeap::heap()->is_gc_generation_young() &&\n+      target_gen == YOUNG_GENERATION) {\n+    markWord mark = p->mark();\n+    if (mark.is_marked()) {\n+      \/\/ Already forwarded.\n+      return ShenandoahBarrierSet::resolve_forwarded(p);\n+    }\n+    if (mark.has_displaced_mark_helper()) {\n+      \/\/ We don't want to deal with MT here just to ensure we read the right mark word.\n+      \/\/ Skip the potential promotion attempt for this one.\n+    } else if (r->age() + mark.age() >= InitialTenuringThreshold) {\n+      oop result = try_evacuate_object(p, thread, r, OLD_GENERATION);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+      \/\/ If we failed to promote this aged object, we'll fall through to code below and evacuate to young-gen.\n+    }\n+  }\n+  return try_evacuate_object(p, thread, r, target_gen);\n+}\n@@ -291,1 +356,6 @@\n-  bool alloc_from_gclab = true;\n+\/\/ try_evacuate_object registers the object and dirties the associated remembered set information when evacuating\n+\/\/ to OLD_GENERATION.\n+inline oop ShenandoahHeap::try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region,\n+                                               ShenandoahAffiliation target_gen) {\n+  bool alloc_from_lab = true;\n+  bool has_plab = false;\n@@ -293,0 +363,2 @@\n+  size_t size = p->size();\n+  bool is_promotion = (target_gen == OLD_GENERATION) && from_region->is_young();\n@@ -301,1 +373,45 @@\n-      copy = allocate_from_gclab(thread, size);\n+      switch (target_gen) {\n+        case YOUNG_GENERATION: {\n+           copy = allocate_from_gclab(thread, size);\n+           if ((copy == nullptr) && (size < ShenandoahThreadLocalData::gclab_size(thread))) {\n+             \/\/ GCLAB allocation failed because we are bumping up against the limit on young evacuation reserve.  Try resetting\n+             \/\/ the desired GCLAB size and retry GCLAB allocation to avoid cascading of shared memory allocations.\n+             ShenandoahThreadLocalData::set_gclab_size(thread, PLAB::min_size());\n+             copy = allocate_from_gclab(thread, size);\n+             \/\/ If we still get nullptr, we'll try a shared allocation below.\n+           }\n+           break;\n+        }\n+        case OLD_GENERATION: {\n+           PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+           if (plab != nullptr) {\n+             has_plab = true;\n+           }\n+           copy = allocate_from_plab(thread, size, is_promotion);\n+           if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n+               ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n+             \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n+             \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n+             \/\/ where abundance is defined as >= PLAB::min_size().  In the former case, we try resetting the desired\n+             \/\/ PLAB size and retry PLAB allocation to avoid cascading of shared memory allocations.\n+\n+             \/\/ In this situation, PLAB memory is precious.  We'll try to preserve our existing PLAB by forcing\n+             \/\/ this particular allocation to be shared.\n+             if (plab->words_remaining() < PLAB::min_size()) {\n+               ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n+               copy = allocate_from_plab(thread, size, is_promotion);\n+               \/\/ If we still get nullptr, we'll try a shared allocation below.\n+               if (copy == nullptr) {\n+                 \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n+                 ShenandoahThreadLocalData::disable_plab_retries(thread);\n+               }\n+             }\n+             \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n+           }\n+           break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n@@ -303,0 +419,1 @@\n+\n@@ -304,3 +421,10 @@\n-      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n-      copy = allocate_memory(req);\n-      alloc_from_gclab = false;\n+      \/\/ If we failed to allocate in LAB, we'll try a shared allocation.\n+      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+        ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen);\n+        copy = allocate_memory(req, is_promotion);\n+        alloc_from_lab = false;\n+      }\n+      \/\/ else, we leave copy equal to nullptr, signaling a promotion failure below if appropriate.\n+      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n+      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n+      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n@@ -313,0 +437,14 @@\n+    if (target_gen == OLD_GENERATION) {\n+      assert(mode()->is_generational(), \"Should only be here in generational mode.\");\n+      if (from_region->is_young()) {\n+        \/\/ Signal that promotion failed. Will evacuate this old object somewhere in young gen.\n+        report_promotion_failure(thread, size);\n+        handle_promotion_failure();\n+        return nullptr;\n+      } else {\n+        \/\/ Remember that evacuation to old gen failed. We'll want to trigger a full gc to recover from this\n+        \/\/ after the evacuation threads have finished.\n+        handle_old_evacuation_failure();\n+      }\n+    }\n+\n@@ -321,0 +459,1 @@\n+  _evac_tracker->begin_evacuation(thread, size * HeapWordSize);\n@@ -323,1 +462,0 @@\n-  \/\/ Try to install the new forwarding pointer.\n@@ -325,0 +463,6 @@\n+\n+  if (mode()->is_generational() && target_gen == YOUNG_GENERATION && is_aging_cycle()) {\n+    ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n+  }\n+\n+  \/\/ Try to install the new forwarding pointer.\n@@ -330,0 +474,4 @@\n+    _evac_tracker->end_evacuation(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n+    if (mode()->is_generational() && target_gen == OLD_GENERATION) {\n+      handle_old_evacuation(copy, size, from_region->is_young());\n+    }\n@@ -338,8 +486,23 @@\n-    \/\/\n-    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n-    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n-    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n-    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n-    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n-    if (alloc_from_gclab) {\n-      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+    if (alloc_from_lab) {\n+       \/\/ For LAB allocations, it is enough to rollback the allocation ptr. Either the next\n+       \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+       \/\/ do this.\n+       switch (target_gen) {\n+         case YOUNG_GENERATION: {\n+             ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+            break;\n+         }\n+         case OLD_GENERATION: {\n+            ShenandoahThreadLocalData::plab(thread)->undo_allocation(copy, size);\n+            if (is_promotion) {\n+              ShenandoahThreadLocalData::subtract_from_plab_promoted(thread, size * HeapWordSize);\n+            } else {\n+              ShenandoahThreadLocalData::subtract_from_plab_evacuated(thread, size * HeapWordSize);\n+            }\n+            break;\n+         }\n+         default: {\n+           ShouldNotReachHere();\n+           break;\n+         }\n+       }\n@@ -347,0 +510,4 @@\n+      \/\/ For non-LAB allocations, we have no way to retract the allocation, and\n+      \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+      \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+      assert(size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n@@ -349,0 +516,1 @@\n+      \/\/ For non-LAB allocations, the object has already been registered\n@@ -355,0 +523,114 @@\n+void ShenandoahHeap::increase_object_age(oop obj, uint additional_age) {\n+  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n+  w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n+  if (obj->has_displaced_mark()) {\n+    obj->set_displaced_mark(w);\n+  } else {\n+    obj->set_mark(w);\n+  }\n+}\n+\n+uint ShenandoahHeap::get_object_age(oop obj) {\n+  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n+  return w.age();\n+}\n+\n+inline bool ShenandoahHeap::clear_old_evacuation_failure() {\n+  return _old_gen_oom_evac.try_unset();\n+}\n+\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  HeapWord* heap_base = (HeapWord*) base();\n+  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n+  return p >= heap_base && p < last_region_end;\n+}\n+\n+inline bool ShenandoahHeap::is_in_active_generation(oop obj) const {\n+  if (!mode()->is_generational()) {\n+    \/\/ everything is the same single generation\n+    return true;\n+  }\n+\n+  if (active_generation() == nullptr) {\n+    \/\/ no collection is happening, only expect this to be called\n+    \/\/ when concurrent processing is active, but that could change\n+    return false;\n+  }\n+\n+  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert((active_generation() == (ShenandoahGeneration*) old_generation()) ||\n+         (active_generation() == (ShenandoahGeneration*) young_generation()) ||\n+         (active_generation() == global_generation()), \"Active generation must be old, young, or global\");\n+\n+  size_t index = heap_region_containing(obj)->index();\n+  switch (_affiliations[index]) {\n+  case ShenandoahAffiliation::FREE:\n+    \/\/ Free regions are in Old, Young, Global\n+    return true;\n+  case ShenandoahAffiliation::YOUNG_GENERATION:\n+    \/\/ Young regions are in young_generation and global_generation, not in old_generation\n+    return (active_generation() != (ShenandoahGeneration*) old_generation());\n+  case ShenandoahAffiliation::OLD_GENERATION:\n+    \/\/ Old regions are in old_generation and global_generation, not in young_generation\n+    return (active_generation() != (ShenandoahGeneration*) young_generation());\n+  default:\n+    assert(false, \"Bad affiliation (%d) for region \" SIZE_FORMAT, _affiliations[index], index);\n+    return false;\n+  }\n+}\n+\n+inline bool ShenandoahHeap::is_in_young(const void* p) const {\n+  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+}\n+\n+inline bool ShenandoahHeap::is_in_old(const void* p) const {\n+  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+}\n+\n+inline bool ShenandoahHeap::is_old(oop obj) const {\n+  return is_gc_generation_young() && is_in_old(obj);\n+}\n+\n+inline ShenandoahAffiliation ShenandoahHeap::region_affiliation(const ShenandoahHeapRegion *r) {\n+  return (ShenandoahAffiliation) _affiliations[r->index()];\n+}\n+\n+inline void ShenandoahHeap::assert_lock_for_affiliation(ShenandoahAffiliation orig_affiliation,\n+                                                        ShenandoahAffiliation new_affiliation) {\n+  \/\/ A lock is required when changing from FREE to NON-FREE.  Though it may be possible to elide the lock when\n+  \/\/ transitioning from in-use to FREE, the current implementation uses a lock for this transition.  A lock is\n+  \/\/ not required to change from YOUNG to OLD (i.e. when promoting humongous region).\n+  \/\/\n+  \/\/         new_affiliation is:     FREE   YOUNG   OLD\n+  \/\/  orig_affiliation is:  FREE      X       L      L\n+  \/\/                       YOUNG      L       X\n+  \/\/                         OLD      L       X      X\n+  \/\/  X means state transition won't happen (so don't care)\n+  \/\/  L means lock should be held\n+  \/\/  Blank means no lock required because affiliation visibility will not be required until subsequent safepoint\n+  \/\/\n+  \/\/ Note: during full GC, all transitions between states are possible.  During Full GC, we should be in a safepoint.\n+\n+  if ((orig_affiliation == ShenandoahAffiliation::FREE) || (new_affiliation == ShenandoahAffiliation::FREE)) {\n+    shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  }\n+}\n+\n+inline void ShenandoahHeap::set_affiliation(ShenandoahHeapRegion* r, ShenandoahAffiliation new_affiliation) {\n+#ifdef ASSERT\n+  assert_lock_for_affiliation(region_affiliation(r), new_affiliation);\n+#endif\n+  _affiliations[r->index()] = (uint8_t) new_affiliation;\n+}\n+\n+inline ShenandoahAffiliation ShenandoahHeap::region_affiliation(size_t index) {\n+  return (ShenandoahAffiliation) _affiliations[index];\n+}\n+\n+inline void ShenandoahHeap::set_affiliation(size_t index, ShenandoahAffiliation new_affiliation) {\n+#ifdef ASSERT\n+  assert_lock_for_affiliation(region_affiliation(index), new_affiliation);\n+#endif\n+  _affiliations[index] = (uint8_t) new_affiliation;\n+}\n+\n@@ -370,0 +652,1 @@\n+\n@@ -374,0 +657,4 @@\n+inline bool ShenandoahHeap::has_evacuation_reserve_quantities() const {\n+  return _has_evacuation_reserve_quantities;\n+}\n+\n@@ -375,1 +662,1 @@\n-  return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS);\n+  return _gc_state.is_unset(YOUNG_MARKING | OLD_MARKING | EVACUATION | UPDATEREFS);\n@@ -379,1 +666,9 @@\n-  return _gc_state.is_set(MARKING);\n+  return _gc_state.is_set(YOUNG_MARKING | OLD_MARKING);\n+}\n+\n+inline bool ShenandoahHeap::is_concurrent_young_mark_in_progress() const {\n+  return _gc_state.is_set(YOUNG_MARKING);\n+}\n+\n+inline bool ShenandoahHeap::is_concurrent_old_mark_in_progress() const {\n+  return _gc_state.is_set(OLD_MARKING);\n@@ -418,0 +713,90 @@\n+inline bool ShenandoahHeap::is_aging_cycle() const {\n+  return _is_aging_cycle.is_set();\n+}\n+\n+inline bool ShenandoahHeap::is_prepare_for_old_mark_in_progress() const {\n+  return _prepare_for_old_mark;\n+}\n+\n+inline size_t ShenandoahHeap::set_promoted_reserve(size_t new_val) {\n+  size_t orig = _promoted_reserve;\n+  _promoted_reserve = new_val;\n+  return orig;\n+}\n+\n+inline size_t ShenandoahHeap::get_promoted_reserve() const {\n+  return _promoted_reserve;\n+}\n+\n+\/\/ returns previous value\n+size_t ShenandoahHeap::capture_old_usage(size_t old_usage) {\n+  size_t previous_value = _captured_old_usage;\n+  _captured_old_usage = old_usage;\n+  return previous_value;\n+}\n+\n+void ShenandoahHeap::set_previous_promotion(size_t promoted_bytes) {\n+  shenandoah_assert_heaplocked();\n+  _previous_promotion = promoted_bytes;\n+}\n+\n+size_t ShenandoahHeap::get_previous_promotion() const {\n+  return _previous_promotion;\n+}\n+\n+inline size_t ShenandoahHeap::set_old_evac_reserve(size_t new_val) {\n+  size_t orig = _old_evac_reserve;\n+  _old_evac_reserve = new_val;\n+  return orig;\n+}\n+\n+inline size_t ShenandoahHeap::get_old_evac_reserve() const {\n+  return _old_evac_reserve;\n+}\n+\n+inline void ShenandoahHeap::augment_old_evac_reserve(size_t increment) {\n+  _old_evac_reserve += increment;\n+}\n+\n+inline void ShenandoahHeap::augment_promo_reserve(size_t increment) {\n+  _promoted_reserve += increment;\n+}\n+\n+inline void ShenandoahHeap::reset_old_evac_expended() {\n+  Atomic::store(&_old_evac_expended, (size_t) 0);\n+}\n+\n+inline size_t ShenandoahHeap::expend_old_evac(size_t increment) {\n+  return Atomic::add(&_old_evac_expended, increment);\n+}\n+\n+inline size_t ShenandoahHeap::get_old_evac_expended() {\n+  return Atomic::load(&_old_evac_expended);\n+}\n+\n+inline void ShenandoahHeap::reset_promoted_expended() {\n+  Atomic::store(&_promoted_expended, (size_t) 0);\n+}\n+\n+inline size_t ShenandoahHeap::expend_promoted(size_t increment) {\n+  return Atomic::add(&_promoted_expended, increment);\n+}\n+\n+inline size_t ShenandoahHeap::unexpend_promoted(size_t decrement) {\n+  return Atomic::sub(&_promoted_expended, decrement);\n+}\n+\n+inline size_t ShenandoahHeap::get_promoted_expended() {\n+  return Atomic::load(&_promoted_expended);\n+}\n+\n+inline size_t ShenandoahHeap::set_young_evac_reserve(size_t new_val) {\n+  size_t orig = _young_evac_reserve;\n+  _young_evac_reserve = new_val;\n+  return orig;\n+}\n+\n+inline size_t ShenandoahHeap::get_young_evac_reserve() const {\n+  return _young_evac_reserve;\n+}\n+\n@@ -427,2 +812,1 @@\n-  ShenandoahMarkingContext* const ctx = complete_marking_context();\n-  assert(ctx->is_complete(), \"sanity\");\n+  ShenandoahMarkingContext* const ctx = marking_context();\n@@ -559,8 +943,0 @@\n-inline void ShenandoahHeap::mark_complete_marking_context() {\n-  _marking_context->mark_complete();\n-}\n-\n-inline void ShenandoahHeap::mark_incomplete_marking_context() {\n-  _marking_context->mark_incomplete();\n-}\n-\n@@ -576,0 +952,24 @@\n+inline void ShenandoahHeap::clear_cards_for(ShenandoahHeapRegion* region) {\n+  if (mode()->is_generational()) {\n+    _card_scan->mark_range_as_empty(region->bottom(), pointer_delta(region->end(), region->bottom()));\n+  }\n+}\n+\n+inline void ShenandoahHeap::dirty_cards(HeapWord* start, HeapWord* end) {\n+  assert(mode()->is_generational(), \"Should only be used for generational mode\");\n+  size_t words = pointer_delta(end, start);\n+  _card_scan->mark_range_as_dirty(start, words);\n+}\n+\n+inline void ShenandoahHeap::clear_cards(HeapWord* start, HeapWord* end) {\n+  assert(mode()->is_generational(), \"Should only be used for generational mode\");\n+  size_t words = pointer_delta(end, start);\n+  _card_scan->mark_range_as_clean(start, words);\n+}\n+\n+inline void ShenandoahHeap::mark_card_as_dirty(void* location) {\n+  if (mode()->is_generational()) {\n+    _card_scan->mark_card_as_dirty((HeapWord*)location);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":432,"deletions":32,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n- * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -29,0 +31,2 @@\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -33,0 +37,4 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -47,0 +55,1 @@\n+\n@@ -69,0 +78,2 @@\n+  _plab_allocs(0),\n+  _has_young_lab(false),\n@@ -71,1 +82,2 @@\n-  _update_watermark(start) {\n+  _update_watermark(start),\n+  _age(0) {\n@@ -87,1 +99,1 @@\n-void ShenandoahHeapRegion::make_regular_allocation() {\n+void ShenandoahHeapRegion::make_regular_allocation(ShenandoahAffiliation affiliation) {\n@@ -89,1 +101,1 @@\n-\n+  reset_age();\n@@ -94,0 +106,1 @@\n+      assert(this->affiliation() == affiliation, \"Region affiliation should already be established\");\n@@ -103,0 +116,27 @@\n+\/\/ Change affiliation to YOUNG_GENERATION if _state is not _pinned_cset, _regular, or _pinned.  This implements\n+\/\/ behavior previously performed as a side effect of make_regular_bypass().\n+void ShenandoahHeapRegion::make_young_maybe() {\n+  shenandoah_assert_heaplocked();\n+  switch (_state) {\n+   case _empty_uncommitted:\n+   case _empty_committed:\n+   case _cset:\n+   case _humongous_start:\n+   case _humongous_cont:\n+     if (affiliation() != YOUNG_GENERATION) {\n+       if (is_old()) {\n+         ShenandoahHeap::heap()->old_generation()->decrement_affiliated_region_count();\n+       }\n+       set_affiliation(YOUNG_GENERATION);\n+       ShenandoahHeap::heap()->young_generation()->increment_affiliated_region_count();\n+     }\n+     return;\n+   case _pinned_cset:\n+   case _regular:\n+   case _pinned:\n+     return;\n+   default:\n+     assert(false, \"Unexpected _state in make_young_maybe\");\n+  }\n+}\n+\n@@ -107,1 +147,1 @@\n-\n+  reset_age();\n@@ -130,0 +170,1 @@\n+  reset_age();\n@@ -141,1 +182,1 @@\n-void ShenandoahHeapRegion::make_humongous_start_bypass() {\n+void ShenandoahHeapRegion::make_humongous_start_bypass(ShenandoahAffiliation affiliation) {\n@@ -144,1 +185,3 @@\n-\n+  \/\/ Don't bother to account for affiliated regions during Full GC.  We recompute totals at end.\n+  set_affiliation(affiliation);\n+  reset_age();\n@@ -159,0 +202,1 @@\n+  reset_age();\n@@ -170,1 +214,1 @@\n-void ShenandoahHeapRegion::make_humongous_cont_bypass() {\n+void ShenandoahHeapRegion::make_humongous_cont_bypass(ShenandoahAffiliation affiliation) {\n@@ -173,1 +217,3 @@\n-\n+  set_affiliation(affiliation);\n+  \/\/ Don't bother to account for affiliated regions during Full GC.  We recompute totals at end.\n+  reset_age();\n@@ -214,0 +260,1 @@\n+      assert(is_affiliated(), \"Pinned region should be affiliated\");\n@@ -232,0 +279,1 @@\n+  \/\/ Leave age untouched.  We need to consult the age when we are deciding whether to promote evacuated objects.\n@@ -244,0 +292,1 @@\n+  reset_age();\n@@ -245,2 +294,0 @@\n-    case _cset:\n-      \/\/ Reclaiming cset regions\n@@ -249,1 +296,7 @@\n-      \/\/ Reclaiming humongous regions\n+    {\n+      \/\/ Reclaiming humongous regions and reclaim humongous waste.  When this region is eventually recycled, we'll reclaim\n+      \/\/ its used memory.  At recycle time, we no longer recognize this as a humongous region.\n+      decrement_humongous_waste();\n+    }\n+    case _cset:\n+      \/\/ Reclaiming cset regions\n@@ -264,1 +317,2 @@\n-  ShenandoahHeap::heap()->complete_marking_context()->reset_top_bitmap(this);\n+  assert(ShenandoahHeap::heap()->active_generation()->is_mark_complete(), \"Marking should be complete here.\");\n+  ShenandoahHeap::heap()->marking_context()->reset_top_bitmap(this);\n@@ -269,0 +323,1 @@\n+  reset_age();\n@@ -308,0 +363,1 @@\n+  _plab_allocs = 0;\n@@ -311,1 +367,1 @@\n-  return used() - (_tlab_allocs + _gclab_allocs) * HeapWordSize;\n+  return used() - (_tlab_allocs + _gclab_allocs + _plab_allocs) * HeapWordSize;\n@@ -322,0 +378,4 @@\n+size_t ShenandoahHeapRegion::get_plab_allocs() const {\n+  return _plab_allocs * HeapWordSize;\n+}\n+\n@@ -354,1 +414,1 @@\n-      st->print(\"|T  \");\n+      st->print(\"|TR \");\n@@ -366,0 +426,2 @@\n+  st->print(\"|%s\", shenandoah_affiliation_code(affiliation()));\n+\n@@ -377,0 +439,3 @@\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    st->print(\"|P \" SIZE_FORMAT_W(5) \"%1s\", byte_size_in_proper_unit(get_plab_allocs()),   proper_unit_for_byte_size(get_plab_allocs()));\n+  }\n@@ -385,1 +450,96 @@\n-void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {\n+\/\/ oop_iterate without closure and without cancellation.  always return true.\n+bool ShenandoahHeapRegion::oop_fill_and_coalesce_without_cancel() {\n+  HeapWord* obj_addr = resume_coalesce_and_fill();\n+\n+  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n+  if (!is_active()) {\n+    end_preemptible_coalesce_and_fill();\n+    return true;\n+  }\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+  \/\/ All objects above TAMS are considered live even though their mark bits will not be set.  Note that young-\n+  \/\/ gen evacuations that interrupt a long-running old-gen concurrent mark may promote objects into old-gen\n+  \/\/ while the old-gen concurrent marking is ongoing.  These newly promoted objects will reside above TAMS\n+  \/\/ and will be treated as live during the current old-gen marking pass, even though they will not be\n+  \/\/ explicitly marked.\n+  HeapWord* t = marking_context->top_at_mark_start(this);\n+\n+  \/\/ Expect marking to be completed before these threads invoke this service.\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+  while (obj_addr < t) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != nullptr, \"klass should not be nullptr\");\n+      obj_addr += obj->size();\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated objects known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+  \/\/ Mark that this region has been coalesced and filled\n+  end_preemptible_coalesce_and_fill();\n+  return true;\n+}\n+\n+\/\/ oop_iterate without closure, return true if completed without cancellation\n+bool ShenandoahHeapRegion::oop_fill_and_coalesce() {\n+  HeapWord* obj_addr = resume_coalesce_and_fill();\n+  \/\/ Consider yielding to cancel\/preemption request after this many coalesce operations (skip marked, or coalesce free).\n+  const size_t preemption_stride = 128;\n+\n+  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n+  if (!is_active()) {\n+    end_preemptible_coalesce_and_fill();\n+    return true;\n+  }\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+  \/\/ All objects above TAMS are considered live even though their mark bits will not be set.  Note that young-\n+  \/\/ gen evacuations that interrupt a long-running old-gen concurrent mark may promote objects into old-gen\n+  \/\/ while the old-gen concurrent marking is ongoing.  These newly promoted objects will reside above TAMS\n+  \/\/ and will be treated as live during the current old-gen marking pass, even though they will not be\n+  \/\/ explicitly marked.\n+  HeapWord* t = marking_context->top_at_mark_start(this);\n+\n+  \/\/ Expect marking to be completed before these threads invoke this service.\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+\n+  size_t ops_before_preempt_check = preemption_stride;\n+  while (obj_addr < t) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != nullptr, \"klass should not be nullptr\");\n+      obj_addr += obj->size();\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+    if (ops_before_preempt_check-- == 0) {\n+      if (heap->cancelled_gc()) {\n+        suspend_coalesce_and_fill(obj_addr);\n+        return false;\n+      }\n+      ops_before_preempt_check = preemption_stride;\n+    }\n+  }\n+  \/\/ Mark that this region has been coalesced and filled\n+  end_preemptible_coalesce_and_fill();\n+  return true;\n+}\n+\n+void ShenandoahHeapRegion::global_oop_iterate_and_fill_dead(OopIterateClosure* blk) {\n@@ -388,0 +548,2 @@\n+    \/\/ No need to fill dead within humongous regions.  Either the entire region is dead, or the entire region is\n+    \/\/ unchanged.  A humongous region holds no more than one humongous object.\n@@ -390,1 +552,1 @@\n-    oop_iterate_objects(blk);\n+    global_oop_iterate_objects_and_fill_dead(blk);\n@@ -394,2 +556,2 @@\n-void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {\n-  assert(! is_humongous(), \"no humongous region here\");\n+void ShenandoahHeapRegion::global_oop_iterate_objects_and_fill_dead(OopIterateClosure* blk) {\n+  assert(!is_humongous(), \"no humongous region here\");\n@@ -397,2 +559,30 @@\n-  HeapWord* t = top();\n-  \/\/ Could call objects iterate, but this is easier.\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+  RememberedScanner* rem_set_scanner = heap->card_scan();\n+  \/\/ Objects allocated above TAMS are not marked, but are considered live for purposes of current GC efforts.\n+  HeapWord* t = marking_context->top_at_mark_start(this);\n+\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+\n+  while (obj_addr < t) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != nullptr, \"klass should not be nullptr\");\n+      \/\/ when promoting an entire region, we have to register the marked objects as well\n+      obj_addr += obj->oop_iterate_size(blk);\n+    } else {\n+      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n+      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated objects known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      \/\/ coalesce_objects() unregisters all but first object subsumed within coalesced range.\n+      rem_set_scanner->coalesce_objects(obj_addr, fill_size);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+\n+  \/\/ Any object above TAMS and below top() is considered live.\n+  t = top();\n@@ -405,0 +595,50 @@\n+\/\/ DO NOT CANCEL.  If this worker thread has accepted responsibility for scanning a particular range of addresses, it\n+\/\/ must finish the work before it can be cancelled.\n+void ShenandoahHeapRegion::oop_iterate_humongous_slice(OopIterateClosure* blk, bool dirty_only,\n+                                                       HeapWord* start, size_t words, bool write_table) {\n+  assert(words % CardTable::card_size_in_words() == 0, \"Humongous iteration must span whole number of cards\");\n+  assert(is_humongous(), \"only humongous region here\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ Find head.\n+  ShenandoahHeapRegion* r = humongous_start_region();\n+  assert(r->is_humongous_start(), \"need humongous head here\");\n+  assert(CardTable::card_size_in_words() * (words \/ CardTable::card_size_in_words()) == words,\n+         \"slice must be integral number of cards\");\n+\n+  oop obj = cast_to_oop(r->bottom());\n+  RememberedScanner* scanner = ShenandoahHeap::heap()->card_scan();\n+  size_t card_index = scanner->card_index_for_addr(start);\n+  size_t num_cards = words \/ CardTable::card_size_in_words();\n+\n+  if (dirty_only) {\n+    if (write_table) {\n+      while (num_cards-- > 0) {\n+        if (scanner->is_write_card_dirty(card_index++)) {\n+          obj->oop_iterate(blk, MemRegion(start, start + CardTable::card_size_in_words()));\n+        }\n+        start += CardTable::card_size_in_words();\n+      }\n+    } else {\n+      while (num_cards-- > 0) {\n+        if (scanner->is_card_dirty(card_index++)) {\n+          obj->oop_iterate(blk, MemRegion(start, start + CardTable::card_size_in_words()));\n+        }\n+        start += CardTable::card_size_in_words();\n+      }\n+    }\n+  } else {\n+    \/\/ Scan all data, regardless of whether cards are dirty\n+    obj->oop_iterate(blk, MemRegion(start, start + num_cards * CardTable::card_size_in_words()));\n+  }\n+}\n+\n+void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk, HeapWord* start, size_t words) {\n+  assert(is_humongous(), \"only humongous region here\");\n+  \/\/ Find head.\n+  ShenandoahHeapRegion* r = humongous_start_region();\n+  assert(r->is_humongous_start(), \"need humongous head here\");\n+  oop obj = cast_to_oop(r->bottom());\n+  obj->oop_iterate(blk, MemRegion(start, start + words));\n+}\n+\n@@ -430,0 +670,5 @@\n+  shenandoah_assert_heaplocked();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* generation = heap->generation_for(affiliation());\n+  heap->decrease_used(generation, used());\n+\n@@ -435,1 +680,1 @@\n-  ShenandoahHeap::heap()->marking_context()->reset_top_at_mark_start(this);\n+  heap->marking_context()->reset_top_at_mark_start(this);\n@@ -439,1 +684,2 @@\n-\n+  ShenandoahHeap::heap()->generation_for(affiliation())->decrement_affiliated_region_count();\n+  set_affiliation(FREE);\n@@ -483,0 +729,5 @@\n+  \/\/ Generational Shenandoah needs this alignment for card tables.\n+  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n+    max_heap_size = align_up(max_heap_size , CardTable::ct_max_alignment_constraint());\n+  }\n+\n@@ -689,0 +940,222 @@\n+\n+void ShenandoahHeapRegion::set_affiliation(ShenandoahAffiliation new_affiliation) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  ShenandoahAffiliation region_affiliation = heap->region_affiliation(this);\n+  {\n+    ShenandoahMarkingContext* const ctx = heap->complete_marking_context();\n+    log_debug(gc)(\"Setting affiliation of Region \" SIZE_FORMAT \" from %s to %s, top: \" PTR_FORMAT \", TAMS: \" PTR_FORMAT\n+                  \", watermark: \" PTR_FORMAT \", top_bitmap: \" PTR_FORMAT,\n+                  index(), shenandoah_affiliation_name(region_affiliation), shenandoah_affiliation_name(new_affiliation),\n+                  p2i(top()), p2i(ctx->top_at_mark_start(this)), p2i(_update_watermark), p2i(ctx->top_bitmap(this)));\n+  }\n+\n+#ifdef ASSERT\n+  {\n+    \/\/ During full gc, heap->complete_marking_context() is not valid, may equal nullptr.\n+    ShenandoahMarkingContext* const ctx = heap->complete_marking_context();\n+    size_t idx = this->index();\n+    HeapWord* top_bitmap = ctx->top_bitmap(this);\n+\n+    assert(ctx->is_bitmap_clear_range(top_bitmap, _end),\n+           \"Region \" SIZE_FORMAT \", bitmap should be clear between top_bitmap: \" PTR_FORMAT \" and end: \" PTR_FORMAT, idx,\n+           p2i(top_bitmap), p2i(_end));\n+  }\n+#endif\n+\n+  if (region_affiliation == new_affiliation) {\n+    return;\n+  }\n+\n+  if (!heap->mode()->is_generational()) {\n+    log_trace(gc)(\"Changing affiliation of region %zu from %s to %s\",\n+                  index(), affiliation_name(), shenandoah_affiliation_name(new_affiliation));\n+    heap->set_affiliation(this, new_affiliation);\n+    return;\n+  }\n+\n+  switch (new_affiliation) {\n+    case FREE:\n+      assert(!has_live(), \"Free region should not have live data\");\n+      break;\n+    case YOUNG_GENERATION:\n+      reset_age();\n+      break;\n+    case OLD_GENERATION:\n+      \/\/ TODO: should we reset_age() for OLD as well?  Examine invocations of set_affiliation(). Some contexts redundantly\n+      \/\/       invoke reset_age().\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      return;\n+  }\n+  heap->set_affiliation(this, new_affiliation);\n+}\n+\n+\/\/ When we promote a region in place, we can continue to use the established marking context to guide subsequent remembered\n+\/\/ set scans of this region's content.  The region will be coalesced and filled prior to the next old-gen marking effort.\n+\/\/ We identify the entirety of the region as DIRTY to force the next remembered set scan to identify the \"interesting poitners\"\n+\/\/ contained herein.\n+void ShenandoahHeapRegion::promote_in_place() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+  HeapWord* tams = marking_context->top_at_mark_start(this);\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+  assert(is_young(), \"Only young regions can be promoted\");\n+  assert(is_regular(), \"Use different service to promote humongous regions\");\n+  assert(age() >= InitialTenuringThreshold, \"Only promote regions that are sufficiently aged\");\n+\n+  ShenandoahOldGeneration* old_gen = heap->old_generation();\n+  ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  {\n+    ShenandoahHeapLocker locker(heap->lock());\n+\n+    HeapWord* update_watermark = get_update_watermark();\n+\n+    \/\/ Now that this region is affiliated with old, we can allow it to receive allocations, though it may not be in the\n+    \/\/ is_collector_free range.\n+    restore_top_before_promote();\n+\n+    size_t region_capacity = free();\n+    size_t region_used = used();\n+\n+    \/\/ The update_watermark was likely established while we had the artificially high value of top.  Make it sane now.\n+    assert(update_watermark >= top(), \"original top cannot exceed preserved update_watermark\");\n+    set_update_watermark(top());\n+\n+    \/\/ Unconditionally transfer one region from young to old to represent the newly promoted region.\n+    \/\/ This expands old and shrinks new by the size of one region.  Strictly, we do not \"need\" to expand old\n+    \/\/ if there are already enough unaffiliated regions in old to account for this newly promoted region.\n+    \/\/ However, if we do not transfer the capacities, we end up reducing the amount of memory that would have\n+    \/\/ otherwise been available to hold old evacuations, because old available is max_capacity - used and now\n+    \/\/ we would be trading a fully empty region for a partially used region.\n+\n+    young_gen->decrease_used(region_used);\n+    young_gen->decrement_affiliated_region_count();\n+\n+    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n+    heap->generation_sizer()->force_transfer_to_old(1);\n+    set_affiliation(OLD_GENERATION);\n+\n+    old_gen->increment_affiliated_region_count();\n+    old_gen->increase_used(region_used);\n+\n+    \/\/ add_old_collector_free_region() increases promoted_reserve() if available space exceeds PLAB::min_size()\n+    heap->free_set()->add_old_collector_free_region(this);\n+  }\n+\n+  assert(top() == tams, \"Cannot promote regions in place if top has advanced beyond TAMS\");\n+\n+  \/\/ Since this region may have served previously as OLD, it may hold obsolete object range info.\n+  heap->card_scan()->reset_object_range(bottom(), end());\n+  heap->card_scan()->mark_range_as_dirty(bottom(), top() - bottom());\n+\n+  \/\/ TODO: use an existing coalesce-and-fill function rather than\n+  \/\/ replicating the code here.\n+  HeapWord* obj_addr = bottom();\n+  while (obj_addr < tams) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if (marking_context->is_marked(obj)) {\n+      assert(obj->klass() != NULL, \"klass should not be NULL\");\n+      \/\/ This thread is responsible for registering all objects in this region.  No need for lock.\n+      heap->card_scan()->register_object_without_lock(obj_addr);\n+      obj_addr += obj->size();\n+    } else {\n+      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, tams);\n+      assert(next_marked_obj <= tams, \"next marked object cannot exceed tams\");\n+      size_t fill_size = next_marked_obj - obj_addr;\n+      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated objects known to be larger than min_size\");\n+      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n+      heap->card_scan()->register_object_without_lock(obj_addr);\n+      obj_addr = next_marked_obj;\n+    }\n+  }\n+\n+  \/\/ We do not need to scan above TAMS because top equals tams\n+  assert(obj_addr == tams, \"Expect loop to terminate when obj_addr equals tams\");\n+}\n+\n+void ShenandoahHeapRegion::promote_humongous() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahMarkingContext* marking_context = heap->marking_context();\n+  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+  assert(is_young(), \"Only young regions can be promoted\");\n+  assert(is_humongous_start(), \"Should not promote humongous continuation in isolation\");\n+  assert(age() >= InitialTenuringThreshold, \"Only promote regions that are sufficiently aged\");\n+\n+  ShenandoahGeneration* old_generation = heap->old_generation();\n+  ShenandoahGeneration* young_generation = heap->young_generation();\n+\n+  oop obj = cast_to_oop(bottom());\n+  assert(marking_context->is_marked(obj), \"promoted humongous object should be alive\");\n+\n+  \/\/ TODO: Consider not promoting humongous objects that represent primitive arrays.  Leaving a primitive array\n+  \/\/ (obj->is_typeArray()) in young-gen is harmless because these objects are never relocated and they are not\n+  \/\/ scanned.  Leaving primitive arrays in young-gen memory allows their memory to be reclaimed more quickly when\n+  \/\/ it becomes garbage.  Better to not make this change until sizes of young-gen and old-gen are completely\n+  \/\/ adaptive, as leaving primitive arrays in young-gen might be perceived as an \"astonishing result\" by someone\n+  \/\/ has carefully analyzed the required sizes of an application's young-gen and old-gen.\n+  size_t used_bytes = obj->size() * HeapWordSize;\n+  size_t spanned_regions = ShenandoahHeapRegion::required_regions(used_bytes);\n+  size_t humongous_waste = spanned_regions * ShenandoahHeapRegion::region_size_bytes() - obj->size() * HeapWordSize;\n+  size_t index_limit = index() + spanned_regions;\n+  {\n+    \/\/ We need to grab the heap lock in order to avoid a race when changing the affiliations of spanned_regions from\n+    \/\/ young to old.\n+    ShenandoahHeapLocker locker(heap->lock());\n+\n+    \/\/ We promote humongous objects unconditionally, without checking for availability.  We adjust\n+    \/\/ usage totals, including humongous waste, after evacuation is done.\n+    log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", spanning \" SIZE_FORMAT, index(), spanned_regions);\n+\n+    young_generation->decrease_used(used_bytes);\n+    young_generation->decrease_humongous_waste(humongous_waste);\n+    young_generation->decrease_affiliated_region_count(spanned_regions);\n+\n+    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n+    heap->generation_sizer()->force_transfer_to_old(spanned_regions);\n+\n+    \/\/ For this region and each humongous continuation region spanned by this humongous object, change\n+    \/\/ affiliation to OLD_GENERATION and adjust the generation-use tallies.  The remnant of memory\n+    \/\/ in the last humongous region that is not spanned by obj is currently not used.\n+    for (size_t i = index(); i < index_limit; i++) {\n+      ShenandoahHeapRegion* r = heap->get_region(i);\n+      log_debug(gc)(\"promoting humongous region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                    r->index(), p2i(r->bottom()), p2i(r->top()));\n+      \/\/ We mark the entire humongous object's range as dirty after loop terminates, so no need to dirty the range here\n+      r->set_affiliation(OLD_GENERATION);\n+    }\n+\n+    old_generation->increase_affiliated_region_count(spanned_regions);\n+    old_generation->increase_used(used_bytes);\n+    old_generation->increase_humongous_waste(humongous_waste);\n+  }\n+\n+  \/\/ Since this region may have served previously as OLD, it may hold obsolete object range info.\n+  heap->card_scan()->reset_object_range(bottom(), bottom() + spanned_regions * ShenandoahHeapRegion::region_size_words());\n+  \/\/ Since the humongous region holds only one object, no lock is necessary for this register_object() invocation.\n+  heap->card_scan()->register_object_without_lock(bottom());\n+\n+  if (obj->is_typeArray()) {\n+    \/\/ Primitive arrays don't need to be scanned.\n+    log_debug(gc)(\"Clean cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                  index(), p2i(bottom()), p2i(bottom() + obj->size()));\n+    heap->card_scan()->mark_range_as_clean(bottom(), obj->size());\n+  } else {\n+    log_debug(gc)(\"Dirty cards for promoted humongous object (Region \" SIZE_FORMAT \") from \" PTR_FORMAT \" to \" PTR_FORMAT,\n+                  index(), p2i(bottom()), p2i(bottom() + obj->size()));\n+    heap->card_scan()->mark_range_as_dirty(bottom(), obj->size());\n+  }\n+}\n+\n+void ShenandoahHeapRegion::decrement_humongous_waste() const {\n+  assert(is_humongous(), \"Should only use this for humongous regions\");\n+  size_t waste_bytes = free();\n+  if (waste_bytes > 0) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    ShenandoahGeneration* generation = heap->generation_for(affiliation());\n+    heap->decrease_humongous_waste(generation, waste_bytes);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":496,"deletions":23,"binary":false,"changes":519,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n@@ -171,1 +173,2 @@\n-  void make_regular_allocation();\n+  void make_regular_allocation(ShenandoahAffiliation affiliation);\n+  void make_young_maybe();\n@@ -175,2 +178,2 @@\n-  void make_humongous_start_bypass();\n-  void make_humongous_cont_bypass();\n+  void make_humongous_start_bypass(ShenandoahAffiliation affiliation);\n+  void make_humongous_cont_bypass(ShenandoahAffiliation affiliation);\n@@ -201,0 +204,3 @@\n+  inline bool is_young() const;\n+  inline bool is_old() const;\n+  inline bool is_affiliated() const;\n@@ -213,0 +219,4 @@\n+  void clear_young_lab_flags();\n+  void set_young_lab_flag();\n+  bool has_young_lab_flag();\n+\n@@ -235,0 +245,2 @@\n+  HeapWord* _top_before_promoted;\n+\n@@ -237,0 +249,1 @@\n+  HeapWord* _coalesce_and_fill_boundary; \/\/ for old regions not selected as collection set candidates.\n@@ -243,0 +256,3 @@\n+  size_t _plab_allocs;\n+\n+  bool _has_young_lab;\n@@ -249,0 +265,2 @@\n+  uint _age;\n+\n@@ -337,2 +355,10 @@\n-  \/\/ Allocation (return null if full)\n-  inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);\n+  inline void save_top_before_promote();\n+  inline HeapWord* get_top_before_promote() const { return _top_before_promoted; }\n+  inline void restore_top_before_promote();\n+  inline size_t garbage_before_padded_for_promote() const;\n+\n+  \/\/ Allocation (return nullptr if full)\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_words);\n+\n+  \/\/ Allocation (return nullptr if full)\n+  inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest req);\n@@ -359,1 +385,35 @@\n-  void oop_iterate(OopIterateClosure* cl);\n+  inline void begin_preemptible_coalesce_and_fill() {\n+    _coalesce_and_fill_boundary = _bottom;\n+  }\n+\n+  inline void end_preemptible_coalesce_and_fill() {\n+    _coalesce_and_fill_boundary = _end;\n+  }\n+\n+  inline void suspend_coalesce_and_fill(HeapWord* next_focus) {\n+    _coalesce_and_fill_boundary = next_focus;\n+  }\n+\n+  inline HeapWord* resume_coalesce_and_fill() {\n+    return _coalesce_and_fill_boundary;\n+  }\n+\n+  \/\/ Coalesce contiguous spans of garbage objects by filling header and reregistering start locations with remembered set.\n+  \/\/ This is used by old-gen GC following concurrent marking to make old-gen HeapRegions parseable.  Return true iff\n+  \/\/ region is completely coalesced and filled.  Returns false if cancelled before task is complete.\n+  bool oop_fill_and_coalesce();\n+\n+  \/\/ Like oop_fill_and_coalesce(), but without honoring cancellation requests.\n+  bool oop_fill_and_coalesce_without_cancel();\n+\n+  \/\/ During global collections, this service iterates through an old-gen heap region that is not part of collection\n+  \/\/ set to fill and register ranges of dead memory.  Note that live objects were previously registered.  Some dead objects\n+  \/\/ that are subsumed into coalesced ranges of dead memory need to be \"unregistered\".\n+  void global_oop_iterate_and_fill_dead(OopIterateClosure* cl);\n+  void oop_iterate_humongous(OopIterateClosure* cl);\n+  void oop_iterate_humongous(OopIterateClosure* cl, HeapWord* start, size_t words);\n+\n+  \/\/ Invoke closure on every reference contained within the humongous object that spans this humongous\n+  \/\/ region if the reference is contained within a DIRTY card and the reference is no more than words following\n+  \/\/ start within the humongous object.\n+  void oop_iterate_humongous_slice(OopIterateClosure* cl, bool dirty_only, HeapWord* start, size_t words, bool write_table);\n@@ -379,0 +439,1 @@\n+  size_t used_before_promote() const { return byte_size(bottom(), get_top_before_promote()); }\n@@ -381,0 +442,5 @@\n+  \/\/ Does this region contain this address?\n+  bool contains(HeapWord* p) const {\n+    return (bottom() <= p) && (p < top());\n+  }\n+\n@@ -386,0 +452,1 @@\n+  size_t get_plab_allocs() const;\n@@ -391,0 +458,14 @@\n+  inline ShenandoahAffiliation affiliation() const;\n+  inline const char* affiliation_name() const;\n+\n+  void set_affiliation(ShenandoahAffiliation new_affiliation);\n+\n+  uint age()           { return _age; }\n+  void increment_age() { _age++; }\n+  void decrement_age() { if (_age-- == 0) { _age = 0; } }\n+  void reset_age()     { _age = 0; }\n+\n+  \/\/ Register all objects.  Set all remembered set cards to dirty.\n+  void promote_humongous();\n+  void promote_in_place();\n+\n@@ -392,0 +473,1 @@\n+  void decrement_humongous_waste() const;\n@@ -395,2 +477,3 @@\n-  void oop_iterate_objects(OopIterateClosure* cl);\n-  void oop_iterate_humongous(OopIterateClosure* cl);\n+  \/\/ This is an old-region that was not part of the collection set during a GLOBAL collection.  We coalesce the dead\n+  \/\/ objects, but do not need to register the live objects as they are already registered.\n+  void global_oop_iterate_objects_and_fill_dead(OopIterateClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":91,"deletions":8,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,1 +35,72 @@\n-HeapWord* ShenandoahHeapRegion::allocate(size_t size, ShenandoahAllocRequest::Type type) {\n+\/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n+\/\/ so that returned object is aligned on an address that is a multiple of alignment_in_words.  Requested\n+\/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n+\/\/ if necessary to assure the new allocation is properly aligned.\n+HeapWord* ShenandoahHeapRegion::allocate_aligned(size_t size, ShenandoahAllocRequest &req, size_t alignment_in_bytes) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(req.is_lab_alloc(), \"allocate_aligned() only applies to LAB allocations\");\n+  assert(is_object_aligned(size), \"alloc size breaks alignment: \" SIZE_FORMAT, size);\n+  assert(is_old(), \"aligned allocations are only taken from OLD regions to support PLABs\");\n+\n+  HeapWord* orig_top = top();\n+  size_t addr_as_int = (uintptr_t) orig_top;\n+\n+  \/\/ unalignment_bytes is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_bytes to determine padding required to next alignment point.\n+\n+  \/\/ top is HeapWord-aligned so unalignment_bytes is a multiple of HeapWordSize\n+  size_t unalignment_bytes = addr_as_int % alignment_in_bytes;\n+  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n+\n+  size_t pad_words;\n+  HeapWord* aligned_obj;\n+  if (unalignment_words > 0) {\n+    pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n+    if (pad_words < ShenandoahHeap::min_fill_size()) {\n+      pad_words += (alignment_in_bytes \/ HeapWordSize);\n+    }\n+    aligned_obj = orig_top + pad_words;\n+  } else {\n+    pad_words = 0;\n+    aligned_obj = orig_top;\n+  }\n+\n+  if (pointer_delta(end(), aligned_obj) < size) {\n+    size = pointer_delta(end(), aligned_obj);\n+    \/\/ Force size to align on multiple of alignment_in_bytes\n+    size_t byte_size = size * HeapWordSize;\n+    size_t excess_bytes = byte_size % alignment_in_bytes;\n+    \/\/ Note: excess_bytes is a multiple of HeapWordSize because it is the difference of HeapWord-aligned end\n+    \/\/       and proposed HeapWord-aligned object address.\n+    if (excess_bytes > 0) {\n+      size -= excess_bytes \/ HeapWordSize;\n+    }\n+  }\n+\n+  \/\/ Both originally requested size and adjusted size must be properly aligned\n+  assert ((size * HeapWordSize) % alignment_in_bytes == 0, \"Size must be multiple of alignment constraint\");\n+  if (size >= req.min_size()) {\n+    \/\/ Even if req.min_size() is not a multiple of card size, we know that size is.\n+    if (pad_words > 0) {\n+      assert(pad_words >= ShenandoahHeap::min_fill_size(), \"pad_words expanded above to meet size constraint\");\n+      ShenandoahHeap::fill_with_object(orig_top, pad_words);\n+      ShenandoahHeap::heap()->card_scan()->register_object(orig_top);\n+    }\n+\n+    make_regular_allocation(req.affiliation());\n+    adjust_alloc_metadata(req.type(), size);\n+\n+    HeapWord* new_top = aligned_obj + size;\n+    assert(new_top <= end(), \"PLAB cannot span end of heap region\");\n+    set_top(new_top);\n+    req.set_actual_size(size);\n+    req.set_waste(pad_words);\n+    assert(is_object_aligned(new_top), \"new top breaks alignment: \" PTR_FORMAT, p2i(new_top));\n+    assert(is_aligned(aligned_obj, alignment_in_bytes), \"obj is not aligned: \" PTR_FORMAT, p2i(aligned_obj));\n+    return aligned_obj;\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+HeapWord* ShenandoahHeapRegion::allocate(size_t size, ShenandoahAllocRequest req) {\n@@ -40,2 +112,2 @@\n-    make_regular_allocation();\n-    adjust_alloc_metadata(type, size);\n+    make_regular_allocation(req.affiliation());\n+    adjust_alloc_metadata(req.type(), size);\n@@ -67,0 +139,3 @@\n+    case ShenandoahAllocRequest::_alloc_plab:\n+      _plab_allocs += size;\n+      break;\n@@ -85,6 +160,0 @@\n-#ifdef ASSERT\n-  size_t live_bytes = new_live_data * HeapWordSize;\n-  size_t used_bytes = used();\n-  assert(live_bytes <= used_bytes,\n-         \"can't have more live data than used: \" SIZE_FORMAT \", \" SIZE_FORMAT, live_bytes, used_bytes);\n-#endif\n@@ -118,0 +187,11 @@\n+inline size_t ShenandoahHeapRegion::garbage_before_padded_for_promote() const {\n+  size_t used_before_promote = byte_size(bottom(), get_top_before_promote());\n+  assert(get_top_before_promote() != nullptr, \"top before promote should not equal null\");\n+  assert(used_before_promote >= get_live_data_bytes(),\n+         \"Live Data must be a subset of used before promotion live: \" SIZE_FORMAT \" used: \" SIZE_FORMAT,\n+         get_live_data_bytes(), used_before_promote);\n+  size_t result = used_before_promote - get_live_data_bytes();\n+  return result;\n+\n+}\n+\n@@ -136,0 +216,45 @@\n+inline ShenandoahAffiliation ShenandoahHeapRegion::affiliation() const {\n+  return ShenandoahHeap::heap()->region_affiliation(this);\n+}\n+\n+inline const char* ShenandoahHeapRegion::affiliation_name() const {\n+  return shenandoah_affiliation_name(affiliation());\n+}\n+\n+inline void ShenandoahHeapRegion::clear_young_lab_flags() {\n+  _has_young_lab = false;\n+}\n+\n+inline void ShenandoahHeapRegion::set_young_lab_flag() {\n+  _has_young_lab = true;\n+}\n+\n+inline bool ShenandoahHeapRegion::has_young_lab_flag() {\n+  return _has_young_lab;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_young() const {\n+  return affiliation() == YOUNG_GENERATION;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_old() const {\n+  return affiliation() == OLD_GENERATION;\n+}\n+\n+inline bool ShenandoahHeapRegion::is_affiliated() const {\n+  return affiliation() != FREE;\n+}\n+\n+inline void ShenandoahHeapRegion::save_top_before_promote() {\n+  _top_before_promoted = _top;\n+}\n+\n+inline void ShenandoahHeapRegion::restore_top_before_promote() {\n+  _top = _top_before_promoted;\n+#ifdef ASSERT\n+  _top_before_promoted = nullptr;\n+#endif\n+ }\n+\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":134,"deletions":9,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -24,1 +25,0 @@\n-\n@@ -26,0 +26,2 @@\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -33,0 +36,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -44,1 +48,1 @@\n-    strcpy(_name_space, cns);\n+    strcpy(_name_space, cns); \/\/ copy cns into _name_space\n@@ -52,0 +56,3 @@\n+    cname = PerfDataManager::counter_name(_name_space, \"protocol_version\"); \/\/creating new protocol_version\n+    PerfDataManager::create_constant(SUN_GC, cname, PerfData::U_None, VERSION_NUMBER, CHECK);\n+\n@@ -60,0 +67,1 @@\n+    \/\/ Initializing performance data resources for each region\n@@ -69,0 +77,1 @@\n+\n@@ -76,0 +85,22 @@\n+void ShenandoahHeapRegionCounters::write_snapshot(PerfLongVariable** regions,\n+                                             PerfLongVariable* ts,\n+                                             PerfLongVariable* status,\n+                                             size_t num_regions,\n+                                             size_t region_size, size_t protocol_version) {\n+  LogTarget(Trace, gc, region) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+\n+    ls.print_cr(JLONG_FORMAT \" \" JLONG_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT,\n+            ts->get_value(), status->get_value(), num_regions, region_size, protocol_version);\n+    if (num_regions > 0) {\n+      ls.print(JLONG_FORMAT, regions[0]->get_value());\n+    }\n+    for (uint i = 1; i < num_regions; ++i) {\n+      ls.print(\" \" JLONG_FORMAT, regions[i]->get_value());\n+    }\n+    ls.cr();\n+  }\n+}\n+\n@@ -80,2 +111,1 @@\n-    if (current - last > ShenandoahRegionSamplingRate &&\n-            Atomic::cmpxchg(&_last_sample_millis, last, current) == last) {\n+    if (current - last > ShenandoahRegionSamplingRate && Atomic::cmpxchg(&_last_sample_millis, last, current) == last) {\n@@ -84,6 +114,1 @@\n-      jlong status = 0;\n-      if (heap->is_concurrent_mark_in_progress())      status |= 1 << 0;\n-      if (heap->is_evacuation_in_progress())           status |= 1 << 1;\n-      if (heap->is_update_refs_in_progress())          status |= 1 << 2;\n-      _status->set_value(status);\n-\n+      _status->set_value(encode_heap_status(heap));\n@@ -92,2 +117,0 @@\n-      size_t num_regions = heap->num_regions();\n-\n@@ -97,0 +120,1 @@\n+        size_t num_regions = heap->num_regions();\n@@ -104,0 +128,1 @@\n+          data |= ((100 * r->get_plab_allocs() \/ rs)     & PERCENT_MASK) << PLAB_SHIFT;\n@@ -105,0 +130,3 @@\n+\n+          data |= (r->age() & AGE_MASK) << AGE_SHIFT;\n+          data |= (r->affiliation() & AFFILIATION_MASK) << AFFILIATION_SHIFT;\n@@ -108,0 +136,3 @@\n+\n+        \/\/ If logging enabled, dump current region snapshot to log file\n+        write_snapshot(_regions_data, _timestamp, _status, num_regions, rs >> 10, VERSION_NUMBER);\n@@ -109,0 +140,38 @@\n+    }\n+  }\n+}\n+\n+static int encode_phase(ShenandoahHeap* heap) {\n+  if (heap->is_evacuation_in_progress() || heap->is_full_gc_move_in_progress()) {\n+    return 2;\n+  }\n+  if (heap->is_update_refs_in_progress() || heap->is_full_gc_move_in_progress()) {\n+    return 3;\n+  }\n+  if (heap->is_concurrent_mark_in_progress() || heap->is_full_gc_in_progress()) {\n+    return 1;\n+  }\n+  assert(heap->is_idle(), \"What is it doing?\");\n+  return 0;\n+}\n+\n+static int get_generation_shift(ShenandoahGeneration* generation) {\n+  switch (generation->type()) {\n+    case GLOBAL_NON_GEN:\n+    case GLOBAL_GEN:\n+      return 0;\n+    case OLD:\n+      return 2;\n+    case YOUNG:\n+      return 4;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n+jlong ShenandoahHeapRegionCounters::encode_heap_status(ShenandoahHeap* heap) {\n+\n+  if (heap->is_idle() && !heap->is_full_gc_in_progress()) {\n+    return 0;\n+  }\n@@ -110,0 +179,11 @@\n+  jlong status = 0;\n+  if (!heap->mode()->is_generational()) {\n+    status = encode_phase(heap);\n+  } else {\n+    int phase = encode_phase(heap);\n+    ShenandoahGeneration* generation = heap->active_generation();\n+    assert(generation != nullptr, \"Expected active generation in this mode.\");\n+    int shift = get_generation_shift(generation);\n+    status |= ((phase & 0x3) << shift);\n+    if (heap->is_concurrent_old_mark_in_progress()) {\n+      status |= (1 << 2);\n@@ -111,0 +191,2 @@\n+    log_develop_trace(gc)(\"%s, phase=%u, old_mark=%s, status=\" JLONG_FORMAT,\n+                          generation->name(), phase, BOOL_TO_STR(heap->is_concurrent_old_mark_in_progress()), status);\n@@ -112,0 +194,9 @@\n+\n+  if (heap->is_degenerated_gc_in_progress()) {\n+    status |= (1 << 6);\n+  }\n+  if (heap->is_full_gc_in_progress()) {\n+    status |= (1 << 7);\n+  }\n+\n+  return status;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":103,"deletions":12,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"logging\/logFileStreamOutput.hpp\"\n@@ -40,3 +42,8 @@\n- *     - bit 0 set when marking in progress\n- *     - bit 1 set when evacuation in progress\n- *     - bit 2 set when update refs in progress\n+ *   | global | old   | young | mode |\n+ *   |  0..1  | 2..3  | 4..5  | 6..7 |\n+ *\n+ *   For each generation:\n+ *   0 = idle, 1 = marking, 2 = evacuating, 3 = updating refs\n+ *\n+ *   For mode:\n+ *   0 = concurrent, 1 = degenerated, 2 = full\n@@ -54,1 +61,1 @@\n- * - bits 35-41  <reserved>\n+ * - bits 35-41  plab allocated memory in percent\n@@ -56,1 +63,2 @@\n- * - bits 51-57  <reserved>\n+ * - bits 51-55  age\n+ * - bits 56-57  affiliation: 0 = free, young = 1, old = 2\n@@ -62,2 +70,4 @@\n-  static const jlong PERCENT_MASK = 0x7f;\n-  static const jlong STATUS_MASK  = 0x3f;\n+  static const jlong PERCENT_MASK      = 0x7f;\n+  static const jlong AGE_MASK          = 0x1f;\n+  static const jlong AFFILIATION_MASK  = 0x03;\n+  static const jlong STATUS_MASK       = 0x3f;\n@@ -65,5 +75,9 @@\n-  static const jlong USED_SHIFT   = 0;\n-  static const jlong LIVE_SHIFT   = 7;\n-  static const jlong TLAB_SHIFT   = 14;\n-  static const jlong GCLAB_SHIFT  = 21;\n-  static const jlong SHARED_SHIFT = 28;\n+  static const jlong USED_SHIFT        = 0;\n+  static const jlong LIVE_SHIFT        = 7;\n+  static const jlong TLAB_SHIFT        = 14;\n+  static const jlong GCLAB_SHIFT       = 21;\n+  static const jlong SHARED_SHIFT      = 28;\n+  static const jlong PLAB_SHIFT        = 35;\n+  static const jlong AGE_SHIFT         = 51;\n+  static const jlong AFFILIATION_SHIFT = 56;\n+  static const jlong STATUS_SHIFT      = 58;\n@@ -71,1 +85,1 @@\n-  static const jlong STATUS_SHIFT = 58;\n+  static const jlong VERSION_NUMBER    = 2;\n@@ -79,0 +93,7 @@\n+  void write_snapshot(PerfLongVariable** regions,\n+                      PerfLongVariable* ts,\n+                      PerfLongVariable* status,\n+                      size_t num_regions,\n+                      size_t region_size, size_t protocolVersion);\n+\n+  uint _count = 0;\n@@ -83,0 +104,3 @@\n+\n+private:\n+  static jlong encode_heap_status(ShenandoahHeap* heap) ;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.hpp","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,2 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -43,2 +46,20 @@\n-  log_info(gc, init)(\"Heuristics: %s\",\n-                     heap->heuristics()->name());\n+  if (!heap->mode()->is_generational()) {\n+    log_info(gc, init)(\"Heuristics: %s\", heap->global_generation()->heuristics()->name());\n+  } else {\n+    log_info(gc, init)(\"Young Heuristics: %s\", heap->young_generation()->heuristics()->name());\n+    log_info(gc, init)(\"Young Generation Soft Size: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->young_generation()->soft_max_capacity()),\n+                       proper_unit_for_byte_size(heap->young_generation()->soft_max_capacity()));\n+    log_info(gc, init)(\"Young Generation Max: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->young_generation()->max_capacity()),\n+                       proper_unit_for_byte_size(heap->young_generation()->max_capacity()));\n+    log_info(gc, init)(\"Old Heuristics: %s\", heap->old_generation()->heuristics()->name());\n+    log_info(gc, init)(\"Old Generation Soft Size: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->old_generation()->soft_max_capacity()),\n+                       proper_unit_for_byte_size(heap->old_generation()->soft_max_capacity()));\n+    log_info(gc, init)(\"Old Generation Max: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_proper_unit(heap->old_generation()->max_capacity()),\n+                       proper_unit_for_byte_size(heap->old_generation()->max_capacity()));\n+  }\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -37,11 +39,0 @@\n-ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q,  ShenandoahReferenceProcessor* rp) :\n-  MetadataVisitingOopIterateClosure(rp),\n-  _queue(q),\n-  _mark_context(ShenandoahHeap::heap()->marking_context()),\n-  _weak(false)\n-{ }\n-\n-ShenandoahMark::ShenandoahMark() :\n-  _task_queues(ShenandoahHeap::heap()->marking_context()->task_queues()) {\n-}\n-\n@@ -57,1 +48,3 @@\n-  CodeCache::on_gc_marking_cycle_finish();\n+  if (!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress()) {\n+    CodeCache::on_gc_marking_cycle_finish();\n+  }\n@@ -60,4 +53,7 @@\n-void ShenandoahMark::clear() {\n-  \/\/ Clean up marking stacks.\n-  ShenandoahObjToScanQueueSet* queues = ShenandoahHeap::heap()->marking_context()->task_queues();\n-  queues->clear();\n+ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q,  ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+  MetadataVisitingOopIterateClosure(rp),\n+  _queue(q),\n+  _old_queue(old_q),\n+  _mark_context(ShenandoahHeap::heap()->marking_context()),\n+  _weak(false)\n+{ }\n@@ -65,2 +61,4 @@\n-  \/\/ Cancel SATB buffers.\n-  ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+ShenandoahMark::ShenandoahMark(ShenandoahGeneration* generation) :\n+  _generation(generation),\n+  _task_queues(generation->task_queues()),\n+  _old_gen_task_queues(generation->old_gen_task_queues()) {\n@@ -69,2 +67,2 @@\n-template <bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n-void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req) {\n+template <ShenandoahGenerationType GENERATION, bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n+void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs) {\n@@ -72,0 +70,1 @@\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(w);\n@@ -78,4 +77,4 @@\n-  if (heap->has_forwarded_objects()) {\n-    using Closure = ShenandoahMarkUpdateRefsClosure;\n-    Closure cl(q, rp);\n-    mark_loop_work<Closure, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n+  if (update_refs) {\n+    using Closure = ShenandoahMarkUpdateRefsClosure<GENERATION>;\n+    Closure cl(q, rp, old_q);\n+    mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n@@ -83,3 +82,3 @@\n-    using Closure = ShenandoahMarkRefsClosure;\n-    Closure cl(q, rp);\n-    mark_loop_work<Closure, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n+    using Closure = ShenandoahMarkRefsClosure<GENERATION>;\n+    Closure cl(q, rp, old_q);\n+    mark_loop_work<Closure, GENERATION, CANCELLABLE, STRING_DEDUP>(&cl, ld, w, t, req);\n@@ -91,2 +90,25 @@\n-void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n-               bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n+template<bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n+void ShenandoahMark::mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req) {\n+  bool update_refs = ShenandoahHeap::heap()->has_forwarded_objects();\n+  switch (generation) {\n+    case YOUNG:\n+      mark_loop_prework<YOUNG, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    case OLD:\n+      \/\/ Old generation collection only performs marking, it should not update references.\n+      mark_loop_prework<OLD, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, false);\n+      break;\n+    case GLOBAL_GEN:\n+      mark_loop_prework<GLOBAL_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    case GLOBAL_NON_GEN:\n+      mark_loop_prework<GLOBAL_NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+  }\n+}\n+\n+void ShenandoahMark::mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                               bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n@@ -96,1 +118,1 @@\n-        mark_loop_prework<true, NO_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<true, NO_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -99,1 +121,1 @@\n-        mark_loop_prework<true, ENQUEUE_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<true, ENQUEUE_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -102,1 +124,1 @@\n-        mark_loop_prework<true, ALWAYS_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<true, ALWAYS_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -108,1 +130,1 @@\n-        mark_loop_prework<false, NO_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<false, NO_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -111,1 +133,1 @@\n-        mark_loop_prework<false, ENQUEUE_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<false, ENQUEUE_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -114,1 +136,1 @@\n-        mark_loop_prework<false, ALWAYS_DEDUP>(worker_id, terminator, rp, req);\n+        mark_loop<false, ALWAYS_DEDUP>(generation, worker_id, terminator, rp, req);\n@@ -120,1 +142,1 @@\n-template <class T, bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n+template <class T, ShenandoahGenerationType GENERATION, bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n@@ -129,1 +151,2 @@\n-  heap->ref_processor()->set_mark_closure(worker_id, cl);\n+  assert(heap->active_generation()->type() == GENERATION, \"Sanity\");\n+  heap->active_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n@@ -158,0 +181,1 @@\n+  ShenandoahObjToScanQueue* old_q = get_old_queue(worker_id);\n@@ -159,1 +183,1 @@\n-  ShenandoahSATBBufferClosure drain_satb(q);\n+  ShenandoahSATBBufferClosure<GENERATION> drain_satb(q, old_q);\n@@ -169,1 +193,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":62,"deletions":39,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,2 +34,0 @@\n-class ShenandoahCMDrainMarkingStackClosure;\n-\n@@ -39,1 +38,0 @@\n-  friend class ShenandoahCMDrainMarkingStackClosure;\n@@ -42,0 +40,1 @@\n+  ShenandoahGeneration* const _generation;\n@@ -43,0 +42,1 @@\n+  ShenandoahObjToScanQueueSet* const _old_gen_task_queues;\n@@ -45,1 +45,1 @@\n-  ShenandoahMark();\n+  ShenandoahMark(ShenandoahGeneration* generation);\n@@ -48,4 +48,2 @@\n-  template<class T>\n-  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n-\n-  static void clear();\n+  template<class T, ShenandoahGenerationType GENERATION>\n+  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak);\n@@ -59,0 +57,4 @@\n+  ShenandoahObjToScanQueueSet* old_task_queues() {\n+    return _old_gen_task_queues;\n+  }\n+\n@@ -60,0 +62,3 @@\n+  inline ShenandoahObjToScanQueue* get_old_queue(uint index) const;\n+\n+  inline ShenandoahGeneration* generation() { return _generation; };\n@@ -74,1 +79,1 @@\n-  template <class T, bool CANCELLABLE,StringDedupMode STRING_DEDUP>\n+  template <class T, ShenandoahGenerationType GENERATION, bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n@@ -77,2 +82,9 @@\n-  template <bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n-  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req);\n+  template <ShenandoahGenerationType GENERATION, bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n+  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs);\n+\n+  template <ShenandoahGenerationType GENERATION>\n+  static bool in_generation(ShenandoahHeap* const heap, oop obj);\n+\n+  static void mark_ref(ShenandoahObjToScanQueue* q,\n+                       ShenandoahMarkingContext* const mark_context,\n+                       bool weak, oop obj);\n@@ -83,1 +95,5 @@\n-  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+  template<bool CANCELLABLE, StringDedupMode STRING_DEDUP>\n+  void mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                 StringDedup::Requests* const req);\n+\n+  void mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -63,0 +64,4 @@\n+  \/\/ TODO: This will push array chunks into the mark queue with no regard for\n+  \/\/ generations. I don't think it will break anything, but the young generation\n+  \/\/ scan might end up processing some old generation array chunks.\n+\n@@ -113,0 +118,1 @@\n+    assert(region->is_affiliated(), \"Do not count live data within Free Regular Region \" SIZE_FORMAT, region_idx);\n@@ -127,0 +133,1 @@\n+    assert(region->is_affiliated(), \"Do not count live data within FREE Humongous Start Region \" SIZE_FORMAT, region_idx);\n@@ -130,0 +137,1 @@\n+      assert(chain_reg->is_affiliated(), \"Do not count live data within FREE Humongous Continuation Region \" SIZE_FORMAT, i);\n@@ -232,0 +240,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -235,0 +244,1 @@\n+  ShenandoahObjToScanQueue* _old_queue;\n@@ -238,1 +248,1 @@\n-  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q) :\n+  ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q) :\n@@ -240,0 +250,1 @@\n+    _old_queue(old_q),\n@@ -246,1 +257,1 @@\n-    assert(size == 0 || !_heap->has_forwarded_objects(), \"Forwarded objects are not expected here\");\n+    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n@@ -249,1 +260,1 @@\n-      ShenandoahMark::mark_through_ref<oop>(p, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, GENERATION>(p, _queue, _old_queue, _mark_context, false);\n@@ -254,2 +265,19 @@\n-template<class T>\n-inline void ShenandoahMark::mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+template<ShenandoahGenerationType GENERATION>\n+bool ShenandoahMark::in_generation(ShenandoahHeap* const heap, oop obj) {\n+  \/\/ Each in-line expansion of in_generation() resolves GENERATION at compile time.\n+  if (GENERATION == YOUNG) {\n+    return heap->is_in_young(obj);\n+  } else if (GENERATION == OLD) {\n+    return heap->is_in_old(obj);\n+  } else if (GENERATION == GLOBAL_GEN || GENERATION == GLOBAL_NON_GEN) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+template<class T, ShenandoahGenerationType GENERATION>\n+inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahObjToScanQueue* q, ShenandoahObjToScanQueue* old_q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+  \/\/ Note: This is a very hot code path, so the code should be conditional on GENERATION template\n+  \/\/ parameter where possible, in order to generate the most efficient code.\n+\n@@ -260,0 +288,1 @@\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -261,12 +290,28 @@\n-    shenandoah_assert_not_in_cset_except(p, obj, ShenandoahHeap::heap()->cancelled_gc());\n-\n-    bool skip_live = false;\n-    bool marked;\n-    if (weak) {\n-      marked = mark_context->mark_weak(obj);\n-    } else {\n-      marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n-    }\n-    if (marked) {\n-      bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n-      assert(pushed, \"overflow queue should always succeed pushing\");\n+    shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n+    if (in_generation<GENERATION>(heap, obj)) {\n+      mark_ref(q, mark_context, weak, obj);\n+      shenandoah_assert_marked(p, obj);\n+      \/\/ TODO: As implemented herein, GLOBAL_GEN collections reconstruct the card table during GLOBAL_GEN concurrent\n+      \/\/ marking. Note that the card table is cleaned at init_mark time so it needs to be reconstructed to support\n+      \/\/ future young-gen collections.  It might be better to reconstruct card table in\n+      \/\/ ShenandoahHeapRegion::global_oop_iterate_and_fill_dead.  We could either mark all live memory as dirty, or could\n+      \/\/ use the GLOBAL update-refs scanning of pointers to determine precisely which cards to flag as dirty.\n+      if (GENERATION == YOUNG && heap->is_in_old(p)) {\n+        \/\/ Mark card as dirty because remembered set scanning still finds interesting pointer.\n+        heap->mark_card_as_dirty((HeapWord*)p);\n+      } else if (GENERATION == GLOBAL_GEN && heap->is_in_old(p) && heap->is_in_young(obj)) {\n+        \/\/ Mark card as dirty because GLOBAL marking finds interesting pointer.\n+        heap->mark_card_as_dirty((HeapWord*)p);\n+      }\n+    } else if (old_q != nullptr) {\n+      \/\/ Young mark, bootstrapping old_q or concurrent with old_q marking.\n+      mark_ref(old_q, mark_context, weak, obj);\n+      shenandoah_assert_marked(p, obj);\n+    } else if (GENERATION == OLD) {\n+      \/\/ Old mark, found a young pointer.\n+      \/\/ TODO:  Rethink this: may be redundant with dirtying of cards identified during young-gen remembered set scanning\n+      \/\/ and by mutator write barriers.  Assert\n+      if (heap->is_in(p)) {\n+        assert(heap->is_in_young(obj), \"Expected young object.\");\n+        heap->mark_card_as_dirty(p);\n+      }\n@@ -274,0 +319,2 @@\n+  }\n+}\n@@ -275,1 +322,13 @@\n-    shenandoah_assert_marked(p, obj);\n+inline void ShenandoahMark::mark_ref(ShenandoahObjToScanQueue* q,\n+                              ShenandoahMarkingContext* const mark_context,\n+                              bool weak, oop obj) {\n+  bool skip_live = false;\n+  bool marked;\n+  if (weak) {\n+    marked = mark_context->mark_weak(obj);\n+  } else {\n+    marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n+  }\n+  if (marked) {\n+    bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n+    assert(pushed, \"overflow queue should always succeed pushing\");\n@@ -286,0 +345,8 @@\n+\n+ShenandoahObjToScanQueue* ShenandoahMark::get_old_queue(uint index) const {\n+  if (_old_gen_task_queues != nullptr) {\n+    return _old_gen_task_queues->queue(index);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":85,"deletions":18,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -46,0 +47,14 @@\n+bool ShenandoahMarkBitMap::is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const {\n+  \/\/ Similar to get_next_marked_addr(), without assertion.\n+  \/\/ Round addr up to a possible object boundary to be safe.\n+  if (start == end) {\n+    return true;\n+  }\n+  size_t const addr_offset = address_to_index(align_up(start, HeapWordSize << LogMinObjAlignment));\n+  size_t const limit_offset = address_to_index(end);\n+  size_t const next_offset = get_next_one_offset(addr_offset, limit_offset);\n+  HeapWord* result = index_to_address(next_offset);\n+  return (result == end);\n+}\n+\n+\n@@ -48,0 +63,5 @@\n+#ifdef ASSERT\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(addr);\n+  ShenandoahMarkingContext* ctx = heap->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(r);\n@@ -49,0 +69,4 @@\n+  assert(limit <= r->top(), \"limit must be less than top\");\n+  assert(addr <= tams, \"addr must be less than TAMS\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -162,0 +163,2 @@\n+  bool is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+\n+ShenandoahFinalMarkUpdateRegionStateClosure::ShenandoahFinalMarkUpdateRegionStateClosure(\n+  ShenandoahMarkingContext *ctx) :\n+  _ctx(ctx), _lock(ShenandoahHeap::heap()->lock()) {}\n+\n+void ShenandoahFinalMarkUpdateRegionStateClosure::heap_region_do(ShenandoahHeapRegion* r) {\n+  if (r->is_active()) {\n+    if (_ctx != nullptr) {\n+      \/\/ _ctx may be null when this closure is used to sync only the pin status\n+      \/\/ update the watermark of old regions. For old regions we cannot reset\n+      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n+      \/\/ old marking is complete.\n+\n+      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n+      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+      if (top > tams) {\n+        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n+      }\n+    }\n+\n+    \/\/ We are about to select the collection set, make sure it knows about\n+    \/\/ current pinning status. Also, this allows trashing more regions that\n+    \/\/ now have their pinning status dropped.\n+    if (r->is_pinned()) {\n+      if (r->pin_count() == 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_unpinned();\n+      }\n+    } else {\n+      if (r->pin_count() > 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_pinned();\n+      }\n+    }\n+\n+    \/\/ Remember limit for updating refs. It's guaranteed that we get no\n+    \/\/ from-space-refs written from here on.\n+    r->set_update_watermark_at_safepoint(r->top());\n+  } else {\n+    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n+    assert(_ctx == nullptr || _ctx->top_at_mark_start(r) == r->top(),\n+             \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+\n+class ShenandoahMarkingContext;\n+class ShenandoahHeapRegion;\n+\n+class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahHeapLock* const _lock;\n+public:\n+  explicit ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext* ctx);\n+\n+  void heap_region_do(ShenandoahHeapRegion* r);\n+\n+  bool is_thread_safe() { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -28,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n@@ -30,2 +30,0 @@\n-#include \"gc\/shenandoah\/shenandoahTaskqueue.inline.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n@@ -33,1 +31,1 @@\n-ShenandoahMarkingContext::ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions, uint max_queues) :\n+ShenandoahMarkingContext::ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions) :\n@@ -38,15 +36,1 @@\n-                      ((uintx) heap_region.start() >> ShenandoahHeapRegion::region_size_bytes_shift())),\n-  _task_queues(new ShenandoahObjToScanQueueSet(max_queues)) {\n-  assert(max_queues > 0, \"At least one queue\");\n-  for (uint i = 0; i < max_queues; ++i) {\n-    ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();\n-    _task_queues->register_queue(i, task_queue);\n-  }\n-}\n-\n-ShenandoahMarkingContext::~ShenandoahMarkingContext() {\n-  for (uint i = 0; i < _task_queues->size(); ++i) {\n-    ShenandoahObjToScanQueue* q = _task_queues->queue(i);\n-    delete q;\n-  }\n-  delete _task_queues;\n+                      ((uintx) heap_region.start() >> ShenandoahHeapRegion::region_size_bytes_shift())) {\n@@ -60,1 +44,1 @@\n-    if (heap->is_bitmap_slice_committed(r) && !is_bitmap_clear_range(r->bottom(), r->end())) {\n+    if (r->is_affiliated() && heap->is_bitmap_slice_committed(r) && !is_bitmap_clear_range(r->bottom(), r->end())) {\n@@ -67,2 +51,14 @@\n-bool ShenandoahMarkingContext::is_bitmap_clear_range(HeapWord* start, HeapWord* end) const {\n-  return _mark_bit_map.get_next_marked_addr(start, end) == end;\n+bool ShenandoahMarkingContext::is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const {\n+  if (start < end) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t start_idx = heap->heap_region_index_containing(start);\n+    size_t end_idx = heap->heap_region_index_containing(end - 1);\n+    while (start_idx <= end_idx) {\n+      ShenandoahHeapRegion* r = heap->get_region(start_idx);\n+      if (!heap->is_bitmap_slice_committed(r)) {\n+        return true;\n+      }\n+      start_idx++;\n+    }\n+  }\n+  return _mark_bit_map.is_bitmap_clear_range(start, end);\n@@ -74,0 +70,1 @@\n+\n@@ -76,0 +73,7 @@\n+\n+  log_debug(gc)(\"SMC:initialize_top_at_mark_start for Region \" SIZE_FORMAT \", TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n+                r->index(), p2i(bottom), p2i(r->end()));\n+}\n+\n+HeapWord* ShenandoahMarkingContext::top_bitmap(ShenandoahHeapRegion* r) {\n+  return _top_bitmaps[r->index()];\n@@ -79,0 +83,6 @@\n+  if (!r->is_affiliated()) {\n+    \/\/ Heap iterators include FREE regions, which don't need to be cleared.\n+    \/\/ TODO: would be better for certain iterators to not include FREE regions.\n+    return;\n+  }\n+\n@@ -81,0 +91,4 @@\n+\n+  log_debug(gc)(\"SMC:clear_bitmap for %s Region \" SIZE_FORMAT \", top_bitmap: \" PTR_FORMAT,\n+                r->affiliation_name(), r->index(), p2i(top_bitmap));\n+\n@@ -85,0 +99,4 @@\n+\n+  \/\/ TODO: Why is clear_live_data here?\n+  r->clear_live_data();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -50,3 +51,0 @@\n-  \/\/ Marking task queues\n-  ShenandoahObjToScanQueueSet* _task_queues;\n-\n@@ -54,2 +52,1 @@\n-  ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions, uint max_queues);\n-  ~ShenandoahMarkingContext();\n+  ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions);\n@@ -66,3 +63,6 @@\n-  inline bool is_marked(oop) const;\n-  inline bool is_marked_strong(oop obj) const;\n-  inline bool is_marked_weak(oop obj) const;\n+  \/\/ TODO: Do these really need to be const?\n+  inline bool is_marked(const oop) const;\n+  inline bool is_marked_strong(const oop obj) const;\n+  inline bool is_marked_weak(const oop obj) const;\n+  inline bool is_marked_or_old(const oop obj) const;\n+  inline bool is_marked_strong_or_old(const oop obj) const;\n@@ -70,1 +70,1 @@\n-  inline HeapWord* get_next_marked_addr(HeapWord* addr, HeapWord* limit) const;\n+  inline HeapWord* get_next_marked_addr(const HeapWord* addr, const HeapWord* limit) const;\n@@ -72,2 +72,2 @@\n-  inline bool allocated_after_mark_start(oop obj) const;\n-  inline bool allocated_after_mark_start(HeapWord* addr) const;\n+  inline bool allocated_after_mark_start(const oop obj) const;\n+  inline bool allocated_after_mark_start(const HeapWord* addr) const;\n@@ -75,1 +75,1 @@\n-  inline HeapWord* top_at_mark_start(ShenandoahHeapRegion* r) const;\n+  inline HeapWord* top_at_mark_start(const ShenandoahHeapRegion* r) const;\n@@ -80,0 +80,2 @@\n+  HeapWord* top_bitmap(ShenandoahHeapRegion* r);\n+\n@@ -84,1 +86,1 @@\n-  bool is_bitmap_clear_range(HeapWord* start, HeapWord* end) const;\n+  bool is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const;\n@@ -89,3 +91,0 @@\n-\n-  \/\/ Task queues\n-  ShenandoahObjToScanQueueSet* task_queues() const { return _task_queues; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,0 @@\n-\n@@ -31,0 +31,1 @@\n+#include \"logging\/log.hpp\"\n@@ -40,1 +41,1 @@\n-inline bool ShenandoahMarkingContext::is_marked(oop obj) const {\n+inline bool ShenandoahMarkingContext::is_marked(const oop obj) const {\n@@ -44,1 +45,1 @@\n-inline bool ShenandoahMarkingContext::is_marked_strong(oop obj) const {\n+inline bool ShenandoahMarkingContext::is_marked_strong(const oop obj) const {\n@@ -48,1 +49,1 @@\n-inline bool ShenandoahMarkingContext::is_marked_weak(oop obj) const {\n+inline bool ShenandoahMarkingContext::is_marked_weak(const oop obj) const {\n@@ -52,1 +53,9 @@\n-inline HeapWord* ShenandoahMarkingContext::get_next_marked_addr(HeapWord* start, HeapWord* limit) const {\n+inline bool ShenandoahMarkingContext::is_marked_or_old(const oop obj) const {\n+  return is_marked(obj) || ShenandoahHeap::heap()->is_old(obj);\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong_or_old(const oop obj) const {\n+  return is_marked_strong(obj) || ShenandoahHeap::heap()->is_old(obj);\n+}\n+\n+inline HeapWord* ShenandoahMarkingContext::get_next_marked_addr(const HeapWord* start, const HeapWord* limit) const {\n@@ -56,2 +65,2 @@\n-inline bool ShenandoahMarkingContext::allocated_after_mark_start(oop obj) const {\n-  HeapWord* addr = cast_from_oop<HeapWord*>(obj);\n+inline bool ShenandoahMarkingContext::allocated_after_mark_start(const oop obj) const {\n+  const HeapWord* addr = cast_from_oop<HeapWord*>(obj);\n@@ -61,1 +70,1 @@\n-inline bool ShenandoahMarkingContext::allocated_after_mark_start(HeapWord* addr) const {\n+inline bool ShenandoahMarkingContext::allocated_after_mark_start(const HeapWord* addr) const {\n@@ -64,1 +73,1 @@\n-  bool alloc_after_mark_start = addr >= top_at_mark_start;\n+  const bool alloc_after_mark_start = addr >= top_at_mark_start;\n@@ -69,0 +78,5 @@\n+  if (!r->is_affiliated()) {\n+    \/\/ Non-affiliated regions do not need their TAMS updated\n+    return;\n+  }\n+\n@@ -76,1 +90,4 @@\n-  assert(is_bitmap_clear_range(old_tams, new_tams),\n+  assert((new_tams == r->bottom()) || (old_tams == r->bottom()) || (new_tams >= _top_bitmaps[idx]),\n+         \"Region \" SIZE_FORMAT\", top_bitmaps updates should be monotonic: \" PTR_FORMAT \" -> \" PTR_FORMAT,\n+         idx, p2i(_top_bitmaps[idx]), p2i(new_tams));\n+  assert(old_tams == r->bottom() || is_bitmap_clear_range(old_tams, new_tams),\n@@ -80,0 +97,11 @@\n+  log_debug(gc)(\"Capturing TAMS for %s Region \" SIZE_FORMAT \", was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n+                r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n+\n+  if ((old_tams == r->bottom()) && (new_tams > old_tams)) {\n+    log_debug(gc)(\"Clearing mark bitmap for %s Region \" SIZE_FORMAT \" while capturing TAMS\",\n+                  r->affiliation_name(), idx);\n+    \/\/ TODO: Do we really need to do bitmap clears here?\n+    \/\/ This could take a while, and we would instead like to clear bitmaps outside the pause.\n+    clear_bitmap(r);\n+  }\n+\n@@ -81,1 +109,4 @@\n-  _top_bitmaps[idx] = new_tams;\n+  if (new_tams > r->bottom()) {\n+    \/\/ In this case, new_tams is greater than old _top_bitmaps[idx]\n+    _top_bitmaps[idx] = new_tams;\n+  }\n@@ -88,1 +119,1 @@\n-inline HeapWord* ShenandoahMarkingContext::top_at_mark_start(ShenandoahHeapRegion* r) const {\n+inline HeapWord* ShenandoahMarkingContext::top_at_mark_start(const ShenandoahHeapRegion* r) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":43,"deletions":12,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,2 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -28,2 +31,3 @@\n-ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap) :\n-        CollectedMemoryPool(\"Shenandoah\",\n+ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                                           const char* name) :\n+        CollectedMemoryPool(name,\n@@ -35,0 +39,11 @@\n+ShenandoahMemoryPool::ShenandoahMemoryPool(ShenandoahHeap* heap,\n+                                           const char* name,\n+                                           size_t initial_capacity,\n+                                           size_t max_capacity) :\n+        CollectedMemoryPool(name,\n+                            initial_capacity,\n+                            max_capacity,\n+                            true \/* support_usage_threshold *\/),\n+                            _heap(heap) {}\n+\n+\n@@ -54,0 +69,54 @@\n+\n+size_t ShenandoahMemoryPool::used_in_bytes() {\n+  return _heap->used();\n+}\n+\n+size_t ShenandoahMemoryPool::max_size() const {\n+  return _heap->max_capacity();\n+}\n+\n+ShenandoahYoungGenMemoryPool::ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahMemoryPool(heap,\n+                             \"Shenandoah Young Gen\",\n+                             0,\n+                             heap->max_capacity()) { }\n+\n+MemoryUsage ShenandoahYoungGenMemoryPool::get_memory_usage() {\n+  size_t initial   = initial_size();\n+  size_t max       = max_size();\n+  size_t used      = used_in_bytes();\n+  size_t committed = _heap->young_generation()->used_regions_size();\n+\n+  return MemoryUsage(initial, used, committed, max);\n+}\n+\n+size_t ShenandoahYoungGenMemoryPool::used_in_bytes() {\n+  return _heap->young_generation()->used();\n+}\n+\n+size_t ShenandoahYoungGenMemoryPool::max_size() const {\n+  return _heap->young_generation()->max_capacity();\n+}\n+\n+ShenandoahOldGenMemoryPool::ShenandoahOldGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahMemoryPool(heap,\n+                             \"Shenandoah Old Gen\",\n+                             0,\n+                             heap->max_capacity()) { }\n+\n+MemoryUsage ShenandoahOldGenMemoryPool::get_memory_usage() {\n+  size_t initial   = initial_size();\n+  size_t max       = max_size();\n+  size_t used      = used_in_bytes();\n+  size_t committed = _heap->old_generation()->used_regions_size();\n+\n+  return MemoryUsage(initial, used, committed, max);\n+}\n+\n+size_t ShenandoahOldGenMemoryPool::used_in_bytes() {\n+  return _heap->old_generation()->used();\n+}\n+\n+size_t ShenandoahOldGenMemoryPool::max_size() const {\n+  return _heap->old_generation()->max_capacity();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.cpp","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,1 +36,1 @@\n-private:\n+protected:\n@@ -39,4 +40,27 @@\n-  ShenandoahMemoryPool(ShenandoahHeap* pool);\n-  MemoryUsage get_memory_usage();\n-  size_t used_in_bytes()              { return _heap->used(); }\n-  size_t max_size() const             { return _heap->max_capacity(); }\n+  ShenandoahMemoryPool(ShenandoahHeap* pool,\n+                       const char* name = \"Shenandoah\");\n+  virtual MemoryUsage get_memory_usage();\n+  virtual size_t used_in_bytes();\n+  virtual size_t max_size() const;\n+\n+protected:\n+  ShenandoahMemoryPool(ShenandoahHeap* pool,\n+                       const char* name,\n+                       size_t initial_capacity,\n+                       size_t max_capacity);\n+};\n+\n+class ShenandoahYoungGenMemoryPool : public ShenandoahMemoryPool {\n+public:\n+  ShenandoahYoungGenMemoryPool(ShenandoahHeap* pool);\n+  MemoryUsage get_memory_usage() override;\n+  size_t used_in_bytes() override;\n+  size_t max_size() const override;\n+};\n+\n+class ShenandoahOldGenMemoryPool : public ShenandoahMemoryPool {\n+public:\n+  ShenandoahOldGenMemoryPool(ShenandoahHeap* pool);\n+  MemoryUsage get_memory_usage() override;\n+  size_t used_in_bytes() override;\n+  size_t max_size() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+\n+class ShenandoahMmuTask : public PeriodicTask {\n+  ShenandoahMmuTracker* _mmu_tracker;\n+public:\n+  explicit ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n+    PeriodicTask(GCPauseIntervalMillis), _mmu_tracker(mmu_tracker) {}\n+\n+  void task() override {\n+    _mmu_tracker->report();\n+  }\n+};\n+\n+class ThreadTimeAccumulator : public ThreadClosure {\n+ public:\n+  size_t total_time;\n+  ThreadTimeAccumulator() : total_time(0) {}\n+  void do_thread(Thread* thread) override {\n+    total_time += os::thread_cpu_time(thread);\n+  }\n+};\n+\n+ShenandoahMmuTracker::ShenandoahMmuTracker() :\n+    _most_recent_timestamp(0.0),\n+    _most_recent_gc_time(0.0),\n+    _most_recent_gcu(0.0),\n+    _most_recent_mutator_time(0.0),\n+    _most_recent_mu(0.0),\n+    _most_recent_periodic_time_stamp(0.0),\n+    _most_recent_periodic_gc_time(0.0),\n+    _most_recent_periodic_mutator_time(0.0),\n+    _mmu_periodic_task(new ShenandoahMmuTask(this)) {\n+}\n+\n+ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n+  _mmu_periodic_task->disenroll();\n+  delete _mmu_periodic_task;\n+}\n+\n+void ShenandoahMmuTracker::fetch_cpu_times(double &gc_time, double &mutator_time) {\n+  ThreadTimeAccumulator cl;\n+  \/\/ We include only the gc threads because those are the only threads\n+  \/\/ we are responsible for.\n+  ShenandoahHeap::heap()->gc_threads_do(&cl);\n+  double most_recent_gc_thread_time = double(cl.total_time) \/ NANOSECS_PER_SEC;\n+  gc_time = most_recent_gc_thread_time;\n+\n+  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n+  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n+  assert(valid, \"don't know why this would not be valid\");\n+  mutator_time =(process_user_time + process_system_time) - most_recent_gc_thread_time;\n+}\n+\n+void ShenandoahMmuTracker::update_utilization(ShenandoahGeneration* generation, size_t gcid, const char *msg) {\n+  double current = os::elapsedTime();\n+  _most_recent_gcid = gcid;\n+  _most_recent_is_full = false;\n+\n+  if (gcid == 0) {\n+    fetch_cpu_times(_most_recent_gc_time, _most_recent_mutator_time);\n+\n+    _most_recent_timestamp = current;\n+  } else {\n+    double gc_cycle_period = current - _most_recent_timestamp;\n+    _most_recent_timestamp = current;\n+\n+    double gc_thread_time, mutator_thread_time;\n+    fetch_cpu_times(gc_thread_time, mutator_thread_time);\n+    double gc_time = gc_thread_time - _most_recent_gc_time;\n+    _most_recent_gc_time = gc_thread_time;\n+    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_period);\n+    double mutator_time = mutator_thread_time - _most_recent_mutator_time;\n+    _most_recent_mutator_time = mutator_thread_time;\n+    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_period);\n+    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% during period of %.3fs\",\n+                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_period);\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_young(ShenandoahGeneration* generation, size_t gcid) {\n+  update_utilization(generation, gcid, \"Concurrent Young GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_bootstrap(ShenandoahGeneration* generation, size_t gcid, bool candidates_for_mixed) {\n+  \/\/ Not likely that this will represent an \"ideal\" GCU, but doesn't hurt to try\n+  update_utilization(generation, gcid, \"Bootstrap Old GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_old_marking_increment(ShenandoahGeneration* generation, size_t gcid, bool old_marking_done,\n+                                                        bool has_old_candidates) {\n+  \/\/ No special processing for old marking\n+  double now = os::elapsedTime();\n+  double duration = now - _most_recent_timestamp;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+  double gcu = (gc_time - _most_recent_gc_time) \/ duration;\n+  double mu = (mutator_time - _most_recent_mutator_time) \/ duration;\n+  log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% for duration %.3fs (totals to be subsumed in next gc report)\",\n+                     old_marking_done? \"last OLD marking increment\": \"OLD marking increment\",\n+                     gcu * 100, mu * 100, duration);\n+}\n+\n+void ShenandoahMmuTracker::record_mixed(ShenandoahGeneration* generation, size_t gcid, bool is_mixed_done) {\n+  update_utilization(generation, gcid, \"Mixed Concurrent GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_degenerated(ShenandoahGeneration* generation,\n+                                              size_t gcid, bool is_old_bootstrap, bool is_mixed_done) {\n+  if ((gcid == _most_recent_gcid) && _most_recent_is_full) {\n+    \/\/ Do nothing.  This is a redundant recording for the full gc that just completed.\n+    \/\/ TODO: avoid making the call to record_degenerated() in the case that this degenerated upgraded to full gc.\n+  } else if (is_old_bootstrap) {\n+    update_utilization(generation, gcid, \"Degenerated Bootstrap Old GC\");\n+  } else {\n+    update_utilization(generation, gcid, \"Degenerated Young GC\");\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_full(ShenandoahGeneration* generation, size_t gcid) {\n+  update_utilization(generation, gcid, \"Full GC\");\n+  _most_recent_is_full = true;\n+}\n+\n+void ShenandoahMmuTracker::report() {\n+  \/\/ This is only called by the periodic thread.\n+  double current = os::elapsedTime();\n+  double time_delta = current - _most_recent_periodic_time_stamp;\n+  _most_recent_periodic_time_stamp = current;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+\n+  double gc_delta = gc_time - _most_recent_periodic_gc_time;\n+  _most_recent_periodic_gc_time = gc_time;\n+\n+  double mutator_delta = mutator_time - _most_recent_periodic_mutator_time;\n+  _most_recent_periodic_mutator_time = mutator_time;\n+\n+  double mu = mutator_delta \/ (_active_processors * time_delta);\n+  double gcu = gc_delta \/ (_active_processors * time_delta);\n+  log_info(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n+}\n+\n+void ShenandoahMmuTracker::initialize() {\n+  \/\/ initialize static data\n+  _active_processors = os::initial_active_processor_count();\n+\n+  double _most_recent_periodic_time_stamp = os::elapsedTime();\n+  fetch_cpu_times(_most_recent_periodic_gc_time, _most_recent_periodic_mutator_time);\n+  _mmu_periodic_task->enroll();\n+}\n+\n+ShenandoahGenerationSizer::ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker)\n+  : _sizer_kind(SizerDefaults),\n+    _use_adaptive_sizing(true),\n+    _min_desired_young_regions(0),\n+    _max_desired_young_regions(0),\n+    _resize_increment(double(YoungGenerationSizeIncrement) \/ 100.0),\n+    _mmu_tracker(mmu_tracker) {\n+\n+  if (FLAG_IS_CMDLINE(NewRatio)) {\n+    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n+    } else {\n+      _sizer_kind = SizerNewRatio;\n+      _use_adaptive_sizing = false;\n+      return;\n+    }\n+  }\n+\n+  if (NewSize > MaxNewSize) {\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"NewSize (\" SIZE_FORMAT \"k) is greater than the MaxNewSize (\" SIZE_FORMAT \"k). \"\n+                            \"A new max generation size of \" SIZE_FORMAT \"k will be used.\",\n+                            NewSize\/K, MaxNewSize\/K, NewSize\/K);\n+    }\n+    FLAG_SET_ERGO(MaxNewSize, NewSize);\n+  }\n+\n+  if (FLAG_IS_CMDLINE(NewSize)) {\n+    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+      _sizer_kind = SizerMaxAndNewSize;\n+      _use_adaptive_sizing = _min_desired_young_regions != _max_desired_young_regions;\n+    } else {\n+      _sizer_kind = SizerNewSizeOnly;\n+    }\n+  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    _sizer_kind = SizerMaxNewSizeOnly;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n+  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n+  return MAX2(min_young_regions, (size_t) 1U);\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n+  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n+  return MAX2(max_young_regions, (size_t) 1U);\n+}\n+\n+void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n+  assert(heap_region_count > 0, \"Heap must be initialized\");\n+\n+  switch (_sizer_kind) {\n+    case SizerDefaults:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      break;\n+    case SizerNewSizeOnly:\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxNewSizeOnly:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxAndNewSize:\n+      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n+      break;\n+    case SizerNewRatio:\n+      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n+      _max_desired_young_regions = _min_desired_young_regions;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n+}\n+\n+void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n+  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n+}\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t bytes_to_transfer = regions * region_size_bytes;\n+\n+  if (young_gen->free_unaffiliated_regions() < regions) {\n+    return false;\n+  } else if (old_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(old_gen)) {\n+    return false;\n+  } else if (young_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(young_gen)) {\n+    return false;\n+  } else {\n+    young_gen->decrease_capacity(bytes_to_transfer);\n+    old_gen->increase_capacity(bytes_to_transfer);\n+    size_t new_size = old_gen->max_capacity();\n+    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n+                 regions, young_gen->name(), old_gen->name(),\n+                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n+    return true;\n+  }\n+}\n+\n+\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n+\/\/ that the transferred regions be unaffiliated.\n+void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t bytes_to_transfer = regions * region_size_bytes;\n+\n+  young_gen->decrease_capacity(bytes_to_transfer);\n+  old_gen->increase_capacity(bytes_to_transfer);\n+  size_t new_size = old_gen->max_capacity();\n+  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n+               regions, young_gen->name(), old_gen->name(),\n+               byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n+}\n+\n+\n+bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t bytes_to_transfer = regions * region_size_bytes;\n+\n+  if (old_gen->free_unaffiliated_regions() < regions) {\n+    return false;\n+  } else if (young_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(young_gen)) {\n+    return false;\n+  } else if (old_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(old_gen)) {\n+    return false;\n+  } else {\n+    old_gen->decrease_capacity(bytes_to_transfer);\n+    young_gen->increase_capacity(bytes_to_transfer);\n+    size_t new_size = young_gen->max_capacity();\n+    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n+                 regions, old_gen->name(), young_gen->name(),\n+                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n+    return true;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::min_young_size() const {\n+  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGenerationSizer::max_young_size() const {\n+  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahGeneration;\n+class ShenandoahMmuTask;\n+\n+\/**\n+ * This class is responsible for tracking and adjusting the minimum mutator\n+ * utilization (MMU). MMU is defined as the percentage of CPU time available\n+ * to mutator threads over an arbitrary, fixed interval of time. This interval\n+ * defaults to 5 seconds and is configured by GCPauseIntervalMillis. The class\n+ * maintains a decaying average of the last 10 values. The MMU is measured\n+ * by summing all of the time given to the GC threads and comparing this to\n+ * the total CPU time for the process. There are OS APIs to support this on\n+ * all major platforms.\n+ *\n+ * The time spent by GC threads is attributed to the young or old generation.\n+ * The time given to the controller and regulator threads is attributed to the\n+ * global generation. At the end of every collection, the average MMU is inspected.\n+ * If it is below `GCTimeRatio`, this class will attempt to increase the capacity\n+ * of the generation that is consuming the most CPU time. The assumption being\n+ * that increasing memory will reduce the collection frequency and raise the\n+ * MMU.\n+ *\/\n+class ShenandoahMmuTracker {\n+private:\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for calculating\n+  \/\/ CPU time consumed by GC and mutator threads during each GC cycle.\n+  double _most_recent_timestamp;\n+  double _most_recent_gc_time;\n+  double _most_recent_gcu;\n+  double _most_recent_mutator_time;\n+  double _most_recent_mu;\n+\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for reporting\n+  \/\/ periodic consumption of CPU time by GC and mutator threads.\n+  double _most_recent_periodic_time_stamp;\n+  double _most_recent_periodic_gc_time;\n+  double _most_recent_periodic_mutator_time;\n+\n+  size_t _most_recent_gcid;\n+  uint _active_processors;\n+\n+  bool _most_recent_is_full;\n+\n+  ShenandoahMmuTask* _mmu_periodic_task;\n+  TruncatedSeq _mmu_average;\n+\n+  void update_utilization(ShenandoahGeneration* generation, size_t gcid, const char* msg);\n+  static void fetch_cpu_times(double &gc_time, double &mutator_time);\n+\n+public:\n+  explicit ShenandoahMmuTracker();\n+  ~ShenandoahMmuTracker();\n+\n+  \/\/ This enrolls the periodic task after everything is initialized.\n+  void initialize();\n+\n+  \/\/ At completion of each GC cycle (not including interrupted cycles), we invoke one of the following to record the\n+  \/\/ GC utilization during this cycle.  Incremental efforts spent in an interrupted GC cycle will be accumulated into\n+  \/\/ the CPU time reports for the subsequent completed [degenerated or full] GC cycle.\n+  \/\/\n+  \/\/ We may redundantly record degen and full in the case that a degen upgrades to full.  When this happens, we will invoke\n+  \/\/ both record_full() and record_degenerated() with the same value of gcid.  record_full() is called first and the log\n+  \/\/ reports such a cycle as a FULL cycle.\n+  void record_young(ShenandoahGeneration* generation, size_t gcid);\n+  void record_bootstrap(ShenandoahGeneration* generation, size_t gcid, bool has_old_candidates);\n+  void record_old_marking_increment(ShenandoahGeneration* generation, size_t gcid, bool old_marking_done, bool has_old_candidates);\n+  void record_mixed(ShenandoahGeneration* generation, size_t gcid, bool is_mixed_done);\n+  void record_full(ShenandoahGeneration* generation, size_t gcid);\n+  void record_degenerated(ShenandoahGeneration* generation, size_t gcid, bool is_old_boostrap, bool is_mixed_done);\n+\n+  \/\/ This is called by the periodic task timer. The interval is defined by\n+  \/\/ GCPauseIntervalMillis and defaults to 5 seconds. This method computes\n+  \/\/ the MMU over the elapsed interval and records it in a running average.\n+  void report();\n+};\n+\n+class ShenandoahGenerationSizer {\n+private:\n+  enum SizerKind {\n+    SizerDefaults,\n+    SizerNewSizeOnly,\n+    SizerMaxNewSizeOnly,\n+    SizerMaxAndNewSize,\n+    SizerNewRatio\n+  };\n+  SizerKind _sizer_kind;\n+\n+  \/\/ False when using a fixed young generation size due to command-line options,\n+  \/\/ true otherwise.\n+  bool _use_adaptive_sizing;\n+\n+  size_t _min_desired_young_regions;\n+  size_t _max_desired_young_regions;\n+\n+  double _resize_increment;\n+  ShenandoahMmuTracker* _mmu_tracker;\n+\n+  static size_t calculate_min_young_regions(size_t heap_region_count);\n+  static size_t calculate_max_young_regions(size_t heap_region_count);\n+\n+  \/\/ Update the given values for minimum and maximum young gen length in regions\n+  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n+  void recalculate_min_max_young_length(size_t heap_region_count);\n+\n+public:\n+  explicit ShenandoahGenerationSizer(ShenandoahMmuTracker* mmu_tracker);\n+\n+  \/\/ Calculate the maximum length of the young gen given the number of regions\n+  \/\/ depending on the sizing algorithm.\n+  void heap_size_changed(size_t heap_size);\n+\n+  \/\/ Minimum size of young generation in bytes as multiple of region size.\n+  size_t min_young_size() const;\n+  size_t min_young_regions() const {\n+    return _min_desired_young_regions;\n+  }\n+\n+  \/\/ Maximum size of young generation in bytes as multiple of region size.\n+  size_t max_young_size() const;\n+  size_t max_young_regions() const {\n+    return _max_desired_young_regions;\n+  }\n+\n+  bool use_adaptive_sizing() const {\n+    return _use_adaptive_sizing;\n+  }\n+\n+  bool transfer_to_young(size_t regions) const;\n+  bool transfer_to_old(size_t regions) const;\n+\n+  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n+  void force_transfer_to_old(size_t regions) const;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -160,5 +160,2 @@\n-  if (heap->is_concurrent_mark_in_progress()) {\n-    ShenandoahKeepAliveClosure cl;\n-    data->oops_do(&cl);\n-  } else if (heap->is_concurrent_weak_root_in_progress() ||\n-             heap->is_concurrent_strong_root_in_progress() ) {\n+  if (heap->is_concurrent_weak_root_in_progress() ||\n+      heap->is_concurrent_strong_root_in_progress()) {\n@@ -167,0 +164,3 @@\n+  } else if (heap->is_concurrent_mark_in_progress()) {\n+    ShenandoahKeepAliveClosure cl;\n+    data->oops_do(&cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -123,0 +124,64 @@\n+void HdrSeq::add(const HdrSeq& other) {\n+  if (other.num() == 0) {\n+    \/\/ Other sequence is empty, return\n+    return;\n+  }\n+\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    int* other_bucket = other._hdr[mag];\n+    if (other_bucket == nullptr) {\n+      \/\/ Nothing to do\n+      continue;\n+    }\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      \/\/ Add into our bucket\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] += other_bucket[val];\n+      }\n+    } else {\n+      \/\/ Create our bucket and copy the contents over\n+      bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n+      for (int val = 0; val < ValBuckets; val++) {\n+        bucket[val] = other_bucket[val];\n+      }\n+      _hdr[mag] = bucket;\n+    }\n+  }\n+\n+  \/\/ This is a hacky way to only update the fields we want.\n+  \/\/ This inlines NumberSeq code without going into AbsSeq and\n+  \/\/ dealing with decayed average\/variance, which we do not\n+  \/\/ know how to compute yet.\n+  _last = other._last;\n+  _maximum = MAX2(_maximum, other._maximum);\n+  _sum += other._sum;\n+  _sum_of_squares += other._sum_of_squares;\n+  _num += other._num;\n+\n+  \/\/ Until JDK-8298902 is fixed, we taint the decaying statistics\n+  _davg = NAN;\n+  _dvariance = NAN;\n+}\n+\n+void HdrSeq::clear() {\n+  \/\/ Clear the storage\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    int* bucket = _hdr[mag];\n+    if (bucket != nullptr) {\n+      for (int c = 0; c < ValBuckets; c++) {\n+        bucket[c] = 0;\n+      }\n+    }\n+  }\n+\n+  \/\/ Clear other fields too\n+  _last = 0;\n+  _maximum = 0;\n+  _sum = 0;\n+  _sum_of_squares = 0;\n+  _num = 0;\n+  _davg = 0;\n+  _dvariance = 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  void add(const HdrSeq& other);\n@@ -53,0 +54,1 @@\n+  void clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+\n+\n+\n+ShenandoahOldGC::ShenandoahOldGC(ShenandoahGeneration* generation, ShenandoahSharedFlag& allow_preemption) :\n+    ShenandoahConcurrentGC(generation, false), _allow_preemption(allow_preemption) {\n+}\n+\n+\/\/ Final mark for old-gen is different than for young or old, so we\n+\/\/ override the implementation.\n+void ShenandoahOldGC::op_final_mark() {\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should be at safepoint\");\n+  assert(!heap->has_forwarded_objects(), \"No forwarded objects on this path\");\n+\n+  if (ShenandoahVerify) {\n+    heap->verifier()->verify_roots_no_forwarded();\n+  }\n+\n+  if (!heap->cancelled_gc()) {\n+    assert(_mark.generation()->is_old(), \"Generation of Old-Gen GC should be OLD\");\n+    _mark.finish_mark();\n+    assert(!heap->cancelled_gc(), \"STW mark cannot OOM\");\n+\n+    \/\/ Old collection is complete, the young generation no longer needs this\n+    \/\/ reference to the old concurrent mark so clean it up.\n+    heap->young_generation()->set_old_gen_task_queues(nullptr);\n+\n+    \/\/ We need to do this because weak root cleaning reports the number of dead handles\n+    JvmtiTagMap::set_needs_cleaning();\n+\n+    _generation->prepare_regions_and_collection_set(true);\n+\n+    heap->set_unload_classes(false);\n+    heap->prepare_concurrent_roots();\n+\n+    \/\/ Believe verification following old-gen concurrent mark needs to be different than verification following\n+    \/\/ young-gen concurrent mark, so am commenting this out for now:\n+    \/\/   if (ShenandoahVerify) {\n+    \/\/     heap->verifier()->verify_after_concmark();\n+    \/\/   }\n+\n+    if (VerifyAfterGC) {\n+      Universe::verify();\n+    }\n+  }\n+}\n+\n+bool ShenandoahOldGC::collect(GCCause::Cause cause) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(!heap->doing_mixed_evacuations(), \"Should not start an old gc with pending mixed evacuations\");\n+  assert(!heap->is_prepare_for_old_mark_in_progress(), \"Old regions need to be parseable during concurrent mark.\");\n+\n+  \/\/ Enable preemption of old generation mark.\n+  _allow_preemption.set();\n+\n+  \/\/ Continue concurrent mark, do not reset regions, do not mark roots, do not collect $200.\n+  entry_mark();\n+\n+  \/\/ If we failed to unset the preemption flag, it means another thread has already unset it.\n+  if (!_allow_preemption.try_unset()) {\n+    \/\/ The regulator thread has unset the preemption guard. That thread will shortly cancel\n+    \/\/ the gc, but the control thread is now racing it. Wait until this thread sees the\n+    \/\/ cancellation.\n+    while (!heap->cancelled_gc()) {\n+      SpinPause();\n+    }\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    return false;\n+  }\n+\n+  \/\/ Complete marking under STW\n+  vmop_entry_final_mark();\n+\n+  \/\/ We aren't dealing with old generation evacuation yet. Our heuristic\n+  \/\/ should not have built a cset in final mark.\n+  assert(!heap->is_evacuation_in_progress(), \"Old gen evacuations are not supported\");\n+\n+  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n+    entry_weak_refs();\n+    entry_weak_roots();\n+  }\n+\n+  \/\/ Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim\n+  \/\/ the space. This would be the last action if there is nothing to evacuate.\n+  entry_cleanup_early();\n+\n+  {\n+    ShenandoahHeapLocker locker(heap->lock());\n+    heap->free_set()->log_status();\n+  }\n+\n+\n+  \/\/ TODO: Old marking doesn't support class unloading yet\n+  \/\/ Perform concurrent class unloading\n+  \/\/ if (heap->unload_classes() &&\n+  \/\/     heap->is_concurrent_weak_root_in_progress()) {\n+  \/\/   entry_class_unloading();\n+  \/\/ }\n+\n+\n+  assert(!heap->is_concurrent_strong_root_in_progress(), \"No evacuations during old gc.\");\n+\n+  \/\/ We must execute this vm operation if we completed final mark. We cannot\n+  \/\/ return from here with weak roots in progress. This is not a valid gc state\n+  \/\/ for any young collections (or allocation failures) that interrupt the old\n+  \/\/ collection.\n+  vmop_entry_final_roots();\n+\n+  \/\/ We do not rebuild_free following increments of old marking because memory has not been reclaimed..  However, we may\n+  \/\/ need to transfer memory to OLD in order to efficiently support the mixed evacuations that might immediately follow.\n+  size_t allocation_runway = heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(0);\n+  heap->adjust_generation_sizes_for_next_cycle(allocation_runway, 0, 0);\n+\n+  bool success;\n+  size_t region_xfer;\n+  const char* region_destination;\n+  ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  {\n+    ShenandoahHeapLocker locker(heap->lock());\n+\n+    size_t old_region_surplus = heap->get_old_region_surplus();\n+    size_t old_region_deficit = heap->get_old_region_deficit();\n+    if (old_region_surplus) {\n+      success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n+      region_destination = \"young\";\n+      region_xfer = old_region_surplus;\n+    } else if (old_region_deficit) {\n+      success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n+      region_destination = \"old\";\n+      region_xfer = old_region_deficit;\n+      if (!success) {\n+        ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n+      }\n+    } else {\n+      region_destination = \"none\";\n+      region_xfer = 0;\n+      success = true;\n+    }\n+    heap->set_old_region_surplus(0);\n+    heap->set_old_region_deficit(0);\n+  }\n+\n+  \/\/ Report outside the heap lock\n+  size_t young_available = young_gen->available();\n+  size_t old_available = old_gen->available();\n+  log_info(gc, ergo)(\"After old marking finished, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                     SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n+                     success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n+                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n+                     byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+\n+class ShenandoahGeneration;\n+\n+class ShenandoahOldGC : public ShenandoahConcurrentGC {\n+ public:\n+  ShenandoahOldGC(ShenandoahGeneration* generation, ShenandoahSharedFlag& allow_preemption);\n+  bool collect(GCCause::Cause cause);\n+\n+ protected:\n+  virtual void op_final_mark();\n+\n+ private:\n+\n+  ShenandoahSharedFlag& _allow_preemption;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHOLDGC_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,487 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMark.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+class ShenandoahFlushAllSATB : public ThreadClosure {\n+private:\n+  SATBMarkQueueSet& _satb_qset;\n+\n+public:\n+  explicit ShenandoahFlushAllSATB(SATBMarkQueueSet& satb_qset) :\n+    _satb_qset(satb_qset) {}\n+\n+  void do_thread(Thread* thread) {\n+    \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+    _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+  }\n+};\n+\n+class ShenandoahProcessOldSATB : public SATBBufferClosure {\n+private:\n+  ShenandoahObjToScanQueue*       _queue;\n+  ShenandoahHeap*                 _heap;\n+  ShenandoahMarkingContext* const _mark_context;\n+  size_t                          _trashed_oops;\n+\n+public:\n+  explicit ShenandoahProcessOldSATB(ShenandoahObjToScanQueue* q) :\n+    _queue(q),\n+    _heap(ShenandoahHeap::heap()),\n+    _mark_context(_heap->marking_context()),\n+    _trashed_oops(0) {}\n+\n+  void do_buffer(void** buffer, size_t size) {\n+    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n+    for (size_t i = 0; i < size; ++i) {\n+      oop *p = (oop *) &buffer[i];\n+      ShenandoahHeapRegion* region = _heap->heap_region_containing(*p);\n+      if (region->is_old() && region->is_active()) {\n+          ShenandoahMark::mark_through_ref<oop, OLD>(p, _queue, nullptr, _mark_context, false);\n+      } else {\n+        _trashed_oops++;\n+      }\n+    }\n+  }\n+\n+  size_t trashed_oops() {\n+    return _trashed_oops;\n+  }\n+};\n+\n+class ShenandoahPurgeSATBTask : public WorkerTask {\n+private:\n+  ShenandoahObjToScanQueueSet* _mark_queues;\n+  volatile size_t             _trashed_oops;\n+\n+public:\n+  explicit ShenandoahPurgeSATBTask(ShenandoahObjToScanQueueSet* queues) :\n+    WorkerTask(\"Purge SATB\"),\n+    _mark_queues(queues),\n+    _trashed_oops(0) {\n+    Threads::change_thread_claim_token();\n+  }\n+\n+  ~ShenandoahPurgeSATBTask() {\n+    if (_trashed_oops > 0) {\n+      log_info(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers\", _trashed_oops);\n+    }\n+  }\n+\n+  void work(uint worker_id) {\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahSATBMarkQueueSet &satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n+    ShenandoahFlushAllSATB flusher(satb_queues);\n+    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &flusher);\n+\n+    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n+    ShenandoahProcessOldSATB processor(mark_queue);\n+    while (satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n+\n+    Atomic::add(&_trashed_oops, processor.trashed_oops());\n+  }\n+};\n+\n+class ShenandoahConcurrentCoalesceAndFillTask : public WorkerTask {\n+private:\n+  uint                    _nworkers;\n+  ShenandoahHeapRegion**  _coalesce_and_fill_region_array;\n+  uint                    _coalesce_and_fill_region_count;\n+  volatile bool           _is_preempted;\n+\n+public:\n+  ShenandoahConcurrentCoalesceAndFillTask(uint nworkers,\n+                                          ShenandoahHeapRegion** coalesce_and_fill_region_array,\n+                                          uint region_count) :\n+    WorkerTask(\"Shenandoah Concurrent Coalesce and Fill\"),\n+    _nworkers(nworkers),\n+    _coalesce_and_fill_region_array(coalesce_and_fill_region_array),\n+    _coalesce_and_fill_region_count(region_count),\n+    _is_preempted(false) {\n+  }\n+\n+  void work(uint worker_id) {\n+    for (uint region_idx = worker_id; region_idx < _coalesce_and_fill_region_count; region_idx += _nworkers) {\n+      ShenandoahHeapRegion* r = _coalesce_and_fill_region_array[region_idx];\n+      if (r->is_humongous()) {\n+        \/\/ There is only one object in this region and it is not garbage,\n+        \/\/ so no need to coalesce or fill.\n+        continue;\n+      }\n+\n+      if (!r->oop_fill_and_coalesce()) {\n+        \/\/ Coalesce and fill has been preempted\n+        Atomic::store(&_is_preempted, true);\n+        return;\n+      }\n+    }\n+  }\n+\n+  \/\/ Value returned from is_completed() is only valid after all worker thread have terminated.\n+  bool is_completed() {\n+    return !Atomic::load(&_is_preempted);\n+  }\n+};\n+\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity),\n+    _coalesce_and_fill_region_array(NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, ShenandoahHeap::heap()->num_regions(), mtGC)),\n+    _state(IDLE),\n+    _growth_before_compaction(INITIAL_GROWTH_BEFORE_COMPACTION)\n+{\n+  _live_bytes_after_last_mark = ShenandoahHeap::heap()->capacity() * INITIAL_LIVE_FRACTION \/ FRACTIONAL_DENOMINATOR;\n+  \/\/ Always clear references for old generation\n+  ref_processor()->set_soft_reference_policy(true);\n+}\n+\n+size_t ShenandoahOldGeneration::get_live_bytes_after_last_mark() const {\n+  return _live_bytes_after_last_mark;\n+}\n+\n+void ShenandoahOldGeneration::set_live_bytes_after_last_mark(size_t bytes) {\n+  _live_bytes_after_last_mark = bytes;\n+  if (_growth_before_compaction > MINIMUM_GROWTH_BEFORE_COMPACTION) {\n+    _growth_before_compaction \/= 2;\n+  }\n+}\n+\n+size_t ShenandoahOldGeneration::usage_trigger_threshold() const {\n+  size_t result = _live_bytes_after_last_mark + (_live_bytes_after_last_mark * _growth_before_compaction) \/ FRACTIONAL_DENOMINATOR;\n+  return result;\n+}\n+\n+bool ShenandoahOldGeneration::contains(ShenandoahHeapRegion* region) const {\n+  \/\/ TODO: Should this be region->is_old() instead?\n+  return !region->is_young();\n+}\n+\n+void ShenandoahOldGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&old_regions);\n+}\n+\n+void ShenandoahOldGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahGenerationRegionClosure<OLD> old_regions(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&old_regions);\n+}\n+\n+void ShenandoahOldGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap::heap()->set_concurrent_old_mark_in_progress(in_progress);\n+}\n+\n+bool ShenandoahOldGeneration::is_concurrent_mark_in_progress() {\n+  return ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress();\n+}\n+\n+void ShenandoahOldGeneration::cancel_marking() {\n+  if (is_concurrent_mark_in_progress()) {\n+    log_info(gc)(\"Abandon SATB buffers\");\n+    ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();\n+  }\n+\n+  ShenandoahGeneration::cancel_marking();\n+}\n+\n+void ShenandoahOldGeneration::prepare_gc() {\n+  \/\/ Make the old generation regions parseable, so they can be safely\n+  \/\/ scanned when looking for objects in memory indicated by dirty cards.\n+  if (entry_coalesce_and_fill()) {\n+    \/\/ Now that we have made the old generation parseable, it is safe to reset the mark bitmap.\n+    static const char* msg = \"Concurrent reset (OLD)\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_old);\n+    ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                                msg);\n+    ShenandoahGeneration::prepare_gc();\n+  }\n+  \/\/ Else, coalesce-and-fill has been preempted and we'll finish that effort in the future.  Do not invoke\n+  \/\/ ShenandoahGeneration::prepare_gc() until coalesce-and-fill is done because it resets the mark bitmap\n+  \/\/ and invokes set_mark_incomplete().  Coalesce-and-fill depends on the mark bitmap.\n+}\n+\n+bool ShenandoahOldGeneration::entry_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  static const char* msg = \"Coalescing and filling (OLD)\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+\n+  \/\/ TODO: I don't think we're using these concurrent collection counters correctly.\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              msg);\n+\n+  return coalesce_and_fill();\n+}\n+\n+bool ShenandoahOldGeneration::coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  heap->set_prepare_for_old_mark_in_progress(true);\n+  transition_to(FILLING);\n+\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  WorkerThreads* workers = heap->workers();\n+  uint nworkers = workers->active_workers();\n+\n+  log_debug(gc)(\"Starting (or resuming) coalesce-and-fill of old heap regions\");\n+\n+  \/\/ This code will see the same set of regions to fill on each resumption as it did\n+  \/\/ on the initial run. That's okay because each region keeps track of its own coalesce\n+  \/\/ and fill state. Regions that were filled on a prior attempt will not try to fill again.\n+  uint coalesce_and_fill_regions_count = old_heuristics->get_coalesce_and_fill_candidates(_coalesce_and_fill_region_array);\n+  assert(coalesce_and_fill_regions_count <= heap->num_regions(), \"Sanity\");\n+  ShenandoahConcurrentCoalesceAndFillTask task(nworkers, _coalesce_and_fill_region_array, coalesce_and_fill_regions_count);\n+\n+  workers->run_task(&task);\n+  if (task.is_completed()) {\n+    \/\/ Remember that we're done with coalesce-and-fill.\n+    heap->set_prepare_for_old_mark_in_progress(false);\n+    old_heuristics->abandon_collection_candidates();\n+    return true;\n+  } else {\n+    \/\/ Otherwise, we were preempted before the work was done.\n+    log_debug(gc)(\"Suspending coalesce-and-fill of old heap regions\");\n+    return false;\n+  }\n+}\n+\n+void ShenandoahOldGeneration::transfer_pointers_from_satb() {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  shenandoah_assert_safepoint();\n+  assert(heap->is_concurrent_old_mark_in_progress(), \"Only necessary during old marking.\");\n+  log_info(gc)(\"Transfer SATB buffers\");\n+  uint nworkers = heap->workers()->active_workers();\n+  StrongRootsScope scope(nworkers);\n+\n+  ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n+  heap->workers()->run_task(&purge_satb_task);\n+}\n+\n+bool ShenandoahOldGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_old(obj);\n+}\n+\n+void ShenandoahOldGeneration::prepare_regions_and_collection_set(bool concurrent) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(!heap->is_full_gc_in_progress(), \"Only for concurrent and degenerated GC\");\n+\n+  {\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_update_region_states :\n+        ShenandoahPhaseTimings::degen_gc_final_update_region_states);\n+    ShenandoahFinalMarkUpdateRegionStateClosure cl(complete_marking_context());\n+\n+    parallel_heap_region_iterate(&cl);\n+    heap->assert_pinned_region_status();\n+  }\n+\n+  {\n+    \/\/ This doesn't actually choose a collection set, but prepares a list of\n+    \/\/ regions as 'candidates' for inclusion in a mixed collection.\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::choose_cset :\n+        ShenandoahPhaseTimings::degen_gc_choose_cset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    heuristics()->choose_collection_set(nullptr, nullptr);\n+  }\n+\n+  {\n+    \/\/ Though we did not choose a collection set above, we still may have\n+    \/\/ freed up immediate garbage regions so proceed with rebuilding the free set.\n+    ShenandoahGCPhase phase(concurrent ?\n+        ShenandoahPhaseTimings::final_rebuild_freeset :\n+        ShenandoahPhaseTimings::degen_gc_final_rebuild_freeset);\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t cset_young_regions, cset_old_regions;\n+    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions);\n+    \/\/ This is just old-gen completion.  No future budgeting required here.  The only reason to rebuild the freeset here\n+    \/\/ is in case there was any immediate old garbage identified.\n+    heap->free_set()->rebuild(cset_young_regions, cset_old_regions);\n+  }\n+}\n+\n+const char* ShenandoahOldGeneration::state_name(State state) {\n+  switch (state) {\n+    case IDLE:              return \"Idle\";\n+    case FILLING:           return \"Coalescing\";\n+    case BOOTSTRAPPING:     return \"Bootstrapping\";\n+    case MARKING:           return \"Marking\";\n+    case WAITING_FOR_EVAC:  return \"Waiting for evacuation\";\n+    case WAITING_FOR_FILL:  return \"Waiting for fill\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"Unknown\";\n+  }\n+}\n+\n+void ShenandoahOldGeneration::transition_to(State new_state) {\n+  if (_state != new_state) {\n+    log_info(gc)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n+    validate_transition(new_state);\n+    _state = new_state;\n+  }\n+}\n+\n+#ifdef ASSERT\n+\/\/ This diagram depicts the expected state transitions for marking the old generation\n+\/\/ and preparing for old collections. When a young generation cycle executes, the\n+\/\/ remembered set scan must visit objects in old regions. Visiting an object which\n+\/\/ has become dead on previous old cycles will result in crashes. To avoid visiting\n+\/\/ such objects, the remembered set scan will use the old generation mark bitmap when\n+\/\/ possible. It is _not_ possible to use the old generation bitmap when old marking\n+\/\/ is active (bitmap is not complete). For this reason, the old regions are made\n+\/\/ parseable _before_ the old generation bitmap is reset. The diagram does not depict\n+\/\/ global and full collections, both of which cancel any old generation activity.\n+\/\/\n+\/\/                              +-----------------+\n+\/\/               +------------> |      IDLE       |\n+\/\/               |   +--------> |                 |\n+\/\/               |   |          +-----------------+\n+\/\/               |   |            |\n+\/\/               |   |            | Begin Old Mark\n+\/\/               |   |            v\n+\/\/               |   |          +-----------------+     +--------------------+\n+\/\/               |   |          |     FILLING     | <-> |      YOUNG GC      |\n+\/\/               |   |    +---> |                 |     | (RSet Uses Bitmap) |\n+\/\/               |   |    |     +-----------------+     +--------------------+\n+\/\/               |   |    |       |\n+\/\/               |   |    |       | Reset Bitmap\n+\/\/               |   |    |       v\n+\/\/               |   |    |     +-----------------+\n+\/\/               |   |    |     |    BOOTSTRAP    |\n+\/\/               |   |    |     |                 |\n+\/\/               |   |    |     +-----------------+\n+\/\/               |   |    |       |\n+\/\/               |   |    |       | Continue Marking\n+\/\/               |   |    |       v\n+\/\/               |   |    |     +-----------------+     +----------------------+\n+\/\/               |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n+\/\/               |   +----|-----|                 |     | (RSet Parses Region) |\n+\/\/               |        |     +-----------------+     +----------------------+\n+\/\/               |        |       |\n+\/\/               |        |       | Has Candidates\n+\/\/               |        |       v\n+\/\/               |        |     +-----------------+\n+\/\/               |        |     |    WAITING FOR  |\n+\/\/               +--------|---- |    EVACUATIONS  |\n+\/\/                        |     +-----------------+\n+\/\/                        |       |\n+\/\/                        |       | All Candidates are Pinned\n+\/\/                        |       v\n+\/\/                        |     +-----------------+\n+\/\/                        |     |    WAITING FOR  |\n+\/\/                        +-----|    FILLING      |\n+\/\/                              +-----------------+\n+\/\/\n+void ShenandoahOldGeneration::validate_transition(State new_state) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  switch (new_state) {\n+    case IDLE:\n+      \/\/ GC cancellation can send us back to IDLE from any state.\n+      assert(!heap->is_concurrent_old_mark_in_progress(), \"Cannot become idle during old mark.\");\n+      assert(!heap->mode()->is_generational() ||\n+             (_old_heuristics->unprocessed_old_collection_candidates() == 0), \"Cannot become idle with collection candidates\");\n+      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot become idle while making old generation parseable.\");\n+      assert(heap->young_generation()->old_gen_task_queues() == nullptr, \"Cannot become idle when setup for bootstrapping.\");\n+      break;\n+    case FILLING:\n+      assert(_state == IDLE || _state == WAITING_FOR_FILL, \"Cannot begin filling without first completing evacuations, state is '%s'\", state_name(_state));\n+      assert(heap->is_prepare_for_old_mark_in_progress(), \"Should be preparing for old mark now.\");\n+      break;\n+    case BOOTSTRAPPING:\n+      assert(_state == FILLING, \"Cannot reset bitmap without making old regions parseable, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot bootstrap with mixed collection candidates\");\n+      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot still be making old regions parseable.\");\n+      break;\n+    case MARKING:\n+      assert(_state == BOOTSTRAPPING, \"Must have finished bootstrapping before marking, state is '%s'\", state_name(_state));\n+      assert(heap->young_generation()->old_gen_task_queues() != nullptr, \"Young generation needs old mark queues.\");\n+      assert(heap->is_concurrent_old_mark_in_progress(), \"Should be marking old now.\");\n+      break;\n+    case WAITING_FOR_EVAC:\n+      assert(_state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Must have collection candidates here.\");\n+      break;\n+    case WAITING_FOR_FILL:\n+      assert(_state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() > 0, \"Cannot wait for fill without something to fill.\");\n+      break;\n+    default:\n+      fatal(\"Unknown new state\");\n+  }\n+}\n+#endif\n+\n+ShenandoahHeuristics* ShenandoahOldGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  assert(ShenandoahOldGCHeuristics != nullptr, \"ShenandoahOldGCHeuristics should not be unset\");\n+  ShenandoahHeuristics* trigger;\n+  if (strcmp(ShenandoahOldGCHeuristics, \"static\") == 0) {\n+    trigger = new ShenandoahStaticHeuristics(this);\n+  } else if (strcmp(ShenandoahOldGCHeuristics, \"adaptive\") == 0) {\n+    trigger = new ShenandoahAdaptiveHeuristics(this);\n+  } else if (strcmp(ShenandoahOldGCHeuristics, \"compact\") == 0) {\n+    trigger = new ShenandoahCompactHeuristics(this);\n+  } else {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahOldGCHeuristics option (must be one of: static, adaptive, compact)\");\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+  trigger->set_guaranteed_gc_interval(ShenandoahGuaranteedOldGCInterval);\n+  _old_heuristics = new ShenandoahOldHeuristics(this, trigger);\n+  _heuristics = _old_heuristics;\n+  return _heuristics;\n+}\n+\n+void ShenandoahOldGeneration::record_success_concurrent(bool abbreviated) {\n+  heuristics()->record_success_concurrent(abbreviated);\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_success_old();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":487,"deletions":0,"binary":false,"changes":487,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+\n+class ShenandoahHeapRegion;\n+class ShenandoahHeapRegionClosure;\n+class ShenandoahOldHeuristics;\n+\n+class ShenandoahOldGeneration : public ShenandoahGeneration {\n+private:\n+  ShenandoahHeapRegion** _coalesce_and_fill_region_array;\n+  ShenandoahOldHeuristics* _old_heuristics;\n+\n+  bool entry_coalesce_and_fill();\n+  bool coalesce_and_fill();\n+\n+public:\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  const char* name() const override {\n+    return \"OLD\";\n+  }\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool is_concurrent_mark_in_progress() override;\n+\n+  virtual void prepare_gc() override;\n+  void prepare_regions_and_collection_set(bool concurrent) override;\n+  virtual void record_success_concurrent(bool abbreviated) override;\n+  virtual void cancel_marking() override;\n+\n+  \/\/ We leave the SATB barrier on for the entirety of the old generation\n+  \/\/ marking phase. In some cases, this can cause a write to a perfectly\n+  \/\/ reachable oop to enqueue a pointer that later becomes garbage (because\n+  \/\/ it points at an object in the collection set, for example). There are\n+  \/\/ also cases where the referent of a weak reference ends up in the SATB\n+  \/\/ and is later collected. In these cases the oop in the SATB buffer becomes\n+  \/\/ invalid and the _next_ cycle will crash during its marking phase. To\n+  \/\/ avoid this problem, we \"purge\" the SATB buffers during the final update\n+  \/\/ references phase if (and only if) an old generation mark is in progress.\n+  \/\/ At this stage we can safely determine if any of the oops in the SATB\n+  \/\/ buffer belong to trashed regions (before they are recycled). As it\n+  \/\/ happens, flushing a SATB queue also filters out oops which have already\n+  \/\/ been marked - which is the case for anything that is being evacuated\n+  \/\/ from the collection set.\n+  \/\/\n+  \/\/ Alternatively, we could inspect the state of the heap and the age of the\n+  \/\/ object at the barrier, but we reject this approach because it is likely\n+  \/\/ the performance impact would be too severe.\n+  void transfer_pointers_from_satb();\n+\n+public:\n+  enum State {\n+    IDLE, FILLING, BOOTSTRAPPING, MARKING, WAITING_FOR_EVAC, WAITING_FOR_FILL\n+  };\n+\n+private:\n+  State _state;\n+\n+  static const size_t FRACTIONAL_DENOMINATOR = 64536;\n+\n+  \/\/ During initialization of the JVM, we search for the correct old-gen size by initally performing old-gen\n+  \/\/ collection when old-gen usage is 50% more (INITIAL_GROWTH_BEFORE_COMPACTION) than the initial old-gen size\n+  \/\/ estimate (3.125% of heap).  The next old-gen trigger occurs when old-gen grows 25% larger than its live\n+  \/\/ memory at the end of the first old-gen collection.  Then we trigger again when old-gen growns 12.5%\n+  \/\/ more than its live memory at the end of the previous old-gen collection.  Thereafter, we trigger each time\n+  \/\/ old-gen grows more than 12.5% following the end of its previous old-gen collection.\n+  static const size_t INITIAL_GROWTH_BEFORE_COMPACTION = FRACTIONAL_DENOMINATOR \/ 2;          \/\/  50.0%\n+  static const size_t MINIMUM_GROWTH_BEFORE_COMPACTION = FRACTIONAL_DENOMINATOR \/ 8;          \/\/  12.5%\n+\n+  \/\/ INITIAL_LIVE_FRACTION represents the initial guess of how large old-gen should be.  We estimate that old-gen\n+  \/\/ needs to consume 3.125% of the total heap size.  And we \"pretend\" that we start out with this amount of live\n+  \/\/ old-gen memory.  The first old-collection trigger will occur when old-gen occupies 50% more than this initial\n+  \/\/ approximation of the old-gen memory requirement, in other words when old-gen usage is 150% of 3.125%, which\n+  \/\/ is 4.6875% of the total heap size.\n+  static const uint16_t INITIAL_LIVE_FRACTION = FRACTIONAL_DENOMINATOR \/ 32;                    \/\/   3.125%\n+  size_t _live_bytes_after_last_mark;\n+  size_t _growth_before_compaction; \/\/ How much growth in usage before we trigger old collection, per 65_536\n+\n+  void validate_transition(State new_state) NOT_DEBUG_RETURN;\n+\n+public:\n+  State state() const {\n+    return _state;\n+  }\n+\n+  void transition_to(State new_state);\n+\n+  size_t get_live_bytes_after_last_mark() const;\n+  void set_live_bytes_after_last_mark(size_t new_live);\n+\n+  size_t usage_trigger_threshold() const;\n+\n+  bool can_start_gc() {\n+    return _state == IDLE || _state == WAITING_FOR_FILL;\n+  }\n+\n+  static const char* state_name(State state);\n+};\n+\n+\n+#endif \/\/SHARE_VM_GC_SHENANDOAH_SHENANDOAHOLDGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -45,0 +46,1 @@\n+  ShenandoahObjToScanQueue* _old_queue;\n@@ -49,1 +51,1 @@\n-  template <class T>\n+  template <class T, ShenandoahGenerationType GENERATION>\n@@ -53,1 +55,1 @@\n-  ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp);\n+  ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q);\n@@ -73,1 +75,1 @@\n-  template <class T>\n+  template <class T, ShenandoahGenerationType GENERATION>\n@@ -77,2 +79,2 @@\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-    ShenandoahMarkRefsSuperClosure(q, rp),\n+  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkRefsSuperClosure(q, rp, old_q),\n@@ -84,0 +86,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -87,1 +90,1 @@\n-  inline void do_oop_work(T* p)     { work<T>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION>(p); }\n@@ -90,2 +93,2 @@\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-    ShenandoahMarkUpdateRefsSuperClosure(q, rp) {}\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp, old_q) {}\n@@ -97,0 +100,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -100,1 +104,1 @@\n-  inline void do_oop_work(T* p)     { work<T>(p); }\n+  inline void do_oop_work(T* p)     { work<T, GENERATION>(p); }\n@@ -103,2 +107,2 @@\n-  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-    ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+    ShenandoahMarkRefsSuperClosure(q, rp, old_q) {};\n@@ -110,1 +114,0 @@\n-\n@@ -145,0 +148,17 @@\n+class ShenandoahSetRememberedCardsToDirtyClosure : public BasicOopIterateClosure {\n+protected:\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n+\n+public:\n+  ShenandoahSetRememberedCardsToDirtyClosure() :\n+      _heap(ShenandoahHeap::heap()),\n+      _scanner(_heap->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p);\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,1 +34,1 @@\n-template<class T>\n+template<class T, ShenandoahGenerationType GENERATION>\n@@ -35,1 +36,1 @@\n-  ShenandoahMark::mark_through_ref<T>(p, _queue, _mark_context, _weak);\n+  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, _old_queue, _mark_context, _weak);\n@@ -38,1 +39,1 @@\n-template<class T>\n+template<class T, ShenandoahGenerationType GENERATION>\n@@ -44,1 +45,1 @@\n-  ShenandoahMarkRefsSuperClosure::work<T>(p);\n+  ShenandoahMarkRefsSuperClosure::work<T, GENERATION>(p);\n@@ -57,0 +58,12 @@\n+template<class T>\n+inline void ShenandoahSetRememberedCardsToDirtyClosure::work(T* p) {\n+  T o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n+    if (_heap->is_in_young(obj)) {\n+      \/\/ Found interesting pointer.  Mark the containing card as dirty.\n+      _scanner->mark_card_as_dirty((HeapWord*) p);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -100,0 +101,1 @@\n+    case init_scan_rset:\n@@ -115,0 +117,1 @@\n+    case conc_mark:\n@@ -311,1 +314,1 @@\n-        ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id) :\n+        ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id, bool cumulative) :\n@@ -315,1 +318,1 @@\n-  assert(_timings->worker_data(_phase, _par_phase)->get(_worker_id) == ShenandoahWorkerData::uninitialized(),\n+  assert(_timings->worker_data(_phase, _par_phase)->get(_worker_id) == ShenandoahWorkerData::uninitialized() || cumulative,\n@@ -321,1 +324,1 @@\n-  _timings->worker_data(_phase, _par_phase)->set(_worker_id, os::elapsedTime() - _start_time);\n+  _timings->worker_data(_phase, _par_phase)->set_or_add(_worker_id, os::elapsedTime() - _start_time);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -47,0 +48,1 @@\n+  f(CNT_PREFIX ## ScanClusters,             DESC_PREFIX \"Scan Clusters\")               \\\n@@ -51,1 +53,1 @@\n-                                                                                       \\\n+  f(conc_reset_old,                                 \"Concurrent Reset (OLD)\")          \\\n@@ -55,0 +57,2 @@\n+  f(init_swap_rset,                                 \"  Swap Remembered Set\")           \\\n+  f(init_transfer_satb,                             \"  Transfer Old From SATB\")        \\\n@@ -57,0 +61,3 @@\n+  f(init_scan_rset,                                 \"Concurrent Scan Remembered Set\")  \\\n+  SHENANDOAH_PAR_PHASE_DO(init_scan_rset_,          \"  RS: \", f)                       \\\n+                                                                                       \\\n@@ -60,0 +67,1 @@\n+  SHENANDOAH_PAR_PHASE_DO(conc_mark,                \"  CM: \", f)                       \\\n@@ -97,0 +105,2 @@\n+  f(coalesce_and_fill,                              \"Coalesce and Fill Old Dead\")      \\\n+  SHENANDOAH_PAR_PHASE_DO(coalesce_and_fill_,       \"  CFOD: \", f)                     \\\n@@ -172,0 +182,1 @@\n+  f(full_gc_recompute_generation_usage,             \"    Recompute generation usage\")  \\\n@@ -174,0 +185,1 @@\n+  f(full_gc_reconstruct_remembered_set,             \"    Reconstruct Remembered Set\")  \\\n@@ -252,1 +264,4 @@\n-  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id);\n+  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase,\n+                                 ShenandoahPhaseTimings::ParPhase par_phase,\n+                                 uint worker_id,\n+                                 bool cumulative = false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -60,0 +62,16 @@\n+template <typename T>\n+static void card_mark_barrier(T* field, oop value) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  assert(heap->is_in_or_null(value), \"Should be in heap\");\n+  if (heap->mode()->is_generational() && heap->is_in_old(field) && heap->is_in_young(value)) {\n+    \/\/ For Shenandoah, each generation collects all the _referents_ that belong to the\n+    \/\/ collected generation. We can end up with discovered lists that contain a mixture\n+    \/\/ of old and young _references_. These references are linked together through the\n+    \/\/ discovered field in java.lang.Reference. In some cases, creating or editing this\n+    \/\/ list may result in the creation of _new_ old-to-young pointers which must dirty\n+    \/\/ the corresponding card. Failing to do this may cause heap verification errors and\n+    \/\/ lead to incorrect GC behavior.\n+    heap->card_scan()->mark_card_as_dirty(reinterpret_cast<HeapWord*>(field));\n+  }\n+}\n+\n@@ -66,0 +84,1 @@\n+  card_mark_barrier(field, value);\n@@ -71,0 +90,1 @@\n+  card_mark_barrier(field, value);\n@@ -260,0 +280,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -276,0 +297,5 @@\n+  if (!heap->is_in_active_generation(referent)) {\n+    log_trace(gc,ref)(\"Referent outside of active generation: \" PTR_FORMAT, p2i(referent));\n+    return false;\n+  }\n+\n@@ -363,1 +389,2 @@\n-  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s)\", p2i(reference), reference_type_name(type));\n+  log_trace(gc, ref)(\"Encountered Reference: \" PTR_FORMAT \" (%s, %s)\",\n+          p2i(reference), reference_type_name(type), ShenandoahHeap::heap()->heap_region_containing(reference)->affiliation_name());\n@@ -378,1 +405,1 @@\n-#ifdef ASSERT\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -380,3 +407,1 @@\n-  assert(referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(referent),\n-         \"only drop references with alive referents\");\n-#endif\n+  assert(referent == nullptr || heap->marking_context()->is_marked(referent), \"only drop references with alive referents\");\n@@ -387,0 +412,8 @@\n+  \/\/ When this reference was discovered, it would not have been marked. If it ends up surviving\n+  \/\/ the cycle, we need to dirty the card if the reference is old and the referent is young.  Note\n+  \/\/ that if the reference is not dropped, then its pointer to the referent will be nulled before\n+  \/\/ evacuation begins so card does not need to be dirtied.\n+  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n+    \/\/ Note: would be sufficient to mark only the card that holds the start of this Reference object.\n+    heap->card_scan()->mark_range_as_dirty(cast_from_oop<HeapWord*>(reference), reference->size());\n+  }\n@@ -526,1 +559,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+static ShenandoahHeuristics* get_heuristics(ShenandoahGeneration* nullable) {\n+  return nullable != nullptr ? nullable->heuristics() : nullptr;\n+}\n+\n+ShenandoahRegulatorThread::ShenandoahRegulatorThread(ShenandoahControlThread* control_thread) :\n+  ConcurrentGCThread(),\n+  _control_thread(control_thread),\n+  _sleep(ShenandoahControlIntervalMin),\n+  _last_sleep_adjust_time(os::elapsedTime()) {\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  _old_heuristics = get_heuristics(heap->old_generation());\n+  _young_heuristics = get_heuristics(heap->young_generation());\n+  _global_heuristics = get_heuristics(heap->global_generation());\n+\n+  create_and_start();\n+}\n+\n+void ShenandoahRegulatorThread::run_service() {\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    if (ShenandoahAllowOldMarkingPreemption) {\n+      regulate_concurrent_cycles();\n+    } else {\n+      regulate_interleaved_cycles();\n+    }\n+  } else {\n+    regulate_heap();\n+  }\n+\n+  log_info(gc)(\"%s: Done.\", name());\n+}\n+\n+void ShenandoahRegulatorThread::regulate_concurrent_cycles() {\n+  assert(_young_heuristics != nullptr, \"Need young heuristics.\");\n+  assert(_old_heuristics != nullptr, \"Need old heuristics.\");\n+\n+  while (!should_terminate()) {\n+    ShenandoahControlThread::GCMode mode = _control_thread->gc_mode();\n+    if (mode == ShenandoahControlThread::none) {\n+      if (should_unload_classes()) {\n+        if (_control_thread->request_concurrent_gc(ShenandoahControlThread::select_global_generation())) {\n+          log_info(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+        }\n+      } else {\n+        if (start_old_cycle()) {\n+          log_info(gc)(\"Heuristics request for old collection accepted\");\n+        } else if (start_young_cycle()) {\n+          log_info(gc)(\"Heuristics request for young collection accepted\");\n+        }\n+      }\n+    } else if (mode == ShenandoahControlThread::servicing_old) {\n+      if (start_young_cycle()) {\n+        log_info(gc)(\"Heuristics request to interrupt old for young collection accepted\");\n+      }\n+    }\n+\n+    regulator_sleep();\n+  }\n+}\n+\n+void ShenandoahRegulatorThread::regulate_interleaved_cycles() {\n+  assert(_young_heuristics != nullptr, \"Need young heuristics.\");\n+  assert(_global_heuristics != nullptr, \"Need global heuristics.\");\n+\n+  while (!should_terminate()) {\n+    if (_control_thread->gc_mode() == ShenandoahControlThread::none) {\n+      if (start_global_cycle()) {\n+        log_info(gc)(\"Heuristics request for global collection accepted.\");\n+      } else if (start_young_cycle()) {\n+        log_info(gc)(\"Heuristics request for young collection accepted.\");\n+      }\n+    }\n+\n+    regulator_sleep();\n+  }\n+}\n+\n+void ShenandoahRegulatorThread::regulate_heap() {\n+  assert(_global_heuristics != nullptr, \"Need global heuristics.\");\n+\n+  while (!should_terminate()) {\n+    if (_control_thread->gc_mode() == ShenandoahControlThread::none) {\n+      if (start_global_cycle()) {\n+        log_info(gc)(\"Heuristics request for global collection accepted.\");\n+      }\n+    }\n+\n+    regulator_sleep();\n+  }\n+}\n+\n+void ShenandoahRegulatorThread::regulator_sleep() {\n+  \/\/ Wait before performing the next action. If allocation happened during this wait,\n+  \/\/ we exit sooner, to let heuristics re-evaluate new conditions. If we are at idle,\n+  \/\/ back off exponentially.\n+  double current = os::elapsedTime();\n+\n+  if (_heap_changed.try_unset()) {\n+    _sleep = ShenandoahControlIntervalMin;\n+  } else if ((current - _last_sleep_adjust_time) * 1000 > ShenandoahControlIntervalAdjustPeriod){\n+    _sleep = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, _sleep * 2));\n+    _last_sleep_adjust_time = current;\n+  }\n+\n+  os::naked_short_sleep(_sleep);\n+}\n+\n+bool ShenandoahRegulatorThread::start_old_cycle() {\n+  return !ShenandoahHeap::heap()->doing_mixed_evacuations() && !ShenandoahHeap::heap()->collection_set()->has_old_regions() &&\n+    _old_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(OLD);\n+}\n+\n+bool ShenandoahRegulatorThread::start_young_cycle() {\n+  return _young_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(YOUNG);\n+}\n+\n+bool ShenandoahRegulatorThread::start_global_cycle() {\n+  return _global_heuristics->should_start_gc() && _control_thread->request_concurrent_gc(ShenandoahControlThread::select_global_generation());\n+}\n+\n+void ShenandoahRegulatorThread::stop_service() {\n+  log_info(gc)(\"%s: Stop requested.\", name());\n+}\n+\n+bool ShenandoahRegulatorThread::should_unload_classes() {\n+  \/\/ The heuristics delegate this decision to the collector policy, which is based on the number\n+  \/\/ of cycles started.\n+  return _global_heuristics->should_unload_classes();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+\n+class ShenandoahHeuristics;\n+class ShenandoahControlThread;\n+\n+\/*\n+ * The purpose of this class (and thread) is to allow us to continue\n+ * to evaluate heuristics during a garbage collection. This is necessary\n+ * to allow young generation collections to interrupt and old generation\n+ * collection which is in-progress. This puts heuristic triggers on the\n+ * same footing as other gc requests (alloc failure, System.gc, etc.).\n+ * However, this regulator does not block after submitting a gc request.\n+ *\n+ * We could use a PeriodicTask for this, but this thread will sleep longer\n+ * when the allocation rate is lower and PeriodicTasks cannot adjust their\n+ * sleep time.\n+ *\/\n+class ShenandoahRegulatorThread: public ConcurrentGCThread {\n+  friend class VMStructs;\n+\n+ public:\n+  explicit ShenandoahRegulatorThread(ShenandoahControlThread* control_thread);\n+\n+  const char* name() const { return \"ShenandoahRegulatorThread\";}\n+\n+  \/\/ This is called from allocation path, and thus should be fast.\n+  void notify_heap_changed() {\n+    \/\/ Notify that something had changed.\n+    if (_heap_changed.is_unset()) {\n+      _heap_changed.set();\n+    }\n+  }\n+\n+ protected:\n+  void run_service();\n+  void stop_service();\n+\n+ private:\n+  void regulate_interleaved_cycles();\n+  void regulate_concurrent_cycles();\n+  void regulate_heap();\n+\n+  bool start_old_cycle();\n+  bool start_young_cycle();\n+  bool start_global_cycle();\n+\n+  bool should_unload_classes();\n+\n+  ShenandoahSharedFlag _heap_changed;\n+  ShenandoahControlThread* _control_thread;\n+  ShenandoahHeuristics* _young_heuristics;\n+  ShenandoahHeuristics* _old_heuristics;\n+  ShenandoahHeuristics* _global_heuristics;\n+\n+  int _sleep;\n+  double _last_sleep_adjust_time;\n+\n+  void regulator_sleep();\n+};\n+\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHREGULATORTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -56,1 +58,1 @@\n-void ShenandoahRootVerifier::roots_do(OopClosure* oops) {\n+void ShenandoahRootVerifier::roots_do(OopIterateClosure* oops) {\n@@ -70,0 +72,6 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->is_gc_generation_young()) {\n+    shenandoah_assert_safepoint();\n+    heap->card_scan()->roots_do(oops);\n+  }\n+\n@@ -76,1 +84,1 @@\n-void ShenandoahRootVerifier::strong_roots_do(OopClosure* oops) {\n+void ShenandoahRootVerifier::strong_roots_do(OopIterateClosure* oops) {\n@@ -86,0 +94,6 @@\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->is_gc_generation_young()) {\n+    heap->card_scan()->roots_do(oops);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,2 +45,2 @@\n-  static void roots_do(OopClosure* cl);\n-  static void strong_roots_do(OopClosure* cl);\n+  static void roots_do(OopIterateClosure* cl);\n+  static void strong_roots_do(OopIterateClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -39,0 +41,1 @@\n+template<ShenandoahGenerationType GENERATION>\n@@ -46,0 +49,1 @@\n+\n@@ -53,1 +57,2 @@\n-ShenandoahInitMarkRootsClosure::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n+template <ShenandoahGenerationType GENERATION>\n+ShenandoahInitMarkRootsClosure<GENERATION>::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n@@ -58,0 +63,1 @@\n+template <ShenandoahGenerationType GENERATION>\n@@ -59,2 +65,3 @@\n-void ShenandoahInitMarkRootsClosure::do_oop_work(T* p) {\n-  ShenandoahMark::mark_through_ref<T>(p, _queue, _mark_context, false);\n+void ShenandoahInitMarkRootsClosure<GENERATION>::do_oop_work(T* p) {\n+  \/\/ Only called from STW mark, should not be used to bootstrap old generation marking.\n+  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, nullptr, _mark_context, false);\n@@ -83,2 +90,2 @@\n-ShenandoahSTWMark::ShenandoahSTWMark(bool full_gc) :\n-  ShenandoahMark(),\n+ShenandoahSTWMark::ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc) :\n+  ShenandoahMark(generation),\n@@ -86,1 +93,1 @@\n-  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), ShenandoahHeap::heap()->marking_context()->task_queues()),\n+  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), task_queues()),\n@@ -94,1 +101,1 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n@@ -113,0 +120,5 @@\n+    if (_generation->is_young()) {\n+      \/\/ But only scan the remembered set for young generation.\n+      _generation->scan_remembered_set(false \/* is_concurrent *\/);\n+    }\n+\n@@ -120,1 +132,1 @@\n-  heap->mark_complete_marking_context();\n+  _generation->set_mark_complete();\n@@ -129,2 +141,19 @@\n-  ShenandoahInitMarkRootsClosure  init_mark(task_queues()->queue(worker_id));\n-  _root_scanner.roots_do(&init_mark, worker_id);\n+  switch (_generation->type()) {\n+    case GLOBAL_NON_GEN: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL_NON_GEN> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case GLOBAL_GEN: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL_GEN> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case YOUNG: {\n+      ShenandoahInitMarkRootsClosure<YOUNG> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -136,1 +165,1 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->active_generation()->ref_processor();\n@@ -139,1 +168,2 @@\n-  mark_loop(worker_id, &_terminator, rp,\n+  mark_loop(_generation->type(),\n+            worker_id, &_terminator, rp,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -40,1 +41,1 @@\n- ShenandoahSTWMark(bool full_gc);\n+ ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+ShenandoahDirectCardMarkRememberedSet::ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable* card_table, size_t total_card_count) {\n+  _heap = ShenandoahHeap::heap();\n+  _card_table = card_table;\n+  _total_card_count = total_card_count;\n+  _cluster_count = total_card_count \/ ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  _card_shift = CardTable::card_shift();\n+\n+  _byte_map = _card_table->byte_for_index(0);\n+\n+  _whole_heap_base = _card_table->addr_for(_byte_map);\n+  _byte_map_base = _byte_map - (uintptr_t(_whole_heap_base) >> _card_shift);\n+\n+  assert(total_card_count % ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster == 0, \"Invalid card count.\");\n+  assert(total_card_count > 0, \"Card count cannot be zero.\");\n+}\n+\n+ShenandoahScanRememberedTask::ShenandoahScanRememberedTask(ShenandoahObjToScanQueueSet* queue_set,\n+                                                           ShenandoahObjToScanQueueSet* old_queue_set,\n+                                                           ShenandoahReferenceProcessor* rp,\n+                                                           ShenandoahRegionChunkIterator* work_list, bool is_concurrent) :\n+  WorkerTask(\"Scan Remembered Set\"),\n+  _queue_set(queue_set), _old_queue_set(old_queue_set), _rp(rp), _work_list(work_list), _is_concurrent(is_concurrent) {}\n+\n+void ShenandoahScanRememberedTask::work(uint worker_id) {\n+  if (_is_concurrent) {\n+    \/\/ This sets up a thread local reference to the worker_id which is needed by the weak reference processor.\n+    ShenandoahConcurrentWorkerSession worker_session(worker_id);\n+    ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+    do_work(worker_id);\n+  } else {\n+    \/\/ This sets up a thread local reference to the worker_id which is needed by the weak reference processor.\n+    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    do_work(worker_id);\n+  }\n+}\n+\n+void ShenandoahScanRememberedTask::do_work(uint worker_id) {\n+  ShenandoahWorkerTimingsTracker x(ShenandoahPhaseTimings::init_scan_rset, ShenandoahPhaseTimings::ScanClusters, worker_id);\n+\n+  ShenandoahObjToScanQueue* q = _queue_set->queue(worker_id);\n+  ShenandoahObjToScanQueue* old = _old_queue_set == nullptr ? nullptr : _old_queue_set->queue(worker_id);\n+  ShenandoahMarkRefsClosure<YOUNG> cl(q, _rp, old);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  RememberedScanner* scanner = heap->card_scan();\n+\n+  \/\/ set up thread local closure for shen ref processor\n+  _rp->set_mark_closure(worker_id, &cl);\n+  struct ShenandoahRegionChunk assignment;\n+  while (_work_list->next(&assignment)) {\n+    ShenandoahHeapRegion* region = assignment._r;\n+    log_debug(gc)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n+                  SIZE_FORMAT \" at offset \" SIZE_FORMAT \", size: \" SIZE_FORMAT,\n+                  worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n+    if (region->is_old()) {\n+      size_t cluster_size =\n+        CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+      size_t clusters = assignment._chunk_size \/ cluster_size;\n+      assert(clusters * cluster_size == assignment._chunk_size, \"Chunk assignments must align on cluster boundaries\");\n+      HeapWord* end_of_range = region->bottom() + assignment._chunk_offset + assignment._chunk_size;\n+\n+      \/\/ During concurrent mark, region->top() equals TAMS with respect to the current young-gen pass.\n+      if (end_of_range > region->top()) {\n+        end_of_range = region->top();\n+      }\n+      scanner->process_region_slice(region, assignment._chunk_offset, clusters, end_of_range, &cl, false, worker_id);\n+    }\n+#ifdef ENABLE_REMEMBERED_SET_CANCELLATION\n+    \/\/ This check is currently disabled to avoid crashes that occur\n+    \/\/ when we try to cancel remembered set scanning; it should be re-enabled\n+    \/\/ after the issues are fixed, as it would allow more prompt cancellation and\n+    \/\/ transition to degenerated \/ full GCs. Note that work that has been assigned\/\n+    \/\/ claimed above must be completed before we return here upon cancellation.\n+    if (heap->check_cancelled_gc_and_yield(_is_concurrent)) {\n+      return;\n+    }\n+#endif\n+  }\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_regular_group_size() {\n+  \/\/ The group size is calculated from the number of regions.  Suppose the heap has N regions.  The first group processes\n+  \/\/ N\/2 regions.  The second group processes N\/4 regions, the third group N\/8 regions and so on.\n+  \/\/ Note that infinite series N\/2 + N\/4 + N\/8 + N\/16 + ...  sums to N.\n+  \/\/\n+  \/\/ The normal group size is the number of regions \/ 2.\n+  \/\/\n+  \/\/ In the case that the region_size_words is greater than _maximum_chunk_size_words, the first group_size is\n+  \/\/ larger than the normal group size because each chunk in the group will be smaller than the region size.\n+  \/\/\n+  \/\/ The last group also has more than the normal entries because it finishes the total scanning effort.  The chunk sizes are\n+  \/\/ different for each group.  The intention is that the first group processes roughly half of the heap, the second processes\n+  \/\/ half of the remaining heap, the third processes half of what remains and so on.  The smallest chunk size\n+  \/\/ is represented by _smallest_chunk_size_words.  We do not divide work any smaller than this.\n+  \/\/\n+\n+  size_t group_size = _heap->num_regions() \/ 2;\n+  return group_size;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_first_group_chunk_size_b4_rebalance() {\n+  size_t words_in_first_chunk = ShenandoahHeapRegion::region_size_words();\n+  return words_in_first_chunk;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_num_groups() {\n+  size_t total_heap_size = _heap->num_regions() * ShenandoahHeapRegion::region_size_words();\n+  size_t num_groups = 0;\n+  size_t cumulative_group_span = 0;\n+  size_t current_group_span = _first_group_chunk_size_b4_rebalance * _regular_group_size;\n+  size_t smallest_group_span = smallest_chunk_size_words() * _regular_group_size;\n+  while ((num_groups < _maximum_groups) && (cumulative_group_span + current_group_span <= total_heap_size)) {\n+    num_groups++;\n+    cumulative_group_span += current_group_span;\n+    if (current_group_span <= smallest_group_span) {\n+      break;\n+    } else {\n+      current_group_span \/= 2;    \/\/ Each group spans half of what the preceding group spanned.\n+    }\n+  }\n+  \/\/ Loop post condition:\n+  \/\/   num_groups <= _maximum_groups\n+  \/\/   cumulative_group_span is the memory spanned by num_groups\n+  \/\/   current_group_span is the span of the last fully populated group (assuming loop iterates at least once)\n+  \/\/   each of num_groups is fully populated with _regular_group_size chunks in each\n+  \/\/ Non post conditions:\n+  \/\/   cumulative_group_span may be less than total_heap size for one or more of the folowing reasons\n+  \/\/   a) The number of regions remaining to be spanned is smaller than a complete group, or\n+  \/\/   b) We have filled up all groups through _maximum_groups and still have not spanned all regions\n+\n+  if (cumulative_group_span < total_heap_size) {\n+    \/\/ We've got more regions to span\n+    if ((num_groups < _maximum_groups) && (current_group_span > smallest_group_span)) {\n+      num_groups++;             \/\/ Place all remaining regions into a new not-full group (chunk_size half that of previous group)\n+    }\n+    \/\/ Else we are unable to create a new group because we've exceed the number of allowed groups or have reached the\n+    \/\/ minimum chunk size.\n+\n+    \/\/ Any remaining regions will be treated as if they are part of the most recently created group.  This group will\n+    \/\/ have more than _regular_group_size chunks within it.\n+  }\n+  return num_groups;\n+}\n+\n+size_t ShenandoahRegionChunkIterator::calc_total_chunks() {\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t unspanned_heap_size = _heap->num_regions() * region_size_words;\n+  size_t num_chunks = 0;\n+  size_t cumulative_group_span = 0;\n+  size_t current_group_span = _first_group_chunk_size_b4_rebalance * _regular_group_size;\n+  size_t smallest_group_span = smallest_chunk_size_words() * _regular_group_size;\n+\n+  \/\/ The first group gets special handling because the first chunk size can be no larger than _largest_chunk_size_words\n+  if (region_size_words > _maximum_chunk_size_words) {\n+    \/\/ In the case that we shrink the first group's chunk size, certain other groups will also be subsumed within the first group\n+    size_t effective_chunk_size = _first_group_chunk_size_b4_rebalance;\n+    while (effective_chunk_size >= _maximum_chunk_size_words) {\n+      num_chunks += current_group_span \/ _maximum_chunk_size_words;\n+      unspanned_heap_size -= current_group_span;\n+      effective_chunk_size \/= 2;\n+      current_group_span \/= 2;\n+    }\n+  } else {\n+    num_chunks = _regular_group_size;\n+    unspanned_heap_size -= current_group_span;\n+    current_group_span \/= 2;\n+  }\n+  size_t spanned_groups = 1;\n+  while (unspanned_heap_size > 0) {\n+    if (current_group_span <= unspanned_heap_size) {\n+      unspanned_heap_size -= current_group_span;\n+      num_chunks += _regular_group_size;\n+      spanned_groups++;\n+\n+      \/\/ _num_groups is the number of groups required to span the configured heap size.  We are not allowed\n+      \/\/ to change the number of groups.  The last group is responsible for spanning all chunks not spanned\n+      \/\/ by previously processed groups.\n+      if (spanned_groups >= _num_groups) {\n+        \/\/ The last group has more than _regular_group_size entries.\n+        size_t chunk_span = current_group_span \/ _regular_group_size;\n+        size_t extra_chunks = unspanned_heap_size \/ chunk_span;\n+        assert (extra_chunks * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+        num_chunks += extra_chunks;\n+        return num_chunks;\n+      } else if (current_group_span <= smallest_group_span) {\n+        \/\/ We cannot introduce new groups because we've reached the lower bound on group size.  So this last\n+        \/\/ group may hold extra chunks.\n+        size_t chunk_span = smallest_chunk_size_words();\n+        size_t extra_chunks = unspanned_heap_size \/ chunk_span;\n+        assert (extra_chunks * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+        num_chunks += extra_chunks;\n+        return num_chunks;\n+      } else {\n+        current_group_span \/= 2;\n+      }\n+    } else {\n+      \/\/ This last group has fewer than _regular_group_size entries.\n+      size_t chunk_span = current_group_span \/ _regular_group_size;\n+      size_t last_group_size = unspanned_heap_size \/ chunk_span;\n+      assert (last_group_size * chunk_span == unspanned_heap_size, \"Chunks must precisely span regions\");\n+      num_chunks += last_group_size;\n+      return num_chunks;\n+    }\n+  }\n+  return num_chunks;\n+}\n+\n+ShenandoahRegionChunkIterator::ShenandoahRegionChunkIterator(size_t worker_count) :\n+    ShenandoahRegionChunkIterator(ShenandoahHeap::heap(), worker_count)\n+{\n+}\n+\n+ShenandoahRegionChunkIterator::ShenandoahRegionChunkIterator(ShenandoahHeap* heap, size_t worker_count) :\n+    _heap(heap),\n+    _regular_group_size(calc_regular_group_size()),\n+    _first_group_chunk_size_b4_rebalance(calc_first_group_chunk_size_b4_rebalance()),\n+    _num_groups(calc_num_groups()),\n+    _total_chunks(calc_total_chunks()),\n+    _index(0)\n+{\n+#ifdef ASSERT\n+  size_t expected_chunk_size_words = _clusters_in_smallest_chunk * CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  assert(smallest_chunk_size_words() == expected_chunk_size_words, \"_smallest_chunk_size (\" SIZE_FORMAT\") is not valid because it does not equal (\" SIZE_FORMAT \")\",\n+         smallest_chunk_size_words(), expected_chunk_size_words);\n+#endif\n+  assert(_num_groups <= _maximum_groups,\n+         \"The number of remembered set scanning groups must be less than or equal to maximum groups\");\n+  assert(smallest_chunk_size_words() << (_maximum_groups - 1) == _maximum_chunk_size_words,\n+         \"Maximum number of groups needs to span maximum chunk size to smallest chunk size\");\n+\n+  size_t words_in_region = ShenandoahHeapRegion::region_size_words();\n+  _region_index[0] = 0;\n+  _group_offset[0] = 0;\n+  if (words_in_region > _maximum_chunk_size_words) {\n+    \/\/ In the case that we shrink the first group's chunk size, certain other groups will also be subsumed within the first group\n+    size_t num_chunks = 0;\n+    size_t effective_chunk_size = _first_group_chunk_size_b4_rebalance;\n+    size_t  current_group_span = effective_chunk_size * _regular_group_size;\n+    while (effective_chunk_size >= _maximum_chunk_size_words) {\n+      num_chunks += current_group_span \/ _maximum_chunk_size_words;\n+      effective_chunk_size \/= 2;\n+      current_group_span \/= 2;\n+    }\n+    _group_entries[0] = num_chunks;\n+    _group_chunk_size[0] = _maximum_chunk_size_words;\n+  } else {\n+    _group_entries[0] = _regular_group_size;\n+    _group_chunk_size[0] = _first_group_chunk_size_b4_rebalance;\n+  }\n+\n+  size_t previous_group_span = _group_entries[0] * _group_chunk_size[0];\n+  for (size_t i = 1; i < _num_groups; i++) {\n+    size_t previous_group_entries = (i == 1)? _group_entries[0]: (_group_entries[i-1] - _group_entries[i-2]);\n+    _group_chunk_size[i] = _group_chunk_size[i-1] \/ 2;\n+    size_t chunks_in_group = _regular_group_size;\n+    size_t this_group_span = _group_chunk_size[i] * chunks_in_group;\n+    size_t total_span_of_groups = previous_group_span + this_group_span;\n+    _region_index[i] = previous_group_span \/ words_in_region;\n+    _group_offset[i] = previous_group_span % words_in_region;\n+    _group_entries[i] = _group_entries[i-1] + _regular_group_size;\n+    previous_group_span = total_span_of_groups;\n+  }\n+  if (_group_entries[_num_groups-1] < _total_chunks) {\n+    assert((_total_chunks - _group_entries[_num_groups-1]) * _group_chunk_size[_num_groups-1] + previous_group_span ==\n+           heap->num_regions() * words_in_region, \"Total region chunks (\" SIZE_FORMAT\n+           \") do not span total heap regions (\" SIZE_FORMAT \")\", _total_chunks, _heap->num_regions());\n+    previous_group_span += (_total_chunks - _group_entries[_num_groups-1]) * _group_chunk_size[_num_groups-1];\n+    _group_entries[_num_groups-1] = _total_chunks;\n+  }\n+  assert(previous_group_span == heap->num_regions() * words_in_region, \"Total region chunks (\" SIZE_FORMAT\n+         \") do not span total heap regions (\" SIZE_FORMAT \"): \" SIZE_FORMAT \" does not equal \" SIZE_FORMAT,\n+         _total_chunks, _heap->num_regions(), previous_group_span, heap->num_regions() * words_in_region);\n+\n+  \/\/ Not necessary, but keeps things tidy\n+  for (size_t i = _num_groups; i < _maximum_groups; i++) {\n+    _region_index[i] = 0;\n+    _group_offset[i] = 0;\n+    _group_entries[i] = _group_entries[i-1];\n+    _group_chunk_size[i] = 0;\n+  }\n+}\n+\n+void ShenandoahRegionChunkIterator::reset() {\n+  _index = 0;\n+}\n+\n+ShenandoahVerifyNoYoungRefsClosure::ShenandoahVerifyNoYoungRefsClosure():\n+  _heap(ShenandoahHeap::heap()) {\n+  assert(_heap->mode()->is_generational(), \"Don't use when non-generational\");\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -0,0 +1,1083 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n+\n+\/\/ Terminology used within this source file:\n+\/\/\n+\/\/ Card Entry:   This is the information that identifies whether a\n+\/\/               particular card-table entry is Clean or Dirty.  A clean\n+\/\/               card entry denotes that the associated memory does not\n+\/\/               hold references to young-gen memory.\n+\/\/\n+\/\/ Card Region, aka\n+\/\/ Card Memory:  This is the region of memory that is assocated with a\n+\/\/               particular card entry.\n+\/\/\n+\/\/ Card Cluster: A card cluster represents 64 card entries.  A card\n+\/\/               cluster is the minimal amount of work performed at a\n+\/\/               time by a parallel thread.  Note that the work required\n+\/\/               to scan a card cluster is somewhat variable in that the\n+\/\/               required effort depends on how many cards are dirty, how\n+\/\/               many references are held within the objects that span a\n+\/\/               DIRTY card's memory, and on the size of the object\n+\/\/               that spans the end of a DIRTY card's memory (because\n+\/\/               that object, if it's not an array, may need to be scanned in\n+\/\/               its entirety, when the object is imprecisely dirtied. Imprecise\n+\/\/               dirtying is when the card corresponding to the object header\n+\/\/               is dirtied, rather than the card on which the updated field lives).\n+\/\/               To better balance work amongst them, parallel worker threads dynamically\n+\/\/               claim clusters and are flexible in the number of clusters they\n+\/\/               process.\n+\/\/\n+\/\/ A cluster represents a \"natural\" quantum of work to be performed by\n+\/\/ a parallel GC thread's background remembered set scanning efforts.\n+\/\/ The notion of cluster is similar to the notion of stripe in the\n+\/\/ implementation of parallel GC card scanning.  However, a cluster is\n+\/\/ typically smaller than a stripe, enabling finer grain division of\n+\/\/ labor between multiple threads, and potentially better load balancing\n+\/\/ when dirty cards are not uniformly distributed in the heap, as is often\n+\/\/ the case with generational workloads where more recently promoted objects\n+\/\/ may be dirtied more frequently that older objects.\n+\/\/\n+\/\/ For illustration, consider the following possible JVM configurations:\n+\/\/\n+\/\/   Scenario 1:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of a card entry is 512 B\n+\/\/     Each card table entry consumes 1 B\n+\/\/     Assume one long word (8 B)of the card table represents a cluster.\n+\/\/       This long word holds 8 card table entries, spanning a\n+\/\/       total of 8*512 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n+\/\/\n+\/\/   Scenario 2:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of each card entry is 128 B\n+\/\/     Each card table entry consumes 1 bit\n+\/\/     Assume one int word (4 B) of the card table represents a cluster.\n+\/\/       This int word holds 32 b\/1 b = 32 card table entries, spanning a\n+\/\/       total of 32 * 128 B = 4 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 4 KB = 32 K\n+\/\/\n+\/\/   Scenario 3:\n+\/\/     RegionSize is 128 MB\n+\/\/     Span of each card entry is 512 B\n+\/\/     Each card table entry consumes 1 bit\n+\/\/     Assume one long word (8 B) of card table represents a cluster.\n+\/\/       This long word holds 64 b\/ 1 b = 64 card table entries, spanning a\n+\/\/       total of 64 * 512 B = 32 KB of the heap\n+\/\/     The number of clusters per region is 128 MB \/ 32 KB = 4 K\n+\/\/\n+\/\/ At the start of a new young-gen concurrent mark pass, the gang of\n+\/\/ Shenandoah worker threads collaborate in performing the following\n+\/\/ actions:\n+\/\/\n+\/\/  Let old_regions = number of ShenandoahHeapRegion comprising\n+\/\/    old-gen memory\n+\/\/  Let region_size = ShenandoahHeapRegion::region_size_bytes()\n+\/\/    represent the number of bytes in each region\n+\/\/  Let clusters_per_region = region_size \/ 512\n+\/\/  Let rs represent the relevant RememberedSet implementation\n+\/\/    (an instance of ShenandoahDirectCardMarkRememberedSet or an instance\n+\/\/     of a to-be-implemented ShenandoahBufferWithSATBRememberedSet)\n+\/\/\n+\/\/  for each ShenandoahHeapRegion old_region in the whole heap\n+\/\/    determine the cluster number of the first cluster belonging\n+\/\/      to that region\n+\/\/    for each cluster contained within that region\n+\/\/      Assure that exactly one worker thread processes each\n+\/\/      cluster, each thread making a series of invocations of the\n+\/\/      following:\n+\/\/\n+\/\/        rs->process_clusters(worker_id, ReferenceProcessor *,\n+\/\/                             ShenandoahConcurrentMark *, cluster_no, cluster_count,\n+\/\/                             HeapWord *end_of_range, OopClosure *oops);\n+\/\/\n+\/\/  For efficiency, divide up the clusters so that different threads\n+\/\/  are responsible for processing different clusters.  Processing costs\n+\/\/  may vary greatly between clusters for the following reasons:\n+\/\/\n+\/\/        a) some clusters contain mostly dirty cards and other\n+\/\/           clusters contain mostly clean cards\n+\/\/        b) some clusters contain mostly primitive data and other\n+\/\/           clusters contain mostly reference data\n+\/\/        c) some clusters are spanned by very large non-array objects that\n+\/\/           begin in some other cluster.  When a large non-array object\n+\/\/           beginning in a preceding cluster spans large portions of\n+\/\/           this cluster, then because of imprecise dirtying, the\n+\/\/           portion of the object in this cluster may be clean, but\n+\/\/           will need to be processed by the worker responsible for\n+\/\/           this cluster, potentially increasing its work.\n+\/\/        d) in the case that the end of this cluster is spanned by a\n+\/\/           very large non-array object, the worker for this cluster will\n+\/\/           be responsible for processing the portion of the object\n+\/\/           in this cluster.\n+\/\/\n+\/\/ Though an initial division of labor between marking threads may\n+\/\/ assign equal numbers of clusters to be scanned by each thread, it\n+\/\/ should be expected that some threads will finish their assigned\n+\/\/ work before others.  Therefore, some amount of the full remembered\n+\/\/ set scanning effort should be held back and assigned incrementally\n+\/\/ to the threads that end up with excess capacity.  Consider the\n+\/\/ following strategy for dividing labor:\n+\/\/\n+\/\/        1. Assume there are 8 marking threads and 1024 remembered\n+\/\/           set clusters to be scanned.\n+\/\/        2. Assign each thread to scan 64 clusters.  This leaves\n+\/\/           512 (1024 - (8*64)) clusters to still be scanned.\n+\/\/        3. As the 8 server threads complete previous cluster\n+\/\/           scanning assignments, issue each of the next 8 scanning\n+\/\/           assignments as units of 32 additional cluster each.\n+\/\/           In the case that there is high variance in effort\n+\/\/           associated with previous cluster scanning assignments,\n+\/\/           multiples of these next assignments may be serviced by\n+\/\/           the server threads that were previously assigned lighter\n+\/\/           workloads.\n+\/\/        4. Make subsequent scanning assignments as follows:\n+\/\/             a) 8 assignments of size 16 clusters\n+\/\/             b) 8 assignments of size 8 clusters\n+\/\/             c) 16 assignments of size 4 clusters\n+\/\/\n+\/\/    When there is no more remembered set processing work to be\n+\/\/    assigned to a newly idled worker thread, that thread can move\n+\/\/    on to work on other tasks associated with root scanning until such\n+\/\/    time as all clusters have been examined.\n+\/\/\n+\/\/ Remembered set scanning is designed to run concurrently with\n+\/\/ mutator threads, with multiple concurrent workers. Furthermore, the\n+\/\/ current implementation of remembered set scanning never clears a\n+\/\/ card once it has been marked.\n+\/\/\n+\/\/ These limitations will be addressed in future enhancements to the\n+\/\/ existing implementation.\n+\n+#include <stdint.h>\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n+#include \"gc\/shenandoah\/shenandoahTaskqueue.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ShenandoahReferenceProcessor;\n+class ShenandoahConcurrentMark;\n+class ShenandoahHeap;\n+class ShenandoahRegionIterator;\n+class ShenandoahMarkingContext;\n+\n+class CardTable;\n+typedef CardTable::CardValue CardValue;\n+\n+class ShenandoahDirectCardMarkRememberedSet: public CHeapObj<mtGC> {\n+\n+private:\n+\n+  \/\/ Use symbolic constants defined in cardTable.hpp\n+  \/\/  CardTable::card_shift = 9;\n+  \/\/  CardTable::card_size = 512;\n+  \/\/  CardTable::card_size_in_words = 64;\n+  \/\/  CardTable::clean_card_val()\n+  \/\/  CardTable::dirty_card_val()\n+\n+  ShenandoahHeap *_heap;\n+  ShenandoahCardTable *_card_table;\n+  size_t _card_shift;\n+  size_t _total_card_count;\n+  size_t _cluster_count;\n+  HeapWord *_whole_heap_base;   \/\/ Points to first HeapWord of data contained within heap memory\n+  CardValue* _byte_map;         \/\/ Points to first entry within the card table\n+  CardValue* _byte_map_base;    \/\/ Points to byte_map minus the bias computed from address of heap memory\n+\n+public:\n+\n+  \/\/ count is the number of cards represented by the card table.\n+  ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable *card_table, size_t total_card_count);\n+  ~ShenandoahDirectCardMarkRememberedSet();\n+\n+  \/\/ Card index is zero-based relative to _byte_map.\n+  size_t last_valid_index() const;\n+  size_t total_cards() const;\n+  size_t card_index_for_addr(HeapWord *p) const;\n+  HeapWord *addr_for_card_index(size_t card_index) const;\n+  inline const CardValue* get_card_table_byte_map(bool write_table) const;\n+  inline bool is_card_dirty(size_t card_index) const;\n+  inline bool is_write_card_dirty(size_t card_index) const;\n+  inline void mark_card_as_dirty(size_t card_index);\n+  inline void mark_range_as_dirty(size_t card_index, size_t num_cards);\n+  inline void mark_card_as_clean(size_t card_index);\n+  inline void mark_read_card_as_clean(size_t card_index);\n+  inline void mark_range_as_clean(size_t card_index, size_t num_cards);\n+  inline bool is_card_dirty(HeapWord *p) const;\n+  inline void mark_card_as_dirty(HeapWord *p);\n+  inline void mark_range_as_dirty(HeapWord *p, size_t num_heap_words);\n+  inline void mark_card_as_clean(HeapWord *p);\n+  inline void mark_range_as_clean(HeapWord *p, size_t num_heap_words);\n+  inline size_t cluster_count() const;\n+\n+  \/\/ Called by GC thread at start of concurrent mark to exchange roles of read and write remembered sets.\n+  \/\/ Not currently used because mutator write barrier does not honor changes to the location of card table.\n+  void swap_remset() {  _card_table->swap_card_tables(); }\n+\n+  void merge_write_table(HeapWord* start, size_t word_count) {\n+    size_t card_index = card_index_for_addr(start);\n+    size_t num_cards = word_count \/ CardTable::card_size_in_words();\n+    size_t iterations = num_cards \/ (sizeof (intptr_t) \/ sizeof (CardValue));\n+    intptr_t* read_table_ptr = (intptr_t*) &(_card_table->read_byte_map())[card_index];\n+    intptr_t* write_table_ptr = (intptr_t*) &(_card_table->write_byte_map())[card_index];\n+    for (size_t i = 0; i < iterations; i++) {\n+      intptr_t card_value = *write_table_ptr;\n+      *read_table_ptr++ &= card_value;\n+      write_table_ptr++;\n+    }\n+  }\n+\n+  \/\/ Instead of swap_remset, the current implementation of concurrent remembered set scanning does reset_remset\n+  \/\/ in parallel threads, each invocation processing one entire HeapRegion at a time.  Processing of a region\n+  \/\/ consists of copying the write table to the read table and cleaning the write table.\n+  void reset_remset(HeapWord* start, size_t word_count) {\n+    size_t card_index = card_index_for_addr(start);\n+    size_t num_cards = word_count \/ CardTable::card_size_in_words();\n+    size_t iterations = num_cards \/ (sizeof (intptr_t) \/ sizeof (CardValue));\n+    intptr_t* read_table_ptr = (intptr_t*) &(_card_table->read_byte_map())[card_index];\n+    intptr_t* write_table_ptr = (intptr_t*) &(_card_table->write_byte_map())[card_index];\n+    for (size_t i = 0; i < iterations; i++) {\n+      *read_table_ptr++ = *write_table_ptr;\n+      *write_table_ptr++ = CardTable::clean_card_row_val();\n+    }\n+  }\n+\n+  \/\/ Called by GC thread after scanning old remembered set in order to prepare for next GC pass\n+  void clear_old_remset() {  _card_table->clear_read_table(); }\n+\n+};\n+\n+\/\/ A ShenandoahCardCluster represents the minimal unit of work\n+\/\/ performed by independent parallel GC threads during scanning of\n+\/\/ remembered sets.\n+\/\/\n+\/\/ The GC threads that perform card-table remembered set scanning may\n+\/\/ overwrite card-table entries to mark them as clean in the case that\n+\/\/ the associated memory no longer holds references to young-gen\n+\/\/ memory.  Rather than access the card-table entries directly, all GC\n+\/\/ thread access to card-table information is made by way of the\n+\/\/ ShenandoahCardCluster data abstraction.  This abstraction\n+\/\/ effectively manages access to multiple possible underlying\n+\/\/ remembered set implementations, including a traditional card-table\n+\/\/ approach and a SATB-based approach.\n+\/\/\n+\/\/ The API services represent a compromise between efficiency and\n+\/\/ convenience.\n+\/\/\n+\/\/ Multiple GC threads that scan the remembered set\n+\/\/ in parallel.  The desire is to divide the complete scanning effort\n+\/\/ into multiple clusters of work that can be independently processed\n+\/\/ by individual threads without need for synchronizing efforts\n+\/\/ between the work performed by each task.  The term \"cluster\" of\n+\/\/ work is similar to the term \"stripe\" as used in the implementation\n+\/\/ of Parallel GC.\n+\/\/\n+\/\/ Complexity arises when an object to be scanned crosses the boundary\n+\/\/ between adjacent cluster regions.  Here is the protocol that we currently\n+\/\/ follow:\n+\/\/\n+\/\/  1. The thread responsible for scanning the cards in a cluster modifies\n+\/\/     the associated card-table entries. Only cards that are dirty are\n+\/\/     processed, except as described below for the case of objects that\n+\/\/     straddle more than one card.\n+\/\/  2. Object Arrays are precisely dirtied, so only the portion of the obj-array\n+\/\/     that overlaps the range of dirty cards in its cluster are scanned\n+\/\/     by each worker thread. This holds for portions of obj-arrays that extend\n+\/\/     over clusters processed by different workers, with each worked responsible\n+\/\/     for scanning the portion of the obj-array overlapping the dirty cards in\n+\/\/     its cluster.\n+\/\/  3. Non-array objects are precisely dirtied by the interpreter and the compilers\n+\/\/     For such objects that extend over multiple cards, or even multiple clusters,\n+\/\/     the entire object is scanned by the worker that processes the (dirty) card on\n+\/\/     which the object's header lies. (However, GC workers should precisely dirty the\n+\/\/     cards with inter-regional\/inter-generational pointers in the body of this object,\n+\/\/     thus making subsequent scans potentially less expensive.) Such larger non-array\n+\/\/     objects are relatively rare.\n+\/\/\n+\/\/  A possible criticism:\n+\/\/  C. The representation of pointer location descriptive information\n+\/\/     within Klass representations is not designed for efficient\n+\/\/     \"random access\".  An alternative approach to this design would\n+\/\/     be to scan very large objects multiple times, once for each\n+\/\/     cluster that is spanned by the object's range.  This reduces\n+\/\/     unnecessary overscan, but it introduces different sorts of\n+\/\/     overhead effort:\n+\/\/       i) For each spanned cluster, we have to look up the start of\n+\/\/          the crossing object.\n+\/\/      ii) Each time we scan the very large object, we have to\n+\/\/          sequentially walk through its pointer location\n+\/\/          descriptors, skipping over all of the pointers that\n+\/\/          precede the start of the range of addresses that we\n+\/\/          consider relevant.\n+\n+\n+\/\/ Because old-gen heap memory is not necessarily contiguous, and\n+\/\/ because cards are not necessarily maintained for young-gen memory,\n+\/\/ consecutive card numbers do not necessarily correspond to consecutive\n+\/\/ address ranges.  For the traditional direct-card-marking\n+\/\/ implementation of this interface, consecutive card numbers are\n+\/\/ likely to correspond to contiguous regions of memory, but this\n+\/\/ should not be assumed.  Instead, rely only upon the following:\n+\/\/\n+\/\/  1. All card numbers for cards pertaining to the same\n+\/\/     ShenandoahHeapRegion are consecutively numbered.\n+\/\/  2. In the case that neighboring ShenandoahHeapRegions both\n+\/\/     represent old-gen memory, the card regions that span the\n+\/\/     boundary between these neighboring heap regions will be\n+\/\/     consecutively numbered.\n+\/\/  3. (A corollary) In the case that an old-gen object straddles the\n+\/\/     boundary between two heap regions, the card regions that\n+\/\/     correspond to the span of this object will be consecutively\n+\/\/     numbered.\n+\/\/\n+\/\/ ShenandoahCardCluster abstracts access to the remembered set\n+\/\/ and also keeps track of crossing map information to allow efficient\n+\/\/ resolution of object start addresses.\n+\/\/\n+\/\/ ShenandoahCardCluster supports all of the services of\n+\/\/ RememberedSet, plus it supports register_object() and lookup_object().\n+\/\/ Note that we only need to register the start addresses of the object that\n+\/\/ overlays the first address of a card; we need to do this for every card.\n+\/\/ In other words, register_object() checks if the object crosses a card boundary,\n+\/\/ and updates the offset value for each card that the object crosses into.\n+\/\/ For objects that don't straddle cards, nothing needs to be done.\n+\/\/\n+\/\/ The RememberedSet template parameter is intended to represent either\n+\/\/     ShenandoahDirectCardMarkRememberedSet, or a to-be-implemented\n+\/\/     ShenandoahBufferWithSATBRememberedSet.\n+template<typename RememberedSet>\n+class ShenandoahCardCluster: public CHeapObj<mtGC> {\n+\n+private:\n+  RememberedSet *_rs;\n+\n+public:\n+  static const size_t CardsPerCluster = 64;\n+\n+private:\n+  typedef struct cross_map { uint8_t first; uint8_t last; } xmap;\n+  typedef union crossing_info { uint16_t short_word; xmap offsets; } crossing_info;\n+\n+  \/\/ ObjectStartsInCardRegion bit is set within a crossing_info.offsets.start iff at least one object starts within\n+  \/\/ a particular card region.  We pack this bit into start byte under assumption that start byte is accessed less\n+  \/\/ frequently than last byte.  This is true when number of clean cards is greater than number of dirty cards.\n+  static const uint16_t ObjectStartsInCardRegion = 0x80;\n+  static const uint16_t FirstStartBits           = 0x7f;\n+\n+  \/\/ Check that we have enough bits to store the largest possible offset into a card for an object start.\n+  \/\/ The value for maximum card size is based on the constraints for GCCardSizeInBytes in gc_globals.hpp.\n+  static const int MaxCardSize = NOT_LP64(512) LP64_ONLY(1024);\n+  STATIC_ASSERT((MaxCardSize \/ HeapWordSize) - 1 <= FirstStartBits);\n+\n+  crossing_info *object_starts;\n+\n+public:\n+  \/\/ If we're setting first_start, assume the card has an object.\n+  inline void set_first_start(size_t card_index, uint8_t value) {\n+    object_starts[card_index].offsets.first = ObjectStartsInCardRegion | value;\n+  }\n+\n+  inline void set_last_start(size_t card_index, uint8_t value) {\n+    object_starts[card_index].offsets.last = value;\n+  }\n+\n+  inline void set_starts_object_bit(size_t card_index) {\n+    object_starts[card_index].offsets.first |= ObjectStartsInCardRegion;\n+  }\n+\n+  inline void clear_starts_object_bit(size_t card_index) {\n+    object_starts[card_index].offsets.first &= ~ObjectStartsInCardRegion;\n+  }\n+\n+  \/\/ Returns true iff an object is known to start within the card memory associated with card card_index.\n+  inline bool starts_object(size_t card_index) const {\n+    return (object_starts[card_index].offsets.first & ObjectStartsInCardRegion) != 0;\n+  }\n+\n+  inline void clear_objects_in_range(HeapWord *addr, size_t num_words) {\n+    size_t card_index = _rs->card_index_for_addr(addr);\n+    size_t last_card_index = _rs->card_index_for_addr(addr + num_words - 1);\n+    while (card_index <= last_card_index)\n+      object_starts[card_index++].short_word = 0;\n+  }\n+\n+  ShenandoahCardCluster(RememberedSet *rs) {\n+    _rs = rs;\n+    \/\/ TODO: We don't really need object_starts entries for every card entry.  We only need these for\n+    \/\/ the card entries that correspond to old-gen memory.  But for now, let's be quick and dirty.\n+    object_starts = NEW_C_HEAP_ARRAY(crossing_info, rs->total_cards(), mtGC);\n+    for (size_t i = 0; i < rs->total_cards(); i++) {\n+      object_starts[i].short_word = 0;\n+    }\n+  }\n+\n+  ~ShenandoahCardCluster() {\n+    FREE_C_HEAP_ARRAY(crossing_info, object_starts);\n+    object_starts = nullptr;\n+  }\n+\n+  \/\/ There is one entry within the object_starts array for each card entry.\n+  \/\/\n+  \/\/  Suppose multiple garbage objects are coalesced during GC sweep\n+  \/\/  into a single larger \"free segment\".  As each two objects are\n+  \/\/  coalesced together, the start information pertaining to the second\n+  \/\/  object must be removed from the objects_starts array.  If the\n+  \/\/  second object had been been the first object within card memory,\n+  \/\/  the new first object is the object that follows that object if\n+  \/\/  that starts within the same card memory, or NoObject if the\n+  \/\/  following object starts within the following cluster.  If the\n+  \/\/  second object had been the last object in the card memory,\n+  \/\/  replace this entry with the newly coalesced object if it starts\n+  \/\/  within the same card memory, or with NoObject if it starts in a\n+  \/\/  preceding card's memory.\n+  \/\/\n+  \/\/  Suppose a large free segment is divided into a smaller free\n+  \/\/  segment and a new object.  The second part of the newly divided\n+  \/\/  memory must be registered as a new object, overwriting at most\n+  \/\/  one first_start and one last_start entry.  Note that one of the\n+  \/\/  newly divided two objects might be a new GCLAB.\n+  \/\/\n+  \/\/  Suppose postprocessing of a GCLAB finds that the original GCLAB\n+  \/\/  has been divided into N objects.  Each of the N newly allocated\n+  \/\/  objects will be registered, overwriting at most one first_start\n+  \/\/  and one last_start entries.\n+  \/\/\n+  \/\/  No object registration operations are linear in the length of\n+  \/\/  the registered objects.\n+  \/\/\n+  \/\/ Consider further the following observations regarding object\n+  \/\/ registration costs:\n+  \/\/\n+  \/\/   1. The cost is paid once for each old-gen object (Except when\n+  \/\/      an object is demoted and repromoted, in which case we would\n+  \/\/      pay the cost again).\n+  \/\/   2. The cost can be deferred so that there is no urgency during\n+  \/\/      mutator copy-on-first-access promotion.  Background GC\n+  \/\/      threads will update the object_starts array by post-\n+  \/\/      processing the contents of retired PLAB buffers.\n+  \/\/   3. The bet is that these costs are paid relatively rarely\n+  \/\/      because:\n+  \/\/      a) Most objects die young and objects that die in young-gen\n+  \/\/         memory never need to be registered with the object_starts\n+  \/\/         array.\n+  \/\/      b) Most objects that are promoted into old-gen memory live\n+  \/\/         there without further relocation for a relatively long\n+  \/\/         time, so we get a lot of benefit from each investment\n+  \/\/         in registering an object.\n+\n+public:\n+\n+  \/\/ The starting locations of objects contained within old-gen memory\n+  \/\/ are registered as part of the remembered set implementation.  This\n+  \/\/ information is required when scanning dirty card regions that are\n+  \/\/ spanned by objects beginning within preceding card regions.  It\n+  \/\/ is necessary to find the first and last objects that begin within\n+  \/\/ this card region.  Starting addresses of objects are required to\n+  \/\/ find the object headers, and object headers provide information\n+  \/\/ about which fields within the object hold addresses.\n+  \/\/\n+  \/\/ The old-gen memory allocator invokes register_object() for any\n+  \/\/ object that is allocated within old-gen memory.  This identifies\n+  \/\/ the starting addresses of objects that span boundaries between\n+  \/\/ card regions.\n+  \/\/\n+  \/\/ It is not necessary to invoke register_object at the very instant\n+  \/\/ an object is allocated.  It is only necessary to invoke it\n+  \/\/ prior to the next start of a garbage collection concurrent mark\n+  \/\/ or concurrent update-references phase.  An \"ideal\" time to register\n+  \/\/ objects is during post-processing of a GCLAB after the GCLAB is\n+  \/\/ retired due to depletion of its memory.\n+  \/\/\n+  \/\/ register_object() does not perform synchronization.  In the case\n+  \/\/ that multiple threads are registering objects whose starting\n+  \/\/ addresses are within the same cluster, races between these\n+  \/\/ threads may result in corruption of the object-start data\n+  \/\/ structures.  Parallel GC threads should avoid registering objects\n+  \/\/ residing within the same cluster by adhering to the following\n+  \/\/ coordination protocols:\n+  \/\/\n+  \/\/  1. Align thread-local GCLAB buffers with some TBD multiple of\n+  \/\/     card clusters.  The card cluster size is 32 KB.  If the\n+  \/\/     desired GCLAB size is 128 KB, align the buffer on a multiple\n+  \/\/     of 4 card clusters.\n+  \/\/  2. Post-process the contents of GCLAB buffers to register the\n+  \/\/     objects allocated therein.  Allow one GC thread at a\n+  \/\/     time to do the post-processing of each GCLAB.\n+  \/\/  3. Since only one GC thread at a time is registering objects\n+  \/\/     belonging to a particular allocation buffer, no locking\n+  \/\/     is performed when registering these objects.\n+  \/\/  4. Any remnant of unallocated memory within an expended GC\n+  \/\/     allocation buffer is not returned to the old-gen allocation\n+  \/\/     pool until after the GC allocation buffer has been post\n+  \/\/     processed.  Before any remnant memory is returned to the\n+  \/\/     old-gen allocation pool, the GC thread that scanned this GC\n+  \/\/     allocation buffer performs a write-commit memory barrier.\n+  \/\/  5. Background GC threads that perform tenuring of young-gen\n+  \/\/     objects without a GCLAB use a CAS lock before registering\n+  \/\/     each tenured object.  The CAS lock assures both mutual\n+  \/\/     exclusion and memory coherency\/visibility.  Note that an\n+  \/\/     object tenured by a background GC thread will not overlap\n+  \/\/     with any of the clusters that are receiving tenured objects\n+  \/\/     by way of GCLAB buffers.  Multiple independent GC threads may\n+  \/\/     attempt to tenure objects into a shared cluster.  This is why\n+  \/\/     sychronization may be necessary.  Consider the following\n+  \/\/     scenarios:\n+  \/\/\n+  \/\/     a) If two objects are tenured into the same card region, each\n+  \/\/        registration may attempt to modify the first-start or\n+  \/\/        last-start information associated with that card region.\n+  \/\/        Furthermore, because the representations of first-start\n+  \/\/        and last-start information within the object_starts array\n+  \/\/        entry uses different bits of a shared uint_16 to represent\n+  \/\/        each, it is necessary to lock the entire card entry\n+  \/\/        before modifying either the first-start or last-start\n+  \/\/        information within the entry.\n+  \/\/     b) Suppose GC thread X promotes a tenured object into\n+  \/\/        card region A and this tenured object spans into\n+  \/\/        neighboring card region B.  Suppose GC thread Y (not equal\n+  \/\/        to X) promotes a tenured object into cluster B.  GC thread X\n+  \/\/        will update the object_starts information for card A.  No\n+  \/\/        synchronization is required.\n+  \/\/     c) In summary, when background GC threads register objects\n+  \/\/        newly tenured into old-gen memory, they must acquire a\n+  \/\/        mutual exclusion lock on the card that holds the starting\n+  \/\/        address of the newly tenured object.  This can be achieved\n+  \/\/        by using a CAS instruction to assure that the previous\n+  \/\/        values of first-offset and last-offset have not been\n+  \/\/        changed since the same thread inquired as to their most\n+  \/\/        current values.\n+  \/\/\n+  \/\/     One way to minimize the need for synchronization between\n+  \/\/     background tenuring GC threads is for each tenuring GC thread\n+  \/\/     to promote young-gen objects into distinct dedicated cluster\n+  \/\/     ranges.\n+  \/\/  6. The object_starts information is only required during the\n+  \/\/     starting of concurrent marking and concurrent evacuation\n+  \/\/     phases of GC.  Before we start either of these GC phases, the\n+  \/\/     JVM enters a safe point and all GC threads perform\n+  \/\/     commit-write barriers to assure that access to the\n+  \/\/     object_starts information is coherent.\n+\n+\n+  \/\/ Notes on synchronization of register_object():\n+  \/\/\n+  \/\/  1. For efficiency, there is no locking in the implementation of register_object()\n+  \/\/  2. Thus, it is required that users of this service assure that concurrent\/parallel invocations of\n+  \/\/     register_object() do pertain to the same card's memory range.  See discussion below to understand\n+  \/\/     the risks.\n+  \/\/  3. When allocating from a TLAB or GCLAB, the mutual exclusion can be guaranteed by assuring that each\n+  \/\/     LAB's start and end are aligned on card memory boundaries.\n+  \/\/  4. Use the same lock that guarantees exclusivity when performing free-list allocation within heap regions.\n+  \/\/\n+  \/\/ Register the newly allocated object while we're holding the global lock since there's no synchronization\n+  \/\/ built in to the implementation of register_object().  There are potential races when multiple independent\n+  \/\/ threads are allocating objects, some of which might span the same card region.  For example, consider\n+  \/\/ a card table's memory region within which three objects are being allocated by three different threads:\n+  \/\/\n+  \/\/ objects being \"concurrently\" allocated:\n+  \/\/    [-----a------][-----b-----][--------------c------------------]\n+  \/\/            [---- card table memory range --------------]\n+  \/\/\n+  \/\/ Before any objects are allocated, this card's memory range holds no objects.  Note that:\n+  \/\/   allocation of object a wants to set the has-object, first-start, and last-start attributes of the preceding card region.\n+  \/\/   allocation of object b wants to set the has-object, first-start, and last-start attributes of this card region.\n+  \/\/   allocation of object c also wants to set the has-object, first-start, and last-start attributes of this card region.\n+  \/\/\n+  \/\/ The thread allocating b and the thread allocating c can \"race\" in various ways, resulting in confusion, such as last-start\n+  \/\/ representing object b while first-start represents object c.  This is why we need to require all register_object()\n+  \/\/ invocations associated with objects that are allocated from \"free lists\" to provide their own mutual exclusion locking\n+  \/\/ mechanism.\n+\n+  \/\/ Reset the starts_object() information to false for all cards in the range between from and to.\n+  void reset_object_range(HeapWord *from, HeapWord *to);\n+\n+  \/\/ register_object() requires that the caller hold the heap lock\n+  \/\/ before calling it.\n+  void register_object(HeapWord* address);\n+\n+  \/\/ register_object_without_lock() does not require that the caller hold\n+  \/\/ the heap lock before calling it, under the assumption that the\n+  \/\/ caller has assure no other thread will endeavor to concurrently\n+  \/\/ register objects that start within the same card's memory region\n+  \/\/ as address.\n+  void register_object_without_lock(HeapWord* address);\n+\n+  \/\/ During the reference updates phase of GC, we walk through each old-gen memory region that was\n+  \/\/ not part of the collection set and we invalidate all unmarked objects.  As part of this effort,\n+  \/\/ we coalesce neighboring dead objects in order to make future remembered set scanning more\n+  \/\/ efficient (since future remembered set scanning of any card region containing consecutive\n+  \/\/ dead objects can skip over all of them at once by reading only a single dead object header\n+  \/\/ instead of having to read the header of each of the coalesced dead objects.\n+  \/\/\n+  \/\/ At some future time, we may implement a further optimization: satisfy future allocation requests\n+  \/\/ by carving new objects out of the range of memory that represents the coalesced dead objects.\n+  \/\/\n+  \/\/ Suppose we want to combine several dead objects into a single coalesced object.  How does this\n+  \/\/ impact our representation of crossing map information?\n+  \/\/  1. If the newly coalesced range is contained entirely within a card range, that card's last\n+  \/\/     start entry either remains the same or it is changed to the start of the coalesced region.\n+  \/\/  2. For the card that holds the start of the coalesced object, it will not impact the first start\n+  \/\/     but it may impact the last start.\n+  \/\/  3. For following cards spanned entirely by the newly coalesced object, it will change starts_object\n+  \/\/     to false (and make first-start and last-start \"undefined\").\n+  \/\/  4. For a following card that is spanned patially by the newly coalesced object, it may change\n+  \/\/     first-start value, but it will not change the last-start value.\n+  \/\/\n+  \/\/ The range of addresses represented by the arguments to coalesce_objects() must represent a range\n+  \/\/ of memory that was previously occupied exactly by one or more previously registered objects.  For\n+  \/\/ convenience, it is legal to invoke coalesce_objects() with arguments that span a single previously\n+  \/\/ registered object.\n+  \/\/\n+  \/\/ The role of coalesce_objects is to change the crossing map information associated with all of the coalesced\n+  \/\/ objects.\n+  void coalesce_objects(HeapWord* address, size_t length_in_words);\n+\n+  \/\/ The typical use case is going to look something like this:\n+  \/\/   for each heapregion that comprises old-gen memory\n+  \/\/     for each card number that corresponds to this heap region\n+  \/\/       scan the objects contained therein if the card is dirty\n+  \/\/ To avoid excessive lookups in a sparse array, the API queries\n+  \/\/ the card number pertaining to a particular address and then uses the\n+  \/\/ card number for subsequent information lookups and stores.\n+\n+  \/\/ If starts_object(card_index), this returns the word offset within this card\n+  \/\/ memory at which the first object begins.  If !starts_object(card_index), the\n+  \/\/ result is a don't care value -- asserts in a debug build.\n+  size_t get_first_start(size_t card_index) const;\n+\n+  \/\/ If starts_object(card_index), this returns the word offset within this card\n+  \/\/ memory at which the last object begins.  If !starts_object(card_index), the\n+  \/\/ result is a don't care value.\n+  size_t get_last_start(size_t card_index) const;\n+\n+\n+  \/\/ Given a card_index, return the starting address of the first block in the heap\n+  \/\/ that straddles into the card. If the card is co-initial with an object, then\n+  \/\/ this would return the starting address of the heap that this card covers.\n+  \/\/ Expects to be called for a card affiliated with the old generation in\n+  \/\/ generational mode.\n+  HeapWord* block_start(size_t card_index) const;\n+};\n+\n+\/\/ ShenandoahScanRemembered is a concrete class representing the\n+\/\/ ability to scan the old-gen remembered set for references to\n+\/\/ objects residing in young-gen memory.\n+\/\/\n+\/\/ Scanning normally begins with an invocation of numRegions and ends\n+\/\/ after all clusters of all regions have been scanned.\n+\/\/\n+\/\/ Throughout the scanning effort, the number of regions does not\n+\/\/ change.\n+\/\/\n+\/\/ Even though the regions that comprise old-gen memory are not\n+\/\/ necessarily contiguous, the abstraction represented by this class\n+\/\/ identifies each of the old-gen regions with an integer value\n+\/\/ in the range from 0 to (numRegions() - 1) inclusive.\n+\/\/\n+\n+template<typename RememberedSet>\n+class ShenandoahScanRemembered: public CHeapObj<mtGC> {\n+\n+private:\n+  RememberedSet* _rs;\n+  ShenandoahCardCluster<RememberedSet>* _scc;\n+\n+  \/\/ Global card stats (cumulative)\n+  HdrSeq _card_stats_scan_rs[MAX_CARD_STAT_TYPE];\n+  HdrSeq _card_stats_update_refs[MAX_CARD_STAT_TYPE];\n+  \/\/ Per worker card stats (multiplexed by phase)\n+  HdrSeq** _card_stats;\n+\n+  \/\/ The types of card metrics that we gather\n+  const char* _card_stats_name[MAX_CARD_STAT_TYPE] = {\n+   \"dirty_run\", \"clean_run\",\n+   \"dirty_cards\", \"clean_cards\",\n+   \"max_dirty_run\", \"max_clean_run\",\n+   \"dirty_scan_objs\",\n+   \"alternations\"\n+  };\n+\n+  \/\/ The statistics are collected and logged separately for\n+  \/\/ card-scans for initial marking, and for updating refs.\n+  const char* _card_stat_log_type[MAX_CARD_STAT_LOG_TYPE] = {\n+   \"Scan Remembered Set\", \"Update Refs\"\n+  };\n+\n+  int _card_stats_log_counter[2] = {0, 0};\n+\n+public:\n+  \/\/ How to instantiate this object?\n+  \/\/   ShenandoahDirectCardMarkRememberedSet *rs =\n+  \/\/       new ShenandoahDirectCardMarkRememberedSet();\n+  \/\/   scr = new\n+  \/\/     ShenandoahScanRememberd<ShenandoahDirectCardMarkRememberedSet>(rs);\n+  \/\/\n+  \/\/ or, after the planned implementation of\n+  \/\/ ShenandoahBufferWithSATBRememberedSet has been completed:\n+  \/\/\n+  \/\/   ShenandoahBufferWithSATBRememberedSet *rs =\n+  \/\/       new ShenandoahBufferWithSATBRememberedSet();\n+  \/\/   scr = new\n+  \/\/     ShenandoahScanRememberd<ShenandoahBufferWithSATBRememberedSet>(rs);\n+\n+\n+  ShenandoahScanRemembered(RememberedSet *rs) {\n+    _rs = rs;\n+    _scc = new ShenandoahCardCluster<RememberedSet>(rs);\n+\n+    \/\/ We allocate ParallelGCThreads worth even though we usually only\n+    \/\/ use up to ConcGCThreads, because degenerate collections may employ\n+    \/\/ ParallelGCThreads for remembered set scanning.\n+    if (ShenandoahEnableCardStats) {\n+      _card_stats = NEW_C_HEAP_ARRAY(HdrSeq*, ParallelGCThreads, mtGC);\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        _card_stats[i] = new HdrSeq[MAX_CARD_STAT_TYPE];\n+      }\n+    } else {\n+      _card_stats = nullptr;\n+    }\n+  }\n+\n+  ~ShenandoahScanRemembered() {\n+    delete _scc;\n+    if (ShenandoahEnableCardStats) {\n+      for (uint i = 0; i < ParallelGCThreads; i++) {\n+        delete _card_stats[i];\n+      }\n+      FREE_C_HEAP_ARRAY(HdrSeq*, _card_stats);\n+      _card_stats = nullptr;\n+    }\n+    assert(_card_stats == nullptr, \"Error\");\n+  }\n+\n+  HdrSeq* card_stats(uint worker_id) {\n+    assert(worker_id < ParallelGCThreads, \"Error\");\n+    assert(ShenandoahEnableCardStats == (_card_stats != nullptr), \"Error\");\n+    return ShenandoahEnableCardStats ? _card_stats[worker_id] : nullptr;\n+  }\n+\n+  HdrSeq* card_stats_for_phase(CardStatLogType t) {\n+    switch (t) {\n+      case CARD_STAT_SCAN_RS:\n+        return _card_stats_scan_rs;\n+      case CARD_STAT_UPDATE_REFS:\n+        return _card_stats_update_refs;\n+      default:\n+        guarantee(false, \"No such CardStatLogType\");\n+    }\n+    return nullptr; \/\/ Quiet compiler\n+  }\n+\n+  \/\/ TODO:  We really don't want to share all of these APIs with arbitrary consumers of the ShenandoahScanRemembered abstraction.\n+  \/\/ But in the spirit of quick and dirty for the time being, I'm going to go ahead and publish everything for right now.  Some\n+  \/\/ of existing code already depends on having access to these services (because existing code has not been written to honor\n+  \/\/ full abstraction of remembered set scanning.  In the not too distant future, we want to try to make most, if not all, of\n+  \/\/ these services private.  Two problems with publicizing:\n+  \/\/  1. Allowing arbitrary users to reach beneath the hood allows the users to make assumptions about underlying implementation.\n+  \/\/     This will make it more difficult to change underlying implementation at a future time, such as when we eventually experiment\n+  \/\/     with SATB-based implementation of remembered set representation.\n+  \/\/  2. If we carefully control sharing of certain of these services, we can reduce the overhead of synchronization by assuring\n+  \/\/     that all users follow protocols that avoid contention that might require synchronization.  When we publish these APIs, we\n+  \/\/     lose control over who and how the data is accessed.  As a result, we are required to insert more defensive measures into\n+  \/\/     the implementation, including synchronization locks.\n+\n+\n+  \/\/ Card index is zero-based relative to first spanned card region.\n+  size_t last_valid_index();\n+  size_t total_cards();\n+  size_t card_index_for_addr(HeapWord *p);\n+  HeapWord *addr_for_card_index(size_t card_index);\n+  bool is_card_dirty(size_t card_index);\n+  bool is_write_card_dirty(size_t card_index) { return _rs->is_write_card_dirty(card_index); }\n+  void mark_card_as_dirty(size_t card_index);\n+  void mark_range_as_dirty(size_t card_index, size_t num_cards);\n+  void mark_card_as_clean(size_t card_index);\n+  void mark_read_card_as_clean(size_t card_index) { _rs->mark_read_card_clean(card_index); }\n+  void mark_range_as_clean(size_t card_index, size_t num_cards);\n+  bool is_card_dirty(HeapWord *p);\n+  void mark_card_as_dirty(HeapWord *p);\n+  void mark_range_as_dirty(HeapWord *p, size_t num_heap_words);\n+  void mark_card_as_clean(HeapWord *p);\n+  void mark_range_as_clean(HeapWord *p, size_t num_heap_words);\n+  size_t cluster_count();\n+\n+  \/\/ Called by GC thread at start of concurrent mark to exchange roles of read and write remembered sets.\n+  void swap_remset() { _rs->swap_remset(); }\n+\n+  void reset_remset(HeapWord* start, size_t word_count) { _rs->reset_remset(start, word_count); }\n+\n+  void merge_write_table(HeapWord* start, size_t word_count) { _rs->merge_write_table(start, word_count); }\n+\n+  \/\/ Called by GC thread after scanning old remembered set in order to prepare for next GC pass\n+  void clear_old_remset() { _rs->clear_old_remset(); }\n+\n+  size_t cluster_for_addr(HeapWord *addr);\n+  HeapWord* addr_for_cluster(size_t cluster_no);\n+\n+  void reset_object_range(HeapWord *from, HeapWord *to);\n+  void register_object(HeapWord *addr);\n+  void register_object_without_lock(HeapWord *addr);\n+  void coalesce_objects(HeapWord *addr, size_t length_in_words);\n+\n+  HeapWord* first_object_in_card(size_t card_index) {\n+    if (_scc->starts_object(card_index)) {\n+      return addr_for_card_index(card_index) + _scc->get_first_start(card_index);\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+  \/\/ Return true iff this object is \"properly\" registered.\n+  bool verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx);\n+\n+  \/\/ clear the cards to clean, and clear the object_starts info to no objects\n+  void mark_range_as_empty(HeapWord *addr, size_t length_in_words);\n+\n+  \/\/ process_clusters() scans a portion of the remembered set\n+  \/\/ for references from old gen into young. Several worker threads\n+  \/\/ scan different portions of the remembered set by making parallel invocations\n+  \/\/ of process_clusters() with each invocation scanning different\n+  \/\/ \"clusters\" of the remembered set.\n+  \/\/\n+  \/\/ An invocation of process_clusters() examines all of the\n+  \/\/ intergenerational references spanned by `count` clusters starting\n+  \/\/ with `first_cluster`.  The `oops` argument is a worker-thread-local\n+  \/\/ OopClosure that is applied to all \"valid\" references in the remembered set.\n+  \/\/\n+  \/\/ A side-effect of executing process_clusters() is to update the remembered\n+  \/\/ set entries (e.g. marking dirty cards clean if they no longer\n+  \/\/ hold references to young-gen memory).\n+  \/\/\n+  \/\/ An implementation of process_clusters() may choose to efficiently\n+  \/\/ address more typical scenarios in the structure of remembered sets. E.g.\n+  \/\/ in the generational setting, one might expect remembered sets to be very sparse\n+  \/\/ (low mutation rates in the old generation leading to sparse dirty cards,\n+  \/\/ each with very few intergenerational pointers). Specific implementations\n+  \/\/ may choose to degrade gracefully as the sparsity assumption fails to hold,\n+  \/\/ such as when there are sudden spikes in (premature) promotion or in the\n+  \/\/ case of an underprovisioned, poorly-tuned, or poorly-shaped heap.\n+  \/\/\n+  \/\/ At the start of a concurrent young generation marking cycle, we invoke process_clusters\n+  \/\/ with ClosureType ShenandoahInitMarkRootsClosure.\n+  \/\/\n+  \/\/ At the start of a concurrent evacuation phase, we invoke process_clusters with\n+  \/\/ ClosureType ShenandoahEvacuateUpdateRootsClosure.\n+\n+  \/\/ All template expansions require methods to be defined in the inline.hpp file, but larger\n+  \/\/ such methods need not be declared as inline.\n+  template <typename ClosureType>\n+  void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops,\n+                               bool use_write_table, uint worker_id);\n+\n+  template <typename ClosureType>\n+  inline void process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+                                         HeapWord *end_of_range, ClosureType *oops, bool use_write_table);\n+\n+  template <typename ClosureType>\n+  inline void process_region_slice(ShenandoahHeapRegion* region, size_t offset, size_t clusters, HeapWord* end_of_range,\n+                                   ClosureType *cl, bool use_write_table, uint worker_id);\n+\n+  \/\/ To Do:\n+  \/\/  Create subclasses of ShenandoahInitMarkRootsClosure and\n+  \/\/  ShenandoahEvacuateUpdateRootsClosure and any other closures\n+  \/\/  that need to participate in remembered set scanning.  Within the\n+  \/\/  subclasses, add a (probably templated) instance variable that\n+  \/\/  refers to the associated ShenandoahCardCluster object.  Use this\n+  \/\/  ShenandoahCardCluster instance to \"enhance\" the do_oops\n+  \/\/  processing so that we can:\n+  \/\/\n+  \/\/   1. Avoid processing references that correspond to clean card\n+  \/\/      regions, and\n+  \/\/   2. Set card status to CLEAN when the associated card region no\n+  \/\/      longer holds inter-generatioanal references.\n+  \/\/\n+  \/\/  To enable efficient implementation of these behaviors, we\n+  \/\/  probably also want to add a few fields into the\n+  \/\/  ShenandoahCardCluster object that allow us to precompute and\n+  \/\/  remember the addresses at which card status is going to change\n+  \/\/  from dirty to clean and clean to dirty.  The do_oops\n+  \/\/  implementations will want to update this value each time they\n+  \/\/  cross one of these boundaries.\n+  void roots_do(OopIterateClosure* cl);\n+\n+  \/\/ Log stats related to card\/RS stats for given phase t\n+  void log_card_stats(uint nworkers, CardStatLogType t) PRODUCT_RETURN;\n+private:\n+  \/\/ Log stats for given worker id related into given summary card\/RS stats\n+  void log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) PRODUCT_RETURN;\n+\n+  \/\/ Log given stats\n+  inline void log_card_stats(HdrSeq* stats) PRODUCT_RETURN;\n+\n+  \/\/ Merge the stats from worked_id into the given summary stats, and clear the worker_id's stats.\n+  void merge_worker_card_stats_cumulative(HdrSeq* worker_stats, HdrSeq* sum_stats) PRODUCT_RETURN;\n+};\n+\n+\n+\/\/ A ShenandoahRegionChunk represents a contiguous interval of a ShenandoahHeapRegion, typically representing\n+\/\/ work to be done by a worker thread.\n+struct ShenandoahRegionChunk {\n+  ShenandoahHeapRegion *_r;      \/\/ The region of which this represents a chunk\n+  size_t _chunk_offset;          \/\/ HeapWordSize offset\n+  size_t _chunk_size;            \/\/ HeapWordSize qty\n+};\n+\n+\/\/ ShenandoahRegionChunkIterator divides the total remembered set scanning effort into ShenandoahRegionChunks\n+\/\/ that are assigned one at a time to worker threads. (Here, we use the terms `assignments` and `chunks`\n+\/\/ interchangeably.) Note that the effort required to scan a range of memory is not necessarily a linear\n+\/\/ function of the size of the range.  Some memory ranges hold only a small number of live objects.\n+\/\/ Some ranges hold primarily primitive (non-pointer) data.  We start with larger chunk sizes because larger chunks\n+\/\/ reduce coordination overhead.  We expect that the GC worker threads that receive more difficult assignments\n+\/\/ will work longer on those chunks.  Meanwhile, other worker will threads repeatedly accept and complete multiple\n+\/\/ easier chunks.  As the total amount of work remaining to be completed decreases, we decrease the size of chunks\n+\/\/ given to individual threads.  This reduces the likelihood of significant imbalance between worker thread assignments\n+\/\/ when there is less meaningful work to be performed by the remaining worker threads while they wait for\n+\/\/ worker threads with difficult assignments to finish, reducing the overall duration of the phase.\n+\n+class ShenandoahRegionChunkIterator : public StackObj {\n+private:\n+  \/\/ The largest chunk size is 4 MiB, measured in words.  Otherwise, remembered set scanning may become too unbalanced.\n+  \/\/ If the largest chunk size is too small, there is too much overhead sifting out assignments to individual worker threads.\n+  static const size_t _maximum_chunk_size_words = (4 * 1024 * 1024) \/ HeapWordSize;\n+\n+  static const size_t _clusters_in_smallest_chunk = 4;\n+\n+  \/\/ smallest_chunk_size is 4 clusters.  Each cluster spans 128 KiB.\n+  \/\/ This is computed from CardTable::card_size_in_words() *\n+  \/\/      ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  static const size_t smallest_chunk_size_words() {\n+      return _clusters_in_smallest_chunk * CardTable::card_size_in_words() *\n+             ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  }\n+\n+  \/\/ The total remembered set scanning effort is divided into chunks of work that are assigned to individual worker tasks.\n+  \/\/ The chunks of assigned work are divided into groups, where the size of the typical group (_regular_group_size) is half the\n+  \/\/ total number of regions.  The first group may be larger than\n+  \/\/ _regular_group_size in the case that the first group's chunk\n+  \/\/ size is less than the region size.  The last group may be larger\n+  \/\/ than _regular_group_size because no group is allowed to\n+  \/\/ have smaller assignments than _smallest_chunk_size, which is 128 KB.\n+\n+  \/\/ Under normal circumstances, no configuration needs more than _maximum_groups (default value of 16).\n+  \/\/ The first group \"effectively\" processes chunks of size 1 MiB (or smaller for smaller region sizes).\n+  \/\/ The last group processes chunks of size 128 KiB.  There are four groups total.\n+\n+  \/\/ group[0] is 4 MiB chunk size (_maximum_chunk_size_words)\n+  \/\/ group[1] is 2 MiB chunk size\n+  \/\/ group[2] is 1 MiB chunk size\n+  \/\/ group[3] is 512 KiB chunk size\n+  \/\/ group[4] is 256 KiB chunk size\n+  \/\/ group[5] is 128 Kib shunk size (_smallest_chunk_size_words = 4 * 64 * 64\n+  static const size_t _maximum_groups = 6;\n+\n+  const ShenandoahHeap* _heap;\n+\n+  const size_t _regular_group_size;                        \/\/ Number of chunks in each group\n+  const size_t _first_group_chunk_size_b4_rebalance;\n+  const size_t _num_groups;                        \/\/ Number of groups in this configuration\n+  const size_t _total_chunks;\n+\n+  shenandoah_padding(0);\n+  volatile size_t _index;\n+  shenandoah_padding(1);\n+\n+  size_t _region_index[_maximum_groups];           \/\/ The region index for the first region spanned by this group\n+  size_t _group_offset[_maximum_groups];           \/\/ The offset at which group begins within first region spanned by this group\n+  size_t _group_chunk_size[_maximum_groups];       \/\/ The size of each chunk within this group\n+  size_t _group_entries[_maximum_groups];          \/\/ Total chunks spanned by this group and the ones before it.\n+\n+  \/\/ No implicit copying: iterators should be passed by reference to capture the state\n+  NONCOPYABLE(ShenandoahRegionChunkIterator);\n+\n+  \/\/ Makes use of _heap.\n+  size_t calc_regular_group_size();\n+\n+  \/\/ Makes use of _regular_group_size, which must be initialized before call.\n+  size_t calc_first_group_chunk_size_b4_rebalance();\n+\n+  \/\/ Makes use of _regular_group_size and _first_group_chunk_size_b4_rebalance, both of which must be initialized before call.\n+  size_t calc_num_groups();\n+\n+  \/\/ Makes use of _regular_group_size, _first_group_chunk_size_b4_rebalance, which must be initialized before call.\n+  size_t calc_total_chunks();\n+\n+public:\n+  ShenandoahRegionChunkIterator(size_t worker_count);\n+  ShenandoahRegionChunkIterator(ShenandoahHeap* heap, size_t worker_count);\n+\n+  \/\/ Reset iterator to default state\n+  void reset();\n+\n+  \/\/ Fills in assignment with next chunk of work and returns true iff there is more work.\n+  \/\/ Otherwise, returns false.  This is multi-thread-safe.\n+  inline bool next(struct ShenandoahRegionChunk *assignment);\n+\n+  \/\/ This is *not* MT safe. However, in the absence of multithreaded access, it\n+  \/\/ can be used to determine if there is more work to do.\n+  inline bool has_next() const;\n+};\n+\n+typedef ShenandoahScanRemembered<ShenandoahDirectCardMarkRememberedSet> RememberedScanner;\n+\n+class ShenandoahScanRememberedTask : public WorkerTask {\n+ private:\n+  ShenandoahObjToScanQueueSet* _queue_set;\n+  ShenandoahObjToScanQueueSet* _old_queue_set;\n+  ShenandoahReferenceProcessor* _rp;\n+  ShenandoahRegionChunkIterator* _work_list;\n+  bool _is_concurrent;\n+\n+ public:\n+  ShenandoahScanRememberedTask(ShenandoahObjToScanQueueSet* queue_set,\n+                               ShenandoahObjToScanQueueSet* old_queue_set,\n+                               ShenandoahReferenceProcessor* rp,\n+                               ShenandoahRegionChunkIterator* work_list,\n+                               bool is_concurrent);\n+\n+  void work(uint worker_id);\n+  void do_work(uint worker_id);\n+};\n+\n+\/\/ Verify that the oop doesn't point into the young generation\n+class ShenandoahVerifyNoYoungRefsClosure: public BasicOopIterateClosure {\n+  ShenandoahHeap* _heap;\n+  template<class T> void work(T* p);\n+\n+ public:\n+  ShenandoahVerifyNoYoungRefsClosure();\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBERED_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":1083,"deletions":0,"binary":false,"changes":1083,"status":"added"},{"patch":"@@ -0,0 +1,1027 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"gc\/shared\/collectorCounters.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardStats.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCardTable.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahScanRemembered.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+\n+inline size_t\n+ShenandoahDirectCardMarkRememberedSet::last_valid_index() const {\n+  return _card_table->last_valid_index();\n+}\n+\n+inline size_t\n+ShenandoahDirectCardMarkRememberedSet::total_cards() const {\n+  return _total_card_count;\n+}\n+\n+inline size_t\n+ShenandoahDirectCardMarkRememberedSet::card_index_for_addr(HeapWord *p) const {\n+  return _card_table->index_for(p);\n+}\n+\n+inline HeapWord*\n+ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(size_t card_index) const {\n+  return _whole_heap_base + CardTable::card_size_in_words() * card_index;\n+}\n+\n+inline const CardValue*\n+ShenandoahDirectCardMarkRememberedSet::get_card_table_byte_map(bool use_write_table) const {\n+  return use_write_table ?\n+           _card_table->write_byte_map()\n+           : _card_table->read_byte_map();\n+}\n+\n+inline bool\n+ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+inline bool\n+ShenandoahDirectCardMarkRememberedSet::is_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->read_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+inline bool\n+ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord *p) const {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->read_byte_map())[index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord *p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to dirty last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord *p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_read_card_as_clean(size_t index) {\n+  CardValue* bp = &(_card_table->read_byte_map())[index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+inline void\n+ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to clean last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+inline size_t\n+ShenandoahDirectCardMarkRememberedSet::cluster_count() const {\n+  return _cluster_count;\n+}\n+\n+\/\/ No lock required because arguments align with card boundaries.\n+template<typename RememberedSet>\n+inline void\n+ShenandoahCardCluster<RememberedSet>::reset_object_range(HeapWord* from, HeapWord* to) {\n+  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n+         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n+         \"reset_object_range bounds must align with card boundaries\");\n+  size_t card_at_start = _rs->card_index_for_addr(from);\n+  size_t num_cards = (to - from) \/ CardTable::card_size_in_words();\n+\n+  for (size_t i = 0; i < num_cards; i++) {\n+    object_starts[card_at_start + i].short_word = 0;\n+  }\n+}\n+\n+\/\/ Assume only one thread at a time registers objects pertaining to\n+\/\/ each card-table entry's range of memory.\n+template<typename RememberedSet>\n+inline void\n+ShenandoahCardCluster<RememberedSet>::register_object(HeapWord* address) {\n+  shenandoah_assert_heaplocked();\n+\n+  register_object_without_lock(address);\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahCardCluster<RememberedSet>::register_object_without_lock(HeapWord* address) {\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  uint8_t offset_in_card = address - card_start_address;\n+\n+  if (!starts_object(card_at_start)) {\n+    set_starts_object_bit(card_at_start);\n+    set_first_start(card_at_start, offset_in_card);\n+    set_last_start(card_at_start, offset_in_card);\n+  } else {\n+    if (offset_in_card < get_first_start(card_at_start))\n+      set_first_start(card_at_start, offset_in_card);\n+    if (offset_in_card > get_last_start(card_at_start))\n+      set_last_start(card_at_start, offset_in_card);\n+  }\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahCardCluster<RememberedSet>::coalesce_objects(HeapWord* address, size_t length_in_words) {\n+\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words();\n+\n+  if (card_at_start == card_at_end) {\n+    \/\/ There are no changes to the get_first_start array.  Either get_first_start(card_at_start) returns this coalesced object,\n+    \/\/ or it returns an object that precedes the coalesced object.\n+    if (card_start_address + get_last_start(card_at_start) < address + length_in_words) {\n+      uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+      \/\/ The object that used to be the last object starting within this card is being subsumed within the coalesced\n+      \/\/ object.  Since we always coalesce entire objects, this condition only occurs if the last object ends before or at\n+      \/\/ the end of the card's memory range and there is no object following this object.  In this case, adjust last_start\n+      \/\/ to represent the start of the coalesced range.\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ Else, no changes to last_starts information.  Either get_last_start(card_at_start) returns the object that immediately\n+    \/\/ follows the coalesced object, or it returns an object that follows the object immediately following the coalesced object.\n+  } else {\n+    uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+    if (get_last_start(card_at_start) > coalesced_offset) {\n+      \/\/ Existing last start is being coalesced, create new last start\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ otherwise, get_last_start(card_at_start) must equal coalesced_offset\n+\n+    \/\/ All the cards between first and last get cleared.\n+    for (size_t i = card_at_start + 1; i < card_at_end; i++) {\n+      clear_starts_object_bit(i);\n+    }\n+\n+    uint8_t follow_offset = static_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n+    if (starts_object(card_at_end) && (get_first_start(card_at_end) < follow_offset)) {\n+      \/\/ It may be that after coalescing within this last card's memory range, the last card\n+      \/\/ no longer holds an object.\n+      if (get_last_start(card_at_end) >= follow_offset) {\n+        set_first_start(card_at_end, follow_offset);\n+      } else {\n+        \/\/ last_start is being coalesced so this card no longer has any objects.\n+        clear_starts_object_bit(card_at_end);\n+      }\n+    }\n+    \/\/ else\n+    \/\/  card_at_end did not have an object, so it still does not have an object, or\n+    \/\/  card_at_end had an object that starts after the coalesced object, so no changes required for card_at_end\n+\n+  }\n+}\n+\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahCardCluster<RememberedSet>::get_first_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get first start because no object starts here\");\n+  return object_starts[card_index].offsets.first & FirstStartBits;\n+}\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahCardCluster<RememberedSet>::get_last_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get last start because no object starts here\");\n+  return object_starts[card_index].offsets.last;\n+}\n+\n+\/\/ Given a card_index, return the starting address of the first block in the heap\n+\/\/ that straddles into this card. If this card is co-initial with an object, then\n+\/\/ this would return the first address of the range that this card covers, which is\n+\/\/ where the card's first object also begins.\n+\/\/ TODO: collect some stats for the size of walks backward over cards.\n+\/\/ For larger objects, a logarithmic BOT such as used by G1 might make the\n+\/\/ backwards walk potentially faster.\n+template<typename RememberedSet>\n+HeapWord*\n+ShenandoahCardCluster<RememberedSet>::block_start(const size_t card_index) const {\n+\n+  HeapWord* left = _rs->addr_for_card_index(card_index);\n+\n+#ifdef ASSERT\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Do not use in non-generational mode\");\n+  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n+  assert(region->is_old(), \"Do not use for young regions\");\n+  \/\/ For HumongousRegion:s it's more efficient to jump directly to the\n+  \/\/ start region.\n+  assert(!region->is_humongous(), \"Use region->humongous_start_region() instead\");\n+#endif\n+  if (starts_object(card_index) && get_first_start(card_index) == 0) {\n+    \/\/ This card contains a co-initial object; a fortiori, it covers\n+    \/\/ also the case of a card being the first in a region.\n+    assert(oopDesc::is_oop(cast_to_oop(left)), \"Should be an object\");\n+    return left;\n+  }\n+\n+  HeapWord* p = nullptr;\n+  oop obj = cast_to_oop(p);\n+  ssize_t cur_index = (ssize_t)card_index;\n+  assert(cur_index >= 0, \"Overflow\");\n+  assert(cur_index > 0, \"Should have returned above\");\n+  \/\/ Walk backwards over the cards...\n+  while (--cur_index > 0 && !starts_object(cur_index)) {\n+   \/\/ ... to the one that starts the object\n+  }\n+  \/\/ cur_index should start an object: we should not have walked\n+  \/\/ past the left end of the region.\n+  assert(cur_index >= 0 && (cur_index <= (ssize_t)card_index), \"Error\");\n+  assert(region->bottom() <= _rs->addr_for_card_index(cur_index),\n+         \"Fell off the bottom of containing region\");\n+  assert(starts_object(cur_index), \"Error\");\n+  size_t offset = get_last_start(cur_index);\n+  \/\/ can avoid call via card size arithmetic below instead\n+  p = _rs->addr_for_card_index(cur_index) + offset;\n+  \/\/ Recall that we already dealt with the co-initial object case above\n+  assert(p < left, \"obj should start before left\");\n+  \/\/ While it is safe to ask an object its size in the loop that\n+  \/\/ follows, the (ifdef'd out) loop should never be needed.\n+  \/\/ 1. we ask this question only for regions in the old generation\n+  \/\/ 2. there is no direct allocation ever by mutators in old generation\n+  \/\/    regions. Only GC will ever allocate in old regions, and then\n+  \/\/    too only during promotion\/evacuation phases. Thus there is no danger\n+  \/\/    of races between reading from and writing to the object start array,\n+  \/\/    or of asking partially initialized objects their size (in the loop below).\n+  \/\/ 3. only GC asks this question during phases when it is not concurrently\n+  \/\/    evacuating\/promoting, viz. during concurrent root scanning (before\n+  \/\/    the evacuation phase) and during concurrent update refs (after the\n+  \/\/    evacuation phase) of young collections. This is never called\n+  \/\/    during old or global collections.\n+  \/\/ 4. Every allocation under TAMS updates the object start array.\n+  NOT_PRODUCT(obj = cast_to_oop(p);)\n+  assert(oopDesc::is_oop(obj), \"Should be an object\");\n+#define WALK_FORWARD_IN_BLOCK_START false\n+  while (WALK_FORWARD_IN_BLOCK_START && p + obj->size() < left) {\n+    p += obj->size();\n+  }\n+#undef WALK_FORWARD_IN_BLOCK_START \/\/ false\n+  assert(p + obj->size() > left, \"obj should end after left\");\n+  return p;\n+}\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::last_valid_index() { return _rs->last_valid_index(); }\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::total_cards() { return _rs->total_cards(); }\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::card_index_for_addr(HeapWord *p) { return _rs->card_index_for_addr(p); };\n+\n+template<typename RememberedSet>\n+inline HeapWord *\n+ShenandoahScanRemembered<RememberedSet>::addr_for_card_index(size_t card_index) { return _rs->addr_for_card_index(card_index); }\n+\n+template<typename RememberedSet>\n+inline bool\n+ShenandoahScanRemembered<RememberedSet>::is_card_dirty(size_t card_index) { return _rs->is_card_dirty(card_index); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(size_t card_index) { _rs->mark_card_as_dirty(card_index); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(size_t card_index, size_t num_cards) { _rs->mark_range_as_dirty(card_index, num_cards); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(size_t card_index) { _rs->mark_card_as_clean(card_index); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_clean(size_t card_index, size_t num_cards) { _rs->mark_range_as_clean(card_index, num_cards); }\n+\n+template<typename RememberedSet>\n+inline bool\n+ShenandoahScanRemembered<RememberedSet>::is_card_dirty(HeapWord *p) { return _rs->is_card_dirty(p); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(HeapWord *p) { _rs->mark_card_as_dirty(p); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) { _rs->mark_range_as_dirty(p, num_heap_words); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(HeapWord *p) { _rs->mark_card_as_clean(p); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>:: mark_range_as_clean(HeapWord *p, size_t num_heap_words) { _rs->mark_range_as_clean(p, num_heap_words); }\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::cluster_count() { return _rs->cluster_count(); }\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::reset_object_range(HeapWord *from, HeapWord *to) {\n+  _scc->reset_object_range(from, to);\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::register_object(HeapWord *addr) {\n+  _scc->register_object(addr);\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::register_object_without_lock(HeapWord *addr) {\n+  _scc->register_object_without_lock(addr);\n+}\n+\n+template <typename RememberedSet>\n+inline bool\n+ShenandoahScanRemembered<RememberedSet>::verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx) {\n+\n+  size_t index = card_index_for_addr(address);\n+  if (!_scc->starts_object(index)) {\n+    return false;\n+  }\n+  HeapWord* base_addr = addr_for_card_index(index);\n+  size_t offset = _scc->get_first_start(index);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ Verify that I can find this object within its enclosing card by scanning forward from first_start.\n+  while (base_addr + offset < address) {\n+    oop obj = cast_to_oop(base_addr + offset);\n+    if (!ctx || ctx->is_marked(obj)) {\n+      offset += obj->size();\n+    } else {\n+      \/\/ If this object is not live, don't trust its size(); all objects above tams are live.\n+      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n+      HeapWord* tams = ctx->top_at_mark_start(r);\n+      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+    }\n+  }\n+  if (base_addr + offset != address){\n+    return false;\n+  }\n+\n+  \/\/ At this point, offset represents object whose registration we are verifying.  We know that at least this object resides\n+  \/\/ within this card's memory.\n+\n+  \/\/ Make sure that last_offset is properly set for the enclosing card, but we can't verify this for\n+  \/\/ candidate collection-set regions during mixed evacuations, so disable this check in general\n+  \/\/ during mixed evacuations.\n+\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n+  size_t max_offset = r->top() - base_addr;\n+  if (max_offset > CardTable::card_size_in_words()) {\n+    max_offset = CardTable::card_size_in_words();\n+  }\n+  size_t prev_offset;\n+  if (!ctx) {\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      prev_offset = offset;\n+      offset += obj->size();\n+    } while (offset < max_offset);\n+    if (_scc->get_last_start(index) != prev_offset) {\n+      return false;\n+    }\n+\n+    \/\/ base + offset represents address of first object that starts on following card, if there is one.\n+\n+    \/\/ Notes: base_addr is addr_for_card_index(index)\n+    \/\/        base_addr + offset is end of the object we are verifying\n+    \/\/        cannot use card_index_for_addr(base_addr + offset) because it asserts arg < end of whole heap\n+    size_t end_card_index = index + offset \/ CardTable::card_size_in_words();\n+\n+    if (end_card_index > index && end_card_index <= _rs->last_valid_index()) {\n+      \/\/ If there is a following object registered on the next card, it should begin where this object ends.\n+      if (_scc->starts_object(end_card_index) &&\n+          ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Assure that no other objects are registered \"inside\" of this one.\n+    for (index++; index < end_card_index; index++) {\n+      if (_scc->starts_object(index)) {\n+        return false;\n+      }\n+    }\n+  } else {\n+    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n+    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n+    \/\/ If the object reaching or spanning the end of this card's memory is marked, then last_offset for this card\n+    \/\/ should represent this object.  Otherwise, last_offset is a don't care.\n+    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n+    HeapWord* tams = ctx->top_at_mark_start(region);\n+    oop last_obj = nullptr;\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      if (ctx->is_marked(obj)) {\n+        prev_offset = offset;\n+        offset += obj->size();\n+        last_obj = obj;\n+      } else {\n+        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+        \/\/ If there are no marked objects remaining in this region, offset equals tams - base_addr.  If this offset is\n+        \/\/ greater than max_offset, we will immediately exit this loop.  Otherwise, the next iteration of the loop will\n+        \/\/ treat the object at offset as marked and live (because address >= tams) and we will continue iterating object\n+        \/\/ by consulting the size() fields of each.\n+      }\n+    } while (offset < max_offset);\n+    if (last_obj != nullptr && prev_offset + last_obj->size() >= max_offset) {\n+      \/\/ last marked object extends beyond end of card\n+      if (_scc->get_last_start(index) != prev_offset) {\n+        return false;\n+      }\n+      \/\/ otherwise, the value of _scc->get_last_start(index) is a don't care because it represents a dead object and we\n+      \/\/ cannot verify its context\n+    }\n+  }\n+  return true;\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::coalesce_objects(HeapWord *addr, size_t length_in_words) {\n+  _scc->coalesce_objects(addr, length_in_words);\n+}\n+\n+template<typename RememberedSet>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::mark_range_as_empty(HeapWord *addr, size_t length_in_words) {\n+  _rs->mark_range_as_clean(addr, length_in_words);\n+  _scc->clear_objects_in_range(addr, length_in_words);\n+}\n+\n+\/\/ Process all objects starting within count clusters beginning with first_cluster and for which the start address is\n+\/\/ less than end_of_range.  For any non-array object whose header lies on a dirty card, scan the entire object,\n+\/\/ even if its end reaches beyond end_of_range. Object arrays, on the other hand, are precisely dirtied and\n+\/\/ only the portions of the array on dirty cards need to be scanned.\n+\/\/\n+\/\/ Do not CANCEL within process_clusters.  It is assumed that if a worker thread accepts responsibility for processing\n+\/\/ a chunk of work, it will finish the work it starts.  Otherwise, the chunk of work will be lost in the transition to\n+\/\/ degenerated execution, leading to dangling references.\n+template<typename RememberedSet>\n+template <typename ClosureType>\n+void ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range,\n+                                                               ClosureType* cl, bool use_write_table, uint worker_id) {\n+\n+  \/\/ If old-gen evacuation is active, then MarkingContext for old-gen heap regions is valid.  We use the MarkingContext\n+  \/\/ bits to determine which objects within a DIRTY card need to be scanned.  This is necessary because old-gen heap\n+  \/\/ regions that are in the candidate collection set have not been coalesced and filled.  Thus, these heap regions\n+  \/\/ may contain zombie objects.  Zombie objects are known to be dead, but have not yet been \"collected\".  Scanning\n+  \/\/ zombie objects is unsafe because the Klass pointer is not reliable, objects referenced from a zombie may have been\n+  \/\/ collected (if dead), or relocated (if live), or if dead but not yet collected, we don't want to \"revive\" them\n+  \/\/ by marking them (when marking) or evacuating them (when updating references).\n+\n+  \/\/ start and end addresses of range of objects to be scanned, clipped to end_of_range\n+  const size_t start_card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  const HeapWord* start_addr = _rs->addr_for_card_index(start_card_index);\n+  \/\/ clip at end_of_range (exclusive)\n+  HeapWord* end_addr = MIN2(end_of_range, (HeapWord*)start_addr + (count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster\n+                                                                   * CardTable::card_size_in_words()));\n+  assert(start_addr < end_addr, \"Empty region?\");\n+\n+  const size_t whole_cards = (end_addr - start_addr + CardTable::card_size_in_words() - 1)\/CardTable::card_size_in_words();\n+  const size_t end_card_index = start_card_index + whole_cards - 1;\n+  log_debug(gc, remset)(\"Worker %u: cluster = \" SIZE_FORMAT \" count = \" SIZE_FORMAT \" eor = \" INTPTR_FORMAT\n+                        \" start_addr = \" INTPTR_FORMAT \" end_addr = \" INTPTR_FORMAT \" cards = \" SIZE_FORMAT,\n+                        worker_id, first_cluster, count, p2i(end_of_range), p2i(start_addr), p2i(end_addr), whole_cards);\n+\n+  \/\/ use_write_table states whether we are using the card table that is being\n+  \/\/ marked by the mutators. If false, we are using a snapshot of the card table\n+  \/\/ that is not subject to modifications. Even when this arg is true, and\n+  \/\/ the card table is being actively marked, SATB marking ensures that we need not\n+  \/\/ worry about cards marked after the processing here has passed them.\n+  const CardValue* const ctbm = _rs->get_card_table_byte_map(use_write_table);\n+\n+  \/\/ If old gen evacuation is active, ctx will hold the completed marking of\n+  \/\/ old generation objects. We'll only scan objects that are marked live by\n+  \/\/ the old generation marking. These include objects allocated since the\n+  \/\/ start of old generation marking (being those above TAMS).\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  const ShenandoahMarkingContext* ctx = heap->is_old_bitmap_stable() ?\n+                                        heap->marking_context() : nullptr;\n+\n+  \/\/ The region we will scan is the half-open interval [start_addr, end_addr),\n+  \/\/ and lies entirely within a single region.\n+  const ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(start_addr);\n+  assert(region->contains(end_addr - 1), \"Slice shouldn't cross regions\");\n+\n+  \/\/ This code may have implicit assumptions of examining only old gen regions.\n+  assert(region->is_old(), \"We only expect to be processing old regions\");\n+  assert(!region->is_humongous(), \"Humongous regions can be processed more efficiently;\"\n+                                  \"see process_humongous_clusters()\");\n+  \/\/ tams and ctx below are for old generation marking. As such, young gen roots must\n+  \/\/ consider everything above tams, since it doesn't represent a TAMS for young gen's\n+  \/\/ SATB marking.\n+  const HeapWord* tams = (ctx == nullptr ? region->bottom() : ctx->top_at_mark_start(region));\n+\n+  NOT_PRODUCT(ShenandoahCardStats stats(whole_cards, card_stats(worker_id));)\n+\n+  \/\/ In the case of imprecise marking, we remember the lowest address\n+  \/\/ scanned in a range of dirty cards, as we work our way left from the\n+  \/\/ highest end_addr. This serves as another upper bound on the address we will\n+  \/\/ scan as we move left over each contiguous range of dirty cards.\n+  HeapWord* upper_bound = nullptr;\n+\n+  \/\/ Starting at the right end of the address range, walk backwards accumulating\n+  \/\/ a maximal dirty range of cards, then process those cards.\n+  ssize_t cur_index = (ssize_t) end_card_index;\n+  assert(cur_index >= 0, \"Overflow\");\n+  assert(((ssize_t)start_card_index) >= 0, \"Overflow\");\n+  while (cur_index >= (ssize_t)start_card_index) {\n+\n+    \/\/ We'll continue the search starting with the card for the upper bound\n+    \/\/ address identified by the last dirty range that we processed, if any,\n+    \/\/ skipping any cards at higher addresses.\n+    if (upper_bound != nullptr) {\n+      ssize_t right_index = _rs->card_index_for_addr(upper_bound);\n+      assert(right_index >= 0, \"Overflow\");\n+      cur_index = MIN2(cur_index, right_index);\n+      assert(upper_bound < end_addr, \"Program logic\");\n+      end_addr  = upper_bound;   \/\/ lower end_addr\n+      upper_bound = nullptr;     \/\/ and clear upper_bound\n+      if (end_addr <= start_addr) {\n+        assert(right_index <= (ssize_t)start_card_index, \"Program logic\");\n+        \/\/ We are done with our cluster\n+        return;\n+      }\n+    }\n+\n+    if (ctbm[cur_index] == CardTable::dirty_card_val()) {\n+      \/\/ ==== BEGIN DIRTY card range processing ====\n+\n+      const size_t dirty_r = cur_index;  \/\/ record right end of dirty range (inclusive)\n+      while (--cur_index >= (ssize_t)start_card_index && ctbm[cur_index] == CardTable::dirty_card_val()) {\n+        \/\/ walk back over contiguous dirty cards to find left end of dirty range (inclusive)\n+      }\n+      \/\/ [dirty_l, dirty_r] is a \"maximal\" closed interval range of dirty card indices:\n+      \/\/ it may not be maximal if we are using the write_table, because of concurrent\n+      \/\/ mutations dirtying the card-table. It may also not be maximal if an upper bound\n+      \/\/ was established by the scan of the previous chunk.\n+      const size_t dirty_l = cur_index + 1;   \/\/ record left end of dirty range (inclusive)\n+      \/\/ Check that we identified a boundary on our left\n+      assert(ctbm[dirty_l] == CardTable::dirty_card_val(), \"First card in range should be dirty\");\n+      assert(dirty_l == start_card_index || use_write_table\n+             || ctbm[dirty_l - 1] == CardTable::clean_card_val(),\n+             \"Interval isn't maximal on the left\");\n+      assert(dirty_r >= dirty_l, \"Error\");\n+      assert(ctbm[dirty_r] == CardTable::dirty_card_val(), \"Last card in range should be dirty\");\n+      \/\/ Record alternations, dirty run length, and dirty card count\n+      NOT_PRODUCT(stats.record_dirty_run(dirty_r - dirty_l + 1);)\n+\n+      \/\/ Find first object that starts this range:\n+      \/\/ [left, right) is a maximal right-open interval of dirty cards\n+      HeapWord* left = _rs->addr_for_card_index(dirty_l);        \/\/ inclusive\n+      HeapWord* right = _rs->addr_for_card_index(dirty_r + 1);   \/\/ exclusive\n+      \/\/ Clip right to end_addr established above (still exclusive)\n+      right = MIN2(right, end_addr);\n+      assert(right <= region->top() && end_addr <= region->top(), \"Busted bounds\");\n+      const MemRegion mr(left, right);\n+\n+      \/\/ NOTE: We'll not call block_start() repeatedly\n+      \/\/ on a very large object if its head card is dirty. If not,\n+      \/\/ (i.e. the head card is clean) we'll call it each time we\n+      \/\/ process a new dirty range on the object. This is always\n+      \/\/ the case for large object arrays, which are typically more\n+      \/\/ common.\n+      \/\/ TODO: It is worthwhile to memoize this, so as to avoid that\n+      \/\/ overhead, and it is easy to do, but deferred to a follow-up.\n+      HeapWord* p = _scc->block_start(dirty_l);\n+      oop obj = cast_to_oop(p);\n+\n+      \/\/ PREFIX: The object that straddles into this range of dirty cards\n+      \/\/ from the left may be subject to special treatment unless\n+      \/\/ it is an object array.\n+      if (p < left && !obj->is_objArray()) {\n+        \/\/ The mutator (both compiler and interpreter, but not JNI?)\n+        \/\/ typically dirty imprecisely (i.e. only the head of an object),\n+        \/\/ but GC closures typically dirty the object precisely. (It would\n+        \/\/ be nice to have everything be precise for maximum efficiency.)\n+        \/\/\n+        \/\/ To handle this, we check the head card of the object here and,\n+        \/\/ if dirty, (arrange to) scan the object in its entirety. If we\n+        \/\/ find the head card clean, we'll scan only the portion of the\n+        \/\/ object lying in the dirty card range below, assuming this was\n+        \/\/ the result of precise marking by GC closures.\n+\n+        \/\/ index of the \"head card\" for p\n+        const size_t hc_index = _rs->card_index_for_addr(p);\n+        if (ctbm[hc_index] == CardTable::dirty_card_val()) {\n+          \/\/ Scan or skip the object, depending on location of its\n+          \/\/ head card, and remember that we'll have processed all\n+          \/\/ the objects back up to p, which is thus an upper bound\n+          \/\/ for the next iteration of a dirty card loop.\n+          upper_bound = p;   \/\/ remember upper bound for next chunk\n+          if (p < start_addr) {\n+            \/\/ if object starts in a previous slice, it'll be handled\n+            \/\/ in its entirety by the thread processing that slice; we can\n+            \/\/ skip over it and avoid an unnecessary extra scan.\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n+            p += obj->size();\n+          } else {\n+            \/\/ the object starts in our slice, we scan it in its entirety\n+            assert(obj == cast_to_oop(p), \"Inconsistency detected\");\n+            if (ctx == nullptr || ctx->is_marked(obj)) {\n+              \/\/ Scan the object in its entirety\n+              p += obj->oop_iterate_size(cl);\n+            } else {\n+              assert(p < tams, \"Error 1 in ctx\/marking\/tams logic\");\n+              \/\/ Skip over any intermediate dead objects\n+              p = ctx->get_next_marked_addr(p, tams);\n+              assert(p <= tams, \"Error 2 in ctx\/marking\/tams logic\");\n+            }\n+          }\n+          assert(p > left, \"Should have processed into interior of dirty range\");\n+        }\n+      }\n+\n+      size_t i = 0;\n+      HeapWord* last_p = nullptr;\n+\n+      \/\/ BODY: Deal with (other) objects in this dirty card range\n+      while (p < right) {\n+        obj = cast_to_oop(p);\n+        \/\/ walk right scanning eligible objects\n+        if (ctx == nullptr || ctx->is_marked(obj)) {\n+          \/\/ we need to remember the last object ptr we scanned, in case we need to\n+          \/\/ complete a partial suffix scan after mr, see below\n+          last_p = p;\n+          \/\/ apply the closure to the oops in the portion of\n+          \/\/ the object within mr.\n+          p += obj->oop_iterate_size(cl, mr);\n+          NOT_PRODUCT(i++);\n+        } else {\n+          \/\/ forget the last object pointer we remembered\n+          last_p = nullptr;\n+          assert(p < tams, \"Tams and above are implicitly marked in ctx\");\n+          \/\/ object under tams isn't marked: skip to next live object\n+          p = ctx->get_next_marked_addr(p, tams);\n+          assert(p <= tams, \"Error 3 in ctx\/marking\/tams logic\");\n+        }\n+      }\n+\n+      \/\/ TODO: if an objArray then only use mr, else just iterate over entire object;\n+      \/\/ that would avoid the special treatment of suffix below.\n+\n+      \/\/ SUFFIX: Fix up a possible incomplete scan at right end of window\n+      \/\/ by scanning the portion of a non-objArray that wasn't done.\n+      if (p > right && last_p != nullptr) {\n+        assert(last_p < right, \"Error\");\n+        \/\/ check if last_p suffix needs scanning\n+        const oop last_obj = cast_to_oop(last_p);\n+        if (!last_obj->is_objArray()) {\n+          \/\/ scan the remaining suffix of the object\n+          const MemRegion last_mr(right, p);\n+          assert(p == last_p + last_obj->size(), \"Would miss portion of last_obj\");\n+          last_obj->oop_iterate(cl, last_mr);\n+          log_debug(gc, remset)(\"Fixed up non-objArray suffix scan in [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \")\",\n+                                p2i(last_mr.start()), p2i(last_mr.end()));\n+        } else {\n+          log_debug(gc, remset)(\"Skipped suffix scan of objArray in [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \")\",\n+                                p2i(right), p2i(p));\n+        }\n+      }\n+      NOT_PRODUCT(stats.record_scan_obj_cnt(i);)\n+\n+      \/\/ ==== END   DIRTY card range processing ====\n+    } else {\n+      \/\/ ==== BEGIN CLEAN card range processing ====\n+\n+      assert(ctbm[cur_index] == CardTable::clean_card_val(), \"Error\");\n+      \/\/ walk back over contiguous clean cards\n+      size_t i = 0;\n+      while (--cur_index >= (ssize_t)start_card_index && ctbm[cur_index] == CardTable::clean_card_val()) {\n+        NOT_PRODUCT(i++);\n+      }\n+      \/\/ Record alternations, clean run length, and clean card count\n+      NOT_PRODUCT(stats.record_clean_run(i);)\n+\n+      \/\/ ==== END CLEAN card range processing ====\n+    }\n+  }\n+}\n+\n+\/\/ Given that this range of clusters is known to span a humongous object spanned by region r, scan the\n+\/\/ portion of the humongous object that corresponds to the specified range.\n+template<typename RememberedSet>\n+template <typename ClosureType>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+                                                                    HeapWord *end_of_range, ClosureType *cl, bool use_write_table) {\n+  ShenandoahHeapRegion* start_region = r->humongous_start_region();\n+  HeapWord* p = start_region->bottom();\n+  oop obj = cast_to_oop(p);\n+  assert(r->is_humongous(), \"Only process humongous regions here\");\n+  assert(start_region->is_humongous_start(), \"Should be start of humongous region\");\n+  assert(p + obj->size() >= end_of_range, \"Humongous object ends before range ends\");\n+\n+  size_t first_card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  HeapWord* first_cluster_addr = _rs->addr_for_card_index(first_card_index);\n+  size_t spanned_words = count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster * CardTable::card_size_in_words();\n+  start_region->oop_iterate_humongous_slice(cl, true, first_cluster_addr, spanned_words, use_write_table);\n+}\n+\n+\n+\/\/ This method takes a region & determines the end of the region that the worker can scan.\n+template<typename RememberedSet>\n+template <typename ClosureType>\n+inline void\n+ShenandoahScanRemembered<RememberedSet>::process_region_slice(ShenandoahHeapRegion *region, size_t start_offset, size_t clusters,\n+                                                              HeapWord *end_of_range, ClosureType *cl, bool use_write_table,\n+                                                              uint worker_id) {\n+\n+  \/\/ This is called only for young gen collection, when we scan old gen regions\n+  assert(region->is_old(), \"Expecting an old region\");\n+  HeapWord *start_of_range = region->bottom() + start_offset;\n+  size_t start_cluster_no = cluster_for_addr(start_of_range);\n+  assert(addr_for_cluster(start_cluster_no) == start_of_range, \"process_region_slice range must align on cluster boundary\");\n+\n+  \/\/ region->end() represents the end of memory spanned by this region, but not all of this\n+  \/\/   memory is eligible to be scanned because some of this memory has not yet been allocated.\n+  \/\/\n+  \/\/ region->top() represents the end of allocated memory within this region.  Any addresses\n+  \/\/   beyond region->top() should not be scanned as that memory does not hold valid objects.\n+\n+  if (use_write_table) {\n+    \/\/ This is update-refs servicing.\n+    if (end_of_range > region->get_update_watermark()) {\n+      end_of_range = region->get_update_watermark();\n+    }\n+  } else {\n+    \/\/ This is concurrent mark servicing.  Note that TAMS for this region is TAMS at start of old-gen\n+    \/\/ collection.  Here, we need to scan up to TAMS for most recently initiated young-gen collection.\n+    \/\/ Since all LABs are retired at init mark, and since replacement LABs are allocated lazily, and since no\n+    \/\/ promotions occur until evacuation phase, TAMS for most recent young-gen is same as top().\n+    if (end_of_range > region->top()) {\n+      end_of_range = region->top();\n+    }\n+  }\n+\n+  log_debug(gc)(\"Remembered set scan processing Region \" SIZE_FORMAT \", from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                region->index(), p2i(start_of_range), p2i(end_of_range),\n+                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n+\n+  \/\/ Note that end_of_range may point to the middle of a cluster because we limit scanning to\n+  \/\/ region->top() or region->get_update_watermark(). We avoid processing past end_of_range.\n+  \/\/ Objects that start between start_of_range and end_of_range, including humongous objects, will\n+  \/\/ be fully processed by process_clusters. In no case should we need to scan past end_of_range.\n+  if (start_of_range < end_of_range) {\n+    if (region->is_humongous()) {\n+      ShenandoahHeapRegion* start_region = region->humongous_start_region();\n+      \/\/ TODO: ysr : This will be called multiple times with same start_region, but different start_cluster_no.\n+      \/\/ Check that it does the right thing here, and doesn't do redundant work. Also see if the call API\/interface\n+      \/\/ can be simplified.\n+      process_humongous_clusters(start_region, start_cluster_no, clusters, end_of_range, cl, use_write_table);\n+    } else {\n+      \/\/ TODO: ysr The start_of_range calculated above is discarded and may be calculated again in process_clusters().\n+      \/\/ See if the redundant and wasted calculations can be avoided, and if the call parameters can be cleaned up.\n+      \/\/ It almost sounds like this set of methods needs a working class to stash away some useful info that can be\n+      \/\/ efficiently passed around amongst these methods, as well as related state. Note that we can't use\n+      \/\/ ShenandoahScanRemembered as there seems to be only one instance of that object for the heap which is shared\n+      \/\/ by all workers. Note that there are also task methods which call these which may have per worker storage.\n+      \/\/ We need to be careful however that if the number of workers changes dynamically that state isn't sequestered\n+      \/\/ and become obsolete.\n+      process_clusters(start_cluster_no, clusters, end_of_range, cl, use_write_table, worker_id);\n+    }\n+  }\n+}\n+\n+template<typename RememberedSet>\n+inline size_t\n+ShenandoahScanRemembered<RememberedSet>::cluster_for_addr(HeapWordImpl **addr) {\n+  size_t card_index = _rs->card_index_for_addr(addr);\n+  size_t result = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  return result;\n+}\n+\n+template<typename RememberedSet>\n+inline HeapWord*\n+ShenandoahScanRemembered<RememberedSet>::addr_for_cluster(size_t cluster_no) {\n+  size_t card_index = cluster_no * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  return addr_for_card_index(card_index);\n+}\n+\n+\/\/ This is used only for debug verification so don't worry about making the scan parallel.\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::roots_do(OopIterateClosure* cl) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (size_t i = 0, n = heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (region->is_old() && region->is_active() && !region->is_cset()) {\n+      HeapWord* start_of_range = region->bottom();\n+      HeapWord* end_of_range = region->top();\n+      size_t start_cluster_no = cluster_for_addr(start_of_range);\n+      size_t num_heapwords = end_of_range - start_of_range;\n+      unsigned int cluster_size = CardTable::card_size_in_words() *\n+                                  ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n+\n+      \/\/ Remembered set scanner\n+      if (region->is_humongous()) {\n+        process_humongous_clusters(region->humongous_start_region(), start_cluster_no, num_clusters, end_of_range, cl,\n+                                   false \/* use_write_table *\/);\n+      } else {\n+        process_clusters(start_cluster_no, num_clusters, end_of_range, cl,\n+                         false \/* use_write_table *\/, 0 \/* fake worker id *\/);\n+      }\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Log given card stats\n+template<typename RememberedSet>\n+inline void ShenandoahScanRemembered<RememberedSet>::log_card_stats(HdrSeq* stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    log_info(gc, remset)(\"%18s: [ %8.2f %8.2f %8.2f %8.2f %8.2f ]\",\n+      _card_stats_name[i],\n+      stats[i].percentile(0), stats[i].percentile(25),\n+      stats[i].percentile(50), stats[i].percentile(75),\n+      stats[i].maximum());\n+  }\n+}\n+\n+\/\/ Log card stats for all nworkers for a specific phase t\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::log_card_stats(uint nworkers, CardStatLogType t) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+  HdrSeq* sum_stats = card_stats_for_phase(t);\n+  log_info(gc, remset)(\"%s\", _card_stat_log_type[t]);\n+  for (uint i = 0; i < nworkers; i++) {\n+    log_worker_card_stats(i, sum_stats);\n+  }\n+\n+  \/\/ Every so often, log the cumulative global stats\n+  if (++_card_stats_log_counter[t] >= ShenandoahCardStatsLogInterval) {\n+    _card_stats_log_counter[t] = 0;\n+    log_info(gc, remset)(\"Cumulative stats\");\n+    log_card_stats(sum_stats);\n+  }\n+}\n+\n+\/\/ Log card stats for given worker_id, & clear them after merging into given cumulative stats\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+\n+  HdrSeq* worker_card_stats = card_stats(worker_id);\n+  log_info(gc, remset)(\"Worker %u Card Stats: \", worker_id);\n+  log_card_stats(worker_card_stats);\n+  \/\/ Merge worker stats into the cumulative stats & clear worker stats\n+  merge_worker_card_stats_cumulative(worker_card_stats, sum_stats);\n+}\n+\n+template<typename RememberedSet>\n+void ShenandoahScanRemembered<RememberedSet>::merge_worker_card_stats_cumulative(\n+  HdrSeq* worker_stats, HdrSeq* sum_stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    sum_stats[i].add(worker_stats[i]);\n+    worker_stats[i].clear();\n+  }\n+}\n+#endif\n+\n+inline bool ShenandoahRegionChunkIterator::has_next() const {\n+  return _index < _total_chunks;\n+}\n+\n+inline bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n+  if (_index >= _total_chunks) {\n+    return false;\n+  }\n+  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  if (new_index > _total_chunks) {\n+    \/\/ First worker that hits new_index == _total_chunks continues, other\n+    \/\/ contending workers return false.\n+    return false;\n+  }\n+  \/\/ convert to zero-based indexing\n+  new_index--;\n+  assert(new_index < _total_chunks, \"Error\");\n+\n+  \/\/ Find the group number for the assigned chunk index\n+  size_t group_no;\n+  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n+    ;\n+  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n+\n+  \/\/ All size computations measured in HeapWord\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t group_region_index = _region_index[group_no];\n+  size_t group_region_offset = _group_offset[group_no];\n+\n+  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n+  size_t group_chunk_size = _group_chunk_size[group_no];\n+  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n+  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n+  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n+\n+  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n+\n+  assignment->_r = _heap->get_region(region_index);\n+  assignment->_chunk_offset = offset_within_region;\n+  assignment->_chunk_size = group_chunk_size;\n+  return true;\n+}\n+\n+template<class T>\n+inline void ShenandoahVerifyNoYoungRefsClosure::work(T* p) {\n+  T o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n+    assert(!_heap->is_in_young(obj), \"Found a young ref\");\n+  }\n+}\n+\n+#endif   \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSCANREMEMBEREDINLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1027,"deletions":0,"binary":false,"changes":1027,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -78,3 +79,1 @@\n-    if (_heap->is_concurrent_mark_in_progress()) {\n-      return &_keep_alive_cl;\n-    } else if (_heap->is_concurrent_weak_root_in_progress()) {\n+    if (_heap->is_concurrent_weak_root_in_progress()) {\n@@ -83,0 +82,2 @@\n+    } else if (_heap->is_concurrent_mark_in_progress()) {\n+      return &_keep_alive_cl;\n@@ -95,8 +96,1 @@\n-  if (heap->is_concurrent_mark_in_progress()) {\n-    \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n-    \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n-    \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n-    retire_tlab();\n-\n-    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n-  } else if (heap->is_concurrent_weak_root_in_progress()) {\n+  if (heap->is_concurrent_weak_root_in_progress()) {\n@@ -111,0 +105,7 @@\n+    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+  } else if (heap->is_concurrent_mark_in_progress()) {\n+    \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n+    \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n+    \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n+    retire_tlab();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -44,0 +46,1 @@\n+\n@@ -45,0 +48,3 @@\n+\n+  \/\/ Thread-local allocation buffer for object evacuations.\n+  \/\/ In generational mode, it is exclusive to the young generation.\n@@ -47,0 +53,1 @@\n+\n@@ -49,0 +56,15 @@\n+  \/\/ Thread-local allocation buffer only used in generational mode.\n+  \/\/ Used both by mutator threads and by GC worker threads\n+  \/\/ for evacuations within the old generation and\n+  \/\/ for promotions from the young generation into the old generation.\n+  PLAB* _plab;\n+  size_t _plab_size;\n+\n+  size_t _plab_evacuated;\n+  size_t _plab_promoted;\n+  size_t _plab_preallocated_promoted;\n+  bool   _plab_allows_promotion; \/\/ If false, no more promotion by this thread during this evacuation phase.\n+  bool   _plab_retries_enabled;\n+\n+  ShenandoahEvacuationStats* _evacuation_stats;\n+\n@@ -56,1 +78,9 @@\n-    _paced_time(0) {\n+    _paced_time(0),\n+    _plab(nullptr),\n+    _plab_size(0),\n+    _plab_evacuated(0),\n+    _plab_promoted(0),\n+    _plab_preallocated_promoted(0),\n+    _plab_allows_promotion(true),\n+    _plab_retries_enabled(true),\n+    _evacuation_stats(new ShenandoahEvacuationStats()) {\n@@ -63,0 +93,7 @@\n+    if (_plab != nullptr) {\n+      ShenandoahHeap::heap()->retire_plab(_plab);\n+      delete _plab;\n+    }\n+\n+    \/\/ TODO: Preserve these stats somewhere for mutator threads.\n+    delete _evacuation_stats;\n@@ -100,0 +137,2 @@\n+    data(thread)->_plab = new PLAB(PLAB::min_size());\n+    data(thread)->_plab_size = 0;\n@@ -114,0 +153,90 @@\n+  static void begin_evacuation(Thread* thread, size_t bytes) {\n+    data(thread)->_evacuation_stats->begin_evacuation(bytes);\n+  }\n+\n+  static void end_evacuation(Thread* thread, size_t bytes, uint age) {\n+    data(thread)->_evacuation_stats->end_evacuation(bytes, age);\n+  }\n+\n+  static ShenandoahEvacuationStats* evacuation_stats(Thread* thread) {\n+    return data(thread)->_evacuation_stats;\n+  }\n+\n+  static PLAB* plab(Thread* thread) {\n+    return data(thread)->_plab;\n+  }\n+\n+  static size_t plab_size(Thread* thread) {\n+    return data(thread)->_plab_size;\n+  }\n+\n+  static void set_plab_size(Thread* thread, size_t v) {\n+    data(thread)->_plab_size = v;\n+  }\n+\n+  static void enable_plab_retries(Thread* thread) {\n+    data(thread)->_plab_retries_enabled = true;\n+  }\n+\n+  static void disable_plab_retries(Thread* thread) {\n+    data(thread)->_plab_retries_enabled = false;\n+  }\n+\n+  static bool plab_retries_enabled(Thread* thread) {\n+    return data(thread)->_plab_retries_enabled;\n+  }\n+\n+  static void enable_plab_promotions(Thread* thread) {\n+    data(thread)->_plab_allows_promotion = true;\n+  }\n+\n+  static void disable_plab_promotions(Thread* thread) {\n+    data(thread)->_plab_allows_promotion = false;\n+  }\n+\n+  static bool allow_plab_promotions(Thread* thread) {\n+    return data(thread)->_plab_allows_promotion;\n+  }\n+\n+  static void reset_plab_evacuated(Thread* thread) {\n+    data(thread)->_plab_evacuated = 0;\n+  }\n+\n+  static void add_to_plab_evacuated(Thread* thread, size_t increment) {\n+    data(thread)->_plab_evacuated += increment;\n+  }\n+\n+  static void subtract_from_plab_evacuated(Thread* thread, size_t increment) {\n+    \/\/ TODO: Assert underflow\n+    data(thread)->_plab_evacuated -= increment;\n+  }\n+\n+  static size_t get_plab_evacuated(Thread* thread) {\n+    return data(thread)->_plab_evacuated;\n+  }\n+\n+  static void reset_plab_promoted(Thread* thread) {\n+    data(thread)->_plab_promoted = 0;\n+  }\n+\n+  static void add_to_plab_promoted(Thread* thread, size_t increment) {\n+    data(thread)->_plab_promoted += increment;\n+  }\n+\n+  static void subtract_from_plab_promoted(Thread* thread, size_t increment) {\n+    \/\/ TODO: Assert underflow\n+    data(thread)->_plab_promoted -= increment;\n+  }\n+\n+  static size_t get_plab_promoted(Thread* thread) {\n+    return data(thread)->_plab_promoted;\n+  }\n+\n+  static void set_plab_preallocated_promoted(Thread* thread, size_t value) {\n+    data(thread)->_plab_preallocated_promoted = value;\n+  }\n+\n+  static size_t get_plab_preallocated_promoted(Thread* thread) {\n+    return data(thread)->_plab_preallocated_promoted;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":130,"deletions":1,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-    _marking_context(ShenandoahHeap::heap()->complete_marking_context()),\n+    \/\/ TODO: In non-generational mode, this should still be complete_marking_context()\n+    _marking_context(ShenandoahHeap::heap()->marking_context()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -35,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -41,1 +44,1 @@\n-ShenandoahGCSession::ShenandoahGCSession(GCCause::Cause cause) :\n+ShenandoahGCSession::ShenandoahGCSession(GCCause::Cause cause, ShenandoahGeneration* generation) :\n@@ -43,0 +46,1 @@\n+  _generation(generation),\n@@ -47,1 +51,2 @@\n-  _heap->set_gc_cause(cause);\n+  _heap->on_cycle_start(cause, _generation);\n+\n@@ -52,2 +57,0 @@\n-  _heap->shenandoah_policy()->record_cycle_start();\n-  _heap->heuristics()->record_cycle_start();\n@@ -68,1 +71,1 @@\n-  _heap->heuristics()->record_cycle_end();\n+  _heap->on_cycle_end(_generation);\n@@ -71,1 +74,1 @@\n-  _tracer->report_gc_reference_stats(_heap->ref_processor()->reference_process_stats());\n+  _tracer->report_gc_reference_stats(_generation->ref_processor()->reference_process_stats());\n@@ -74,1 +77,1 @@\n-  _heap->set_gc_cause(GCCause::_no_gc);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,16 @@\n+class ShenandoahGeneration;\n+\n+#define SHENANDOAH_RETURN_EVENT_MESSAGE(heap, generation_type, prefix, postfix) \\\n+  switch (generation_type) {                                                    \\\n+    case GLOBAL_NON_GEN:                                                        \\\n+      return prefix \"\" postfix;                                                 \\\n+    case GLOBAL_GEN:                                                            \\\n+      return prefix \" (GLOBAL)\" postfix;                                        \\\n+    case YOUNG:                                                                 \\\n+      return prefix \" (YOUNG)\" postfix;                                         \\\n+    case OLD:                                                                   \\\n+      return prefix \" (OLD)\" postfix;                                           \\\n+    default:                                                                    \\\n+      ShouldNotReachHere();                                                     \\\n+      return prefix \" (?)\" postfix;                                             \\\n+  }                                                                             \\\n@@ -48,0 +65,1 @@\n+  ShenandoahGeneration* const _generation;\n@@ -53,1 +71,1 @@\n-  ShenandoahGCSession(GCCause::Cause cause);\n+  ShenandoahGCSession(GCCause::Cause cause, ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -36,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -71,0 +75,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -82,1 +87,2 @@\n-    _loc(nullptr) {\n+    _loc(nullptr),\n+    _generation(nullptr) {\n@@ -87,0 +93,5 @@\n+\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->active_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode\");\n+    }\n@@ -110,1 +121,3 @@\n-      if (_map->par_mark(obj)) {\n+      \/\/ TODO: We should consider specializing this closure by generation ==\/!= null,\n+      \/\/ to avoid in_generation check on fast path here for non-generational mode.\n+      if (in_generation(obj) && _map->par_mark(obj)) {\n@@ -117,0 +130,9 @@\n+  bool in_generation(oop obj) {\n+    if (_generation == nullptr) {\n+      return true;\n+    }\n+\n+    ShenandoahHeapRegion* region = _heap->heap_region_containing(obj);\n+    return _generation->contains(region);\n+  }\n+\n@@ -167,1 +189,2 @@\n-          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live(),\n+          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live() ||\n+                (obj_reg->is_old() && ShenandoahHeap::heap()->is_gc_generation_young()),\n@@ -216,1 +239,8 @@\n-\n+    \/\/ We allow for marked or old here for two reasons:\n+    \/\/  1. If this is a young collect, old objects wouldn't be marked. We've\n+    \/\/     recently change the verifier traversal to only follow young objects\n+    \/\/     during a young collect so this _shouldn't_ be necessary.\n+    \/\/  2. At present, we do not clear dead objects from the remembered set.\n+    \/\/     Everything in the remembered set is old (ipso facto), so allowing for\n+    \/\/     'marked_or_old' covers the case of stale objects in rset.\n+    \/\/ TODO: Just use 'is_marked' here.\n@@ -222,1 +252,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->marking_context()->is_marked(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->marking_context()->is_marked_or_old(obj),\n@@ -226,1 +256,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked_or_old(obj),\n@@ -230,1 +260,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked_or_old(obj),\n@@ -316,0 +346,2 @@\n+\/\/ This closure computes the amounts of used, committed, and garbage memory and the number of regions contained within\n+\/\/ a subset (e.g. the young generation or old generation) of the total heap.\n@@ -318,1 +350,1 @@\n-  size_t _used, _committed, _garbage;\n+  size_t _used, _committed, _garbage, _regions, _humongous_waste;\n@@ -320,1 +352,1 @@\n-  ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0) {};\n+  ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0), _regions(0), _humongous_waste(0) {};\n@@ -326,0 +358,6 @@\n+    if (r->is_humongous()) {\n+      _humongous_waste += r->free();\n+    }\n+    _regions++;\n+    log_debug(gc)(\"ShenandoahCalculateRegionStatsClosure: adding \" SIZE_FORMAT \" for %s Region \" SIZE_FORMAT \", yielding: \" SIZE_FORMAT,\n+            r->used(), (r->is_humongous() ? \"humongous\" : \"regular\"), r->index(), _used);\n@@ -331,0 +369,71 @@\n+  size_t regions() { return _regions; }\n+  size_t waste() { return _humongous_waste; }\n+\n+  \/\/ span is the total memory affiliated with these stats (some of which is in use and other is available)\n+  size_t span() { return _regions * ShenandoahHeapRegion::region_size_bytes(); }\n+};\n+\n+class ShenandoahGenerationStatsClosure : public ShenandoahHeapRegionClosure {\n+ public:\n+  ShenandoahCalculateRegionStatsClosure old;\n+  ShenandoahCalculateRegionStatsClosure young;\n+  ShenandoahCalculateRegionStatsClosure global;\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    switch (r->affiliation()) {\n+      case FREE:\n+        return;\n+      case YOUNG_GENERATION:\n+        young.heap_region_do(r);\n+        global.heap_region_do(r);\n+        break;\n+      case OLD_GENERATION:\n+        old.heap_region_do(r);\n+        global.heap_region_do(r);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+\n+  static void log_usage(ShenandoahGeneration* generation, ShenandoahCalculateRegionStatsClosure& stats) {\n+    log_debug(gc)(\"Safepoint verification: %s verified usage: \" SIZE_FORMAT \"%s, recorded usage: \" SIZE_FORMAT \"%s\",\n+                  generation->name(),\n+                  byte_size_in_proper_unit(generation->used()), proper_unit_for_byte_size(generation->used()),\n+                  byte_size_in_proper_unit(stats.used()),       proper_unit_for_byte_size(stats.used()));\n+  }\n+\n+  static void validate_usage(const bool adjust_for_padding,\n+                             const char* label, ShenandoahGeneration* generation, ShenandoahCalculateRegionStatsClosure& stats) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    size_t generation_used = generation->used();\n+    size_t generation_used_regions = generation->used_regions();\n+    if (adjust_for_padding && (generation->is_young() || generation->is_global())) {\n+      size_t pad = ShenandoahHeap::heap()->get_pad_for_promote_in_place();\n+      generation_used += pad;\n+    }\n+\n+    guarantee(stats.used() == generation_used,\n+              \"%s: generation (%s) used size must be consistent: generation-used: \" SIZE_FORMAT \"%s, regions-used: \" SIZE_FORMAT \"%s\",\n+              label, generation->name(),\n+              byte_size_in_proper_unit(generation_used), proper_unit_for_byte_size(generation_used),\n+              byte_size_in_proper_unit(stats.used()),    proper_unit_for_byte_size(stats.used()));\n+\n+    guarantee(stats.regions() == generation_used_regions,\n+              \"%s: generation (%s) used regions (\" SIZE_FORMAT \") must equal regions that are in use (\" SIZE_FORMAT \")\",\n+              label, generation->name(), generation->used_regions(), stats.regions());\n+\n+    size_t generation_capacity = generation->max_capacity();\n+    size_t humongous_regions_promoted = 0;\n+    guarantee(stats.span() <= generation_capacity,\n+              \"%s: generation (%s) size spanned by regions (\" SIZE_FORMAT \") must not exceed current capacity (\" SIZE_FORMAT \"%s)\",\n+              label, generation->name(), stats.regions(),\n+              byte_size_in_proper_unit(generation_capacity), proper_unit_for_byte_size(generation_capacity));\n+\n+    size_t humongous_waste = generation->get_humongous_waste();\n+    guarantee(stats.waste() == humongous_waste,\n+              \"%s: generation (%s) humongous waste must be consistent: generation: \" SIZE_FORMAT \"%s, regions: \" SIZE_FORMAT \"%s\",\n+              label, generation->name(),\n+              byte_size_in_proper_unit(humongous_waste), proper_unit_for_byte_size(humongous_waste),\n+              byte_size_in_proper_unit(stats.waste()),   proper_unit_for_byte_size(stats.waste()));\n+  }\n@@ -414,2 +523,5 @@\n-    verify(r, r->get_shared_allocs() + r->get_tlab_allocs() + r->get_gclab_allocs() == r->used(),\n-           \"Accurate accounting: shared + TLAB + GCLAB = used\");\n+    verify(r, r->get_plab_allocs() <= r->capacity(),\n+           \"PLAB alloc count should not be larger than capacity\");\n+\n+    verify(r, r->get_shared_allocs() + r->get_tlab_allocs() + r->get_gclab_allocs() + r->get_plab_allocs() == r->used(),\n+           \"Accurate accounting: shared + TLAB + GCLAB + PLAB = used\");\n@@ -497,0 +609,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -510,1 +623,7 @@\n-          _processed(0) {};\n+          _processed(0),\n+          _generation(nullptr) {\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->active_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode.\");\n+    }\n+  };\n@@ -526,0 +645,4 @@\n+        if (!in_generation(r)) {\n+          continue;\n+        }\n+\n@@ -537,0 +660,4 @@\n+  bool in_generation(ShenandoahHeapRegion* r) {\n+    return _generation == nullptr || _generation->contains(r);\n+  }\n+\n@@ -609,1 +736,1 @@\n-    if (actual != _expected) {\n+    if (!verify_gc_state(actual, _expected)) {\n@@ -613,0 +740,7 @@\n+\n+  static bool verify_gc_state(char actual, char expected) {\n+    \/\/ Old generation marking is allowed in all states.\n+    \/\/ TODO: This actually accepts more than just OLD_MARKING.\n+    \/\/ TODO: Also, only accept OLD_MARKING in generational mode.\n+    return (actual == expected) || (actual & ShenandoahHeap::OLD_MARKING);\n+  }\n@@ -615,1 +749,2 @@\n-void ShenandoahVerifier::verify_at_safepoint(const char *label,\n+void ShenandoahVerifier::verify_at_safepoint(const char* label,\n+                                             VerifyRememberedSet remembered,\n@@ -619,0 +754,1 @@\n+                                             VerifySize sizeness,\n@@ -648,0 +784,4 @@\n+      case _verify_gcstate_updating:\n+        enabled = true;\n+        expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::UPDATEREFS;\n+        break;\n@@ -667,1 +807,2 @@\n-      if (actual != expected) {\n+      \/\/ Old generation marking is allowed in all states.\n+      if (!VerifyThreadGCState::verify_gc_state(actual, expected)) {\n@@ -685,7 +826,14 @@\n-    size_t heap_used = _heap->used();\n-    guarantee(cl.used() == heap_used,\n-              \"%s: heap used size must be consistent: heap-used = \" SIZE_FORMAT \"%s, regions-used = \" SIZE_FORMAT \"%s\",\n-              label,\n-              byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),\n-              byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));\n-\n+    size_t heap_used;\n+    if (_heap->mode()->is_generational() && (sizeness == _verify_size_adjusted_for_padding)) {\n+      \/\/ Prior to evacuation, regular regions that are to be evacuated in place are padded to prevent further allocations\n+      heap_used = _heap->used() + _heap->get_pad_for_promote_in_place();\n+    } else if (sizeness != _verify_size_disable) {\n+      heap_used = _heap->used();\n+    }\n+    if (sizeness != _verify_size_disable) {\n+      guarantee(cl.used() == heap_used,\n+                \"%s: heap used size must be consistent: heap-used = \" SIZE_FORMAT \"%s, regions-used = \" SIZE_FORMAT \"%s\",\n+                label,\n+                byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),\n+                byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));\n+    }\n@@ -700,0 +848,54 @@\n+  log_debug(gc)(\"Safepoint verification finished heap usage verification\");\n+\n+  ShenandoahGeneration* generation;\n+  if (_heap->mode()->is_generational()) {\n+    generation = _heap->active_generation();\n+    guarantee(generation != nullptr, \"Need to know which generation to verify.\");\n+  } else {\n+    generation = nullptr;\n+  }\n+\n+  if (generation != nullptr) {\n+    ShenandoahHeapLocker lock(_heap->lock());\n+\n+    switch (remembered) {\n+      case _verify_remembered_disable:\n+        break;\n+      case _verify_remembered_before_marking:\n+        log_debug(gc)(\"Safepoint verification of remembered set at mark\");\n+        verify_rem_set_before_mark();\n+        break;\n+      case _verify_remembered_before_updating_references:\n+        log_debug(gc)(\"Safepoint verification of remembered set at update ref\");\n+        verify_rem_set_before_update_ref();\n+        break;\n+      case _verify_remembered_after_full_gc:\n+        log_debug(gc)(\"Safepoint verification of remembered set after full gc\");\n+        verify_rem_set_after_full_gc();\n+        break;\n+      default:\n+        fatal(\"Unhandled remembered set verification mode\");\n+    }\n+\n+    ShenandoahGenerationStatsClosure cl;\n+    _heap->heap_region_iterate(&cl);\n+\n+    if (LogTarget(Debug, gc)::is_enabled()) {\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(),    cl.old);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(),  cl.young);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->global_generation(), cl.global);\n+    }\n+    if (sizeness == _verify_size_adjusted_for_padding) {\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->young_generation(), cl.young);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->global_generation(), cl.global);\n+    } else if (sizeness == _verify_size_exact) {\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->young_generation(), cl.young);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->global_generation(), cl.global);\n+    }\n+    \/\/ else: sizeness must equal _verify_size_disable\n+  }\n+\n+  log_debug(gc)(\"Safepoint verification finished remembered set verification\");\n+\n@@ -703,1 +905,5 @@\n-    _heap->heap_region_iterate(&cl);\n+    if (generation != nullptr) {\n+      generation->heap_region_iterate(&cl);\n+    } else {\n+      _heap->heap_region_iterate(&cl);\n+    }\n@@ -706,0 +912,2 @@\n+  log_debug(gc)(\"Safepoint verification finished heap region closure verification\");\n+\n@@ -730,0 +938,2 @@\n+  log_debug(gc)(\"Safepoint verification finished getting initial reachable set\");\n+\n@@ -747,0 +957,2 @@\n+  log_debug(gc)(\"Safepoint verification finished walking marked objects\");\n+\n@@ -753,0 +965,3 @@\n+      if (generation != nullptr && !generation->contains(r)) {\n+        continue;\n+      }\n@@ -776,0 +991,3 @@\n+  log_debug(gc)(\"Safepoint verification finished accumulation of liveness data\");\n+\n+\n@@ -785,0 +1003,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -790,0 +1009,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -797,0 +1017,2 @@\n+          _verify_remembered_before_marking,\n+                                       \/\/ verify read-only remembered set from bottom() to top()\n@@ -802,0 +1024,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -809,0 +1032,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -810,1 +1034,2 @@\n-          _verify_marked_complete_except_references, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n+          _verify_marked_complete_except_references,\n+                                       \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n@@ -814,0 +1039,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -821,0 +1047,1 @@\n+          _verify_remembered_disable,                \/\/ do not verify remembered set\n@@ -826,0 +1053,2 @@\n+          _verify_size_adjusted_for_padding,         \/\/ expect generation and heap sizes to match after adjustments\n+                                                     \/\/  for promote in place padding\n@@ -833,0 +1062,1 @@\n+          _verify_remembered_disable, \/\/ do not verify remembered set\n@@ -838,0 +1068,1 @@\n+          _verify_size_disable,       \/\/ we don't know how much of promote-in-place work has been completed\n@@ -845,0 +1076,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -850,0 +1082,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -857,0 +1090,1 @@\n+          _verify_remembered_before_updating_references,  \/\/ verify read-write remembered set\n@@ -862,1 +1096,2 @@\n-          _verify_gcstate_forwarded    \/\/ evacuation should have produced some forwarded objects\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n+          _verify_gcstate_updating     \/\/ evacuation should have produced some forwarded objects\n@@ -866,0 +1101,1 @@\n+\/\/ We have not yet cleanup (reclaimed) the collection set\n@@ -869,0 +1105,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -874,0 +1111,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -881,0 +1119,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -886,0 +1125,1 @@\n+          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n@@ -893,0 +1133,1 @@\n+          _verify_remembered_disable,  \/\/ do not verify remembered set\n@@ -898,0 +1139,1 @@\n+          _verify_size_disable,        \/\/ if we degenerate during evacuation, usage not valid: padding and deferred accounting\n@@ -905,0 +1147,1 @@\n+          _verify_remembered_after_full_gc,  \/\/ verify read-write remembered set\n@@ -910,0 +1153,1 @@\n+          _verify_size_exact,           \/\/ expect generation and heap sizes to match exactly\n@@ -914,1 +1158,2 @@\n-class ShenandoahVerifyNoForwared : public OopClosure {\n+\/\/ TODO: Why this closure does not visit metadata?\n+class ShenandoahVerifyNoForwared : public BasicOopIterateClosure {\n@@ -934,1 +1179,2 @@\n-class ShenandoahVerifyInToSpaceClosure : public OopClosure {\n+\/\/ TODO: Why this closure does not visit metadata?\n+class ShenandoahVerifyInToSpaceClosure : public BasicOopIterateClosure {\n@@ -943,1 +1189,1 @@\n-      if (!heap->marking_context()->is_marked(obj)) {\n+      if (!heap->marking_context()->is_marked_or_old(obj)) {\n@@ -975,0 +1221,212 @@\n+\n+class ShenandoahVerifyRemSetClosure : public BasicOopIterateClosure {\n+protected:\n+  bool               const _init_mark;\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n+\n+public:\n+  \/\/ Argument distinguishes between initial mark or start of update refs verification.\n+  ShenandoahVerifyRemSetClosure(bool init_mark) :\n+            _init_mark(init_mark),\n+            _heap(ShenandoahHeap::heap()),\n+            _scanner(_heap->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj)) {\n+        size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n+        if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                           \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n+        }\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+void ShenandoahVerifier::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n+                                                    HeapWord* top, HeapWord* registration_watermark, const char* message) {\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n+\n+  HeapWord* obj_addr = from;\n+  if (r->is_humongous_start()) {\n+    oop obj = cast_to_oop(obj_addr);\n+    if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+      size_t card_index = scanner->card_index_for_addr(obj_addr);\n+      \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+      \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+      \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+        obj->oop_iterate(&check_interesting_pointers);\n+      }\n+      \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+    }\n+    \/\/ else, this humongous object is not live so no need to verify its internal pointers\n+\n+    if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+      ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                       \"object not properly registered\", __FILE__, __LINE__);\n+    }\n+  } else if (!r->is_humongous()) {\n+    while (obj_addr < top) {\n+      oop obj = cast_to_oop(obj_addr);\n+      \/\/ ctx->is_marked() returns true if mark bit set or if obj above TAMS.\n+      if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+        size_t card_index = scanner->card_index_for_addr(obj_addr);\n+        \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+        \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+          obj->oop_iterate(&check_interesting_pointers);\n+        }\n+        \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+\n+        if ((obj_addr < registration_watermark) && !scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, obj_addr, nullptr, message,\n+                                           \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+        obj_addr += obj->size();\n+      } else {\n+        \/\/ This object is not live so we don't verify dirty cards contained therein\n+        HeapWord* tams = ctx->top_at_mark_start(r);\n+        obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.\n+\/\/ This examines the read_card_table between bottom() and top() since all PLABS are retired\n+\/\/ before the safepoint for init_mark.  Actually, we retire them before update-references and don't\n+\/\/ restore them until the start of evacuation.\n+void ShenandoahVerifier::verify_rem_set_before_mark() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  RememberedScanner* scanner = _heap->card_scan();\n+  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n+  ShenandoahMarkingContext* ctx;\n+\n+  log_debug(gc)(\"Verifying remembered set at %s mark\", _heap->doing_mixed_evacuations()? \"mixed\": \"young\");\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+\n+    HeapWord* tams = (ctx != nullptr) ? ctx->top_at_mark_start(r) : nullptr;\n+\n+    \/\/ TODO: Is this replaceable with call to help_verify_region_rem_set?\n+\n+    if (r->is_old() && r->is_active()) {\n+      HeapWord* obj_addr = r->bottom();\n+      if (r->is_humongous_start()) {\n+        oop obj = cast_to_oop(obj_addr);\n+        if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n+          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+            obj->oop_iterate(&check_interesting_pointers);\n+          }\n+          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+        }\n+        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n+        if (!scanner->verify_registration(obj_addr, ctx)) {\n+          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, nullptr, nullptr,\n+                                           \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+        }\n+      } else if (!r->is_humongous()) {\n+        HeapWord* top = r->top();\n+        while (obj_addr < top) {\n+          oop obj = cast_to_oop(obj_addr);\n+          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n+          if ((ctx == nullptr) || ctx->is_marked(obj)) {\n+            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n+            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n+            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n+              obj->oop_iterate(&check_interesting_pointers);\n+            }\n+            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n+            if (!scanner->verify_registration(obj_addr, ctx)) {\n+              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, nullptr, nullptr,\n+                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n+            }\n+            obj_addr += obj->size();\n+          } else {\n+            \/\/ This object is not live so we don't verify dirty cards contained therein\n+            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n+            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n+          }\n+        }\n+      } \/\/ else, we ignore humongous continuation region\n+    } \/\/ else, this is not an OLD region so we ignore it\n+  } \/\/ all regions have been processed\n+}\n+\n+void ShenandoahVerifier::verify_rem_set_after_full_gc() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n+    }\n+  }\n+}\n+\n+\/\/ Assure that the remember set has a dirty card everywhere there is an interesting pointer.  Even though\n+\/\/ the update-references scan of remembered set only examines cards up to update_watermark, the remembered\n+\/\/ set should be valid through top.  This examines the write_card_table between bottom() and top() because\n+\/\/ all PLABS are retired immediately before the start of update refs.\n+void ShenandoahVerifier::verify_rem_set_before_update_ref() {\n+  shenandoah_assert_safepoint();\n+  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+\n+  ShenandoahRegionIterator iterator;\n+  ShenandoahMarkingContext* ctx;\n+\n+  if (_heap->is_old_bitmap_stable() || _heap->active_generation()->is_global()) {\n+    ctx = _heap->complete_marking_context();\n+  } else {\n+    ctx = nullptr;\n+  }\n+\n+  while (iterator.has_next()) {\n+    ShenandoahHeapRegion* r = iterator.next();\n+    if (r == nullptr) {\n+      \/\/ TODO: Can this really happen?\n+      break;\n+    }\n+    if (r->is_old() && !r->is_cset()) {\n+      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n+                                 \"Remembered set violation at init-update-references\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":486,"deletions":28,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -60,0 +61,18 @@\n+  typedef enum {\n+    \/\/ Disable remembered set verification.\n+    _verify_remembered_disable,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-only* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_marking,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    _verify_remembered_before_updating_references,\n+\n+    \/\/ Old objects should be registered and RS cards within *read-write* RS are dirty for all\n+    \/\/ inter-generational pointers.\n+    \/\/ TODO: This differs from the previous mode by update-watermark() vs top() end range?\n+    _verify_remembered_after_full_gc\n+  } VerifyRememberedSet;\n+\n@@ -125,0 +144,11 @@\n+  typedef enum {\n+    \/\/ Disable size verification\n+    _verify_size_disable,\n+\n+    \/\/ Enforce exact consistency\n+    _verify_size_exact,\n+\n+    \/\/ Expect promote-in-place adjustments: padding inserted to temporarily prevent further allocation in regular regions\n+    _verify_size_adjusted_for_padding\n+  } VerifySize;\n+\n@@ -139,1 +169,4 @@\n-    _verify_gcstate_evacuation\n+    _verify_gcstate_evacuation,\n+\n+    \/\/ Evacuation is done, some objects are forwarded, updating is in progress\n+    _verify_gcstate_updating\n@@ -163,1 +196,2 @@\n-  void verify_at_safepoint(const char *label,\n+  void verify_at_safepoint(const char* label,\n+                           VerifyRememberedSet remembered,\n@@ -169,0 +203,1 @@\n+                           VerifySize sizeness,\n@@ -191,0 +226,8 @@\n+\n+private:\n+   void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                    HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n+\n+  void verify_rem_set_before_mark();\n+  void verify_rem_set_before_update_ref();\n+  void verify_rem_set_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+uint ShenandoahWorkerPolicy::_prev_conc_rs_scanning = 0;\n@@ -64,0 +65,9 @@\n+uint ShenandoahWorkerPolicy::calc_workers_for_rs_scanning() {\n+  uint active_workers = (_prev_conc_rs_scanning == 0) ? ConcGCThreads : _prev_conc_rs_scanning;\n+  _prev_conc_rs_scanning =\n+    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n+                                           active_workers,\n+                                           Threads::number_of_non_daemon_threads());\n+  return _prev_conc_rs_scanning;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  static uint _prev_conc_rs_scanning;\n@@ -51,0 +52,3 @@\n+  \/\/ Calculate the number of workers for remembered set scanning\n+  static uint calc_workers_for_rs_scanning();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahVerifier.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n+  _old_gen_task_queues(nullptr) {\n+}\n+\n+void ShenandoahYoungGeneration::set_concurrent_mark_in_progress(bool in_progress) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->set_concurrent_young_mark_in_progress(in_progress);\n+  if (is_bootstrap_cycle() && in_progress && !heap->is_prepare_for_old_mark_in_progress()) {\n+    \/\/ This is not a bug. When the bootstrapping marking phase is complete,\n+    \/\/ the old generation marking is still in progress, unless it's not.\n+    \/\/ In the case that old-gen preparation for mixed evacuation has been\n+    \/\/ preempted, we do not want to set concurrent old mark to be in progress.\n+    heap->set_concurrent_old_mark_in_progress(in_progress);\n+  }\n+}\n+\n+bool ShenandoahYoungGeneration::contains(ShenandoahHeapRegion* region) const {\n+  \/\/ TODO: why not test for equals YOUNG_GENERATION?  As written, returns true for regions that are FREE\n+  return !region->is_old();\n+}\n+\n+void ShenandoahYoungGeneration::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Just iterate over the young generation here.\n+  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n+  ShenandoahHeap::heap()->parallel_heap_region_iterate(&young_regions);\n+}\n+\n+void ShenandoahYoungGeneration::heap_region_iterate(ShenandoahHeapRegionClosure* cl) {\n+  ShenandoahGenerationRegionClosure<YOUNG> young_regions(cl);\n+  ShenandoahHeap::heap()->heap_region_iterate(&young_regions);\n+}\n+\n+bool ShenandoahYoungGeneration::is_concurrent_mark_in_progress() {\n+  return ShenandoahHeap::heap()->is_concurrent_young_mark_in_progress();\n+}\n+\n+void ShenandoahYoungGeneration::reserve_task_queues(uint workers) {\n+  ShenandoahGeneration::reserve_task_queues(workers);\n+  if (is_bootstrap_cycle()) {\n+    _old_gen_task_queues->reserve(workers);\n+  }\n+}\n+\n+bool ShenandoahYoungGeneration::contains(oop obj) const {\n+  return ShenandoahHeap::heap()->is_in_young(obj);\n+}\n+\n+ShenandoahHeuristics* ShenandoahYoungGeneration::initialize_heuristics(ShenandoahMode* gc_mode) {\n+  _heuristics = gc_mode->initialize_heuristics(this);\n+  _heuristics->set_guaranteed_gc_interval(ShenandoahGuaranteedYoungGCInterval);\n+  confirm_heuristics_mode();\n+  return _heuristics;\n+}\n+\n+void ShenandoahYoungGeneration::add_collection_time(double time_seconds) {\n+  if (is_bootstrap_cycle()) {\n+    \/\/ This is a bootstrap cycle, so attribute time to old gc\n+    ShenandoahHeap::heap()->old_generation()->add_collection_time(time_seconds);\n+  } else {\n+    ShenandoahGeneration::add_collection_time(time_seconds);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+#define SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+\n+class ShenandoahYoungGeneration : public ShenandoahGeneration {\n+private:\n+  ShenandoahObjToScanQueueSet* _old_gen_task_queues;\n+\n+public:\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n+\n+  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+\n+  const char* name() const override {\n+    return \"YOUNG\";\n+  }\n+\n+  void set_concurrent_mark_in_progress(bool in_progress) override;\n+  bool is_concurrent_mark_in_progress() override;\n+\n+  void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+  void heap_region_iterate(ShenandoahHeapRegionClosure* cl) override;\n+\n+  bool contains(ShenandoahHeapRegion* region) const override;\n+  bool contains(oop obj) const override;\n+\n+  void reserve_task_queues(uint workers) override;\n+  void set_old_gen_task_queues(ShenandoahObjToScanQueueSet* old_gen_queues) {\n+    _old_gen_task_queues = old_gen_queues;\n+  }\n+  ShenandoahObjToScanQueueSet* old_gen_task_queues() const override {\n+    return _old_gen_task_queues;\n+  }\n+\n+  \/\/ Returns true if the young generation is configured to enqueue old\n+  \/\/ oops for the old generation mark queues.\n+  bool is_bootstrap_cycle() {\n+    return _old_gen_task_queues != nullptr;\n+  }\n+\n+  virtual void add_collection_time(double time_seconds) override;\n+};\n+\n+#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHYOUNGGENERATION_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -65,1 +66,2 @@\n-          \" passive - stop the world GC only (either degenerated or full)\") \\\n+          \" passive - stop the world GC only (either degenerated or full);\" \\\n+          \" generational - generational concurrent GC\")                     \\\n@@ -79,0 +81,6 @@\n+  product(ccstr, ShenandoahOldGCHeuristics, \"adaptive\", EXPERIMENTAL,       \\\n+          \"Similar to ShenandoahGCHeuristics, but applied to the old \"      \\\n+          \"generation. This configuration is only used to trigger old \"     \\\n+          \"collections and does not change how regions are selected \"       \\\n+          \"for collection.\")                                                \\\n+                                                                            \\\n@@ -92,0 +100,14 @@\n+  product(uintx, ShenandoahOldGarbageThreshold, 15, EXPERIMENTAL,           \\\n+          \"How much garbage an old region has to contain before it would \"  \\\n+          \"be taken for collection.\")                                       \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahIgnoreGarbageThreshold, 5, EXPERIMENTAL,         \\\n+          \"When less than this amount of garbage (as a percentage of \"      \\\n+          \"region size) exists within a region, the region will not be \"    \\\n+          \"added to the collection set, even when the heuristic has \"       \\\n+          \"chosen to aggressively add regions with less than \"              \\\n+          \"ShenandoahGarbageThreshold amount of garbage into the \"          \\\n+          \"collection set.\")                                                \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n@@ -93,4 +115,6 @@\n-          \"How much heap should be free before some heuristics trigger the \"\\\n-          \"initial (learning) cycles. Affects cycle frequency on startup \"  \\\n-          \"and after drastic state changes, e.g. after degenerated\/full \"   \\\n-          \"GC cycles. In percents of (soft) max heap size.\")                \\\n+          \"When less than this amount of memory is free within the\"         \\\n+          \"heap or generation, trigger a learning cycle if we are \"         \\\n+          \"in learning mode.  Learning mode happens during initialization \" \\\n+          \"and following a drastic state change, such as following a \"      \\\n+          \"degenerated or Full GC cycle.  In percents of soft max \"         \\\n+          \"heap size.\")                                                     \\\n@@ -100,3 +124,5 @@\n-          \"How much heap should be free before most heuristics trigger the \"\\\n-          \"collection, even without other triggers. Provides the safety \"   \\\n-          \"margin for many heuristics. In percents of (soft) max heap size.\")\\\n+          \"Percentage of free heap memory (or young generation, in \"        \\\n+          \"generational mode) below which most heuristics trigger \"         \\\n+          \"collection independent of other triggers. Provides a safety \"    \\\n+          \"margin for many heuristics. In percents of (soft) max heap \"     \\\n+          \"size.\")                                                          \\\n@@ -118,1 +144,1 @@\n-  product(uintx, ShenandoahLearningSteps, 5, EXPERIMENTAL,                  \\\n+  product(uintx, ShenandoahLearningSteps, 10, EXPERIMENTAL,                 \\\n@@ -123,1 +149,1 @@\n-  product(uintx, ShenandoahImmediateThreshold, 90, EXPERIMENTAL,            \\\n+  product(uintx, ShenandoahImmediateThreshold, 70, EXPERIMENTAL,            \\\n@@ -152,1 +178,1 @@\n-  product(double, ShenandoahAdaptiveDecayFactor, 0.5, EXPERIMENTAL,         \\\n+  product(double, ShenandoahAdaptiveDecayFactor, 0.1, EXPERIMENTAL,         \\\n@@ -158,0 +184,10 @@\n+  product(bool, ShenandoahAdaptiveIgnoreShortCycles, true, EXPERIMENTAL,    \\\n+          \"The adaptive heuristic tracks a moving average of cycle \"        \\\n+          \"times in order to start a gc before memory is exhausted. \"       \\\n+          \"In some cases, Shenandoah may skip the evacuation and update \"   \\\n+          \"reference phases, resulting in a shorter cycle. These may skew \" \\\n+          \"the average cycle time downward and may cause the heuristic \"    \\\n+          \"to wait too long to start a cycle. Disabling this will have \"    \\\n+          \"the gc run less often, which will reduce CPU utilization, but\"   \\\n+          \"increase the risk of degenerated cycles.\")                       \\\n+                                                                            \\\n@@ -165,0 +201,10 @@\n+  product(uintx, ShenandoahGuaranteedOldGCInterval, 10*60*1000, EXPERIMENTAL, \\\n+          \"Run a collection of the old generation at least this often. \"    \\\n+          \"Heuristics may trigger collections more frequently. Time is in \" \\\n+          \"milliseconds. Setting this to 0 disables the feature.\")          \\\n+                                                                            \\\n+  product(uintx, ShenandoahGuaranteedYoungGCInterval, 5*60*1000,  EXPERIMENTAL,  \\\n+          \"Run a collection of the young generation at least this often. \"  \\\n+          \"Heuristics may trigger collections more frequently. Time is in \" \\\n+          \"milliseconds. Setting this to 0 disables the feature.\")          \\\n+                                                                            \\\n@@ -224,1 +270,2 @@\n-          \"Use Elastic TLABs with Shenandoah\")                              \\\n+          \"Use Elastic TLABs with Shenandoah. This allows Shenandoah to \"   \\\n+          \"decrease the size of a TLAB to fit in a region's remaining space\") \\\n@@ -227,4 +274,12 @@\n-          \"How much of heap to reserve for evacuations. Larger values make \"\\\n-          \"GC evacuate more live objects on every cycle, while leaving \"    \\\n-          \"less headroom for application to allocate in. In percents of \"   \\\n-          \"total heap size.\")                                               \\\n+          \"How much of (young-generation) heap to reserve for \"             \\\n+          \"(young-generation) evacuations.  Larger values allow GC to \"     \\\n+          \"evacuate more live objects on every cycle, while leaving \"       \\\n+          \"less headroom for application to allocate while GC is \"          \\\n+          \"evacuating and updating references. This parameter is \"          \\\n+          \"consulted at the of marking, before selecting the collection \"   \\\n+          \"set.  If available memory at this time is smaller than the \"     \\\n+          \"indicated reserve, the bound on collection set size is \"         \\\n+          \"adjusted downward.  The size of a generational mixed \"           \\\n+          \"evacuation collection set (comprised of both young and old \"     \\\n+          \"regions) is also bounded by this parameter.  In percents of \"    \\\n+          \"total (young-generation) heap size.\")                            \\\n@@ -237,1 +292,2 @@\n-          \"GC cycle.\")                                                      \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n@@ -240,0 +296,36 @@\n+  product(double, ShenandoahOldEvacWaste, 1.4, EXPERIMENTAL,                \\\n+          \"How much waste evacuations produce within the reserved space. \"  \\\n+          \"Larger values make evacuations more resilient against \"          \\\n+          \"evacuation conflicts, at expense of evacuating less on each \"    \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n+          range(1.0,100.0)                                                  \\\n+                                                                            \\\n+  product(double, ShenandoahPromoEvacWaste, 1.2, EXPERIMENTAL,              \\\n+          \"How much waste promotions produce within the reserved space. \"   \\\n+          \"Larger values make evacuations more resilient against \"          \\\n+          \"evacuation conflicts, at expense of promoting less on each \"     \\\n+          \"GC cycle.  Smaller values increase the risk of evacuation \"      \\\n+          \"failures, which will trigger stop-the-world Full GC passes.\")    \\\n+          range(1.0,100.0)                                                  \\\n+                                                                            \\\n+  product(uintx, ShenandoahMaxEvacLABRatio, 0, EXPERIMENTAL,                \\\n+          \"Potentially, each running thread maintains a PLAB for \"          \\\n+          \"evacuating objects into old-gen memory and a GCLAB for \"         \\\n+          \"evacuating objects into young-gen memory.  Each time a thread \"  \\\n+          \"exhausts its PLAB or GCLAB, a new local buffer is allocated. \"   \\\n+          \"By default, the new buffer is twice the size of the previous \"   \\\n+          \"buffer.  The sizes are reset to the minimum at the start of \"    \\\n+          \"each GC pass.  This parameter limits the growth of evacuation \"  \\\n+          \"buffer sizes to its value multiplied by the minimum buffer \"     \\\n+          \"size.  A higher value allows evacuation allocations to be more \" \\\n+          \"efficient because less synchronization is required by \"          \\\n+          \"individual threads.  However, a larger value increases the \"     \\\n+          \"likelihood of evacuation failures, leading to long \"             \\\n+          \"stop-the-world pauses.  This is because a large value \"          \\\n+          \"allows individual threads to consume large percentages of \"      \\\n+          \"the total evacuation budget without necessarily effectively \"    \\\n+          \"filling their local evacuation buffers with evacuated \"          \\\n+          \"objects.  A value of zero means no maximum size is enforced.\")   \\\n+          range(0, 1024)                                                    \\\n+                                                                            \\\n@@ -246,0 +338,35 @@\n+  product(uintx, ShenandoahOldEvacRatioPercent, 75, EXPERIMENTAL,           \\\n+          \"The maximum proportion of evacuation from old-gen memory, as \"   \\\n+          \"a percent ratio.  The default value 75 denotes that no more \"    \\\n+          \"than 75% of the collection set evacuation \"                      \\\n+          \"workload may be evacuate to old-gen heap regions.  This limits \" \\\n+          \"both the promotion of aged regions and the compaction of \"       \\\n+          \"existing old regions.  A value of 75 denotes that the normal \"   \\\n+          \"young-gen evacuation is increased by up to four fold. \"          \\\n+          \"A larger value allows quicker promotion and allows\"              \\\n+          \"a smaller number of mixed evacuations to process \"               \\\n+          \"the entire list of old-gen collection candidates at the cost \"   \\\n+          \"of an increased disruption of the normal cadence of young-gen \"  \\\n+          \"collections.  A value of 100 allows a mixed evacuation to \"      \\\n+          \"focus entirely on old-gen memory, allowing no young-gen \"        \\\n+          \"regions to be collected, likely resulting in subsequent \"        \\\n+          \"allocation failures because the allocation pool is not \"         \\\n+          \"replenished.  A value of 0 allows a mixed evacuation to\"         \\\n+          \"focus entirely on young-gen memory, allowing no old-gen \"        \\\n+          \"regions to be collected, likely resulting in subsequent \"        \\\n+          \"promotion failures and triggering of stop-the-world full GC \"    \\\n+          \"events.\")                                                        \\\n+          range(0,100)                                                      \\\n+                                                                            \\\n+  product(uintx, ShenandoahMinYoungPercentage, 20, EXPERIMENTAL,            \\\n+          \"The minimum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be less than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uintx, ShenandoahMaxYoungPercentage, 100, EXPERIMENTAL,           \\\n+          \"The maximum percentage of the heap to use for the young \"        \\\n+          \"generation. Heuristics will not adjust the young generation \"    \\\n+          \"to be more than this.\")                                          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n@@ -293,1 +420,1 @@\n-  product(uintx, ShenandoahFullGCThreshold, 3, EXPERIMENTAL,                \\\n+  product(uintx, ShenandoahFullGCThreshold, 64, EXPERIMENTAL,               \\\n@@ -297,0 +424,4 @@\n+  product(uintx, ShenandoahOOMGCRetries, 3, EXPERIMENTAL,                   \\\n+          \"How many GCs should happen before we throw OutOfMemoryException \"\\\n+          \"for allocation request, including at least one Full GC.\")        \\\n+                                                                            \\\n@@ -315,0 +446,9 @@\n+  product(uintx, ShenandoahCoalesceChance, 0, DIAGNOSTIC,                   \\\n+          \"Testing: Abandon remaining mixed collections with this \"         \\\n+          \"likelihood. Following each mixed collection, abandon all \"       \\\n+          \"remaining mixed collection candidate regions with likelihood \"   \\\n+          \"ShenandoahCoalesceChance. Abandoning a mixed collection will \"   \\\n+          \"cause the old regions to be made parseable, rather than being \"  \\\n+          \"evacuated.\")                                                     \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n@@ -369,3 +509,24 @@\n-          \"might degrade performance.\")\n-\n-\/\/ end of GC_SHENANDOAH_FLAGS\n+          \"might degrade performance.\")                                     \\\n+                                                                            \\\n+  product(uintx, ShenandoahOldCompactionReserve, 8, EXPERIMENTAL,           \\\n+          \"During generational GC, prevent promotions from filling \"        \\\n+          \"this number of heap regions.  These regions are reserved \"       \\\n+          \"for the purpose of supporting compaction of old-gen \"            \\\n+          \"memory.  Otherwise, old-gen memory cannot be compacted.\")        \\\n+          range(0, 128)                                                     \\\n+                                                                            \\\n+  product(bool, ShenandoahAllowOldMarkingPreemption, true, DIAGNOSTIC,      \\\n+          \"Allow young generation collections to suspend concurrent\"        \\\n+          \" marking in the old generation.\")                                \\\n+                                                                            \\\n+  product(uintx, ShenandoahAgingCyclePeriod, 1, EXPERIMENTAL,               \\\n+          \"With generational mode, increment the age of objects and\"        \\\n+          \"regions each time this many young-gen GC cycles are completed.\") \\\n+                                                                            \\\n+  notproduct(bool, ShenandoahEnableCardStats, trueInDebug,                  \\\n+          \"Enable statistics collection related to clean & dirty cards\")    \\\n+                                                                            \\\n+  notproduct(int, ShenandoahCardStatsLogInterval, 50,                       \\\n+          \"Log cumulative card stats every so many remembered set or \"      \\\n+          \"update refs scans\")                                              \\\n+  \/\/ end of GC_SHENANDOAH_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":183,"deletions":22,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,1 +36,1 @@\n-  volatile_nonstatic_field(ShenandoahHeap, _used,                  size_t)                            \\\n+  nonstatic_field(ShenandoahHeap, _global_generation,              ShenandoahGeneration*)             \\\n@@ -37,0 +38,1 @@\n+  volatile_nonstatic_field(ShenandoahGeneration, _used,            size_t)                            \\\n@@ -65,0 +67,2 @@\n+  declare_toplevel_type(ShenandoahGeneration)                                 \\\n+  declare_toplevel_type(ShenandoahGeneration*)                                \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/vmStructs_shenandoah.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/x\/xBarrier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    return Raw::oop_arraycopy_in_heap(nullptr, 0, src, NULL, 0, dst, length);\n+    return Raw::oop_arraycopy_in_heap(nullptr, 0, src, nullptr, 0, dst, length);\n","filename":"src\/hotspot\/share\/gc\/x\/xBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    if (entry != NULL && entry != _prev) {\n+    if (entry != nullptr && entry != _prev) {\n","filename":"src\/hotspot\/share\/gc\/x\/xPageTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -401,2 +401,3 @@\n-  const uint _gc_id;\n-  bool       _success;\n+  const uint           _gc_id;\n+  const GCCause::Cause _gc_cause;\n+  bool                 _success;\n@@ -405,1 +406,1 @@\n-  VM_ZOperation()\n+  VM_ZOperation(GCCause::Cause gc_cause)\n@@ -407,0 +408,1 @@\n+      _gc_cause(gc_cause),\n@@ -409,0 +411,4 @@\n+  virtual const char* cause() const {\n+    return GCCause::to_string(_gc_cause);\n+  }\n+\n@@ -561,0 +567,3 @@\n+  VM_ZMarkStartYoungAndOld()\n+    : VM_ZOperation(ZDriver::major()->gc_cause()) {}\n+\n@@ -581,1 +590,16 @@\n-class VM_ZMarkStartYoung : public VM_ZOperation {\n+class VM_ZYoungOperation : public VM_ZOperation {\n+private:\n+  static ZDriver* driver() {\n+    if (ZGeneration::young()->type() == ZYoungType::minor) {\n+      return ZDriver::minor();\n+    } else {\n+      return ZDriver::major();\n+    }\n+  }\n+\n+public:\n+  VM_ZYoungOperation()\n+    : VM_ZOperation(driver()->gc_cause()) {}\n+};\n+\n+class VM_ZMarkStartYoung : public VM_ZYoungOperation {\n@@ -629,1 +653,1 @@\n-class VM_ZMarkEndYoung : public VM_ZOperation {\n+class VM_ZMarkEndYoung : public VM_ZYoungOperation {\n@@ -788,1 +812,2 @@\n-class VM_ZRelocateStartYoung : public VM_ZOperation {\n+class VM_ZRelocateStartYoung : public VM_ZYoungOperation {\n+\n@@ -1050,0 +1075,3 @@\n+  VM_ZMarkEndOld()\n+    : VM_ZOperation(ZDriver::major()->gc_cause()) {}\n+\n@@ -1128,0 +1156,3 @@\n+  VM_ZRelocateStartOld()\n+    : VM_ZOperation(ZDriver::major()->gc_cause()) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    st->print_raw_cr(\"NULL\");\n+    st->print_raw_cr(\"null\");\n@@ -438,1 +438,1 @@\n-    st->print_raw_cr(\"NULL\");\n+    st->print_raw_cr(\"null\");\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,8 +378,8 @@\n-    if (ZHeap::heap()->is_old(to_zaddress(obj))) {\n-      if (finalizable) {\n-        ZMarkBarrierFollowOopClosure<true \/* finalizable *\/, ZGenerationIdOptional::old> cl;\n-        ZIterator::oop_iterate(obj, &cl);\n-      } else {\n-        ZMarkBarrierFollowOopClosure<false \/* finalizable *\/, ZGenerationIdOptional::old> cl;\n-        ZIterator::oop_iterate(obj, &cl);\n-      }\n+    assert(ZHeap::heap()->is_old(to_zaddress(obj)), \"Should only follow objects from old gen\");\n+    if (obj->is_stackChunk()) {\n+      \/\/ No support for tracing through stack chunks as finalizably reachable\n+      ZMarkBarrierFollowOopClosure<false \/* finalizable *\/, ZGenerationIdOptional::old> cl;\n+      ZIterator::oop_iterate(obj, &cl);\n+    } else if (finalizable) {\n+      ZMarkBarrierFollowOopClosure<true \/* finalizable *\/, ZGenerationIdOptional::old> cl;\n+      ZIterator::oop_iterate(obj, &cl);\n@@ -387,1 +387,2 @@\n-      fatal(\"Catch me!\");\n+      ZMarkBarrierFollowOopClosure<false \/* finalizable *\/, ZGenerationIdOptional::old> cl;\n+      ZIterator::oop_iterate(obj, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-  JMM_VERSION     = JMM_VERSION_3\n+  JMM_VERSION_4   = 0x20040000, \/\/ JDK 21\n+  JMM_VERSION     = JMM_VERSION_4\n@@ -243,0 +244,2 @@\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1167,0 +1167,6 @@\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_PrintWarningAtDynamicAgentLoad(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+  } else {\n+    \/\/ InterpreterCodelet is not being commited and may be re-used. We need to free the storage for\n+    \/\/ remarks and strings.\n+    NOT_PRODUCT(_clet->clear_remarks());\n+    NOT_PRODUCT(_clet->clear_strings());\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+\n+  void clear_remarks() { _asm_remarks.clear(); }\n+  void clear_strings() { _dbg_strings.clear(); }\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-            (klass == nullptr ? \"<nullptr>\" : klass->internal_name()),\n+            (klass == nullptr ? \"<null>\" : klass->internal_name()),\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", NULL};\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n@@ -187,1 +187,1 @@\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", NULL};\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,5 @@\n+  <Event name=\"ResidentSetSize\" category=\"Java Virtual Machine, Memory\" label=\"Resident Set Size\" description=\"Resident set size of the process\" thread=\"false\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"size\" label=\"Resident Set Size\" description=\"Resident set size of the process\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"peak\" label=\"Resident Set Size Peak Value\" description=\"Resident set size peak value of the process\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,0 +98,4 @@\n+TRACE_REQUEST_FUNC(ResidentSetSize) {\n+  os::jfr_report_memory_info();\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  assert(name_str != nullptr, \"unexpected nullptr thread name\");\n+  assert(name_str != nullptr, \"unexpected null thread name\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    \/\/ new output is nullptr and current output is null\n+    \/\/ new output is null and current output is null\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrRepository.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"jfr\/utilities\/jfrThreadIterator.hpp\"\n@@ -124,0 +125,24 @@\n+\/\/ Reset thread local state used for object allocation sampling.\n+class ClearObjectAllocationSampling : public ThreadClosure {\n+ public:\n+  void do_thread(Thread* t) {\n+    assert(t != nullptr, \"invariant\");\n+    t->jfr_thread_local()->clear_last_allocated_bytes();\n+  }\n+};\n+\n+template <typename Iterator>\n+static inline void iterate(Iterator& it, ClearObjectAllocationSampling& coas) {\n+  while (it.has_next()) {\n+    coas.do_thread(it.next());\n+  }\n+}\n+\n+static void clear_object_allocation_sampling() {\n+  ClearObjectAllocationSampling coas;\n+  JfrJavaThreadIterator jit;\n+  iterate(jit, coas);\n+  JfrNonJavaThreadIterator njit;\n+  iterate(njit, coas);\n+}\n+\n@@ -438,0 +463,1 @@\n+  clear_object_allocation_sampling();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  return new_buffer; \/\/ might be nullptr\n+  return new_buffer; \/\/ might be null\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"jfr\/support\/jfrThreadLocal.hpp\"\n@@ -32,4 +33,1 @@\n-static THREAD_LOCAL int64_t _last_allocated_bytes = 0;\n-\n-inline void send_allocation_sample(const Klass* klass, int64_t allocated_bytes) {\n-  assert(allocated_bytes > 0, \"invariant\");\n+inline bool send_allocation_sample(const Klass* klass, int64_t allocated_bytes, JfrThreadLocal* tl) {\n@@ -38,1 +36,1 @@\n-    const int64_t weight = allocated_bytes - _last_allocated_bytes;\n+    const int64_t weight = allocated_bytes - tl->last_allocated_bytes();\n@@ -43,14 +41,1 @@\n-    _last_allocated_bytes = allocated_bytes;\n-  }\n-}\n-\n-inline bool send_allocation_sample_with_result(const Klass* klass, int64_t allocated_bytes) {\n-  assert(allocated_bytes > 0, \"invariant\");\n-  EventObjectAllocationSample event;\n-  if (event.should_commit()) {\n-    const int64_t weight = allocated_bytes - _last_allocated_bytes;\n-    assert(weight > 0, \"invariant\");\n-    event.set_objectClass(klass);\n-    event.set_weight(weight);\n-    event.commit();\n-    _last_allocated_bytes = allocated_bytes;\n+    tl->set_last_allocated_bytes(allocated_bytes);\n@@ -69,2 +54,1 @@\n-inline int64_t load_allocated_bytes(Thread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n+inline int64_t load_allocated_bytes(JfrThreadLocal* tl, Thread* thread) {\n@@ -72,8 +56,1 @@\n-  if (allocated_bytes < _last_allocated_bytes) {\n-    \/\/ A hw thread can detach and reattach to the VM, and when it does,\n-    \/\/ it gets a new JavaThread representation. The thread local variable\n-    \/\/ tracking _last_allocated_bytes is mapped to the existing hw thread,\n-    \/\/ so it needs to be reset.\n-    _last_allocated_bytes = 0;\n-  }\n-  return allocated_bytes == _last_allocated_bytes ? 0 : allocated_bytes;\n+  return allocated_bytes == tl->last_allocated_bytes() ? 0 : allocated_bytes;\n@@ -84,2 +61,2 @@\n-static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass, int64_t obj_alloc_size_bytes, Thread* thread) {\n-  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass, int64_t obj_alloc_size_bytes, JfrThreadLocal* tl, Thread* thread) {\n+  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n@@ -88,1 +65,1 @@\n-    send_allocation_sample(klass, allocated_bytes);\n+    send_allocation_sample(klass, allocated_bytes, tl);\n@@ -92,1 +69,1 @@\n-  if (allocated_bytes - _last_allocated_bytes < tlab_size_bytes) {\n+  if (allocated_bytes - tl->last_allocated_bytes() < tlab_size_bytes) {\n@@ -97,1 +74,1 @@\n-    if (send_allocation_sample_with_result(klass, allocated_bytes)) {\n+    if (send_allocation_sample(klass, allocated_bytes, tl)) {\n@@ -105,0 +82,3 @@\n+  assert(thread != nullptr, \"invariant\");\n+  JfrThreadLocal* const tl = thread->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n@@ -106,1 +86,1 @@\n-    normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), thread);\n+    normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), tl, thread);\n@@ -109,1 +89,1 @@\n-  const int64_t allocated_bytes = load_allocated_bytes(thread);\n+  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n@@ -113,1 +93,1 @@\n-  send_allocation_sample(klass, allocated_bytes);\n+  send_allocation_sample(klass, allocated_bytes, tl);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrObjectAllocationSample.cpp","additions":17,"deletions":37,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  _last_allocated_bytes(0),\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  int64_t _last_allocated_bytes;\n@@ -152,0 +153,12 @@\n+  int64_t last_allocated_bytes() const {\n+    return _last_allocated_bytes;\n+  }\n+\n+  void set_last_allocated_bytes(int64_t allocated_bytes) {\n+    _last_allocated_bytes = allocated_bytes;\n+  }\n+\n+  void clear_last_allocated_bytes() {\n+    set_last_allocated_bytes(0);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-    if (ex != NULL) {\n+    if (ex != nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1969,1 +1969,6 @@\n-JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {\n+JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies,\n+                                                                          JVMCICompileState* compile_state,\n+                                                                          char** failure_detail,\n+                                                                          bool& failing_dep_is_call_site)\n+{\n+  failing_dep_is_call_site = false;\n@@ -1978,0 +1983,1 @@\n+\n@@ -1981,1 +1987,3 @@\n-\n+  if (result == Dependencies::call_site_target_value) {\n+    failing_dep_is_call_site = true;\n+  }\n@@ -2170,1 +2178,3 @@\n-    result = validate_compile_task_dependencies(dependencies, JVMCIENV->compile_state(), &failure_detail);\n+    JVMCICompileState* compile_state = JVMCIENV->compile_state();\n+    bool failing_dep_is_call_site;\n+    result = validate_compile_task_dependencies(dependencies, compile_state, &failure_detail, failing_dep_is_call_site);\n@@ -2174,1 +2184,1 @@\n-      if (mdp != nullptr) {\n+      if (mdp != nullptr && !failing_dep_is_call_site) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -431,1 +431,4 @@\n-  static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);\n+  static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target,\n+                                                                     JVMCICompileState* task,\n+                                                                     char** failure_detail,\n+                                                                     bool& failing_dep_is_call_site);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  JVMCI_FLAG_CHECKED(UseGraalJIT)\n@@ -167,1 +168,1 @@\n-bool JVMCIGlobals::enable_jvmci_product_mode(JVMFlagOrigin origin) {\n+bool JVMCIGlobals::enable_jvmci_product_mode(JVMFlagOrigin origin, bool use_graal_jit) {\n@@ -204,0 +205,6 @@\n+  if (use_graal_jit) {\n+    JVMFlag *useGraalJITFlag = JVMFlag::find_flag(\"UseGraalJIT\");\n+    if (JVMFlagAccess::set_bool(useGraalJITFlag, &value, origin) != JVMFlag::SUCCESS) {\n+      return false;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,5 @@\n+  product(bool, UseGraalJIT, false, EXPERIMENTAL,                           \\\n+          \"Select the Graal JVMCI compiler. This is an alias for: \"         \\\n+          \"  -XX:+EnableJVMCIProduct \"                                      \\\n+          \"  -Djvmci.Compiler=graal \")                                      \\\n+                                                                            \\\n@@ -188,1 +193,1 @@\n-  static bool enable_jvmci_product_mode(JVMFlagOrigin);\n+  static bool enable_jvmci_product_mode(JVMFlagOrigin origin, bool use_graal_jit);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+  NONCOPYABLE(Dict);\n+  Dict& operator=(Dict&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Dict(Dict&&) = default;\n+\n","filename":"src\/hotspot\/share\/libadt\/dict.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,5 @@\n+  NONCOPYABLE(VectorSet);\n+  VectorSet& operator=(VectorSet&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  VectorSet(VectorSet&&) = default;\n+\n","filename":"src\/hotspot\/share\/libadt\/vectset.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    \/\/ All readers of _instance after the fence see non-nullptr.\n+    \/\/ All readers of _instance after the fence see non-null.\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-  assert(errstream != nullptr, \"errstream can not be nullptr\");\n+  assert(errstream != nullptr, \"errstream can not be null\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  \/\/ Create a new output. Returns nullptr if failed.\n+  \/\/ Create a new output. Returns null if failed.\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  \/\/ Setting this to nullptr will disable prefixing.\n+  \/\/ Setting this to null will disable prefixing.\n","filename":"src\/hotspot\/share\/logging\/logMessageBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  \/\/ Constructor to support creation from typed (likely nullptr) pointer. Mostly used by the logging framework.\n+  \/\/ Constructor to support creation from typed (likely null) pointer. Mostly used by the logging framework.\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-  assert(loader_data != nullptr, \"Should never pass around a nullptr loader_data. \"\n+  assert(loader_data != nullptr, \"Should never pass around a null loader_data. \"\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  assert(base() != nullptr, \"Base pointer nullptr\");\n+  assert(base() != nullptr, \"Base pointer null\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-    UL(info, \"allocation failed, returned nullptr.\");\n+    UL(info, \"allocation failed, returned null.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-          assert(m != nullptr, \"archived mirrors should not be nullptr\");\n+          assert(m != nullptr, \"archived mirrors should not be null\");\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-    if (UseCompressedClassPointers && !UseSharedSpaces &&\n+    if (UseCompressedClassPointers && !UseSharedSpaces && !DumpSharedSpaces &&\n@@ -598,1 +598,1 @@\n-      log_trace(gc, heap, coops)(\"Trying to allocate at address nullptr heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n+      log_trace(gc, heap, coops)(\"Trying to allocate at address null heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -888,1 +888,1 @@\n-  LogStream* log_stream = NULL;\n+  LogStream* log_stream = nullptr;\n@@ -906,1 +906,1 @@\n-    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n+    assert(resolved_references->obj_at(appendix_index) == nullptr, \"init just once\");\n@@ -914,1 +914,1 @@\n-  if (log_stream != NULL) {\n+  if (log_stream != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,\n+Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseValues* phase,\n@@ -889,0 +889,28 @@\n+\n+  \/\/ Propagate xor through constant cmoves. This pattern can occur after expansion of Conv2B nodes.\n+  const TypeInt* in2_type = phase->type(in2)->isa_int();\n+  if (in1->Opcode() == Op_CMoveI && in2_type != nullptr && in2_type->is_con()) {\n+    int in2_val = in2_type->get_con();\n+\n+    \/\/ Get types of both sides of the CMove\n+    const TypeInt* left = phase->type(in1->in(CMoveNode::IfFalse))->isa_int();\n+    const TypeInt* right = phase->type(in1->in(CMoveNode::IfTrue))->isa_int();\n+\n+    \/\/ Ensure that both sides are int constants\n+    if (left != nullptr && right != nullptr && left->is_con() && right->is_con()) {\n+      Node* cond = in1->in(CMoveNode::Condition);\n+\n+      \/\/ Check that the comparison is a bool and that the cmp node type is correct\n+      if (cond->is_Bool()) {\n+        int cmp_op = cond->in(1)->Opcode();\n+\n+        if (cmp_op == Op_CmpI || cmp_op == Op_CmpP) {\n+          int l_val = left->get_con();\n+          int r_val = right->get_con();\n+\n+          return new CMoveINode(cond, phase->intcon(l_val ^ in2_val), phase->intcon(r_val ^ in2_val), TypeInt::INT);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1005,0 +1033,8 @@\n+Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxINode(a, b);\n+  } else {\n+    return new MinINode(a, b);\n+  }\n+}\n+\n@@ -1019,7 +1055,2 @@\n-    if (is_max) {\n-      res =  gvn.transform(new MaxINode(a, b));\n-      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-    } else {\n-      Node* res =  gvn.transform(new MinINode(a, b));\n-      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-    }\n+    res = gvn.transform(build_min_max_int(a, b, is_max));\n+    assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -1070,12 +1101,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.\n-const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Otherwise just MAX them bits.\n-  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n-}\n-\n-\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow\n+\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow.\n@@ -1089,14 +1109,16 @@\n-\/\/ Ideal transformations for MaxINode\n-Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  \/\/ Force a right-spline graph\n-  Node* l = in(1);\n-  Node* r = in(2);\n-  \/\/ Transform  MaxI1(MaxI2(a, b), c)  into  MaxI1(a, MaxI2(b, c))\n-  \/\/ to force a right-spline graph for the rest of MaxINode::Ideal().\n-  if (l->Opcode() == Op_MaxI) {\n-    assert(l != l->in(1), \"dead loop in MaxINode::Ideal\");\n-    r = phase->transform(new MaxINode(l->in(2), r));\n-    l = l->in(1);\n-    set_req_X(1, l, phase);\n-    set_req_X(2, r, phase);\n-    return this;\n+\/\/ Let <x, x_off> = x_operands and <y, y_off> = y_operands.\n+\/\/ If x == y and neither add(x, x_off) nor add(y, y_off) overflow, return\n+\/\/ add(x, op(x_off, y_off)). Otherwise, return nullptr.\n+Node* MaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n+  Node* x = x_operands.first;\n+  Node* y = y_operands.first;\n+  int opcode = Opcode();\n+  assert(opcode == Op_MaxI || opcode == Op_MinI, \"Unexpected opcode\");\n+  const TypeInt* tx = phase->type(x)->isa_int();\n+  jint x_off = x_operands.second;\n+  jint y_off = y_operands.second;\n+  if (x == y && tx != nullptr &&\n+      !can_overflow(tx, x_off) &&\n+      !can_overflow(tx, y_off)) {\n+    jint c = opcode == Op_MinI ? MIN2(x_off, y_off) : MAX2(x_off, y_off);\n+    return new AddINode(x, phase->intcon(c));\n@@ -1104,0 +1126,2 @@\n+  return nullptr;\n+}\n@@ -1105,9 +1129,7 @@\n-  \/\/ Get left input & constant\n-  Node* x = l;\n-  jint x_off = 0;\n-  if (x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n-      x->in(2)->is_Con()) {\n-    const Type* t = x->in(2)->bottom_type();\n-    if (t == Type::TOP) return nullptr;  \/\/ No progress\n-    x_off = t->is_int()->get_con();\n-    x = x->in(1);\n+\/\/ Try to cast n as an integer addition with a constant. Return:\n+\/\/   <x, C>,       if n == add(x, C), where 'C' is a non-TOP constant;\n+\/\/   <nullptr, 0>, if n == add(x, C), where 'C' is a TOP constant; or\n+\/\/   <n, 0>,       otherwise.\n+static ConstAddOperands as_add_with_constant(Node* n) {\n+  if (n->Opcode() != Op_AddI) {\n+    return ConstAddOperands(n, 0);\n@@ -1115,11 +1137,4 @@\n-\n-  \/\/ Scan a right-spline-tree for MAXs\n-  Node* y = r;\n-  jint y_off = 0;\n-  \/\/ Check final part of MAX tree\n-  if (y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n-      y->in(2)->is_Con()) {\n-    const Type* t = y->in(2)->bottom_type();\n-    if (t == Type::TOP) return nullptr;  \/\/ No progress\n-    y_off = t->is_int()->get_con();\n-    y = y->in(1);\n+  Node* x = n->in(1);\n+  Node* c = n->in(2);\n+  if (!c->is_Con()) {\n+    return ConstAddOperands(n, 0);\n@@ -1127,3 +1142,3 @@\n-  if (x->_idx > y->_idx && r->Opcode() != Op_MaxI) {\n-    swap_edges(1, 2);\n-    return this;\n+  const Type* c_type = c->bottom_type();\n+  if (c_type == Type::TOP) {\n+    return ConstAddOperands(nullptr, 0);\n@@ -1131,0 +1146,2 @@\n+  return ConstAddOperands(x, c_type->is_int()->get_con());\n+}\n@@ -1132,12 +1149,15 @@\n-  const TypeInt* tx = phase->type(x)->isa_int();\n-\n-  if (r->Opcode() == Op_MaxI) {\n-    assert(r != r->in(2), \"dead loop in MaxINode::Ideal\");\n-    y = r->in(1);\n-    \/\/ Check final part of MAX tree\n-    if (y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n-        y->in(2)->is_Con()) {\n-      const Type* t = y->in(2)->bottom_type();\n-      if (t == Type::TOP) return nullptr;  \/\/ No progress\n-      y_off = t->is_int()->get_con();\n-      y = y->in(1);\n+Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+  int opcode = Opcode();\n+  assert(opcode == Op_MinI || opcode == Op_MaxI, \"Unexpected opcode\");\n+  \/\/ Try to transform the following pattern, in any of its four possible\n+  \/\/ permutations induced by op's commutativity:\n+  \/\/     op(op(add(inner, inner_off), inner_other), add(outer, outer_off))\n+  \/\/ into\n+  \/\/     op(add(inner, op(inner_off, outer_off)), inner_other),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  for (uint inner_op_index = 1; inner_op_index <= 2; inner_op_index++) {\n+    if (in(inner_op_index)->Opcode() != opcode) {\n+      continue;\n@@ -1145,10 +1165,4 @@\n-\n-    if (x->_idx > y->_idx)\n-      return new MaxINode(r->in(1), phase->transform(new MaxINode(l, r->in(2))));\n-\n-    \/\/ Transform MAX2(x + c0, MAX2(x + c1, z)) into MAX2(x + MAX2(c0, c1), z)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new MaxINode(phase->transform(new AddINode(x, phase->intcon(MAX2(x_off, y_off)))), r->in(2));\n+    Node* outer_add = in(inner_op_index == 1 ? 2 : 1);\n+    ConstAddOperands outer_add_operands = as_add_with_constant(outer_add);\n+    if (outer_add_operands.first == nullptr) {\n+      return nullptr; \/\/ outer_add has a TOP input, no need to continue.\n@@ -1156,7 +1170,17 @@\n-  } else {\n-    \/\/ Transform MAX2(x + c0, y + c1) into x + MAX2(c0, c1)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new AddINode(x, phase->intcon(MAX2(x_off, y_off)));\n+    \/\/ One operand is a MinI\/MaxI and the other is an integer addition with\n+    \/\/ constant. Test the operands of the inner MinI\/MaxI.\n+    for (uint inner_add_index = 1; inner_add_index <= 2; inner_add_index++) {\n+      Node* inner_op = in(inner_op_index);\n+      Node* inner_add = inner_op->in(inner_add_index);\n+      ConstAddOperands inner_add_operands = as_add_with_constant(inner_add);\n+      if (inner_add_operands.first == nullptr) {\n+        return nullptr; \/\/ inner_add has a TOP input, no need to continue.\n+      }\n+      \/\/ Try to extract the inner add.\n+      Node* add_extracted = extract_add(phase, inner_add_operands, outer_add_operands);\n+      if (add_extracted == nullptr) {\n+        continue;\n+      }\n+      Node* add_transformed = phase->transform(add_extracted);\n+      Node* inner_other = inner_op->in(inner_add_index == 1 ? 2 : 1);\n+      return build_min_max_int(add_transformed, inner_other, opcode == Op_MaxI);\n@@ -1165,1 +1189,28 @@\n- return nullptr;\n+  \/\/ Try to transform\n+  \/\/     op(add(x, x_off), add(y, y_off))\n+  \/\/ into\n+  \/\/     add(x, op(x_off, y_off)),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  ConstAddOperands xC = as_add_with_constant(in(1));\n+  ConstAddOperands yC = as_add_with_constant(in(2));\n+  if (xC.first == nullptr || yC.first == nullptr) return nullptr;\n+  return extract_add(phase, xC, yC);\n+}\n+\n+\/\/ Ideal transformations for MaxINode\n+Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return IdealI(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------add_ring---------------------------------------\n+\/\/ Supplied function returns the sum of the inputs.\n+const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n+  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n+  const TypeInt *r1 = t1->is_int();\n+\n+  \/\/ Otherwise just MAX them bits.\n+  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n@@ -1172,77 +1223,2 @@\n-Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  Node *progress = nullptr;\n-  \/\/ Force a right-spline graph\n-  Node *l = in(1);\n-  Node *r = in(2);\n-  \/\/ Transform  MinI1( MinI2(a,b), c)  into  MinI1( a, MinI2(b,c) )\n-  \/\/ to force a right-spline graph for the rest of MinINode::Ideal().\n-  if( l->Opcode() == Op_MinI ) {\n-    assert( l != l->in(1), \"dead loop in MinINode::Ideal\" );\n-    r = phase->transform(new MinINode(l->in(2),r));\n-    l = l->in(1);\n-    set_req_X(1, l, phase);\n-    set_req_X(2, r, phase);\n-    return this;\n-  }\n-\n-  \/\/ Get left input & constant\n-  Node *x = l;\n-  jint x_off = 0;\n-  if( x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n-      x->in(2)->is_Con() ) {\n-    const Type *t = x->in(2)->bottom_type();\n-    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-    x_off = t->is_int()->get_con();\n-    x = x->in(1);\n-  }\n-\n-  \/\/ Scan a right-spline-tree for MINs\n-  Node *y = r;\n-  jint y_off = 0;\n-  \/\/ Check final part of MIN tree\n-  if( y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n-      y->in(2)->is_Con() ) {\n-    const Type *t = y->in(2)->bottom_type();\n-    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-    y_off = t->is_int()->get_con();\n-    y = y->in(1);\n-  }\n-  if( x->_idx > y->_idx && r->Opcode() != Op_MinI ) {\n-    swap_edges(1, 2);\n-    return this;\n-  }\n-\n-  const TypeInt* tx = phase->type(x)->isa_int();\n-\n-  if( r->Opcode() == Op_MinI ) {\n-    assert( r != r->in(2), \"dead loop in MinINode::Ideal\" );\n-    y = r->in(1);\n-    \/\/ Check final part of MIN tree\n-    if( y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n-        y->in(2)->is_Con() ) {\n-      const Type *t = y->in(2)->bottom_type();\n-      if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-      y_off = t->is_int()->get_con();\n-      y = y->in(1);\n-    }\n-\n-    if( x->_idx > y->_idx )\n-      return new MinINode(r->in(1),phase->transform(new MinINode(l,r->in(2))));\n-\n-    \/\/ Transform MIN2(x + c0, MIN2(x + c1, z)) into MIN2(x + MIN2(c0, c1), z)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new MinINode(phase->transform(new AddINode(x, phase->intcon(MIN2(x_off, y_off)))), r->in(2));\n-    }\n-  } else {\n-    \/\/ Transform MIN2(x + c0, y + c1) into x + MIN2(c0, c1)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new AddINode(x,phase->intcon(MIN2(x_off,y_off)));\n-    }\n-  }\n-  return nullptr;\n+Node* MinINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return IdealI(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":140,"deletions":164,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -35,0 +36,1 @@\n+typedef const Pair<Node*, jint> ConstAddOperands;\n@@ -169,1 +171,1 @@\n-  static Node* Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,\n+  static Node* Ideal_base_and_offset(Node* ptr, PhaseValues* phase,\n@@ -255,0 +257,1 @@\n+  Node* extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands);\n@@ -261,0 +264,1 @@\n+  Node* IdealI(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -675,1 +675,1 @@\n-bool ArrayCopyNode::may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call) {\n+bool ArrayCopyNode::may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call) {\n@@ -686,2 +686,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac) {\n-\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode*& ac) {\n@@ -728,1 +727,1 @@\n-bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {\n+bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  static bool may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call);\n+  static bool may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call);\n@@ -176,1 +176,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -182,1 +182,1 @@\n-  static bool may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac);\n+  static bool may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode*& ac);\n@@ -186,1 +186,1 @@\n-  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const;\n+  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -1584,1 +1584,1 @@\n-Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {\n+Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseValues* phase, bool allow_new_nodes) {\n@@ -2198,1 +2198,1 @@\n-bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -632,1 +632,1 @@\n-  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -916,1 +916,1 @@\n-  virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) { return false;}\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) { return false;}\n@@ -925,1 +925,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase);\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase);\n@@ -930,1 +930,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase,\n@@ -934,1 +934,1 @@\n-  static Node* Ideal_klass(Node* ptr, PhaseTransform* phase) {\n+  static Node* Ideal_klass(Node* ptr, PhaseValues* phase) {\n@@ -1000,1 +1000,1 @@\n-  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseTransform *phase, bool can_create = true);\n+  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseValues* phase, bool can_create = true);\n@@ -1004,1 +1004,1 @@\n-  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseTransform* phase) {\n+  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseValues* phase) {\n@@ -1074,1 +1074,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase){ return false;}\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase){ return false; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1092,3 +1092,2 @@\n-  Arena *a = Thread::current()->resource_area();\n-  Node_Array node_map = new Node_Array(a);\n-  Node_Stack stack(a, C->live_nodes() >> 4);\n+  Node_Array node_map;\n+  Node_Stack stack(C->live_nodes() >> 4);\n@@ -1461,1 +1460,1 @@\n-Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {\n+Node* PhiNode::unique_input(PhaseValues* phase, bool uncast) {\n@@ -1526,0 +1525,6 @@\n+\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -1568,3 +1573,4 @@\n-  Node *n = new Conv2BNode(cmp->in(1));\n-  if( flipped )\n-    n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flipped) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -222,2 +222,2 @@\n-  Node* unique_input(PhaseTransform *phase, bool uncast);\n-  Node* unique_input(PhaseTransform *phase) {\n+  Node* unique_input(PhaseValues* phase, bool uncast);\n+  Node* unique_input(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n@@ -433,1 +433,2 @@\n-      worklist->push(n->unique_out());\n+      assert(useful.member(n->unique_out()), \"do not push a useless node\");\n+      worklist.push(n->unique_out());\n@@ -633,1 +634,3 @@\n-                  _for_igvn(nullptr),\n+                  _igvn_worklist(nullptr),\n+                  _types(nullptr),\n+                  _node_hash(nullptr),\n@@ -706,3 +709,0 @@\n-  \/\/ Node list that Iterative GVN will start with\n-  Unique_Node_List for_igvn(comp_arena());\n-  set_for_igvn(&for_igvn);\n@@ -713,1 +713,4 @@\n-  PhaseGVN gvn(node_arena(), estimated_size);\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), estimated_size);\n+  PhaseGVN gvn;\n@@ -803,1 +806,1 @@\n-      PhaseRemoveUseless pru(initial_gvn(), &for_igvn);\n+      PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -920,1 +923,3 @@\n-    _for_igvn(nullptr),\n+    _igvn_worklist(nullptr),\n+    _types(nullptr),\n+    _node_hash(nullptr),\n@@ -952,0 +957,3 @@\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), 255);\n@@ -953,4 +961,1 @@\n-    \/\/ The following is a dummy for the sake of GraphKit::gen_stub\n-    Unique_Node_List for_igvn(comp_arena());\n-    set_for_igvn(&for_igvn);  \/\/ not used, but some GraphKit guys push on this\n-    PhaseGVN gvn(Thread::current()->resource_area(),255);\n+    PhaseGVN gvn;\n@@ -1952,1 +1957,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -1983,3 +1988,1 @@\n-    assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n-    for_igvn()->clear();\n-    gvn->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2048,1 +2051,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -2052,1 +2055,1 @@\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2095,2 +2098,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2113,1 +2115,2 @@\n-  assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n+\n+  igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2117,2 +2120,0 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n@@ -2140,2 +2141,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2274,4 +2274,1 @@\n-    initial_gvn()->replace_with(&igvn);\n-    Unique_Node_List* old_worklist = for_igvn();\n-    old_worklist->clear();\n-    Unique_Node_List new_worklist(C->comp_arena());\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2280,1 +2277,1 @@\n-      PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &new_worklist);\n+      PhaseRenumberLive prl(initial_gvn(), *igvn_worklist());\n@@ -2282,3 +2279,1 @@\n-    Unique_Node_List* save_for_igvn = for_igvn();\n-    set_for_igvn(&new_worklist);\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2286,1 +2281,0 @@\n-    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2383,1 +2377,1 @@\n-    igvn = ccp;\n+    igvn.reset_from_igvn(&ccp);\n@@ -2447,0 +2441,4 @@\n+ \/\/ We will never use the NodeHash table any more. Clear it so that final_graph_reshaping does not have\n+ \/\/ to remove hashes to unlock nodes for modifications.\n+ C->node_hash()->clear();\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+class NodeHash;\n@@ -90,0 +91,1 @@\n+class Type_Array;\n@@ -417,1 +419,10 @@\n-  Unique_Node_List*     _for_igvn;              \/\/ Initial work-list for next round of Iterative GVN\n+\n+  \/\/ Shared worklist for all IGVN rounds. Nodes can be pushed to it at any time.\n+  \/\/ If pushed outside IGVN, the Node is processed in the next IGVN round.\n+  Unique_Node_List*     _igvn_worklist;\n+\n+  \/\/ Shared type array for GVN, IGVN and CCP. It maps node idx -> Type*.\n+  Type_Array*           _types;\n+\n+  \/\/ Shared node hash table for GVN, IGVN and CCP.\n+  NodeHash*             _node_hash;\n@@ -664,0 +675,6 @@\n+  void dump_igv(const char* graph_name, int level = 3) {\n+    if (should_print_igv(level)) {\n+      _igv_printer->print_method(graph_name, level);\n+    }\n+  }\n+\n@@ -940,1 +957,12 @@\n-  Unique_Node_List* for_igvn()                  { return _for_igvn; }\n+  Unique_Node_List* igvn_worklist() {\n+    assert(_igvn_worklist != nullptr, \"must be created in Compile::Compile\");\n+    return _igvn_worklist;\n+  }\n+  Type_Array* types() {\n+    assert(_types != nullptr, \"must be created in Compile::Compile\");\n+    return _types;\n+  }\n+  NodeHash* node_hash() {\n+    assert(_node_hash != nullptr, \"must be created in Compile::Compile\");\n+    return _node_hash;\n+  }\n@@ -944,1 +972,0 @@\n-  void          set_for_igvn(Unique_Node_List *for_igvn) { _for_igvn = for_igvn; }\n@@ -953,1 +980,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -64,0 +66,24 @@\n+Node* Conv2BNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!Matcher::match_rule_supported(Op_Conv2B)) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      \/\/ Get type of comparison to make\n+      const Type* t = phase->type(in(1));\n+      Node* cmp = nullptr;\n+      if (t->isa_int()) {\n+        cmp = phase->transform(new CmpINode(in(1), phase->intcon(0)));\n+      } else if (t->isa_ptr()) {\n+        cmp = phase->transform(new CmpPNode(in(1), phase->zerocon(BasicType::T_OBJECT)));\n+      } else {\n+        assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[in(1)->Opcode()]);\n+      }\n+\n+      \/\/ Replace Conv2B with the cmove\n+      Node* bol = phase->transform(new BoolNode(cmp, BoolTest::eq));\n+      return new CMoveINode(bol, phase->intcon(1), phase->intcon(0), TypeInt::BOOL);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  Conv2BNode( Node *i ) : Node(0,i) {}\n+  Conv2BNode(Node* i) : Node(nullptr, i) {}\n@@ -40,0 +40,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1739,1 +1739,1 @@\n-int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseTransform* phase) {\n+int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseValues* phase) {\n@@ -2501,1 +2501,1 @@\n-int ConnectionGraph::address_offset(Node* adr, PhaseTransform *phase) {\n+int ConnectionGraph::address_offset(Node* adr, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  int find_init_values_null   (JavaObjectNode* ptn, PhaseTransform* phase);\n+  int find_init_values_null   (JavaObjectNode* ptn, PhaseValues* phase);\n@@ -529,1 +529,1 @@\n-  int address_offset(Node* adr, PhaseTransform *phase);\n+  int address_offset(Node* adr, PhaseValues* phase);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3921,1 +3921,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase) {\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase) {\n@@ -3948,1 +3948,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase,\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1272,1 +1272,1 @@\n-    Node_Array inputs = new Node_List();\n+    Node_Array inputs;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -834,1 +834,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, BasicType bt, Node *iv, Node *&range,\n@@ -836,0 +836,1 @@\n+  IfNode* iff = if_success_proj->in(0)->as_If();\n@@ -843,1 +844,37 @@\n-  if (bol->_test._test != BoolTest::lt) {\n+  if (bol->_test._test != BoolTest::lt || if_success_proj->is_IfFalse()) {\n+    \/\/ We don't have the required range check pattern:\n+    \/\/ if (scale*iv + offset <u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ Having the trap on the true projection:\n+    \/\/ if (scale*iv + offset <u limit) {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ is not correct. We would need to flip the test to get the expected \"trap on false path\" pattern:\n+    \/\/ if (scale*iv + offset >=u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ If we create a Hoisted Range Check Predicate for this wrong pattern, it could succeed at runtime (i.e. true\n+    \/\/ for the value of \"scale*iv + offset\" in the first loop iteration and true for the value of \"scale*iv + offset\"\n+    \/\/ in the last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Loop: \"for (int i = -1; i < 1000; i++)\"\n+    \/\/ init = \"scale*iv + offset\" in the first loop iteration = 1*-1 + 0 = -1\n+    \/\/ last = \"scale*iv + offset\" in the last loop iteration = 1*999 + 0 = 999\n+    \/\/ limit = 100\n+    \/\/\n+    \/\/ Hoisted Range Check Predicate is always true:\n+    \/\/ init >=u limit && last >=u limit  <=>\n+    \/\/ -1 >=u 100 && 999 >= u 100\n+    \/\/\n+    \/\/ But for 0 <= x < 100: x >=u 100 is false.\n+    \/\/ We would wrongly skip the branch with the trap() and possibly miss to execute some other statements inside that\n+    \/\/ trap() branch.\n@@ -874,1 +911,1 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+bool IdealLoopTree::is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n@@ -881,1 +918,1 @@\n-  if (!is_range_check_if(iff, phase, T_INT, iv, range, offset, scale)) {\n+  if (!is_range_check_if(if_success_proj, phase, T_INT, iv, range, offset, scale)) {\n@@ -934,4 +971,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                                       int scale, Node* offset,\n-                                       Node* init, Node* limit, jint stride,\n-                                       Node* range, bool upper, bool &overflow, bool negate) {\n+BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n+                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n@@ -1063,1 +1098,1 @@\n-  BoolNode* bol = new BoolNode(cmp, negate ? BoolTest::ge : BoolTest::lt);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::lt);\n@@ -1326,1 +1361,1 @@\n-bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n@@ -1331,1 +1366,1 @@\n-  IfNode*   iff  = if_proj->in(0)->as_If();\n+  IfNode*   iff  = if_success_proj->in(0)->as_If();\n@@ -1347,1 +1382,1 @@\n-    if (if_proj->is_IfFalse()) {\n+    if (if_success_proj->is_IfFalse()) {\n@@ -1364,1 +1399,1 @@\n-  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(if_success_proj, this, invar DEBUG_ONLY(COMMA parse_predicate_proj))) {\n@@ -1366,0 +1401,1 @@\n+    assert(if_success_proj->is_IfTrue(), \"trap must be on false projection for a range check\");\n@@ -1400,3 +1436,0 @@\n-    \/\/ Negate test if necessary (Parse Predicates always have IfTrue as success projection and IfFalse as uncommon trap)\n-    const bool negate = (if_proj->is_IfFalse());\n-\n@@ -1404,1 +1437,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow, negate);\n+    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1411,1 +1444,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n@@ -1414,1 +1447,2 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow, negate);\n+    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n+                                             overflow);\n@@ -1421,1 +1455,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d\", lower_bound_iff->_idx);\n@@ -1426,1 +1460,1 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_proj, parse_predicate_proj, upper_bound_proj, scale,\n+    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n@@ -1442,1 +1476,1 @@\n-  invar.map_ctrl(if_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n+  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n@@ -1445,1 +1479,1 @@\n-  dominated_by(new_predicate_proj, iff, if_proj->_con != new_predicate_proj->_con );\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con);\n@@ -1462,1 +1496,2 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+                               (stride > 0) != (scale > 0), overflow);\n@@ -1484,1 +1519,2 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+                     overflow);\n@@ -1802,0 +1838,3 @@\n+\/\/ Only initialize if Parse Predicate projection itself or any of the Parse Predicate projections coming further up\n+\/\/ in the graph are not already initialized (this would be a sign of repeated Parse Predicates which are not cleaned up,\n+\/\/ yet).\n@@ -1814,1 +1853,2 @@\n-      if (_profiled_loop_predicate_proj != nullptr) {\n+      if (_profiled_loop_predicate_proj != nullptr ||\n+          _loop_predicate_proj != nullptr) {\n@@ -1820,1 +1860,3 @@\n-      if (_loop_limit_check_predicate_proj != nullptr) {\n+      if (_loop_limit_check_predicate_proj != nullptr ||\n+          _loop_predicate_proj != nullptr ||\n+          _profiled_loop_predicate_proj != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":69,"deletions":27,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2861,1 +2861,1 @@\n-                               limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n+                               limit, (stride_con > 0) != (scale_con > 0), overflow);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,2 +262,2 @@\n-  if (_nodes[n->_idx]) return;\n-  \/\/ Recursively set _nodes array to indicate where the Node goes\n+  if (_loop_or_ctrl[n->_idx]) return;\n+  \/\/ Recursively set _loop_or_ctrl array to indicate where the Node goes\n@@ -1092,1 +1092,2 @@\n-      CallStaticJavaNode* call = c->as_IfProj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+      IfProjNode* if_proj = c->as_IfProj();\n+      CallStaticJavaNode* call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n@@ -1097,2 +1098,1 @@\n-        RangeCheckNode* rc = c->in(0)->as_RangeCheck();\n-        if (loop->is_range_check_if(rc, this, T_LONG, phi, range, offset, scale) &&\n+        if (loop->is_range_check_if(if_proj, this, T_LONG, phi, range, offset, scale) &&\n@@ -4304,2 +4304,2 @@\n-  _nodes.map(C->unique(), nullptr);\n-  memset(_nodes.adr(), 0, wordSize * C->unique());\n+  _loop_or_ctrl.map(C->unique(), nullptr);\n+  memset(_loop_or_ctrl.adr(), 0, wordSize * C->unique());\n@@ -4371,1 +4371,1 @@\n-      _nodes.clear();\n+      _loop_or_ctrl.clear();\n@@ -4401,1 +4401,1 @@\n-      if( !_nodes[C->root()->in(i)->_idx] ) {    \/\/ Dead path into Root?\n+      if (!_loop_or_ctrl[C->root()->in(i)->_idx]) { \/\/ Dead path into Root?\n@@ -4415,1 +4415,1 @@\n-  \/\/ node.  For CFG nodes, the _nodes array starts out and remains\n+  \/\/ node.  For CFG nodes, the _loop_or_ctrl array starts out and remains\n@@ -4417,1 +4417,1 @@\n-  \/\/ _nodes array holds the earliest legal controlling CFG node.\n+  \/\/ _loop_or_ctrl array holds the earliest legal controlling CFG node.\n@@ -4722,1 +4722,1 @@\n-    success &= verify_nodes(n, phase_verify);\n+    success &= verify_loop_ctrl(n, phase_verify);\n@@ -4761,2 +4761,2 @@\n-\/\/ Verify \"_nodes\": control and loop membership.\n-\/\/  (0) _nodes[i] == nullptr -> node not reachable.\n+\/\/ Verify \"_loop_or_ctrl\": control and loop membership.\n+\/\/  (0) _loop_or_ctrl[i] == nullptr -> node not reachable.\n@@ -4766,1 +4766,1 @@\n-bool PhaseIdealLoop::verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const {\n+bool PhaseIdealLoop::verify_loop_ctrl(Node* n, const PhaseIdealLoop* phase_verify) const {\n@@ -4771,2 +4771,2 @@\n-  if (_nodes[i] == nullptr || phase_verify->_nodes[i] == nullptr) {\n-    if (_nodes[i] != nullptr || phase_verify->_nodes[i] != nullptr) {\n+  if (_loop_or_ctrl[i] == nullptr || phase_verify->_loop_or_ctrl[i] == nullptr) {\n+    if (_loop_or_ctrl[i] != nullptr || phase_verify->_loop_or_ctrl[i] != nullptr) {\n@@ -4774,1 +4774,1 @@\n-                 _nodes[i] != nullptr, phase_verify->_nodes[i] != nullptr);\n+                 _loop_or_ctrl[i] != nullptr, phase_verify->_loop_or_ctrl[i] != nullptr);\n@@ -4803,1 +4803,1 @@\n-    if( _nodes[i] != loop_verify->_nodes[i] &&\n+    if( _loop_or_ctrl[i] != loop_verify->_loop_or_ctrl[i] &&\n@@ -5037,1 +5037,1 @@\n-      \/\/ heal _idom if it has a fwd mapping in _nodes\n+      \/\/ heal _idom if it has a fwd mapping in _loop_or_ctrl\n@@ -5108,1 +5108,1 @@\n-\/\/ bits.  The _nodes[] array is mapped by Node index and holds a null for\n+\/\/ bits.  The _loop_or_ctrl[] array is mapped by Node index and holds a null for\n@@ -5234,1 +5234,1 @@\n-      if( !_nodes[m->_idx] ) continue; \/\/ Dead code has no loop\n+      if (!_loop_or_ctrl[m->_idx]) continue; \/\/ Dead code has no loop\n@@ -5461,1 +5461,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_or_ctrl[]->loop mapping.\n@@ -5490,1 +5490,1 @@\n-            _nodes.map(n->_idx, (Node*)(ilt->_parent) );\n+            _loop_or_ctrl.map(n->_idx, (Node*)(ilt->_parent));\n@@ -5649,1 +5649,1 @@\n-    if (_nodes[c->_idx] == nullptr)\n+    if (_loop_or_ctrl[c->_idx] == nullptr)\n@@ -5912,1 +5912,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_or_ctrl[]->loop mapping.\n@@ -5922,1 +5922,1 @@\n-      assert( _nodes[n->_idx], \"no dead nodes\" );\n+      assert(_loop_or_ctrl[n->_idx], \"no dead nodes\");\n@@ -5930,1 +5930,1 @@\n-        if( _nodes[use->_idx] != nullptr || use->is_top() ) { \/\/ Not dead?\n+        if (_loop_or_ctrl[use->_idx] != nullptr || use->is_top()) { \/\/ Not dead?\n@@ -6001,1 +6001,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_or_ctrl[]->loop mapping.\n@@ -6070,1 +6070,1 @@\n-      _nodes.map(n->_idx,0);    \/\/ No block setting, it's globally dead\n+      _loop_or_ctrl.map(n->_idx,0);    \/\/ No block setting, it's globally dead\n@@ -6085,1 +6085,1 @@\n-      assert( _nodes[n->out(i1)->_idx] == nullptr, \"all uses must also be dead\");\n+      assert(_loop_or_ctrl[n->out(i1)->_idx] == nullptr, \"all uses must also be dead\");\n@@ -6088,1 +6088,1 @@\n-    _nodes.map(n->_idx, 0);     \/\/ This node is useless\n+    _loop_or_ctrl.map(n->_idx, 0);     \/\/ This node is useless\n@@ -6369,1 +6369,1 @@\n-    if (!_nodes[n->_idx])      \/\/ Skip dead nodes\n+    if (!_loop_or_ctrl[n->_idx])      \/\/ Skip dead nodes\n@@ -6402,1 +6402,1 @@\n-    for (uint k = 0; k < _nodes.max(); k++) {\n+    for (uint k = 0; k < _loop_or_ctrl.max(); k++) {\n@@ -6404,1 +6404,1 @@\n-      if (k < C->unique() && _nodes[k] == (Node*)((intptr_t)n + 1)) {\n+      if (k < C->unique() && _loop_or_ctrl[k] == (Node*)((intptr_t)n + 1)) {\n@@ -6408,2 +6408,2 @@\n-            tty->print_cr(\"*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p\",\n-                          _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : nullptr);\n+            tty->print_cr(\"*** BROKEN CTRL ACCESSOR!  _loop_or_ctrl[k] is %p, ctrl is %p\",\n+                          _loop_or_ctrl[k], has_ctrl(m) ? get_ctrl_no_update(m) : nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  bool can_be_counted_loop(PhaseTransform* phase) const {\n+  bool can_be_counted_loop(PhaseValues* phase) const {\n@@ -736,2 +736,2 @@\n-  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n-  bool is_range_check_if(IfNode* iff, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode* predicate_proj)) const;\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n@@ -835,0 +835,3 @@\n+  \/\/ Map loop membership for CFG nodes, and ctrl for non-CFG nodes.\n+  Node_List _loop_or_ctrl;\n+\n@@ -896,1 +899,1 @@\n-  bool has_ctrl(const Node* n) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n+  bool has_ctrl(const Node* n) const { return ((intptr_t)_loop_or_ctrl[n->_idx]) & 1; }\n@@ -984,1 +987,1 @@\n-    return _nodes[n->_idx] != nullptr;\n+    return _loop_or_ctrl[n->_idx] != nullptr;\n@@ -996,1 +999,1 @@\n-    _nodes.map( n->_idx, (Node*)((intptr_t)ctrl + 1) );\n+    _loop_or_ctrl.map(n->_idx, (Node*)((intptr_t)ctrl + 1));\n@@ -1016,1 +1019,1 @@\n-    _nodes.map( i->_idx, (Node*)((intptr_t)n + 1) );\n+    _loop_or_ctrl.map(i->_idx, (Node*)((intptr_t)n + 1));\n@@ -1035,1 +1038,1 @@\n-    return (Node*)(((intptr_t)_nodes[i->_idx]) & ~1);\n+    return (Node*)(((intptr_t)_loop_or_ctrl[i->_idx]) & ~1);\n@@ -1059,1 +1062,1 @@\n-    _nodes.map(n->_idx, (Node*)loop);\n+    _loop_or_ctrl.map(n->_idx, (Node*)loop);\n@@ -1069,1 +1072,1 @@\n-    _nodes.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n+    _loop_or_ctrl.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n@@ -1148,1 +1151,1 @@\n-      n = (Node*)(((intptr_t)_nodes[n->_idx]) & ~1);\n+      n = (Node*)(((intptr_t)_loop_or_ctrl[n->_idx]) & ~1);\n@@ -1244,1 +1247,1 @@\n-    return (IdealLoopTree*)_nodes[n->_idx];\n+    return (IdealLoopTree*)_loop_or_ctrl[n->_idx];\n@@ -1366,5 +1369,2 @@\n-  BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                         int scale, Node* offset,\n-                         Node* init, Node* limit, jint stride,\n-                         Node* range, bool upper, bool &overflow,\n-                         bool negate);\n+  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+                         jint stride, Node* range, bool upper, bool& overflow);\n@@ -1374,1 +1374,1 @@\n-  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n@@ -1486,1 +1486,1 @@\n-  void register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth);\n+  void register_node(Node* n, IdealLoopTree* loop, Node* pred, uint ddepth);\n@@ -1669,1 +1669,1 @@\n-    return _nodes[n->_idx] ? (IdealLoopTree*)_nodes[n->_idx] : _ltree_root;\n+    return _loop_or_ctrl[n->_idx] ? (IdealLoopTree*)_loop_or_ctrl[n->_idx] : _ltree_root;\n@@ -1684,1 +1684,1 @@\n-  bool verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_loop_ctrl(Node* n, const PhaseIdealLoop* phase_verify) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2714,1 +2714,1 @@\n-void PhaseIdealLoop::register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth) {\n+void PhaseIdealLoop::register_node(Node* n, IdealLoopTree* loop, Node* pred, uint ddepth) {\n@@ -2773,1 +2773,1 @@\n-  int ddepth = dom_depth(proj);\n+  uint ddepth = dom_depth(proj);\n@@ -2834,1 +2834,1 @@\n-  int ddepth = dom_depth(proj);\n+  uint ddepth = dom_depth(proj);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  _new_nodes(C->comp_arena()),\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+  \/\/ Map old nodes to new nodes\n+  Node_List   _new_nodes;\n+\n@@ -150,1 +153,0 @@\n-  \/\/ Accessors for the inherited field PhaseTransform::_nodes:\n@@ -152,1 +154,1 @@\n-    _nodes.map(idx_limit-1, nullptr);\n+    _new_nodes.map(idx_limit-1, nullptr);\n@@ -155,1 +157,1 @@\n-    return _nodes.at(n->_idx) != nullptr;\n+    return _new_nodes.at(n->_idx) != nullptr;\n@@ -159,1 +161,1 @@\n-    return _nodes.at(n->_idx);\n+    return _new_nodes.at(n->_idx);\n@@ -163,1 +165,1 @@\n-    _nodes.map(n->_idx, nn);\n+    _new_nodes.map(n->_idx, nn);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  static const Type* Value(const OverflowOp* node, PhaseTransform* phase) {\n+  static const Type* Value(const OverflowOp* node, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class PhaseTransform;\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-Node* LoadNode::find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n+Node* LoadNode::find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n@@ -611,1 +611,1 @@\n-ArrayCopyNode* MemNode::find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const {\n+ArrayCopyNode* MemNode::find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const {\n@@ -655,1 +655,1 @@\n-Node* MemNode::find_previous_store(PhaseTransform* phase) {\n+Node* MemNode::find_previous_store(PhaseValues* phase) {\n@@ -1057,1 +1057,1 @@\n-Node* MemNode::can_see_stored_value(Node* st, PhaseTransform* phase) const {\n+Node* MemNode::can_see_stored_value(Node* st, PhaseValues* phase) const {\n@@ -2850,1 +2850,1 @@\n-bool StoreNode::value_never_loaded( PhaseTransform *phase) const {\n+bool StoreNode::value_never_loaded(PhaseValues* phase) const {\n@@ -3140,1 +3140,1 @@\n-bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseTransform* phase) {\n+bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseValues* phase) {\n@@ -3692,1 +3692,1 @@\n-intptr_t InitializeNode::get_store_offset(Node* st, PhaseTransform* phase) {\n+intptr_t InitializeNode::get_store_offset(Node* st, PhaseValues* phase) {\n@@ -3886,1 +3886,1 @@\n-                                                   PhaseTransform* phase) {\n+                                                   PhaseValues* phase) {\n@@ -3940,1 +3940,1 @@\n-                                          PhaseTransform* phase) {\n+                                          PhaseValues* phase) {\n@@ -3956,1 +3956,1 @@\n-                                       PhaseTransform* phase) {\n+                                       PhaseGVN* phase) {\n@@ -4500,1 +4500,1 @@\n-bool InitializeNode::stores_are_sane(PhaseTransform* phase) {\n+bool InitializeNode::stores_are_sane(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n-  ArrayCopyNode* find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n+  ArrayCopyNode* find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const;\n@@ -149,1 +149,1 @@\n-  Node* find_previous_store(PhaseTransform* phase);\n+  Node* find_previous_store(PhaseValues* phase);\n@@ -153,1 +153,1 @@\n-  Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;\n+  Node* can_see_stored_value(Node* st, PhaseValues* phase) const;\n@@ -211,1 +211,1 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n@@ -636,1 +636,1 @@\n-  bool value_never_loaded(PhaseTransform *phase) const;\n+  bool value_never_loaded(PhaseValues* phase) const;\n@@ -1120,1 +1120,1 @@\n-  static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);\n+  static bool step_through(Node** np, uint instance_id, PhaseValues* phase);\n@@ -1357,1 +1357,1 @@\n-  bool stores_are_sane(PhaseTransform* phase);\n+  bool stores_are_sane(PhaseValues* phase);\n@@ -1371,1 +1371,1 @@\n-  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);\n+  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseValues* phase);\n@@ -1383,1 +1383,1 @@\n-                                     PhaseTransform* phase);\n+                                     PhaseValues* phase);\n@@ -1385,1 +1385,1 @@\n-  static intptr_t get_store_offset(Node* st, PhaseTransform* phase);\n+  static intptr_t get_store_offset(Node* st, PhaseValues* phase);\n@@ -1387,1 +1387,1 @@\n-  Node* make_raw_address(intptr_t offset, PhaseTransform* phase);\n+  Node* make_raw_address(intptr_t offset, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -210,0 +211,5 @@\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -241,3 +247,4 @@\n-  Node *n = new Conv2BNode( cmp->in(1) );\n-  if( flip )\n-  n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flip) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1554,0 +1554,6 @@\n+  Node_Array() : Node_Array(Thread::current()->resource_area()) {}\n+\n+  NONCOPYABLE(Node_Array);\n+  Node_Array& operator=(Node_Array&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_Array(Node_Array&&) = default;\n@@ -1555,1 +1561,0 @@\n-  Node_Array(Node_Array* na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n@@ -1579,0 +1584,6 @@\n+\n+  NONCOPYABLE(Node_List);\n+  Node_List& operator=(Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_List(Node_List&&) = default;\n+\n@@ -1613,0 +1624,5 @@\n+  NONCOPYABLE(Unique_Node_List);\n+  Unique_Node_List& operator=(Unique_Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Unique_Node_List(Unique_Node_List&&) = default;\n+\n@@ -1644,0 +1660,4 @@\n+  void ensure_empty() {\n+    assert(size() == 0, \"must be empty\");\n+    clear(); \/\/ just in case\n+  }\n@@ -1648,0 +1668,21 @@\n+  \/\/ If the idx of the Nodes change, we must recompute the VectorSet\n+  void recompute_idx_set() {\n+    _in_worklist.clear();\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      _in_worklist.set(n->_idx);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  bool is_subset_of(Unique_Node_List& other) {\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      if (!other.member(n)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+#endif\n+\n@@ -1690,1 +1731,1 @@\n-  _for_igvn->push(n);\n+  _igvn_worklist->push(n);\n@@ -1695,1 +1736,1 @@\n-  _for_igvn->remove(n);\n+  _igvn_worklist->remove(n);\n@@ -1766,0 +1807,2 @@\n+\n+  NONCOPYABLE(Node_Stack);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+  NONCOPYABLE(Phase);\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,16 +46,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(uint est_max_size) :\n-  _a(Thread::current()->resource_area()),\n-  _max( round_up(est_max_size < NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),\n-  _inserts(0), _insert_limit( insert_limit() ),\n-  _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) \/\/ (Node**)_a->Amalloc(_max * sizeof(Node*)) ),\n-#ifndef PRODUCT\n-  , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),\n-  _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),\n-   _total_inserts(0), _total_insert_probes(0)\n-#endif\n-{\n-  \/\/ _sentinel must be in the current node space\n-  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n-  memset(_table,0,sizeof(Node*)*_max);\n-}\n@@ -80,15 +64,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n-void NodeHash::replace_with(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n@@ -391,12 +360,0 @@\n-\n-void NodeHash::operator=(const NodeHash& nh) {\n-  \/\/ Unlock all nodes upon replacement of table.\n-  if (&nh == this)  return;\n-  if (_table != (Node**)badAddress)  clear();\n-  memcpy((void*)this, (void*)&nh, sizeof(*this));\n-  \/\/ Do not increment hash_lock counts again.\n-  \/\/ Instead, be sure we never again use the source table.\n-  ((NodeHash*)&nh)->_table = (Node**)badAddress;\n-}\n-\n-\n@@ -409,1 +366,1 @@\n-PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List* worklist, PhaseNumber phase_num) : Phase(phase_num) {\n+PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List& worklist, PhaseNumber phase_num) : Phase(phase_num) {\n@@ -423,1 +380,1 @@\n-  worklist->remove_useless_nodes(_useful.member_set());\n+  worklist.remove_useless_nodes(_useful.member_set());\n@@ -443,8 +400,5 @@\n-\/\/ (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be\n-\/\/ processed. A new worklist (with the updated node IDs) is returned in 'new_worklist'.\n-\/\/ 'worklist' is cleared upon returning.\n-\/\/ (2) Type information (the field PhaseGVN::_types) maps type information to each\n-\/\/ node ID. The mapping is updated to use the new node IDs as well. Updated type\n-\/\/ information is returned in PhaseGVN::_types.\n-\/\/\n-\/\/ The PhaseRenumberLive phase does not preserve the order of elements in the worklist.\n+\/\/ (1) The \"worklist\" is \"C->igvn_worklist()\", which is to collect which nodes need to\n+\/\/     be processed by IGVN after removal of the useless nodes.\n+\/\/ (2) Type information \"gvn->types()\" (same as \"C->types()\") maps every node ID to\n+\/\/     the node's type. The mapping is updated to use the new node IDs as well. We\n+\/\/     create a new map, and swap it with the old one.\n@@ -453,3 +407,2 @@\n-\/\/ numbering (the field PhaseGVN::_table) is not updated because computing the hash\n-\/\/ values is not based on node IDs. The field PhaseGVN::_nodes is not updated either\n-\/\/ because it is empty wherever PhaseRenumberLive is used.\n+\/\/ numbering (\"C->node_hash()\", referenced by PhaseValue::_table) is not updated because\n+\/\/ computing the hash values is not based on node IDs.\n@@ -457,1 +410,1 @@\n-                                     Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                                     Unique_Node_List& worklist,\n@@ -467,1 +420,0 @@\n-  assert(gvn->nodes_size() == 0, \"GVN must not contain any nodes at this point\");\n@@ -469,2 +421,2 @@\n-\n-  uint worklist_size = worklist->size();\n+  assert(&worklist == C->igvn_worklist(), \"reference still same as the one from Compile\");\n+  assert(&gvn->types() == C->types(), \"reference still same as that from Compile\");\n@@ -480,0 +432,2 @@\n+  assert(worklist.is_subset_of(_useful), \"only useful nodes should still be in the worklist\");\n+\n@@ -484,5 +438,0 @@\n-    bool in_worklist = false;\n-    if (worklist->member(n)) {\n-      in_worklist = true;\n-    }\n-\n@@ -502,4 +451,0 @@\n-    if (in_worklist) {\n-      new_worklist->push(n);\n-    }\n-\n@@ -511,1 +456,3 @@\n-  assert(worklist_size == new_worklist->size(), \"the new worklist must have the same size as the original worklist\");\n+  \/\/ VectorSet in Unique_Node_Set must be recomputed, since IDs have changed.\n+  worklist.recompute_idx_set();\n+\n@@ -523,1 +470,1 @@\n-  gvn->replace_types(_new_type_array);\n+  gvn->types().swap(_new_type_array);\n@@ -530,3 +477,0 @@\n-\n-  \/\/ Clear the original worklist\n-  worklist->clear();\n@@ -584,49 +528,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),\n-  _arena(Thread::current()->resource_area()),\n-  _nodes(_arena),\n-  _types(_arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(arena),\n-  _nodes(arena),\n-  _types(arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-\/\/ Initialize with previously generated type information\n-PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(pt->_arena),\n-  _nodes(pt->_nodes),\n-  _types(pt->_types)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-}\n-\n-void PhaseTransform::init_con_caches() {\n+void PhaseValues::init_con_caches() {\n@@ -638,1 +534,0 @@\n-\n@@ -640,1 +535,1 @@\n-const TypeInt* PhaseTransform::find_int_type(Node* n) {\n+const TypeInt* PhaseValues::find_int_type(Node* n) {\n@@ -652,1 +547,1 @@\n-const TypeLong* PhaseTransform::find_long_type(Node* n) {\n+const TypeLong* PhaseValues::find_long_type(Node* n) {\n@@ -660,61 +555,0 @@\n-\n-#ifndef PRODUCT\n-void PhaseTransform::dump_old2new_map() const {\n-  _nodes.dump();\n-}\n-\n-void PhaseTransform::dump_new( uint nidx ) const {\n-  for( uint i=0; i<_nodes.max(); i++ )\n-    if( _nodes[i] && _nodes[i]->_idx == nidx ) {\n-      _nodes[i]->dump();\n-      tty->cr();\n-      tty->print_cr(\"Old index= %d\",i);\n-      return;\n-    }\n-  tty->print_cr(\"Node %d not found in the new indices\", nidx);\n-}\n-\n-\/\/------------------------------dump_types-------------------------------------\n-void PhaseTransform::dump_types( ) const {\n-  _types.dump();\n-}\n-\n-\/\/------------------------------dump_nodes_and_types---------------------------\n-void PhaseTransform::dump_nodes_and_types(const Node* root, uint depth, bool only_ctrl) {\n-  VectorSet visited;\n-  dump_nodes_and_types_recur(root, depth, only_ctrl, visited);\n-}\n-\n-\/\/------------------------------dump_nodes_and_types_recur---------------------\n-void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited) {\n-  if( !n ) return;\n-  if( depth == 0 ) return;\n-  if( visited.test_set(n->_idx) ) return;\n-  for( uint i=0; i<n->len(); i++ ) {\n-    if( only_ctrl && !(n->is_Region()) && i != TypeFunc::Control ) continue;\n-    dump_nodes_and_types_recur( n->in(i), depth-1, only_ctrl, visited );\n-  }\n-  n->dump();\n-  if (type_or_null(n) != nullptr) {\n-    tty->print(\"      \"); type(n)->dump(); tty->cr();\n-  }\n-}\n-\n-#endif\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues( Arena *arena, uint est_max_size )\n-  : PhaseTransform(arena, GVN), _table(arena, est_max_size), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues(PhaseValues* ptv)\n-  : PhaseTransform(ptv, GVN), _table(&ptv->_table), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n@@ -724,0 +558,1 @@\n+  \/\/ Statistics for NodeHash\n@@ -725,1 +560,0 @@\n-\n@@ -740,1 +574,1 @@\n-ConNode* PhaseTransform::makecon(const Type *t) {\n+ConNode* PhaseValues::makecon(const Type* t) {\n@@ -777,1 +611,1 @@\n-ConINode* PhaseTransform::intcon(jint i) {\n+ConINode* PhaseValues::intcon(jint i) {\n@@ -793,1 +627,1 @@\n-ConLNode* PhaseTransform::longcon(jlong l) {\n+ConLNode* PhaseValues::longcon(jlong l) {\n@@ -806,1 +640,1 @@\n-ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+ConNode* PhaseValues::integercon(jlong l, BasicType bt) {\n@@ -817,1 +651,1 @@\n-ConNode* PhaseTransform::zerocon(BasicType bt) {\n+ConNode* PhaseValues::zerocon(BasicType bt) {\n@@ -974,4 +808,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : PhaseGVN(igvn),\n-                                                 _delay_transform(igvn->_delay_transform),\n-                                                 _stack(igvn->_stack ),\n-                                                 _worklist(igvn->_worklist)\n+PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : _delay_transform(igvn->_delay_transform),\n+                                                 _worklist(*C->igvn_worklist())\n@@ -980,0 +812,1 @@\n+  assert(&_worklist == &igvn->_worklist, \"sanity\");\n@@ -984,8 +817,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : PhaseGVN(gvn),\n-                                            _delay_transform(false),\n-\/\/ TODO: Before incremental inlining it was allocated only once and it was fine. Now that\n-\/\/       the constructor is used in incremental inlining, this consumes too much memory:\n-\/\/                                            _stack(C->live_nodes() >> 1),\n-\/\/       So, as a band-aid, we replace this by:\n-                                            _stack(C->comp_arena(), 32),\n-                                            _worklist(*C->for_igvn())\n+PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : _delay_transform(false),\n+                                            _worklist(*C->igvn_worklist())\n@@ -1471,2 +1298,3 @@\n-  assert(_stack.is_empty(), \"not empty\");\n-  _stack.push(dead, PROCESS_INPUTS);\n+  ResourceMark rm;\n+  Node_Stack stack(32);\n+  stack.push(dead, PROCESS_INPUTS);\n@@ -1474,2 +1302,2 @@\n-  while (_stack.is_nonempty()) {\n-    dead = _stack.node();\n+  while (stack.is_nonempty()) {\n+    dead = stack.node();\n@@ -1479,1 +1307,1 @@\n-    uint progress_state = _stack.index();\n+    uint progress_state = stack.index();\n@@ -1485,1 +1313,1 @@\n-      _stack.set_index(PROCESS_OUTPUTS);\n+      stack.set_index(PROCESS_OUTPUTS);\n@@ -1497,1 +1325,1 @@\n-              _stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n+              stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n@@ -1544,1 +1372,1 @@\n-      _stack.push(dead->raw_out(0), PROCESS_INPUTS);\n+      stack.push(dead->raw_out(0), PROCESS_INPUTS);\n@@ -1547,1 +1375,1 @@\n-      _stack.pop();\n+      stack.pop();\n@@ -1552,1 +1380,1 @@\n-  } \/\/ while (_stack.is_nonempty())\n+  } \/\/ while (stack.is_nonempty())\n@@ -1915,2 +1743,0 @@\n-  \/\/ Clear out _nodes from IterGVN.  Must be clear to transform call.\n-  _nodes.clear();               \/\/ Clear out from IterGVN\n@@ -2193,4 +2019,0 @@\n-  Node *new_node = _nodes[n->_idx]; \/\/ Check for transformed node\n-  if( new_node != nullptr )\n-    return new_node;                \/\/ Been there, done that, return old answer\n-\n@@ -2200,1 +2022,4 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  ResourceMark rm;\n+  \/\/ Map: old node idx -> node after CCP (or nullptr if not yet transformed or useless).\n+  Node_List node_map;\n+  \/\/ Pre-allocate to avoid frequent realloc\n@@ -2202,1 +2027,2 @@\n-  Unique_Node_List useful; \/\/ track all visited nodes, so that we can remove the complement\n+  \/\/ track all visited nodes, so that we can remove the complement\n+  Unique_Node_List useful;\n@@ -2214,1 +2040,1 @@\n-    Node* new_node = _nodes[nn->_idx];\n+    Node* new_node = node_map[nn->_idx];\n@@ -2217,1 +2043,1 @@\n-    _nodes.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n+    node_map.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n@@ -2228,1 +2054,1 @@\n-        Node *new_input = _nodes[input->_idx]; \/\/ Check for cloned input node\n+        Node *new_input = node_map[input->_idx]; \/\/ Check for cloned input node\n@@ -2231,1 +2057,1 @@\n-          _nodes.map( input->_idx, new_input );\/\/ Flag as having been cloned\n+          node_map.map( input->_idx, new_input );\/\/ Flag as having been cloned\n@@ -2254,1 +2080,1 @@\n-  C->disconnect_useless_nodes(useful, &_worklist);\n+  C->disconnect_useless_nodes(useful, _worklist);\n@@ -2256,1 +2082,1 @@\n-  Node* new_root = _nodes[n->_idx];\n+  Node* new_root = node_map[n->_idx];\n@@ -2261,1 +2087,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":55,"deletions":230,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -54,1 +55,1 @@\n-class NodeHash : public StackObj {\n+class NodeHash : public AnyObj {\n@@ -64,1 +65,0 @@\n-  NodeHash(uint est_max_size);\n@@ -66,1 +66,0 @@\n-  NodeHash(NodeHash *use_this_state);\n@@ -69,1 +68,0 @@\n-  void operator=(const NodeHash&); \/\/ Unlock all nodes upon replacement of table.\n@@ -96,1 +94,0 @@\n-  void   replace_with(NodeHash* nh);\n@@ -115,0 +112,1 @@\n+  NONCOPYABLE(NodeHash);\n@@ -123,2 +121,2 @@\n-\/\/ Despite the general name, this class is customized for use by PhaseTransform.\n-class Type_Array : public StackObj {\n+\/\/ Despite the general name, this class is customized for use by PhaseValues.\n+class Type_Array : public AnyObj {\n@@ -131,1 +129,1 @@\n-  friend class PhaseTransform;\n+  friend class PhaseValues;\n@@ -134,1 +132,0 @@\n-  Type_Array(Type_Array *ta) : _a(ta->_a), _max(ta->_max), _types(ta->_types) { }\n@@ -142,0 +139,8 @@\n+  void swap(Type_Array &other) {\n+    if (this != &other) {\n+      assert(_a == other._a, \"swapping for differing arenas is probably a bad idea\");\n+      ::swap(_max, other._max);\n+      ::swap(_types, other._types);\n+    }\n+  }\n+  NONCOPYABLE(Type_Array);\n@@ -152,1 +157,1 @@\n-  PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List *worklist, PhaseNumber phase_num = Remove_Useless);\n+  PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List& worklist, PhaseNumber phase_num = Remove_Useless);\n@@ -173,1 +178,1 @@\n-                    Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                    Unique_Node_List& worklist,\n@@ -184,0 +189,38 @@\n+public:\n+  PhaseTransform(PhaseNumber pnum) : Phase(pnum) {\n+#ifndef PRODUCT\n+    clear_progress();\n+    clear_transforms();\n+    set_allow_progress(true);\n+#endif\n+  }\n+\n+  \/\/ Return a node which computes the same function as this node, but\n+  \/\/ in a faster or cheaper fashion.\n+  virtual Node *transform( Node *n ) = 0;\n+\n+  \/\/ true if CFG node d dominates CFG node n\n+  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n+\n+#ifndef PRODUCT\n+  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n+  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n+  void   clear_progress()      { _count_progress = 0; }\n+  uint   made_progress() const { return _count_progress; }\n+\n+  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n+  void   set_transforms()      { ++_count_transforms; }\n+  void   clear_transforms()    { _count_transforms = 0; }\n+  uint   made_transforms() const{ return _count_transforms; }\n+\n+  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n+  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n+  bool   allow_progress()               { return _allow_progress; }\n+#endif\n+};\n+\n+\/\/ Phase infrastructure required for Node::Value computations.\n+\/\/ 1) Type array, and accessor methods.\n+\/\/ 2) Constants cache, which requires access to the types.\n+\/\/ 3) NodeHash table, to find identical nodes (and remove\/update the hash of a node on modification).\n+class PhaseValues : public PhaseTransform {\n@@ -185,3 +228,7 @@\n-  Arena*     _arena;\n-  Node_List  _nodes;           \/\/ Map old node indices to new nodes.\n-  Type_Array _types;           \/\/ Map old node indices to Types.\n+  bool      _iterGVN;\n+\n+  \/\/ Hash table for value-numbering. Reference to \"C->node_hash()\",\n+  NodeHash &_table;\n+\n+  \/\/ Type array mapping node idx to Type*. Reference to \"C->types()\".\n+  Type_Array &_types;\n@@ -190,0 +237,2 @@\n+  \/\/ Support both int and long caches because either might be an intptr_t,\n+  \/\/ so they show up frequently in address computations.\n@@ -201,3 +250,0 @@\n-  \/\/ Support both int and long caches because either might be an intptr_t,\n-  \/\/ so they show up frequently in address computations.\n-\n@@ -205,8 +251,7 @@\n-  PhaseTransform( PhaseNumber pnum );\n-  PhaseTransform( Arena *arena, PhaseNumber pnum );\n-  PhaseTransform( PhaseTransform *phase, PhaseNumber pnum );\n-\n-  Arena*      arena()   { return _arena; }\n-  Type_Array& types()   { return _types; }\n-  void replace_types(Type_Array new_types) {\n-    _types = new_types;\n+  PhaseValues() : PhaseTransform(GVN), _iterGVN(false),\n+                  _table(*C->node_hash()), _types(*C->types())\n+  {\n+    NOT_PRODUCT( clear_new_values(); )\n+    \/\/ Force allocation for currently existing nodes\n+    _types.map(C->unique(), nullptr);\n+    init_con_caches();\n@@ -214,3 +259,18 @@\n-  \/\/ _nodes is used in varying ways by subclasses, which define local accessors\n-  uint nodes_size() {\n-    return _nodes.size();\n+  NOT_PRODUCT(~PhaseValues();)\n+  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n+\n+  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n+  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n+  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n+  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n+  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n+\n+  \/\/ Used after parsing to eliminate values that are no longer in program\n+  void   remove_useless_nodes(VectorSet &useful) {\n+    _table.remove_useless_nodes(useful);\n+    \/\/ this may invalidate cached cons so reset the cache\n+    init_con_caches();\n+  }\n+\n+  Type_Array& types() {\n+    return _types;\n@@ -219,1 +279,0 @@\n-public:\n@@ -225,1 +284,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -234,1 +292,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -277,2 +334,1 @@\n-  virtual ConNode* uncached_makecon(const Type* t)  \/\/ override in PhaseValues\n-  { ShouldNotCallThis(); return nullptr; }\n+  ConNode* uncached_makecon(const Type* t);\n@@ -288,4 +344,0 @@\n-  \/\/ Return a node which computes the same function as this node, but\n-  \/\/ in a faster or cheaper fashion.\n-  virtual Node *transform( Node *n ) = 0;\n-\n@@ -340,3 +392,5 @@\n-  virtual const Type* saturate(const Type* new_type, const Type* old_type,\n-                               const Type* limit_type) const\n-  { ShouldNotCallThis(); return nullptr; }\n+  virtual const Type* saturate(const Type* new_type,\n+                               const Type* old_type,\n+                               const Type* limit_type) const {\n+    return new_type;\n+  }\n@@ -347,57 +401,0 @@\n-  \/\/ true if CFG node d dominates CFG node n\n-  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n-\n-#ifndef PRODUCT\n-  void dump_old2new_map() const;\n-  void dump_new( uint new_lidx ) const;\n-  void dump_types() const;\n-  void dump_nodes_and_types(const Node *root, uint depth, bool only_ctrl = true);\n-  void dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited);\n-\n-  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n-  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n-  void   clear_progress()      { _count_progress = 0; }\n-  uint   made_progress() const { return _count_progress; }\n-\n-  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n-  void   set_transforms()      { ++_count_transforms; }\n-  void   clear_transforms()    { _count_transforms = 0; }\n-  uint   made_transforms() const{ return _count_transforms; }\n-\n-  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n-  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n-  bool   allow_progress()               { return _allow_progress; }\n-#endif\n-};\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Phase infrastructure to support values\n-class PhaseValues : public PhaseTransform {\n-protected:\n-  NodeHash  _table;             \/\/ Hash table for value-numbering\n-  bool      _iterGVN;\n-public:\n-  PhaseValues(Arena* arena, uint est_max_size);\n-  PhaseValues(PhaseValues* pt);\n-  NOT_PRODUCT(~PhaseValues();)\n-  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n-\n-  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n-  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n-  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n-  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n-  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n-\n-  \/\/ Used after parsing to eliminate values that are no longer in program\n-  void   remove_useless_nodes(VectorSet &useful) {\n-    _table.remove_useless_nodes(useful);\n-    \/\/ this may invalidate cached cons so reset the cache\n-    init_con_caches();\n-  }\n-\n-  virtual ConNode* uncached_makecon(const Type* t);  \/\/ override from PhaseTransform\n-\n-  const Type* saturate(const Type* new_type, const Type* old_type,\n-                       const Type* limit_type) const\n-  { return new_type; }\n-\n@@ -420,3 +417,0 @@\n-  PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}\n-  PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}\n-\n@@ -431,5 +425,0 @@\n-  void replace_with(PhaseGVN* gvn) {\n-    _table.replace_with(&gvn->_table);\n-    _types = gvn->_types;\n-  }\n-\n@@ -462,1 +451,0 @@\n-  Node_Stack _stack;      \/\/ Stack used to avoid recursion\n@@ -464,1 +452,0 @@\n-\n@@ -474,0 +461,1 @@\n+\n@@ -477,0 +465,20 @@\n+  \/\/ Reset IGVN from GVN: call deconstructor, and placement new.\n+  \/\/ Achieves the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(gvn);\n+  void reset_from_gvn(PhaseGVN* gvn) {\n+    if (this != gvn) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(gvn);\n+    }\n+  }\n+\n+  \/\/ Reset IGVN with another: call deconstructor, and placement new.\n+  \/\/ Achieves the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(other);\n+  void reset_from_igvn(PhaseIterGVN* other) {\n+    if (this != other) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(other);\n+    }\n+  }\n+\n@@ -481,1 +489,2 @@\n-  Unique_Node_List _worklist;       \/\/ Iterative worklist\n+  \/\/ Iterative worklist. Reference to \"C->igvn_worklist()\".\n+  Unique_Node_List &_worklist;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":117,"deletions":108,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-        if (_nodes[m->_idx] == nullptr) {\n+        if (_loop_or_ctrl[m->_idx] == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-const Type* SubNode::Value_common(PhaseTransform *phase) const {\n+const Type* SubNode::Value_common(PhaseValues* phase) const {\n@@ -363,1 +363,1 @@\n-    return new AddLNode(in1, phase->longcon(-i->get_con()));\n+    return new AddLNode(in1, phase->longcon(java_negate(i->get_con())));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  const Type* Value_common( PhaseTransform *phase ) const;\n+  const Type* Value_common(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2667,0 +2667,1 @@\n+      \/\/ create_post_loop_vmask checks many conditions, any of them could fail\n@@ -2721,0 +2722,1 @@\n+            assert(false, \"input to vector store was not created\");\n@@ -2860,0 +2862,1 @@\n+              assert(false, \"input in1 to vector operand was not created\");\n@@ -2869,0 +2872,1 @@\n+            assert(false, \"input in2 to vector operand was not created\");\n@@ -2942,0 +2946,1 @@\n+          assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n@@ -3473,1 +3478,1 @@\n-            if (ReductionNode::implemented(use->Opcode(), Matcher::min_vector_size(bt), bt)) {\n+            if (ReductionNode::implemented(use->Opcode(), Matcher::superword_max_vector_size(bt), bt)) {\n@@ -3710,2 +3715,6 @@\n-      nn = nn->in(1);\n-      set_velt_type(n, velt_type(nn));\n+      assert(in_bb(nn->in(1)) || in_bb(nn->in(2)), \"one of the inputs must be in the loop too\");\n+      if (in_bb(nn->in(1))) {\n+        set_velt_type(n, velt_type(nn->in(1)));\n+      } else {\n+        set_velt_type(n, velt_type(nn->in(2)));\n+      }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  return t->hash();\n+  return (int)t->hash();\n@@ -773,1 +773,1 @@\n-int Type::hash(void) const {\n+uint Type::hash(void) const {\n@@ -1363,2 +1363,2 @@\n-int TypeF::hash(void) const {\n-  return *(int*)(&_f);\n+uint TypeF::hash(void) const {\n+  return *(uint*)(&_f);\n@@ -1473,2 +1473,2 @@\n-int TypeD::hash(void) const {\n-  return *(int*)(&_d);\n+uint TypeD::hash(void) const {\n+  return *(uint*)(&_d);\n@@ -1767,2 +1767,2 @@\n-int TypeInt::hash(void) const {\n-  return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));\n+uint TypeInt::hash(void) const {\n+  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n@@ -2033,2 +2033,2 @@\n-int TypeLong::hash(void) const {\n-  return (int)(_lo+_hi+_widen+(int)Type::Long);\n+uint TypeLong::hash(void) const {\n+  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n@@ -2275,2 +2275,2 @@\n-int TypeTuple::hash(void) const {\n-  intptr_t sum = _cnt;\n+uint TypeTuple::hash(void) const {\n+  uintptr_t sum = _cnt;\n@@ -2278,2 +2278,2 @@\n-    sum += (intptr_t)_fields[i];     \/\/ Hash on pointers directly\n-  return sum;\n+    sum += (uintptr_t)_fields[i];     \/\/ Hash on pointers directly\n+  return (uint)sum;\n@@ -2390,2 +2390,2 @@\n-int TypeAry::hash(void) const {\n-  return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);\n+uint TypeAry::hash(void) const {\n+  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_size + (uint)(_stable ? 43 : 0);\n@@ -2578,2 +2578,2 @@\n-int TypeVect::hash(void) const {\n-  return (intptr_t)_elem + (intptr_t)_length;\n+uint TypeVect::hash(void) const {\n+  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n@@ -2804,3 +2804,2 @@\n-int TypePtr::hash(void) const {\n-  return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));\n-;\n+uint TypePtr::hash(void) const {\n+  return (uint)_ptr + (uint)_offset + (uint)hash_speculative() + (uint)_inline_depth;\n@@ -3238,2 +3237,2 @@\n-int TypeRawPtr::hash(void) const {\n-  return (intptr_t)_bits + TypePtr::hash();\n+uint TypeRawPtr::hash(void) const {\n+  return (uint)(uintptr_t)_bits + (uint)TypePtr::hash();\n@@ -3328,1 +3327,1 @@\n-int TypePtr::InterfaceSet::hash() const {\n+uint TypePtr::InterfaceSet::hash() const {\n@@ -3334,1 +3333,1 @@\n-  int hash = 0;\n+  uint hash = 0;\n@@ -3337,1 +3336,1 @@\n-    hash += (jint)k->hash();\n+    hash += k->hash();\n@@ -3849,1 +3848,1 @@\n-int TypeOopPtr::hash(void) const {\n+uint TypeOopPtr::hash(void) const {\n@@ -3851,2 +3850,3 @@\n-    java_add(java_add((jint)(const_oop() ? const_oop()->hash() : 0), (jint)_klass_is_exact),\n-             java_add((jint)_instance_id, (jint)TypePtr::hash()));\n+    (uint)(const_oop() ? const_oop()->hash() : 0) +\n+    (uint)_klass_is_exact +\n+    (uint)_instance_id + TypePtr::hash();\n@@ -4486,3 +4486,2 @@\n-int TypeInstPtr::hash(void) const {\n-  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n-  return hash;\n+uint TypeInstPtr::hash(void) const {\n+  return klass()->hash() + TypeOopPtr::hash() + _interfaces.hash();\n@@ -4837,2 +4836,2 @@\n-int TypeAryPtr::hash(void) const {\n-  return (intptr_t)_ary + TypeOopPtr::hash();\n+uint TypeAryPtr::hash(void) const {\n+  return (uint)(uintptr_t)_ary + TypeOopPtr::hash();\n@@ -5222,1 +5221,1 @@\n-int TypeNarrowPtr::hash(void) const {\n+uint TypeNarrowPtr::hash(void) const {\n@@ -5382,1 +5381,1 @@\n-int TypeMetadataPtr::hash(void) const {\n+uint TypeMetadataPtr::hash(void) const {\n@@ -5622,2 +5621,2 @@\n-int TypeKlassPtr::hash(void) const {\n-  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n+uint TypeKlassPtr::hash(void) const {\n+  return TypePtr::hash() + _interfaces.hash();\n@@ -5735,2 +5734,2 @@\n-int TypeInstKlassPtr::hash(void) const {\n-  return java_add((jint)klass()->hash(), TypeKlassPtr::hash());\n+uint TypeInstKlassPtr::hash(void) const {\n+  return klass()->hash() + TypeKlassPtr::hash();\n@@ -6095,2 +6094,2 @@\n-int TypeAryKlassPtr::hash(void) const {\n-  return (intptr_t)_elem + TypeKlassPtr::hash();\n+uint TypeAryKlassPtr::hash(void) const {\n+  return (uint)(uintptr_t)_elem + TypeKlassPtr::hash();\n@@ -6643,2 +6642,2 @@\n-int TypeFunc::hash(void) const {\n-  return (intptr_t)_domain + (intptr_t)_range;\n+uint TypeFunc::hash(void) const {\n+  return (uint)(uintptr_t)_domain + (uint)(uintptr_t)_range;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -494,1 +494,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -525,1 +525,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -584,1 +584,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -650,1 +650,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -709,1 +709,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -759,1 +759,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -801,1 +801,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -887,1 +887,1 @@\n-    int _hash;\n+    uint _hash;\n@@ -902,1 +902,1 @@\n-    int hash() const;\n+    uint hash() const;\n@@ -1018,1 +1018,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1073,1 +1073,1 @@\n-  virtual int  hash() const;     \/\/ Type specific hashing\n+  virtual uint hash() const;    \/\/ Type specific hashing\n@@ -1110,1 +1110,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1279,1 +1279,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1408,1 +1408,1 @@\n-  virtual int hash() const;     \/\/ Type specific hashing\n+  virtual uint hash() const;    \/\/ Type specific hashing\n@@ -1516,1 +1516,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1560,1 +1560,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -1681,1 +1681,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -1737,1 +1737,1 @@\n-  virtual int hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1782,1 +1782,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1893,1 +1893,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-  C->for_igvn()->clear();\n-  C->initial_gvn()->replace_with(&_igvn);\n+  C->igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -67,1 +66,1 @@\n-    PhaseRemoveUseless pru(C->initial_gvn(), C->for_igvn());\n+    PhaseRemoveUseless pru(C->initial_gvn(), *C->igvn_worklist());\n@@ -72,1 +71,1 @@\n-    _igvn = PhaseIterGVN(C->initial_gvn());\n+    _igvn.reset_from_gvn(C->initial_gvn());\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3475,1 +3475,9 @@\n-volatile int vm_created = 0;\n+enum VM_Creation_State {\n+  NOT_CREATED = 0,\n+  IN_PROGRESS,  \/\/ Most JNI operations are permitted during this phase to\n+                \/\/ allow for initialization actions by libraries and agents.\n+  COMPLETE\n+};\n+\n+volatile VM_Creation_State vm_created = NOT_CREATED;\n+\n@@ -3544,1 +3552,1 @@\n-  if (Atomic::xchg(&vm_created, 1) == 1) {\n+  if (Atomic::xchg(&vm_created, IN_PROGRESS) != NOT_CREATED) {\n@@ -3557,2 +3565,0 @@\n-  assert(vm_created == 1, \"vm_created is true during the creation\");\n-\n@@ -3575,1 +3581,1 @@\n-    \/* thread is thread_in_vm here *\/\n+    \/\/ thread is thread_in_vm here\n@@ -3578,0 +3584,2 @@\n+    \/\/ mark creation complete for other JNI ops\n+    Atomic::release_store(&vm_created, COMPLETE);\n@@ -3640,1 +3648,2 @@\n-    Atomic::release_store(&vm_created, 0);\n+    assert(vm_created == IN_PROGRESS, \"must be\");\n+    Atomic::release_store(&vm_created, NOT_CREATED);\n@@ -3669,1 +3678,1 @@\n-  if (vm_created == 1) {\n+  if (vm_created == COMPLETE) {\n@@ -3689,1 +3698,1 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n@@ -3720,1 +3729,1 @@\n-  vm_created = 0;\n+  vm_created = NOT_CREATED;\n@@ -3854,1 +3863,2 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n@@ -3867,1 +3877,2 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n@@ -3930,1 +3941,1 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n@@ -3981,2 +3992,3 @@\n-  if (vm_created == 0) {\n-  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n+    HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1365,1 +1365,1 @@\n-    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ScopedValue_Carrier(), true, THREAD);\n@@ -1398,1 +1398,1 @@\n-      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      StackValue* head_sv = locals->at(loc); \/\/ java\/lang\/ScopedValue$Snapshot\n@@ -4027,0 +4027,7 @@\n+\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JVM_LEAF(jboolean, JVM_PrintWarningAtDynamicAgentLoad(void))\n+  return (EnableDynamicAgentLoading && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading)) ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -643,0 +643,11 @@\n+    The VM prints a warning on the standard error stream for each agent that it attempts\n+    to start in the live phase. If an agent was previously started (in the <code>OnLoad<\/code>\n+    phase or in the live phase), then it is implementation specific as to whether a\n+    warning is printed when attempting to start the same agent a second or subsequent time.\n+    Warnings can be disabled by means of an implementation-specific command line option.\n+    <p\/>\n+    <b>Implementation Note:<\/b> For the HotSpot VM, the VM option\n+    <code>-XX:+EnableDynamicAgentLoading<\/code> is used to opt-in to allow dynamic loading\n+    of agents in the live phase. This option suppresses the warning to standard error when\n+    starting an agent in the live phase.\n+    <p\/>\n@@ -5829,3 +5840,2 @@\n-      local variable in the topmost frame of a virtual thread suspended at a\n-      breakpoint or single step event. An implementation may support setting locals\n-      in other cases.\n+      local variable in the topmost frame of a virtual thread suspended at an event.\n+      An implementation may support setting locals in other cases.\n@@ -6208,1 +6218,1 @@\n-          The thread is a virtual thread and the implementation does not support\n+          The thread is a suspended virtual thread and the implementation does not support\n@@ -6272,1 +6282,1 @@\n-          The thread is a virtual thread and the implementation does not support\n+          The thread is a suspended virtual thread and the implementation does not support\n@@ -6331,1 +6341,1 @@\n-          The thread is a virtual thread and the implementation does not support\n+          The thread is a suspended virtual thread and the implementation does not support\n@@ -6390,1 +6400,1 @@\n-          The thread is a virtual thread and the implementation does not support\n+          The thread is a suspended virtual thread and the implementation does not support\n@@ -6449,1 +6459,1 @@\n-          The thread is a virtual thread and the implementation does not support\n+          The thread is a suspended virtual thread and the implementation does not support\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -40,0 +42,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -263,1 +266,1 @@\n-\/\/ For statically linked agents we cant't rely on os_lib == nullptr because\n+\/\/ For statically linked agents we can't rely on os_lib == nullptr because\n@@ -265,1 +268,1 @@\n-\/\/ If this function returns true, then agent->is_static_lib().&& agent->is_loaded().\n+\/\/ If this function returns true, then agent->is_static_lib() && agent->is_loaded().\n@@ -375,1 +378,1 @@\n-  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n+  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr);\n@@ -486,0 +489,1 @@\n+\/\/ This function is called before the agent is added to JvmtiAgentList.\n@@ -487,0 +491,5 @@\n+  if (!EnableDynamicAgentLoading) {\n+    st->print_cr(\"Dynamic agent loading is not enabled. \"\n+                 \"Use -XX:+EnableDynamicAgentLoading to launch target VM.\");\n+    return false;\n+  }\n@@ -494,1 +503,4 @@\n-  if (!load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+  bool previously_loaded;\n+  if (load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+    previously_loaded = JvmtiAgentList::is_static_lib_loaded(agent->name());\n+  } else {\n@@ -506,0 +518,1 @@\n+    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(library);\n@@ -507,0 +520,9 @@\n+\n+  \/\/ Print warning if agent was not previously loaded and EnableDynamicAgentLoading not enabled on the command line.\n+  if (!previously_loaded && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib()) {\n+    jio_fprintf(defaultStream::error_stream(),\n+      \"WARNING: A JVM TI agent has been loaded dynamically (%s)\\n\"\n+      \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n+      \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -223,0 +223,24 @@\n+\/\/ Return true if a statically linked agent is on the list\n+bool JvmtiAgentList::is_static_lib_loaded(const char* name) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (agent->is_static_lib() && strcmp(agent->name(), name) == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Return true if a agent library on the list\n+bool JvmtiAgentList::is_dynamic_lib_loaded(void* os_lib) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (!agent->is_static_lib() && agent->os_lib() == os_lib) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  static bool is_static_lib_loaded(const char* name);\n+  static bool is_dynamic_lib_loaded(void* os_lib);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1783,0 +1783,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1785,1 +1786,0 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1347,1 +1347,1 @@\n-JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread,\n+JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread, JavaThread* cur_thread,\n@@ -1349,1 +1349,0 @@\n-  JavaThread* cur_thread = JavaThread::current();\n@@ -1354,0 +1353,3 @@\n+    if (cur_thread == nullptr) { \/\/ cur_thread can be null when called from a VM_op\n+      return JVMTI_ERROR_INVALID_THREAD;\n+    }\n@@ -1384,0 +1386,8 @@\n+jvmtiError\n+JvmtiEnvBase::get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread,\n+                                           JavaThread** jt_pp, oop* thread_oop_p) {\n+  JavaThread* cur_thread = JavaThread::current();\n+  jvmtiError err = get_threadOop_and_JavaThread(t_list, thread, cur_thread, jt_pp, thread_oop_p);\n+  return err;\n+}\n+\n@@ -1934,1 +1944,2 @@\n-    jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), jt, &java_thread, &thread_oop);\n+    jvmtiError err = JvmtiEnvBase::get_threadOop_and_JavaThread(tlh.list(), jt, nullptr, &java_thread, &thread_oop);\n+\n@@ -1939,2 +1950,3 @@\n-      \/\/ In the virtual thread case the cv_external_thread_to_JavaThread is expected to correctly set\n-      \/\/ the thread_oop and return JVMTI_ERROR_INVALID_THREAD which we ignore here.\n+      \/\/ In the virtual thread case the get_threadOop_and_JavaThread is expected to correctly set\n+      \/\/ the thread_oop and return JVMTI_ERROR_THREAD_NOT_ALIVE which we ignore here.\n+      \/\/ The corresponding thread state will be recorded in the jvmtiStackInfo.state.\n@@ -1955,1 +1967,1 @@\n-  oop thread_oop = jt->threadObj();\n+  oop thread_oop = JNIHandles::resolve_external_guard(_jthread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -217,0 +217,2 @@\n+  static jvmtiError get_threadOop_and_JavaThread(ThreadsList* t_list, jthread thread, JavaThread* cur_thread,\n+                                                 JavaThread** jt_pp, oop* thread_oop_p);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2971,0 +2971,3 @@\n+  \/\/ VTMS transitions must be disabled before the EscapeBarrier.\n+  JvmtiVTMSTransitionDisabler disabler;\n+\n@@ -2977,2 +2980,0 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n-\n@@ -3018,0 +3019,3 @@\n+  \/\/ VTMS transitions must be disabled before the EscapeBarrier.\n+  JvmtiVTMSTransitionDisabler disabler;\n+\n@@ -3030,2 +3034,0 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-\/\/ no-op if thread is non-NULL and not a virtual thread\n+\/\/ no-op if thread is non-null and not a virtual thread\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1885,1 +1885,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n@@ -1894,1 +1894,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n@@ -2830,1 +2830,1 @@\n-    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\")) {\n+    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\") || match_option(option, \"-XX:-UseGraalJIT\")) {\n@@ -2833,1 +2833,1 @@\n-                  \"-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\\n\");\n+                  \"-XX:-EnableJVMCIProduct or -XX:-UseGraalJIT cannot come after -XX:+EnableJVMCIProduct or -XX:+UseGraalJIT\\n\");\n@@ -2836,2 +2836,16 @@\n-    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\")) {\n-      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" has been specified before\n+    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\") || match_option(option, \"-XX:+UseGraalJIT\")) {\n+      bool use_graal_jit = match_option(option, \"-XX:+UseGraalJIT\");\n+      if (use_graal_jit) {\n+        const char* jvmci_compiler = get_property(\"jvmci.Compiler\");\n+        if (jvmci_compiler != nullptr) {\n+          if (strncmp(jvmci_compiler, \"graal\", strlen(\"graal\")) != 0) {\n+            jio_fprintf(defaultStream::error_stream(),\n+              \"Value of jvmci.Compiler incompatible with +UseGraalJIT: %s\", jvmci_compiler);\n+            return JNI_ERR;\n+          }\n+        } else if (!add_property(\"jvmci.Compiler=graal\")) {\n+            return JNI_ENOMEM;\n+        }\n+      }\n+\n+      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" or \"-XX:+UseGraalJIT\" has been specified before\n@@ -2844,1 +2858,1 @@\n-        if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {\n+        if (!JVMCIGlobals::enable_jvmci_product_mode(origin, use_graal_jit)) {\n@@ -2851,1 +2865,1 @@\n-      else if (!process_argument(\"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n+      else if (!process_argument(use_graal_jit ? \"UseGraalJIT\" : \"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        st->print(\"nullptr\");\n+        st->print(\"null\");\n@@ -171,1 +171,1 @@\n-        st->print(\"nullptr\");\n+        st->print(\"null\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -550,1 +550,1 @@\n-  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                            \\\n+  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                         \\\n@@ -604,1 +604,1 @@\n-  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                    \\\n+  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                 \\\n@@ -632,1 +632,1 @@\n-          \"Start debugger when an implicit OS (e.g. nullptr) \"                 \\\n+          \"Start debugger when an implicit OS (e.g. null pointer) \"         \\\n@@ -838,1 +838,1 @@\n-  product(ccstr, TraceJVMTI, nullptr,                                          \\\n+  product(ccstr, TraceJVMTI, nullptr,                                       \\\n@@ -1028,1 +1028,1 @@\n-  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                                 \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                              \\\n@@ -1032,1 +1032,1 @@\n-  product(ccstr, ErrorFile, nullptr,                                           \\\n+  product(ccstr, ErrorFile, nullptr,                                        \\\n@@ -1069,1 +1069,1 @@\n-  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                      \\\n+  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                   \\\n@@ -1073,1 +1073,1 @@\n-  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,               \\\n+  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,            \\\n@@ -1385,1 +1385,1 @@\n-  product(double, MinInlineFrequencyRatio, 0.0085, DIAGNOSTIC,               \\\n+  product(double, MinInlineFrequencyRatio, 0.0085, DIAGNOSTIC,              \\\n@@ -1730,1 +1730,1 @@\n-  product(ccstr, PerfDataSaveFile, nullptr,                                    \\\n+  product(ccstr, PerfDataSaveFile, nullptr,                                 \\\n@@ -1917,1 +1917,1 @@\n-  product(ccstr, AllocateHeapAt, nullptr,                                      \\\n+  product(ccstr, AllocateHeapAt, nullptr,                                   \\\n@@ -1952,1 +1952,1 @@\n-  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                      \\\n+  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                   \\\n@@ -1955,1 +1955,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                       \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving nullptr handle\"); return *_handle; }\n+  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving null handle\"); return *_handle; }\n@@ -147,1 +147,1 @@\n-    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving nullptr _value\"); return _value; } \\\n+    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving null _value\"); return _value; } \\\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,0 +241,2 @@\n+  const char* cause() const { return _op->name(); }\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,0 +146,4 @@\n+  return JNI_OK;\n+}\n+\n+jint init_globals2() {\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+jint init_globals2();    \/\/ construction of early Java objects (main Java thread)\n","filename":"src\/hotspot\/share\/runtime\/init.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be nullptr\");\n+      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be null\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  assert(result != nullptr, \"nullptr read from jni handle\");\n+  assert(result != nullptr, \"null read from jni handle\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-extern Mutex*   MonitoringSupport_lock;          \/\/ Protects updates to the serviceability memory pools.\n+extern Mutex*   MonitoringSupport_lock;          \/\/ Protects updates to the serviceability memory pools and allocated memory high water mark.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-    \/\/ Set a nullptr owner to DEFLATER_MARKER to force any contending thread\n+    \/\/ Set a null owner to DEFLATER_MARKER to force any contending thread\n@@ -564,1 +564,1 @@\n-      \/\/ ObjectMonitor is now busy. Restore owner to nullptr if it is\n+      \/\/ ObjectMonitor is now busy. Restore owner to null if it is\n@@ -669,1 +669,1 @@\n-    \/\/ We report nullptr instead of DEFLATER_MARKER here because is_busy()\n+    \/\/ We report null instead of DEFLATER_MARKER here because is_busy()\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-#if defined(_ALLBSD_SOURCE) || defined(_GNU_SOURCE)\n+#if (defined(_ALLBSD_SOURCE) || defined(_GNU_SOURCE)) && !defined(AIX)\n@@ -881,2 +881,2 @@\n-    if (have_function_name = is_function_descriptor =\n-        dll_address_to_function_name(addr2, p, buflen, &offset, demangle)) {\n+    if ((have_function_name = is_function_descriptor =\n+        dll_address_to_function_name(addr2, p, buflen, &offset, demangle))) {\n@@ -1131,1 +1131,1 @@\n-    st->print_cr(\"0x0 is nullptr\");\n+    st->print_cr(\"0x0 is null\");\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -794,0 +794,3 @@\n+  \/\/ Send JFR memory info event\n+  static void jfr_report_memory_info() NOT_JFR_RETURN();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,8 +194,0 @@\n-PerfLongVariant::PerfLongVariant(CounterNS ns, const char* namep, Units u,\n-                                 Variability v, jlong* sampled)\n-                                : PerfLong(ns, namep, u, v),\n-                                  _sampled(sampled), _sample_helper(nullptr) {\n-\n-  sample();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -408,3 +408,0 @@\n-    PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,\n-                    jlong* sampled);\n-\n@@ -442,3 +439,0 @@\n-    PerfLongCounter(CounterNS ns, const char* namep, Units u, jlong* sampled)\n-                  : PerfLongVariant(ns, namep, u, V_Monotonic, sampled) { }\n-\n@@ -467,3 +461,0 @@\n-    PerfLongVariable(CounterNS ns, const char* namep, Units u, jlong* sampled)\n-                    : PerfLongVariant(ns, namep, u, V_Variable, sampled) { }\n-\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    assert(cur_tss->get_next() == nullptr, \"Must be nullptr\");\n+    assert(cur_tss->get_next() == nullptr, \"Must be null\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  \/\/ osthread() can be nullptr, if creation of thread failed.\n+  \/\/ osthread() can be null, if creation of thread failed.\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-  \/\/ Returns the current thread (ASSERTS if nullptr)\n+  \/\/ Returns the current thread (ASSERTS if null)\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -623,1 +623,1 @@\n-\/\/ No real entries, just the final nullptr terminator.\n+\/\/ No real entries, just the final null terminator.\n@@ -845,1 +845,1 @@\n-    \/\/ We captured a non-nullptr JavaThread* before the _tlh was created\n+    \/\/ We captured a non-null JavaThread* before the _tlh was created\n@@ -849,1 +849,1 @@\n-    \/\/ If we captured a non-nullptr JavaThread* after the _tlh was created\n+    \/\/ If we captured a non-null JavaThread* after the _tlh was created\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -556,0 +556,16 @@\n+  \/\/ Add main_thread to threads list to finish barrier setup with\n+  \/\/ on_thread_attach.  Should be before starting to build Java objects in\n+  \/\/ init_globals2, which invokes barriers.\n+  {\n+    MutexLocker mu(Threads_lock);\n+    Threads::add(main_thread);\n+  }\n+\n+  status = init_globals2();\n+  if (status != JNI_OK) {\n+    Threads::remove(main_thread, false);\n+    main_thread->smr_delete();\n+    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n+    return status;\n+  }\n+\n@@ -561,4 +577,0 @@\n-  { MutexLocker mu(Threads_lock);\n-    Threads::add(main_thread);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -177,0 +177,2 @@\n+  \/\/ Extra information about what triggered this operation.\n+  virtual const char* cause() const { return nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-        \/\/ add a nullptr snapshot if skipped\n+        \/\/ add a null snapshot if skipped\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1692,1 +1692,0 @@\n-  declare_c2_type(NodeHash, StackObj)                                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -410,1 +410,8 @@\n-  EventMarkVMOperation em(\"Executing %sVM operation: %s\", prev_vm_operation != nullptr ? \"nested \" : \"\", op->name());\n+\n+  const char* const cause = op->cause();\n+  EventMarkVMOperation em(\"Executing %sVM operation: %s%s%s%s\",\n+      prev_vm_operation != nullptr ? \"nested \" : \"\",\n+      op->name(),\n+      cause != nullptr ? \" (\" : \"\",\n+      cause != nullptr ? cause : \"\",\n+      cause != nullptr ? \")\" : \"\");\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -405,4 +405,0 @@\n-    } else if (!EnableDynamicAgentLoading && strcmp(op->name(), \"load\") == 0) {\n-      st.print(\"Dynamic agent loading is not enabled. \"\n-               \"Use -XX:+EnableDynamicAgentLoading to launch target VM.\");\n-      res = JNI_ERR;\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -431,2 +432,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -458,2 +457,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2098,1 +2095,35 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n+\n+\/\/ Gets the amount of memory allocated on the Java heap since JVM launch.\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n+    \/\/ A thread increments exited_allocated_bytes in ThreadService::remove_thread\n+    \/\/ only after it removes itself from the threads list, and once a TLH is\n+    \/\/ created, no thread it references can remove itself from the threads\n+    \/\/ list, so none can update exited_allocated_bytes. We therefore initialize\n+    \/\/ result with exited_allocated_bytes after after we create the TLH so that\n+    \/\/ the final result can only be short due to (1) threads that start after\n+    \/\/ the TLH is created, or (2) terminating threads that escape TLH creation\n+    \/\/ and don't update exited_allocated_bytes before we initialize result.\n+\n+    \/\/ We keep a high water mark to ensure monotonicity in case threads counted\n+    \/\/ on a previous call end up in state (2).\n+    static jlong high_water_result = 0;\n+\n+    JavaThreadIteratorWithHandle jtiwh;\n+    jlong result = ThreadService::exited_allocated_bytes();\n+    for (; JavaThread* thread = jtiwh.next();) {\n+      jlong size = thread->cooked_allocated_bytes();\n+      result += size;\n+    }\n+\n+    {\n+      MutexLocker ml(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);\n+      if (result < high_water_result) {\n+        \/\/ Encountered (2) above, or result wrapped to a negative value. In\n+        \/\/ the latter case, it's pegged at the last positive value.\n+        result = high_water_result;\n+      } else {\n+        high_water_result = result;\n+      }\n+    }\n+    return result;\n+JVM_END\n@@ -2231,3 +2262,0 @@\n-\n-\n-#if INCLUDE_MANAGEMENT\n@@ -2244,0 +2272,1 @@\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -783,0 +783,7 @@\n+      } else if (early_site->flag() != current_site->flag()) {\n+        \/\/ This site was originally allocated with one flag, then released,\n+        \/\/ then re-allocated at the same site (as far as we can tell) with a different flag.\n+        old_virtual_memory_site(early_site);\n+        early_site = early_itr.next();\n+        new_virtual_memory_site(current_site);\n+        current_site = current_itr.next();\n@@ -845,2 +852,0 @@\n-  assert(early->flag() == current->flag() || early->flag() == mtNone,\n-    \"Expect the same flag, but %s != %s\", NMTUtil::flag_to_name(early->flag()),NMTUtil::flag_to_name(current->flag()));\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -73,0 +74,2 @@\n+volatile jlong ThreadService::_exited_allocated_bytes = 0;\n+\n@@ -160,0 +163,3 @@\n+  \/\/ Include hidden thread allcations in exited_allocated_bytes\n+  ThreadService::incr_exited_allocated_bytes(thread->cooked_allocated_bytes());\n+\n@@ -1071,1 +1077,1 @@\n-      assert(currentThread != nullptr, \"AbstractOwnableSynchronizer owning thread is unexpectedly nullptr\");\n+      assert(currentThread != nullptr, \"AbstractOwnableSynchronizer owning thread is unexpectedly null\");\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ As could this...\n+  \/\/ Number of heap bytes allocated by terminated threads.\n+  static volatile jlong _exited_allocated_bytes;\n+\n@@ -105,0 +109,8 @@\n+  static jlong exited_allocated_bytes()       { return Atomic::load(&_exited_allocated_bytes); }\n+  static void incr_exited_allocated_bytes(jlong size) {\n+    \/\/ No need for an atomic add because called under the Threads_lock,\n+    \/\/ but because _exited_allocated_bytes is read concurrently, need\n+    \/\/ atomic store to avoid readers seeing a partial update.\n+    Atomic::store(&_exited_allocated_bytes, _exited_allocated_bytes + size);\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1295,1 +1295,1 @@\n-  assert(_new_table == nullptr || _new_table == POISON_PTR, \"Must be nullptr\");\n+  assert(_new_table == nullptr || _new_table == POISON_PTR, \"Must be null\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    assert(src != nullptr, \"address must not be nullptr\");\n-    assert(dst != nullptr, \"address must not be nullptr\");\n+    assert(src != nullptr, \"address must not be null\");\n+    assert(dst != nullptr, \"address must not be null\");\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1827,1 +1827,1 @@\n-\/\/ If result is a nullptr, we do not care about the content of the string being read.\n+\/\/ If result is a null, we do not care about the content of the string being read.\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  \/\/ return the function address for the function descriptor at 'index' or nullptr on error\n+  \/\/ return the function address for the function descriptor at 'index' or null on error\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  assert(exception != nullptr, \"exception should not be nullptr\");\n+  assert(exception != nullptr, \"exception should not be null\");\n@@ -145,1 +145,1 @@\n-  assert(h_exception() != nullptr, \"exception should not be nullptr\");\n+  assert(h_exception() != nullptr, \"exception should not be null\");\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-\/\/ offset directly when base address is NULL. The -Wno-invalid-offsetof\n+\/\/ offset directly when base address is null. The -Wno-invalid-offsetof\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include <alloca.h>\n@@ -41,0 +42,9 @@\n+\/\/ In stdlib.h on AIX malloc is defined as a macro causing\n+\/\/ compiler errors when resolving them in different depths as it\n+\/\/ happens in the log tags. This avoids the macro.\n+#if (defined(__VEC__) || defined(__AIXVEC)) && defined(AIX) \\\n+    && defined(__open_xl_version__) && __open_xl_version__ >= 17\n+  #undef malloc\n+  extern void *malloc(size_t) asm(\"vec_malloc\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_xlc.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    assert(node != nullptr, \"nullptr pointer\");\n+    assert(node != nullptr, \"null pointer\");\n@@ -388,1 +388,1 @@\n-    assert(node != nullptr, \"nullptr pointer\");\n+    assert(node != nullptr, \"null pointer\");\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  \/\/ pointer to that object, or nullptr if this stack is empty. Acts as a\n+  \/\/ pointer to that object, or null if this stack is empty. Acts as a\n@@ -100,1 +100,1 @@\n-  \/\/ Atomically exchange the list of elements with nullptr, returning the old\n+  \/\/ Atomically exchange the list of elements with null, returning the old\n","filename":"src\/hotspot\/share\/utilities\/lockFreeStack.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-\/\/ the value of r may be nullptr.\n+\/\/ the value of r may be null.\n@@ -108,1 +108,1 @@\n-  \/\/ first object, or nullptr if the queue was empty.  If unsuccessful, because\n+  \/\/ first object, or null if the queue was empty.  If unsuccessful, because\n@@ -114,1 +114,1 @@\n-  \/\/ Thread-safe remove and return the first object in the queue, or nullptr\n+  \/\/ Thread-safe remove and return the first object in the queue, or null\n@@ -116,1 +116,1 @@\n-  \/\/ succeeds, returning the (possibly nullptr) element obtained from that.\n+  \/\/ succeeds, returning the (possibly null) element obtained from that.\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-\/\/ appended. If the old tail is nullptr then the queue was empty, then the\n+\/\/ appended. If the old tail is null then the queue was empty, then the\n@@ -110,2 +110,2 @@\n-    \/\/ If old_tail is nullptr then the queue was empty, and _head must also be\n-    \/\/ nullptr.  The correctness of this assertion depends on try_pop clearing\n+    \/\/ If old_tail is null then the queue was empty, and _head must also be\n+    \/\/ null. The correctness of this assertion depends on try_pop clearing\n@@ -129,1 +129,1 @@\n-    \/\/ list.  The queue was logically empty.  _head is either nullptr or\n+    \/\/ list. The queue was logically empty.  _head is either null or\n@@ -155,1 +155,1 @@\n-    \/\/ (2) next_node is nullptr, because a competing try_pop took old_head.\n+    \/\/ (2) next_node is null, because a competing try_pop took old_head.\n@@ -174,1 +174,1 @@\n-      \/\/ _head to nullptr, \"helping\" the competing try_pop.  _head will remain\n+      \/\/ _head to null, \"helping\" the competing try_pop.  _head will remain\n@@ -194,1 +194,1 @@\n-    \/\/ value to nullptr.  However, this leaves the queue in disarray.  Fix up\n+    \/\/ value to null.  However, this leaves the queue in disarray.  Fix up\n@@ -203,1 +203,1 @@\n-    \/\/ Attempt to change the queue head from old_head to nullptr.  Failure of\n+    \/\/ Attempt to change the queue head from old_head to null.  Failure of\n@@ -208,1 +208,1 @@\n-    \/\/ Attempt to change the queue tail from old_head to nullptr.  Failure of\n+    \/\/ Attempt to change the queue tail from old_head to null.  Failure of\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -709,1 +709,1 @@\n-    \/\/ and leave xtty as nullptr\n+    \/\/ and leave xtty as null\n@@ -765,1 +765,1 @@\n-        assert(p->key() != nullptr, \"p->key() is nullptr\");\n+        assert(p->key() != nullptr, \"p->key() is null\");\n@@ -771,1 +771,1 @@\n-          assert(p->value() != nullptr, \"p->value() is nullptr\");\n+          assert(p->value() != nullptr, \"p->value() is null\");\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-      \/\/ Note: if _limit_ptr is nullptr, the ARR& is never reassigned,\n+      \/\/ Note: if _limit_ptr is null, the ARR& is never reassigned,\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  \/\/ Returns nullptr if 'c' it not found. This only works as long\n+  \/\/ Returns null if 'c' it not found. This only works as long\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static Thread*     _thread;           \/\/ nullptr if it's native thread\n+  static Thread*     _thread;           \/\/ null if it's native thread\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            addr < p->ldinfo_textorg + p->ldinfo_textsize) {\n+            (char*)addr < (char*)(p->ldinfo_textorg) + p->ldinfo_textsize) {\n","filename":"src\/java.base\/aix\/native\/libjli\/java_md_aix.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        \/\/ Each KeyStore.TrustedCertificateEntry have 2 attributes:\n+        \/\/ Each KeyStore.TrustedCertificateEntry has 2 attributes:\n@@ -655,1 +655,0 @@\n-                Certificate certElem;\n@@ -807,0 +806,18 @@\n+            \/\/ Check whether a certificate with same alias already exists and is the same\n+            \/\/ If yes, we can return here - the existing entry must have the same\n+            \/\/ properties and trust settings\n+            if (entries.contains(alias.toLowerCase())) {\n+                int uniqueVal = 1;\n+                String originalAlias = alias;\n+                var co = entries.get(alias.toLowerCase());\n+                while (co != null) {\n+                    if (co instanceof TrustedCertEntry tco) {\n+                        if (tco.cert.equals(tce.cert)) {\n+                            return;\n+                        }\n+                    }\n+                    alias = originalAlias + \" \" + uniqueVal++;\n+                    co = entries.get(alias.toLowerCase());\n+                }\n+            }\n+\n@@ -808,1 +825,1 @@\n-            Map<String,String> tmpMap = new LinkedHashMap<>();\n+            Map<String, String> tmpMap = new LinkedHashMap<>();\n@@ -831,0 +848,1 @@\n+\n@@ -833,1 +851,1 @@\n-                    \/\/ If a self-signed certificate has an empty trust settings,\n+                    \/\/ If a self-signed certificate has trust settings without specific entries,\n@@ -846,1 +864,2 @@\n-                    \/\/ 1 = kSecTrustSettingsResultTrustRoot, 2 = kSecTrustSettingsResultTrustAsRoot\n+                    \/\/ 1 = kSecTrustSettingsResultTrustRoot, 2 = kSecTrustSettingsResultTrustAsRoot,\n+                    \/\/ 3 = kSecTrustSettingsResultDeny\n@@ -848,1 +867,1 @@\n-                    \/\/ for self-signed certificates (see doc for SecTrustSettingsCopyTrustSettings).\n+                    \/\/ (see doc for SecTrustSettingsCopyTrustSettings).\n@@ -851,0 +870,7 @@\n+\n+                    \/\/ If we find explicit distrust in some record, we ignore the certificate\n+                    if (\"3\".equals(result)) {\n+                        return;\n+                    }\n+\n+                    \/\/ Trust, if explicitly trusted or result is null and certificate is self signed\n@@ -870,0 +896,1 @@\n+\n@@ -876,8 +903,0 @@\n-            int uniqueVal = 1;\n-            String originalAlias = alias;\n-\n-            while (entries.containsKey(alias.toLowerCase())) {\n-                alias = originalAlias + \" \" + uniqueVal;\n-                uniqueVal++;\n-            }\n-\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/KeychainStore.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -37,2 +36,2 @@\n-    private static final boolean hasDynamicLoaderCache = OperatingSystem.version()\n-            .compareTo(new Version(10, 16)) >= 0;\n+    private static final boolean hasDynamicLoaderCache = OSVersion.current()\n+            .compareTo(new OSVersion(10, 16)) >= 0;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/loader\/ClassLoaderHelper.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -384,0 +384,29 @@\n+\n+static void addTrustSettingsToInputTrust(JNIEnv *env, jmethodID jm_listAdd, CFArrayRef trustSettings, jobject inputTrust)\n+{\n+    CFIndex count = CFArrayGetCount(trustSettings);\n+    for (int i = 0; i < count; i++) {\n+        CFDictionaryRef oneTrust = (CFDictionaryRef) CFArrayGetValueAtIndex(trustSettings, i);\n+        CFIndex size = CFDictionaryGetCount(oneTrust);\n+        const void * keys [size];\n+        const void * values [size];\n+        CFDictionaryGetKeysAndValues(oneTrust, keys, values);\n+        for (int j = 0; j < size; j++) {\n+            NSString* s = [NSString stringWithFormat:@\"%@\", keys[j]];\n+            ADD(inputTrust, s);\n+            s = [NSString stringWithFormat:@\"%@\", values[j]];\n+            ADD(inputTrust, s);\n+        }\n+        SecPolicyRef certPolicy;\n+        certPolicy = (SecPolicyRef)CFDictionaryGetValue(oneTrust, kSecTrustSettingsPolicy);\n+        if (certPolicy != NULL) {\n+            CFDictionaryRef policyDict = SecPolicyCopyProperties(certPolicy);\n+            ADD(inputTrust, @\"SecPolicyOid\");\n+            NSString* s = [NSString stringWithFormat:@\"%@\", CFDictionaryGetValue(policyDict, @\"SecPolicyOid\")];\n+            ADD(inputTrust, s);\n+            CFRelease(policyDict);\n+        }\n+        ADDNULL(inputTrust);\n+    }\n+}\n+\n@@ -438,7 +467,0 @@\n-            \/\/ Only add certificates with trusted settings\n-            CFArrayRef trustSettings;\n-            if (SecTrustSettingsCopyTrustSettings(certRef, kSecTrustSettingsDomainUser, &trustSettings)\n-                    == errSecItemNotFound) {\n-                continue;\n-            }\n-\n@@ -446,2 +468,13 @@\n-            jobject inputTrust = (*env)->NewObject(env, jc_arrayListClass, jm_arrayListCons);\n-            if (inputTrust == NULL) {\n+            \/\/ We load trust settings from domains kSecTrustSettingsDomainUser and kSecTrustSettingsDomainAdmin\n+            \/\/ kSecTrustSettingsDomainSystem is ignored because it seems to only contain data for root certificates\n+            jobject inputTrust = NULL;\n+            CFArrayRef trustSettings = NULL;\n+\n+            \/\/ Load user trustSettings into inputTrust\n+            if (SecTrustSettingsCopyTrustSettings(certRef, kSecTrustSettingsDomainUser, &trustSettings) == errSecSuccess && trustSettings != NULL) {\n+                inputTrust = (*env)->NewObject(env, jc_arrayListClass, jm_arrayListCons);\n+                if (inputTrust == NULL) {\n+                    CFRelease(trustSettings);\n+                    goto errOut;\n+                }\n+                addTrustSettingsToInputTrust(env, jm_listAdd, trustSettings, inputTrust);\n@@ -449,1 +482,0 @@\n-                goto errOut;\n@@ -451,14 +483,5 @@\n-\n-            \/\/ Dump everything inside trustSettings into inputTrust\n-            CFIndex count = CFArrayGetCount(trustSettings);\n-            for (int i = 0; i < count; i++) {\n-                CFDictionaryRef oneTrust = (CFDictionaryRef) CFArrayGetValueAtIndex(trustSettings, i);\n-                CFIndex size = CFDictionaryGetCount(oneTrust);\n-                const void * keys [size];\n-                const void * values [size];\n-                CFDictionaryGetKeysAndValues(oneTrust, keys, values);\n-                for (int j = 0; j < size; j++) {\n-                    NSString* s = [NSString stringWithFormat:@\"%@\", keys[j]];\n-                    ADD(inputTrust, s);\n-                    s = [NSString stringWithFormat:@\"%@\", values[j]];\n-                    ADD(inputTrust, s);\n+            \/\/ Load admin trustSettings into inputTrust\n+            trustSettings = NULL;\n+            if (SecTrustSettingsCopyTrustSettings(certRef, kSecTrustSettingsDomainAdmin, &trustSettings) == errSecSuccess && trustSettings != NULL) {\n+                if (inputTrust == NULL) {\n+                    inputTrust = (*env)->NewObject(env, jc_arrayListClass, jm_arrayListCons);\n@@ -466,8 +489,3 @@\n-                SecPolicyRef certPolicy;\n-                certPolicy = (SecPolicyRef)CFDictionaryGetValue(oneTrust, kSecTrustSettingsPolicy);\n-                if (certPolicy != NULL) {\n-                    CFDictionaryRef policyDict = SecPolicyCopyProperties(certPolicy);\n-                    ADD(inputTrust, @\"SecPolicyOid\");\n-                    NSString* s = [NSString stringWithFormat:@\"%@\", CFDictionaryGetValue(policyDict, @\"SecPolicyOid\")];\n-                    ADD(inputTrust, s);\n-                    CFRelease(policyDict);\n+                if (inputTrust == NULL) {\n+                    CFRelease(trustSettings);\n+                    goto errOut;\n@@ -475,1 +493,7 @@\n-                ADDNULL(inputTrust);\n+                addTrustSettingsToInputTrust(env, jm_listAdd, trustSettings, inputTrust);\n+                CFRelease(trustSettings);\n+            }\n+\n+            \/\/ Only add certificates with trust settings\n+            if (inputTrust == NULL) {\n+                continue;\n@@ -477,1 +501,0 @@\n-            CFRelease(trustSettings);\n","filename":"src\/java.base\/macosx\/native\/libosxsecurity\/KeystoreImpl.m","additions":57,"deletions":34,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.ssl.HKDF;\n+import sun.security.util.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/ Implementing DHKEM defined inside https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html,\n+\/\/ without the AuthEncap and AuthDecap functions\n+public class DHKEM implements KEMSpi {\n+\n+    private static final byte[] KEM = new byte[]\n+            {'K', 'E', 'M'};\n+    private static final byte[] EAE_PRK = new byte[]\n+            {'e', 'a', 'e', '_', 'p', 'r', 'k'};\n+    private static final byte[] SHARED_SECRET = new byte[]\n+            {'s', 'h', 'a', 'r', 'e', 'd', '_', 's', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] DKP_PRK = new byte[]\n+            {'d', 'k', 'p', '_', 'p', 'r', 'k'};\n+    private static final byte[] CANDIDATE = new byte[]\n+            {'c', 'a', 'n', 'd', 'i', 'd', 'a', 't', 'e'};\n+    private static final byte[] SK = new byte[]\n+            {'s', 'k'};\n+    private static final byte[] HPKE_V1 = new byte[]\n+            {'H', 'P', 'K', 'E', '-', 'v', '1'};\n+    private static final byte[] EMPTY = new byte[0];\n+\n+    private record Handler(Params params, SecureRandom secureRandom,\n+                           PrivateKey skR, PublicKey pkR)\n+                implements EncapsulatorSpi, DecapsulatorSpi {\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n+            KeyPair kpE = params.generateKeyPair(secureRandom);\n+            PrivateKey skE = kpE.getPrivate();\n+            PublicKey pkE = kpE.getPublic();\n+            byte[] pkEm = params.SerializePublicKey(pkE);\n+            byte[] pkRm = params.SerializePublicKey(pkR);\n+            byte[] kem_context = concat(pkEm, pkRm);\n+            try {\n+                byte[] dh = params.DH(skE, pkR);\n+                byte[] key = params.ExtractAndExpand(dh, kem_context);\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(key, from, to - from, algorithm),\n+                        pkEm, null);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm) throws DecapsulateException {\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n+            Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+            if (encapsulation.length != params.Npk) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n+            try {\n+                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n+                byte[] dh = params.DH(skR, pkE);\n+                byte[] pkRm = params.SerializePublicKey(pkR);\n+                byte[] kem_context = concat(encapsulation, pkRm);\n+                byte[] key = params.ExtractAndExpand(dh, kem_context);\n+                return new SecretKeySpec(key, from, to - from, algorithm);\n+            } catch (IOException | InvalidKeyException e) {\n+                throw new DecapsulateException(\"Cannot decapsulate\", e);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return params.Nsecret;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return params.Npk;\n+        }\n+    }\n+\n+    \/\/ Not really a random. For KAT test only. It generates key pair from ikm.\n+    public static class RFC9180DeriveKeyPairSR extends SecureRandom {\n+\n+        static final long serialVersionUID = 0L;\n+\n+        private final byte[] ikm;\n+\n+        public RFC9180DeriveKeyPairSR(byte[] ikm) {\n+            super(null, null); \/\/ lightest constructor\n+            this.ikm = ikm;\n+        }\n+\n+        public KeyPair derive(Params params) {\n+            try {\n+                return params.deriveKeyPair(ikm);\n+            } catch (Exception e) {\n+                throw new UnsupportedOperationException(e);\n+            }\n+        }\n+\n+        public KeyPair derive(int kem_id) {\n+            Params params = Arrays.stream(Params.values())\n+                    .filter(p -> p.kem_id == kem_id)\n+                    .findFirst()\n+                    .orElseThrow();\n+            return derive(params);\n+        }\n+    }\n+\n+    private enum Params {\n+\n+        P256(0x10, 32, 32, 2 * 32 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+\n+        P384(0x11, 48, 48, 2 * 48 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+\n+        P521(0x12, 64, 66, 2 * 66 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+\n+        X25519(0x20, 32, 32, 32,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+\n+        X448(0x21, 64, 56, 56,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+        ;\n+\n+        private final int kem_id;\n+        private final int Nsecret;\n+        private final int Nsk;\n+        private final int Npk;\n+        private final String kaAlgorithm;\n+        private final String keyAlgorithm;\n+        private final AlgorithmParameterSpec spec;\n+        private final String hkdfAlgorithm;\n+\n+        private final byte[] suiteId;\n+\n+        Params(int kem_id, int Nsecret, int Nsk, int Npk,\n+                String kaAlgorithm, String keyAlgorithm, AlgorithmParameterSpec spec,\n+                String hkdfAlgorithm) {\n+            this.kem_id = kem_id;\n+            this.spec = spec;\n+            this.Nsecret = Nsecret;\n+            this.Nsk = Nsk;\n+            this.Npk = Npk;\n+            this.kaAlgorithm = kaAlgorithm;\n+            this.keyAlgorithm = keyAlgorithm;\n+            this.hkdfAlgorithm = hkdfAlgorithm;\n+            suiteId = concat(KEM, I2OSP(kem_id, 2));\n+        }\n+\n+        private boolean isEC() {\n+            return this == P256 || this == P384 || this == P521;\n+        }\n+\n+        private KeyPair generateKeyPair(SecureRandom sr) {\n+            if (sr instanceof RFC9180DeriveKeyPairSR r9) {\n+                return r9.derive(this);\n+            }\n+            try {\n+                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n+                g.initialize(spec, sr);\n+                return g.generateKeyPair();\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private byte[] SerializePublicKey(PublicKey k) {\n+            if (isEC()) {\n+                ECPoint w = ((ECPublicKey) k).getW();\n+                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n+            } else {\n+                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n+                ArrayUtil.reverse(uArray);\n+                return Arrays.copyOf(uArray, Npk);\n+            }\n+        }\n+\n+        private PublicKey DeserializePublicKey(byte[] data)\n+                throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+            KeySpec keySpec;\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) this.spec;\n+                keySpec = new ECPublicKeySpec(\n+                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n+            } else {\n+                data = data.clone();\n+                ArrayUtil.reverse(data);\n+                keySpec = new XECPublicKeySpec(\n+                        this.spec, new BigInteger(1, data));\n+            }\n+            return KeyFactory.getInstance(keyAlgorithm).generatePublic(keySpec);\n+        }\n+\n+        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n+            ka.init(skE);\n+            ka.doPhase(pkR, true);\n+            return ka.generateSecret();\n+        }\n+\n+        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            HKDF kdf = new HKDF(hkdfAlgorithm);\n+            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n+            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n+                    kem_context, Nsecret);\n+        }\n+\n+        private PublicKey getPublicKey(PrivateKey sk)\n+                throws InvalidKeyException {\n+            if (!(sk instanceof InternalPrivateKey)) {\n+                try {\n+                    KeyFactory kf = KeyFactory.getInstance(keyAlgorithm, \"SunEC\");\n+                    sk = (PrivateKey) kf.translateKey(sk);\n+                } catch (Exception e) {\n+                    throw new InvalidKeyException(\"Error translating key\", e);\n+                }\n+            }\n+            if (sk instanceof InternalPrivateKey ik) {\n+                try {\n+                    return ik.calculatePublicKey();\n+                } catch (UnsupportedOperationException e) {\n+                    throw new InvalidKeyException(\"Error retrieving key\", e);\n+                }\n+            } else {\n+                \/\/ Should not happen, unless SunEC goes wrong\n+                throw new ProviderException(\"Unknown key\");\n+            }\n+        }\n+\n+        \/\/ For KAT tests only. See RFC9180DeriveKeyPairSR.\n+        public KeyPair deriveKeyPair(byte[] ikm) throws Exception {\n+            HKDF kdf = new HKDF(hkdfAlgorithm);\n+            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) spec;\n+                BigInteger sk = BigInteger.ZERO;\n+                int counter = 0;\n+                while (sk.signum() == 0 || sk.compareTo(curve.getOrder()) >= 0) {\n+                    if (counter > 255) {\n+                        throw new RuntimeException();\n+                    }\n+                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n+                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    \/\/ bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521\n+                    if (this == Params.P521) {\n+                        bytes[0] = (byte) (bytes[0] & 0x01);\n+                    }\n+                    sk = new BigInteger(1, (bytes));\n+                    counter = counter + 1;\n+                }\n+                PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n+                return new KeyPair(getPublicKey(k), k);\n+            } else {\n+                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                PrivateKey k = DeserializePrivateKey(sk);\n+                return new KeyPair(getPublicKey(k), k);\n+            }\n+        }\n+\n+        private PrivateKey DeserializePrivateKey(byte[] data) throws Exception {\n+            KeySpec keySpec = isEC()\n+                    ? new ECPrivateKeySpec(new BigInteger(1, (data)), (NamedCurve) spec)\n+                    : new XECPrivateKeySpec(spec, data);\n+            return KeyFactory.getInstance(keyAlgorithm).generatePrivate(keySpec);\n+        }\n+    }\n+\n+    private static SecureRandom getSecureRandom(SecureRandom userSR) {\n+        return userSR != null ? userSR : JCAUtil.getSecureRandom();\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (sk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(sk);\n+        return new Handler(params, null, sk, params.getPublicKey(sk));\n+    }\n+\n+    private Params paramsFromKey(Key k) throws InvalidKeyException {\n+        if (k instanceof ECKey eckey) {\n+            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+                return Params.P256;\n+            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+                return Params.P384;\n+            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+                return Params.P521;\n+            }\n+        } else if (k instanceof XECKey xkey\n+                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+            if (ns.getName().equals(\"X25519\")) {\n+                return Params.X25519;\n+            } else if (ns.getName().equals(\"X448\")) {\n+                return Params.X448;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unsupported key\");\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        ByteArrayOutputStream o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+\n+    private static byte[] I2OSP(int n, int w) {\n+        assert n < 256;\n+        assert w == 1 || w == 2;\n+        if (w == 1) {\n+            return new byte[] { (byte) n };\n+        } else {\n+            return new byte[] { (byte) (n >> 8), (byte) n };\n+        }\n+    }\n+\n+    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n+            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n+        return kdf.extract(salt,\n+                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n+                    \"HKDF-PRK\");\n+    }\n+\n+    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n+            SecretKey prk, byte[] label, byte[] info, int L)\n+            throws InvalidKeyException {\n+        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n+                suite_id, label, info);\n+        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-\n-import javax.crypto.SecretKey;\n@@ -32,1 +29,1 @@\n-import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -35,0 +32,4 @@\n+import java.util.Arrays;\n+\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.PBEUtil;\n@@ -111,25 +112,4 @@\n-        char[] passwdChars;\n-        byte[] salt = null;\n-        int iCount = 0;\n-        if (key instanceof javax.crypto.interfaces.PBEKey) {\n-            javax.crypto.interfaces.PBEKey pbeKey =\n-                (javax.crypto.interfaces.PBEKey) key;\n-            passwdChars = pbeKey.getPassword();\n-            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n-            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n-        } else if (key instanceof SecretKey) {\n-            byte[] passwdBytes;\n-            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n-                    (passwdBytes = key.getEncoded()) == null) {\n-                throw new InvalidKeyException(\"Missing password\");\n-            }\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i=0; i<passwdChars.length; i++) {\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-            }\n-            Arrays.fill(passwdBytes, (byte)0x00);\n-        } else {\n-            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n-        }\n-\n-        byte[] derivedKey;\n+        char[] password = null;\n+        byte[] derivedKey = null;\n+        SecretKeySpec cipherKey = null;\n+        PBEKeySpec keySpec = PBEUtil.getPBAKeySpec(key, params);\n@@ -137,30 +117,11 @@\n-            if (params == null) {\n-                \/\/ should not auto-generate default values since current\n-                \/\/ javax.crypto.Mac api does not have any method for caller to\n-                \/\/ retrieve the generated defaults.\n-                if ((salt == null) || (iCount == 0)) {\n-                    throw new InvalidAlgorithmParameterException\n-                            (\"PBEParameterSpec required for salt and iteration count\");\n-                }\n-            } else if (!(params instanceof PBEParameterSpec)) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"PBEParameterSpec type required\");\n-            } else {\n-                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n-                \/\/ make sure the parameter values are consistent\n-                if (salt != null) {\n-                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Inconsistent value of salt between key and params\");\n-                    }\n-                } else {\n-                    salt = pbeParams.getSalt();\n-                }\n-                if (iCount != 0) {\n-                    if (iCount != pbeParams.getIterationCount()) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Different iteration count between key and params\");\n-                    }\n-                } else {\n-                    iCount = pbeParams.getIterationCount();\n-                }\n+            password = keySpec.getPassword();\n+            derivedKey = PKCS12PBECipherCore.derive(\n+                    password, keySpec.getSalt(),\n+                    keySpec.getIterationCount(), engineGetMacLength(),\n+                    PKCS12PBECipherCore.MAC_KEY, algorithm, bl);\n+            cipherKey = new SecretKeySpec(derivedKey, \"HmacSHA1\");\n+            super.engineInit(cipherKey, null);\n+        } finally {\n+            if (cipherKey != null) {\n+                SharedSecrets.getJavaxCryptoSpecAccess()\n+                        .clearSecretKeySpec(cipherKey);\n@@ -168,6 +129,2 @@\n-            \/\/ For security purpose, we need to enforce a minimum length\n-            \/\/ for salt; just require the minimum salt length to be 8-byte\n-            \/\/ which is what PKCS#5 recommends and openssl does.\n-            if (salt.length < 8) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"Salt must be at least 8 bytes long\");\n+            if (derivedKey != null) {\n+                Arrays.fill(derivedKey, (byte) 0);\n@@ -175,3 +132,2 @@\n-            if (iCount <= 0) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"IterationCount must be a positive number\");\n+            if (password != null) {\n+                Arrays.fill(password, '\\0');\n@@ -179,5 +135,1 @@\n-            derivedKey = PKCS12PBECipherCore.derive(passwdChars, salt,\n-                    iCount, engineGetMacLength(), PKCS12PBECipherCore.MAC_KEY,\n-                    algorithm, bl);\n-        } finally {\n-            Arrays.fill(passwdChars, '\\0');\n+            keySpec.clearPassword();\n@@ -185,2 +137,0 @@\n-        SecretKey cipherKey = new SecretKeySpec(derivedKey, \"HmacSHA1\");\n-        super.engineInit(cipherKey, null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HmacPKCS12PBECore.java","additions":26,"deletions":76,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.PBEUtil;\n+\n@@ -46,4 +49,0 @@\n-\n-    private static final int DEFAULT_SALT_LENGTH = 20;\n-    private static final int DEFAULT_COUNT = 4096;\n-\n@@ -57,3 +56,1 @@\n-    private int iCount = DEFAULT_COUNT;\n-    private byte[] salt = null;\n-    private IvParameterSpec ivSpec = null;\n+    private final PBEUtil.PBES2Params pbes2Params = new PBEUtil.PBES2Params();\n@@ -138,26 +135,2 @@\n-        AlgorithmParameters params = null;\n-        if (salt == null) {\n-            \/\/ generate random salt and use default iteration count\n-            salt = new byte[DEFAULT_SALT_LENGTH];\n-            SunJCE.getRandom().nextBytes(salt);\n-            iCount = DEFAULT_COUNT;\n-        }\n-        if (ivSpec == null) {\n-            \/\/ generate random IV\n-            byte[] ivBytes = new byte[blkSize];\n-            SunJCE.getRandom().nextBytes(ivBytes);\n-            ivSpec = new IvParameterSpec(ivBytes);\n-        }\n-        PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, iCount, ivSpec);\n-        try {\n-            params = AlgorithmParameters.getInstance(pbeAlgo,\n-                SunJCE.getInstance());\n-            params.init(pbeSpec);\n-        } catch (NoSuchAlgorithmException nsae) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"SunJCE called, but not configured\");\n-        } catch (InvalidParameterSpecException ipse) {\n-            \/\/ should never happen\n-            throw new RuntimeException(\"PBEParameterSpec not supported\");\n-        }\n-        return params;\n+        return pbes2Params.getAlgorithmParameters(\n+                blkSize, pbeAlgo, SunJCE.getInstance(), SunJCE.getRandom());\n@@ -175,18 +148,0 @@\n-    private static byte[] check(byte[] salt)\n-        throws InvalidAlgorithmParameterException {\n-        if (salt != null && salt.length < 8) {\n-            throw new InvalidAlgorithmParameterException(\n-                    \"Salt must be at least 8 bytes long\");\n-        }\n-        return salt;\n-    }\n-\n-    private static int check(int iCount)\n-        throws InvalidAlgorithmParameterException {\n-        if (iCount < 0) {\n-            throw new InvalidAlgorithmParameterException(\n-                    \"Iteration count must be a positive number\");\n-        }\n-        return iCount == 0 ? DEFAULT_COUNT : iCount;\n-    }\n-\n@@ -198,75 +153,4 @@\n-        if (key == null) {\n-            throw new InvalidKeyException(\"Null key\");\n-        }\n-\n-        byte[] passwdBytes = key.getEncoded();\n-        char[] passwdChars = null;\n-        salt = null;\n-        iCount = 0;\n-        ivSpec = null;\n-\n-        PBEKeySpec pbeSpec;\n-        try {\n-            if ((passwdBytes == null) ||\n-                    !(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3))) {\n-                throw new InvalidKeyException(\"Missing password\");\n-            }\n-\n-            boolean doEncrypt = ((opmode == Cipher.ENCRYPT_MODE) ||\n-                        (opmode == Cipher.WRAP_MODE));\n-\n-            \/\/ Extract from the supplied PBE params, if present\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                \/\/ salt should be non-null per PBEParameterSpec\n-                salt = check(pbeParams.getSalt());\n-                iCount = check(pbeParams.getIterationCount());\n-                AlgorithmParameterSpec ivParams = pbeParams.getParameterSpec();\n-                if (ivParams instanceof IvParameterSpec iv) {\n-                    ivSpec = iv;\n-                } else if (ivParams == null && doEncrypt) {\n-                    \/\/ generate random IV\n-                    byte[] ivBytes = new byte[blkSize];\n-                    random.nextBytes(ivBytes);\n-                    ivSpec = new IvParameterSpec(ivBytes);\n-                } else {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Wrong parameter type: IV expected\");\n-                }\n-            } else if (params == null && doEncrypt) {\n-                \/\/ Try extracting from the key if present. If unspecified,\n-                \/\/ PBEKey returns null and 0 respectively.\n-                if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n-                    salt = check(pbeKey.getSalt());\n-                    iCount = check(pbeKey.getIterationCount());\n-                }\n-                if (salt == null) {\n-                    \/\/ generate random salt\n-                    salt = new byte[DEFAULT_SALT_LENGTH];\n-                    random.nextBytes(salt);\n-                }\n-                if (iCount == 0) {\n-                    \/\/ use default iteration count\n-                    iCount = DEFAULT_COUNT;\n-                }\n-                \/\/ generate random IV\n-                byte[] ivBytes = new byte[blkSize];\n-                random.nextBytes(ivBytes);\n-                ivSpec = new IvParameterSpec(ivBytes);\n-            } else {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"Wrong parameter type: PBE expected\");\n-            }\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i = 0; i < passwdChars.length; i++)\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-\n-            pbeSpec = new PBEKeySpec(passwdChars, salt, iCount, keyLength);\n-        } finally {\n-            \/\/ password char[] was cloned in PBEKeySpec constructor,\n-            \/\/ so we can zero it out here\n-            if (passwdChars != null) Arrays.fill(passwdChars, '\\0');\n-            if (passwdBytes != null) Arrays.fill(passwdBytes, (byte)0x00);\n-        }\n-\n-        PBKDF2KeyImpl s;\n-\n+        PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(blkSize, keyLength,\n+                opmode, key, params, random);\n+        PBKDF2KeyImpl s = null;\n+        byte[] derivedKey;\n@@ -275,0 +159,1 @@\n+            derivedKey = s.getEncoded();\n@@ -278,0 +163,3 @@\n+            if (s != null) {\n+                s.clear();\n+            }\n@@ -280,3 +168,0 @@\n-        byte[] derivedKey = s.getEncoded();\n-        s.clearPassword();\n-        SecretKeySpec cipherKey = new SecretKeySpec(derivedKey, cipherAlgo);\n@@ -284,2 +169,12 @@\n-        \/\/ initialize the underlying cipher\n-        cipher.init(opmode, cipherKey, ivSpec, random);\n+        SecretKeySpec cipherKey = null;\n+        try {\n+            cipherKey = new SecretKeySpec(derivedKey, cipherAlgo);\n+            \/\/ initialize the underlying cipher\n+            cipher.init(opmode, cipherKey, pbes2Params.getIvSpec(), random);\n+        } finally {\n+            if (cipherKey != null) {\n+                SharedSecrets.getJavaxCryptoSpecAccess()\n+                        .clearSecretKeySpec(cipherKey);\n+            }\n+            Arrays.fill(derivedKey, (byte) 0);\n+        }\n@@ -291,10 +186,2 @@\n-        AlgorithmParameterSpec pbeSpec = null;\n-        if (params != null) {\n-            try {\n-                pbeSpec = params.getParameterSpec(PBEParameterSpec.class);\n-            } catch (InvalidParameterSpecException ipse) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"Wrong parameter type: PBE expected\");\n-            }\n-        }\n-        engineInit(opmode, key, pbeSpec, random);\n+        engineInit(opmode, key, PBEUtil.PBES2Params.getParameterSpec(params),\n+                random);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Core.java","additions":29,"deletions":142,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import java.lang.ref.Reference;\n+import java.lang.ref.Cleaner;\n@@ -67,3 +67,3 @@\n-    @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable;\n-                                \/\/ see writeReplace method\n-    private Mac prf;\n+    \/\/ The following fields are not Serializable. See writeReplace method.\n+    private transient Mac prf;\n+    private transient Cleaner.Cleanable cleaner;\n@@ -91,7 +91,1 @@\n-        char[] passwd = keySpec.getPassword();\n-        if (passwd == null) {\n-            \/\/ Should allow an empty password.\n-            this.passwd = new char[0];\n-        } else {\n-            this.passwd = passwd.clone();\n-        }\n+        this.passwd = keySpec.getPassword();\n@@ -100,2 +94,0 @@\n-        \/\/ remove local copy\n-        if (passwd != null) Arrays.fill(passwd, '\\0');\n@@ -127,9 +119,3 @@\n-\n-            \/\/ Use the cleaner to zero the key when no longer referenced\n-            final byte[] k = this.key;\n-            final char[] p = this.passwd;\n-            CleanerFactory.cleaner().register(this,\n-                    () -> {\n-                        Arrays.fill(k, (byte) 0x00);\n-                        Arrays.fill(p, '\\0');\n-                    });\n+            if (key == null) {\n+                Arrays.fill(passwd, '\\0');\n+            }\n@@ -137,0 +123,8 @@\n+        \/\/ Use the cleaner to zero the key when no longer referenced\n+        final byte[] k = this.key;\n+        final char[] p = this.passwd;\n+        cleaner = CleanerFactory.cleaner().register(this,\n+                () -> {\n+                    Arrays.fill(k, (byte) 0x00);\n+                    Arrays.fill(p, '\\0');\n+                });\n@@ -214,5 +208,1 @@\n-        \/\/ The key is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        byte[] result = key.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        return key.clone();\n@@ -229,2 +219,2 @@\n-    public void clearPassword() {\n-        Arrays.fill(passwd, (char)0);\n+    public void clear() {\n+        cleaner.clean();\n@@ -234,5 +224,1 @@\n-        \/\/ The password is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        char[] result = passwd.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        return passwd.clone();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -182,2 +184,2 @@\n-        PBKDF2Core kdf = getKDFImpl(kdfAlgo);\n-        byte[] derivedKey;\n+        byte[] derivedKey = null;\n+        SecretKeySpec cipherKey = null;\n@@ -185,0 +187,1 @@\n+            PBKDF2Core kdf = getKDFImpl(kdfAlgo);\n@@ -187,0 +190,2 @@\n+            cipherKey = new SecretKeySpec(derivedKey, kdfAlgo);\n+            super.engineInit(cipherKey, null);\n@@ -190,1 +195,7 @@\n-            pbeSpec.clearPassword();\n+            if (cipherKey != null) {\n+                SharedSecrets.getJavaxCryptoSpecAccess()\n+                        .clearSecretKeySpec(cipherKey);\n+            }\n+            if (derivedKey != null) {\n+                Arrays.fill(derivedKey, (byte) 0);\n+            }\n@@ -192,1 +203,1 @@\n-                s.clearPassword();\n+                s.clear();\n@@ -194,0 +205,1 @@\n+            pbeSpec.clearPassword();\n@@ -195,4 +207,0 @@\n-        SecretKey cipherKey = new SecretKeySpec(derivedKey, kdfAlgo);\n-        Arrays.fill(derivedKey, (byte)0);\n-\n-        super.engineInit(cipherKey, null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBMAC1Core.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,4 @@\n+ * - JCEKS KeyStore\n+ *\n+ * - DHKEM\n+ *\n@@ -746,0 +750,9 @@\n+        \/*\n+         * KEMs\n+         *\/\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        attrs.put(\"SupportedKeyClasses\", \"java.security.interfaces.ECKey\" +\n+                \"|java.security.interfaces.XECKey\");\n+        ps(\"KEM\", \"DHKEM\", \"com.sun.crypto.provider.DHKEM\", null, attrs);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -75,0 +76,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -84,0 +86,1 @@\n+\n@@ -129,6 +132,5 @@\n- * <blockquote><pre>\n- *     void printClassName(Object obj) {\n- *         System.out.println(\"The class of \" + obj +\n- *                            \" is \" + obj.getClass().getName());\n- *     }\n- * <\/pre><\/blockquote>\n+ * {@snippet lang=\"java\" :\n+ * void printClassName(Object obj) {\n+ *     System.out.println(\"The class of \" + obj +\n+ *                        \" is \" + obj.getClass().getName());\n+ * }}\n@@ -140,3 +142,3 @@\n- * <blockquote>\n- *     {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}\n- * <\/blockquote>\n+ * {@snippet lang=\"java\" :\n+ * System.out.println(\"The name of class Foo is: \"+Foo.class.getName());\n+ * }\n@@ -161,1 +163,2 @@\n- * <p> A class or interface created by the invocation of\n+ * <h2><a id=hiddenClasses>Hidden Classes<\/a><\/h2>\n+ * A class or interface created by the invocation of\n@@ -189,0 +192,25 @@\n+ * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n+ *\n+ * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n+ * is generated by a Java compiler from a source file for an unnamed class.\n+ * The {@code Class} object representing an unnamed class is top-level,\n+ * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n+ * unnamed class does <em>not<\/em> have a name in its Java source\n+ * form, several of the name-related methods of {@code java.lang.Class}\n+ * do return non-null and non-empty results for the {@code Class}\n+ * object representing an unnamed class.\n+ *\n+ * Conventionally, a Java compiler, starting from a source file for an\n+ * unnamed class, say {@code HelloWorld.java}, creates a\n+ * similarly-named {@code class} file, {@code HelloWorld.class}, where\n+ * the class stored in that {@code class} file is named {@code\n+ * \"HelloWorld\"}, matching the base names of the source and {@code\n+ * class} files.\n+ *\n+ * For the {@code Class} object of an unnamed class {@code\n+ * HelloWorld}, the methods to get the {@linkplain #getName name} and\n+ * {@linkplain #getTypeName type name} return results\n+ * equal to {@code \"HelloWorld\"}. The {@linkplain #getSimpleName\n+ * simple name} of such an unnamed class is the empty string and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ *\n@@ -344,3 +372,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(className, true, currentLoader)}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(className, true, currentLoader)\n+     * }\n@@ -355,3 +383,3 @@\n-     * <blockquote>\n-     *   {@code Class t = Class.forName(\"java.lang.Thread\")}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class<?> t = Class.forName(\"java.lang.Thread\");\n+     * }\n@@ -418,3 +446,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(\"Foo\")}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(\"Foo\")\n+     * }\n@@ -424,3 +452,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(\"Foo\", true, this.getClass().getClassLoader())}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(\"Foo\", true, this.getClass().getClassLoader())\n+     * }\n@@ -610,1 +638,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -612,1 +640,1 @@\n-     * }<\/pre>\n+     * }\n@@ -616,1 +644,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -618,1 +646,1 @@\n-     * }<\/pre>\n+     * }\n@@ -1721,1 +1749,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous}.\n+     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n@@ -1734,0 +1762,3 @@\n+        if (isUnnamedClass()) {\n+            return \"\";\n+        }\n@@ -1783,0 +1814,1 @@\n+     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1802,0 +1834,3 @@\n+        if (isUnnamedClass()) {\n+            return null;\n+        }\n@@ -1836,0 +1871,20 @@\n+    \/**\n+     * {@return {@code true} if and only if the underlying class\n+     * is an unnamed class}\n+     *\n+     * @apiNote\n+     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n+     *\n+     * @since 21\n+     *\n+     * @jls 7.3 Compilation Units\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    public boolean isUnnamedClass() {\n+        return PreviewFeatures.isEnabled() && isSynthetic()\n+                                           && isTopLevelClass()\n+                                           && Modifier.isFinal(getModifiers());\n+    }\n+\n+\n@@ -1842,0 +1897,1 @@\n+     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n@@ -2488,1 +2544,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -2496,1 +2552,1 @@\n-     * }}<\/pre>\n+     * }}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":86,"deletions":30,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,962 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.ScopedValueContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * A value that may be safely and efficiently shared to methods without using method\n+ * parameters.\n+ *\n+ * <p> In the Java programming language, data is usually passed to a method by means of a\n+ * method parameter. The data may need to be passed through a sequence of many methods to\n+ * get to the method that makes use of the data. Every method in the sequence of calls\n+ * needs to declare the parameter and every method has access to the data.\n+ * {@code ScopedValue} provides a means to pass data to a faraway method (typically a\n+ * <em>callback<\/em>) without using method parameters. In effect, a {@code ScopedValue}\n+ * is an <em>implicit method parameter<\/em>. It is \"as if\" every method in a sequence of\n+ * calls has an additional parameter. None of the methods declare the parameter and only\n+ * the methods that have access to the {@code ScopedValue} object can access its value\n+ * (the data). {@code ScopedValue} makes it possible to securely pass data from a\n+ * <em>caller<\/em> to a faraway <em>callee<\/em> through a sequence of intermediate methods\n+ * that do not declare a parameter for the data and have no access to the data.\n+ *\n+ * <p> The {@code ScopedValue} API works by executing a method with a {@code ScopedValue}\n+ * object <em>bound<\/em> to some value for the bounded period of execution of a method.\n+ * The method may invoke another method, which in turn may invoke another. The unfolding\n+ * execution of the methods define a <em>dynamic scope<\/em>. Code in these methods with\n+ * access to the {@code ScopedValue} object may read its value. The {@code ScopedValue}\n+ * object reverts to being <em>unbound<\/em> when the original method completes normally or\n+ * with an exception. The {@code ScopedValue} API supports executing a {@link Runnable#run()\n+ * Runnable.run}, {@link Callable#call() Callable.call}, or {@link Supplier#get() Supplier.get}\n+ * method with a {@code ScopedValue} bound to a value.\n+ *\n+ * <p> Consider the following example with a scoped value \"{@code NAME}\" bound to the value\n+ * \"{@code duke}\" for the execution of a {@code run} method. The {@code run} method, in\n+ * turn, invokes {@code doSomething}.\n+ * {@snippet lang=java :\n+ *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"runWhere\" target=\"#runWhere\" :\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> doSomething());\n+ * }\n+ * Code executed directly or indirectly by {@code doSomething}, with access to the field\n+ * {@code NAME}, can invoke {@code NAME.get()} to read the value \"{@code duke}\". {@code\n+ * NAME} is bound while executing the {@code run} method. It reverts to being unbound when\n+ * the {@code run} method completes.\n+ *\n+ * <p> The example using {@code runWhere} invokes a method that does not return a result.\n+ * The {@link #callWhere(ScopedValue, Object, Callable) callWhere} and {@link\n+ * #getWhere(ScopedValue, Object, Supplier) getWhere} can be used to invoke a method that\n+ * returns a result.\n+ * In addition, {@code ScopedValue} defines the {@link #where(ScopedValue, Object)} method\n+ * for cases where multiple mappings (of {@code ScopedValue} to value) are accumulated\n+ * in advance of calling a method with all {@code ScopedValue}s bound to their value.\n+ *\n+ * <h2>Bindings are per-thread<\/h2>\n+ *\n+ * A {@code ScopedValue} binding to a value is per-thread. Invoking {@code xxxWhere}\n+ * executes a method with a {@code ScopedValue} bound to a value for the current thread.\n+ * The {@link #get() get} method returns the value bound for the current thread.\n+ *\n+ * <p> In the example, if code executed by one thread invokes this:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke1\", () -> doSomething());\n+ * }\n+ * and code executed by another thread invokes:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke2\", () -> doSomething());\n+ * }\n+ * then code in {@code doSomething} (or any method that it calls) invoking {@code NAME.get()}\n+ * will read the value \"{@code duke1}\" or \"{@code duke2}\", depending on which thread is\n+ * executing.\n+ *\n+ * <h2>Scoped values as capabilities<\/h2>\n+ *\n+ * A {@code ScopedValue} object should be treated as a <em>capability<\/em> or a key to\n+ * access its value when the {@code ScopedValue} is bound. Secure usage depends on access\n+ * control (see <cite>The Java Virtual Machine Specification<\/cite>, Section {@jvms 5.4.4})\n+ * and taking care to not share the {@code ScopedValue} object. In many cases, a {@code\n+ * ScopedValue} will be declared in a {@code final} and {@code static} field so that it\n+ * is only accessible to code in a single class (or nest).\n+ *\n+ * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n+ *\n+ * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n+ * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n+ * is bound to a value may be bound to a new value for the bounded execution of a new\n+ * method. The unfolding execution of code executed by that method defines the nested\n+ * dynamic scope. When the method completes, the value of the {@code ScopedValue} reverts\n+ * to its previous value.\n+ *\n+ * <p> In the above example, suppose that code executed by {@code doSomething} binds\n+ * {@code NAME} to a new value with:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duchess\", () -> doMore());\n+ * }\n+ * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n+ * NAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * then the value of {@code NAME} reverts to \"{@code duke}\".\n+ *\n+ * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n+ *\n+ * {@code ScopedValue} supports sharing across threads. This sharing is limited to\n+ * structured cases where child threads are started and terminate within the bounded\n+ * period of execution by a parent thread. When using a {@link StructuredTaskScope},\n+ * scoped value bindings are <em>captured<\/em> when creating a {@code StructuredTaskScope}\n+ * and inherited by all threads started in that task scope with the\n+ * {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> A {@code ScopedValue} that is shared across threads requires that the value be an\n+ * immutable object or for all access to the value to be appropriately synchronized.\n+ *\n+ * <p> In the following example, the {@code ScopedValue} {@code NAME} is bound to the\n+ * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n+ * run} method creates a {@code StructuredTaskScope} that forks three tasks. Code executed\n+ * directly or indirectly by these threads running {@code childTask1()}, {@code childTask2()},\n+ * and {@code childTask3()} that invokes {@code NAME.get()} will read the value\n+ * \"{@code duke}\".\n+ *\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n+\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask1());\n+ *             scope.fork(() -> childTask2());\n+ *             scope.fork(() -> childTask3());\n+ *\n+ *             ...\n+ *          }\n+ *     });\n+ * }\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * A {@code ScopedValue} should be preferred over a {@link ThreadLocal} for cases where\n+ * the goal is \"one-way transmission\" of data without using method parameters.  While a\n+ * {@code ThreadLocal} can be used to pass data to a method without using method parameters,\n+ * it does suffer from a number of issues:\n+ * <ol>\n+ *   <li> {@code ThreadLocal} does not prevent code in a faraway callee from {@linkplain\n+ *   ThreadLocal#set(Object) setting} a new value.\n+ *   <li> A {@code ThreadLocal} has an unbounded lifetime and thus continues to have a value\n+ *   after a method completes, unless explicitly {@linkplain ThreadLocal#remove() removed}.\n+ *   <li> {@linkplain InheritableThreadLocal Inheritance} is expensive - the map of\n+ *   thread-locals to values must be copied when creating each child thread.\n+ * <\/ol>\n+ *\n+ * @implNote\n+ * Scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find a scoped value's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving a scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single {@code ScopedValue} to an instance of that record.\n+ *\n+ * <p>For this release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n+ *\n+ * <p>The system property {@code java.lang.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djava.lang.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the type of the value\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n+public final class ScopedValue<T> {\n+    private final int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static final class Snapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    \/**\n+     * A mapping of scoped values, as <em>keys<\/em>, to values.\n+     *\n+     * <p> A {@code Carrier} is used to accumulate mappings so that an operation (a\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n+     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n+     * it does not mutate an existing mapping.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n+     * this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static <T> Carrier where(ScopedValue<T> key, T value, Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n+         * new mapping from {@code key} to {@code value}. If this carrier already has a\n+         * mapping for the scoped value {@code key} then it will map to the new\n+         * {@code value}. The current carrier is immutable, so it is not changed by this\n+         * method.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param value the value, can be {@code null}\n+         * @param <T> the type of the value\n+         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        Object get() {\n+            return value;\n+        }\n+\n+        ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a {@link ScopedValue} in this mapping.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param <T> the type of the value\n+         * @return the value\n+         * @throws NoSuchElementException if the key is not present in this mapping\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Calls a value-returning operation with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         * @see ScopedValue#callWhere(ScopedValue, Object, Callable)\n+         *\/\n+        public <R> R call(Callable<? extends R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Invokes a supplier of results with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @see ScopedValue#getWhere(ScopedValue, Object, Supplier)\n+         *\/\n+        public <R> R get(Supplier<? extends R> op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, new CallableAdapter<R>(op));\n+        }\n+\n+        \/\/ A lightweight adapter from Supplier to Callable. This is\n+        \/\/ used here to create the Callable which is passed to\n+        \/\/ Carrier#call() in this thread because it needs neither\n+        \/\/ runtime bytecode generation nor any release fencing.\n+        private static final class CallableAdapter<V> implements Callable<V> {\n+            private \/*non-final*\/ Supplier<? extends V> s;\n+            CallableAdapter(Supplier<? extends V> s) {\n+                this.s = s;\n+            }\n+            public V call() {\n+                return s.get();\n+            }\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) {\n+            try {\n+                Thread.setScopedValueBindings(newSnapshot);\n+                Thread.ensureMaterializedForStackWalk(newSnapshot);\n+                return ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                Thread.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with each scoped value in this mapping bound to its value\n+         * in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @see ScopedValue#runWhere(ScopedValue, Object, Runnable)\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of {@code ScopedValue} bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private void runWith(Snapshot newSnapshot, Runnable op) {\n+            try {\n+                Thread.setScopedValueBindings(newSnapshot);\n+                Thread.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                Thread.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n+     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n+     * that an operation can be executed with all scoped values in the mapping bound to\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @return a new {@code Carrier} with a single mapping\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n+     *     ScopedValue.where(key, value).call(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, R> R callWhere(ScopedValue<T> key,\n+                                     T value,\n+                                     Callable<? extends R> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Invokes a supplier of results with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"get\" target=\"Carrier#get(Supplier)\" :\n+     *     ScopedValue.where(key, value).get(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     *\/\n+    public static <T, R> R getWhere(ScopedValue<T> key,\n+                                    T value,\n+                                    Supplier<? extends R> op) {\n+        return where(key, value).get(op);\n+    }\n+\n+    \/**\n+     * Run an operation with a {@code ScopedValue} bound to a value in the current\n+     * thread. When the operation completes (normally or with an exception), the\n+     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n+     * when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(key, value).run(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param op the operation to call\n+     *\/\n+    public static <T> void runWhere(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped value that is initially unbound for all threads.\n+     *\n+     * @param <T> the type of the value\n+     * @return a new {@code ScopedValue}\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * {@return the value of the scoped value if bound in the current thread}\n+     *\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n+     *\/\n+    public boolean isBound() {\n+        Object[] objects = scopedValueCache();\n+        if (objects != null) {\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+        }\n+        var value = findBinding();\n+        boolean result = (value != Snapshot.NIL);\n+        if (result)  Cache.put(this, value);\n+        return result;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * returns {@code other}.\n+     *\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * throws an exception produced by the exception supplying function.\n+     *\n+     * @param <X> the type of the exception that may be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound in the current thread\n+     * @throws X if the scoped value is not bound in the current thread\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return Thread.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        Thread.setScopedValueCache(cache);\n+    }\n+\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in j.l.Thread.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke Thread.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = Thread.scopedValueBindings();\n+        if (bindings == NEW_THREAD_BINDINGS) {\n+            \/\/ This must be a new thread\n+           return Snapshot.EMPTY_SNAPSHOT;\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = Thread.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                bindings = Snapshot.EMPTY_SNAPSHOT;\n+            }\n+        }\n+        assert (bindings != null);\n+        Thread.setScopedValueBindings(bindings);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static final class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":962,"deletions":0,"binary":false,"changes":962,"status":"added"},{"patch":"@@ -756,1 +756,4 @@\n-     *     <td>Java class format version number<\/td><\/tr>\n+     *     <td>{@linkplain java.lang.reflect.ClassFileFormatVersion#latest() Latest}\n+     *     Java class file format version recognized by the Java runtime as {@code \"MAJOR.MINOR\"}\n+     *     where {@link java.lang.reflect.ClassFileFormatVersion#major() MAJOR} and {@code MINOR}\n+     *     are both formatted as decimal integers<\/td><\/tr>\n@@ -2621,13 +2624,0 @@\n-            public Object findScopedValueBindings() {\n-                return Thread.findScopedValueBindings();\n-            }\n-\n-            public void setScopedValueBindings(Object bindings) {\n-                Thread.setScopedValueBindings(bindings);\n-            }\n-\n-            @ForceInline\n-            public void ensureMaterializedForStackWalk(Object value) {\n-                Thread.ensureMaterializedForStackWalk(value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -42,1 +43,0 @@\n-import jdk.internal.misc.StructureViolationExceptions;\n@@ -324,1 +324,1 @@\n-                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n+                throw new StructureViolationException(\"Scoped value bindings have changed\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return new MethodTypeDescImpl(returnDesc, ConstantUtils.EMPTY_CLASSDESC);\n+        return MethodTypeDescImpl.ofTrusted(returnDesc, ConstantUtils.EMPTY_CLASSDESC);\n@@ -98,1 +98,1 @@\n-        return new MethodTypeDescImpl(returnDesc, paramDescs);\n+        return MethodTypeDescImpl.ofTrusted(returnDesc, paramDescs.clone());\n@@ -198,7 +198,1 @@\n-    default String descriptorString() {\n-        return String.format(\"(%s)%s\",\n-                             Stream.of(parameterArray())\n-                                   .map(ClassDesc::descriptorString)\n-                                   .collect(Collectors.joining()),\n-                             returnType().descriptorString());\n-    }\n+    String descriptorString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -34,0 +36,1 @@\n+import java.util.StringJoiner;\n@@ -44,1 +47,2 @@\n-    private final ClassDesc[] argTypes;\n+    private final @Stable ClassDesc[] argTypes;\n+    private @Stable String cachedDescriptorString;\n@@ -48,1 +52,1 @@\n-     * and parameter types\n+     * and a trusted and already-validated parameter types array.\n@@ -51,1 +55,1 @@\n-     * @param argTypes {@link ClassDesc}s describing the parameter types\n+     * @param validatedArgTypes {@link ClassDesc}s describing the trusted and validated parameter types\n@@ -53,1 +57,1 @@\n-    MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] argTypes) {\n+    private MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] validatedArgTypes) {\n@@ -55,1 +59,14 @@\n-        this.argTypes = requireNonNull(argTypes);\n+        this.argTypes = requireNonNull(validatedArgTypes);\n+    }\n+\n+    \/**\n+     * Constructs a {@linkplain MethodTypeDesc} with the specified return type\n+     * and a trusted parameter types array, which will be validated.\n+     *\n+     * @param returnType a {@link ClassDesc} describing the return type\n+     * @param trustedArgTypes {@link ClassDesc}s describing the trusted parameter types\n+     *\/\n+    static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+        Objects.requireNonNull(returnType);\n+        if (trustedArgTypes.length == 0) \/\/ implicit null check\n+            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n@@ -57,2 +74,2 @@\n-        for (ClassDesc cr : argTypes)\n-            if (cr.isPrimitive() && cr.descriptorString().equals(\"V\"))\n+        for (ClassDesc cd : trustedArgTypes)\n+            if (cd.isPrimitive() && cd.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n@@ -60,0 +77,2 @@\n+\n+        return new MethodTypeDescImpl(returnType, trustedArgTypes);\n@@ -73,0 +92,1 @@\n+\n@@ -74,2 +94,10 @@\n-        ClassDesc[] paramTypes = types.stream().skip(1).map(ClassDesc::ofDescriptor).toArray(ClassDesc[]::new);\n-        return new MethodTypeDescImpl(ClassDesc.ofDescriptor(types.get(0)), paramTypes);\n+\n+        int paramCount = types.size() - 1;\n+        var paramTypes = paramCount > 0 ? new ClassDesc[paramCount] : ConstantUtils.EMPTY_CLASSDESC;\n+        for (int i = 0; i < paramCount; i++) {\n+            paramTypes[i] = ClassDesc.ofDescriptor(types.get(i + 1));\n+        }\n+\n+        MethodTypeDescImpl result = ofTrusted(ClassDesc.ofDescriptor(types.getFirst()), paramTypes);\n+        result.cachedDescriptorString = descriptor;\n+        return result;\n@@ -105,1 +133,1 @@\n-        return MethodTypeDesc.of(returnType, argTypes);\n+        return new MethodTypeDescImpl(returnType, argTypes);\n@@ -112,1 +140,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return ofTrusted(returnType, newArgs);\n@@ -123,1 +151,1 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+        return ofTrusted(returnType, newArgs);\n@@ -130,0 +158,1 @@\n+\n@@ -134,1 +163,15 @@\n-        return MethodTypeDesc.of(returnType, newArgs);\n+\n+        return ofTrusted(returnType, newArgs);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var desc = this.cachedDescriptorString;\n+        if (desc != null)\n+            return desc;\n+\n+        var sj = new StringJoiner(\"\", \"(\", \")\" + returnType().descriptorString());\n+        for (int i = 0; i < parameterCount(); i++) {\n+            sj.add(parameterType(i).descriptorString());\n+        }\n+        return cachedDescriptorString = sj.toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":57,"deletions":14,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -368,5 +368,35 @@\n- * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n- * list or with an empty formal parameter list) are not supported directly by the native linker. However, it is still possible\n- * to link a variadic function by using a <em>specialized<\/em> function descriptor, together with a\n- * {@linkplain Linker.Option#firstVariadicArg(int) a linker option} which indicates the position of the first variadic argument\n- * in that specialized descriptor.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n+ * <ol>\n+ * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n+ * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n+ * <\/ol>\n+ * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n+ * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n+ * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n+ * of a fixed number and type.\n+ * <p>\n+ * It should be noted that values passed as variadic arguments undergo default argument promotion in C. For instance, the\n+ * following argument promotions are applied:\n+ * <ul>\n+ * <li>{@code _Bool} -> {@code unsigned int}<\/li>\n+ * <li>{@code [signed] char} -> {@code [signed] int}<\/li>\n+ * <li>{@code [signed] short} -> {@code [signed] int}<\/li>\n+ * <li>{@code float} -> {@code double}<\/li>\n+ * <\/ul>\n+ * whereby the signed-ness of the source type corresponds to the signed-ness of the promoted type. The complete process\n+ * of default argument promotion is described in the C specification. In effect these promotions place limits on the\n+ * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n+ * type.\n+ * <p>\n+ * The native linker only supports linking the specialized form of a variadic function. A variadic function in its specialized\n+ * form can be linked using a function descriptor describing the specialized form. Additionally, the\n+ * {@link Linker.Option#firstVariadicArg(int)} linker option must be provided to indicate the first variadic parameter in\n+ * the parameter list. The corresponding argument layout, and all following argument layouts in the specialized function\n+ * descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n+ * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * <p>\n+ * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n+ * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n+ * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n+ * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n+ * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.nio.file.Path;\n@@ -96,1 +95,1 @@\n-        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\"));\n+        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, \"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.file.Path;\n@@ -101,1 +100,1 @@\n-                Path.of(\"DUMP_METHOD_HANDLE_INTERNALS\"));\n+                \"DUMP_METHOD_HANDLE_INTERNALS\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import java.nio.file.Path;\n@@ -2255,1 +2254,1 @@\n-                \"jdk.invoke.MethodHandle.dumpClassFiles\", Path.of(\"DUMP_CLASS_FILES\"));\n+                \"jdk.invoke.MethodHandle.dumpClassFiles\", \"DUMP_CLASS_FILES\");\n@@ -3932,0 +3931,8 @@\n+        private boolean isArrayClone(byte refKind, Class<?> refc, MemberName m) {\n+            return Modifier.isProtected(m.getModifiers()) &&\n+                    refKind == REF_invokeVirtual &&\n+                    m.getDeclaringClass() == Object.class &&\n+                    m.getName().equals(\"clone\") &&\n+                    refc.isArray();\n+        }\n+\n@@ -3940,5 +3947,1 @@\n-            if (Modifier.isProtected(mods) &&\n-                    refKind == REF_invokeVirtual &&\n-                    m.getDeclaringClass() == Object.class &&\n-                    m.getName().equals(\"clone\") &&\n-                    refc.isArray()) {\n+            if (isArrayClone(refKind, refc, m)) {\n@@ -4071,1 +4074,1 @@\n-                !refc.isInterface() &&\n+                !refc.isInterface() && !lookupClass().isInterface() &&\n@@ -4104,1 +4107,6 @@\n-                    (MethodHandleNatives.refKindHasReceiver(refKind) && restrictProtectedReceiver(method))) {\n+                    (MethodHandleNatives.refKindHasReceiver(refKind) &&\n+                            restrictProtectedReceiver(method) &&\n+                            \/\/ All arrays simply inherit the protected Object.clone method.\n+                            \/\/ The leading argument is already restricted to the requested\n+                            \/\/ array type (not the lookup class).\n+                            !isArrayClone(refKind, refc, method))) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,0 +39,7 @@\n+ * @apiNote\n+ * The complete version used in a class file includes a major version\n+ * and a minor version; this enum only models the major version. A\n+ * Java virtual machine implementation is required to support a range\n+ * of major versions; see the corresponding edition of the <cite>The\n+ * Java Virtual Machine Specification<\/cite> for details.\n+ *\n@@ -67,1 +74,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -77,1 +84,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -83,1 +90,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -89,1 +96,1 @@\n-     * The version recognized by the Java 2 Platform, Standard\n+     * The version introduced by the Java 2 Platform, Standard\n@@ -103,1 +110,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -113,1 +120,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -123,1 +130,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -135,1 +142,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -147,1 +154,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -157,1 +164,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -169,1 +176,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -179,1 +186,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -189,1 +196,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -199,1 +206,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -211,1 +218,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -221,1 +228,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -238,1 +245,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -248,1 +255,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -258,1 +265,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -268,1 +275,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    private transient ConstructorRepository genericInfo;\n+    private transient volatile ConstructorRepository genericInfo;\n@@ -90,0 +90,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -96,0 +97,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    private transient FieldRepository genericInfo;\n+    private transient volatile FieldRepository genericInfo;\n@@ -109,0 +109,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -114,0 +115,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    private transient MethodRepository genericInfo;\n+    private transient volatile MethodRepository genericInfo;\n@@ -111,0 +111,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -116,0 +117,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    private transient FieldRepository genericInfo;\n+    private transient volatile FieldRepository genericInfo;\n@@ -130,0 +130,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -134,0 +135,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RecordComponent.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.invoke.ConstantBootstraps;\n@@ -35,0 +34,1 @@\n+import java.util.List;\n@@ -37,0 +37,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.Stable;\n@@ -39,1 +41,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -53,0 +54,1 @@\n+    private static final Object SENTINEL = new Object();\n@@ -55,2 +57,8 @@\n-    private static final MethodHandle DO_TYPE_SWITCH;\n-    private static final MethodHandle DO_ENUM_SWITCH;\n+    private static final MethodHandle INSTANCEOF_CHECK;\n+    private static final MethodHandle INTEGER_EQ_CHECK;\n+    private static final MethodHandle OBJECT_EQ_CHECK;\n+    private static final MethodHandle ENUM_EQ_CHECK;\n+    private static final MethodHandle NULL_CHECK;\n+    private static final MethodHandle IS_ZERO;\n+    private static final MethodHandle CHECK_INDEX;\n+    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n@@ -60,5 +68,18 @@\n-            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n-                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n-            DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doEnumSwitch\",\n-                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class,\n-                                                                 MethodHandles.Lookup.class, Class.class, ResolvedEnumLabels.class));\n+            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n+                                                                                 MethodType.methodType(boolean.class, Object.class)),\n+                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n+            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n+            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n+                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n+            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n+            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n+                                           MethodType.methodType(boolean.class, Object.class));\n+            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                           MethodType.methodType(boolean.class, int.class));\n+            CHECK_INDEX = LOOKUP.findStatic(Objects.class, \"checkIndex\",\n+                                           MethodType.methodType(int.class, int.class, int.class));\n+            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n+                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n+                                                                         Class.class, EnumDesc[].class, EnumMap.class));\n@@ -137,1 +158,2 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n+        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+\n@@ -154,23 +176,30 @@\n-    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n-        Objects.checkIndex(startIndex, labels.length + 1);\n-\n-        if (target == null)\n-            return -1;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label instanceof Integer constant) {\n-                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                    return i;\n-                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                    return i;\n-                }\n-            } else if (label instanceof EnumDesc<?> enumDesc) {\n-                if (target.getClass().isEnum() &&\n-                    ((Enum<?>) target).describeConstable().stream().anyMatch(d -> d.equals(enumDesc))) {\n-                    return i;\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n+     *     case 1 -> if (selector matches label[1]) return 1; else ...\n+     *     ...\n+     * }\n+     *\/\n+    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        MethodHandle[] testChains = new MethodHandle[labels.length];\n+        List<Object> labelsList = List.of(labels).reversed();\n+\n+        for (int i = 0; i < labels.length; i++) {\n+            MethodHandle test = def;\n+            int idx = labels.length - 1;\n+            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n+\n+            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n+                Object currentLabel = currentLabels.get(j);\n+                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n+                MethodHandle currentTest;\n+                if (currentLabel instanceof Class<?>) {\n+                    currentTest = INSTANCEOF_CHECK;\n+                } else if (currentLabel instanceof Integer) {\n+                    currentTest = INTEGER_EQ_CHECK;\n+                } else if (currentLabel instanceof EnumDesc) {\n+                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n+                } else {\n+                    currentTest = OBJECT_EQ_CHECK;\n@@ -178,2 +207,3 @@\n-            } else if (label.equals(target)) {\n-                return i;\n+                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n+                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n+                                                   test);\n@@ -181,0 +211,33 @@\n+            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n+        }\n+\n+        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n+    }\n+\n+    \/*\n+     * Construct code that maps the given selector and repeat index to a case label number:\n+     * if (selector == null) return -1;\n+     * else return \"createRepeatIndexSwitch(labels)\"\n+     *\/\n+    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n+        MethodHandle mainTest;\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        if (labels.length > 0) {\n+            mainTest = createRepeatIndexSwitch(lookup, labels);\n+        } else {\n+            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n+        }\n+        MethodHandle body =\n+                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                            mainTest);\n+        MethodHandle switchImpl =\n+                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+        return withIndexCheck(switchImpl, labels.length);\n+    }\n+\n+    private static boolean integerEqCheck(Object value, Integer constant) {\n+        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n+            return true;\n+        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n+            return true;\n@@ -183,1 +246,5 @@\n-        return labels.length;\n+        return false;\n+    }\n+\n+    private static boolean isZero(int value) {\n+        return value == 0;\n@@ -257,4 +324,1 @@\n-        Stream.of(labels).forEach(l -> validateEnumLabel(enumClass, l));\n-        MethodHandle temporary =\n-                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, labels, lookup, enumClass, new ResolvedEnumLabels());\n-        temporary = temporary.asType(invocationType);\n+        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n@@ -262,2 +326,2 @@\n-        return new ConstantCallSite(temporary);\n-    }\n+        MethodHandle target;\n+        boolean constantsOnly = Stream.of(labels).allMatch(l -> enumClass.isAssignableFrom(EnumDesc.class));\n@@ -265,13 +329,14 @@\n-    private static <E extends Enum<E>> void validateEnumLabel(Class<?> enumClassTemplate, Object label) {\n-        if (label == null) {\n-            throw new IllegalArgumentException(\"null label found\");\n-        }\n-        Class<?> labelClass = label.getClass();\n-        if (labelClass == Class.class) {\n-            if (label != enumClassTemplate) {\n-                throw new IllegalArgumentException(\"the Class label: \" + label +\n-                                                   \", expected the provided enum class: \" + enumClassTemplate);\n-            }\n-        } else if (labelClass != String.class) {\n-            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass +\n-                                               \", expected label of type either String or Class\");\n+        if (labels.length > 0 && constantsOnly) {\n+            \/\/If all labels are enum constants, construct an optimized handle for repeat index 0:\n+            \/\/if (selector == null) return -1\n+            \/\/else if (idx == 0) return mappingArray[selector.ordinal()]; \/\/mapping array created lazily\n+            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            MethodHandle body =\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                                MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n+            target = MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+        } else {\n+            target = createMethodHandleSwitch(lookup, labels);\n@@ -279,0 +344,5 @@\n+\n+        target = target.asType(invocationType);\n+        target = withIndexCheck(target, labels.length);\n+\n+        return new ConstantCallSite(target);\n@@ -293,7 +363,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            Class<E> enumClass = (Class<E>) enumClassTemplate;\n-            try {\n-                return ConstantBootstraps.enumConstant(lookup, (String) label, enumClass);\n-            } catch (IllegalArgumentException ex) {\n-                return null;\n-            }\n+            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n@@ -306,4 +370,5 @@\n-    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] unresolvedLabels,\n-                                    MethodHandles.Lookup lookup, Class<?> enumClass,\n-                                    ResolvedEnumLabels resolvedLabels) {\n-        Objects.checkIndex(startIndex, unresolvedLabels.length + 1);\n+    private static <T extends Enum<T>> int mappedEnumLookup(T value, MethodHandles.Lookup lookup, Class<T> enumClass, EnumDesc<?>[] labels, EnumMap enumMap) {\n+        if (enumMap.map == null) {\n+            T[] constants = SharedSecrets.getJavaLangAccess().getEnumConstantsShared(enumClass);\n+            int[] map = new int[constants.length];\n+            int ordinal = 0;\n@@ -311,2 +376,2 @@\n-        if (target == null)\n-            return -1;\n+            for (T constant : constants) {\n+                map[ordinal] = labels.length;\n@@ -314,4 +379,9 @@\n-        if (resolvedLabels.resolvedLabels == null) {\n-            resolvedLabels.resolvedLabels = Stream.of(unresolvedLabels)\n-                                                  .map(l -> convertEnumConstants(lookup, enumClass, l))\n-                                                  .toArray();\n+                for (int i = 0; i < labels.length; i++) {\n+                    if (Objects.equals(labels[i].constantName(), constant.name())) {\n+                        map[ordinal] = i;\n+                        break;\n+                    }\n+                }\n+\n+                ordinal++;\n+            }\n@@ -319,0 +389,9 @@\n+        return enumMap.map[value.ordinal()];\n+    }\n+\n+    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n+        if (resolvedEnum.resolvedEnum == null) {\n+            Object resolved;\n+\n+            try {\n+                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -320,11 +399,7 @@\n-        Object[] labels = resolvedLabels.resolvedLabels;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label == target) {\n-                return i;\n+                if (value.getClass() != clazz) {\n+                    return false;\n+                }\n+\n+                resolved = label.resolveConstantDesc(lookup);\n+            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                resolved = SENTINEL;\n@@ -332,0 +407,2 @@\n+\n+            resolvedEnum.resolvedEnum = resolved;\n@@ -334,1 +411,12 @@\n-        return labels.length;\n+        return value == resolvedEnum.resolvedEnum;\n+    }\n+\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n+\n+    private static final class ResolvedEnumLabel {\n+        @Stable\n+        public Object resolvedEnum;\n@@ -337,1 +425,1 @@\n-    private static final class ResolvedEnumLabels {\n+    private static final class EnumMap {\n@@ -339,1 +427,1 @@\n-        public Object[] resolvedLabels;\n+        public int[] map;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":175,"deletions":87,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -3279,0 +3279,1 @@\n+            boolean skipParseException;\n@@ -3294,0 +3295,4 @@\n+            \/\/ When parsing a URI, skip creating exception objects if the server-based\n+            \/\/ authority is not required and the registry parse is successful.\n+            \/\/\n+            skipParseException = (!requireServerAuthority && regChars);\n@@ -3299,4 +3304,13 @@\n-                    q = parseServer(p, n);\n-                    if (q < n)\n-                        failExpecting(\"end of authority\", q);\n-                    authority = input.substring(p, n);\n+                    q = parseServer(p, n, skipParseException);\n+                    if (q < n) {\n+                        if (skipParseException) {\n+                            userInfo = null;\n+                            host = null;\n+                            port = -1;\n+                            q = p;\n+                        } else {\n+                            failExpecting(\"end of authority\", q);\n+                        }\n+                    } else {\n+                        authority = input.substring(p, n);\n+                    }\n@@ -3340,1 +3354,1 @@\n-        private int parseServer(int start, int n)\n+        private int parseServer(int start, int n, boolean skipParseException)\n@@ -3380,1 +3394,1 @@\n-                    q = parseHostname(p, n);\n+                    q = parseHostname(p, n, skipParseException);\n@@ -3397,0 +3411,2 @@\n+            } else if (p < n && skipParseException) {\n+                return p;\n@@ -3398,0 +3414,1 @@\n+\n@@ -3500,1 +3517,1 @@\n-        private int parseHostname(int start, int n)\n+        private int parseHostname(int start, int n, boolean skipParseException)\n@@ -3526,1 +3543,4 @@\n-            if ((p < n) && !at(p, n, ':'))\n+            if ((p < n) && !at(p, n, ':')) {\n+                if (skipParseException) {\n+                    return p;\n+                }\n@@ -3528,1 +3548,1 @@\n-\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1602,0 +1602,1 @@\n+        addEngine(\"KEM\",                                true,  null);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-     * is the default setting and provides the fastest collation but\n+     * setting provides the fastest collation but\n@@ -247,1 +247,1 @@\n-     *     <td>TERTIARY<\/td><\/tr>\n+     *     <td>TERTIARY<sup>*<\/sup><\/td><\/tr>\n@@ -259,1 +259,1 @@\n-     *     <td>NO_DECOMPOSITION<\/td><\/tr>\n+     *     <td>NO_DECOMPOSITION<sup>*<\/sup><\/td><\/tr>\n@@ -262,0 +262,1 @@\n+     * Asterisk (<sup>*<\/sup>) denotes the default value.\n@@ -263,1 +264,1 @@\n-     * decomposition will not be overridden, as if there were no BCP 47 collation\n+     * decomposition is not overridden, as if there were no BCP 47 collation\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -896,0 +896,3 @@\n+     * <p>\n+     * The non-sequenced map view is obtained by calling the abstract view()\n+     * method for each operation.\n@@ -901,3 +904,1 @@\n-        final Collection<E> view;\n-\n-        ViewCollection(Collection<E> view) { this.view = view; }\n+        abstract Collection<E> view();\n@@ -907,19 +908,18 @@\n-        public void clear() { view.clear(); }\n-        public boolean contains(Object o) { return view.contains(o); }\n-        public boolean containsAll(Collection<?> c) { return view.containsAll(c); }\n-        public boolean equals(Object o) { return view.equals(o); }\n-        public void forEach(Consumer<? super E> c) { view.forEach(c); }\n-        public int hashCode() { return view.hashCode(); }\n-        public boolean isEmpty() { return view.isEmpty(); }\n-        public Iterator<E> iterator() { return view.iterator(); }\n-        public Stream<E> parallelStream() { return view.parallelStream(); }\n-        public boolean remove(Object o) { return view.remove(o); }\n-        public boolean removeAll(Collection<?> c) { return view.removeAll(c); }\n-        public boolean removeIf(Predicate<? super E> filter) { return view.removeIf(filter); }\n-        public boolean retainAll(Collection<?> c) { return view.retainAll(c); }\n-        public int size() { return view.size(); }\n-        public Spliterator<E> spliterator() { return view.spliterator(); }\n-        public Stream<E> stream() { return view.stream(); }\n-        public Object[] toArray() { return view.toArray(); }\n-        public <T> T[] toArray(IntFunction<T[]> generator) { return view.toArray(generator); }\n-        public <T> T[] toArray(T[] a) { return view.toArray(a); }\n+        public void clear() { view().clear(); }\n+        public boolean contains(Object o) { return view().contains(o); }\n+        public boolean containsAll(Collection<?> c) { return view().containsAll(c); }\n+        public void forEach(Consumer<? super E> c) { view().forEach(c); }\n+        public boolean isEmpty() { return view().isEmpty(); }\n+        public Iterator<E> iterator() { return view().iterator(); }\n+        public Stream<E> parallelStream() { return view().parallelStream(); }\n+        public boolean remove(Object o) { return view().remove(o); }\n+        public boolean removeAll(Collection<?> c) { return view().removeAll(c); }\n+        public boolean removeIf(Predicate<? super E> filter) { return view().removeIf(filter); }\n+        public boolean retainAll(Collection<?> c) { return view().retainAll(c); }\n+        public int size() { return view().size(); }\n+        public Spliterator<E> spliterator() { return view().spliterator(); }\n+        public Stream<E> stream() { return view().stream(); }\n+        public Object[] toArray() { return view().toArray(); }\n+        public <T> T[] toArray(IntFunction<T[]> generator) { return view().toArray(generator); }\n+        public <T> T[] toArray(T[] a) { return view().toArray(a); }\n+        public String toString() { return view().toString(); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n+\n@@ -151,1 +153,1 @@\n-        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+        return it.hasNext() ? new NullableKeyValueHolder<>(it.next()) : null;\n@@ -168,1 +170,1 @@\n-        return it.hasNext() ? Map.Entry.copyOf(it.next()) : null;\n+        return it.hasNext() ? new NullableKeyValueHolder<>(it.next()) : null;\n@@ -188,1 +190,1 @@\n-            var entry = Map.Entry.copyOf(it.next());\n+            var entry = new NullableKeyValueHolder<>(it.next());\n@@ -213,1 +215,1 @@\n-            var entry = Map.Entry.copyOf(it.next());\n+            var entry = new NullableKeyValueHolder<>(it.next());\n@@ -260,1 +262,1 @@\n-     * Returns a {@link SequencedSet} view of this map's keySet.\n+     * Returns a {@code SequencedSet} view of this map's {@link #keySet keySet}.\n@@ -263,5 +265,7 @@\n-     * The implementation in this interface returns a {@code SequencedSet}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #keySet}, except for its {@link SequencedSet#reversed reversed} method,\n-     * which instead returns the result of calling {@code sequencedKeySet} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedSet} instance\n+     * that behaves as follows. Its {@link SequencedSet#add add} and {@link\n+     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedSet#reversed reversed} method returns the {@link\n+     * #sequencedKeySet sequencedKeySet} view of the {@link #reversed reversed} view of\n+     * this map. Each of its other methods calls the corresponding method of the {@link\n+     * #keySet keySet} view of this map.\n@@ -269,1 +273,1 @@\n-     * @return a SequencedSet view of this map's keySet\n+     * @return a {@code SequencedSet} view of this map's {@code keySet}\n@@ -273,2 +277,2 @@\n-            SeqKeySet() {\n-                super(SequencedMap.this.keySet());\n+            Collection<K> view() {\n+                return SequencedMap.this.keySet();\n@@ -279,0 +283,6 @@\n+            public boolean equals(Object other) {\n+                return view().equals(other);\n+            }\n+            public int hashCode() {\n+                return view().hashCode();\n+            }\n@@ -284,1 +294,1 @@\n-     * Returns a {@link SequencedCollection} view of this map's values collection.\n+     * Returns a {@code SequencedCollection} view of this map's {@link #values values} collection.\n@@ -287,5 +297,8 @@\n-     * The implementation in this interface returns a {@code SequencedCollection}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #values} collection, except for its {@link SequencedCollection#reversed reversed}\n-     * method, which instead returns the result of calling {@code sequencedValues} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedCollection} instance\n+     * that behaves as follows. Its {@link SequencedCollection#add add} and {@link\n+     * SequencedCollection#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedCollection#reversed reversed} method returns the {@link\n+     * #sequencedValues sequencedValues} view of the {@link #reversed reversed} view of\n+     * this map. Its {@link Object#equals equals} and {@link Object#hashCode hashCode} methods\n+     * are inherited from {@link Object}. Each of its other methods calls the corresponding\n+     * method of the {@link #values values} view of this map.\n@@ -293,1 +306,1 @@\n-     * @return a SequencedCollection view of this map's values collection\n+     * @return a {@code SequencedCollection} view of this map's {@code values} collection\n@@ -297,2 +310,2 @@\n-            SeqValues() {\n-                super(SequencedMap.this.values());\n+            Collection<V> view() {\n+                return SequencedMap.this.values();\n@@ -308,1 +321,1 @@\n-     * Returns a {@link SequencedSet} view of this map's entrySet.\n+     * Returns a {@code SequencedSet} view of this map's {@link #entrySet entrySet}.\n@@ -311,5 +324,7 @@\n-     * The implementation in this interface returns a {@code SequencedSet}\n-     * implementation that delegates all operations either to this map or to this map's\n-     * {@link #entrySet}, except for its {@link SequencedSet#reversed reversed} method,\n-     * which instead returns the result of calling {@code sequencedEntrySet} on this map's\n-     * reverse-ordered view.\n+     * The implementation in this interface returns a {@code SequencedSet} instance\n+     * that behaves as follows. Its {@link SequencedSet#add add} and {@link\n+     * SequencedSet#addAll addAll} methods throw {@link UnsupportedOperationException}.\n+     * Its {@link SequencedSet#reversed reversed} method returns the {@link\n+     * #sequencedEntrySet sequencedEntrySet} view of the {@link #reversed reversed} view of\n+     * this map. Each of its other methods calls the corresponding method of the {@link\n+     * #entrySet entrySet} view of this map.\n@@ -317,1 +332,1 @@\n-     * @return a SequencedSet view of this map's entrySet\n+     * @return a {@code SequencedSet} view of this map's {@code entrySet}\n@@ -322,2 +337,2 @@\n-            SeqEntrySet() {\n-                super(SequencedMap.this.entrySet());\n+            Collection<Map.Entry<K, V>> view() {\n+                return SequencedMap.this.entrySet();\n@@ -328,0 +343,6 @@\n+            public boolean equals(Object other) {\n+                return view().equals(other);\n+            }\n+            public int hashCode() {\n+                return view().hashCode();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/SequencedMap.java","additions":52,"deletions":31,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Thrown when a structure violation is detected.\n+ *\n+ * @see StructuredTaskScope#close()\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+public final class StructureViolationException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = -7705327650798235468L;\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with no detail message.\n+     *\/\n+    public StructureViolationException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with the specified\n+     * detail message.\n+     *\n+     * @param  message the detail message, can be null\n+     *\/\n+    public StructureViolationException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructureViolationException.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,1273 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.ThreadFlock;\n+\n+\/**\n+ * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n+ * cases where a task splits into several concurrent subtasks, and where the subtasks must\n+ * complete before the main task continues. A {@code StructuredTaskScope} can be used to\n+ * ensure that the lifetime of a concurrent operation is confined by a <em>syntax block<\/em>,\n+ * just like that of a sequential operation in structured programming.\n+ *\n+ * <h2>Basic operation<\/h2>\n+ *\n+ * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n+ * the {@link #fork(Callable) fork} method to start a thread to execute a subtask, the {@link\n+ * #join() join} method to wait for all subtasks to finish, and the {@link #close() close}\n+ * method to close the task scope. The API is intended to be used with the {@code\n+ * try-with-resources} statement. The intention is that code in the try <em>block<\/em>\n+ * uses the {@code fork} method to fork threads to execute the subtasks, wait for the\n+ * subtasks to finish with the {@code join} method, and then <em>process the results<\/em>.\n+ * A call to the {@code fork} method returns a {@link Subtask Subtask} to representing\n+ * the <em>forked subtask<\/em>. Once {@code join} is called, the {@code Subtask} can be\n+ * used to get the result completed successfully, or the exception if the subtask failed.\n+ * {@snippet lang=java :\n+ *     Callable<String> task1 = ...\n+ *     Callable<Integer> task1 = ...\n+ *\n+ *     try (var scope = new StructuredTaskScope<Object>()) {\n+ *\n+ *         Subtask<String> subtask1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n+ *         Subtask<Integer> subtask2 = scope.fork(task2);  \/\/ @highlight substring=\"fork\"\n+ *\n+ *         scope.join();                                   \/\/ @highlight substring=\"join\"\n+ *\n+ *         ... process results\/exceptions ...\n+ *\n+ *     } \/\/ close                                          \/\/ @highlight substring=\"close\"\n+ * }\n+ * <p> The following example forks a collection of homogeneous subtasks, waits for all of\n+ * them to complete with the {@code join} method, and uses the {@link Subtask.State\n+ * Subtask.State} to partition the subtasks into a set of the subtasks that completed\n+ * successfully and another for the subtasks that failed.\n+ * {@snippet lang=java :\n+ *     List<Callable<String>> callables = ...\n+ *\n+ *     try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *         List<Subtask<String>> subtasks = callables.stream().map(scope::fork).toList();\n+ *\n+ *         scope.join();\n+ *\n+ *         Map<Boolean, Set<Subtask<String>>> map = subtasks.stream()\n+ *                 .collect(Collectors.partitioningBy(h -> h.state() == Subtask.State.SUCCESS,\n+ *                                                    Collectors.toSet()));\n+ *\n+ *     } \/\/ close\n+ * }\n+ *\n+ * <p> To ensure correct usage, the {@code join} and {@code close} methods may only be\n+ * invoked by the <em>owner<\/em> (the thread that opened\/created the task scope), and the\n+ * {@code close} method throws an exception after closing if the owner did not invoke the\n+ * {@code join} method after forking.\n+ *\n+ * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n+ * down a task scope without closing it. The {@code shutdown()} method <em>cancels<\/em> all\n+ * unfinished subtasks by {@linkplain Thread#interrupt() interrupting} the threads. It\n+ * prevents new threads from starting in the task scope. If the owner is waiting in the\n+ * {@code join} method then it will wakeup.\n+ *\n+ * <p> Shutdown is used for <em>short-circuiting<\/em> and allow subclasses to implement\n+ * <em>policy<\/em> that does not require all subtasks to finish.\n+ *\n+ * <h2>Subclasses with policies for common cases<\/h2>\n+ *\n+ * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n+ * common cases:\n+ * <ol>\n+ *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the result of the first\n+ *   subtask to complete successfully. Once captured, it shuts down the task scope to\n+ *   interrupt unfinished threads and wakeup the owner. This class is intended for cases\n+ *   where the result of any subtask will do (\"invoke any\") and where there is no need to\n+ *   wait for results of other unfinished subtasks. It defines methods to get the first\n+ *   result or throw an exception if all subtasks fail.\n+ *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the exception of the first\n+ *   subtask to fail. Once captured, it shuts down the task scope to interrupt unfinished\n+ *   threads and wakeup the owner. This class is intended for cases where the results of all\n+ *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n+ *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n+ *   any of the subtasks fail.\n+ * <\/ol>\n+ *\n+ * <p> The following are two examples that use the two classes. In both cases, a pair of\n+ * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n+ * first example creates a ShutdownOnSuccess object to capture the result of the first\n+ * subtask to complete successfully, cancelling the other by way of shutting down the task\n+ * scope. The main task waits in {@code join} until either subtask completes with a result\n+ * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n+ * result(Function)} method to get the captured result. If both subtasks fail then this\n+ * method throws a {@code WebApplicationException} with the exception from one of the\n+ * subtasks as the cause.\n+ * {@snippet lang=java :\n+ *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n+ *\n+ *         scope.fork(() -> fetch(left));\n+ *         scope.fork(() -> fetch(right));\n+ *\n+ *         scope.join();\n+ *\n+ *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n+ *         String result = scope.result(e -> new WebApplicationException(e));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ * The second example creates a ShutdownOnFailure object to capture the exception of the\n+ * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n+ * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n+ * result, either fails, or a deadline is reached. It invokes {@link\n+ * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n+ * if either subtask fails. This method is a no-op if both subtasks complete successfully.\n+ * The example uses {@link Supplier#get()} to get the result of each subtask. Using\n+ * {@code Supplier} instead of {@code Subtask} is preferred for common cases where the\n+ * object returned by fork is only used to get the result of a subtask that completed\n+ * successfully.\n+ * {@snippet lang=java :\n+ *    Instant deadline = ...\n+ *\n+ *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n+ *\n+ *         Supplier<String> supplier1 = scope.fork(() -> query(left));\n+ *         Supplier<String> supplier2 = scope.fork(() -> query(right));\n+ *\n+ *         scope.joinUntil(deadline);\n+ *\n+ *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n+ *         scope.throwIfFailed(e -> new WebApplicationException(e));\n+ *\n+ *         \/\/ both subtasks completed successfully\n+ *         String result = Stream.of(supplier1, supplier2)\n+ *                 .map(Supplier::get)\n+ *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <h2>Extending StructuredTaskScope<\/h2>\n+ *\n+ * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Subtask)\n+ * handleComplete} method overridden, to implement policies other than those implemented\n+ * by {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. A subclass may, for example,\n+ * collect the results of subtasks that complete successfully and ignore subtasks that\n+ * fail. It may collect exceptions when subtasks fail. It may invoke the {@link #shutdown()\n+ * shutdown} method to shut down and cause {@link #join() join} to wakeup when some\n+ * condition arises.\n+ *\n+ * <p> A subclass will typically define methods to make available results, state, or other\n+ * outcome to code that executes after the {@code join} method. A subclass that collects\n+ * results and ignores subtasks that fail may define a method that returns the results.\n+ * A subclass that implements a policy to shut down when a subtask fails may define a\n+ * method to get the exception of the first subtask to fail.\n+ *\n+ * <p> The following is an example of a simple {@code StructuredTaskScope} implementation\n+ * that collects homogenous subtasks that complete successfully. It defines the method\n+ * \"{@code completedSuccessfully()}\" that the main task can invoke after it joins.\n+ * {@snippet lang=java :\n+ *     class CollectingScope<T> extends StructuredTaskScope<T> {\n+ *         private final Queue<Subtask<? extends T>> subtasks = new LinkedTransferQueue<>();\n+ *\n+ *         @Override\n+ *         protected void handleComplete(Subtask<? extends T> subtask) {\n+ *             if (subtask.state() == Subtask.State.SUCCESS) {\n+ *                 subtasks.add(subtask);\n+ *             }\n+ *         }\n+ *\n+ *         @Override\n+ *         public CollectingScope<T> join() throws InterruptedException {\n+ *             super.join();\n+ *             return this;\n+ *         }\n+ *\n+ *         public Stream<Subtask<? extends T>> completedSuccessfully() {\n+ *             \/\/ @link substring=\"ensureOwnerAndJoined\" target=\"ensureOwnerAndJoined\" :\n+ *             super.ensureOwnerAndJoined();\n+ *             return subtasks.stream();\n+ *         }\n+ *     }\n+ * }\n+ * <p> The implementations of the {@code completedSuccessfully()} method in the example\n+ * invokes {@link #ensureOwnerAndJoined()} to ensure that the method can only be invoked\n+ * by the owner thread and only after it has joined.\n+ *\n+ * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n+ *\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n+ * <ul>\n+ *   <li> A parent-child relation is established when a thread started in a task scope\n+ *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n+ *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n+ *   scope \"B\".\n+ *   <li> A parent-child relation is established with nesting. If a thread opens task\n+ *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n+ *   scope \"B\" is the parent of the nested task scope \"C\".\n+ * <\/ul>\n+ *\n+ * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n+ * <p> The tree structure supports:\n+ * <ul>\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n+ *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n+ *   descriptions means threads started in the task scope or descendant scopes.\n+ * <\/ul>\n+ *\n+ * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"runWhere\" target=\"ScopedValue#runWhere(ScopedValue, Object, Runnable)\" :\n+ *     ScopedValue.runWhere(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n+ *             ...\n+ *          }\n+ *     });\n+ *\n+ *     ...\n+ *\n+ *     String childTask() {\n+ *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n+ *         String name = USERNAME.get();   \/\/ \"duke\"\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n+ * at this time.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2>Memory consistency effects<\/h2>\n+ *\n+ * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * {@linkplain #fork forking} of a subtask\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn <i>happen-before<\/i>\n+ * the subtask result is {@linkplain Subtask#get() retrieved} or <i>happen-before<\/i> any\n+ * actions taken in a thread after {@linkplain #join() joining} of the task scope.\n+ *\n+ * @jls 17.4.5 Happens-before Order\n+ *\n+ * @param <T> the result type of tasks executed in the task scope\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+public class StructuredTaskScope<T> implements AutoCloseable {\n+    private final ThreadFactory factory;\n+    private final ThreadFlock flock;\n+    private final ReentrantLock shutdownLock = new ReentrantLock();\n+\n+    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n+    private static final int OPEN     = 0;   \/\/ initial state\n+    private static final int SHUTDOWN = 1;\n+    private static final int CLOSED   = 2;\n+\n+    \/\/ state: set to SHUTDOWN by any thread, set to CLOSED by owner, read by any thread\n+    private volatile int state;\n+\n+    \/\/ Counters to support checking that the task scope owner joins before processing\n+    \/\/ results and attempts join before closing the task scope. These counters are\n+    \/\/ accessed only by the owner thread.\n+    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+\n+    \/**\n+     * Represents a subtask forked with {@link #fork(Callable)}.\n+     * @param <T> the result type\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+        \/**\n+         * {@return the value returning task provided to the {@code fork} method}\n+         *\n+         * @apiNote Task objects with unique identity may be used for correlation by\n+         * implementations of {@link #handleComplete(Subtask) handleComplete}.\n+         *\/\n+        Callable<? extends T> task();\n+\n+        \/**\n+         * Represents the state of a subtask.\n+         * @see Subtask#state()\n+         * @since 21\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+        enum State {\n+            \/**\n+             * The subtask result or exception is not available. This state indicates that\n+             * the subtask was forked but has not completed, it completed after the task\n+             * scope was {@linkplain #shutdown() shut down}, or it was forked after the\n+             * task scope was shut down.\n+             *\/\n+            UNAVAILABLE,\n+            \/**\n+             * The subtask completed successfully with a result. The {@link Subtask#get()\n+             * Subtask.get()} method can be used to obtain the result. This is a terminal\n+             * state.\n+             *\/\n+            SUCCESS,\n+            \/**\n+             * The subtask failed with an exception. The {@link Subtask#exception()\n+             * Subtask.exception()} method can be used to obtain the exception. This is a\n+             * terminal state.\n+             *\/\n+            FAILED,\n+        }\n+\n+        \/**\n+         * {@return the state of the subtask}\n+         *\/\n+        State state();\n+\n+        \/**\n+         * Returns the result of the subtask.\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the result of the subtask.\n+         *\n+         * @return the possibly-null result\n+         * @throws IllegalStateException if the subtask has not completed, did not complete\n+         * successfully, or the current thread is the task scope owner and did not join\n+         * after forking\n+         * @see State#SUCCESS\n+         *\/\n+        T get();\n+\n+        \/**\n+         * {@return the exception thrown by the subtask}\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the exception thrown by the subtask.\n+         *\n+         * @throws IllegalStateException if the subtask has not completed, completed with\n+         * a result, or the current thread is the task scope owner and did not join after\n+         * forking\n+         * @see State#FAILED\n+         *\/\n+        Throwable exception();\n+    }\n+\n+    \/**\n+     * Creates a structured task scope with the given name and thread factory. The task\n+     * scope is optionally named for the purposes of monitoring and management. The thread\n+     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n+     * subtasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n+     * current thread.\n+     *\n+     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped value}\n+     * bindings for inheritance by threads started in the task scope. The\n+     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description details\n+     * how parent-child relations are established implicitly for the purpose of inheritance\n+     * of scoped value bindings.\n+     *\n+     * @param name the name of the task scope, can be null\n+     * @param factory the thread factory\n+     *\/\n+    public StructuredTaskScope(String name, ThreadFactory factory) {\n+        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n+        if (name == null)\n+            name = Objects.toIdentityString(this);\n+        this.flock = ThreadFlock.open(name);\n+    }\n+\n+    \/**\n+     * Creates an unnamed structured task scope that creates virtual threads. The task\n+     * scope is owned by the current thread.\n+     *\n+     * @implSpec This constructor is equivalent to invoking the 2-arg constructor with a\n+     * name of {@code null} and a thread factory that creates virtual threads.\n+     *\/\n+    public StructuredTaskScope() {\n+        this(null, Thread.ofVirtual().factory());\n+    }\n+\n+    private IllegalStateException newIllegalStateExceptionScopeClosed() {\n+        return new IllegalStateException(\"Task scope is closed\");\n+    }\n+\n+    private IllegalStateException newIllegalStateExceptionNoJoin() {\n+        return new IllegalStateException(\"Owner did not join after forking subtasks\");\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if the scope is closed, returning the state if not\n+     * closed.\n+     *\/\n+    private int ensureOpen() {\n+        int s = state;\n+        if (s == CLOSED)\n+            throw newIllegalStateExceptionScopeClosed();\n+        return s;\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner.\n+     *\/\n+    private void ensureOwner() {\n+        if (Thread.currentThread() != flock.owner())\n+            throw new WrongThreadException(\"Current thread not owner\");\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner\n+     * or a thread contained in the tree.\n+     *\/\n+    private void ensureOwnerOrContainsThread() {\n+        Thread currentThread = Thread.currentThread();\n+        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n+            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if the current thread is the owner, and the owner did\n+     * not join after forking a subtask in the given fork round.\n+     *\/\n+    private void ensureJoinedIfOwner(int round) {\n+        if (Thread.currentThread() == flock.owner() && (round > lastJoinCompleted)) {\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    \/**\n+     * Ensures that the current thread is the owner of this task scope and that it joined\n+     * (with {@link #join()} or {@link #joinUntil(Instant)}) after {@linkplain #fork(Callable)\n+     * forking} subtasks.\n+     *\n+     * @apiNote This method can be used by subclasses that define methods to make available\n+     * results, state, or other outcome to code intended to execute after the join method.\n+     *\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws IllegalStateException if the task scope is open and task scope owner did\n+     * not join after forking\n+     *\/\n+    protected final void ensureOwnerAndJoined() {\n+        ensureOwner();\n+        if (forkRound > lastJoinCompleted) {\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by a subtask when it completes successfully or fails in this task scope.\n+     * This method is not invoked if a subtask completes after the task scope is\n+     * {@linkplain #shutdown() shut down}.\n+     *\n+     * @implSpec The default implementation throws {@code NullPointerException} if the\n+     * subtask is {@code null}. It throws {@link IllegalArgumentException} if the subtask\n+     * has not completed.\n+     *\n+     * @apiNote The {@code handleComplete} method should be thread safe. It may be\n+     * invoked by several threads concurrently.\n+     *\n+     * @param subtask the subtask\n+     *\n+     * @throws IllegalArgumentException if called with a subtask that has not completed\n+     *\/\n+    protected void handleComplete(Subtask<? extends T> subtask) {\n+        if (subtask.state() == Subtask.State.UNAVAILABLE)\n+            throw new IllegalArgumentException();\n+    }\n+\n+    \/**\n+     * Starts a new thread in this task scope to execute a value-returning task, thus\n+     * creating a <em>subtask<\/em> of this task scope.\n+     *\n+     * <p> The value-returning task is provided to this method as a {@link Callable}, the\n+     * thread executes the task's {@link Callable#call() call} method. The thread is\n+     * created with the task scope's {@link ThreadFactory}. It inherits the current thread's\n+     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n+     * captured when the task scope was created.\n+     *\n+     * <p> This method returns a {@link Subtask Subtask} to represent the <em>forked\n+     * subtask<\/em>. The {@code Subtask} object can be used to obtain the result when\n+     * the subtask completes successfully, or the exception when the subtask fails. To\n+     * ensure correct usage, the {@link Subtask#get() get()} and {@link Subtask#exception()\n+     * exception()} methods may only be called by the task scope owner after it has waited\n+     * for all threads to finish with the {@link #join() join} or {@link #joinUntil(Instant)}\n+     * methods. When the subtask completes, the thread invokes the {@link\n+     * #handleComplete(Subtask) handleComplete} method to consume the completed subtask.\n+     * If the task scope is {@linkplain #shutdown() shut down} before the subtask completes\n+     * then the {@code handleComplete} method will not be invoked.\n+     *\n+     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process of\n+     * shutting down) then the subtask will not run and the {@code handleComplete} method\n+     * will not be invoked.\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope.\n+     *\n+     * @implSpec This method may be overridden for customization purposes, wrapping tasks\n+     * for example. If overridden, the subclass must invoke {@code super.fork} to start a\n+     * new thread in this task scope.\n+     *\n+     * @param task the value-returning task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner or a\n+     * thread contained in the task scope\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the task scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     *\/\n+    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+        Objects.requireNonNull(task, \"'task' is null\");\n+        int s = ensureOpen();   \/\/ throws ISE if closed\n+\n+        \/\/ when forked by the owner, the subtask is forked in the current or next round\n+        int round = -1;\n+        if (Thread.currentThread() == flock.owner()) {\n+            round = forkRound;\n+            if (forkRound == lastJoinCompleted) {\n+                \/\/ new round if first fork after join\n+                round++;\n+            }\n+        }\n+\n+        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, round);\n+        boolean started = false;\n+\n+        if (s < SHUTDOWN) {\n+            \/\/ create thread to run task\n+            Thread thread = factory.newThread(subtask);\n+            if (thread == null) {\n+                throw new RejectedExecutionException(\"Rejected by thread factory\");\n+            }\n+\n+            \/\/ attempt to start the thread\n+            try {\n+                flock.start(thread);\n+                started = true;\n+            } catch (IllegalStateException e) {\n+                \/\/ shutdown by another thread, or underlying flock is shutdown due\n+                \/\/ to unstructured use\n+            }\n+        }\n+\n+        \/\/ force owner to join if thread started\n+        if (started && Thread.currentThread() == flock.owner() && round > forkRound) {\n+            forkRound = round;\n+        }\n+\n+        \/\/ return forked subtask or a subtask that did not run\n+        return subtask;\n+    }\n+\n+    \/**\n+     * Wait for all threads to finish or the task scope to shut down.\n+     *\/\n+    private void implJoin(Duration timeout)\n+        throws InterruptedException, TimeoutException\n+    {\n+        ensureOwner();\n+        lastJoinAttempted = forkRound;\n+        int s = ensureOpen();  \/\/ throws ISE if closed\n+        if (s == OPEN) {\n+            \/\/ wait for all threads, wakeup, interrupt, or timeout\n+            if (timeout != null) {\n+                flock.awaitAll(timeout);\n+            } else {\n+                flock.awaitAll();\n+            }\n+        }\n+        lastJoinCompleted = forkRound;\n+    }\n+\n+    \/**\n+     * Wait for all threads in this task scope to finish or the task scope to shut down.\n+     * This method waits until all threads started in this task scope finish execution,\n+     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n+     * or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @implSpec This method may be overridden for customization purposes or to return a\n+     * more specific return type. If overridden, the subclass must invoke {@code\n+     * super.join} to ensure that the method waits for threads in this task scope to\n+     * finish.\n+     *\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws InterruptedException if interrupted while waiting\n+     *\/\n+    public StructuredTaskScope<T> join() throws InterruptedException {\n+        try {\n+            implJoin(null);\n+        } catch (TimeoutException e) {\n+            throw new InternalError();\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Wait for all threads in this task scope to finish or the task scope to shut down,\n+     * up to the given deadline. This method waits until all threads started in the task\n+     * scope finish execution, the {@link #shutdown() shutdown} method is invoked to\n+     * shut down the task scope, the current thread is {@linkplain Thread#interrupt()\n+     * interrupted}, or the deadline is reached.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @implSpec This method may be overridden for customization purposes or to return a\n+     * more specific return type. If overridden, the subclass must invoke {@code\n+     * super.joinUntil} to ensure that the method waits for threads in this task scope to\n+     * finish.\n+     *\n+     * @param deadline the deadline\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if the deadline is reached while waiting\n+     *\/\n+    public StructuredTaskScope<T> joinUntil(Instant deadline)\n+        throws InterruptedException, TimeoutException\n+    {\n+        Duration timeout = Duration.between(Instant.now(), deadline);\n+        implJoin(timeout);\n+        return this;\n+    }\n+\n+    \/**\n+     * Interrupt all unfinished threads.\n+     *\/\n+    private void implInterruptAll() {\n+        flock.threads()\n+            .filter(t -> t != Thread.currentThread())\n+            .forEach(t -> {\n+                try {\n+                    t.interrupt();\n+                } catch (Throwable ignore) { }\n+            });\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void interruptAll() {\n+        if (System.getSecurityManager() == null) {\n+            implInterruptAll();\n+        } else {\n+            PrivilegedAction<Void> pa = () -> {\n+                implInterruptAll();\n+                return null;\n+            };\n+            AccessController.doPrivileged(pa);\n+        }\n+    }\n+\n+    \/**\n+     * Shutdown the task scope if not already shutdown. Return true if this method\n+     * shutdowns the task scope, false if already shutdown.\n+     *\/\n+    private boolean implShutdown() {\n+        shutdownLock.lock();\n+        try {\n+            if (state < SHUTDOWN) {\n+                \/\/ prevent new threads from starting\n+                flock.shutdown();\n+\n+                \/\/ set status before interrupting tasks\n+                state = SHUTDOWN;\n+\n+                \/\/ interrupt all unfinished threads\n+                interruptAll();\n+\n+                return true;\n+            } else {\n+                \/\/ already shutdown\n+                return false;\n+            }\n+        } finally {\n+            shutdownLock.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Shut down this task scope without closing it. Shutting down a task scope prevents\n+     * new threads from starting, interrupts all unfinished threads, and causes the\n+     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n+     * results of unfinished subtasks are no longer needed. It will typically be called\n+     * by the {@link #handleComplete(Subtask)} implementation of a subclass that\n+     * implements a policy to discard unfinished tasks once some outcome is reached.\n+     *\n+     * <p> More specifically, this method:\n+     * <ul>\n+     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n+     * task scope (except the current thread).\n+     * <li> Wakes up the task scope owner if it is waiting in {@link #join()} or {@link\n+     * #joinUntil(Instant)}. If the task scope owner is not waiting then its next call to\n+     * {@code join} or {@code joinUntil} will return immediately.\n+     * <\/ul>\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope.\n+     *\n+     * @implSpec This method may be overridden for customization purposes. If overridden,\n+     * the subclass must invoke {@code super.shutdown} to ensure that the method shuts\n+     * down the task scope.\n+     *\n+     * @apiNote\n+     * There may be threads that have not finished because they are executing code that\n+     * did not respond (or respond promptly) to thread interrupt. This method does not wait\n+     * for these threads. When the owner invokes the {@link #close() close} method\n+     * to close the task scope then it will wait for the remaining threads to finish.\n+     *\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner or\n+     * a thread contained in the task scope\n+     * @see #isShutdown()\n+     *\/\n+    public void shutdown() {\n+        ensureOwnerOrContainsThread();\n+        int s = ensureOpen();  \/\/ throws ISE if closed\n+        if (s < SHUTDOWN && implShutdown())\n+            flock.wakeup();\n+    }\n+\n+    \/**\n+     * {@return true if this task scope is shutdown, otherwise false}\n+     * @see #shutdown()\n+     *\/\n+    public final boolean isShutdown() {\n+        return state >= SHUTDOWN;\n+    }\n+\n+    \/**\n+     * Closes this task scope.\n+     *\n+     * <p> This method first shuts down the task scope (as if by invoking the {@link\n+     * #shutdown() shutdown} method). It then waits for the threads executing any\n+     * unfinished tasks to finish. If interrupted, this method will continue to wait for\n+     * the threads to finish before completing with the interrupt status set.\n+     *\n+     * <p> This method may only be invoked by the task scope owner. If the task scope\n+     * is already closed then the task scope owner invoking this method has no effect.\n+     *\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a task scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested task scope\n+     * (in the reverse order that they were created in), closes this task scope, and then\n+     * throws {@link StructureViolationException}.\n+     * Similarly, if this method is called to close a task scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the task scope.\n+     * If a thread terminates without first closing task scopes that it owns then\n+     * termination will cause the underlying construct of each of its open tasks scopes to\n+     * be closed. Closing is performed in the reverse order that the task scopes were\n+     * created in. Thread termination may therefore be delayed when the task scope owner\n+     * has to wait for threads forked in these task scopes to finish.\n+     *\n+     * @implSpec This method may be overridden for customization purposes. If overridden,\n+     * the subclass must invoke {@code super.close} to close the task scope.\n+     *\n+     * @throws IllegalStateException thrown after closing the task scope if the task scope\n+     * owner did not attempt to join after forking\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws StructureViolationException if a structure violation was detected\n+     *\/\n+    @Override\n+    public void close() {\n+        ensureOwner();\n+        int s = state;\n+        if (s == CLOSED)\n+            return;\n+\n+        try {\n+            if (s < SHUTDOWN)\n+                implShutdown();\n+            flock.close();\n+        } finally {\n+            state = CLOSED;\n+        }\n+\n+        \/\/ throw ISE if the owner didn't attempt to join after forking\n+        if (forkRound > lastJoinAttempted) {\n+            lastJoinCompleted = forkRound;\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String name = flock.name();\n+        return switch (state) {\n+            case OPEN     -> name;\n+            case SHUTDOWN -> name + \"\/shutdown\";\n+            case CLOSED   -> name + \"\/closed\";\n+            default -> throw new InternalError();\n+        };\n+    }\n+\n+    \/**\n+     * Subtask implementation, runs the task specified to the fork method.\n+     *\/\n+    private static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n+        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n+\n+        private record AltResult(Subtask.State state, Throwable exception) {\n+            AltResult(Subtask.State state) {\n+                this(state, null);\n+            }\n+        }\n+\n+        private final StructuredTaskScope<? super T> scope;\n+        private final Callable<? extends T> task;\n+        private final int round;\n+        private volatile Object result;\n+\n+        SubtaskImpl(StructuredTaskScope<? super T> scope,\n+                    Callable<? extends T> task,\n+                    int round) {\n+            this.scope = scope;\n+            this.task = task;\n+            this.round = round;\n+        }\n+\n+        @Override\n+        public void run() {\n+            T result = null;\n+            Throwable ex = null;\n+            try {\n+                result = task.call();\n+            } catch (Throwable e) {\n+                ex = e;\n+            }\n+\n+            \/\/ nothing to do if task scope is shutdown\n+            if (scope.isShutdown())\n+                return;\n+\n+            \/\/ capture result or exception, invoke handleComplete\n+            if (ex == null) {\n+                this.result = (result != null) ? result : RESULT_NULL;\n+            } else {\n+                this.result = new AltResult(State.FAILED, ex);\n+            }\n+            scope.handleComplete(this);\n+        }\n+\n+        @Override\n+        public Callable<? extends T> task() {\n+            return task;\n+        }\n+\n+        @Override\n+        public Subtask.State state() {\n+            Object result = this.result;\n+            if (result == null) {\n+                return State.UNAVAILABLE;\n+            } else if (result instanceof AltResult alt) {\n+                \/\/ null or failed\n+                return alt.state();\n+            } else {\n+                return State.SUCCESS;\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            scope.ensureJoinedIfOwner(round);\n+            Object result = this.result;\n+            if (result instanceof AltResult) {\n+                if (result == RESULT_NULL) return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+            throw new IllegalStateException(\"Subtask not completed or did not complete successfully\");\n+        }\n+\n+        @Override\n+        public Throwable exception() {\n+            scope.ensureJoinedIfOwner(round);\n+            Object result = this.result;\n+            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n+                return alt.exception();\n+            }\n+            throw new IllegalStateException(\"Subtask not completed or did not complete with exception\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String stateAsString = switch (state()) {\n+                case UNAVAILABLE -> \"[Unavailable]\";\n+                case SUCCESS     -> \"[Completed successfully]\";\n+                case FAILED      -> {\n+                    Throwable ex = ((AltResult) result).exception();\n+                    yield \"[Failed: \" + ex + \"]\";\n+                }\n+            };\n+            return Objects.toIdentityString(this ) + stateAsString;\n+        }\n+    }\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * invokes the {@linkplain #shutdown() shutdown} method to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @param <T> the result type\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n+        private static final Object RESULT_NULL = new Object();\n+        private static final VarHandle FIRST_RESULT;\n+        private static final VarHandle FIRST_EXCEPTION;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FIRST_RESULT = l.findVarHandle(ShutdownOnSuccess.class, \"firstResult\", Object.class);\n+                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnSuccess.class, \"firstException\", Throwable.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private volatile Object firstResult;\n+        private volatile Throwable firstException;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnSuccess() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            super.handleComplete(subtask);\n+\n+            if (firstResult != null) {\n+                \/\/ already captured a result\n+                return;\n+            }\n+\n+            if (subtask.state() == Subtask.State.SUCCESS) {\n+                \/\/ task succeeded\n+                T result = subtask.get();\n+                Object r = (result != null) ? result : RESULT_NULL;\n+                if (FIRST_RESULT.compareAndSet(this, null, r)) {\n+                    super.shutdown();\n+                }\n+            } else if (firstException == null) {\n+                \/\/ capture the exception thrown by the first subtask that failed\n+                FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return the result of the first subtask that completed {@linkplain\n+         * Subtask.State#SUCCESS successfully}}\n+         *\n+         * <p> When no subtask completed successfully, but a subtask {@linkplain\n+         * Subtask.State#FAILED failed} then {@code ExecutionException} is thrown with\n+         * the subtask's exception as the {@linkplain Throwable#getCause() cause}.\n+         *\n+         * @throws ExecutionException if no subtasks completed successfully but at least\n+         * one subtask failed\n+         * @throws IllegalStateException if the handleComplete method was not invoked with\n+         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         *\/\n+        public T result() throws ExecutionException {\n+            return result(ExecutionException::new);\n+        }\n+\n+        \/**\n+         * Returns the result of the first subtask that completed {@linkplain\n+         * Subtask.State#SUCCESS successfully}, otherwise throws an exception produced\n+         * by the given exception supplying function.\n+         *\n+         * <p> When no subtask completed successfully, but a subtask {@linkplain\n+         * Subtask.State#FAILED failed}, then the exception supplying function is invoked\n+         * with subtask's exception.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         * @return the result of the first subtask that completed with a result\n+         *\n+         * @throws X if no subtasks completed successfully but at least one subtask failed\n+         * @throws IllegalStateException if the handleComplete method was not invoked with\n+         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         *\/\n+        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n+            Objects.requireNonNull(esf);\n+            ensureOwnerAndJoined();\n+\n+            Object result = firstResult;\n+            if (result == RESULT_NULL) {\n+                return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+\n+            Throwable exception = firstException;\n+            if (exception != null) {\n+                X ex = esf.apply(exception);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+\n+            throw new IllegalStateException(\"No completed subtasks\");\n+        }\n+    }\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n+     * {@linkplain Subtask.State#FAILED fail}. Once captured, it invokes the {@linkplain\n+     * #shutdown() shutdown} method to interrupt unfinished threads and wakeup the task\n+     * scope owner. The policy implemented by this class is intended for cases where the\n+     * results for all subtasks are required (\"invoke all\"); if any subtask fails then the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n+        private static final VarHandle FIRST_EXCEPTION;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnFailure.class, \"firstException\", Throwable.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private volatile Throwable firstException;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnFailure(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnFailure() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<?> subtask) {\n+            super.handleComplete(subtask);\n+            if (subtask.state() == Subtask.State.FAILED\n+                    && firstException == null\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception())) {\n+                super.shutdown();\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns the exception of the first subtask that {@linkplain Subtask.State#FAILED\n+         * failed}. If no subtasks failed then an empty {@code Optional} is returned.\n+         *\n+         * @return the exception for the first subtask to fail or an empty optional if no\n+         * subtasks failed\n+         *\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public Optional<Throwable> exception() {\n+            ensureOwnerAndJoined();\n+            return Optional.ofNullable(firstException);\n+        }\n+\n+        \/**\n+         * Throws if a subtask {@linkplain Subtask.State#FAILED failed}.\n+         * If any subtask failed with an exception then {@code ExecutionException} is\n+         * thrown with the exception of the first subtask to fail as the {@linkplain\n+         * Throwable#getCause() cause}. This method does nothing if no subtasks failed.\n+         *\n+         * @throws ExecutionException if a subtask failed\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public void throwIfFailed() throws ExecutionException {\n+            throwIfFailed(ExecutionException::new);\n+        }\n+\n+        \/**\n+         * Throws the exception produced by the given exception supplying function if a\n+         * subtask {@linkplain Subtask.State#FAILED failed}. If any subtask failed with\n+         * an exception then the function is invoked with the exception of the first\n+         * subtask to fail. The exception returned by the function is thrown. This method\n+         * does nothing if no subtasks failed.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         *\n+         * @throws X produced by the exception supplying function\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public <X extends Throwable>\n+        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n+            ensureOwnerAndJoined();\n+            Objects.requireNonNull(esf);\n+            Throwable exception = firstException;\n+            if (exception != null) {\n+                X ex = esf.apply(exception);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":1273,"deletions":0,"binary":false,"changes":1273,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-            throw new InternalError(e);\n+            throw new ExceptionInInitializerError(e);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+\/**\n+ * An exception that is thrown by the\n+ * {@link javax.crypto.KEM.Decapsulator#decapsulate} method to denote an\n+ * error during decapsulation.\n+ *\n+ * @since 21\n+ *\/\n+public class DecapsulateException extends GeneralSecurityException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 21L;\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     *\/\n+    public DecapsulateException(String message) {\n+        super(message);\n+    }\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is permitted,\n+     *        and indicates that the cause is nonexistent or unknown.)\n+     *\/\n+    public DecapsulateException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/DecapsulateException.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,737 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import sun.security.jca.GetInstance;\n+\n+import java.security.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Encapsulation Mechanism (KEM).\n+ * A KEM can be used to secure symmetric keys using asymmetric or public key\n+ * cryptography between two parties. The sender calls the encapsulate method\n+ * to generate a secret key and a key encapsulation message, and the receiver\n+ * calls the decapsulate method to recover the same secret key from\n+ * the key encapsulation message.\n+ * <p>\n+ * The {@code getInstance} method creates a new {@code KEM} object that\n+ * implements the specified algorithm.\n+ * <p>\n+ * A {@code KEM} object is immutable. It is safe to call multiple\n+ * {@code newEncapsulator} and {@code newDecapsulator} methods on the\n+ * same {@code KEM} object at the same time.\n+ * <p>\n+ * If a provider is not specified in the {@code getInstance} method when\n+ * instantiating a {@code KEM} object, the {@code newEncapsulator} and\n+ * {@code newDecapsulator} methods may return encapsulators or decapsulators\n+ * from different providers. The provider selected is based on the parameters\n+ * passed to the {@code newEncapsulator} or {@code newDecapsulator} methods:\n+ * the private or public key and the optional {@code AlgorithmParameterSpec}.\n+ * The {@link Encapsulator#providerName} and {@link Decapsulator#providerName}\n+ * methods return the name of the selected provider.\n+ * <p>\n+ * {@code Encapsulator} and {@code Decapsulator} objects are also immutable.\n+ * It is safe to invoke multiple {@code encapsulate} and {@code decapsulate}\n+ * methods on the same {@code Encapsulator} or {@code Decapsulator} object\n+ * at the same time. Each invocation of {@code encapsulate} will generate a\n+ * new shared secret and key encapsulation message.\n+ * <p>\n+ *\n+ * Example:\n+ * {@snippet lang = java:\n+ *    \/\/ Receiver side\n+ *    var kpg = KeyPairGenerator.getInstance(\"X25519\");\n+ *    var kp = kpg.generateKeyPair();\n+ *\n+ *    \/\/ Sender side\n+ *    var kem1 = KEM.getInstance(\"DHKEM\");\n+ *    var sender = kem1.newEncapsulator(kp.getPublic());\n+ *    var encapsulated = sender.encapsulate();\n+ *    var k1 = encapsulated.key();\n+ *\n+ *    \/\/ Receiver side\n+ *    var kem2 = KEM.getInstance(\"DHKEM\");\n+ *    var receiver = kem2.newDecapsulator(kp.getPrivate());\n+ *    var k2 = receiver.decapsulate(encapsulated.encapsulation());\n+ *\n+ *    assert Arrays.equals(k1.getEncoded(), k2.getEncoded());\n+ * }\n+ *\n+ * @since 21\n+ *\/\n+public final class KEM {\n+\n+    \/**\n+     * This class specifies the return value of the encapsulate method of\n+     * a Key Encapsulation Mechanism (KEM), which includes the shared secret\n+     * (as a {@code SecretKey}), the key encapsulation message,\n+     * and optional parameters.\n+     * <p>\n+     * Note: the key encapsulation message can be also referred to as ciphertext.\n+     *\n+     * @see #newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     * @see Encapsulator#encapsulate(int, int, String)\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulated {\n+        private final SecretKey key;\n+        private final byte[] encapsulation;\n+        private final byte[] params;\n+\n+        \/**\n+         * Constructs an {@code Encapsulated} object.\n+         *\n+         * @param key the shared secret as a key, must not be {@code null}.\n+         * @param encapsulation the key encapsulation message, must not\n+         *          be {@code null}. The contents of the array are copied\n+         *          to protect against subsequent modification.\n+         * @param params optional parameters, can be {@code null}.\n+         *          The contents of the array are copied to protect\n+         *          against subsequent modification.\n+         * @throws NullPointerException if {@code key} or {@code encapsulation}\n+         *          is {@code null}\n+         *\/\n+        public Encapsulated(SecretKey key, byte[] encapsulation, byte[] params) {\n+            Objects.requireNonNull(key);\n+            Objects.requireNonNull(encapsulation);\n+            this.key = key;\n+            this.encapsulation = encapsulation.clone();\n+            this.params = params == null ? null : params.clone();\n+        }\n+\n+        \/**\n+         * Returns the {@code SecretKey}.\n+         *\n+         * @return the secret key\n+         *\/\n+        public SecretKey key() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the key encapsulation message.\n+         *\n+         * @return the key encapsulation message. A new copy of the byte array\n+         *      is returned.\n+         *\/\n+        public byte[] encapsulation() {\n+            return encapsulation.clone();\n+        }\n+\n+        \/**\n+         * Returns the optional parameters in a byte array.\n+         *\n+         * @return the optional parameters in a byte array or {@code null}\n+         *      if not specified. A new copy of the byte array is returned.\n+         *\/\n+        public byte[] params() {\n+            return params == null ? null : params.clone();\n+        }\n+    }\n+\n+    \/**\n+     * An encapsulator, generated by {@link #newEncapsulator} on the KEM\n+     * sender side.\n+     * <p>\n+     * This class represents the key encapsulation function of a KEM.\n+     * Each invocation of the {@code encapsulate} method generates a\n+     * new secret key and key encapsulation message that is returned\n+     * in an {@link Encapsulated} object.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulator {\n+\n+        private final KEMSpi.EncapsulatorSpi e;\n+        private final Provider p;\n+\n+        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {\n+            assert e != null;\n+            assert p != null;\n+            this.e = e;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code encapsulate(0, secretSize(), \"Generic\")}. This combination\n+         * of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @return a {@link Encapsulated} object containing the shared\n+         *          secret, key encapsulation message, and optional parameters.\n+         *          The shared secret is a {@code SecretKey} containing all of\n+         *          the bytes of the secret, and an algorithm name of \"Generic\".\n+         *\/\n+        public Encapsulated encapsulate() {\n+            return encapsulate(0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method generates a new secret key and key\n+         * encapsulation message that is returned in an {@link Encapsulated} object.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a {@link Encapsulated} object containing a portion of\n+         *          the shared secret, key encapsulation message, and optional\n+         *          parameters. The portion of the shared secret is a\n+         *          {@code SecretKey} containing the bytes of the secret\n+         *          ranging from {@code from} to {@code to}, exclusive,\n+         *          and an algorithm name as specified. For example,\n+         *          {@code encapsulate(0, 16, \"AES\")} uses the first 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         *\/\n+        public Encapsulated encapsulate(int from, int to, String algorithm) {\n+            return e.engineEncapsulate(from, to, algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code encapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = e.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be called to find out the length of the encapsulation\n+         * message before {@code encapsulate} is called.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = e.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    \/**\n+     * A decapsulator, generated by {@link #newDecapsulator} on the KEM\n+     * receiver side.\n+     * <p>\n+     * This class represents the key decapsulation function of a KEM.\n+     * An invocation of the {@code decapsulate} method recovers the\n+     * secret key from the key encapsulation message.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Decapsulator {\n+        private final KEMSpi.DecapsulatorSpi d;\n+        private final Provider p;\n+\n+        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {\n+            assert d != null;\n+            assert p != null;\n+            this.d = d;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code decapsulate(encapsulation, 0, secretSize(), \"Generic\")}. This\n+         * combination of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @return the shared secret as a {@code SecretKey} with\n+         *          an algorithm name of \"Generic\"\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws NullPointerException if {@code encapsulation} is {@code null}\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {\n+            return decapsulate(encapsulation, 0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey}\n+         *          containing the bytes of the secret ranging from {@code from}\n+         *          to {@code to}, exclusive, and an algorithm name as specified.\n+         *          For example, {@code decapsulate(encapsulation, secretSize()\n+         *          - 16, secretSize(), \"AES\")} uses the last 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm)\n+                throws DecapsulateException {\n+            return d.engineDecapsulate(\n+                    encapsulation,\n+                    from, to,\n+                    algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code decapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = d.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be used to extract the encapsulation message\n+         * from a longer byte array if no length information is provided\n+         * by a higher level protocol.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = d.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    private static final class DelayedKEM {\n+\n+        private final Provider.Service[] list; \/\/ non empty array\n+\n+        private DelayedKEM(Provider.Service[] list) {\n+            this.list = list;\n+        }\n+\n+        private Encapsulator newEncapsulator(PublicKey publicKey,\n+                AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (publicKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(publicKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Encapsulator(\n+                            spi.engineNewEncapsulator(publicKey, spec, secureRandom),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                            + publicKey.getClass().getName(), re);\n+        }\n+\n+        private static <T extends Exception> T merge(T e1, T e2) {\n+            if (e1 == null) {\n+                return e2;\n+            } else {\n+                e1.addSuppressed(e2);\n+                return e1;\n+            }\n+        }\n+\n+        private Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (privateKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(privateKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Decapsulator(\n+                            spi.engineNewDecapsulator(privateKey, spec),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                    + privateKey.getClass().getName(), re);\n+        }\n+    }\n+\n+    \/\/ If delayed provider selection is needed\n+    private final DelayedKEM delayed;\n+\n+    \/\/ otherwise\n+    private final KEMSpi spi;\n+    private final Provider provider;\n+\n+    private final String algorithm;\n+\n+    private KEM(String algorithm, KEMSpi spi, Provider provider) {\n+        assert spi != null;\n+        assert provider != null;\n+        this.delayed = null;\n+        this.spi = spi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+    }\n+\n+    private KEM(String algorithm, DelayedKEM delayed) {\n+        assert delayed != null;\n+        this.delayed = delayed;\n+        this.spi = null;\n+        this.provider = null;\n+        this.algorithm = algorithm;\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n+     *         {@code KEM} implementation for the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm)\n+            throws NoSuchAlgorithmException {\n+        List<Provider.Service> list = GetInstance.getServices(\n+                \"KEM\",\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"));\n+        if (list.isEmpty()) {\n+            throw new NoSuchAlgorithmException(algorithm + \" KEM not available\");\n+        }\n+        return new KEM(algorithm, new DelayedKEM(list.toArray(new Provider.Service[0])));\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, Provider provider)\n+            throws NoSuchAlgorithmException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = GetInstance.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NoSuchProviderException if the specified provider is not\n+     *         registered in the security provider list\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = GetInstance.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, null)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, secureRandom)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey, SecureRandom secureRandom)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, secureRandom);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * An algorithm can define an {@code AlgorithmParameterSpec} child class to\n+     * provide extra information in this method. This is especially useful if\n+     * the same key can be used to derive shared secrets in different ways.\n+     * If any extra information inside this object needs to be transmitted along\n+     * with the key encapsulation message so that the receiver is able to create\n+     * a matching decapsulator, it will be included as a byte array in the\n+     * {@link Encapsulated#params} field inside the encapsulation output.\n+     * In this case, the security provider should provide an\n+     * {@code AlgorithmParameters} implementation using the same algorithm name\n+     * as the KEM. The receiver can initiate such an {@code AlgorithmParameters}\n+     * instance with the {@code params} byte array received and recover\n+     * an {@code AlgorithmParameterSpec} object to be used in its\n+     * {@link #newDecapsulator(PrivateKey, AlgorithmParameterSpec)} call.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newEncapsulator(publicKey, spec, secureRandom)\n+                : new Encapsulator(spi.engineNewEncapsulator(publicKey, spec, secureRandom), provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     * <p>\n+     * This method is equivalent to {@code newDecapsulator(privateKey, null)}.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newDecapsulator(privateKey, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newDecapsulator(privateKey, spec)\n+                : new Decapsulator(spi.engineNewDecapsulator(privateKey, spec), provider);\n+    }\n+\n+    \/**\n+     * Returns the name of the algorithm for this {@code KEM} object.\n+     *\n+     * @return the name of the algorithm for this {@code KEM} object.\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":737,"deletions":0,"binary":false,"changes":737,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ * This class defines the Service Provider Interface (SPI) for the {@link KEM}\n+ * class. A security provider implements this interface to provide an\n+ * implementation of a Key Encapsulation Mechanism (KEM) algorithm.\n+ * <p>\n+ * A KEM algorithm may support a family of configurations. Each configuration\n+ * may accept different types of keys, cryptographic primitives, and sizes of\n+ * shared secrets and key encapsulation messages. A configuration is defined\n+ * by the KEM algorithm name, the key it uses, and an optional\n+ * {@code AlgorithmParameterSpec} argument that is specified when creating\n+ * an encapsulator or decapsulator. The result of calling\n+ * {@link #engineNewEncapsulator} or {@link #engineNewDecapsulator} must return\n+ * an encapsulator or decapsulator that maps to a single configuration,\n+ * where its {@code engineSecretSize()} and {@code engineEncapsulationSize()}\n+ * methods return constant values.\n+ * <p>\n+ * A {@code KEMSpi} implementation must be immutable. It must be safe to\n+ * call multiple {@code engineNewEncapsulator} and {@code engineNewDecapsulator}\n+ * methods at the same time.\n+ * <p>\n+ * {@code EncapsulatorSpi} and {@code DecapsulatorSpi} implementations must also\n+ * be immutable. It must be safe to invoke multiple {@code encapsulate} and\n+ * {@code decapsulate} methods at the same time. Each invocation of\n+ * {@code encapsulate} should generate a new shared secret and key\n+ * encapsulation message.\n+ * <p>\n+ * For example,\n+ * {@snippet lang = java:\n+ * public static class MyKEMImpl implements KEMSpi {\n+ *\n+ *     @Override\n+ *     public KEMSpi.EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+ *             AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+ *             throws InvalidAlgorithmParameterException, InvalidKeyException {\n+ *         if (!checkPublicKey(publicKey)) {\n+ *             throw new InvalidKeyException(\"unsupported key\");\n+ *         }\n+ *         if (!checkParameters(spec)) {\n+ *             throw new InvalidAlgorithmParameterException(\"unsupported params\");\n+ *         }\n+ *         return new MyEncapsulator(publicKey, spec, secureRandom);\n+ *     }\n+ *\n+ *     class MyEncapsulator implements KEMSpi.EncapsulatorSpi {\n+ *         MyEncapsulator(PublicKey publicKey, AlgorithmParameterSpec spec,\n+ *                 SecureRandom secureRandom){\n+ *             this.spec = spec != null ? spec : getDefaultParameters();\n+ *             this.secureRandom = secureRandom != null\n+ *                     ? secureRandom\n+ *                     : getDefaultSecureRandom();\n+ *             this.publicKey = publicKey;\n+ *         }\n+ *\n+ *         @Override\n+ *         public KEM.Encapsulated encapsulate(int from, int to, String algorithm) {\n+ *             byte[] encapsulation;\n+ *             byte[] secret;\n+ *             \/\/ calculating...\n+ *             return new KEM.Encapsulated(\n+ *                     new SecretKeySpec(secret, from, to - from, algorithm),\n+ *                     encapsulation, null);\n+ *         }\n+ *\n+ *         \/\/ ...\n+ *     }\n+ *\n+ *     \/\/ ...\n+ * }\n+ * }\n+ *\n+ * @see KEM\n+ * @since 21\n+ *\/\n+public interface KEMSpi {\n+\n+    \/**\n+     * The KEM encapsulator implementation, generated by\n+     * {@link #engineNewEncapsulator} on the KEM sender side.\n+     *\n+     * @see KEM.Encapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface EncapsulatorSpi {\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method must generate a new secret key and key\n+         * encapsulation message that is returned in an {@link KEM.Encapsulated} object.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return an {@link KEM.Encapsulated} object containing a portion of\n+         *          the shared secret as a key with the specified algorithm,\n+         *          key encapsulation message, and optional parameters.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         * @see KEM.Encapsulated\n+         * @see KEM.Encapsulator#encapsulate(int, int, String)\n+         *\/\n+        KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm);\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Encapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Encapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * The KEM decapsulator implementation, generated by\n+     * {@link #engineNewDecapsulator} on the KEM receiver side.\n+     *\n+     * @see KEM.Decapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface DecapsulatorSpi {\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #engineEncapsulationSize()} ()}, or a\n+         *          {@code DecapsulateException} must be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey} with\n+         *          the specified algorithm\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         * @see KEM.Decapsulator#decapsulate(byte[], int, int, String)\n+         *\/\n+        SecretKey engineDecapsulate(byte[] encapsulation, int from, int to, String algorithm)\n+                throws DecapsulateException;\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Decapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Decapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code null}, the implementation must provide\n+     *                     a default one.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     *\/\n+    EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @see KEM#newDecapsulator(PrivateKey, AlgorithmParameterSpec)\n+     *\/\n+    DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEMSpi.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -534,9 +534,0 @@\n-    \/**\n-     * Set the current thread's scoped value bindings.\n-     *\/\n-    void setScopedValueBindings(Object bindings);\n-\n-    Object findScopedValueBindings();\n-\n-    void ensureMaterializedForStackWalk(Object value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.classfile.constantpool.ConstantPoolException;\n@@ -99,1 +100,1 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     * @throws ConstantPoolException if the index is out of range of the\n@@ -109,1 +110,1 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     * @throws ConstantPoolException if the index is out of range of the\n@@ -118,3 +119,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n@@ -130,3 +130,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or the index does not correspond to\n@@ -141,3 +140,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n@@ -152,3 +150,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n@@ -163,3 +160,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n@@ -174,3 +170,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n@@ -185,3 +180,2 @@\n-     * @throws IndexOutOfBoundsException if the index is out of range of the\n-     *         constant pool size, or zero\n-     * @throws IllegalArgumentException if the index does not correspond to\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the index does not correspond to\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassReader.java","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-         * Default is to throw IllegalStateException when any {@link ExceptionCatch},\n+         * Default is to throw IllegalArgumentException when any {@link ExceptionCatch},\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-     * @throws java.lang.IllegalArgumentException if the operation code is not for a branch instruction that accepts\n+     * @throws IllegalArgumentException if the operation code is not for a branch instruction that accepts\n@@ -287,1 +287,1 @@\n-     * @throws java.lang.IllegalArgumentException if the operation code is not for a branch instruction that accepts\n+     * @throws IllegalArgumentException if the operation code is not for a branch instruction that accepts\n@@ -330,1 +330,1 @@\n-         * @throws java.lang.IllegalArgumentException if an existing catch block catches an exception of the given type.\n+         * @throws IllegalArgumentException if an existing catch block catches an exception of the given type.\n@@ -347,1 +347,1 @@\n-         * @throws java.lang.IllegalArgumentException if an existing catch block catches one or more exceptions of the given types.\n+         * @throws IllegalArgumentException if an existing catch block catches one or more exceptions of the given types.\n@@ -360,1 +360,1 @@\n-         * @throws java.lang.IllegalArgumentException if an existing catch block catches all exceptions.\n+         * @throws IllegalArgumentException if an existing catch block catches all exceptions.\n@@ -376,0 +376,1 @@\n+     * @throws IllegalArgumentException if the try block is empty.\n@@ -389,1 +390,1 @@\n-            throw new IllegalStateException(\"The body of the try block is empty\");\n+            throw new IllegalArgumentException(\"The body of the try block is empty\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeBuilder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+\/**\n+ * Thrown to indicate that requested entry cannot be obtained from the constant\n+ * pool.\n+ *\/\n+public class ConstantPoolException extends IllegalArgumentException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 7245472922409094120L;\n+\n+    \/**\n+     * Constructs a {@code ConstantPoolException} with no detail message.\n+     *\/\n+    public ConstantPoolException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a {@code ConstantPoolException} with the specified detail\n+     * message.\n+     *\n+     * @param message the detail message.\n+     *\/\n+    public ConstantPoolException(String message) {\n+        super(message);\n+    }\n+\n+    \/**\n+     * Constructs a {@code ConstantPoolException} with the specified cause and\n+     * a detail message of {@code (cause==null ? null : cause.toString())}.\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link Throwable#getCause()} method).  (A {@code null} value is\n+     *        permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     *\/\n+    public ConstantPoolException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    \/**\n+     * Constructs a {@code ConstantPoolException} with the specified detail\n+     * message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link Throwable#getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link Throwable#getCause()} method).  (A {@code null} value\n+     *        is permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     *\/\n+    public ConstantPoolException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolException.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -132,0 +132,1 @@\n+        int cfLen = reader.classfileLength();\n@@ -136,0 +137,3 @@\n+            if (len < 0 || len > cfLen - p) {\n+                throw new IllegalArgumentException(\"attribute \" + name.stringValue() + \" too big to handle\");\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.classfile.constantpool.ConstantPoolException;\n@@ -94,1 +95,1 @@\n-            throw new IllegalStateException(\"Bad magic number\");\n+            throw new IllegalArgumentException(\"Bad magic number\");\n@@ -121,1 +122,1 @@\n-                default -> throw new IllegalStateException(\n+                default -> throw new ConstantPoolException(\n@@ -309,1 +310,1 @@\n-            throw new IndexOutOfBoundsException(\"Bad CP index: \" + index);\n+            throw new ConstantPoolException(\"Bad CP index: \" + index);\n@@ -339,1 +340,1 @@\n-                default -> throw new IllegalStateException(\n+                default -> throw new ConstantPoolException(\n@@ -350,1 +351,1 @@\n-            throw new IndexOutOfBoundsException(\"Bad CP UTF8 index: \" + index);\n+            throw new ConstantPoolException(\"Bad CP UTF8 index: \" + index);\n@@ -357,1 +358,1 @@\n-            if (tag != TAG_UTF8) throw new IllegalArgumentException(\"Not a UTF8 - index: \" + index);\n+            if (tag != TAG_UTF8) throw new ConstantPoolException(\"Not a UTF8 - index: \" + index);\n@@ -373,1 +374,5 @@\n-            p += 6 + len;\n+            p += 6;\n+            if (len < 0 || len > classfileLength - p) {\n+                throw new IllegalArgumentException(\"attribute \" + readUtf8Entry(p - 6).stringValue() + \" too big to handle\");\n+            }\n+            p += len;\n@@ -410,1 +415,1 @@\n-        throw new IllegalArgumentException(\"Not a module entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a module entry at pos: \" + pos);\n@@ -416,1 +421,1 @@\n-        throw new IllegalArgumentException(\"Not a package entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a package entry at pos: \" + pos);\n@@ -422,1 +427,1 @@\n-        throw new IllegalArgumentException(\"Not a class entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a class entry at pos: \" + pos);\n@@ -428,1 +433,1 @@\n-        throw new IllegalArgumentException(\"Not a name and type entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a name and type entry at pos: \" + pos);\n@@ -434,1 +439,1 @@\n-        throw new IllegalArgumentException(\"Not a method handle entry at pos: \" + pos);\n+        throw new ConstantPoolException(\"Not a method handle entry at pos: \" + pos);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-                    throw new IllegalStateException(\"Unbound label in exception handler\");\n+                    throw new IllegalArgumentException(\"Unbound label in exception handler\");\n@@ -239,1 +239,1 @@\n-                                    throw new IllegalStateException(\"Unbound label in character range\");\n+                                    throw new IllegalArgumentException(\"Unbound label in character range\");\n@@ -268,1 +268,1 @@\n-                                    throw new IllegalStateException(\"Unbound label in local variable type\");\n+                                    throw new IllegalArgumentException(\"Unbound label in local variable type\");\n@@ -291,1 +291,1 @@\n-                                    throw new IllegalStateException(\"Unbound label in local variable type\");\n+                                    throw new IllegalArgumentException(\"Unbound label in local variable type\");\n@@ -344,1 +344,1 @@\n-                    } catch (Exception e) {\n+                    } catch (IllegalArgumentException e) {\n@@ -700,1 +700,1 @@\n-                throw new IllegalStateException(\"Setting label target for already-set label\");\n+                throw new IllegalArgumentException(\"Setting label target for already-set label\");\n@@ -755,1 +755,1 @@\n-    private static final class LabelOverflowException extends IllegalStateException {\n+    private static final class LabelOverflowException extends IllegalArgumentException {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -177,2 +177,1 @@\n-        x = -1 >>> Long.numberOfLeadingZeros(x - 1);\n-        return x + 1;\n+        return 1L << -Long.numberOfLeadingZeros(x - 1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/EntryMap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                throw new IllegalStateException(\"not a valid type signature: \" + sig);\n+                throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n@@ -160,1 +160,1 @@\n-        throw new IllegalStateException(\"not a valid type signature: \" + sig);\n+        throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-                default -> throw new IllegalStateException(String.format(\"Bad tag %d\", reference.tag()));\n+                default -> throw new IllegalArgumentException(String.format(\"Bad tag %d\", reference.tag()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -864,1 +864,1 @@\n-        throw new IllegalStateException(sb.toString());\n+        throw new IllegalArgumentException(sb.toString());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                MemorySessionImpl.toMemorySession(arena), null);\n+                MemorySessionImpl.toMemorySession(arena), cleanup);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        validateVariadicLayouts(function, optionSet);\n@@ -98,0 +99,1 @@\n+            handle = SharedUtils.maybeCheckCaptureSegment(handle, linkRequest.options());\n@@ -137,0 +139,22 @@\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    \/\/ We reject the corresponding layouts here, to avoid issues where unsigned values\n+    \/\/ are sign extended when promoted. (as we don't have a way to unambiguously represent signed-ness atm).\n+    private void validateVariadicLayouts(FunctionDescriptor function, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            List<MemoryLayout> argumentLayouts = function.argumentLayouts();\n+            List<MemoryLayout> variadicLayouts = argumentLayouts.subList(optionSet.firstVariadicArgIndex(), argumentLayouts.size());\n+\n+            for (MemoryLayout variadicLayout : variadicLayouts) {\n+                if (variadicLayout.equals(ValueLayout.JAVA_BOOLEAN)\n+                    || variadicLayout.equals(ValueLayout.JAVA_BYTE)\n+                    || variadicLayout.equals(ValueLayout.JAVA_CHAR)\n+                    || variadicLayout.equals(ValueLayout.JAVA_SHORT)\n+                    || variadicLayout.equals(ValueLayout.JAVA_FLOAT)) {\n+                    throw new IllegalArgumentException(\"Invalid variadic argument layout: \" + variadicLayout);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+    public int firstVariadicArgIndex() {\n+        return getOption(FirstVariadicArg.class).index();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    private static final MethodHandle MH_CHECK_CAPTURE_SEGMENT;\n@@ -113,0 +114,2 @@\n+            MH_CHECK_CAPTURE_SEGMENT = lookup.findStatic(SharedUtils.class, \"checkCaptureSegment\",\n+                    methodType(MemorySegment.class, MemorySegment.class));\n@@ -346,0 +349,17 @@\n+    public static MethodHandle maybeCheckCaptureSegment(MethodHandle handle, LinkerOptions options) {\n+        if (options.hasCapturedCallState()) {\n+            \/\/ (<target address>, SegmentAllocator, <capture segment>, ...) -> ...\n+            handle = MethodHandles.filterArguments(handle, 2, MH_CHECK_CAPTURE_SEGMENT);\n+        }\n+        return handle;\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment checkCaptureSegment(MemorySegment captureSegment) {\n+        Objects.requireNonNull(captureSegment);\n+        if (captureSegment.equals(MemorySegment.NULL)) {\n+            throw new IllegalArgumentException(\"Capture segment is NULL: \" + captureSegment);\n+        }\n+        return captureSegment.asSlice(0, CapturableState.LAYOUT);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -84,1 +83,1 @@\n-        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(inferredMethodType, function, options, Arena.ofAuto());\n@@ -110,1 +109,1 @@\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(targetType, function, options, Arena.ofAuto());\n@@ -126,1 +125,3 @@\n-    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, LinkerOptions options, Arena scope) {\n+        FFIABI abi = FFIABI.DEFAULT;\n+\n@@ -137,1 +138,8 @@\n-        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+\n+        if (options.isVariadicFunction()) {\n+            int numFixedArgs = options.firstVariadicArgIndex();\n+            int numTotalArgs = argLayouts.size();\n+            return LibFallback.prepCifVar(returnType, numFixedArgs, numTotalArgs, argTypes, abi, scope);\n+        } else {\n+            return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+        }\n@@ -155,1 +163,1 @@\n-                capturedState = (MemorySegment) args[argStart++];\n+                capturedState = SharedUtils.checkCaptureSegment((MemorySegment) args[argStart++]);\n@@ -247,1 +255,1 @@\n-            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -107,0 +107,21 @@\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif_var}. The variadic version of prep_cif\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numFixedArgs the number of fixed arguments\n+     * @param numTotalArgs the number of total arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCifVar(MemorySegment returnType, int numFixedArgs, int numTotalArgs, MemorySegment paramTypes, FFIABI abi,\n+                                    Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(NativeConstants.SIZEOF_CIF);\n+        checkStatus(ffi_prep_cif_var(cif.address(), abi.value(), numFixedArgs, numTotalArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n@@ -180,0 +201,1 @@\n+    private static native int ffi_prep_cif_var(long cif, int abi, int nfixedargs, int ntotalargs, long rtype, long atypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        @JEP(number=430, title=\"String Templates\", status=\"First Preview\")\n+        @JEP(number=430, title=\"String Templates\")\n@@ -75,0 +75,6 @@\n+        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\")\n+        UNNAMED_CLASSES,\n+        @JEP(number=446, title=\"Scoped Values\", status=\"Preview\")\n+        SCOPED_VALUES,\n+        @JEP(number=453, title=\"Structured Concurrency\", status=\"Preview\")\n+        STRUCTURED_CONCURRENCY,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MainMethodFinder {\n+    private static boolean correctArgs(Method method) {\n+        int argc = method.getParameterCount();\n+\n+        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n+    }\n+\n+    \/**\n+     * Gather all the \"main\" methods in the class hierarchy.\n+     *\n+     * @param refc         the main class or super class\n+     * @param mains        accumulated main methods\n+     * @param isMainClass  the class is the main class and not a super class\n+     *\/\n+    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n+        if (refc != null && refc != Object.class) {\n+            for (Method method : refc.getDeclaredMethods()) {\n+                int mods = method.getModifiers();\n+                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n+                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n+                if (\"main\".equals(method.getName()) &&\n+                        !method.isSynthetic() &&\n+                        !Modifier.isPrivate(mods) &&\n+                        correctArgs(method) &&\n+                        (isMainClass || !Modifier.isStatic(mods)))\n+                {\n+                    mains.add(method);\n+                }\n+            }\n+\n+            gatherMains(refc.getSuperclass(), mains, false);\n+        }\n+    }\n+\n+    \/**\n+     * Comparator for two methods.\n+     * Priority order is;\n+     * sub-class < super-class.\n+     * static < non-static,\n+     * string arg < no arg and\n+     *\n+     * @param a  first method\n+     * @param b  second method\n+     *\n+     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n+     *\/\n+    private static int compareMethods(Method a, Method b) {\n+        Class<?> aClass = a.getDeclaringClass();\n+        Class<?> bClass = b.getDeclaringClass();\n+\n+        if (aClass != bClass) {\n+            if (bClass.isAssignableFrom(aClass)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        }\n+\n+        int aMods = a.getModifiers();\n+        int bMods = b.getModifiers();\n+        boolean aIsStatic = Modifier.isStatic(aMods);\n+        boolean bIsStatic = Modifier.isStatic(bMods);\n+\n+        if (aIsStatic && !bIsStatic) {\n+            return -1;\n+        } else if (!aIsStatic && bIsStatic) {\n+            return 1;\n+        }\n+\n+        int aCount = a.getParameterCount();\n+        int bCount = b.getParameterCount();\n+\n+        if (bCount < aCount) {\n+            return -1;\n+        } else if (aCount < bCount) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    \/**\n+     * Return the traditional main method or null if not found.\n+     *\n+     * @param mainClass main class\n+     *\n+     * @return main method or null\n+     *\/\n+    private static Method getTraditionalMain(Class<?> mainClass) {\n+        try {\n+            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n+            int mods = traditionalMain.getModifiers();\n+\n+            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n+                return traditionalMain;\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            \/\/ not found\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return priority main method if none found}\n+     *\n+     * @param mainClass main class\n+     *\n+     * @throws NoSuchMethodException when not preview and no method found\n+     *\/\n+    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n+        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n+        if (isTraditionMain) {\n+            return mainClass.getMethod(\"main\", String[].class);\n+        }\n+\n+        List<Method> mains = new ArrayList<>();\n+        gatherMains(mainClass, mains, true);\n+\n+        if (mains.isEmpty()) {\n+            throw new NoSuchMethodException(\"No main method found\");\n+        }\n+\n+        if (1 < mains.size()) {\n+            mains.sort(MainMethodFinder::compareMethods);\n+        }\n+\n+        Method mainMethod = mains.get(0);\n+        Method traditionalMain = getTraditionalMain(mainClass);\n+\n+        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n+            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n+        }\n+\n+        return mains.get(0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.misc;\n-\n-import java.lang.reflect.Constructor;\n-\n-\/**\n- * Defines static methods to allow code in java.base to create or throw\n- * StructureViolationException. This class will go away when the exception\n- * moves to java.base.\n- *\/\n-public class StructureViolationExceptions {\n-    private static final Constructor<?> SVE_CTOR = structureViolationExceptionCtor();\n-\n-    private StructureViolationExceptions() { }\n-\n-    \/**\n-     * Creates a StructureViolationException with the given message.\n-     *\/\n-    public static RuntimeException newException(String message) {\n-        if (SVE_CTOR != null) {\n-            try {\n-                return (RuntimeException) SVE_CTOR.newInstance(message);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        } else {\n-            return new RuntimeException(\"Structure violation exception: \" + message);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a StructureViolationException with no message.\n-     *\/\n-    public static RuntimeException newException() {\n-        return newException(null);\n-    }\n-\n-    \/**\n-     * Throws a StructureViolationException with the given message.\n-     *\/\n-    public static void throwException(String message) {\n-        throw newException(message);\n-    }\n-\n-    \/**\n-     * Throws a StructureViolationException with no message.\n-     *\/\n-    public static void throwException() {\n-        throw newException(null);\n-    }\n-\n-    \/**\n-     * Returns the StructureViolationException(String) constructor.\n-     *\/\n-    private static Constructor<?> structureViolationExceptionCtor() {\n-        Constructor<?> ctor;\n-        try {\n-            Class<?> exClass = Class.forName(\"jdk.incubator.concurrent.StructureViolationException\");\n-            ctor = exClass.getConstructor(String.class);\n-        } catch (ClassNotFoundException e) {\n-            ctor = null;\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-        return ctor;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/StructureViolationExceptions.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -90,1 +91,0 @@\n-            Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n@@ -265,2 +265,2 @@\n-     * @throws jdk.incubator.concurrent.StructureViolationException if the current\n-     * scoped value bindings are not the same as when the flock was created\n+     * @throws StructureViolationException if the current scoped value bindings are\n+     * not the same as when the flock was created\n@@ -408,2 +408,1 @@\n-     * @throws jdk.incubator.concurrent.StructureViolationException if a structure\n-     * violation was detected\n+     * @throws StructureViolationException if a structure violation was detected\n@@ -516,1 +515,1 @@\n-            \/\/ Virtual threads in the root containers are not tracked so need\n+            \/\/ Virtual threads in the root containers may not be tracked so need\n@@ -518,4 +517,6 @@\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual()\n-                    && JLA.threadContainer(thread) == ThreadContainers.root()) {\n-                this.key = ThreadContainers.registerContainer(this);\n+            if (!ThreadContainers.trackAllThreads()) {\n+                Thread thread = Thread.currentThread();\n+                if (thread.isVirtual()\n+                        && JLA.threadContainer(thread) == ThreadContainers.root()) {\n+                    this.key = ThreadContainers.registerContainer(this);\n+                }\n@@ -523,1 +524,0 @@\n-\n@@ -541,1 +541,1 @@\n-                    StructureViolationExceptions.throwException();\n+                    throw new StructureViolationException();\n@@ -566,0 +566,4 @@\n+        @Override\n+        public String name() {\n+            return flock.name();\n+        }\n@@ -583,4 +587,0 @@\n-        public String toString() {\n-            return flock.toString();\n-        }\n-        @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.io.FilePermission;\n@@ -32,1 +31,0 @@\n-import java.io.UncheckedIOException;\n@@ -39,1 +37,0 @@\n-import java.util.PropertyPermission;\n@@ -55,30 +52,0 @@\n-    \/**\n-     * Returns a ClassFileDumper instance for the given key.  To enable\n-     * dumping of the generated classes, set the system property via\n-     * -D<key>=<path>.\n-     *\n-     * The system property is read only once when it is the first time\n-     * the dumper instance for the given key is created.\n-     *\n-     * If not enabled, this method returns ClassFileDumper with null\n-     * dump path.\n-     *\/\n-    public static ClassFileDumper getInstance(String key) {\n-        Objects.requireNonNull(key);\n-\n-        var dumper = DUMPER_MAP.get(key);\n-        if (dumper == null) {\n-            String path = GetPropertyAction.privilegedGetProperty(key);\n-            Path dir;\n-            if (path == null || path.trim().isEmpty()) {\n-                dir = null;\n-            } else {\n-                dir = validateDumpDir(Path.of(path.trim()));\n-            }\n-            var newDumper = new ClassFileDumper(key, dir);\n-            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n-            dumper = v != null ? v : newDumper;\n-        }\n-        return dumper;\n-    }\n-\n@@ -92,3 +59,0 @@\n-     *\n-     * If not enabled, this method returns ClassFileDumper with null\n-     * dump path.\n@@ -96,1 +60,1 @@\n-    public static ClassFileDumper getInstance(String key, Path path) {\n+    public static ClassFileDumper getInstance(String key, String path) {\n@@ -102,5 +66,1 @@\n-            String value = GetPropertyAction.privilegedGetProperty(key);\n-            boolean enabled = value != null && value.isEmpty()\n-                                    ? true : Boolean.parseBoolean(value);\n-            Path dir = enabled ? validateDumpDir(path) : null;\n-            var newDumper = new ClassFileDumper(key, dir);\n+            var newDumper = new ClassFileDumper(key, path);\n@@ -111,1 +71,1 @@\n-        if (dumper.isEnabled() && !path.equals(dumper.dumpPath())) {\n+        if (dumper.isEnabled() && !path.equals(dumper.dumpDir)) {\n@@ -118,1 +78,2 @@\n-    private final Path dumpDir;\n+    private final String dumpDir;\n+    private final boolean enabled;\n@@ -121,1 +82,2 @@\n-    private ClassFileDumper(String key, Path path) {\n+    private ClassFileDumper(String key, String path) {\n+        String value = GetPropertyAction.privilegedGetProperty(key);\n@@ -123,0 +85,4 @@\n+        boolean enabled = value != null && value.isEmpty() ? true : Boolean.parseBoolean(value);\n+        if (enabled) {\n+            validateDumpDir(path);\n+        }\n@@ -124,0 +90,1 @@\n+        this.enabled = enabled;\n@@ -130,5 +97,1 @@\n-        return dumpDir != null;\n-    }\n-\n-    public Path dumpPath() {\n-        return dumpDir;\n+        return enabled;\n@@ -137,2 +100,2 @@\n-    public Path pathname(String internalName) {\n-        return dumpDir.resolve(encodeForFilename(internalName) + \".class\");\n+    private Path pathname(String name) {\n+        return Path.of(dumpDir, encodeForFilename(name) + \".class\");\n@@ -172,13 +135,10 @@\n-                @Override public Void run() {\n-                    try {\n-                        Path dir = path.getParent();\n-                        Files.createDirectories(dir);\n-                        Files.write(path, bytes);\n-                    } catch (Exception ex) {\n-                        if (VM.isModuleSystemInited()) {\n-                            \/\/ log only when lambda is ready to use\n-                            System.getLogger(ClassFileDumper.class.getName())\n-                                  .log(System.Logger.Level.WARNING, \"Exception writing to \" +\n-                                          path.toString() + \" \" + ex.getMessage());\n-                        }\n-                        \/\/ simply don't care if this operation failed\n+            @Override public Void run() {\n+                try {\n+                    Files.createDirectories(path.getParent());\n+                    Files.write(path, bytes);\n+                } catch (Exception ex) {\n+                    if (VM.isModuleSystemInited()) {\n+                        \/\/ log only when lambda is ready to use\n+                        System.getLogger(ClassFileDumper.class.getName())\n+                              .log(System.Logger.Level.WARNING, \"Exception writing to \" +\n+                                        path + \" \" + ex.getMessage());\n@@ -186,6 +146,4 @@\n-                    return null;\n-                }},\n-                null,\n-                new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-                \/\/ createDirectories may need it\n-                new PropertyPermission(\"user.dir\", \"read\"));\n+                    \/\/ simply don't care if this operation failed\n+                }\n+                return null;\n+            }});\n@@ -194,0 +152,3 @@\n+    \/*\n+     * Validate if the given dir is a writeable directory if exists.\n+     *\/\n@@ -195,4 +156,6 @@\n-    private static Path validateDumpDir(Path path) {\n-            return AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Path run() {\n+    private static Path validateDumpDir(String dir) {\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Path run() {\n+                Path path = Path.of(dir);\n+                if (Files.notExists(path)) {\n@@ -202,1 +165,1 @@\n-                        throw new UncheckedIOException(\"Fail to create \" + path, ex);\n+                        throw new IllegalArgumentException(\"Fail to create \" + path, ex);\n@@ -204,6 +167,0 @@\n-                    if (!Files.isDirectory(path)) {\n-                        throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n-                    } else if (!Files.isWritable(path)) {\n-                        throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n-                    }\n-                    return path;\n@@ -211,1 +168,8 @@\n-            });\n+                if (!Files.isDirectory(path)) {\n+                    throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n+                } else if (!Files.isWritable(path)) {\n+                    throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n+                }\n+                return path;\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":47,"deletions":83,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * An immutable container for a key and a value, both of which are nullable.\n+ *\n+ * <p>This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; programmers should treat instances that are\n+ * {@linkplain #equals(Object) equal} as interchangeable and should not\n+ * use instances for synchronization, or unpredictable behavior may\n+ * occur. For example, in a future release, synchronization may fail.\n+ *\n+ * @apiNote\n+ * This class is not exported. Instances are created by various Map implementations\n+ * when they need a Map.Entry that isn't connected to the Map.\n+ *\n+ * <p>This class differs from AbstractMap.SimpleImmutableEntry in that it is not\n+ * serializable and that it is final. This class differs from java.util.KeyValueHolder\n+ * in that the key and value are nullable.\n+ *\n+ * <p>In principle this class could be a variation on KeyValueHolder. However,\n+ * making that class selectively support nullable keys and values is quite intricate.\n+ * Various specifications (such as Map.ofEntries and Map.entry) specify non-nullability\n+ * of the key and the value. Map.Entry.copyOf also requires non-null keys and values;\n+ * but it simply passes through KeyValueHolder instances, assuming their keys and values\n+ * are non-nullable. If a KVH with nullable keys and values were introduced, some way\n+ * to distinguish it would be necessary. This could be done by introducing a subclass\n+ * (requiring KVH to be made non-final) or by introducing some kind of \"mode\" field\n+ * (potentially increasing the size of every KVH instance, though another field could\n+ * probably fit into the object's padding in most JVMs.) More critically, a mode field\n+ * would have to be checked in all the right places to get the right behavior.\n+ *\n+ * <p>A longer range possibility is to selectively relax the restrictions against nulls in\n+ * Map.entry and Map.Entry.copyOf. This would also require some intricate specification\n+ * changes and corresponding implementation changes (e.g., the implementations backing\n+ * Map.of might still need to reject nulls, and so would Map.ofEntries) but allowing\n+ * a Map.Entry itself to contain nulls seems beneficial in general. If this is done,\n+ * merging KeyValueHolder and NullableKeyValueHolder should be reconsidered.\n+ *\n+ * @param <K> the key type\n+ * @param <V> the value type\n+ *\/\n+@jdk.internal.ValueBased\n+public final class NullableKeyValueHolder<K,V> implements Map.Entry<K,V> {\n+    final K key;\n+    final V value;\n+\n+    \/**\n+     * Constructs a NullableKeyValueHolder.\n+     *\n+     * @param k the key, may be null\n+     * @param v the value, may be null\n+     *\/\n+    public NullableKeyValueHolder(K k, V v) {\n+        key = k;\n+        value = v;\n+    }\n+\n+    \/**\n+     * Constructs a NullableKeyValueHolder from a Map.Entry. No need for an\n+     * idempotent copy at this time.\n+     *\n+     * @param entry the entry, must not be null\n+     *\/\n+    public NullableKeyValueHolder(Map.Entry<K,V> entry) {\n+        Objects.requireNonNull(entry);\n+        key = entry.getKey();\n+        value = entry.getValue();\n+    }\n+\n+    \/**\n+     * Gets the key from this holder.\n+     *\n+     * @return the key, may be null\n+     *\/\n+    @Override\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    \/**\n+     * Gets the value from this holder.\n+     *\n+     * @return the value, may be null\n+     *\/\n+    @Override\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    \/**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @param value ignored\n+     * @return never returns normally\n+     *\/\n+    @Override\n+    public V setValue(V value) {\n+        throw new UnsupportedOperationException(\"not supported\");\n+    }\n+\n+    \/**\n+     * Compares the specified object with this entry for equality.\n+     * Returns {@code true} if the given object is also a map entry and\n+     * the two entries' keys and values are equal.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof Map.Entry<?, ?> e\n+                && Objects.equals(key, e.getKey())\n+                && Objects.equals(value, e.getValue());\n+    }\n+\n+    private int hash(Object obj) {\n+        return (obj == null) ? 0 : obj.hashCode();\n+    }\n+\n+    \/**\n+     * Returns the hash code value for this map entry. The hash code\n+     * is {@code key.hashCode() ^ value.hashCode()}.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return hash(key) ^ hash(value);\n+    }\n+\n+    \/**\n+     * Returns a String representation of this map entry.  This\n+     * implementation returns the string representation of this\n+     * entry's key followed by the equals character (\"{@code =}\")\n+     * followed by the string representation of this entry's value.\n+     *\n+     * @return a String representation of this map entry\n+     *\/\n+    @Override\n+    public String toString() {\n+        return key + \"=\" + value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/NullableKeyValueHolder.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.util;\n+\n+\/**\n+ * A software Version with major, minor, and micro components.\n+ * @param major major version\n+ * @param minor minor version\n+ * @param micro micro version\n+ *\/\n+public record OSVersion(int major, int minor, int micro) implements Comparable<OSVersion> {\n+\n+    \/\/ Parse and save the current OS version\n+    private static final OSVersion CURRENT_OSVERSION = initVersion();\n+\n+    \/**\n+     * {@return a Version for major, minor versions}\n+     *\n+     * @param major major version\n+     * @param minor minor version\n+     *\/\n+    public OSVersion(int major, int minor) {\n+        this(major, minor, 0);\n+    }\n+\n+    \/*\n+     * Initialize the current Version from the os.version system property\n+     *\/\n+    private static OSVersion initVersion() {\n+        final String osVer = StaticProperty.osVersion();\n+        try {\n+            return parse(osVer);\n+        } catch (IllegalArgumentException iae) {\n+            throw new InternalError(\"os.version malformed: \" + osVer, iae);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the current operating system version}\n+     *\/\n+    public static OSVersion current() {\n+        return CURRENT_OSVERSION;\n+    }\n+\n+    \/**\n+     * {@return Compare this version with another version}\n+     *\n+     * @param other the object to be compared\n+     *\/\n+    @Override\n+    public int compareTo(OSVersion other) {\n+        int result = Integer.compare(major, other.major);\n+        if (result == 0) {\n+            result = Integer.compare(minor, other.minor);\n+            if (result == 0) {\n+                return Integer.compare(micro, other.micro);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return (micro == 0)\n+                ? major + \".\" + minor\n+                : major + \".\" + minor + \".\" + micro;\n+    }\n+\n+    \/**\n+     * {@return A Version parsed from a version string split on \".\" characters}\n+     * Only major, minor, and micro version numbers are parsed, finer detail is ignored.\n+     * Missing values for minor and micro are replaced with zero.\n+     * The string must start with a number, if there is a '.' it must be followed by a number.\n+     * <p>\n+     * Parsed by hand because it is called before RegEx can be initialized safely.\n+     *\n+     * @param str a version string\n+     * @throws IllegalArgumentException if the string does not start with digits\n+     *          or digits do not follow '.'\n+     *\/\n+    public static OSVersion parse(String str) throws IllegalArgumentException {\n+        int len = str.length();\n+        int majorStart = 0;\n+        int majorEnd = skipDigits(str, majorStart);\n+        int major = Integer.parseInt(str.substring(majorStart, majorEnd));\n+\n+        int minor = 0, micro = 0;\n+        if (majorEnd < len && str.charAt(majorEnd) == '.') {\n+            int minorStart = majorEnd + 1;\n+            int minorEnd = skipDigits(str, minorStart);\n+            minor = Integer.parseInt(str.substring(minorStart, minorEnd));\n+\n+            if (minorEnd < len && str.charAt(minorEnd) == '.') {\n+                int microStart = minorEnd + 1;\n+                int microEnd = skipDigits(str, microStart);\n+                micro = Integer.parseInt(str.substring(microStart, microEnd));\n+            }\n+        }\n+        return new OSVersion(major, minor, micro);\n+    }\n+\n+    \/**\n+     * {@return The index of the first non-digit from start}\n+     * @throws IllegalArgumentException if there are no digits\n+     *\/\n+    private static int skipDigits(String s, int start) {\n+        int index = start;\n+        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n+            index++;\n+        }\n+        if (index == start)\n+            throw new IllegalArgumentException(\"malformed version, missing digits: \" + s);\n+        return index;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OSVersion.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.Locale;\n@@ -83,1 +84,2 @@\n-    private static final OperatingSystem CURRENT_OS = initOS(PlatformProps.CURRENT_OS_STRING);\n+    \/\/ The current OperatingSystem\n+    private static final OperatingSystem CURRENT_OS = initOS();\n@@ -129,30 +131,2 @@\n-    private static OperatingSystem initOS(String osName) {\n-        \/\/ Too early to use Locale conversions, manually do uppercase\n-        StringBuilder sb = new StringBuilder(osName);\n-        for (int i = 0; i < sb.length(); i++) {\n-            char ch = sb.charAt(i);\n-            if (ch >= 'a' && ch <= 'z') {\n-                sb.setCharAt(i, (char)(ch - ('a' - 'A')));  \/\/ Map lower case down to uppercase\n-            }\n-        }\n-        osName = sb.toString();\n-        return OperatingSystem.valueOf(osName);\n-    }\n-\n-    \/**\n-     * {@return the operating system version with major, minor, micro}\n-     *\/\n-    public static Version version() {\n-        return CURRENT_VERSION;\n-    }\n-\n-    \/\/ Parse and save the current version\n-    private static final Version CURRENT_VERSION = initVersion();\n-\n-    private static Version initVersion() {\n-        final String osVer = StaticProperty.osVersion();\n-        try {\n-            return Version.parse(osVer);\n-        } catch (IllegalArgumentException iae) {\n-            throw new InternalError(\"os.version malformed: \" + osVer, iae);\n-        }\n+    private static OperatingSystem initOS() {\n+        return OperatingSystem.valueOf(PlatformProps.CURRENT_OS_STRING.toUpperCase(Locale.ROOT));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OperatingSystem.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.util;\n-\n-\/**\n- * A software Version with major, minor, and micro components.\n- * @param major major version\n- * @param minor minor version\n- * @param micro micro version\n- *\/\n-public record Version(int major, int minor, int micro) implements Comparable<Version> {\n-\n-    \/**\n-     * {@return a Version for major, minor versions}\n-     *\n-     * @param major major version\n-     * @param minor minor version\n-     *\/\n-    public Version(int major, int minor) {\n-        this(major, minor, 0);\n-    }\n-\n-    \/**\n-     * {@return Compare this version with another version}\n-     *\n-     * @param other the object to be compared\n-     *\/\n-    @Override\n-    public int compareTo(Version other) {\n-        int result = Integer.compare(major, other.major);\n-        if (result == 0) {\n-            result = Integer.compare(minor, other.minor);\n-            if (result == 0) {\n-                return Integer.compare(micro, other.micro);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return (micro == 0)\n-                ? major + \".\" + minor\n-                : major + \".\" + minor + \".\" + micro;\n-    }\n-\n-    \/**\n-     * {@return A Version parsed from a version string split on \".\" characters}\n-     * Only major, minor, and micro version numbers are parsed, finer detail is ignored.\n-     * Missing values for minor and micro are replaced with zero.\n-     * The string must start with a number, if there is a '.' it must be followed by a number.\n-     * <p>\n-     * Parsed by hand because it is called before RegEx can be initialized safely.\n-     *\n-     * @param str a version string\n-     * @throws IllegalArgumentException if the string does not start with digits\n-     *          or digits do not follow '.'\n-     *\/\n-    public static Version parse(String str) throws IllegalArgumentException {\n-        int len = str.length();\n-        int majorStart = 0;\n-        int majorEnd = skipDigits(str, majorStart);\n-        int major = Integer.parseInt(str.substring(majorStart, majorEnd));\n-\n-        int minor = 0, micro = 0;\n-        if (majorEnd < len && str.charAt(majorEnd) == '.') {\n-            int minorStart = majorEnd + 1;\n-            int minorEnd = skipDigits(str, minorStart);\n-            minor = Integer.parseInt(str.substring(minorStart, minorEnd));\n-\n-            if (minorEnd < len && str.charAt(minorEnd) == '.') {\n-                int microStart = minorEnd + 1;\n-                int microEnd = skipDigits(str, microStart);\n-                micro = Integer.parseInt(str.substring(microStart, microEnd));\n-            }\n-        }\n-        return new Version(major, minor, micro);\n-    }\n-\n-    \/**\n-     * {@return The index of the first non-digit from start}\n-     * @throws IllegalArgumentException if there are no digits\n-     *\/\n-\n-    private static int skipDigits(String s, int start) {\n-        int index = start;\n-        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n-            index++;\n-        }\n-        if (index == start)\n-            throw new IllegalArgumentException(\"malformed version, missing digits: \" + s);\n-        return index;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Version.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -30,1 +31,0 @@\n-import jdk.internal.misc.StructureViolationExceptions;\n@@ -32,2 +32,0 @@\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n@@ -45,1 +43,1 @@\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationException.class);\n@@ -146,1 +144,1 @@\n-    public static <V> V call(Callable<V> op) throws Exception {\n+    public static <V> V call(Callable<V> op) {\n@@ -205,1 +203,1 @@\n-                var sve = StructureViolationExceptions.newException();\n+                var sve = new StructureViolationException();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Objects;\n@@ -32,1 +31,0 @@\n-import java.util.concurrent.atomic.LongAdder;\n@@ -53,1 +51,1 @@\n-            throw new InternalError(e);\n+            throw new ExceptionInInitializerError(e);\n@@ -60,3 +58,0 @@\n-    \/\/ the number of threads in the container\n-    private final LongAdder threadCount;\n-\n@@ -79,1 +74,0 @@\n-        this.threadCount = new LongAdder();\n@@ -103,0 +97,5 @@\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n@@ -122,1 +121,0 @@\n-        threadCount.add(1L);\n@@ -127,1 +125,0 @@\n-        threadCount.add(-1L);\n@@ -132,5 +129,0 @@\n-    @Override\n-    public long threadCount() {\n-        return threadCount.sum();\n-    }\n-\n@@ -174,10 +166,0 @@\n-\n-    @Override\n-    public String toString() {\n-        String id = Objects.toIdentityString(this);\n-        if (name != null) {\n-            return name + \"\/\" + id;\n-        } else {\n-            return id;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/SharedThreadContainer.java","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -44,0 +45,7 @@\n+    \/**\n+     * Return the name of this container, may be null.\n+     *\/\n+    public String name() {\n+        return null;\n+    }\n+\n@@ -97,0 +105,11 @@\n+\n+    @Override\n+    public String toString() {\n+        String name = name();\n+        if (name != null && name.indexOf('@') >= 0) {\n+            return name;\n+        } else {\n+            String id = Objects.toIdentityString(this);\n+            return (name != null) ? name + \"\/\" + id : id;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.nio.ch.Poller;\n@@ -40,2 +39,1 @@\n- * This class consists exclusively of static methods to support debugging and\n- * monitoring of threads.\n+ * This class consists exclusively of static methods to support groupings of threads.\n@@ -46,0 +44,6 @@\n+    \/\/ true if all threads are tracked\n+    private static final boolean TRACK_ALL_THREADS;\n+\n+    \/\/ the root container\n+    private static final RootContainer ROOT_CONTAINER;\n+\n@@ -50,0 +54,11 @@\n+    static {\n+        String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n+        if (s == null || s.isEmpty() || Boolean.parseBoolean(s)) {\n+            TRACK_ALL_THREADS = true;\n+            ROOT_CONTAINER = new RootContainer.TrackingRootContainer();\n+        } else {\n+            TRACK_ALL_THREADS = false;\n+            ROOT_CONTAINER = new RootContainer.CountingRootContainer();\n+        }\n+    }\n+\n@@ -62,0 +77,7 @@\n+    \/**\n+     * Returns true if all threads are tracked.\n+     *\/\n+    public static boolean trackAllThreads() {\n+        return TRACK_ALL_THREADS;\n+    }\n+\n@@ -86,1 +108,1 @@\n-        return RootContainer.INSTANCE;\n+        return ROOT_CONTAINER;\n@@ -186,3 +208,2 @@\n-     * Root container that \"contains\" all platform threads not started in a\n-     * container plus some (or all) virtual threads that are started directly\n-     * with the Thread API.\n+     * Root container that \"contains\" all platform threads not started in a container.\n+     * It may include all virtual threads started directly with the Thread API.\n@@ -191,9 +212,0 @@\n-        static final RootContainer INSTANCE;\n-        static {\n-            String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n-            if (s != null && (s.isEmpty() || Boolean.parseBoolean(s))) {\n-                INSTANCE = new TrackingRootContainer();\n-            } else {\n-                INSTANCE = new CountingRootContainer();\n-            }\n-        }\n@@ -208,1 +220,1 @@\n-        public String toString() {\n+        public String name() {\n@@ -215,0 +227,4 @@\n+        @Override\n+        public String toString() {\n+            return name();\n+        }\n@@ -273,5 +289,1 @@\n-                \/\/ virtual threads in this container that are those blocked on I\/O.\n-                Stream<Thread> blockedVirtualThreads = Poller.blockedThreads()\n-                        .filter(t -> t.isVirtual()\n-                                && JLA.threadContainer(t) == this);\n-                return Stream.concat(platformThreads(), blockedVirtualThreads);\n+                return platformThreads();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,1 +243,3 @@\n-        threadCount = Long.max(threadCount, container.threadCount());\n+        if (!ThreadContainers.trackAllThreads()) {\n+            threadCount = Long.max(threadCount, container.threadCount());\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-        jdk.incubator.concurrent,\n@@ -225,1 +224,0 @@\n-        jdk.incubator.concurrent,\n@@ -259,1 +257,0 @@\n-        jdk.incubator.concurrent,\n@@ -267,1 +264,0 @@\n-        jdk.incubator.concurrent,\n@@ -286,0 +282,1 @@\n+        jdk.jpackage,\n@@ -328,2 +325,1 @@\n-        jdk.crypto.ec,\n-        jdk.incubator.concurrent;\n+        jdk.crypto.ec;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.lang.reflect.Constructor;\n@@ -81,0 +82,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -846,0 +849,21 @@\n+    \/*\n+     * main type flags\n+     *\/\n+    private static final int MAIN_WITHOUT_ARGS = 1;\n+    private static final int MAIN_NONSTATIC = 2;\n+    private static int mainType = 0;\n+\n+    \/*\n+     * Return type so that launcher invokes the correct main\n+     *\/\n+    public static int getMainType() {\n+        return mainType;\n+    }\n+\n+    private static void setMainType(Method mainMethod) {\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+        mainType = (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n+    }\n+\n@@ -850,1 +874,1 @@\n-            mainMethod = mainClass.getMethod(\"main\", String[].class);\n+            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n@@ -866,0 +890,2 @@\n+        setMainType(mainMethod);\n+\n@@ -867,1 +893,1 @@\n-         * getMethod (above) will choose the correct method, based\n+         * findMainMethod (above) will choose the correct method, based\n@@ -869,1 +895,1 @@\n-         * ensure that the method is static and returns a void.\n+         * ensure that the method is static (non-preview) and returns a void.\n@@ -871,4 +897,10 @@\n-        int mod = mainMethod.getModifiers();\n-        if (!Modifier.isStatic(mod)) {\n-            abort(null, \"java.launcher.cls.error2\", \"static\",\n-                  mainMethod.getDeclaringClass().getName());\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled()) {\n+            if (!isStatic || !isPublic || noArgs) {\n+                abort(null, \"java.launcher.cls.error2\", \"static\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n@@ -876,0 +908,18 @@\n+\n+        if (!isStatic) {\n+            if (mainClass.isMemberClass() && !Modifier.isStatic(mainClass.getModifiers())) {\n+                abort(null, \"java.launcher.cls.error9\",\n+                        mainMethod.getDeclaringClass().getName());\n+            }\n+            try {\n+                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n+                if (Modifier.isPrivate(constructor.getModifiers())) {\n+                    abort(null, \"java.launcher.cls.error8\",\n+                          mainMethod.getDeclaringClass().getName());\n+                }\n+            } catch (Throwable ex) {\n+                abort(null, \"java.launcher.cls.error8\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":57,"deletions":7,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,7 @@\n+java.launcher.cls.error8=\\\n+    Error: no non-private zero argument constructor found in class {0}\\n\\\n+    remove private from existing constructor or define as:\\n\\\n+\\   public {0}()\n+java.launcher.cls.error9=\\\n+    Error: non-static inner class {0} constructor can not be invoked \\n\\\n+    make inner class static or move inner class out to separate source file\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,848 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.provider;\n+\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.*;\n+import java.security.*;\n+import java.security.SecureRandom;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+\/**\n+ * Implementation of the Hierarchical Signature System using the\n+ * Leighton-Micali Signatures (HSS\/LMS) as described in RFC 8554 and\n+ * NIST Special publication 800-208.\n+ *\/\n+public final class HSS extends SignatureSpi {\n+    private HSSPublicKey pubKey;\n+    private ByteArrayOutputStream messageStream;\n+\n+    @Override\n+    @Deprecated\n+    protected void engineSetParameter(String param, Object value) {\n+        throw new InvalidParameterException(\"No settable parameters exist for HSS\/LMS\");\n+    }\n+\n+    @Override\n+    @Deprecated\n+    protected AlgorithmParameters engineGetParameter(String param) {\n+        throw new InvalidParameterException(\"No parameters exist for HSS\/LMS\");\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        throw new InvalidKeyException(\"HSS\/LMS signing is not supported\");\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey prk, SecureRandom sr)\n+            throws InvalidKeyException {\n+        throw new InvalidKeyException(\"HSS\/LMS signing is not supported\");\n+    }\n+\n+    \/\/ This will never be called because engineInitSign unconditionally\n+    \/\/ throws an exception\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        throw new SignatureException(\"HSS\/LMS signing is not supported\");\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        HSSPublicKey pub;\n+        if (publicKey instanceof HSSPublicKey p) {\n+            pub = p;\n+        } else {\n+            KeyFactoryImpl factory = new HSS.KeyFactoryImpl();\n+            Key pk = factory.engineTranslateKey(publicKey);\n+            pub = (HSSPublicKey) pk;\n+        }\n+        pubKey = pub;\n+        messageStream = new ByteArrayOutputStream();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte data) {\n+        messageStream.write(data);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] data, int off, int len) {\n+        messageStream.write(data, off, len);\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] signature)\n+            throws SignatureException {\n+\n+        boolean result = true;\n+        try {\n+            HSSSignature sig = new HSSSignature(signature, pubKey);\n+            LMSPublicKey lmsPubKey = pubKey.lmsPublicKey;\n+            for (int i = 0; i < sig.Nspk; i++) {\n+                byte[] keyArr = sig.pubList[i].keyArray();\n+                result &= LMSUtils.lmsVerify(lmsPubKey, sig.siglist[i], keyArr);\n+                lmsPubKey = sig.pubList[i];\n+            }\n+\n+            result &= LMSUtils.lmsVerify(\n+                    lmsPubKey, sig.siglist[sig.Nspk], messageStream.toByteArray());\n+        } finally {\n+            messageStream.reset();\n+        }\n+        return result;\n+    }\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\"No parameters accepted\");\n+        }\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    static class LMSPublicKey {\n+        final int type;\n+        final int otsType;\n+        final LMSParams lmsParams;\n+        private final byte[] I;\n+        private final byte[] T1;\n+\n+        LMSPublicKey(byte[] keyArray, int offset, boolean checkExactLength)\n+                throws InvalidKeyException {\n+            int inLen = keyArray.length - offset;\n+            if (inLen < 8) {\n+                throw new InvalidKeyException(\"LMS public key is too short\");\n+            }\n+            type = LMSUtils.fourBytesToInt(keyArray, offset);\n+            otsType = LMSUtils.fourBytesToInt(keyArray, offset + 4);\n+            LMOTSParams lmotsParams;\n+\n+            try {\n+                lmsParams = LMSParams.of(type);\n+                lmotsParams = LMOTSParams.of(otsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new InvalidKeyException(e.getMessage());\n+            }\n+\n+            int m = lmsParams.m;\n+            if ((inLen < (24 + m)) || (checkExactLength && (inLen != (24 + m))) ||\n+                    !lmsParams.hasSameHash(lmotsParams)) {\n+                throw new InvalidKeyException(\"Wrong LMS public key length\");\n+            }\n+\n+            I = Arrays.copyOfRange(keyArray, offset + 8, offset + 8 + 16);\n+            T1 = Arrays.copyOfRange(keyArray, offset + 24, offset + 24 + m);\n+        }\n+\n+        void getI(byte[] arr, int pos) {\n+            System.arraycopy(I, 0, arr, pos, 16);\n+        }\n+\n+        boolean isT1(byte[] arr, int pos) {\n+            int m = lmsParams.m;\n+            int diff = 0;\n+            for (int i = 0; i < m; i++) {\n+                diff |= (T1[i] ^ arr[pos + i]);\n+            }\n+            return (diff == 0);\n+        }\n+\n+        byte[] keyArray() {\n+            byte[] result = new byte[keyArrayLength()];\n+            LMSUtils.intToFourBytes(type, result, 0);\n+            LMSUtils.intToFourBytes(otsType, result, 4);\n+            System.arraycopy(I, 0, result, 8, 16);\n+            System.arraycopy(T1, 0, result, 24, lmsParams.m);\n+            return result;\n+        }\n+\n+        int keyArrayLength() {\n+            return 24 + lmsParams.m;\n+        }\n+    }\n+\n+    static class LMSUtils {\n+        static final int LMS_RESERVED = 0;\n+        static final int LMS_SHA256_M32_H5 = 5;\n+        static final int LMS_SHA256_M32_H10 = 6;\n+        static final int LMS_SHA256_M32_H15 = 7;\n+        static final int LMS_SHA256_M32_H20 = 8;\n+        static final int LMS_SHA256_M32_H25 = 9;\n+\n+        static String lmsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMS_RESERVED: typeStr = \"LMS_RESERVED\"; break;\n+                case LMS_SHA256_M32_H5: typeStr = \"LMS_SHA256_M32_H5\"; break;\n+                case LMS_SHA256_M32_H10: typeStr = \"LMS_SHA256_M32_H10\"; break;\n+                case LMS_SHA256_M32_H15: typeStr = \"LMS_SHA256_M32_H15\"; break;\n+                case LMS_SHA256_M32_H20: typeStr = \"LMS_SHA256_M32_H20\"; break;\n+                case LMS_SHA256_M32_H25: typeStr = \"LMS_SHA256_M32_H25\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n+        static final int LMOTS_RESERVED = 0;\n+        static final int LMOTS_SHA256_N32_W1 = 1;\n+        static final int LMOTS_SHA256_N32_W2 = 2;\n+        static final int LMOTS_SHA256_N32_W4 = 3;\n+        static final int LMOTS_SHA256_N32_W8 = 4;\n+\n+        static String lmotsType(int type) {\n+            String typeStr;\n+            switch (type) {\n+                case LMOTS_RESERVED: typeStr = \"LMOTS_RESERVED\"; break;\n+                case LMOTS_SHA256_N32_W1: typeStr = \"LMOTS_SHA256_N32_W1\"; break;\n+                case LMOTS_SHA256_N32_W2: typeStr = \"LMOTS_SHA256_N32_W2\"; break;\n+                case LMOTS_SHA256_N32_W4: typeStr = \"LMOTS_SHA256_N32_W4\"; break;\n+                case LMOTS_SHA256_N32_W8: typeStr = \"LMOTS_SHA256_N32_W8\"; break;\n+                default: typeStr = \"unrecognized\";\n+            }\n+            return typeStr;\n+        }\n+\n+\n+        static int fourBytesToInt(byte[] arr, int i) {\n+            return ((arr[i] & 0xff) << 24) |\n+                    ((arr[i + 1] & 0xff) << 16) |\n+                    ((arr[i + 2] & 0xff) << 8) |\n+                    (arr[i + 3] & 0xff);\n+        }\n+\n+        static void intToFourBytes(int i, byte[] arr, int pos) {\n+            arr[pos] = (byte) (i >> 24);\n+            arr[pos + 1] = (byte) (i >> 16);\n+            arr[pos + 2] = (byte) (i >> 8);\n+            arr[pos + 3] = (byte) i;\n+        }\n+        static boolean lmsVerify(\n+                LMSPublicKey lmsPublicKey, LMSignature sig, byte[] message)\n+                throws SignatureException {\n+\n+            if ((sig.sigOtsType != lmsPublicKey.otsType) ||\n+                    (sig.sigLmType != lmsPublicKey.type)) {\n+                return false;\n+            }\n+            LMOTSignature lmotSig = sig.lmotSig;\n+            LMOTSParams lmotsParams = lmotSig.lmotsParams;\n+            int q = sig.q;\n+            int m = lmsPublicKey.lmsParams.m;\n+            int hashAlg_m = lmsPublicKey.lmsParams.hashAlg_m;\n+            int n = lmotsParams.n;\n+\n+            try {\n+                byte[] otsPkCandidate =\n+                        lmotsParams.lmotsPubKeyCandidate(sig, message, lmsPublicKey);\n+                int nodeNum = lmsPublicKey.lmsParams.twoPowh + q;\n+                int tmp0MsgLen = 22 + n;\n+                int tmpLoopMsgLen = 22 + m + hashAlg_m;\n+                byte[] tmpMsg = new byte[Integer.max(tmp0MsgLen, tmpLoopMsgLen)];\n+                lmsPublicKey.getI(tmpMsg, 0);\n+                MessageDigest md =\n+                        MessageDigest.getInstance(lmsPublicKey.lmsParams.hashAlgStr);\n+                LMSUtils.intToFourBytes(nodeNum, tmpMsg, 16);\n+                tmpMsg[20] = (byte) 0x82; \/\/ D_LEAF = 0x8282\n+                tmpMsg[21] = (byte) 0x82;\n+                System.arraycopy(otsPkCandidate, 0, tmpMsg, 22, n);\n+                md.update(tmpMsg, 0, tmp0MsgLen);\n+                if ((nodeNum & 1) == 1) {\n+                    md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                } else {\n+                    md.digest(tmpMsg, 22, hashAlg_m);\n+                }\n+                tmpMsg[20] = (byte) 0x83; \/\/ D_INTR = 0x8383\n+                tmpMsg[21] = (byte) 0x83;\n+\n+                int i = 0;\n+                while (nodeNum > 1) {\n+                    LMSUtils.intToFourBytes(nodeNum \/ 2, tmpMsg, 16);\n+\n+                    if ((nodeNum & 1) == 1) {\n+                        sig.getPath(i, tmpMsg, 22);\n+                    } else {\n+                        sig.getPath(i, tmpMsg, 22 + m);\n+                    }\n+                    md.update(tmpMsg, 0, 22 + 2 * m);\n+                    nodeNum \/= 2;\n+                    if ((nodeNum & 1) == 1) {\n+                        md.digest(tmpMsg, 22 + m, hashAlg_m);\n+                    } else {\n+                        md.digest(tmpMsg, 22, hashAlg_m);\n+                    }\n+                    i++;\n+                }\n+                return lmsPublicKey.isT1(tmpMsg, 22 + m);\n+            } catch (NoSuchAlgorithmException | DigestException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+    }\n+\n+    static class LMOTSignature {\n+        final int otSigType;\n+        final LMOTSParams lmotsParams;\n+        private final int n;\n+        private final byte[] C;\n+        private final byte[][] y;\n+\n+        LMOTSignature(byte[] sigArray, LMOTSParams lmotsParams)\n+                throws InvalidParameterException {\n+            int inLen = sigArray.length;\n+            if (inLen < 4) {\n+                throw new InvalidParameterException(\"OTS signature is too short\");\n+            }\n+            otSigType = lmotsParams.lmotSigType;\n+            this.lmotsParams = lmotsParams;\n+            n = lmotsParams.n;\n+            int p = lmotsParams.p;\n+            if (inLen != (4 + n * (p + 1))) {\n+                throw new InvalidParameterException(\"OTS signature has incorrect length\");\n+            }\n+            C = Arrays.copyOfRange(sigArray, 4, 4 + n);\n+            int pStart = 4 + n;\n+            y = new byte[p][n];\n+            for (int i = 0; i < p; i++) {\n+                y[i] = Arrays.copyOfRange(sigArray, pStart, pStart + n);\n+                pStart += n;\n+            }\n+        }\n+\n+        void getC(byte[] arr, int pos) {\n+            System.arraycopy(C, 0, arr, pos, n);\n+        }\n+\n+        void getY(int i, byte[] arr, int pos) {\n+            System.arraycopy(y[i], 0, arr, pos, n);\n+        }\n+    }\n+\n+    static class LMSParams {\n+        final int m; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_m = 32; \/\/ output length of the LMS tree hash function\n+        final int h; \/\/ height of the LMS tree\n+        final int twoPowh;\n+        final String hashAlgStr;\n+\n+        LMSParams(int m, int h, String hashAlgStr) {\n+            this.m = m;\n+            this.h = h;\n+            this.hashAlgStr = hashAlgStr;\n+            twoPowh = 1 << h;\n+        }\n+\n+        static LMSParams of(int type) {\n+            int m;\n+            int h;\n+            String hashAlgStr;\n+            switch (type) {\n+                case LMSUtils.LMS_SHA256_M32_H5:\n+                    m = 32;\n+                    h = 5;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H10:\n+                    m = 32;\n+                    h = 10;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H15:\n+                    m = 32;\n+                    h = 15;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H20:\n+                    m = 32;\n+                    h = 20;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                case LMSUtils.LMS_SHA256_M32_H25:\n+                    m = 32;\n+                    h = 25;\n+                    hashAlgStr = \"SHA-256\";\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported or bad LMS type\");\n+            }\n+\n+            return new LMSParams(m, h, hashAlgStr);\n+        }\n+\n+        boolean hasSameHash(LMSParams other) {\n+            return other.hashAlgStr.equals(hashAlgStr) && (other.m == m);\n+        }\n+\n+        boolean hasSameHash(LMOTSParams lmotsParams) {\n+            return lmotsParams.hashAlgName.equals(hashAlgStr) &&\n+                    (lmotsParams.n == m);\n+        }\n+    }\n+\n+    static class LMSignature {\n+        final int sigLmType;\n+        final int sigOtsType;\n+        private final byte[] qArr;\n+        final int q; \/\/ serial number of the LMS key being used for this signature\n+        final LMOTSignature lmotSig;\n+        final int n; \/\/ output length of the hash function used in the OTS\n+        final int p; \/\/ number of hash chains in the signature\n+        final int m; \/\/ output length of the hash function used in the Merkle tree\n+        final int h; \/\/ height of the Merkle tree\n+        private final byte[][] path;\n+\n+        LMSignature(byte[] sigArray, int offset, boolean checkExactLen)\n+                throws SignatureException {\n+            int inLen = sigArray.length - offset;\n+            if (inLen < 8) {\n+                throw new SignatureException(\"LMS signature is too short\");\n+            }\n+\n+            LMOTSParams lmotsParams;\n+            q = LMSUtils.fourBytesToInt(sigArray, offset);\n+            qArr = Arrays.copyOfRange(sigArray, offset, offset + 4);\n+            sigOtsType = LMSUtils.fourBytesToInt(sigArray, offset + 4);\n+            try {\n+                lmotsParams = LMOTSParams.of(sigOtsType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n+\n+            n = lmotsParams.n;\n+            p = lmotsParams.p;\n+\n+            if (inLen < (12 + n * (p + 1))) {\n+                throw new SignatureException(\"LMS signature is too short\");\n+            }\n+\n+            int otsSigLen = 4 + n * (p + 1);\n+            byte[] otSigArr = Arrays.copyOfRange(\n+                    sigArray, offset + 4, offset + 4 + otsSigLen);\n+            lmotSig = new LMOTSignature(otSigArr, lmotsParams);\n+\n+            int sigTypePos = offset + 4 + otsSigLen;\n+            sigLmType = LMSUtils.fourBytesToInt(sigArray, sigTypePos);\n+\n+            LMSParams lmsParams;\n+            try {\n+                lmsParams = LMSParams.of(sigLmType);\n+            } catch (IllegalArgumentException e) {\n+                throw new SignatureException(e);\n+            }\n+            m = lmsParams.m;\n+            h = lmsParams.h;\n+\n+            int sigArrLen = (12 + n * (p + 1) + m * h);\n+            if ((q >= (1 << h)) ||\n+                    (inLen < sigArrLen) ||\n+                    (checkExactLen && (inLen != sigArrLen))) {\n+                throw new SignatureException(\"LMS signature length is incorrect\");\n+            }\n+\n+            int pStart = offset + 12 + n * (p + 1);\n+            path = new byte[h][m];\n+            for (int i = 0; i < h; i++) {\n+                path[i] = Arrays.copyOfRange(sigArray, pStart, pStart + m);\n+                pStart += m;\n+            }\n+        }\n+\n+        int sigArrayLength() {\n+            return 12 + n * (p + 1) + m * h;\n+        }\n+\n+        void getQArr(byte[] arr, int pos) {\n+            System.arraycopy(qArr, 0, arr, pos, 4);\n+        }\n+\n+        void getPath(int i, byte[] arr, int pos) {\n+            System.arraycopy(path[i], 0, arr, pos, m);\n+        }\n+    }\n+\n+    static class LMOTSParams {\n+        final int lmotSigType;\n+        final int n; \/\/ the number of bytes used from the hash output\n+        final int hashAlg_n = 32; \/\/ the output length of the hash function\n+        final int w;\n+        final int twoPowWMinus1;\n+        final int ls;\n+        final int p;\n+        final String hashAlgName;\n+\n+        \/\/ The initial buffer image for the lmotsPubKeyCandidate() function.\n+        \/\/ In that function a clone of this buffer is fed into the\n+        \/\/ hash function as input to the implDigestFixedLengthPreprocessed()\n+        \/\/ function (which is basically an allocation and padding computation\n+        \/\/ free digest() function, so we can avoid the update()-digest()\n+        \/\/ sequence) which is parametrized so that the digest output is copied\n+        \/\/ back into the buffer. This way, we avoid memory allocations and some\n+        \/\/ computations that would have to be done otherwise.\n+        final byte[] hashBuf;\n+        \/\/ Precomputed block for SHA256 when the message size is 55 bytes\n+        \/\/ (i.e. when SHA256 is used)\n+        private static final byte[] hashbufSha256_32 = {\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, 0,\n+                0, 0, 0, 0, 0, 0, 0, (byte) 0x80,\n+                0, 0, 0, 0, 0, 0, 1, (byte) 0xb8\n+        };\n+\n+        private LMOTSParams(\n+                int lmotSigType, int hLen, int w,\n+                int ls, int p, String hashAlgName) {\n+            this.lmotSigType = lmotSigType;\n+            this.n = hLen;\n+            this.w = w;\n+            this.ls = ls;\n+            this.p = p;\n+            twoPowWMinus1 = (1 << w) - 1;\n+            this.hashAlgName = hashAlgName;\n+            hashBuf = hashbufSha256_32;\n+        }\n+\n+        static LMOTSParams of(int lmotsType) {\n+            LMOTSParams params;\n+            switch (lmotsType) {\n+                case LMSUtils.LMOTS_SHA256_N32_W1:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 1, 7, 265, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W2:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 2, 6, 133, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W4:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 4, 4, 67, \"SHA-256\");\n+                    break;\n+                case LMSUtils.LMOTS_SHA256_N32_W8:\n+                    params = new LMOTSParams(\n+                            lmotsType, 32, 8, 0, 34, \"SHA-256\");\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\n+                            \"Unsupported or bad OTS Algorithm Identifier.\");\n+            }\n+            return params;\n+        }\n+\n+        int coef(byte[] S, int i) {\n+            return (twoPowWMinus1 &\n+                    (S[i * w \/ 8] >> (8 - (w * (i % (8 \/ w)) + w))));\n+        }\n+\n+        private void addCksm(byte[] S) {\n+            int len = n;\n+            int sum = 0;\n+            int numSlices = len * 8 \/ w;\n+            for (int i = 0; i < numSlices; i++) {\n+                sum += twoPowWMinus1 - coef(S, i);\n+            }\n+            sum = sum << ls;\n+            S[len] = (byte) (sum >> 8);\n+            S[len + 1] = (byte) (sum & 0xff);\n+        }\n+\n+        void digestFixedLengthPreprocessed(\n+                SHA2.SHA256 sha256, byte[] input, int inLen,\n+                byte[] output, int outOffset, int outLen) {\n+            sha256.implDigestFixedLengthPreprocessed(\n+                    input, inLen, output, outOffset, outLen);\n+        }\n+\n+        byte[] lmotsPubKeyCandidate(\n+                LMSignature lmSig, byte[] message, LMSPublicKey pKey)\n+                throws SignatureException {\n+            LMOTSignature lmOtSig = lmSig.lmotSig;\n+            if (lmOtSig.otSigType != pKey.otsType) {\n+                throw new SignatureException(\n+                        \"OTS public key type and OTS signature type do not match\");\n+            }\n+\n+            byte[] preQ = new byte[22 + hashAlg_n];\n+            pKey.getI(preQ, 0);\n+            lmSig.getQArr(preQ, 16);\n+            preQ[20] = (byte) 0x81; \/\/ D_MSG = 0x8181\n+            preQ[21] = (byte) 0x81;\n+            lmOtSig.getC(preQ, 22);\n+            MessageDigest md;\n+            try {\n+                md = MessageDigest.getInstance(hashAlgName);\n+            } catch (NoSuchAlgorithmException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest implementation not found\", e);\n+            }\n+            byte[] result;\n+            try {\n+                md.update(preQ, 0, 22 + n);\n+                md.update(message);\n+                byte[] QWithChecksum = new byte[hashAlg_n + 2];\n+                md.digest(QWithChecksum, 0, hashAlg_n);\n+                \/\/ the MessageDigest object has now been reset\n+                addCksm(QWithChecksum);\n+\n+                byte[] preCandidate = new byte[22 + (p - 1) * n + hashAlg_n];\n+                pKey.getI(preCandidate, 0);\n+                lmSig.getQArr(preCandidate, 16);\n+                preCandidate[20] = (byte) 0x80; \/\/ D_PBLC = 0x8080\n+                preCandidate[21] = (byte) 0x80;\n+\n+                byte[] preZi = hashBuf.clone();\n+                int hashLen = hashBuf.length;\n+                SHA2.SHA256 sha256 = new SHA2.SHA256();\n+                pKey.getI(preZi, 0);\n+                lmSig.getQArr(preZi, 16);\n+\n+                int twoPowWMinus2 = twoPowWMinus1 - 1;\n+                for (int i = 0; i < p; i++) {\n+                    int a = coef(QWithChecksum, i);\n+                    if (a == twoPowWMinus1) {\n+                        lmOtSig.getY(i, preCandidate, 22 + i * n);\n+                    } else {\n+                        preZi[20] = (byte) (i >> 8);\n+                        preZi[21] = (byte) i;\n+                        lmOtSig.getY(i, preZi, 23);\n+                    }\n+\n+                    for (int j = a; j < twoPowWMinus1; j++) {\n+                        preZi[22] = (byte) j;\n+                        if (j < twoPowWMinus2) {\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, hashLen, preZi, 23, n);\n+                        } else {\n+                            digestFixedLengthPreprocessed(\n+                                    sha256, preZi, hashLen, preCandidate, 22 + i * n, n);\n+                        }\n+                    }\n+                }\n+                md.update(preCandidate, 0, 22 + p * n);\n+\n+                result = md.digest();\n+            } catch (DigestException e) { \/\/ This should not happen\n+                throw new ProviderException(\"Digest failed\", e);\n+            }\n+            if (n != hashAlg_n) {\n+                result = Arrays.copyOfRange(result, 0, n);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static class KeyFactoryImpl extends KeyFactorySpi {\n+        @Override\n+        protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            if (keySpec instanceof X509EncodedKeySpec x509Spec) {\n+                try {\n+                    return new HSSPublicKey(\n+                            x509Spec.getEncoded(), true);\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            } else if (keySpec instanceof RawKeySpec rawSpec) {\n+                try {\n+                    return new HSSPublicKey(rawSpec.getKeyArr(), false);\n+                } catch (InvalidKeyException e) {\n+                    throw new InvalidKeySpecException(e);\n+                }\n+            }\n+            throw new InvalidKeySpecException(\"Unrecognized KeySpec\");\n+        }\n+\n+        @Override\n+        protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+                throws InvalidKeySpecException {\n+            throw new InvalidKeySpecException(\n+                    \"Private key generation is not supported\");\n+        }\n+\n+        @Override\n+        protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+                throws InvalidKeySpecException {\n+            if (key == null) {\n+                throw new InvalidKeySpecException(\"key should not be null\");\n+            }\n+            if (key.getFormat().equals(\"X.509\") &&\n+                    key.getAlgorithm().equalsIgnoreCase(\"HSS\/LMS\")) {\n+                if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n+                    return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+                }\n+                throw new InvalidKeySpecException(\n+                        \"keySpec is not an X509EncodedKeySpec\");\n+            }\n+            throw new InvalidKeySpecException(\"Wrong key format or key algorithm\");\n+        }\n+\n+        @Override\n+        protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+            if (key == null) {\n+                throw new InvalidKeyException(\"key cannot be null\");\n+            }\n+            PublicKey pKey;\n+            try {\n+                \/\/ Check if key originates from this factory\n+                if (key instanceof HSSPublicKey) {\n+                    return key;\n+                }\n+                \/\/ Convert key to spec\n+                X509EncodedKeySpec x509EncodedKeySpec\n+                        = engineGetKeySpec(key, X509EncodedKeySpec.class);\n+                \/\/ Create key from spec, and return it\n+                pKey = engineGeneratePublic(x509EncodedKeySpec);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            }\n+            return pKey;\n+        }\n+    }\n+\n+    static class HSSPublicKey extends X509Key implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 21;\n+        private transient int L;\n+        private transient LMSPublicKey lmsPublicKey;\n+\n+        HSSPublicKey(byte[] keyArray, boolean x509Encoded)\n+                throws InvalidKeyException {\n+            if (x509Encoded) {\n+                decode(keyArray);\n+                if (!KnownOIDs.HSSLMS.value().equals(algid.getOID().toString()) ||\n+                        (algid.getParameters() != null)) {\n+                    throw new InvalidKeyException(\"X509Key is not an HSS key\");\n+                }\n+            } else {\n+                int inLen = keyArray.length;\n+                if (inLen < 4) {\n+                    throw new InvalidKeyException(\"HSS public key too short\");\n+                }\n+                L = LMSUtils.fourBytesToInt(keyArray, 0);\n+                lmsPublicKey =\n+                        new LMSPublicKey(\n+                                Arrays.copyOfRange(keyArray, 4, keyArray.length),\n+                                0, true);\n+                algid = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.HSSLMS));\n+                byte[] derEncodedKeyarray =\n+                        new DerOutputStream()\n+                                .putOctetString(keyArray)\n+                                .toByteArray();\n+                this.setKey(new BitArray(\n+                        8 * derEncodedKeyarray.length, derEncodedKeyarray));\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            HexDumpEncoder encoder = new HexDumpEncoder();\n+\n+            return \"HSS\/LMS public key, number of layers: \" + L +\n+                    \", LMS type: \" + LMSUtils.lmsType(lmsPublicKey.type) +\n+                    \",\\nOTS type: \" + LMSUtils.lmotsType(lmsPublicKey.otsType) +\n+                    \", byte array representation:\\n\" +\n+                    encoder.encode(getKey().toByteArray());\n+        }\n+\n+        \/**\n+         * Parse the key. Called by X509Key.\n+         *\/\n+        @Override\n+        protected void parseKeyBits() throws InvalidKeyException {\n+            byte[] keyArray = getKey().toByteArray();\n+            if ((keyArray[0] != DerValue.tag_OctetString) || (keyArray[1] != keyArray.length -2)) {\n+                throw new InvalidKeyException(\"Bad X509Key\");\n+            }\n+            L = LMSUtils.fourBytesToInt(keyArray, 2);\n+            lmsPublicKey = new LMSPublicKey(keyArray, 6, true);\n+        }\n+\n+        @java.io.Serial\n+        private Object writeReplace() throws java.io.ObjectStreamException {\n+            return new KeyRep(KeyRep.Type.PUBLIC,\n+                    getAlgorithm(),\n+                    getFormat(),\n+                    getEncoded());\n+        }\n+\n+        @java.io.Serial\n+        private void readObject(java.io.ObjectInputStream s)\n+                throws java.io.ObjectStreamException {\n+            throw new InvalidObjectException(\n+                    \"HSS public keys are not directly deserializable\");\n+        }\n+    }\n+\n+    static class HSSSignature {\n+        private final int Nspk;\n+        private final LMSignature[] siglist;\n+        private final LMSPublicKey[] pubList;\n+\n+        HSSSignature(byte[] sigArr, HSSPublicKey pubKey)\n+                throws SignatureException {\n+            if (sigArr.length < 4) {\n+                throw new SignatureException(\"HSS signature is too short\");\n+            }\n+            Nspk = LMSUtils.fourBytesToInt(sigArr, 0);\n+            if (Nspk + 1 != pubKey.L) {\n+                throw new SignatureException(\n+                        \"HSS signature and public key have different tree heights\");\n+            }\n+            siglist = new LMSignature[Nspk + 1];\n+            pubList = new LMSPublicKey[Nspk];\n+            int index = 4;\n+            try {\n+                for (int i = 0; i < Nspk; i++) {\n+                    siglist[i] = new LMSignature(sigArr, index, false);\n+                    index += siglist[i].sigArrayLength();\n+                    pubList[i] = new LMSPublicKey(sigArr, index, false);\n+                    if (!pubKey\n+                            .lmsPublicKey\n+                            .lmsParams\n+                            .hasSameHash(pubList[i].lmsParams)) {\n+                        throw new SignatureException(\n+                                \"Digest algorithm in public key and Signature do not match\");\n+                    }\n+                    index += pubList[i].keyArrayLength();\n+                }\n+                siglist[Nspk] = new LMSignature(sigArr, index, true);\n+            } catch (InvalidKeyException e) {\n+                throw new SignatureException(\"Invalid key in HSS signature\", e);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/HSS.java","additions":848,"deletions":0,"binary":false,"changes":848,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+    private static final int BLOCKSIZE = 64;\n@@ -84,1 +85,1 @@\n-        super(name, digestLength, 64);\n+        super(name, digestLength, BLOCKSIZE);\n@@ -118,0 +119,11 @@\n+\n+    protected void implDigestFixedLengthPreprocessed(\n+            byte[] input, int inLen, byte[] output, int outOffset, int outLen) {\n+        implReset();\n+\n+        for (int ofs = 0; ofs < inLen; ofs += BLOCKSIZE) {\n+            implCompress0(input, ofs);\n+        }\n+        i2bBig(state, 0, output, outOffset, outLen);\n+    }\n+\n@@ -132,1 +144,1 @@\n-        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkFromIndexSize(ofs, BLOCKSIZE, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,4 @@\n+\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        addWithAlias(p, \"Signature\", \"HSS\/LMS\", \"sun.security.provider.HSS\", attrs);\n@@ -217,0 +221,2 @@\n+        addWithAlias(p, \"KeyFactory\", \"HSS\/LMS\",\n+                \"sun.security.provider.HSS$KeyFactoryImpl\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-final class HKDF {\n+public final class HKDF {\n@@ -60,1 +60,1 @@\n-    HKDF(String hashAlg) throws NoSuchAlgorithmException {\n+    public HKDF(String hashAlg) throws NoSuchAlgorithmException {\n@@ -85,1 +85,1 @@\n-    SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n+    public SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n@@ -113,1 +113,1 @@\n-    SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n+    public SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n@@ -136,1 +136,1 @@\n-    SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n+    public SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HKDF.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,5 @@\n+\n+    public static final NamedCurve P_256;\n+    public static final NamedCurve P_384;\n+    public static final NamedCurve P_521;\n+\n@@ -112,1 +117,1 @@\n-    private static void add(KnownOIDs o, int type, String sfield,\n+    private static NamedCurve add(KnownOIDs o, int type, String sfield,\n@@ -146,0 +151,2 @@\n+\n+        return params;\n@@ -258,1 +265,1 @@\n-        add(KnownOIDs.secp256r1, PD,\n+        P_256 = add(KnownOIDs.secp256r1, PD,\n@@ -267,1 +274,1 @@\n-        add(KnownOIDs.secp384r1, PD,\n+        P_384 = add(KnownOIDs.secp384r1, PD,\n@@ -276,1 +283,1 @@\n-        add(KnownOIDs.secp521r1, PD,\n+        P_521 = add(KnownOIDs.secp521r1, PD,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CurveDB.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,1 @@\n+    HSSLMS(\"1.2.840.113549.1.9.16.3.17\", \"HSS\/LMS\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+public final class PBEUtil {\n+\n+    \/*\n+     * PBES2Params is an auxiliary class that represents the state needed for\n+     * PBES2 operations (iterations count, salt and IV) and its (re)\n+     * initialization logic. Users of this class are CipherSpi implementors that\n+     * support PBES2 cryptography (RFC #8018), such as PBES2Core (SunJCE) and\n+     * P11PBECipher (SunPKCS11).\n+     *\n+     * CipherSpi implementors must call ::getPBEKeySpec in every engine\n+     * initialization (CipherSpi::engineInit override) to reset the state and\n+     * get new values in a PBEKeySpec instance. These new values are taken\n+     * from parameters, defaults or generated randomly.\n+     *\n+     * After engine initialization, values in effect can be extracted with\n+     * ::getAlgorithmParameters (as AlgorithmParameters) or ::getIvSpec (as\n+     * IvParameterSpec).\n+     *\/\n+    public static final class PBES2Params {\n+        private static final int DEFAULT_SALT_LENGTH = 20;\n+        private static final int DEFAULT_ITERATIONS = 4096;\n+\n+        private int iCount;\n+        private byte[] salt;\n+        private IvParameterSpec ivSpec;\n+\n+        \/*\n+         * Initialize a PBES2Params instance. May generate random salt and\n+         * IV if not passed and the operation is encryption. If initialization\n+         * fails, values are reset. Used by PBES2Params and P11PBECipher\n+         * (SunPKCS11).\n+         *\/\n+        public void initialize(int blkSize, int opmode, int iCount, byte[] salt,\n+                AlgorithmParameterSpec ivSpec, SecureRandom random)\n+                throws InvalidAlgorithmParameterException {\n+            try {\n+                boolean doEncrypt = opmode == Cipher.ENCRYPT_MODE ||\n+                        opmode == Cipher.WRAP_MODE;\n+                if (ivSpec instanceof IvParameterSpec iv) {\n+                    this.ivSpec = iv;\n+                } else if (ivSpec == null && doEncrypt) {\n+                    byte[] ivBytes = new byte[blkSize];\n+                    random.nextBytes(ivBytes);\n+                    this.ivSpec = new IvParameterSpec(ivBytes);\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(\"Wrong \" +\n+                            \"parameter type: IvParameterSpec \" +\n+                            (doEncrypt ? \"or null \" : \"\") + \"expected\");\n+                }\n+                this.iCount = iCount == 0 ? DEFAULT_ITERATIONS : iCount;\n+                if (salt == null) {\n+                    if (doEncrypt) {\n+                        salt = new byte[DEFAULT_SALT_LENGTH];\n+                        random.nextBytes(salt);\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException(\"Salt \" +\n+                                \"needed for decryption\");\n+                    }\n+                }\n+                this.salt = salt;\n+            } catch (InvalidAlgorithmParameterException e) {\n+                this.ivSpec = null;\n+                this.iCount = 0;\n+                this.salt = null;\n+                throw e;\n+            }\n+        }\n+\n+        \/*\n+         * Obtain an IvParameterSpec for Cipher services. This method returns\n+         * null when the state is not initialized. Used by PBES2Core (SunJCE)\n+         * and P11PBECipher (SunPKCS11).\n+         *\/\n+        public IvParameterSpec getIvSpec() {\n+            return ivSpec;\n+        }\n+\n+        \/*\n+         * Obtain AlgorithmParameters for Cipher services. This method will\n+         * initialize PBES2Params if needed, generating new values randomly or\n+         * assigning from defaults. If PBES2Params is initialized, existing\n+         * values will be returned. Used by PBES2Core (SunJCE) and\n+         * P11PBECipher (SunPKCS11).\n+         *\/\n+        public AlgorithmParameters getAlgorithmParameters(int blkSize,\n+                String pbeAlgo, Provider algParamsProv, SecureRandom random) {\n+            AlgorithmParameters params;\n+            try {\n+                if (iCount == 0 && salt == null && ivSpec == null) {\n+                    initialize(blkSize, Cipher.ENCRYPT_MODE, 0, null, null,\n+                            random);\n+                }\n+                params = AlgorithmParameters.getInstance(pbeAlgo,\n+                        algParamsProv);\n+                params.init(new PBEParameterSpec(salt, iCount, ivSpec));\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"AlgorithmParameters for \"\n+                        + pbeAlgo + \" not configured\");\n+            } catch (InvalidParameterSpecException ipse) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"PBEParameterSpec not supported\");\n+            } catch (InvalidAlgorithmParameterException iape) {\n+                \/\/ should never happen\n+                throw new RuntimeException(\"Error initializing PBES2Params\");\n+            }\n+            return params;\n+        }\n+\n+        \/*\n+         * Initialize PBES2Params and obtain a PBEKeySpec for Cipher services.\n+         * Data from the key, parameters, defaults or random may be used for\n+         * initialization. Used by PBES2Core (SunJCE) and P11PBECipher\n+         * (SunPKCS11).\n+         *\/\n+        public PBEKeySpec getPBEKeySpec(int blkSize, int keyLength, int opmode,\n+                Key key, AlgorithmParameterSpec params, SecureRandom random)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (key == null) {\n+                throw new InvalidKeyException(\"Null key\");\n+            }\n+            byte[] passwdBytes;\n+            char[] passwdChars = null;\n+            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n+                    (passwdBytes = key.getEncoded()) == null) {\n+                throw new InvalidKeyException(\"Missing password\");\n+            }\n+            try {\n+                int iCountInit;\n+                byte[] saltInit;\n+                AlgorithmParameterSpec ivSpecInit;\n+                \/\/ Extract from the supplied PBE params, if present\n+                if (params instanceof PBEParameterSpec pbeParams) {\n+                    \/\/ salt should be non-null per PBEParameterSpec\n+                    iCountInit = check(pbeParams.getIterationCount());\n+                    saltInit = check(pbeParams.getSalt());\n+                    ivSpecInit = pbeParams.getParameterSpec();\n+                } else if (params == null) {\n+                    \/\/ Try extracting from the key if present. If unspecified,\n+                    \/\/ PBEKey returns 0 and null respectively.\n+                    if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+                        iCountInit = check(pbeKey.getIterationCount());\n+                        saltInit = check(pbeKey.getSalt());\n+                    } else {\n+                        iCountInit = 0;\n+                        saltInit = null;\n+                    }\n+                    ivSpecInit = null;\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Wrong parameter type: PBE expected\");\n+                }\n+                initialize(blkSize, opmode, iCountInit, saltInit, ivSpecInit,\n+                        random);\n+                passwdChars = new char[passwdBytes.length];\n+                for (int i = 0; i < passwdChars.length; i++) {\n+                    passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n+                }\n+                return new PBEKeySpec(passwdChars, salt, iCount, keyLength);\n+            } finally {\n+                \/\/ password char[] was cloned in PBEKeySpec constructor,\n+                \/\/ so we can zero it out here\n+                if (passwdChars != null) Arrays.fill(passwdChars, '\\0');\n+                if (passwdBytes != null) Arrays.fill(passwdBytes, (byte)0x00);\n+            }\n+        }\n+\n+        \/*\n+         * Obtain an AlgorithmParameterSpec from an AlgorithmParameters\n+         * instance, for Cipher services. Used by PBES2Core (SunJCE) and\n+         * P11PBECipher (SunPKCS11).\n+         *\/\n+        public static AlgorithmParameterSpec getParameterSpec(\n+                AlgorithmParameters params)\n+                throws InvalidAlgorithmParameterException {\n+            AlgorithmParameterSpec pbeSpec = null;\n+            if (params != null) {\n+                try {\n+                    pbeSpec = params.getParameterSpec(PBEParameterSpec.class);\n+                } catch (InvalidParameterSpecException ipse) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Wrong parameter type: PBE expected\");\n+                }\n+            }\n+            return pbeSpec;\n+        }\n+\n+        private static byte[] check(byte[] salt)\n+                throws InvalidAlgorithmParameterException {\n+            if (salt != null && salt.length < 8) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Salt must be at least 8 bytes long\");\n+            }\n+            return salt;\n+        }\n+\n+        private static int check(int iCount)\n+                throws InvalidAlgorithmParameterException {\n+            if (iCount < 0) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Iteration count must be a positive number\");\n+            }\n+            return iCount;\n+        }\n+    }\n+\n+    \/*\n+     * Obtain a PBEKeySpec for Mac services, after key and parameters\n+     * validation. Used by HmacPKCS12PBECore (SunJCE) and P11Mac (SunPKCS11).\n+     *\/\n+    public static PBEKeySpec getPBAKeySpec(Key key,\n+            AlgorithmParameterSpec params)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        char[] passwdChars;\n+        byte[] salt = null;\n+        int iCount = 0;\n+        if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+            passwdChars = pbeKey.getPassword();\n+            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n+            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n+        } else if (key instanceof SecretKey) {\n+            byte[] passwdBytes;\n+            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n+                    (passwdBytes = key.getEncoded()) == null) {\n+                throw new InvalidKeyException(\"Missing password\");\n+            }\n+            passwdChars = new char[passwdBytes.length];\n+            for (int i = 0; i < passwdChars.length; i++) {\n+                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n+            }\n+            Arrays.fill(passwdBytes, (byte)0x00);\n+        } else {\n+            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n+        }\n+\n+        try {\n+            if (params == null) {\n+                \/\/ should not auto-generate default values since current\n+                \/\/ javax.crypto.Mac api does not have any method for caller to\n+                \/\/ retrieve the generated defaults.\n+                if ((salt == null) || (iCount == 0)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"PBEParameterSpec required for salt \" +\n+                            \"and iteration count\");\n+                }\n+            } else if (!(params instanceof PBEParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"PBEParameterSpec type required\");\n+            } else {\n+                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n+                \/\/ make sure the parameter values are consistent\n+                if (salt != null) {\n+                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Inconsistent value of salt \" +\n+                                \"between key and params\");\n+                    }\n+                } else {\n+                    salt = pbeParams.getSalt();\n+                }\n+                if (iCount != 0) {\n+                    if (iCount != pbeParams.getIterationCount()) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Different iteration count \" +\n+                                \"between key and params\");\n+                    }\n+                } else {\n+                    iCount = pbeParams.getIterationCount();\n+                }\n+            }\n+            \/\/ For security purpose, we need to enforce a minimum length\n+            \/\/ for salt; just require the minimum salt length to be 8-byte\n+            \/\/ which is what PKCS#5 recommends and openssl does.\n+            if (salt.length < 8) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Salt must be at least 8 bytes long\");\n+            }\n+            if (iCount <= 0) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"IterationCount must be a positive number\");\n+            }\n+            return new PBEKeySpec(passwdChars, salt, iCount);\n+        } finally {\n+            Arrays.fill(passwdChars, '\\0');\n+        }\n+    }\n+\n+    \/*\n+     * Check that the key implements the PBEKey interface. If params is an\n+     * instance of PBEParameterSpec, validate consistency with the key's\n+     * derivation data. Used by P11Mac and P11PBECipher (SunPKCS11).\n+     *\/\n+    public static void checkKeyAndParams(Key key,\n+            AlgorithmParameterSpec params, String algorithm)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                if (pbeParams.getIterationCount() !=\n+                        pbeKey.getIterationCount() ||\n+                        !Arrays.equals(pbeParams.getSalt(), pbeKey.getSalt())) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Salt or iteration count parameters are \" +\n+                            \"not consistent with PBE key\");\n+                }\n+            }\n+        } else {\n+            throw new InvalidKeyException(\n+                    \"Cannot use a \" + algorithm + \" service with a key that \" +\n+                    \"does not implement javax.crypto.interfaces.PBEKey\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBEUtil.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.spec.KeySpec;\n+\n+\/**\n+ * This is a KeySpec that is used to specify a key by its byte array implementation.\n+ * It is intended to be used in testing algorithms where the algorithm specification\n+ * describes the key in this form.\n+ *\/\n+public class RawKeySpec implements KeySpec {\n+    private final byte[] keyArr;\n+    \/**\n+     * The sole constructor.\n+     * @param key contains the key as a byte array\n+     *\/\n+    public RawKeySpec(byte[] key) {\n+        keyArr = key.clone();\n+    }\n+\n+    \/**\n+     * Getter function.\n+     * @return a copy of the key bits\n+     *\/\n+    public byte[] getKeyArr() {\n+        return keyArr.clone();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/RawKeySpec.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -61,0 +61,4 @@\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif_1var(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nfixedargs, jint ntotalargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif_var(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nfixedargs, (unsigned int) ntotalargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -918,1 +918,1 @@\n-            (*env)->ReleasePrimitiveArrayCritical(env, value, str, 0);\n+            (*env)->ReleasePrimitiveArrayCritical(env, value, str, JNI_ABORT);\n@@ -929,1 +929,1 @@\n-        (*env)->ReleasePrimitiveArrayCritical(env, value, str, 0);\n+        (*env)->ReleasePrimitiveArrayCritical(env, value, str, JNI_ABORT);\n@@ -943,1 +943,1 @@\n-    (*env)->ReleasePrimitiveArrayCritical(env, value, str, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, value, str, JNI_ABORT);\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -404,1 +404,0 @@\n-    jmethodID mainID;\n@@ -406,0 +405,3 @@\n+    jmethodID mainID;\n+    jmethodID constructor;\n+    jobject mainObject;\n@@ -542,6 +544,49 @@\n-    mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"([Ljava\/lang\/String;)V\");\n-    CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-\n-    \/* Invoke main method. *\/\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+#define MAIN_WITHOUT_ARGS 1\n+#define MAIN_NONSTATIC 2\n+\n+    jclass helperClass = GetLauncherHelperClass(env);\n+    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"getMainType\",\n+                                                      \"()I\");\n+    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n+    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n+    CHECK_EXCEPTION_LEAVE(mainType);\n+\n+    switch (mainType) {\n+    case 0: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_WITHOUT_ARGS: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+        break;\n+        }\n+    case MAIN_NONSTATIC: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID);\n+        break;\n+        }\n+    }\n@@ -911,1 +956,1 @@\n-    def = JLI_MemAlloc(sizeof(format)\n+    size_t defSize = sizeof(format)\n@@ -913,2 +958,3 @@\n-                       + JLI_StrLen(s));\n-    sprintf(def, format, s);\n+                       + JLI_StrLen(s);\n+    def = JLI_MemAlloc(defSize);\n+    snprintf(def, defSize, format, s);\n@@ -1367,2 +1413,3 @@\n-            char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);\n-            sprintf(tmp, \"-X%s\", arg + 1); \/* skip '-' *\/\n+            size_t tmpSize = JLI_StrLen(arg) + 6;\n+            char *tmp = JLI_MemAlloc(tmpSize);\n+            snprintf(tmp, tmpSize, \"-X%s\", arg + 1); \/* skip '-' *\/\n@@ -1702,2 +1749,3 @@\n-                envcp = (char *)JLI_MemAlloc(JLI_StrLen(s) + 40);\n-                sprintf(envcp, \"-Denv.class.path=%s\", s);\n+                size_t envcpSize = JLI_StrLen(s) + 40;\n+                envcp = (char *)JLI_MemAlloc(envcpSize);\n+                snprintf(envcp, envcpSize, \"-Denv.class.path=%s\", s);\n@@ -1715,2 +1763,3 @@\n-    apphome = (char *)JLI_MemAlloc(JLI_StrLen(home) + 40);\n-    sprintf(apphome, \"-Dapplication.home=%s\", home);\n+    size_t apphomeSize = JLI_StrLen(home) + 40;\n+    apphome = (char *)JLI_MemAlloc(apphomeSize);\n+    snprintf(apphome, apphomeSize, \"-Dapplication.home=%s\", home);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -104,0 +104,8 @@\n+    \/\/ Remove trailing '\/' if present and there are at least two characters\n+    private static String trimSeparator(String s) {\n+        int len = s.length();\n+        if (len > 1 && s.charAt(len - 1) == '\/')\n+            return s.substring(0, len - 1);\n+        return s;\n+    }\n+\n@@ -109,1 +117,1 @@\n-            return parent + child;\n+            return trimSeparator(parent + child);\n@@ -111,2 +119,2 @@\n-        if (parent.equals(\"\/\")) return parent + child;\n-        return parent + '\/' + child;\n+        if (parent.equals(\"\/\")) return trimSeparator(parent + child);\n+        return trimSeparator(parent + '\/' + child);\n","filename":"src\/java.base\/unix\/classes\/java\/io\/UnixFileSystem.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -908,0 +908,9 @@\n+            \/\/ Obtain the directory stream pointer. It will be closed by\n+            \/\/ UnixDirectoryStream::close.\n+            long dp = -1;\n+            try {\n+                dp = opendir(path);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(path);\n+            }\n+\n@@ -911,1 +920,0 @@\n-            FileSystemProvider provider = getFileSystem().provider();\n@@ -913,1 +921,1 @@\n-            try (DirectoryStream<Path> entries = provider.newDirectoryStream(path, filter)) {\n+            try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include <assert.h>\n@@ -86,1 +87,5 @@\n-    if (readFully (fdin, c, sizeof(*c)) == -1) {\n+#ifdef DEBUG\n+    jtregSimulateCrash(0, 5);\n+#endif\n+\n+    if (readFully (fdin, c, sizeof(*c)) != sizeof(*c)) {\n@@ -90,1 +95,1 @@\n-    if (readFully (fdin, &sp, sizeof(sp)) == -1) {\n+    if (readFully (fdin, &sp, sizeof(sp)) != sizeof(sp)) {\n@@ -99,1 +104,1 @@\n-    if (readFully (fdin, buf, bufsize) == -1) {\n+    if (readFully (fdin, buf, bufsize) != bufsize) {\n@@ -135,1 +140,1 @@\n-    int r, fdin, fdout;\n+    int r, fdinr, fdinw, fdout;\n@@ -138,3 +143,6 @@\n-    r = sscanf (argv[argc-1], \"%d:%d\", &fdin, &fdout);\n-    if (r == 2 && fcntl(fdin, F_GETFD) != -1) {\n-        fstat(fdin, &buf);\n+#ifdef DEBUG\n+    jtregSimulateCrash(0, 4);\n+#endif\n+    r = sscanf (argv[argc-1], \"%d:%d:%d\", &fdinr, &fdinw, &fdout);\n+    if (r == 3 && fcntl(fdinr, F_GETFD) != -1 && fcntl(fdinw, F_GETFD) != -1) {\n+        fstat(fdinr, &buf);\n@@ -151,1 +159,12 @@\n-    initChildStuff (fdin, fdout, &c);\n+    \/\/ Close the writing end of the pipe we use for reading from the parent.\n+    \/\/ We have to do this before we start reading from the parent to avoid\n+    \/\/ blocking in the case the parent exits before we finished reading from it.\n+    close(fdinw); \/\/ Deliberately ignore errors (see https:\/\/lwn.net\/Articles\/576478\/).\n+    initChildStuff (fdinr, fdout, &c);\n+    \/\/ Now set the file descriptor for the pipe's writing end to -1\n+    \/\/ for the case that somebody tries to close it again.\n+    assert(c.childenv[1] == fdinw);\n+    c.childenv[1] = -1;\n+    \/\/ The file descriptor for reporting errors back to our parent we got on the command\n+    \/\/ line should be the same like the one in the ChildStuff struct we've just read.\n+    assert(c.fail[1] == fdout);\n","filename":"src\/java.base\/unix\/native\/jspawnhelper\/jspawnhelper.c","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -625,1 +625,1 @@\n-    int ret;\n+    size_t ret;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -490,1 +490,1 @@\n-    char *buf, buf1[(2 * 11) + 2]; \/\/ \"%d:%d\\0\"\n+    char *buf, buf1[(3 * 11) + 3]; \/\/ \"%d:%d:%d\\0\"\n@@ -497,1 +497,1 @@\n-    snprintf(buf1, sizeof(buf1), \"%d:%d\", c->childenv[0], c->fail[1]);\n+    snprintf(buf1, sizeof(buf1), \"%d:%d:%d\", c->childenv[0], c->childenv[1], c->fail[1]);\n@@ -530,1 +530,1 @@\n-                fcntl(c->fds[i], F_SETFD, flags & (~1));\n+                fcntl(c->fds[i], F_SETFD, flags & (~FD_CLOEXEC));\n@@ -541,0 +541,4 @@\n+#ifdef DEBUG\n+    jtregSimulateCrash(resultPid, 1);\n+#endif\n+\n@@ -556,4 +560,14 @@\n-    write(c->childenv[1], (char *)&magic, sizeof(magic)); \/\/ magic number first\n-    write(c->childenv[1], (char *)c, sizeof(*c));\n-    write(c->childenv[1], (char *)&sp, sizeof(sp));\n-    write(c->childenv[1], buf, bufsize);\n+    if (writeFully(c->childenv[1], (char *)&magic, sizeof(magic)) != sizeof(magic)) { \/\/ magic number first\n+        return -1;\n+    }\n+#ifdef DEBUG\n+    jtregSimulateCrash(resultPid, 2);\n+#endif\n+    if (writeFully(c->childenv[1], (char *)c, sizeof(*c)) != sizeof(*c) ||\n+        writeFully(c->childenv[1], (char *)&sp, sizeof(sp)) != sizeof(sp) ||\n+        writeFully(c->childenv[1], buf, bufsize) != bufsize) {\n+        return -1;\n+    }\n+    \/* We're done. Let jspwanhelper know he can't expect any more data from us. *\/\n+    close(c->childenv[1]);\n+    c->childenv[1] = -1;\n@@ -561,0 +575,3 @@\n+#ifdef DEBUG\n+    jtregSimulateCrash(resultPid, 3);\n+#endif\n@@ -613,0 +630,2 @@\n+    \/\/ Reset errno to protect against bogus error messages\n+    errno = 0;\n@@ -711,1 +730,0 @@\n-            assert(errnum == CHILD_IS_ALIVE);\n@@ -713,3 +731,2 @@\n-                \/* Should never happen since the first thing the spawn\n-                 * helper should do is to send an alive ping to the parent,\n-                 * before doing any subsequent work. *\/\n+                \/* This can happen if the spawn helper encounters an error\n+                 * before or during the handshake with the parent. *\/\n@@ -751,2 +768,6 @@\n-    closeSafely(childenv[0]);\n-    closeSafely(childenv[1]);\n+    \/* We use 'c->childenv' here rather than 'childenv' because 'spawnChild()' might have\n+     * already closed 'c->childenv[1]' and signaled this by setting 'c->childenv[1]' to '-1'.\n+     * Otherwise 'c->childenv' and 'childenv' are the same because we just copied 'childenv'\n+     * to 'c->childenv' (with 'copyPipe()') before calling 'startChild()'. *\/\n+    closeSafely(c->childenv[0]);\n+    closeSafely(c->childenv[1]);\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -591,1 +591,1 @@\n-    sprintf(buf, (const char *)\"GMT%c%02.2d:%02.2d\",\n+    snprintf(buf, sizeof(buf), (const char *)\"GMT%c%02.2d:%02.2d\",\n@@ -598,1 +598,1 @@\n-    sprintf(buf, (const char *)\"GMT%c%c%c:%c%c\", offset[0], offset[1], offset[2],\n+    snprintf(buf, sizeof(buf), (const char *)\"GMT%c%c%c:%c%c\", offset[0], offset[1], offset[2],\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,8 +39,0 @@\n-ssize_t\n-restartableWrite(int fd, const void *buf, size_t count)\n-{\n-    ssize_t result;\n-    RESTARTABLE(write(fd, buf, count), result);\n-    return result;\n-}\n-\n@@ -166,0 +158,40 @@\n+\/*\n+ * Writes nbyte bytes from buf into file descriptor fd,\n+ * The write operation is retried in case of EINTR or partial writes.\n+ *\n+ * Returns number of bytes written (normally nbyte).\n+ * In case of write errors, returns -1 and sets errno.\n+ *\/\n+ssize_t\n+writeFully(int fd, const void *buf, size_t nbyte)\n+{\n+#ifdef DEBUG\n+\/* This code is only used in debug builds for testing truncated writes\n+ * during the handshake with the spawn helper for MODE_POSIX_SPAWN.\n+ * See: test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java\n+ *\/\n+    const char* env = getenv(\"JTREG_JSPAWNHELPER_PROTOCOL_TEST\");\n+    if (env != NULL && atoi(env) == 99 && nbyte == sizeof(ChildStuff)) {\n+        printf(\"posix_spawn: truncating write of ChildStuff struct\\n\");\n+        fflush(stdout);\n+        nbyte = nbyte \/ 2;\n+    }\n+#endif\n+    ssize_t remaining = nbyte;\n+    for (;;) {\n+        ssize_t n = write(fd, buf, remaining);\n+        if (n > 0) {\n+            remaining -= n;\n+            if (remaining <= 0)\n+                return nbyte;\n+            \/* We were interrupted in the middle of writing the bytes.\n+             * Unlikely, but possible. *\/\n+            buf = (void *) (((char *)buf) + n);\n+        } else if (n == -1 && errno == EINTR) {\n+            \/* Retry *\/\n+        } else {\n+            return -1;\n+        }\n+    }\n+}\n+\n@@ -213,1 +245,1 @@\n-    if (mode == MODE_CLONE || mode == MODE_VFORK) {\n+    if (mode == MODE_VFORK) {\n@@ -324,1 +356,3 @@\n-        restartableWrite(fail_pipe_fd, &code, sizeof(code));\n+        if (writeFully(fail_pipe_fd, &code, sizeof(code)) != sizeof(code)) {\n+            goto WhyCantJohnnyExec;\n+        }\n@@ -327,0 +361,3 @@\n+#ifdef DEBUG\n+    jtregSimulateCrash(0, 6);\n+#endif\n@@ -393,1 +430,1 @@\n-        restartableWrite(fail_pipe_fd, &errnum, sizeof(errnum));\n+        writeFully(fail_pipe_fd, &errnum, sizeof(errnum));\n@@ -399,0 +436,17 @@\n+\n+#ifdef DEBUG\n+\/* This method is only used in debug builds for testing MODE_POSIX_SPAWN\n+ * in the light of abnormal program termination of either the parent JVM\n+ * or the newly created jspawnhelper child process during the execution of\n+ * Java_java_lang_ProcessImpl_forkAndExec().\n+ * See: test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java\n+ *\/\n+void jtregSimulateCrash(pid_t child, int stage) {\n+    const char* env = getenv(\"JTREG_JSPAWNHELPER_PROTOCOL_TEST\");\n+    if (env != NULL && atoi(env) == stage) {\n+        printf(\"posix_spawn:%d\\n\", child);\n+        fflush(stdout);\n+        _exit(stage);\n+    }\n+}\n+#endif\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":66,"deletions":12,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-#define MODE_CLONE 4\n@@ -131,1 +130,1 @@\n-ssize_t restartableWrite(int fd, const void *buf, size_t count);\n+ssize_t writeFully(int fd, const void *buf, size_t count);\n@@ -152,0 +151,10 @@\n+#ifdef DEBUG\n+\/* This method is only used in debug builds for testing MODE_POSIX_SPAWN\n+ * in the light of abnormal program termination of either the parent JVM\n+ * or the newly created jspawnhelper child process during the execution of\n+ * Java_java_lang_ProcessImpl_forkAndExec().\n+ * See: test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java\n+ *\/\n+void jtregSimulateCrash(pid_t child, int stage);\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.h","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,1 @@\n-                sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n+                snprintf(new_runpath, new_runpath_size, LD_LIBRARY_PATH \"=\"\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,1 +1269,1 @@\n-            sprintf(addr6, \"%s:%s:%s:%s:%s:%s:%s:%s\",\n+            snprintf(addr6, sizeof(addr6), \"%s:%s:%s:%s:%s:%s:%s:%s\",\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-        sprintf(buf, format, hostname, error_string);\n+        snprintf(buf, size, format, hostname, error_string);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1251,1 +1251,1 @@\n-#elif _ALLBSD_SOURCE\n+#elif defined(_ALLBSD_SOURCE)\n@@ -1272,1 +1272,1 @@\n-#elif _ALLBSD_SOURCE\n+#elif defined(_ALLBSD_SOURCE)\n@@ -1291,1 +1291,1 @@\n-#elif _ALLBSD_SOURCE\n+#elif defined(_ALLBSD_SOURCE)\n@@ -1310,1 +1310,1 @@\n-#elif _ALLBSD_SOURCE\n+#elif defined(_ALLBSD_SOURCE)\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -288,0 +288,7 @@\n+\n+        \/\/ if present, strip trailing name separator unless after a ':'\n+        if (theChars.length > 1\n+            && theChars[theChars.length - 1] == slash\n+            && theChars[theChars.length - 2] != ':')\n+            return new String(theChars, 0, theChars.length - 1);\n+\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -241,3 +241,3 @@\n-                CreateSymbolicLink(targetPath,\n-                                   WindowsPath.addPrefixIfNeeded(linkTarget),\n-                                   flags);\n+                WindowsLinkSupport.createSymbolicLink(targetPath,\n+                                                      WindowsPath.addPrefixIfNeeded(linkTarget),\n+                                                      flags);\n@@ -444,3 +444,3 @@\n-                CreateSymbolicLink(targetPath,\n-                                   WindowsPath.addPrefixIfNeeded(linkTarget),\n-                                   SYMBOLIC_LINK_FLAG_DIRECTORY);\n+                WindowsLinkSupport.createSymbolicLink(targetPath,\n+                                                      WindowsPath.addPrefixIfNeeded(linkTarget),\n+                                                      SYMBOLIC_LINK_FLAG_DIRECTORY);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -597,3 +597,3 @@\n-            CreateSymbolicLink(link.getPathForWin32Calls(),\n-                               WindowsPath.addPrefixIfNeeded(target.toString()),\n-                               flags);\n+            WindowsLinkSupport.createSymbolicLink(link.getPathForWin32Calls(),\n+                                                  WindowsPath.addPrefixIfNeeded(target.toString()),\n+                                                  flags);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,0 +48,30 @@\n+    \/**\n+     * Creates a symbolic link, retyring if not privileged\n+     *\/\n+    static void createSymbolicLink(String link, String target, int flags)\n+        throws WindowsException\n+    {\n+        try {\n+            CreateSymbolicLink(link, target, flags);\n+        } catch (WindowsException x) {\n+            \/\/ Retry if the privilege to create symbolic links is not held\n+            if (x.lastError() == ERROR_PRIVILEGE_NOT_HELD) {\n+                flags |= SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;\n+                try {\n+                    CreateSymbolicLink(link, target, flags);\n+                    return;\n+                } catch (WindowsException y) {\n+                    \/\/ Throw an exception if and only if it is not due to symbolic link creation\n+                    \/\/ privilege not being held (ERROR_PRIVILEGE_NOT_HELD) nor the\n+                    \/\/ SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE flag not being recognized\n+                    \/\/ (ERROR_INVALID_PARAMETER). The latter will occur for Windows builds\n+                    \/\/ older than 14972.\n+                    int lastError = y.lastError();\n+                    if (lastError != ERROR_PRIVILEGE_NOT_HELD && lastError != ERROR_INVALID_PARAMETER)\n+                        throw y;\n+                }\n+            }\n+            throw x;\n+        }\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -978,13 +978,0 @@\n-        } catch (WindowsException x) {\n-            if (x.lastError() == ERROR_PRIVILEGE_NOT_HELD) {\n-                flags |= SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;\n-                try {\n-                    CreateSymbolicLink0(linkBuffer.address(),\n-                                        targetBuffer.address(), flags);\n-                    return;\n-                } catch (WindowsException ignored) {\n-                    \/\/ Will fail with ERROR_INVALID_PARAMETER for Windows\n-                    \/\/ builds older than 14972.\n-                }\n-            }\n-            throw x;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsNativeDispatcher.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        sprintf(buf, \"ms%d\", cp);\n+        snprintf(buf, sizeof(buf), \"ms%d\", cp);\n@@ -61,1 +61,1 @@\n-        sprintf(buf, \"UTF-8\");\n+        snprintf(buf, sizeof(buf), \"UTF-8\");\n@@ -63,1 +63,1 @@\n-        sprintf(buf, \"cp%d\", cp);\n+        snprintf(buf, sizeof(buf), \"cp%d\", cp);\n","filename":"src\/java.base\/windows\/native\/libjava\/Console_md.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-static void customZoneName(LONG bias, char *buffer) {\n+static void customZoneName(LONG bias, char *buffer, size_t bufSize) {\n@@ -137,1 +137,1 @@\n-        sprintf(buffer, \"GMT%c%02d:%02d\",\n+        snprintf(buffer, bufSize, \"GMT%c%02d:%02d\",\n@@ -149,1 +149,1 @@\n-static int getWinTimeZone(char *winZoneName)\n+static int getWinTimeZone(char *winZoneName, size_t winZoneNameBufSize)\n@@ -176,1 +176,1 @@\n-            customZoneName(dtzi.Bias, winZoneName);\n+            customZoneName(dtzi.Bias, winZoneName, winZoneNameBufSize);\n@@ -209,1 +209,1 @@\n-            customZoneName(dtzi.Bias, winZoneName);\n+            customZoneName(dtzi.Bias, winZoneName, winZoneNameBufSize);\n@@ -254,1 +254,1 @@\n-                    customZoneName(tzi.Bias, winZoneName);\n+                    customZoneName(tzi.Bias, winZoneName, winZoneNameBufSize);\n@@ -521,1 +521,1 @@\n-    result = getWinTimeZone(winZoneName);\n+    result = getWinTimeZone(winZoneName, sizeof(winZoneName));\n@@ -571,1 +571,1 @@\n-    customZoneName(bias, zonename);\n+    customZoneName(bias, zonename, sizeof(zonename));\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,2 @@\n-    char* buf = malloc(16);\n+    size_t buflen = 16;\n+    char* buf = malloc(buflen);\n@@ -144,1 +145,1 @@\n-        sprintf(buf, \"ms%d\", cp);\n+        snprintf(buf, buflen, \"ms%d\", cp);\n@@ -146,1 +147,1 @@\n-        sprintf(buf, \"UTF-8\");\n+        snprintf(buf, buflen, \"UTF-8\");\n@@ -148,1 +149,1 @@\n-        sprintf(buf, \"cp%d\", cp);\n+        snprintf(buf, buflen, \"cp%d\", cp);\n@@ -578,1 +579,1 @@\n-        sprintf(buf, \"%d.%d\", majorVersion, minorVersion);\n+        snprintf(buf, sizeof(buf), \"%d.%d\", majorVersion, minorVersion);\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-    sprintf(exc, \"%s%s\", JNU_JAVANETPKG, excP);\n+    snprintf(exc, sizeof(exc), \"%s%s\", JNU_JAVANETPKG, excP);\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -179,0 +180,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n+     * to create an unnamed class hosted in {@code Foo.java}. All\n+     * unnamed classes must be in an unnamed package.\n+     *\n@@ -258,0 +266,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n+     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n+     * classes must be in an unnamed package.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-     * The version recognized by the Java Platform 1.1.\n+     * The version introduced by the Java Platform 1.1.\n@@ -90,2 +90,3 @@\n-     * The language is {@code RELEASE_0} augmented with nested classes as described in the 1.1 update to\n-     * <cite>The Java Language Specification, First Edition<\/cite>.\n+     * The language is {@code RELEASE_0} augmented with nested classes\n+     * as described in the 1.1 update to <cite>The Java Language\n+     * Specification, First Edition<\/cite>.\n@@ -96,1 +97,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -107,1 +108,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -115,1 +116,1 @@\n-     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * The version introduced by the Java 2 Platform, Standard Edition,\n@@ -126,1 +127,1 @@\n-     * The version recognized by the Java 2 Platform, Standard\n+     * The version introduced by the Java 2 Platform, Standard\n@@ -146,1 +147,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -158,1 +159,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -161,1 +162,1 @@\n-     * Additions in this release include, diamond syntax for\n+     * Additions in this release include diamond syntax for\n@@ -175,1 +176,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -190,1 +191,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -209,1 +210,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -226,1 +227,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -243,1 +244,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -256,1 +257,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -269,1 +270,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -285,1 +286,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -301,1 +302,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -320,1 +321,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -339,1 +340,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -353,1 +354,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -367,1 +368,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -381,1 +382,1 @@\n-     * The version recognized by the Java Platform, Standard Edition\n+     * The version introduced by the Java Platform, Standard Edition\n@@ -384,0 +385,3 @@\n+     * Additions in this release include record patterns and pattern\n+     * matching for {@code switch}.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":29,"deletions":25,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -150,1 +152,1 @@\n-     * For local and anonymous classes, which do not have canonical\n+     * For local, anonymous, and {@linkplain #isUnnamed() unnamed} classes, which do not have canonical\n@@ -166,0 +168,1 @@\n+     * @jls 7.3 Compilation Units\n@@ -175,0 +178,4 @@\n+     * For an {@linkplain #isUnnamed() unnamed} class, a name matching\n+     * the base name of the hosting file, minus any extension, is\n+     * returned.\n+     *\n@@ -182,0 +189,16 @@\n+    \/**\n+     * {@return {@code true} if this is an unnamed class and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns {@code false}.\n+     *\n+     * @jls 7.3 Compilation Units\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    default boolean isUnnamed() {\n+        return false;\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- * collections and do use the argument as a backing store.  The\n+ * collections that do <em>not<\/em> use the argument collection as a backing store.  The\n@@ -51,2 +51,2 @@\n- * lists are mutable but unsafe for concurrent access.  A returned set\n- * has the same iteration order as the argument set to a method.\n+ * lists are mutable and unsafe for concurrent access.  A returned set\n+ * from a method has the same iteration order as the argument set to the method.\n@@ -54,1 +54,1 @@\n- * <p>If iterables and sets containing {@code null} are passed as\n+ * <p>If iterables or sets containing {@code null} are passed as\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementFilter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2013, 2019 SAP SE. All rights reserved.\n+# Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n@@ -310,0 +310,2 @@\n+# C and POSIX locale\n+sequence.allfonts.UTF-8.en.=latin-1\n@@ -317,1 +319,1 @@\n-sequence.allfonts.x-EUC_CN=latin-1,chinese\n+sequence.allfonts.x-IBM1383=latin-1,chinese\n@@ -322,1 +324,1 @@\n-sequence.allfonts.Big5=latin-1,taiwanese-iso10646\n+sequence.allfonts.x-IBM950=latin-1,taiwanese-iso10646\n","filename":"src\/java.desktop\/aix\/data\/fontconfig\/fontconfig.properties","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.event.FocusEvent;\n@@ -359,1 +360,1 @@\n-                slider.requestFocus();\n+                slider.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaSliderUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-                child.requestFocus();\n+                child.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaSpinnerUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-                c.requestFocusInWindow();\n+                c.requestFocusInWindow(FocusEvent.Cause.MOUSE_EVENT);\n@@ -201,1 +201,1 @@\n-                    c.requestFocusInWindow();\n+                    c.requestFocusInWindow(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaTextFieldSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-                    requestFocus();\n+                    requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKColorChooserPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-                b.requestFocus();\n+                b.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicButtonListener.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -930,1 +930,1 @@\n-                    comp.requestFocus();\n+                    comp.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n@@ -934,1 +934,1 @@\n-                comboBox.requestFocus();\n+                comboBox.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n@@ -1240,1 +1240,5 @@\n-                comp.requestFocus();\n+                if (e != null) {\n+                    comp.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n+                } else {\n+                    comp.requestFocus();\n+                }\n@@ -1244,1 +1248,5 @@\n-            comboBox.requestFocus();\n+            if (e != null) {\n+                comboBox.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n+            } else {\n+                comboBox.requestFocus();\n+            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboPopup.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.nio.file.Files;\n@@ -712,2 +711,1 @@\n-                                || (!fsv.isFileSystem(((File)objects[0]))\n-                                    && !Files.isSymbolicLink(((File)objects[0]).toPath())))) {\n+                                || (!fsv.isFileSystem((File)objects[0])))) {\n@@ -723,1 +721,1 @@\n-                                        && (fsv.isFileSystem(f) || Files.isSymbolicLink(f.toPath()))\n+                                        && fsv.isFileSystem(f)\n@@ -745,5 +743,1 @@\n-                            if (Files.isSymbolicLink(file.toPath())) {\n-                                chooser.setSelectedFile(file);\n-                            } else {\n-                                chooser.setSelectedFile(null);\n-                            }\n+                            chooser.setSelectedFile(null);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1284,1 +1284,1 @@\n-                scrollbar.requestFocus();\n+                scrollbar.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n@@ -1561,1 +1561,1 @@\n-                scrollbar.requestFocus();\n+                scrollbar.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollBarUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1984,1 +1984,1 @@\n-                slider.requestFocus();\n+                slider.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-                        child.requestFocus();\n+                        child.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSpinnerUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4145,1 +4145,1 @@\n-                    tabPane.requestFocus();\n+                    tabPane.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTabbedPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -585,1 +585,1 @@\n-                component.requestFocusInWindow();\n+                component.requestFocusInWindow(FocusEvent.Cause.MOUSE_EVENT);\n@@ -588,1 +588,1 @@\n-                component.requestFocus();\n+                component.requestFocus(FocusEvent.Cause.MOUSE_EVENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultCaret.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1886,0 +1886,5 @@\n+    \/**\n+     * Checks if the system is running Linux with the Wayland server.\n+     *\n+     * @return true if running on Wayland, false otherwise\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#if !defined(AIX)\n+#if !defined(AIX) || defined(AIX_XLC_GE_17)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.awt.Toolkit;\n@@ -395,0 +396,34 @@\n+    \/**\n+     * Our X11 code expects the drop target window to be a top level window\n+     * and to have the XA_WM_STATE property.\n+     * This is not true when performing drag and drop from XWayland\n+     * to a native Wayland application.\n+     * In this case XWayland creates a dummy window with only one property,\n+     * XdndAware.\n+     *\n+     * @param window to test\n+     * @return true if window has XdndAware property when running under Wayland\n+     *\/\n+    private static boolean isXWaylandDndAwareWindow(long window) {\n+        Toolkit toolkit = Toolkit.getDefaultToolkit();\n+        if (!(toolkit instanceof SunToolkit)\n+                || !((SunToolkit) toolkit).isRunningOnWayland()) {\n+            return false;\n+        }\n+\n+        WindowPropertyGetter wpg =\n+            new WindowPropertyGetter(window, XDnDConstants.XA_XdndAware, 0, 1,\n+                                     false, XConstants.AnyPropertyType);\n+\n+        try {\n+            int status =\n+                wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());\n+\n+            return status == XConstants.Success\n+                   && wpg.getData() != 0\n+                   && wpg.getActualType() == XAtom.XA_ATOM;\n+        } finally {\n+            wpg.dispose();\n+        }\n+    }\n+\n@@ -403,0 +438,4 @@\n+        if (isXWaylandDndAwareWindow(window)) {\n+            return window;\n+        }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDragSourceContextPeer.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import sun.awt.screencast.ScreencastHelper;\n@@ -44,0 +45,4 @@\n+    private static final String screenshotMethod;\n+    private static final String METHOD_X11 = \"x11\";\n+    private static final String METHOD_SCREENCAST = \"dbusScreencast\";\n+\n@@ -46,0 +51,1 @@\n+\n@@ -47,3 +53,18 @@\n-                            AccessController.doPrivileged(\n-                                    new GetPropertyAction(\"awt.robot.gtk\", \"true\")\n-                            ));\n+                     AccessController.doPrivileged(\n+                             new GetPropertyAction(\"awt.robot.gtk\",\n+                                     \"true\")\n+                     ));\n+\n+        boolean isOnWayland = false;\n+\n+        if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+            isOnWayland = sunToolkit.isRunningOnWayland();\n+        }\n+\n+        screenshotMethod = AccessController.doPrivileged(\n+                new GetPropertyAction(\n+                        \"awt.robot.screenshotMethod\",\n+                        isOnWayland\n+                            ? METHOD_SCREENCAST\n+                            : METHOD_X11\n+                ));\n@@ -51,0 +72,1 @@\n+\n@@ -52,1 +74,1 @@\n-    private final X11GraphicsConfig  xgc;\n+    private final X11GraphicsConfig xgc;\n@@ -103,1 +125,7 @@\n-        getRGBPixelsImpl(xgc, x, y, 1, 1, pixelArray, useGtk);\n+        if (screenshotMethod.equals(METHOD_SCREENCAST)\n+            && ScreencastHelper.isAvailable()) {\n+\n+            ScreencastHelper.getRGBPixels(x, y, 1, 1, pixelArray);\n+        } else {\n+            getRGBPixelsImpl(xgc, x, y, 1, 1, pixelArray, useGtk);\n+        }\n@@ -108,4 +136,14 @@\n-    public int [] getRGBPixels(Rectangle bounds) {\n-        int[] pixelArray = new int[bounds.width*bounds.height];\n-        getRGBPixelsImpl(xgc, bounds.x, bounds.y, bounds.width, bounds.height,\n-                            pixelArray, useGtk);\n+    public int[] getRGBPixels(Rectangle bounds) {\n+        int[] pixelArray = new int[bounds.width * bounds.height];\n+        if (screenshotMethod.equals(METHOD_SCREENCAST)\n+            && ScreencastHelper.isAvailable()) {\n+\n+            ScreencastHelper.getRGBPixels(bounds.x, bounds.y,\n+                                          bounds.width, bounds.height,\n+                                          pixelArray);\n+        } else {\n+            getRGBPixelsImpl(xgc,\n+                             bounds.x, bounds.y,\n+                             bounds.width, bounds.height,\n+                             pixelArray, useGtk);\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XRobotPeer.java","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -890,8 +890,10 @@\n-        final X11GraphicsDevice device = (X11GraphicsDevice) gc.getDevice();\n-        Insets insets = device.getInsets();\n-        if (insets == null) {\n-            synchronized (device) {\n-                insets = device.getInsets();\n-                if (insets == null) {\n-                    insets = getScreenInsetsImpl(gc);\n-                    device.setInsets(insets);\n+        final GraphicsDevice gd = gc.getDevice();\n+        if (gd instanceof X11GraphicsDevice x11Device) {\n+            Insets insets = x11Device.getInsets();\n+            if (insets == null) {\n+                synchronized (x11Device) {\n+                    insets = x11Device.getInsets();\n+                    if (insets == null) {\n+                        insets = getScreenInsetsImpl(gc);\n+                        x11Device.setInsets(insets);\n+                    }\n@@ -900,0 +902,3 @@\n+            return (Insets) insets.clone();\n+        } else {\n+            return super.getScreenInsets(gc);\n@@ -901,1 +906,0 @@\n-        return (Insets) insets.clone();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.awt.screencast;\n+\n+import sun.awt.UNIXToolkit;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.security.AccessController;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Helper class for grabbing pixels from the screen using the\n+ * <a href=\"https:\/\/flatpak.github.io\/xdg-desktop-portal\/#gdbus-org.freedesktop.portal.ScreenCast\">\n+ * org.freedesktop.portal.ScreenCast API<\/a>\n+ *\/\n+\n+@SuppressWarnings(\"removal\")\n+public class ScreencastHelper {\n+\n+    static final boolean SCREENCAST_DEBUG;\n+    private static final boolean IS_NATIVE_LOADED;\n+\n+\n+    private static final int ERROR = -1;\n+    private static final int DENIED = -11;\n+    private static final int OUT_OF_BOUNDS = -12;\n+\n+    private ScreencastHelper() {\n+    }\n+\n+    static {\n+        SCREENCAST_DEBUG = Boolean.parseBoolean(\n+                               AccessController.doPrivileged(\n+                                       new GetPropertyAction(\n+                                               \"awt.robot.screenshotDebug\",\n+                                               \"false\"\n+                                       )\n+                               ));\n+\n+        boolean loadFailed = false;\n+\n+        if (!(Toolkit.getDefaultToolkit() instanceof UNIXToolkit tk\n+              && tk.loadGTK())\n+              || !loadPipewire(SCREENCAST_DEBUG)) {\n+\n+            System.err.println(\n+                    \"Could not load native libraries for ScreencastHelper\"\n+            );\n+\n+            loadFailed = true;\n+        }\n+\n+        IS_NATIVE_LOADED = !loadFailed;\n+    }\n+\n+    public static boolean isAvailable() {\n+        return IS_NATIVE_LOADED;\n+    }\n+\n+    private static native boolean loadPipewire(boolean screencastDebug);\n+\n+    private static native int getRGBPixelsImpl(\n+            int x, int y, int width, int height,\n+            int[] pixelArray,\n+            int[] affectedScreensBoundsArray,\n+            String token\n+    );\n+\n+    private static List<Rectangle> getSystemScreensBounds() {\n+        return Arrays\n+                .stream(GraphicsEnvironment\n+                        .getLocalGraphicsEnvironment()\n+                        .getScreenDevices())\n+                .map(graphicsDevice ->\n+                        graphicsDevice.getDefaultConfiguration().getBounds()\n+                ).toList();\n+    }\n+\n+    public static synchronized void getRGBPixels(\n+            int x, int y, int width, int height, int[] pixelArray\n+    ) {\n+        if (!IS_NATIVE_LOADED) return;\n+\n+        Rectangle captureArea = new Rectangle(x, y, width, height);\n+\n+        List<Rectangle> affectedScreenBounds = getSystemScreensBounds()\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .toList();\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"\/\/ getRGBPixels in %s, affectedScreenBounds %s\\n\",\n+                    captureArea, affectedScreenBounds);\n+        }\n+\n+        if (affectedScreenBounds.isEmpty()) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getRGBPixels - requested area \"\n+                        + \"outside of any screen\");\n+            }\n+            return;\n+        }\n+\n+        int retVal;\n+        Set<TokenItem> tokensForRectangle =\n+                TokenStorage.getTokens(affectedScreenBounds);\n+\n+        int[] affectedScreenBoundsArray = affectedScreenBounds\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .flatMapToInt(bounds -> IntStream.of(\n+                        bounds.x, bounds.y,\n+                        bounds.width, bounds.height\n+                ))\n+                .toArray();\n+\n+        for (TokenItem tokenItem : tokensForRectangle) {\n+            retVal = getRGBPixelsImpl(\n+                    x, y, width, height,\n+                    pixelArray,\n+                    affectedScreenBoundsArray,\n+                    tokenItem.token\n+            );\n+\n+            if (retVal >= 0) { \/\/ we have received a screen data\n+                return;\n+            } else if (!checkReturnValue(retVal)) {\n+                return;\n+            } \/\/ else, try other tokens\n+        }\n+\n+        \/\/ we do not have a saved token or it did not work,\n+        \/\/ try without the token to show the system's permission request window\n+        retVal = getRGBPixelsImpl(\n+                x, y, width, height,\n+                pixelArray,\n+                affectedScreenBoundsArray,\n+                null\n+        );\n+\n+        checkReturnValue(retVal);\n+    }\n+\n+    private static boolean checkReturnValue(int retVal) {\n+        if (retVal == DENIED) {\n+            \/\/ user explicitly denied the capture, no more tries.\n+            throw new SecurityException(\n+                    \"Screen Capture in the selected area was not allowed\"\n+            );\n+        } else if (retVal == ERROR) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(\"Screen capture failed.\");\n+            }\n+        } else if (retVal == OUT_OF_BOUNDS) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(\n+                        \"Token does not provide access to requested area.\");\n+            }\n+        }\n+        return retVal != ERROR;\n+    }\n+}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static sun.awt.screencast.ScreencastHelper.SCREENCAST_DEBUG;\n+\n+\/**\n+ * Helper class used by {@link TokenStorage} as restore token record\n+ * with its associated screen boundaries.\n+ *\n+ * It helps in serialization\/deserialization of screen boundaries\n+ * to\/from string format.\n+ *\n+ * The screen boundary is represented as {@code _x_y_width_height}\n+ * and can be repeated several times.\n+ *\/\n+final class TokenItem {\n+\n+    final String token;\n+    final List<Rectangle> allowedScreensBounds;\n+\n+    public TokenItem(String token, int[] allowedScreenBounds) {\n+        if (token == null || token.isBlank()) {\n+            throw new RuntimeException(\"empty or null tokens are not allowed\");\n+        }\n+        if (allowedScreenBounds.length % 4 != 0) {\n+            throw new RuntimeException(\"array with incorrect length provided\");\n+        }\n+\n+        this.token = token;\n+\n+        this.allowedScreensBounds = IntStream\n+                        .iterate(0,\n+                                i -> i < allowedScreenBounds.length,\n+                                i -> i + 4)\n+                        .mapToObj(i -> new Rectangle(\n+                                allowedScreenBounds[i], allowedScreenBounds[i+1],\n+                                allowedScreenBounds[i+2], allowedScreenBounds[i+3]\n+                        ))\n+                        .collect(Collectors.toList());\n+    }\n+\n+    public boolean hasAllScreensWithExactMatch(List<Rectangle> bounds) {\n+        return allowedScreensBounds.containsAll(bounds);\n+    }\n+\n+    public boolean hasAllScreensOfSameSize(List<Dimension> screenSizes) {\n+        \/\/ We also need to consider duplicates, since there may be\n+        \/\/ multiple screens of the same size.\n+        \/\/ The token item must also have at least the same number\n+        \/\/ of screens with that size.\n+\n+        List<Dimension> tokenSizes = allowedScreensBounds\n+                .stream()\n+                .map(bounds -> new Dimension(bounds.width, bounds.height))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+\n+        return screenSizes.size() == screenSizes\n+                .stream()\n+                .filter(tokenSizes::remove)\n+                .count();\n+    }\n+\n+    private static final int MAX_SIZE = 50000;\n+    private static final int MIN_SIZE = 1;\n+\n+    public boolean hasValidBounds() {\n+        \/\/This check is very rough, in order to filter out abnormal values\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            if (bounds.x < -MAX_SIZE || bounds.x > MAX_SIZE\n+                    || bounds.y < -MAX_SIZE || bounds.y > MAX_SIZE\n+                    || bounds.width < MIN_SIZE || bounds.width > MAX_SIZE\n+                    || bounds.height < MIN_SIZE || bounds.height > MAX_SIZE\n+            ) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String dump() {\n+        StringBuilder sb = new StringBuilder();\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            sb.append(\"_%d_%d_%d_%d\"\n+                    .formatted(bounds.x, bounds.y, bounds.width, bounds.height));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static TokenItem parse(String token, Object input) {\n+        if (token == null || input == null) return null;\n+\n+        try {\n+            int[] integers = Arrays.stream(String.valueOf(input)\n+                    .split(\"_\"))\n+                    .filter(s -> !s.isBlank())\n+                    .mapToInt(Integer::parseInt)\n+                    .toArray();\n+\n+            if (integers.length % 4 == 0) {\n+                TokenItem tokenItem = new TokenItem(token, integers);\n+                if (tokenItem.hasValidBounds()) {\n+                    return tokenItem;\n+                }\n+            }\n+        } catch (NumberFormatException ignored) {}\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.err.printf(\"Malformed record for token %s: %s\\n\",\n+                    token, input);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"Token: \" + token + \"\\n\");\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            sb.append(\"\\t\").append(bounds).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenItem.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+import static java.nio.file.StandardWatchEventKinds.OVERFLOW;\n+import static sun.awt.screencast.ScreencastHelper.SCREENCAST_DEBUG;\n+\n+\/**\n+ * Helper class for persistent storage of ScreenCast restore tokens\n+ * and associated screen boundaries.\n+ *\n+ * The restore token allows the ScreenCast session to be restored\n+ * with previously granted screen access permissions.\n+ *\/\n+final class TokenStorage {\n+\n+    private TokenStorage() {}\n+\n+    private static final String REL_NAME =\n+            \".awt\/robot\/screencast-tokens.properties\";\n+\n+    private static final Properties PROPS = new Properties();\n+    private static final Path PROPS_PATH;\n+    private static final Path PROP_FILENAME;\n+\n+    static {\n+        PROPS_PATH = setupPath();\n+        if (PROPS_PATH != null) {\n+            PROP_FILENAME = PROPS_PATH.getFileName();\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"Token storage: using \" + PROPS_PATH);\n+            }\n+            setupWatch();\n+        } else {\n+            \/\/ We can still work with tokens,\n+            \/\/ but they are not saved between sessions.\n+            PROP_FILENAME = null;\n+        }\n+    }\n+\n+    private static Path setupPath() {\n+        String userHome = System.getProperty(\"user.home\", null);\n+        if (userHome == null) {\n+            return null;\n+        }\n+\n+        Path path = Path.of(userHome, REL_NAME);\n+        Path workdir = path.getParent();\n+\n+        if (!Files.exists(workdir)) {\n+            try {\n+                Files.createDirectories(workdir);\n+            } catch (Exception e) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: cannot create\" +\n+                                    \" directory %s %s\\n\", workdir, e);\n+                }\n+                return null;\n+            }\n+        }\n+\n+        if (!Files.isWritable(workdir)) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+            }\n+            return null;\n+        }\n+\n+        try {\n+            Files.setPosixFilePermissions(\n+                    workdir,\n+                    Set.of(PosixFilePermission.OWNER_READ,\n+                           PosixFilePermission.OWNER_WRITE,\n+                           PosixFilePermission.OWNER_EXECUTE)\n+            );\n+        } catch (IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: cannot set permissions \" +\n+                        \"for directory %s %s\\n\", workdir, e);\n+            }\n+        }\n+\n+        if (Files.exists(path)) {\n+            if (!setFilePermission(path)) {\n+                return null;\n+            }\n+\n+            readTokens(path);\n+        }\n+\n+        return path;\n+    }\n+\n+    private static boolean setFilePermission(Path path) {\n+        try {\n+            Files.setPosixFilePermissions(\n+                    path,\n+                    Set.of(PosixFilePermission.OWNER_READ,\n+                           PosixFilePermission.OWNER_WRITE)\n+            );\n+            return true;\n+        } catch (IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: failed to set \" +\n+                        \"property file permission %s %s\\n\", path, e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static class WatcherThread extends Thread {\n+        private final WatchService watcher;\n+\n+        public WatcherThread(WatchService watchService) {\n+            this.watcher = watchService;\n+            setName(\"ScreencastWatcher\");\n+            setDaemon(true);\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"ScreencastWatcher: started\");\n+            }\n+            for (;;) {\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException e) {\n+                    if (SCREENCAST_DEBUG) {\n+                        System.err.println(\"ScreencastWatcher: interrupted\");\n+                    }\n+                    return;\n+                }\n+\n+                for (WatchEvent<?> event: key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+                    if (kind == OVERFLOW\n+                            || !event.context().equals(PROP_FILENAME)) {\n+                        continue;\n+                    }\n+\n+                    if (SCREENCAST_DEBUG) {\n+                        System.out.printf(\"ScreencastWatcher: %s %s\\n\",\n+                                kind, event.context());\n+                    }\n+\n+                    if (kind == ENTRY_CREATE) {\n+                        setFilePermission(PROPS_PATH);\n+                    } else if (kind == ENTRY_MODIFY) {\n+                        readTokens(PROPS_PATH);\n+                    } else if (kind == ENTRY_DELETE) {\n+                        synchronized (PROPS) {\n+                            PROPS.clear();\n+                        }\n+                    }\n+                }\n+\n+                key.reset();\n+            }\n+        }\n+    }\n+\n+    private static void setupWatch() {\n+        try {\n+            WatchService watchService =\n+                    FileSystems.getDefault().newWatchService();\n+\n+            PROPS_PATH\n+                    .getParent()\n+                    .register(watchService,\n+                            ENTRY_CREATE,\n+                            ENTRY_DELETE,\n+                            ENTRY_MODIFY);\n+\n+            new WatcherThread(watchService).start();\n+        } catch (Exception e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: failed to setup \" +\n+                        \"file watch %s\\n\", e);\n+            }\n+        }\n+    }\n+\n+    \/\/ called from native\n+    private static void storeTokenFromNative(String oldToken,\n+                                             String newToken,\n+                                             int[] allowedScreenBounds) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"\/\/ storeToken old: |%s| new |%s| \" +\n+                            \"allowed bounds %s\\n\",\n+                    oldToken, newToken,\n+                    Arrays.toString(allowedScreenBounds));\n+        }\n+\n+        if (allowedScreenBounds == null) return;\n+\n+        TokenItem tokenItem = new TokenItem(newToken, allowedScreenBounds);\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"\/\/ Storing TokenItem:\\n%s\\n\", tokenItem);\n+        }\n+\n+        synchronized (PROPS) {\n+            String oldBoundsRecord = PROPS.getProperty(tokenItem.token, null);\n+            String newBoundsRecord = tokenItem.dump();\n+\n+            boolean changed = false;\n+\n+            if (oldBoundsRecord == null\n+                    || !oldBoundsRecord.equals(newBoundsRecord)) {\n+                PROPS.setProperty(tokenItem.token, newBoundsRecord);\n+                if (SCREENCAST_DEBUG) {\n+                    System.out.printf(\n+                            \"\/\/ Writing new TokenItem:\\n%s\\n\", tokenItem);\n+                }\n+                changed = true;\n+            }\n+\n+            if (oldToken != null && !oldToken.equals(newToken)) {\n+                \/\/ old token is no longer valid\n+                if (SCREENCAST_DEBUG) {\n+                    System.out.printf(\n+                            \"\/\/ storeTokenFromNative old token |%s| is \"\n+                                    + \"no longer valid, removing\\n\", oldToken);\n+                }\n+\n+                PROPS.remove(oldToken);\n+                changed = true;\n+            }\n+\n+            if (changed) {\n+                store(\"save tokens\");\n+            }\n+        }\n+    }\n+\n+    private static boolean readTokens(Path path) {\n+        if (path == null) return false;\n+\n+        try (BufferedReader reader = Files.newBufferedReader(path)) {\n+            synchronized (PROPS) {\n+                PROPS.clear();\n+                PROPS.load(reader);\n+            }\n+        } catch (IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"\"\"\n+                        Token storage: failed to load property file %s\n+                        %s\n+                        \"\"\", path, e);\n+            }\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+        \/\/ We need an ordered set to store tokens\n+        \/\/ with exact matches at the beginning.\n+        LinkedHashSet<TokenItem> result = new LinkedHashSet<>();\n+\n+        Set<String> malformed = new HashSet<>();\n+        List<TokenItem> allTokenItems;\n+\n+        synchronized (PROPS) {\n+            allTokenItems =\n+                    PROPS.entrySet()\n+                    .stream()\n+                    .map(o -> {\n+                        String token = String.valueOf(o.getKey());\n+                        TokenItem tokenItem =\n+                                TokenItem.parse(token, o.getValue());\n+                        if (tokenItem == null) {\n+                            malformed.add(token);\n+                        }\n+                        return tokenItem;\n+                    })\n+                    .filter(Objects::nonNull)\n+                    .toList();\n+        }\n+\n+        removeMalformedRecords(malformed);\n+\n+        \/\/ 1. Try to find exact matches\n+        for (TokenItem tokenItem : allTokenItems) {\n+            if (tokenItem != null\n+                && tokenItem.hasAllScreensWithExactMatch(affectedScreenBounds)) {\n+\n+                result.add(tokenItem);\n+            }\n+        }\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getTokens exact matches 1. \" + result);\n+        }\n+\n+        \/\/ 2. Try screens of the same size but in different locations,\n+        \/\/ screens may have been moved while the token is still valid\n+        List<Dimension> dimensions =\n+                affectedScreenBounds\n+                .stream()\n+                .map(rectangle -> new Dimension(\n+                        rectangle.width,\n+                        rectangle.height\n+                ))\n+                .toList();\n+\n+        for (TokenItem tokenItem : allTokenItems) {\n+            if (tokenItem != null\n+                && tokenItem.hasAllScreensOfSameSize(dimensions)) {\n+\n+                result.add(tokenItem);\n+            }\n+        }\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getTokens same sizes 2. \" + result);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static void removeMalformedRecords(Set<String> malformedRecords) {\n+        if (!isWritable()\n+            || malformedRecords == null\n+            || malformedRecords.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (PROPS) {\n+            for (String token : malformedRecords) {\n+                Object remove = PROPS.remove(token);\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.println(\"removing malformed record\\n\" + remove);\n+                }\n+            }\n+\n+            store(\"remove malformed records\");\n+        }\n+    }\n+\n+    private static void store(String failMsg) {\n+        if (!isWritable()) {\n+            return;\n+        }\n+\n+        synchronized (PROPS) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(PROPS_PATH)) {\n+                PROPS.store(writer, null);\n+            } catch (IOException e) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\n+                            \"Token storage: unable to %s\\n%s\\n\", failMsg, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isWritable() {\n+        if (PROPS_PATH == null\n+            || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n+\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\n+                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n+            }\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+## PipeWire 0.3.68\n+\n+### PipeWire license:\n+\n+All PipeWire header files are licensed under the MIT License:\n+\n+\n+<pre>\n+Copyright  2018-2023 Wim Taymans\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the\n+Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice (including the next\n+paragraph) shall be included in all copies or substantial portions of the\n+Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE.\n+<\/pre>\n+\n+The below copyright applies to the following files:\n+\n+spa\/include\/spa\/monitor\/type-info.h\n+```\n+Copyright  2021 Collabora Ltd.\n+```\n+\n+spa\/include\/spa\/utils\/string.h\n+```\n+Copyright  2021 Red Hat, Inc.\n+```\n","filename":"src\/java.desktop\/unix\/legal\/pipewire.md","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+#ifndef _FP_PIPEWIRE_H\n+#define _FP_PIPEWIRE_H\n+\n+\n+struct pw_buffer *(*fp_pw_stream_dequeue_buffer)(struct pw_stream *stream);\n+const char * (*fp_pw_stream_state_as_string)(enum pw_stream_state state);\n+int (*fp_pw_stream_queue_buffer)(struct pw_stream *stream,\n+                                 struct pw_buffer *buffer);\n+int (*fp_pw_stream_set_active)(struct pw_stream *stream, bool active);\n+\n+int (*fp_pw_stream_connect)(\n+        struct pw_stream *stream,\n+        enum pw_direction direction,\n+        uint32_t target_id,\n+        enum pw_stream_flags flags,\n+        const struct spa_pod **params,\n+        uint32_t n_params);\n+\n+struct pw_stream *(*fp_pw_stream_new)(\n+        struct pw_core *core,\n+        const char *name,\n+        struct pw_properties *props\n+);\n+void (*fp_pw_stream_add_listener)(struct pw_stream *stream,\n+                            struct spa_hook *listener,\n+                            const struct pw_stream_events *events,\n+                            void *data);\n+int (*fp_pw_stream_disconnect)(struct pw_stream *stream);\n+void (*fp_pw_stream_destroy)(struct pw_stream *stream);\n+\n+\n+void (*fp_pw_init)(int *argc, char **argv[]);\n+\n+\n+struct pw_core *\n+(*fp_pw_context_connect_fd)(struct pw_context *context,\n+                      int fd,\n+                      struct pw_properties *properties,\n+                      size_t user_data_size);\n+\n+int (*fp_pw_core_disconnect)(struct pw_core *core);\n+\n+struct pw_context * (*fp_pw_context_new)(struct pw_loop *main_loop,\n+                                   struct pw_properties *props,\n+                                   size_t user_data_size);\n+\n+struct pw_thread_loop *\n+(*fp_pw_thread_loop_new)(const char *name, const struct spa_dict *props);\n+struct pw_loop * (*fp_pw_thread_loop_get_loop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_signal)(struct pw_thread_loop *loop,\n+                                 bool wait_for_accept);\n+void (*fp_pw_thread_loop_wait)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_accept)(struct pw_thread_loop *loop);\n+int (*fp_pw_thread_loop_start)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_stop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_destroy)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_lock)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_unlock)(struct pw_thread_loop *loop);\n+\n+struct pw_properties * (*fp_pw_properties_new)(const char *key, ...);\n+\n+\n+#endif \/\/_FP_PIPEWIRE_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/fp_pipewire.h","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,7 +89,0 @@\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GdkRectangle;\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,4 @@\n+static void transform_detail_string (const gchar *detail,\n+                                     GtkStyleContext *context);\n+static void gtk3_init(GtkApi* gtk);\n+\n@@ -249,0 +253,1 @@\n+gboolean glib_version_2_68 = FALSE;\n@@ -570,0 +575,44 @@\n+\n+        \/**\n+         * other\n+         *\/\n+\n+        fp_g_bus_get_sync = dl_symbol(\"g_bus_get_sync\");\n+        fp_g_dbus_proxy_call_sync = dl_symbol(\"g_dbus_proxy_call_sync\");\n+        fp_g_dbus_proxy_new_sync = dl_symbol(\"g_dbus_proxy_new_sync\");\n+        fp_g_dbus_connection_get_unique_name = dl_symbol(\"g_dbus_connection_get_unique_name\");\n+        fp_g_dbus_connection_call_sync = dl_symbol(\"g_dbus_connection_call_sync\");\n+        fp_g_dbus_connection_signal_subscribe = dl_symbol(\"g_dbus_connection_signal_subscribe\");\n+        fp_g_dbus_connection_signal_unsubscribe = dl_symbol(\"g_dbus_connection_signal_unsubscribe\");\n+        fp_g_dbus_proxy_call_with_unix_fd_list_sync = dl_symbol(\"g_dbus_proxy_call_with_unix_fd_list_sync\");\n+\n+        fp_g_variant_builder_init = dl_symbol(\"g_variant_builder_init\");\n+        fp_g_variant_builder_add = dl_symbol(\"g_variant_builder_add\");\n+        fp_g_variant_new = dl_symbol(\"g_variant_new\");\n+        fp_g_variant_new_string = dl_symbol(\"g_variant_new_string\");\n+        fp_g_variant_new_uint32 = dl_symbol(\"g_variant_new_uint32\");\n+        fp_g_variant_new_boolean = dl_symbol(\"g_variant_new_boolean\");\n+        fp_g_variant_get = dl_symbol(\"g_variant_get\");\n+        fp_g_variant_get_string = dl_symbol(\"g_variant_get_string\");\n+        fp_g_variant_get_uint32 = dl_symbol(\"g_variant_get_uint32\");\n+        fp_g_variant_iter_loop = dl_symbol(\"g_variant_iter_loop\");\n+        fp_g_variant_unref = dl_symbol(\"g_variant_unref\");\n+        fp_g_variant_lookup = dl_symbol(\"g_variant_lookup\");\n+        fp_g_variant_lookup_value = dl_symbol(\"g_variant_lookup_value\");\n+        fp_g_variant_iter_init = dl_symbol(\"g_variant_iter_init\");\n+        fp_g_variant_iter_n_children = dl_symbol(\"g_variant_iter_n_children\");\n+\n+        fp_g_string_new = dl_symbol(\"g_string_new\");\n+        fp_g_string_erase = dl_symbol(\"g_string_erase\");\n+        fp_g_string_free = dl_symbol(\"g_string_free\");\n+\n+        glib_version_2_68 = !fp_glib_check_version(2, 68, 0);\n+        if (glib_version_2_68) {\n+            fp_g_string_replace = dl_symbol(\"g_string_replace\"); \/\/since: 2.68\n+            fp_g_uuid_string_is_valid = \/\/since: 2.52\n+                    dl_symbol(\"g_uuid_string_is_valid\");\n+        }\n+        fp_g_string_printf = dl_symbol(\"g_string_printf\");\n+\n+        fp_g_error_free = dl_symbol(\"g_error_free\");\n+        fp_g_unix_fd_list_get = dl_symbol(\"g_unix_fd_list_get\");\n@@ -3030,0 +3079,42 @@\n+\n+    gtk->g_bus_get_sync = fp_g_bus_get_sync;\n+    gtk->g_dbus_proxy_call_sync = fp_g_dbus_proxy_call_sync;\n+    gtk->g_dbus_proxy_new_sync = fp_g_dbus_proxy_new_sync;\n+    gtk->g_dbus_connection_get_unique_name = fp_g_dbus_connection_get_unique_name;\n+    gtk->g_dbus_connection_signal_subscribe = fp_g_dbus_connection_signal_subscribe;\n+    gtk->g_dbus_connection_signal_unsubscribe = fp_g_dbus_connection_signal_unsubscribe;\n+    gtk->g_dbus_proxy_call_with_unix_fd_list_sync = fp_g_dbus_proxy_call_with_unix_fd_list_sync;\n+    gtk->g_dbus_connection_call_sync = fp_g_dbus_connection_call_sync;\n+\n+    gtk->g_variant_new = fp_g_variant_new;\n+    gtk->g_variant_new_string = fp_g_variant_new_string;\n+    gtk->g_variant_new_boolean = fp_g_variant_new_boolean;\n+    gtk->g_variant_new_uint32 = fp_g_variant_new_uint32;\n+\n+    gtk->g_variant_get = fp_g_variant_get;\n+    gtk->g_variant_get_string = fp_g_variant_get_string;\n+    gtk->g_variant_get_uint32 = fp_g_variant_get_uint32;\n+\n+    gtk->g_variant_lookup = fp_g_variant_lookup;\n+\n+    gtk->g_variant_iter_loop = fp_g_variant_iter_loop;\n+\n+    gtk->g_variant_unref = fp_g_variant_unref;\n+\n+    gtk->g_variant_builder_init = fp_g_variant_builder_init;\n+    gtk->g_variant_builder_add = fp_g_variant_builder_add;\n+\n+    gtk->g_variant_lookup_value = fp_g_variant_lookup_value;\n+    gtk->g_variant_iter_init = fp_g_variant_iter_init;\n+    gtk->g_variant_iter_n_children = fp_g_variant_iter_n_children;\n+\n+    gtk->g_string_new = fp_g_string_new;\n+    gtk->g_string_erase = fp_g_string_erase;\n+    gtk->g_string_free = fp_g_string_free;\n+    gtk->g_string_replace = fp_g_string_replace;\n+    gtk->g_string_printf = fp_g_string_printf;\n+    gtk->g_uuid_string_is_valid = fp_g_uuid_string_is_valid;\n+\n+    gtk->g_main_context_iteration = fp_g_main_context_iteration;\n+    gtk->g_error_free = fp_g_error_free;\n+    gtk->g_unix_fd_list_get = fp_g_unix_fd_list_get;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,7 +238,0 @@\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GdkRectangle;\n-\n@@ -378,1 +371,0 @@\n-static void gtk3_init(GtkApi* gtk);\n@@ -497,3 +489,2 @@\n-static void transform_detail_string (const gchar *detail,\n-                     GtkStyleContext *context);\n-void (*fp_gtk_style_context_set_junction_sides)(GtkStyleContext  *context,\n+\n+static void (*fp_gtk_style_context_set_junction_sides)(GtkStyleContext  *context,\n@@ -501,1 +492,1 @@\n-void (*fp_gtk_style_context_add_region)(GtkStyleContext *context,\n+static void (*fp_gtk_style_context_add_region)(GtkStyleContext *context,\n@@ -503,1 +494,1 @@\n-void (*fp_gtk_render_arrow)(GtkStyleContext *context, cairo_t *cr,\n+static void (*fp_gtk_render_arrow)(GtkStyleContext *context, cairo_t *cr,\n@@ -505,2 +496,2 @@\n-void (*fp_gtk_bin_set_child)(GtkBin *bin, GtkWidget *widget);\n-void (*fp_gtk_scrolled_window_set_shadow_type)(\n+static void (*fp_gtk_bin_set_child)(GtkBin *bin, GtkWidget *widget);\n+static void (*fp_gtk_scrolled_window_set_shadow_type)(\n@@ -525,1 +516,1 @@\n-                     gdouble page_increment);\n+                                                    gdouble page_increment);\n@@ -640,0 +631,152 @@\n+\n+\/\/ ---------- fp_g_dbus_* ----------\n+static GVariant *(*fp_g_dbus_proxy_call_sync)(\n+        GDBusProxy *proxy,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static GDBusProxy *(*fp_g_dbus_proxy_new_sync)(\n+        GDBusConnection *connection,\n+        GDBusProxyFlags flags,\n+        GDBusInterfaceInfo *info,\n+        const gchar *name,\n+        const gchar *object_path,\n+        const gchar *interface_name,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static const gchar *(*fp_g_dbus_connection_get_unique_name)(\n+        GDBusConnection *connection\n+);\n+\n+static GDBusConnection *(*fp_g_bus_get_sync)(GBusType bus_type,\n+                                             GCancellable *cancellable,\n+                                             GError **error);\n+\n+static guint (*fp_g_dbus_connection_signal_subscribe)(\n+        GDBusConnection *connection,\n+        const gchar *sender,\n+        const gchar *interface_name,\n+        const gchar *member,\n+        const gchar *object_path,\n+        const gchar *arg0,\n+        GDBusSignalFlags flags,\n+        GDBusSignalCallback callback,\n+        gpointer user_data,\n+        GDestroyNotify user_data_free_func\n+);\n+\n+static void (*fp_g_dbus_connection_signal_unsubscribe)(\n+        GDBusConnection *connection,\n+        guint subscription_id\n+);\n+\n+static GVariant *(*fp_g_dbus_proxy_call_with_unix_fd_list_sync)(\n+        GDBusProxy *proxy,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GUnixFDList *fd_list,\n+        GUnixFDList **out_fd_list,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static GVariant *(*fp_g_dbus_connection_call_sync)(\n+        GDBusConnection *connection,\n+        const gchar *bus_name,\n+        const gchar *object_path,\n+        const gchar *interface_name,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        const GVariantType *reply_type,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+\/\/ ---------- fp_g_variant_*  ----------\n+\n+static GVariant *(*fp_g_variant_new)(const gchar *format_string, ...);\n+\n+static GVariant *(*fp_g_variant_new_string)(const gchar *string);\n+\n+static GVariant *(*fp_g_variant_new_boolean)(gboolean value);\n+\n+static GVariant *(*fp_g_variant_new_uint32)(guint32 value);\n+\n+static void (*fp_g_variant_get)(GVariant *value,\n+                                const gchar *format_string,\n+                                ...);\n+\n+static const gchar *(*fp_g_variant_get_string)(GVariant *value,\n+                                               gsize *length);\n+\n+static guint32 (*fp_g_variant_get_uint32)(GVariant *value);\n+\n+static gboolean (*fp_g_variant_lookup)(GVariant *dictionary,\n+                                       const gchar *key,\n+                                       const gchar *format_string,\n+                                       ...);\n+\n+static gboolean (*fp_g_variant_iter_loop)(GVariantIter *iter,\n+                                          const gchar *format_string,\n+                                          ...);\n+\n+static void (*fp_g_variant_unref)(GVariant *value);\n+\n+static void (*fp_g_variant_builder_init)(GVariantBuilder *builder,\n+                                         const GVariantType *type);\n+\n+static void (*fp_g_variant_builder_add)(GVariantBuilder *builder,\n+                                        const gchar *format_string,\n+                                        ...);\n+\n+static GVariant *(*fp_g_variant_lookup_value)(GVariant *dictionary,\n+                                              const gchar *key,\n+                                              const GVariantType *expected_type);\n+\n+static gsize (*fp_g_variant_iter_init)(GVariantIter *iter,\n+                                       GVariant *value);\n+\n+static gsize (*fp_g_variant_iter_n_children)(GVariantIter *iter);\n+\n+\n+\/\/ ---------- fp_g_string_* ----------\n+\n+static GString *(*fp_g_string_new)(const gchar *init);\n+\n+static GString *(*fp_g_string_erase)(GString *string,\n+                                     gssize pos,\n+                                     gssize len);\n+\n+static gchar *(*fp_g_string_free)(GString *string,\n+                                  gboolean free_segment);\n+\n+static guint (*fp_g_string_replace)(GString *string,\n+                                    const gchar *find,\n+                                    const gchar *replace,\n+                                    guint limit);\n+\n+static void *(*fp_g_string_printf)(GString *string,\n+                                   const gchar *format,\n+                                   ...);\n+\n+static gboolean (*fp_g_uuid_string_is_valid)(const gchar *str);\n+\n+\n+\/\/ ---------- * ----------\n+static void (*fp_g_error_free)(GError *error);\n+\n+static gint (*fp_g_unix_fd_list_get)(GUnixFDList *list,\n+                                     gint index_,\n+                                     GError **error);\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":160,"deletions":17,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-typedef unsigned int   gsize;\n+typedef unsigned long   gsize;\n@@ -131,0 +131,87 @@\n+typedef signed long gssize;\n+typedef struct _GString         GString;\n+\n+struct _GString\n+{\n+    gchar  *str;\n+    gsize len;\n+    gsize allocated_len;\n+};\n+\n+typedef struct _GVariant                      GVariant;\n+typedef struct _GVariantIter GVariantIter;\n+struct _GVariantIter {\n+    \/*< private >*\/\n+    gsize x[16];\n+};\n+\n+typedef struct _GVariantType GVariantType;\n+typedef struct _GVariantBuilder GVariantBuilder;\n+\n+struct _GVariantBuilder {\n+    \/*< private >*\/\n+    union\n+    {\n+        struct {\n+            gsize partial_magic;\n+            const GVariantType *type;\n+            gsize y[14];\n+        } s;\n+        gsize x[16];\n+    } u;\n+};\n+\n+\n+#define G_VARIANT_TYPE_VARDICT              ((const GVariantType *) \"a{sv}\")\n+#define G_VARIANT_TYPE_ARRAY                ((const GVariantType *) \"a*\")\n+#define G_VARIANT_TYPE_STRING               ((const GVariantType *) \"s\")\n+\n+typedef struct _GDBusProxy                    GDBusProxy;\n+typedef enum {\n+    G_DBUS_CALL_FLAGS_NONE = 0,\n+    G_DBUS_CALL_FLAGS_NO_AUTO_START = (1<<0),\n+    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<1)\n+} GDBusCallFlags;\n+\n+typedef void GMainContext;\n+typedef void GUnixFDList;\n+\n+typedef void GDBusConnection;\n+typedef enum \/*< flags >*\/\n+{\n+    G_DBUS_SIGNAL_FLAGS_NONE = 0,\n+    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = (1<<0),\n+    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = (1<<1),\n+    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = (1<<2)\n+} GDBusSignalFlags;\n+\n+typedef void (*GDBusSignalCallback) (GDBusConnection  *connection,\n+                                     const gchar      *sender_name,\n+                                     const gchar      *object_path,\n+                                     const gchar      *interface_name,\n+                                     const gchar      *signal_name,\n+                                     GVariant         *parameters,\n+                                     gpointer          user_data);\n+\n+typedef struct _GCancellable                  GCancellable;\n+\n+typedef enum\n+{\n+    G_BUS_TYPE_STARTER = -1,\n+    G_BUS_TYPE_NONE = 0,\n+    G_BUS_TYPE_SYSTEM  = 1,\n+    G_BUS_TYPE_SESSION = 2\n+} GBusType;\n+\n+typedef enum\n+{\n+    G_DBUS_PROXY_FLAGS_NONE = 0,\n+    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = (1<<0),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = (1<<1),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = (1<<2),\n+    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = (1<<3),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = (1<<4)\n+} GDBusProxyFlags;\n+\n+typedef struct _GDBusInterfaceInfo            GDBusInterfaceInfo;\n+\n@@ -412,0 +499,8 @@\n+typedef guint32 GQuark;\n+struct _GError\n+{\n+    GQuark       domain;\n+    gint         code;\n+    gchar       *message;\n+};\n+typedef struct _GError GError;\n@@ -413,1 +508,0 @@\n-typedef void GError;\n@@ -420,0 +514,8 @@\n+\n+typedef struct {\n+    gint x;\n+    gint y;\n+    gint width;\n+    gint height;\n+} GdkRectangle;\n+\n@@ -516,1 +618,0 @@\n-\n@@ -561,0 +662,135 @@\n+\n+\n+    \/* <for screencast, used only with GTK3>  *\/\n+    GVariant *(*g_dbus_proxy_call_sync)(\n+            GDBusProxy *proxy,\n+            const gchar *method_name,\n+            GVariant *parameters,\n+            GDBusCallFlags flags,\n+            gint timeout_msec,\n+            GCancellable *cancellable,\n+            GError **error);\n+\n+    GVariant *(*g_variant_new)(const gchar *format_string, ...);\n+    GVariant *(*g_variant_new_string)(const gchar *string);\n+    GVariant *(*g_variant_new_boolean)(gboolean value);\n+    GVariant *(*g_variant_new_uint32)(guint32 value);\n+\n+\n+    void (*g_variant_get)(GVariant *value,\n+                                    const gchar *format_string,\n+                                    ...);\n+    const gchar *(*g_variant_get_string)(GVariant *value, gsize *length);\n+    guint32 (*g_variant_get_uint32)(GVariant *value);\n+\n+    gboolean (*g_variant_lookup)(GVariant *dictionary,\n+                                           const gchar *key,\n+                                           const gchar *format_string,\n+                                           ...);\n+    gboolean (*g_variant_iter_loop)(GVariantIter *iter,\n+                                              const gchar *format_string,\n+                                              ...);\n+\n+    void (*g_variant_unref)(GVariant             *value);\n+\n+    void (*g_variant_builder_init)(GVariantBuilder *builder, \/\/+\n+                                             const GVariantType *type);\n+\n+    void (*g_variant_builder_add)(GVariantBuilder *builder, \/\/+\n+                                            const gchar *format_string,\n+                                            ...);\n+\n+    GVariant *(*g_variant_lookup_value)(GVariant *dictionary,\n+                                                  const gchar *key,\n+                                                  const GVariantType *expected_type);\n+\n+    gsize (*g_variant_iter_init)(GVariantIter *iter,\n+                                           GVariant *value);\n+\n+    gsize (*g_variant_iter_n_children)(GVariantIter *iter);\n+\n+\n+    GString *(*g_string_new)(const gchar *init);\n+\n+    GString *(*g_string_erase)(GString *string,\n+                               gssize pos,\n+                               gssize len);\n+\n+    gchar *(*g_string_free)(GString *string,\n+                            gboolean free_segment);\n+\n+    guint (*g_string_replace)(GString *string,\n+                              const gchar *find,\n+                              const gchar *replace,\n+                              guint limit);\n+\n+    void *(*g_string_printf)(GString *string,\n+                             const gchar *format,\n+                             ...);\n+\n+    gboolean (*g_uuid_string_is_valid)(const gchar *str);\n+\n+\n+    GDBusConnection *(*g_bus_get_sync)(GBusType bus_type,\n+                                       GCancellable *cancellable,\n+                                       GError **error);\n+\n+    GDBusProxy *(*g_dbus_proxy_new_sync)(GDBusConnection *connection,\n+                                                   GDBusProxyFlags flags,\n+                                                   GDBusInterfaceInfo *info,\n+                                                   const gchar *name,\n+                                                   const gchar *object_path,\n+                                                   const gchar *interface_name,\n+                                                   GCancellable *cancellable,\n+                                                   GError **error);\n+\n+    const gchar *(*g_dbus_connection_get_unique_name)(GDBusConnection *connection);\n+\n+\n+\n+    guint (*g_dbus_connection_signal_subscribe)(GDBusConnection *connection,\n+                                                          const gchar *sender,\n+                                                          const gchar *interface_name,\n+                                                          const gchar *member,\n+                                                          const gchar *object_path,\n+                                                          const gchar *arg0,\n+                                                          GDBusSignalFlags flags,\n+                                                          GDBusSignalCallback callback,\n+                                                          gpointer user_data,\n+                                                          GDestroyNotify user_data_free_func);\n+\n+    void (*g_dbus_connection_signal_unsubscribe)(GDBusConnection *connection,\n+                                                           guint subscription_id);\n+\n+    GVariant *(*g_dbus_proxy_call_with_unix_fd_list_sync)(GDBusProxy *proxy,\n+                                                                    const gchar *method_name,\n+                                                                    GVariant *parameters,\n+                                                                    GDBusCallFlags flags,\n+                                                                    gint timeout_msec,\n+                                                                    GUnixFDList *fd_list,\n+                                                                    GUnixFDList **out_fd_list,\n+                                                                    GCancellable *cancellable,\n+                                                                    GError **error);\n+\n+    GVariant *(*g_dbus_connection_call_sync)(GDBusConnection *connection,\n+                                                       const gchar *bus_name,\n+                                                       const gchar *object_path,\n+                                                       const gchar *interface_name,\n+                                                       const gchar *method_name,\n+                                                       GVariant *parameters,\n+                                                       const GVariantType *reply_type,\n+                                                       GDBusCallFlags flags,\n+                                                       gint timeout_msec,\n+                                                       GCancellable *cancellable,\n+                                                       GError **error);\n+\n+    gboolean (*g_main_context_iteration)(GMainContext *context,\n+                                         gboolean may_block);\n+\n+    void (*g_error_free)(GError *error);\n+\n+    gint (*g_unix_fd_list_get)(GUnixFDList *list,\n+                               gint index_,\n+                               GError **error);\n+\n+    \/* <\/for screencast, used only with GTK3>  *\/\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.h","additions":240,"deletions":4,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -0,0 +1,897 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+#include <dlfcn.h>\n+#include \"jni_util.h\"\n+#include \"awt.h\"\n+#include \"screencast_pipewire.h\"\n+#include \"fp_pipewire.h\"\n+#include <stdio.h>\n+\n+#include \"gtk_interface.h\"\n+#include \"gtk3_interface.h\"\n+\n+int DEBUG_SCREENCAST_ENABLED = FALSE;\n+\n+#define EXCEPTION_CHECK_DESCRIBE() if ((*env)->ExceptionCheck(env)) { \\\n+                                      (*env)->ExceptionDescribe(env); \\\n+                                   }\n+\n+struct ScreenSpace screenSpace = {0};\n+static struct PwLoopData pw = {0};\n+\n+jclass tokenStorageClass = NULL;\n+jmethodID storeTokenMethodID = NULL;\n+\n+inline void debug_screencast(\n+        const char *__restrict fmt,\n+        ...\n+) {\n+    if (DEBUG_SCREENCAST_ENABLED) {\n+        va_list myargs;\n+        va_start(myargs, fmt);\n+        vfprintf(stdout, fmt, myargs);\n+        va_end(myargs);\n+    }\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+static gboolean initScreenSpace() {\n+    screenSpace.screenCount = 0;\n+    screenSpace.allocated = SCREEN_SPACE_DEFAULT_ALLOCATED;\n+    screenSpace.screens = calloc(\n+            SCREEN_SPACE_DEFAULT_ALLOCATED,\n+            sizeof(struct ScreenProps)\n+    );\n+\n+    if (!screenSpace.screens) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return FALSE;\n+    }\n+    return TRUE;\n+}\n+\n+static void doCleanup() {\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct ScreenProps *screenProps = &screenSpace.screens[i];\n+        if (screenProps->data) {\n+            if (screenProps->data->stream) {\n+                fp_pw_stream_disconnect(screenProps->data->stream);\n+                fp_pw_stream_destroy(screenProps->data->stream);\n+                screenProps->data->stream = NULL;\n+            }\n+            free(screenProps->data);\n+            screenProps->data = NULL;\n+        }\n+    }\n+\n+    if (pw.pwFd > 0) {\n+        close(pw.pwFd);\n+        pw.pwFd = -1;\n+    }\n+\n+    portalScreenCastCleanup();\n+\n+    if (pw.core) {\n+        fp_pw_core_disconnect(pw.core);\n+        pw.core = NULL;\n+    }\n+\n+    DEBUG_SCREENCAST(\"STOPPING loop\\n\", NULL)\n+\n+    if (pw.loop) {\n+        fp_pw_thread_loop_stop(pw.loop);\n+        fp_pw_thread_loop_destroy(pw.loop);\n+        pw.loop = NULL;\n+    }\n+\n+    if (screenSpace.screens) {\n+        free(screenSpace.screens);\n+        screenSpace.screens = NULL;\n+    }\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+static gboolean initScreencast(const gchar *token,\n+                               GdkRectangle *affectedBounds,\n+                               gint affectedBoundsLength) {\n+    fp_pw_init(NULL, NULL);\n+\n+    pw.pwFd = RESULT_ERROR;\n+\n+    if (!initScreenSpace()\n+        || !initXdgDesktopPortal()\n+        || (pw.pwFd = getPipewireFd(token,\n+                                    affectedBounds,\n+                                    affectedBoundsLength)) < 0) {\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static inline void convertRGBxToBGRx(int* in) {\n+    char* o = (char*) in;\n+    char tmp = o[0];\n+    o[0] = o[2];\n+    o[2] = tmp;\n+}\n+\n+static gchar * cropTo(\n+        struct spa_data data,\n+        struct spa_video_info_raw raw,\n+        guint32 x,\n+        guint32 y,\n+        guint32 width,\n+        guint32 height\n+) {\n+    int srcW = raw.size.width;\n+    if (data.chunk->stride \/ 4 != srcW) {\n+        fprintf(stderr, \"%s:%i Unexpected stride \/ 4: %i srcW: %i\\n\",\n+                __func__, __LINE__, data.chunk->stride \/ 4, srcW);\n+    }\n+\n+    int* d = data.data;\n+\n+    int *outData = calloc(width * height, sizeof(int));\n+    if (!outData) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return NULL;\n+    }\n+\n+    gboolean needConversion = raw.format != SPA_VIDEO_FORMAT_BGRx;\n+    for (guint32 j = y; j < y + height; ++j) {\n+        for (guint32 i = x; i < x + width; ++i) {\n+            int color = *(d + (j * srcW) + i);\n+            if (needConversion) {\n+                convertRGBxToBGRx(&color);\n+            }\n+            *(outData + ((j - y) * width) + (i - x)) = color;\n+        }\n+    }\n+\n+    return (gchar*) outData;\n+}\n+\n+static void onStreamParamChanged(\n+        void *userdata,\n+        uint32_t id,\n+        const struct spa_pod *param\n+) {\n+    struct PwStreamData *data = userdata;\n+    uint32_t mediaType;\n+    uint32_t mediaSubtype;\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"param event id %i\\n\", id);\n+\n+    if (param == NULL || id != SPA_PARAM_Format) {\n+        return;\n+    }\n+\n+    if (spa_format_parse(param,\n+                         &mediaType,\n+                         &mediaSubtype) < 0) {\n+        return;\n+    }\n+\n+    if (mediaType != SPA_MEDIA_TYPE_video ||\n+        mediaSubtype != SPA_MEDIA_SUBTYPE_raw) {\n+        return;\n+    }\n+\n+    if (spa_format_video_raw_parse(param, &data->rawFormat) < 0) {\n+        return;\n+    }\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"stream format: %s (%d)\\t%dx%d\\n\",\n+                     spa_debug_type_find_name(\n+                             spa_type_video_format,\n+                             data->rawFormat.format\n+                     ),\n+                     data->rawFormat.format,\n+                     data->rawFormat.size.width,\n+                     data->rawFormat.size.height);\n+\n+    data->hasFormat = TRUE;\n+    fp_pw_thread_loop_signal(pw.loop, TRUE);\n+}\n+\n+static void onStreamProcess(void *userdata) {\n+    struct PwStreamData *data = userdata;\n+\n+    struct ScreenProps *screen = data->screenProps;\n+\n+    DEBUG_SCREEN_PREFIX(screen,\n+                        \"hasFormat %i \"\n+                        \"captureDataReady %i shouldCapture %i\\n\",\n+                        data->hasFormat,\n+                        screen->captureDataReady,\n+                        screen->shouldCapture\n+    );\n+    if (\n+            !data->hasFormat\n+            || !screen->shouldCapture\n+            || screen->captureDataReady\n+    ) {\n+        return;\n+    }\n+\n+    struct pw_buffer *pwBuffer;\n+    struct spa_buffer *spaBuffer;\n+\n+    if (!data->stream\n+        || (pwBuffer = fp_pw_stream_dequeue_buffer(data->stream)) == NULL) {\n+        DEBUG_SCREEN_PREFIX(screen, \"!!! out of buffers\\n\", NULL);\n+        return;\n+    }\n+\n+    spaBuffer = pwBuffer->buffer;\n+    if (!spaBuffer\n+        || spaBuffer->n_datas < 1\n+        || spaBuffer->datas[0].data == NULL) {\n+        DEBUG_SCREEN_PREFIX(screen, \"!!! no data, n_datas %d\\n\",\n+                            spaBuffer->n_datas);\n+        return;\n+    }\n+\n+    struct spa_data spaData = spaBuffer->datas[0];\n+\n+    DEBUG_SCREEN(screen);\n+    DEBUG_SCREEN_PREFIX(screen,\n+                        \"got a frame of size %d offset %d stride %d \"\n+                        \"flags %d FD %li captureDataReady %i\\n\",\n+                        spaBuffer->datas[0].chunk->size,\n+                        spaData.chunk->offset,\n+                        spaData.chunk->stride,\n+                        spaData.chunk->flags,\n+                        spaData.fd,\n+                        screen->captureDataReady\n+    );\n+\n+    data->screenProps->captureData = cropTo(\n+            spaData,\n+            data->rawFormat,\n+            screen->captureArea.x, screen->captureArea.y,\n+            screen->captureArea.width, screen->captureArea.height\n+    );\n+\n+    screen->captureDataReady = TRUE;\n+\n+    DEBUG_SCREEN_PREFIX(screen, \"data ready\\n\", NULL);\n+    fp_pw_stream_queue_buffer(data->stream, pwBuffer);\n+}\n+\n+static void onStreamStateChanged(\n+        void *userdata,\n+        enum pw_stream_state old,\n+        enum pw_stream_state state,\n+        const char *error\n+) {\n+    struct PwStreamData *data = userdata;\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"state %i (%s) -> %i (%s) err %s\\n\",\n+                     old, fp_pw_stream_state_as_string(old),\n+                     state, fp_pw_stream_state_as_string(state),\n+                     error);\n+}\n+\n+static const struct pw_stream_events streamEvents = {\n+        PW_VERSION_STREAM_EVENTS,\n+        .param_changed = onStreamParamChanged,\n+        .process = onStreamProcess,\n+        .state_changed = onStreamStateChanged,\n+};\n+\n+\n+static bool startStream(\n+        struct pw_stream *stream,\n+        uint32_t node\n+) {\n+    char buffer[1024];\n+    struct spa_pod_builder builder =\n+            SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));\n+    const struct spa_pod *param;\n+\n+\n+    param = spa_pod_builder_add_object(\n+            &builder,\n+            SPA_TYPE_OBJECT_Format,\n+            SPA_PARAM_EnumFormat,\n+            SPA_FORMAT_mediaType,\n+            SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,\n+            SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),\n+            SPA_FORMAT_VIDEO_format,\n+            SPA_POD_CHOICE_ENUM_Id(\n+                    2,\n+                    SPA_VIDEO_FORMAT_RGBx,\n+                    SPA_VIDEO_FORMAT_BGRx\n+            ),\n+            SPA_FORMAT_VIDEO_size,\n+            SPA_POD_CHOICE_RANGE_Rectangle(\n+                    &SPA_RECTANGLE(320, 240),\n+                    &SPA_RECTANGLE(1, 1),\n+                    &SPA_RECTANGLE(8192, 8192)\n+            ),\n+            SPA_FORMAT_VIDEO_framerate,\n+            SPA_POD_CHOICE_RANGE_Fraction(\n+                    &SPA_FRACTION(25, 1),\n+                    &SPA_FRACTION(0, 1),\n+                    &SPA_FRACTION(1000, 1)\n+            )\n+    );\n+\n+    DEBUG_SCREENCAST(\"screenId#%i: stream connecting %p\\n\", node, stream);\n+\n+    return fp_pw_stream_connect(\n+            stream,\n+            PW_DIRECTION_INPUT,\n+            node,\n+            PW_STREAM_FLAG_AUTOCONNECT\n+            | PW_STREAM_FLAG_MAP_BUFFERS,\n+            &param,\n+            1\n+    ) >= 0;\n+}\n+\n+\/**\n+ * @param index of a screen\n+ * @return TRUE on success\n+ *\/\n+static gboolean connectStream(int index) {\n+    DEBUG_SCREENCAST(\"@@@ using screen %i\\n\", index);\n+    if (index >= screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"!!! Wrong index for screen\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    struct PwStreamData *data = screenSpace.screens[index].data;\n+\n+    data->screenProps = &screenSpace.screens[index];\n+\n+    data->hasFormat = FALSE;\n+\n+\n+    data->stream = fp_pw_stream_new(\n+            pw.core,\n+            \"AWT Screen Stream\",\n+            fp_pw_properties_new(\n+                    PW_KEY_MEDIA_TYPE, \"Video\",\n+                    PW_KEY_MEDIA_CATEGORY, \"Capture\",\n+                    PW_KEY_MEDIA_ROLE, \"Screen\",\n+                    NULL\n+            )\n+    );\n+\n+    if (!data->stream) {\n+        DEBUG_SCREEN_PREFIX(data->screenProps,\n+                            \"!!! Could not create a pipewire stream\\n\", NULL);\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        return FALSE;\n+    }\n+\n+    fp_pw_stream_add_listener(\n+            data->stream,\n+            &data->streamListener,\n+            &streamEvents,\n+            data\n+    );\n+\n+    DEBUG_SCREEN(data->screenProps);\n+\n+    if (!startStream(data->stream, screenSpace.screens[index].id)){\n+        DEBUG_SCREEN_PREFIX(data->screenProps,\n+                            \"!!! Could not start a pipewire stream\\n\", NULL);\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        return FALSE;\n+    }\n+\n+    while (!data->hasFormat) {\n+        fp_pw_thread_loop_wait(pw.loop);\n+    }\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps,\n+            \"frame size: %dx%d\\n\",\n+            data->rawFormat.size.width, data->rawFormat.size.height\n+    );\n+\n+    fp_pw_thread_loop_accept(pw.loop);\n+\n+    return TRUE;\n+}\n+\n+\/**\n+ * @return TRUE if requested screenshot area intersects with a screen\n+ *\/\n+static gboolean checkScreen(int index, GdkRectangle requestedArea) {\n+    if (index >= screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"!!! Wrong index for screen %i >= %i\\n\",\n+                         index, screenSpace.screenCount);\n+        return FALSE;\n+    }\n+\n+    struct ScreenProps * screen = &screenSpace.screens[index];\n+\n+    int x1 = MAX(requestedArea.x, screen->bounds.x);\n+    int y1 = MAX(requestedArea.y, screen->bounds.y);\n+\n+    int x2 = MIN(\n+            requestedArea.x + requestedArea.width,\n+            screen->bounds.x + screen->bounds.width\n+    );\n+    int y2 = MIN(\n+            requestedArea.y + requestedArea.height,\n+            screen->bounds.y + screen->bounds.height\n+    );\n+\n+    screen->shouldCapture = x2 > x1 && y2 > y1;\n+\n+    if (screen->shouldCapture) {  \/\/intersects\n+        \/\/in screen coords:\n+        GdkRectangle * captureArea = &(screen->captureArea);\n+\n+        captureArea->x = x1 - screen->bounds.x;\n+        captureArea->y = y1 - screen->bounds.y;\n+        captureArea->width = x2 - x1;\n+        captureArea->height = y2 - y1;\n+\n+        screen->captureArea.x = x1 - screen->bounds.x;\n+    }\n+\n+    DEBUG_SCREEN(screen);\n+    return screen->shouldCapture;\n+}\n+\n+\n+static void onCoreError(\n+        void *data,\n+        uint32_t id,\n+        int seq,\n+        int res,\n+        const char *message\n+) {\n+    DEBUG_SCREENCAST(\n+            \"!!! pipewire error: id %u, seq: %d, res: %d (%s): %s\\n\",\n+            id, seq, res, strerror(res), message\n+    );\n+    fp_pw_thread_loop_unlock(pw.loop);\n+}\n+\n+static const struct pw_core_events coreEvents = {\n+        PW_VERSION_CORE_EVENTS,\n+        .error = onCoreError,\n+};\n+\n+\/**\n+ *\n+ * @param requestedArea requested screenshot area\n+ * @return TRUE on success\n+ *\/\n+static gboolean doLoop(GdkRectangle requestedArea) {\n+    pw.loop = fp_pw_thread_loop_new(\"AWT Pipewire Thread\", NULL);\n+\n+    if (!pw.loop) {\n+        DEBUG_SCREENCAST(\"!!! Could not create a loop\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    pw.context = fp_pw_context_new(\n+            fp_pw_thread_loop_get_loop(pw.loop),\n+            NULL,\n+            0\n+    );\n+\n+    if (!pw.context) {\n+        DEBUG_SCREENCAST(\"!!! Could not create a pipewire context\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    if (fp_pw_thread_loop_start(pw.loop) != 0) {\n+        DEBUG_SCREENCAST(\"!!! Could not start pipewire thread loop\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    fp_pw_thread_loop_lock(pw.loop);\n+\n+    pw.core = fp_pw_context_connect_fd(\n+            pw.context,\n+            pw.pwFd,\n+            NULL,\n+            0\n+    );\n+\n+    if (!pw.core) {\n+        DEBUG_SCREENCAST(\"!!! Could not create pipewire core\\n\", NULL);\n+        goto fail;\n+    }\n+\n+    pw_core_add_listener(pw.core, &pw.coreListener, &coreEvents, NULL);\n+\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct PwStreamData *data =\n+                (struct PwStreamData*) malloc(sizeof (struct PwStreamData));\n+        if (!data) {\n+            ERR(\"failed to allocate memory\\n\");\n+            goto fail;\n+        }\n+\n+        memset(data, 0, sizeof (struct PwStreamData));\n+\n+        struct ScreenProps *screen = &screenSpace.screens[i];\n+        screen->data = data;\n+\n+        DEBUG_SCREEN_PREFIX(screen, \"@@@ adding screen %i\\n\", i);\n+        if (checkScreen(i, requestedArea)) {\n+            if (!connectStream(i)){\n+                goto fail;\n+            }\n+        }\n+        DEBUG_SCREEN_PREFIX(screen, \"@@@ screen processed %i\\n\", i);\n+    }\n+\n+    fp_pw_thread_loop_unlock(pw.loop);\n+\n+    return TRUE;\n+\n+    fail:\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        doCleanup();\n+        return FALSE;\n+}\n+\n+static gboolean isAllDataReady() {\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        if (!screenSpace.screens[i].shouldCapture) {\n+            continue;\n+        }\n+        if (!screenSpace.screens[i].captureDataReady ) {\n+            return FALSE;\n+        }\n+    }\n+    return TRUE;\n+}\n+\n+\n+static void *pipewire_libhandle = NULL;\n+\/\/glib_version_2_68 false for gtk2, as it comes from gtk3_interface.c\n+\n+extern gboolean glib_version_2_68;\n+\n+#define LOAD_SYMBOL(fp_name, name) do {                             \\\n+    (fp_name) = dlsym(pipewire_libhandle, name);                    \\\n+    if (!(fp_name)) {                                               \\\n+       debug_screencast(\"!!! %s:%i error loading dl_symbol %s\\n\",   \\\n+                        __func__, __LINE__, name);                  \\\n+       goto fail;                                                   \\\n+    }                                                               \\\n+} while(0);\n+\n+static gboolean loadSymbols() {\n+    if (!glib_version_2_68) {\n+        DEBUG_SCREENCAST(\"glib version 2.68+ required\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    pipewire_libhandle = dlopen(VERSIONED_JNI_LIB_NAME(\"pipewire-0.3\", \"0\"),\n+            RTLD_LAZY | RTLD_LOCAL);\n+\n+    if (!pipewire_libhandle) {\n+        DEBUG_SCREENCAST(\"could not load pipewire library\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    LOAD_SYMBOL(fp_pw_stream_dequeue_buffer, \"pw_stream_dequeue_buffer\");\n+    LOAD_SYMBOL(fp_pw_stream_state_as_string, \"pw_stream_state_as_string\");\n+    LOAD_SYMBOL(fp_pw_stream_queue_buffer, \"pw_stream_queue_buffer\");\n+    LOAD_SYMBOL(fp_pw_stream_set_active, \"pw_stream_set_active\");\n+    LOAD_SYMBOL(fp_pw_stream_connect, \"pw_stream_connect\");\n+    LOAD_SYMBOL(fp_pw_stream_new, \"pw_stream_new\");\n+    LOAD_SYMBOL(fp_pw_stream_add_listener, \"pw_stream_add_listener\");\n+    LOAD_SYMBOL(fp_pw_stream_disconnect, \"pw_stream_disconnect\");\n+    LOAD_SYMBOL(fp_pw_stream_destroy, \"pw_stream_destroy\");\n+    LOAD_SYMBOL(fp_pw_init, \"pw_init\");\n+    LOAD_SYMBOL(fp_pw_context_connect_fd, \"pw_context_connect_fd\");\n+    LOAD_SYMBOL(fp_pw_core_disconnect, \"pw_core_disconnect\");\n+    LOAD_SYMBOL(fp_pw_context_new, \"pw_context_new\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_new, \"pw_thread_loop_new\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_get_loop, \"pw_thread_loop_get_loop\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_signal, \"pw_thread_loop_signal\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_wait, \"pw_thread_loop_wait\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_accept, \"pw_thread_loop_accept\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_start, \"pw_thread_loop_start\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_stop, \"pw_thread_loop_stop\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_destroy, \"pw_thread_loop_destroy\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_lock, \"pw_thread_loop_lock\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_unlock, \"pw_thread_loop_unlock\");\n+    LOAD_SYMBOL(fp_pw_properties_new, \"pw_properties_new\");\n+\n+    return TRUE;\n+\n+    fail:\n+        dlclose(pipewire_libhandle);\n+        pipewire_libhandle = NULL;\n+    return FALSE;\n+}\n+\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken) {\n+\n+    JNIEnv* env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);\n+    DEBUG_SCREENCAST(\"saving token, old: |%s| > new: |%s|\\n\", oldToken, newToken);\n+    if (env) {\n+        jstring jOldToken = NULL;\n+        if (oldToken) {\n+            jOldToken = (*env)->NewStringUTF(env, oldToken);\n+            EXCEPTION_CHECK_DESCRIBE();\n+            if (!jOldToken) {\n+                return;\n+            }\n+        }\n+        jstring jNewToken = (*env)->NewStringUTF(env, newToken);\n+        EXCEPTION_CHECK_DESCRIBE();\n+        if (!jNewToken) {\n+            (*env)->DeleteLocalRef(env, jOldToken);\n+            return;\n+        }\n+\n+        jintArray allowedBounds = NULL;\n+        if (screenSpace.screenCount > 0) {\n+            allowedBounds = (*env)->NewIntArray(env, screenSpace.screenCount*4);\n+            EXCEPTION_CHECK_DESCRIBE();\n+            if (!allowedBounds) {\n+                return;\n+            }\n+            jint* elements = (*env)->GetIntArrayElements(env, allowedBounds, NULL);\n+            EXCEPTION_CHECK_DESCRIBE();\n+            if (!elements) {\n+                return;\n+            }\n+\n+            for (int i = 0; i < screenSpace.screenCount; ++i) {\n+                GdkRectangle bounds = screenSpace.screens[i].bounds;\n+                elements[4 * i] = bounds.x;\n+                elements[4 * i + 1] = bounds.y;\n+                elements[4 * i + 2] = bounds.width;\n+                elements[4 * i + 3] = bounds.height;\n+            }\n+\n+            (*env)->ReleaseIntArrayElements(env, allowedBounds, elements, 0);\n+\n+            (*env)->CallStaticVoidMethod(env, tokenStorageClass,\n+                                         storeTokenMethodID,\n+                                         jOldToken, jNewToken,\n+                                         allowedBounds);\n+            EXCEPTION_CHECK_DESCRIBE();\n+        }\n+        (*env)->DeleteLocalRef(env, jOldToken);\n+        (*env)->DeleteLocalRef(env, jNewToken);\n+    } else {\n+        DEBUG_SCREENCAST(\"!!! Could not get env\\n\", NULL);\n+    }\n+}\n+\n+\/*\n+ * Class:     sun_awt_UNIXToolkit\n+ * Method:    load_gtk\n+ * Signature: (IZ)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_sun_awt_screencast_ScreencastHelper_loadPipewire(\n+        JNIEnv *env, jclass cls, jboolean screencastDebug\n+) {\n+    DEBUG_SCREENCAST_ENABLED = screencastDebug;\n+\n+    if (!loadSymbols()) {\n+        return JNI_FALSE;\n+    }\n+\n+    tokenStorageClass = (*env)->FindClass(env, \"sun\/awt\/screencast\/TokenStorage\");\n+    if (!tokenStorageClass) {\n+        return JNI_FALSE;\n+    }\n+\n+    tokenStorageClass = (*env)->NewGlobalRef(env, tokenStorageClass);\n+\n+    if (tokenStorageClass) {\n+        storeTokenMethodID = (*env)->GetStaticMethodID(\n+                env,\n+                tokenStorageClass,\n+                \"storeTokenFromNative\",\n+                \"(Ljava\/lang\/String;Ljava\/lang\/String;[I)V\"\n+                );\n+        if (!storeTokenMethodID) {\n+            return JNI_FALSE;\n+        }\n+    } else {\n+        DEBUG_SCREENCAST(\"!!! @@@ tokenStorageClass %p\\n\",\n+                         tokenStorageClass);\n+        return JNI_FALSE;\n+    }\n+\n+    gboolean usable = initXdgDesktopPortal();\n+    portalScreenCastCleanup();\n+    return usable;\n+}\n+\n+static void releaseToken(JNIEnv *env, jstring jtoken, const gchar *token) {\n+    if (token) {\n+        (*env)->ReleaseStringUTFChars(env, jtoken, token);\n+    }\n+}\n+\n+static void arrayToRectangles(JNIEnv *env,\n+                             jintArray boundsArray,\n+                             jint boundsLen,\n+                             GdkRectangle *out\n+) {\n+    if (!boundsArray) {\n+        return;\n+    }\n+\n+    jint * body = (*env)->GetIntArrayElements(env, boundsArray, 0);\n+    EXCEPTION_CHECK_DESCRIBE();\n+    if (!body) {\n+        return;\n+    }\n+\n+    for (int i = 0; i < boundsLen; i += 4) {\n+        GdkRectangle screenBounds = {\n+                body[i], body[i + 1],\n+                body[i + 2], body[i + 3]\n+        };\n+        out[i \/ 4] = screenBounds;\n+    }\n+\n+    (*env)->ReleaseIntArrayElements(env, boundsArray, body, 0);\n+}\n+\n+\/*\n+ * Class:     sun_awt_screencast_ScreencastHelper\n+ * Method:    getRGBPixelsImpl\n+ * Signature: (IIII[I[ILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_sun_awt_screencast_ScreencastHelper_getRGBPixelsImpl(\n+        JNIEnv *env,\n+        jclass cls,\n+        jint jx,\n+        jint jy,\n+        jint jwidth,\n+        jint jheight,\n+        jintArray pixelArray,\n+        jintArray affectedScreensBoundsArray,\n+        jstring jtoken\n+) {\n+    jsize boundsLen = 0;\n+    gint affectedBoundsLength = 0;\n+    if (affectedScreensBoundsArray) {\n+        boundsLen = (*env)->GetArrayLength(env, affectedScreensBoundsArray);\n+        EXCEPTION_CHECK_DESCRIBE();\n+        if (boundsLen % 4 != 0) {\n+            DEBUG_SCREENCAST(\"%s:%i incorrect array length\\n\", __FUNCTION__, __LINE__);\n+            return RESULT_ERROR;\n+        }\n+        affectedBoundsLength = boundsLen \/ 4;\n+    }\n+\n+    GdkRectangle affectedScreenBounds[affectedBoundsLength];\n+    arrayToRectangles(env,\n+                     affectedScreensBoundsArray,\n+                     boundsLen,\n+                     (GdkRectangle *) &affectedScreenBounds);\n+\n+    GdkRectangle requestedArea = { jx, jy, jwidth, jheight};\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+\n+    DEBUG_SCREENCAST(\n+            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i with token |%s|\\n\",\n+            jx, jy, jwidth, jheight, token\n+    );\n+\n+    if (!initScreencast(token, affectedScreenBounds, affectedBoundsLength)) {\n+        releaseToken(env, jtoken, token);\n+        return pw.pwFd;\n+    }\n+\n+    if (!doLoop(requestedArea)) {\n+        releaseToken(env, jtoken, token);\n+        return RESULT_ERROR;\n+    }\n+\n+    while (!isAllDataReady()) {\n+        fp_pw_thread_loop_wait(pw.loop);\n+    }\n+\n+    DEBUG_SCREENCAST(\"\\nall data ready\\n\", NULL);\n+\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct ScreenProps * screenProps = &screenSpace.screens[i];\n+\n+        if (screenProps->shouldCapture) {\n+            GdkRectangle bounds = screenProps->bounds;\n+            GdkRectangle captureArea  = screenProps->captureArea;\n+            DEBUG_SCREEN_PREFIX(screenProps,\n+                                \"@@@ copying screen data %i, captureData %p\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\\n\",\n+                                i, screenProps->captureData,\n+                                requestedArea.x, requestedArea.y,\n+                                requestedArea.width, requestedArea.height,\n+                                \"requested area\",\n+\n+                                bounds.x, bounds.y,\n+                                bounds.width, bounds.height,\n+                                \"screen bound\",\n+\n+                                captureArea.x, captureArea.y,\n+                                captureArea.width, captureArea.height,\n+                                \"in-screen coords capture area\"\n+            );\n+\n+            if (screenProps->captureData) {\n+                for (int y = 0; y < captureArea.height; y++) {\n+                    jsize preY = (requestedArea.y > screenProps->bounds.y)\n+                            ? 0\n+                            : screenProps->bounds.y - requestedArea.y;\n+                    jsize preX = (requestedArea.x > screenProps->bounds.x)\n+                            ? 0\n+                            : screenProps->bounds.x - requestedArea.x;\n+                    jsize start = jwidth * (preY + y) + preX;\n+\n+                    jsize len = captureArea.width;\n+\n+                    (*env)->SetIntArrayRegion(\n+                            env, pixelArray,\n+                            start, len,\n+                            ((jint *) screenProps->captureData)\n+                                + (captureArea.width * y)\n+                    );\n+                }\n+            }\n+\n+            free(screenProps->captureData);\n+            screenProps->captureData = NULL;\n+            screenProps->shouldCapture = FALSE;\n+\n+            fp_pw_stream_set_active(screenProps->data->stream, FALSE);\n+            fp_pw_stream_disconnect(screenProps->data->stream);\n+        }\n+    }\n+    doCleanup();\n+    releaseToken(env, jtoken, token);\n+    return 0;\n+}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":897,"deletions":0,"binary":false,"changes":897,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+\n+#ifndef _SCREENCAST_PIPEWIRE_H\n+#define _SCREENCAST_PIPEWIRE_H\n+\n+#include \"screencast_portal.h\"\n+\n+#include <pipewire\/stream.h>\n+#include <pipewire\/keys.h>\n+\n+#include <spa\/param\/video\/format-utils.h>\n+#include <spa\/debug\/types.h>\n+\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken);\n+\n+struct ScreenProps {\n+    guint32 id;\n+    GdkRectangle bounds;\n+\n+    GdkRectangle captureArea;\n+    struct PwStreamData *data;\n+\n+    gchar *captureData;\n+    volatile gboolean shouldCapture;\n+    volatile gboolean captureDataReady;\n+};\n+\n+\n+#define SCREEN_SPACE_DEFAULT_ALLOCATED 2\n+struct ScreenSpace {\n+    struct ScreenProps *screens;\n+    int screenCount;\n+    int allocated;\n+};\n+\n+#define DEBUG_SCREENCAST(FORMAT, ...) debug_screencast(\"%s:%i \" FORMAT, \\\n+                                        __func__, __LINE__, __VA_ARGS__);\n+\n+#define DEBUG_SCREEN(SCREEN)                                            \\\n+    DEBUG_SCREENCAST(\"screenId#%i\\n\"                                    \\\n+    \"||\\tbounds         x %5i y %5i w %5i h %5i\\n\"                      \\\n+    \"||\\tcapture area   x %5i y %5i w %5i h %5i shouldCapture %i\\n\\n\",  \\\n+    (SCREEN)->id,                                                       \\\n+    (SCREEN)->bounds.x,          (SCREEN)->bounds.y,                    \\\n+    (SCREEN)->bounds.width,      (SCREEN)->bounds.height,               \\\n+    (SCREEN)->captureArea.x,     (SCREEN)->captureArea.y,               \\\n+    (SCREEN)->captureArea.width, (SCREEN)->captureArea.height,          \\\n+    (SCREEN)->shouldCapture);\n+\n+#define DEBUG_SCREEN_PREFIX(SCREEN, FORMAT, ...)                        \\\n+    DEBUG_SCREENCAST(\"screenId#%i[loc(%d,%d) size(%dx%d)] \"FORMAT,      \\\n+    (SCREEN)->id, (SCREEN)->bounds.x, (SCREEN)->bounds.y,               \\\n+    (SCREEN)->bounds.width, (SCREEN)->bounds.height, __VA_ARGS__);\n+\n+#define ERR(MSG) fprintf(stderr, \"%s:%i \" MSG, __func__, __LINE__);\n+#define ERR_HANDLE(ERROR) errHandle((ERROR), __func__, __LINE__);\n+\n+struct PwLoopData {\n+    struct pw_thread_loop *loop;\n+    struct pw_context *context;\n+    struct pw_core *core;\n+    struct spa_hook coreListener;\n+    int pwFd; \/\/negative values can also be used to store a failure reason\n+};\n+\n+struct PwStreamData {\n+    struct pw_stream *stream;\n+    struct spa_hook streamListener;\n+\n+    struct spa_video_info_raw rawFormat;\n+    struct ScreenProps *screenProps;\n+\n+    gboolean hasFormat;\n+};\n+\n+#endif \/\/_SCREENCAST_PIPEWIRE_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,905 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"stdlib.h\"\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <pwd.h>\n+#include <unistd.h>\n+#include \"screencast_pipewire.h\"\n+#include \"screencast_portal.h\"\n+\n+\n+extern struct ScreenSpace screenSpace;\n+\n+struct XdgDesktopPortalApi *portal = NULL;\n+\n+void errHandle(\n+        GError *error,\n+        const gchar *functionName,\n+        int lineNum\n+) {\n+    if (error) {\n+        fprintf(stderr, \"!!! %s:%i Error: domain %i code %i message: \\\"%s\\\"\\n\",\n+                functionName, lineNum,\n+                error->domain, error->code, error->message);\n+    }\n+    if (error) {\n+        gtk->g_error_free(error);\n+    }\n+    error = NULL;\n+}\n+\n+gboolean validateToken(const gchar *token) {\n+    if (!token) {\n+        return FALSE;\n+    }\n+\n+    gboolean isValid = gtk->g_uuid_string_is_valid(token);\n+    if (!isValid) {\n+        DEBUG_SCREENCAST(\"!!! restore token \"\n+                         \"is not a valid UUID string:\\n\\\"%s\\\"\\n\",\n+                         token);\n+    }\n+    return isValid;\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+gboolean rebuildScreenData(GVariantIter *iterStreams, gboolean isTheOnlyMon) {\n+    guint32 nodeID;\n+    GVariant* prop = NULL;\n+\n+    int screenIndex = 0;\n+\n+    gboolean hasFailures = FALSE;\n+\n+    while (gtk->g_variant_iter_loop(\n+            iterStreams,\n+            \"(u@a{sv})\",\n+            &nodeID,\n+            &prop\n+    )) {\n+        DEBUG_SCREENCAST(\"\\n==== screenId#%i\\n\", nodeID);\n+\n+        if (screenIndex >= screenSpace.allocated) {\n+            screenSpace.screens = realloc(\n+                    screenSpace.screens,\n+                    ++screenSpace.allocated * sizeof(struct ScreenProps)\n+            );\n+            if (!screenSpace.screens) {\n+                ERR(\"failed to allocate memory\\n\");\n+                return FALSE;\n+            }\n+        }\n+\n+        struct ScreenProps * screen = &screenSpace.screens[screenIndex];\n+        memset(screen, 0, sizeof(struct ScreenProps));\n+\n+        screenSpace.screenCount = screenIndex + 1;\n+\n+        screen->id = nodeID;\n+\n+        if (\n+                !gtk->g_variant_lookup(\n+                        prop,\n+                        \"size\",\n+                        \"(ii)\",\n+                        &screen->bounds.width,\n+                        &screen->bounds.height\n+                )\n+                || (\n+                        !gtk->g_variant_lookup(\n+                                prop,\n+                                \"position\",\n+                                \"(ii)\",\n+                                &screen->bounds.x,\n+                                &screen->bounds.y\n+                        )\n+                        \/\/Screen position is not specified in some cases\n+                        \/\/(e.g. on Plasma).\n+                        \/\/In this case, proceed only if there is only one screen.\n+                        && !isTheOnlyMon\n+                )\n+                ) {\n+            hasFailures = TRUE;\n+        }\n+\n+        DEBUG_SCREENCAST(\"-----------------------\\n\", NULL);\n+        DEBUG_SCREEN(screen);\n+        DEBUG_SCREENCAST(\"#---------------------#\\n\\n\", NULL);\n+\n+        gtk->g_variant_unref(prop);\n+        screenIndex++;\n+    };\n+\n+    if (hasFailures) {\n+        DEBUG_SCREENCAST(\"screenId#%i hasFailures\\n\", nodeID);\n+    }\n+\n+    return !hasFailures;\n+}\n+\n+\/**\n+ * Checks screencast protocol version\n+ * @return FALSE if version < 4, or could not be determined\n+ *\/\n+gboolean checkVersion() {\n+    static guint32 version = 0;\n+    if (version == 0) {\n+        GError *error = NULL;\n+        GVariant *retVersion = gtk->g_dbus_proxy_call_sync(\n+                portal->screenCastProxy,\n+                \"org.freedesktop.DBus.Properties.Get\",\n+                gtk->g_variant_new(\"(ss)\",\n+                                   \"org.freedesktop.portal.ScreenCast\",\n+                                   \"version\"),\n+                G_DBUS_CALL_FLAGS_NONE,\n+                -1, NULL, NULL\n+        );\n+\n+        if (!retVersion) { \/\/no backend on system\n+            DEBUG_SCREENCAST(\"!!! could not detect the screencast version\\n\",\n+                             NULL);\n+            return FALSE;\n+        }\n+\n+        ERR_HANDLE(error);\n+\n+        GVariant *varVersion = NULL;\n+        gtk->g_variant_get(retVersion, \"(v)\", &varVersion);\n+\n+        if (!varVersion){\n+            gtk->g_variant_unref(retVersion);\n+            DEBUG_SCREENCAST(\"!!! could not get the screencast version\\n\",\n+                             NULL);\n+            return FALSE;\n+        }\n+\n+        version = gtk->g_variant_get_uint32(varVersion);\n+\n+        gtk->g_variant_unref(varVersion);\n+        gtk->g_variant_unref(retVersion);\n+\n+    }\n+\n+    DEBUG_SCREENCAST(\"ScreenCast protocol version %d\\n\", version);\n+    if (version < 4) {\n+        DEBUG_SCREENCAST(\"!!! ScreenCast protocol version %d < 4,\"\n+                         \" session restore is not available\\n\",\n+                         version);\n+    }\n+\n+    \/\/ restore_token was added in version 4, without it,\n+    \/\/ user confirmation is required for every screenshot.\n+    return version >= 4;\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+gboolean initXdgDesktopPortal() {\n+    portal = calloc(1, sizeof(*portal));\n+\n+    if (!portal) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return FALSE;\n+    }\n+\n+    GError* err = NULL;\n+\n+    portal->connection = gtk->g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &err);\n+\n+    if (err) {\n+        ERR_HANDLE(err);\n+        return FALSE;\n+    }\n+\n+    const gchar *name = gtk\n+            ->g_dbus_connection_get_unique_name(portal->connection);\n+    if (!name) {\n+        ERR(\"Failed to get unique connection name\\n\");\n+        return FALSE;\n+    }\n+\n+    GString * nameStr = gtk->g_string_new(name);\n+    gtk->g_string_erase(nameStr, 0, 1); \/\/remove leading colon \":\"\n+    gtk->g_string_replace(nameStr, \".\", \"_\", 0);\n+    portal->senderName = nameStr->str;\n+\n+    gtk->g_string_free(nameStr, FALSE);\n+\n+    DEBUG_SCREENCAST(\"connection\/sender name %s \/ %s\\n\",\n+                     name,\n+                     portal->senderName);\n+\n+    portal->screenCastProxy = gtk->g_dbus_proxy_new_sync(\n+            portal->connection,\n+            G_DBUS_PROXY_FLAGS_NONE,\n+            NULL,\n+            \"org.freedesktop.portal.Desktop\",\n+            \"\/org\/freedesktop\/portal\/desktop\",\n+            \"org.freedesktop.portal.ScreenCast\",\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get ScreenCast portal: %s\", err->message);\n+        ERR_HANDLE(err);\n+        return FALSE;\n+    }\n+\n+    return checkVersion();\n+}\n+\n+static void updateRequestPath(\n+        gchar **path,\n+        gchar **token\n+) {\n+    static uint64_t counter = 0;\n+    ++counter;\n+\n+    GString *tokenStr = gtk->g_string_new(NULL);\n+    gtk->g_string_printf(\n+            tokenStr,\n+            PORTAL_TOKEN_TEMPLATE,\n+            counter\n+    );\n+\n+    *token = tokenStr->str;\n+    gtk->g_string_free(tokenStr, FALSE);\n+\n+    GString *pathStr = gtk->g_string_new(NULL);\n+\n+    gtk->g_string_printf(\n+            pathStr,\n+            PORTAL_REQUEST_TEMPLATE,\n+            portal->senderName,\n+            counter\n+    );\n+\n+    *path = pathStr->str;\n+    gtk->g_string_free(pathStr, FALSE);\n+}\n+\n+static void updateSessionToken(\n+        gchar **token\n+) {\n+    static uint64_t counter = 0;\n+    counter++;\n+\n+    GString *tokenStr = gtk->g_string_new(NULL);\n+\n+    gtk->g_string_printf(\n+            tokenStr,\n+            PORTAL_TOKEN_TEMPLATE,\n+            counter\n+    );\n+\n+    *token = tokenStr->str;\n+    gtk->g_string_free(tokenStr, FALSE);\n+}\n+\n+static void registerScreenCastCallback(\n+        const char *path,\n+        struct DBusCallbackHelper *helper,\n+        GDBusSignalCallback callback\n+) {\n+    helper->id = gtk->g_dbus_connection_signal_subscribe(\n+            portal->connection,\n+            \"org.freedesktop.portal.Desktop\",\n+            \"org.freedesktop.portal.Request\",\n+            \"Response\",\n+            path,\n+            NULL,\n+            G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE,\n+            callback,\n+            helper,\n+            NULL\n+    );\n+}\n+\n+static void unregisterScreenCastCallback(\n+        struct DBusCallbackHelper *helper\n+) {\n+    if (helper->id) {\n+        gtk->g_dbus_connection_signal_unsubscribe(\n+                portal->connection,\n+                helper->id\n+        );\n+    }\n+}\n+\n+static void callbackScreenCastCreateSession(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+    uint32_t status;\n+    GVariant *result = NULL;\n+\n+    gtk->g_variant_get(\n+            parameters,\n+            \"(u@a{sv})\",\n+            &status,\n+            &result\n+    );\n+\n+    if (status != 0) {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast: %u\\n\", status);\n+    } else {\n+        gtk->g_variant_lookup(result, \"session_handle\", \"s\", helper->data);\n+    }\n+\n+    helper->isDone = TRUE;\n+}\n+\n+gboolean portalScreenCastCreateSession() {\n+    GError *err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+    gchar *sessionToken = NULL;\n+\n+    struct DBusCallbackHelper helper = {\n+            .id = 0,\n+            .data = &portal->screenCastSessionHandle\n+    };\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+    updateSessionToken(&sessionToken);\n+\n+    portal->screenCastSessionHandle = NULL;\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastCreateSession\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"session_handle_token\",\n+            gtk->g_variant_new_string(sessionToken)\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"CreateSession\",\n+            gtk->g_variant_new(\"(a{sv})\", &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast session: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(sessionToken);\n+    free(requestPath);\n+    free(requestToken);\n+\n+    return portal->screenCastSessionHandle != NULL;\n+}\n+\n+static void callbackScreenCastSelectSources(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+\n+    helper->data = (void *) 0;\n+\n+    uint32_t status;\n+    GVariant* result = NULL;\n+\n+    gtk->g_variant_get(parameters, \"(u@a{sv})\", &status, &result);\n+\n+    if (status != 0) {\n+        DEBUG_SCREENCAST(\"Failed select sources: %u\\n\", status);\n+    } else {\n+        helper->data = (void *) 1;\n+    }\n+\n+    helper->isDone = TRUE;\n+\n+    if (result) {\n+        gtk->g_variant_unref(result);\n+    }\n+}\n+\n+gboolean portalScreenCastSelectSources(const gchar *token) {\n+    GError* err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+\n+    struct DBusCallbackHelper helper = {0};\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastSelectSources\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\", \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\", \"multiple\",\n+            gtk->g_variant_new_boolean(TRUE));\n+\n+    \/\/ 1: MONITOR\n+    \/\/ 2: WINDOW\n+    \/\/ 4: VIRTUAL\n+    gtk->g_variant_builder_add(\n+            &builder, \"{sv}\", \"types\",\n+            gtk->g_variant_new_uint32(1)\n+    );\n+\n+    \/\/ 0: Do not persist (default)\n+    \/\/ 1: Permissions persist as long as the application is running\n+    \/\/ 2: Permissions persist until explicitly revoked\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"persist_mode\",\n+            gtk->g_variant_new_uint32(2)\n+    );\n+\n+    if (validateToken(token)) {\n+        gtk->g_variant_builder_add(\n+                &builder,\n+                \"{sv}\",\n+                \"restore_token\",\n+                gtk->g_variant_new_string(token)\n+        );\n+    }\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"SelectSources\",\n+            gtk->g_variant_new(\"(oa{sv})\", portal->screenCastSessionHandle, &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to call SelectSources: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(requestPath);\n+    free(requestToken);\n+\n+    return helper.data != NULL;\n+}\n+\n+static void callbackScreenCastStart(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+    struct StartHelper *startHelper = helper->data;\n+\n+    uint32_t status;\n+    GVariant* result = NULL;\n+    const gchar *oldToken = startHelper->token;\n+\n+    gtk->g_variant_get(parameters, \"(u@a{sv})\", &status, &result);\n+\n+    if (status != 0) {\n+        \/\/ Cancel pressed on the system dialog\n+        DEBUG_SCREENCAST(\"Failed to start screencast: %u\\n\", status);\n+        startHelper->result = RESULT_DENIED;\n+        helper->isDone = TRUE;\n+        return;\n+    }\n+\n+    GVariant *streams = gtk->g_variant_lookup_value(\n+            result,\n+            \"streams\",\n+            G_VARIANT_TYPE_ARRAY\n+    );\n+\n+    GVariantIter iter;\n+    gtk->g_variant_iter_init(\n+            &iter,\n+            streams\n+    );\n+\n+    size_t count = gtk->g_variant_iter_n_children(&iter);\n+\n+    DEBUG_SCREENCAST(\"available screen count %i\\n\", count);\n+\n+    startHelper->result = (rebuildScreenData(&iter, count == 1))\n+                   ? RESULT_OK\n+                   : RESULT_ERROR;\n+\n+    DEBUG_SCREENCAST(\"rebuildScreenData result |%i|\\n\", startHelper->result);\n+\n+    if (startHelper->result == RESULT_OK) {\n+        GVariant *restoreTokenVar = gtk->g_variant_lookup_value(\n+                result,\n+                \"restore_token\",\n+                G_VARIANT_TYPE_STRING\n+        );\n+\n+        if (restoreTokenVar) {\n+            gsize len;\n+            const gchar *newToken = gtk->\n+                    g_variant_get_string(restoreTokenVar, &len);\n+            DEBUG_SCREENCAST(\"restore_token |%s|\\n\", newToken);\n+\n+            storeRestoreToken(oldToken, newToken);\n+\n+            gtk->g_variant_unref(restoreTokenVar);\n+        }\n+    }\n+\n+    helper->isDone = TRUE;\n+\n+    if (streams) {\n+        gtk->g_variant_unref(streams);\n+    }\n+}\n+\n+ScreenCastResult portalScreenCastStart(const gchar *token) {\n+    GError *err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+\n+    struct StartHelper startHelper = { 0 };\n+    startHelper.token = token;\n+\n+    struct DBusCallbackHelper helper = { 0 };\n+    helper.data = &startHelper;\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastStart\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"Start\",\n+            gtk->g_variant_new(\"(osa{sv})\", portal->screenCastSessionHandle, \"\", &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to start session: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(requestPath);\n+    free(requestToken);\n+\n+    DEBUG_SCREENCAST(\"ScreenCastResult |%i|\\n\", startHelper.result);\n+\n+    return startHelper.result;\n+}\n+\n+int portalScreenCastOpenPipewireRemote() {\n+    GError* err = NULL;\n+    GUnixFDList* fdList = NULL;\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder, G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_with_unix_fd_list_sync(\n+            portal->screenCastProxy,\n+            \"OpenPipeWireRemote\",\n+            gtk->g_variant_new(\"(oa{sv})\", portal->screenCastSessionHandle, &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &fdList,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err || !response) {\n+        DEBUG_SCREENCAST(\"Failed to call OpenPipeWireRemote on session: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+        return RESULT_ERROR;\n+    }\n+\n+    gint32 index;\n+    gtk->g_variant_get(\n+            response,\n+            \"(h)\",\n+            &index,\n+            &err\n+    );\n+\n+    gtk->g_variant_unref(response);\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get pipewire fd index: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+        return RESULT_ERROR;\n+    }\n+\n+    int fd = gtk->g_unix_fd_list_get(\n+            fdList,\n+            index,\n+            &err\n+    );\n+\n+    if (fdList) {\n+        gtk->g_object_unref(fdList);\n+    }\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get pipewire fd: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+        return RESULT_ERROR;\n+    }\n+\n+    return fd;\n+}\n+\n+void portalScreenCastCleanup() {\n+    if (portal->screenCastSessionHandle) {\n+        gtk->g_dbus_connection_call_sync(\n+                portal->connection,\n+                \"org.freedesktop.portal.Desktop\",\n+                portal->screenCastSessionHandle,\n+                \"org.freedesktop.portal.Session\",\n+                \"Close\",\n+                NULL,\n+                NULL,\n+                G_DBUS_CALL_FLAGS_NONE,\n+                -1,\n+                NULL,\n+                NULL\n+        );\n+\n+        gtk->g_free(portal->screenCastSessionHandle);\n+        portal->screenCastSessionHandle = NULL;\n+    }\n+\n+    if (!portal) {\n+        return;\n+    }\n+    if (portal->connection) {\n+        gtk->g_object_unref(portal->connection);\n+        portal->connection = NULL;\n+    }\n+\n+    if (portal->screenCastProxy) {\n+        gtk->g_object_unref(portal->screenCastProxy);\n+        portal->screenCastProxy = NULL;\n+    }\n+\n+    if (portal->senderName) {\n+        free(portal->senderName);\n+        portal->senderName = NULL;\n+    }\n+\n+    free(portal);\n+    portal = NULL;\n+}\n+\n+gboolean rectanglesEqual(GdkRectangle rect1, GdkRectangle rect2) {\n+    return rect1.x == rect2.x\n+           && rect1.y == rect2.y\n+           && rect1.width == rect2.width\n+           && rect1.height == rect2.height;\n+}\n+\n+gboolean checkCanCaptureAllRequiredScreens(GdkRectangle *affectedBounds,\n+                        gint affectedBoundsLength) {\n+\n+\n+    if (affectedBoundsLength > screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"Requested screen count is greater \"\n+                         \"than allowed with token (%i > %i)\\n\",\n+                         affectedBoundsLength, screenSpace.screenCount);\n+        return false;\n+    }\n+\n+\n+    for (int i = 0; i < affectedBoundsLength; ++i) {\n+        gboolean found = false;\n+        GdkRectangle affBounds = affectedBounds[i];\n+        for (int j = 0; j < screenSpace.screenCount; ++j) {\n+            GdkRectangle allowedBounds = screenSpace.screens[j].bounds;\n+\n+            if (rectanglesEqual(allowedBounds, affBounds)) {\n+                DEBUG_SCREENCAST(\"Found allowed screen bounds in affected \"\n+                                 \"screen bounds %i %i %i %i\\n\",\n+                                 affBounds.x, affBounds.y,\n+                                 affBounds.width, affBounds.height);\n+                found = true;\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            DEBUG_SCREENCAST(\"Could not find required screen %i %i %i %i \"\n+                             \"in allowed bounds\\n\",\n+                             affBounds.x, affBounds.y,\n+                             affBounds.width, affBounds.height);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength) {\n+    if (!portalScreenCastCreateSession())  {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast session\\n\", NULL);\n+        return RESULT_ERROR;\n+    }\n+\n+    if (!portalScreenCastSelectSources(token)) {\n+        DEBUG_SCREENCAST(\"Failed to select sources\\n\", NULL);\n+        return RESULT_ERROR;\n+    }\n+\n+    ScreenCastResult startResult = portalScreenCastStart(token);\n+    DEBUG_SCREENCAST(\"portalScreenCastStart result |%i|\\n\", startResult);\n+    if (startResult != RESULT_OK) {\n+        DEBUG_SCREENCAST(\"Failed to start\\n\", NULL);\n+        return startResult;\n+    } else {\n+        if (!checkCanCaptureAllRequiredScreens(affectedBounds,\n+                                               affectedBoundsLength)) {\n+            DEBUG_SCREENCAST(\"The location of the screens has changed, \"\n+                             \"the capture area is outside the allowed \"\n+                             \"area.\\n\", NULL)\n+            return RESULT_OUT_OF_BOUNDS;\n+        }\n+    }\n+\n+    DEBUG_SCREENCAST(\"--- portalScreenCastStart\\n\", NULL);\n+\n+    int pipewireFd = portalScreenCastOpenPipewireRemote();\n+    if (pipewireFd < 0) {\n+        DEBUG_SCREENCAST(\"!!! Failed to get pipewire fd\\n\", NULL);\n+    }\n+\n+    DEBUG_SCREENCAST(\"pwFd %i\\n\", pipewireFd);\n+    return pipewireFd;\n+}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.c","additions":905,"deletions":0,"binary":false,"changes":905,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+#ifndef _SCREENCAST_PORTAL_H\n+#define _SCREENCAST_PORTAL_H\n+\n+#include \"gtk_interface.h\"\n+\n+#define PORTAL_TOKEN_TEMPLATE \"awtPipewire%lu\"\n+#define PORTAL_REQUEST_TEMPLATE \"\/org\/freedesktop\/portal\/desktop\/\" \\\n+                                \"request\/%s\/awtPipewire%lu\"\n+\n+void debug_screencast(const char *__restrict fmt, ...);\n+\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength);\n+\n+void portalScreenCastCleanup();\n+\n+gboolean initXdgDesktopPortal();\n+\n+void errHandle(GError *error, const gchar *functionName, int lineNum);\n+\n+struct XdgDesktopPortalApi {\n+    GDBusConnection *connection;\n+    GDBusProxy *screenCastProxy;\n+    gchar *senderName;\n+    char *screenCastSessionHandle;\n+};\n+\n+struct DBusCallbackHelper {\n+    guint id;\n+    void *data;\n+    gboolean isDone;\n+};\n+\n+typedef enum {\n+    RESULT_OK = 0,\n+    RESULT_ERROR = -1,\n+    RESULT_DENIED = -11,\n+    RESULT_OUT_OF_BOUNDS = -12,\n+} ScreenCastResult;\n+\n+struct StartHelper {\n+    const gchar *token;\n+    ScreenCastResult result;\n+};\n+\n+#endif \/\/_SCREENCAST_PORTAL_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.h","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_CONTEXT_H\n+#define PIPEWIRE_CONTEXT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup pw_context Context\n+ *\n+ * \\brief The PipeWire context object manages all locally available\n+ * resources. It is used by both clients and servers.\n+ *\n+ * The context is used to:\n+ *\n+ *  - Load modules and extend the functionality. This includes\n+ *    extending the protocol with new object types or creating\n+ *    any of the available objects.\n+ *\n+ *  - Create implementations of various objects like nodes,\n+ *    devices, factories, modules, etc.. This will usually also\n+ *    create pw_global objects that can then be shared with\n+ *    clients.\n+ *\n+ *  - Connect to another PipeWire instance (the main daemon, for\n+ *    example) and interact with it (See \\ref page_core_api).\n+ *\n+ *  - Export a local implementation of an object to another\n+ *    instance.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_context\n+ * @{\n+ *\/\n+struct pw_context;\n+\n+struct pw_global;\n+struct pw_impl_client;\n+\n+#include <pipewire\/core.h>\n+#include <pipewire\/loop.h>\n+#include <pipewire\/properties.h>\n+\n+\/** context events emitted by the context object added with \\ref pw_context_add_listener *\/\n+struct pw_context_events {\n+#define PW_VERSION_CONTEXT_EVENTS    0\n+    uint32_t version;\n+\n+    \/** The context is being destroyed *\/\n+    void (*destroy) (void *data);\n+    \/** The context is being freed *\/\n+    void (*free) (void *data);\n+    \/** a new client object is added *\/\n+    void (*check_access) (void *data, struct pw_impl_client *client);\n+    \/** a new global object was added *\/\n+    void (*global_added) (void *data, struct pw_global *global);\n+    \/** a global object was removed *\/\n+    void (*global_removed) (void *data, struct pw_global *global);\n+};\n+\n+\/** Make a new context object for a given main_loop. Ownership of the properties is taken *\/\n+struct pw_context * pw_context_new(struct pw_loop *main_loop,        \/**< a main loop to run in *\/\n+                 struct pw_properties *props,    \/**< extra properties *\/\n+                 size_t user_data_size        \/**< extra user data size *\/);\n+\n+\/** destroy a context object, all resources except the main_loop will be destroyed *\/\n+void pw_context_destroy(struct pw_context *context);\n+\n+\/** Get the context user data *\/\n+void *pw_context_get_user_data(struct pw_context *context);\n+\n+\/** Add a new event listener to a context *\/\n+void pw_context_add_listener(struct pw_context *context,\n+              struct spa_hook *listener,\n+              const struct pw_context_events *events,\n+              void *data);\n+\n+\/** Get the context properties *\/\n+const struct pw_properties *pw_context_get_properties(struct pw_context *context);\n+\n+\/** Update the context properties *\/\n+int pw_context_update_properties(struct pw_context *context, const struct spa_dict *dict);\n+\n+\/** Get a config section for this context. Since 0.3.22, deprecated,\n+ * use pw_context_conf_section_for_each(). *\/\n+const char *pw_context_get_conf_section(struct pw_context *context, const char *section);\n+\/** Parse a standard config section for this context. Since 0.3.22 *\/\n+int pw_context_parse_conf_section(struct pw_context *context,\n+        struct pw_properties *conf, const char *section);\n+\n+\/** update properties from a section into props. Since 0.3.45 *\/\n+int pw_context_conf_update_props(struct pw_context *context, const char *section,\n+        struct pw_properties *props);\n+\/** emit callback for all config sections. Since 0.3.45 *\/\n+int pw_context_conf_section_for_each(struct pw_context *context, const char *section,\n+        int (*callback) (void *data, const char *location, const char *section,\n+            const char *str, size_t len),\n+        void *data);\n+\/** emit callback for all matched properties. Since 0.3.46 *\/\n+int pw_context_conf_section_match_rules(struct pw_context *context, const char *section,\n+        const struct spa_dict *props,\n+        int (*callback) (void *data, const char *location, const char *action,\n+            const char *str, size_t len),\n+        void *data);\n+\n+\/** Get the context support objects *\/\n+const struct spa_support *pw_context_get_support(struct pw_context *context, uint32_t *n_support);\n+\n+\/** get the context main loop *\/\n+struct pw_loop *pw_context_get_main_loop(struct pw_context *context);\n+\n+\/** get the context data loop. Since 0.3.56 *\/\n+struct pw_data_loop *pw_context_get_data_loop(struct pw_context *context);\n+\n+\/** Get the work queue from the context: Since 0.3.26 *\/\n+struct pw_work_queue *pw_context_get_work_queue(struct pw_context *context);\n+\n+\/** Iterate the globals of the context. The callback should return\n+ * 0 to fetch the next item, any other value stops the iteration and returns\n+ * the value. When all callbacks return 0, this function returns 0 when all\n+ * globals are iterated. *\/\n+int pw_context_for_each_global(struct pw_context *context,\n+                int (*callback) (void *data, struct pw_global *global),\n+                void *data);\n+\n+\/** Find a context global by id *\/\n+struct pw_global *pw_context_find_global(struct pw_context *context,    \/**< the context *\/\n+                      uint32_t id        \/**< the global id *\/);\n+\n+\/** add a spa library for the given factory_name regex *\/\n+int pw_context_add_spa_lib(struct pw_context *context, const char *factory_regex, const char *lib);\n+\n+\/** find the library name for a spa factory *\/\n+const char * pw_context_find_spa_lib(struct pw_context *context, const char *factory_name);\n+\n+struct spa_handle *pw_context_load_spa_handle(struct pw_context *context,\n+        const char *factory_name,\n+        const struct spa_dict *info);\n+\n+\n+\/** data for registering export functions *\/\n+struct pw_export_type {\n+    struct spa_list link;\n+    const char *type;\n+    struct pw_proxy * (*func) (struct pw_core *core,\n+        const char *type, const struct spa_dict *props, void *object,\n+        size_t user_data_size);\n+};\n+\n+\/** register a type that can be exported on a context_proxy. This is usually used by\n+ * extension modules *\/\n+int pw_context_register_export_type(struct pw_context *context, struct pw_export_type *type);\n+\/** find information about registered export type *\/\n+const struct pw_export_type *pw_context_find_export_type(struct pw_context *context, const char *type);\n+\n+\/** add an object to the context *\/\n+int pw_context_set_object(struct pw_context *context, const char *type, void *value);\n+\/** get an object from the context *\/\n+void *pw_context_get_object(struct pw_context *context, const char *type);\n+\n+\/**\n+ * \\}\n+ *\/\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_CONTEXT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/context.h","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,612 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_CORE_H\n+#define PIPEWIRE_CORE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <errno.h>\n+\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup pw_core Core\n+ *\n+ * \\brief The core global object.\n+ *\n+ * This is a special singleton object. It is used for internal PipeWire\n+ * protocol features. Connecting to a PipeWire instance returns one core\n+ * object, the caller should then register event listeners\n+ * using \\ref pw_core_add_listener.\n+ *\n+ * Updates to the core object are then provided through the \\ref\n+ * pw_core_events interface. See \\ref page_tutorial2 for an example.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_core\n+ * \\{\n+ *\/\n+#define PW_TYPE_INTERFACE_Core        PW_TYPE_INFO_INTERFACE_BASE \"Core\"\n+#define PW_TYPE_INTERFACE_Registry    PW_TYPE_INFO_INTERFACE_BASE \"Registry\"\n+\n+#define PW_VERSION_CORE        4\n+struct pw_core;\n+#define PW_VERSION_REGISTRY    3\n+struct pw_registry;\n+\n+\/** The default remote name to connect to *\/\n+#define PW_DEFAULT_REMOTE    \"pipewire-0\"\n+\n+\/** default ID for the core object after connect *\/\n+#define PW_ID_CORE        0\n+\n+\/* invalid ID that matches any object when used for permissions *\/\n+#define PW_ID_ANY        (uint32_t)(0xffffffff)\n+\n+\/**  The core information. Extra information may be added in later versions,\n+ * clients must not assume a constant struct size *\/\n+struct pw_core_info {\n+    uint32_t id;            \/**< id of the global *\/\n+    uint32_t cookie;        \/**< a random cookie for identifying this instance of PipeWire *\/\n+    const char *user_name;        \/**< name of the user that started the core *\/\n+    const char *host_name;        \/**< name of the machine the core is running on *\/\n+    const char *version;        \/**< version of the core *\/\n+    const char *name;        \/**< name of the core *\/\n+#define PW_CORE_CHANGE_MASK_PROPS      (1 << 0)\n+#define PW_CORE_CHANGE_MASK_ALL        ((1 << 1)-1)\n+    uint64_t change_mask;        \/**< bitfield of changed fields since last call *\/\n+    struct spa_dict *props;        \/**< extra properties *\/\n+};\n+\n+#include <pipewire\/context.h>\n+#include <pipewire\/properties.h>\n+#include <pipewire\/proxy.h>\n+\n+\/** Update an existing \\ref pw_core_info with \\a update with reset *\/\n+struct pw_core_info *\n+pw_core_info_update(struct pw_core_info *info,\n+        const struct pw_core_info *update);\n+\/** Update an existing \\ref pw_core_info with \\a update *\/\n+struct pw_core_info *\n+pw_core_info_merge(struct pw_core_info *info,\n+        const struct pw_core_info *update, bool reset);\n+\/** Free a \\ref pw_core_info  *\/\n+void pw_core_info_free(struct pw_core_info *info);\n+\n+\/** Core *\/\n+\n+#define PW_CORE_EVENT_INFO        0\n+#define PW_CORE_EVENT_DONE        1\n+#define PW_CORE_EVENT_PING        2\n+#define PW_CORE_EVENT_ERROR        3\n+#define PW_CORE_EVENT_REMOVE_ID        4\n+#define PW_CORE_EVENT_BOUND_ID        5\n+#define PW_CORE_EVENT_ADD_MEM        6\n+#define PW_CORE_EVENT_REMOVE_MEM    7\n+#define PW_CORE_EVENT_BOUND_PROPS    8\n+#define PW_CORE_EVENT_NUM        9\n+\n+\/** \\struct pw_core_events\n+ *  \\brief Core events\n+ *\/\n+struct pw_core_events {\n+#define PW_VERSION_CORE_EVENTS    1\n+    uint32_t version;\n+\n+    \/**\n+     * Notify new core info\n+     *\n+     * This event is emitted when first bound to the core or when the\n+     * hello method is called.\n+     *\n+     * \\param info new core info\n+     *\/\n+    void (*info) (void *data, const struct pw_core_info *info);\n+    \/**\n+     * Emit a done event\n+     *\n+     * The done event is emitted as a result of a sync method with the\n+     * same seq number.\n+     *\n+     * \\param seq the seq number passed to the sync method call\n+     *\/\n+    void (*done) (void *data, uint32_t id, int seq);\n+\n+    \/** Emit a ping event\n+     *\n+     * The client should reply with a pong reply with the same seq\n+     * number.\n+     *\/\n+    void (*ping) (void *data, uint32_t id, int seq);\n+\n+    \/**\n+     * Fatal error event\n+         *\n+         * The error event is sent out when a fatal (non-recoverable)\n+         * error has occurred. The id argument is the proxy object where\n+         * the error occurred, most often in response to a request to that\n+         * object. The message is a brief description of the error,\n+         * for (debugging) convenience.\n+     *\n+     * This event is usually also emitted on the proxy object with\n+     * \\a id.\n+     *\n+         * \\param id object where the error occurred\n+         * \\param seq the sequence number that generated the error\n+         * \\param res error code\n+         * \\param message error description\n+     *\/\n+    void (*error) (void *data, uint32_t id, int seq, int res, const char *message);\n+    \/**\n+     * Remove an object ID\n+         *\n+         * This event is used internally by the object ID management\n+         * logic. When a client deletes an object, the server will send\n+         * this event to acknowledge that it has seen the delete request.\n+         * When the client receives this event, it will know that it can\n+         * safely reuse the object ID.\n+     *\n+         * \\param id deleted object ID\n+     *\/\n+    void (*remove_id) (void *data, uint32_t id);\n+\n+    \/**\n+     * Notify an object binding\n+     *\n+     * This event is emitted when a local object ID is bound to a\n+     * global ID. It is emitted before the global becomes visible in the\n+     * registry.\n+     *\n+     * \\param id bound object ID\n+     * \\param global_id the global id bound to\n+     *\/\n+    void (*bound_id) (void *data, uint32_t id, uint32_t global_id);\n+\n+    \/**\n+     * Add memory for a client\n+     *\n+     * Memory is given to a client as \\a fd of a certain\n+     * memory \\a type.\n+     *\n+     * Further references to this fd will be made with the per memory\n+     * unique identifier \\a id.\n+     *\n+     * \\param id the unique id of the memory\n+     * \\param type the memory type, one of enum spa_data_type\n+     * \\param fd the file descriptor\n+     * \\param flags extra flags\n+     *\/\n+    void (*add_mem) (void *data, uint32_t id, uint32_t type, int fd, uint32_t flags);\n+\n+    \/**\n+     * Remove memory for a client\n+     *\n+     * \\param id the memory id to remove\n+     *\/\n+    void (*remove_mem) (void *data, uint32_t id);\n+\n+    void (*bound_props) (void *data, uint32_t id, uint32_t global_id, const struct spa_dict *props);\n+};\n+\n+#define PW_CORE_METHOD_ADD_LISTENER    0\n+#define PW_CORE_METHOD_HELLO        1\n+#define PW_CORE_METHOD_SYNC        2\n+#define PW_CORE_METHOD_PONG        3\n+#define PW_CORE_METHOD_ERROR        4\n+#define PW_CORE_METHOD_GET_REGISTRY    5\n+#define PW_CORE_METHOD_CREATE_OBJECT    6\n+#define PW_CORE_METHOD_DESTROY        7\n+#define PW_CORE_METHOD_NUM        8\n+\n+\/**\n+ * \\struct pw_core_methods\n+ * \\brief Core methods\n+ *\n+ * The core global object. This is a singleton object used for\n+ * creating new objects in the remote PipeWire instance. It is\n+ * also used for internal features.\n+ *\/\n+struct pw_core_methods {\n+#define PW_VERSION_CORE_METHODS    0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_core_events *events,\n+            void *data);\n+    \/**\n+     * Start a conversation with the server. This will send\n+     * the core info and will destroy all resources for the client\n+     * (except the core and client resource).\n+     *\/\n+    int (*hello) (void *object, uint32_t version);\n+    \/**\n+     * Do server roundtrip\n+     *\n+     * Ask the server to emit the 'done' event with \\a seq.\n+     *\n+     * Since methods are handled in-order and events are delivered\n+     * in-order, this can be used as a barrier to ensure all previous\n+     * methods and the resulting events have been handled.\n+     *\n+     * \\param seq the seq number passed to the done event\n+     *\/\n+    int (*sync) (void *object, uint32_t id, int seq);\n+    \/**\n+     * Reply to a server ping event.\n+     *\n+     * Reply to the server ping event with the same seq.\n+     *\n+     * \\param seq the seq number received in the ping event\n+     *\/\n+    int (*pong) (void *object, uint32_t id, int seq);\n+    \/**\n+     * Fatal error event\n+         *\n+         * The error method is sent out when a fatal (non-recoverable)\n+         * error has occurred. The id argument is the proxy object where\n+         * the error occurred, most often in response to an event on that\n+         * object. The message is a brief description of the error,\n+         * for (debugging) convenience.\n+     *\n+     * This method is usually also emitted on the resource object with\n+     * \\a id.\n+     *\n+         * \\param id object where the error occurred\n+         * \\param res error code\n+         * \\param message error description\n+     *\/\n+    int (*error) (void *object, uint32_t id, int seq, int res, const char *message);\n+    \/**\n+     * Get the registry object\n+     *\n+     * Create a registry object that allows the client to list and bind\n+     * the global objects available from the PipeWire server\n+     * \\param version the client version\n+     * \\param user_data_size extra size\n+     *\/\n+    struct pw_registry * (*get_registry) (void *object, uint32_t version,\n+            size_t user_data_size);\n+\n+    \/**\n+     * Create a new object on the PipeWire server from a factory.\n+     *\n+     * \\param factory_name the factory name to use\n+     * \\param type the interface to bind to\n+     * \\param version the version of the interface\n+     * \\param props extra properties\n+     * \\param user_data_size extra size\n+     *\/\n+    void * (*create_object) (void *object,\n+                   const char *factory_name,\n+                   const char *type,\n+                   uint32_t version,\n+                   const struct spa_dict *props,\n+                   size_t user_data_size);\n+    \/**\n+     * Destroy an resource\n+     *\n+     * Destroy the server resource for the given proxy.\n+     *\n+     * \\param obj the proxy to destroy\n+     *\/\n+    int (*destroy) (void *object, void *proxy);\n+};\n+\n+#define pw_core_method(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_core_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define pw_core_add_listener(c,...)    pw_core_method(c,add_listener,0,__VA_ARGS__)\n+#define pw_core_hello(c,...)        pw_core_method(c,hello,0,__VA_ARGS__)\n+#define pw_core_sync(c,...)        pw_core_method(c,sync,0,__VA_ARGS__)\n+#define pw_core_pong(c,...)        pw_core_method(c,pong,0,__VA_ARGS__)\n+#define pw_core_error(c,...)        pw_core_method(c,error,0,__VA_ARGS__)\n+\n+\n+static inline\n+SPA_PRINTF_FUNC(5, 0) int\n+pw_core_errorv(struct pw_core *core, uint32_t id, int seq,\n+        int res, const char *message, va_list args)\n+{\n+    char buffer[1024];\n+    vsnprintf(buffer, sizeof(buffer), message, args);\n+    buffer[1023] = '\\0';\n+    return pw_core_error(core, id, seq, res, buffer);\n+}\n+\n+static inline\n+SPA_PRINTF_FUNC(5, 6) int\n+pw_core_errorf(struct pw_core *core, uint32_t id, int seq,\n+        int res, const char *message, ...)\n+{\n+        va_list args;\n+    int r;\n+    va_start(args, message);\n+    r = pw_core_errorv(core, id, seq, res, message, args);\n+    va_end(args);\n+    return r;\n+}\n+\n+static inline struct pw_registry *\n+pw_core_get_registry(struct pw_core *core, uint32_t version, size_t user_data_size)\n+{\n+    struct pw_registry *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)core,\n+            struct pw_core_methods, res,\n+            get_registry, 0, version, user_data_size);\n+    return res;\n+}\n+\n+static inline void *\n+pw_core_create_object(struct pw_core *core,\n+                const char *factory_name,\n+                const char *type,\n+                uint32_t version,\n+                const struct spa_dict *props,\n+                size_t user_data_size)\n+{\n+    void *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)core,\n+            struct pw_core_methods, res,\n+            create_object, 0, factory_name,\n+            type, version, props, user_data_size);\n+    return res;\n+}\n+\n+#define pw_core_destroy(c,...)        pw_core_method(c,destroy,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/** \\defgroup pw_registry Registry\n+ *\n+ * The registry object is a singleton object that keeps track of\n+ * global objects on the PipeWire instance. See also \\ref pw_global.\n+ *\n+ * Global objects typically represent an actual object in PipeWire\n+ * (for example, a module or node) or they are singleton\n+ * objects such as the core.\n+ *\n+ * When a client creates a registry object, the registry object\n+ * will emit a global event for each global currently in the\n+ * registry.  Globals come and go as a result of device hotplugs or\n+ * reconfiguration or other events, and the registry will send out\n+ * global and global_remove events to keep the client up to date\n+ * with the changes.  To mark the end of the initial burst of\n+ * events, the client can use the pw_core.sync methosd immediately\n+ * after calling pw_core.get_registry.\n+ *\n+ * A client can bind to a global object by using the bind\n+ * request.  This creates a client-side proxy that lets the object\n+ * emit events to the client and lets the client invoke methods on\n+ * the object. See \\ref page_proxy\n+ *\n+ * Clients can also change the permissions of the global objects that\n+ * it can see. This is interesting when you want to configure a\n+ * pipewire session before handing it to another application. You\n+ * can, for example, hide certain existing or new objects or limit\n+ * the access permissions on an object.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_registry\n+ * \\{\n+ *\/\n+\n+#define PW_REGISTRY_EVENT_GLOBAL             0\n+#define PW_REGISTRY_EVENT_GLOBAL_REMOVE      1\n+#define PW_REGISTRY_EVENT_NUM                2\n+\n+\/** Registry events *\/\n+struct pw_registry_events {\n+#define PW_VERSION_REGISTRY_EVENTS    0\n+    uint32_t version;\n+    \/**\n+     * Notify of a new global object\n+     *\n+     * The registry emits this event when a new global object is\n+     * available.\n+     *\n+     * \\param id the global object id\n+     * \\param permissions the permissions of the object\n+     * \\param type the type of the interface\n+     * \\param version the version of the interface\n+     * \\param props extra properties of the global\n+     *\/\n+    void (*global) (void *data, uint32_t id,\n+               uint32_t permissions, const char *type, uint32_t version,\n+               const struct spa_dict *props);\n+    \/**\n+     * Notify of a global object removal\n+     *\n+     * Emitted when a global object was removed from the registry.\n+     * If the client has any bindings to the global, it should destroy\n+     * those.\n+     *\n+     * \\param id the id of the global that was removed\n+     *\/\n+    void (*global_remove) (void *data, uint32_t id);\n+};\n+\n+#define PW_REGISTRY_METHOD_ADD_LISTENER    0\n+#define PW_REGISTRY_METHOD_BIND        1\n+#define PW_REGISTRY_METHOD_DESTROY    2\n+#define PW_REGISTRY_METHOD_NUM        3\n+\n+\/** Registry methods *\/\n+struct pw_registry_methods {\n+#define PW_VERSION_REGISTRY_METHODS    0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_registry_events *events,\n+            void *data);\n+    \/**\n+     * Bind to a global object\n+     *\n+     * Bind to the global object with \\a id and use the client proxy\n+     * with new_id as the proxy. After this call, methods can be\n+     * send to the remote global object and events can be received\n+     *\n+     * \\param id the global id to bind to\n+     * \\param type the interface type to bind to\n+     * \\param version the interface version to use\n+     * \\returns the new object\n+     *\/\n+    void * (*bind) (void *object, uint32_t id, const char *type, uint32_t version,\n+            size_t use_data_size);\n+\n+    \/**\n+     * Attempt to destroy a global object\n+     *\n+     * Try to destroy the global object.\n+     *\n+     * \\param id the global id to destroy\n+     *\/\n+    int (*destroy) (void *object, uint32_t id);\n+};\n+\n+#define pw_registry_method(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_registry_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\/** Registry *\/\n+#define pw_registry_add_listener(p,...)    pw_registry_method(p,add_listener,0,__VA_ARGS__)\n+\n+static inline void *\n+pw_registry_bind(struct pw_registry *registry,\n+               uint32_t id, const char *type, uint32_t version,\n+               size_t user_data_size)\n+{\n+    void *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)registry,\n+            struct pw_registry_methods, res,\n+            bind, 0, id, type, version, user_data_size);\n+    return res;\n+}\n+\n+#define pw_registry_destroy(p,...)    pw_registry_method(p,destroy,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_core\n+ * \\{\n+ *\/\n+\n+\/** Connect to a PipeWire instance\n+ *\n+ * \\param context a \\ref pw_context\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error. The core\n+ * will have an id of \\ref PW_ID_CORE (0)\n+ *\/\n+struct pw_core *\n+pw_context_connect(struct pw_context *context,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Connect to a PipeWire instance on the given socket\n+ *\n+ * \\param context a \\ref pw_context\n+ * \\param fd the connected socket to use, the socket will be closed\n+ *    automatically on disconnect or error.\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error *\/\n+struct pw_core *\n+pw_context_connect_fd(struct pw_context *context,\n+          int fd,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Connect to a given PipeWire instance\n+ *\n+ * \\param context a \\ref pw_context to connect to\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error *\/\n+struct pw_core *\n+pw_context_connect_self(struct pw_context *context,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Steal the fd of the core connection or < 0 on error. The core\n+  * will be disconnected after this call. *\/\n+int pw_core_steal_fd(struct pw_core *core);\n+\n+\/** Pause or resume the core. When the core is paused, no new events\n+ *  will be dispatched until the core is resumed again. *\/\n+int pw_core_set_paused(struct pw_core *core, bool paused);\n+\n+\/** disconnect and destroy a core *\/\n+int pw_core_disconnect(struct pw_core *core);\n+\n+\/** Get the user_data. It is of the size specified when this object was\n+ * constructed *\/\n+void *pw_core_get_user_data(struct pw_core *core);\n+\n+\/** Get the client proxy of the connected core. This will have the id\n+ * of PW_ID_CLIENT (1) *\/\n+struct pw_client * pw_core_get_client(struct pw_core *core);\n+\n+\/** Get the context object used to created this core *\/\n+struct pw_context * pw_core_get_context(struct pw_core *core);\n+\n+\/** Get properties from the core *\/\n+const struct pw_properties *pw_core_get_properties(struct pw_core *core);\n+\n+\/** Update the core properties. This updates the properties\n+ * of the associated client.\n+ * \\return the number of properties that were updated *\/\n+int pw_core_update_properties(struct pw_core *core, const struct spa_dict *dict);\n+\n+\/** Get the core mempool object *\/\n+struct pw_mempool * pw_core_get_mempool(struct pw_core *core);\n+\n+\/** Get the proxy with the given id *\/\n+struct pw_proxy *pw_core_find_proxy(struct pw_core *core, uint32_t id);\n+\n+\/** Export an object into the PipeWire instance associated with core *\/\n+struct pw_proxy *pw_core_export(struct pw_core *core,            \/**< the core *\/\n+                  const char *type,            \/**< the type of object *\/\n+                  const struct spa_dict *props,        \/**< extra properties *\/\n+                  void *object,                \/**< object to export *\/\n+                  size_t user_data_size            \/**< extra user data *\/);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_CORE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/core.h","additions":612,"deletions":0,"binary":false,"changes":612,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_KEYS_H\n+#define PIPEWIRE_KEYS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <pipewire\/utils.h>\n+\/**\n+ * \\defgroup pw_keys Key Names\n+ *\n+ * A collection of keys that are used to add extra information on objects.\n+ *\n+ * Keys that start with \"pipewire.\" are in general set-once and then\n+ * read-only. They are usually used for security sensitive information that\n+ * needs to be fixed.\n+ *\n+ * Properties from other objects can also appear. This usually suggests some\n+ * sort of parent\/child or owner\/owned relationship.\n+ *\n+ * \\addtogroup pw_keys\n+ * \\{\n+ *\/\n+#define PW_KEY_PROTOCOL            \"pipewire.protocol\"    \/**< protocol used for connection *\/\n+#define PW_KEY_ACCESS            \"pipewire.access\"    \/**< how the client access is controlled *\/\n+#define PW_KEY_CLIENT_ACCESS        \"pipewire.client.access\"\/**< how the client wants to be access\n+                                  *  controlled *\/\n+\n+\/** Various keys related to the identity of a client process and its security.\n+ * Must be obtained from trusted sources by the protocol and placed as\n+ * read-only properties. *\/\n+#define PW_KEY_SEC_PID            \"pipewire.sec.pid\"    \/**< Client pid, set by protocol *\/\n+#define PW_KEY_SEC_UID            \"pipewire.sec.uid\"    \/**< Client uid, set by protocol*\/\n+#define PW_KEY_SEC_GID            \"pipewire.sec.gid\"    \/**< client gid, set by protocol*\/\n+#define PW_KEY_SEC_LABEL        \"pipewire.sec.label\"    \/**< client security label, set by protocol*\/\n+\n+#define PW_KEY_LIBRARY_NAME_SYSTEM    \"library.name.system\"    \/**< name of the system library to use *\/\n+#define PW_KEY_LIBRARY_NAME_LOOP    \"library.name.loop\"    \/**< name of the loop library to use *\/\n+#define PW_KEY_LIBRARY_NAME_DBUS    \"library.name.dbus\"    \/**< name of the dbus library to use *\/\n+\n+\/** object properties *\/\n+#define PW_KEY_OBJECT_PATH        \"object.path\"        \/**< unique path to construct the object *\/\n+#define PW_KEY_OBJECT_ID        \"object.id\"        \/**< a global object id *\/\n+#define PW_KEY_OBJECT_SERIAL        \"object.serial\"        \/**< a 64 bit object serial number. This is a number\n+                                  *  incremented for each object that is created.\n+                                  *  The lower 32 bits are guaranteed to never be\n+                                  *  SPA_ID_INVALID. *\/\n+#define PW_KEY_OBJECT_LINGER        \"object.linger\"        \/**< the object lives on even after the client\n+                                  *  that created it has been destroyed *\/\n+#define PW_KEY_OBJECT_REGISTER        \"object.register\"    \/**< If the object should be registered. *\/\n+\n+\n+\/* config *\/\n+#define PW_KEY_CONFIG_PREFIX        \"config.prefix\"        \/**< a config prefix directory *\/\n+#define PW_KEY_CONFIG_NAME        \"config.name\"        \/**< a config file name *\/\n+#define PW_KEY_CONFIG_OVERRIDE_PREFIX    \"config.override.prefix\"    \/**< a config override prefix directory *\/\n+#define PW_KEY_CONFIG_OVERRIDE_NAME    \"config.override.name\"    \/**< a config override file name *\/\n+\n+\/* context *\/\n+#define PW_KEY_CONTEXT_PROFILE_MODULES    \"context.profile.modules\"    \/**< a context profile for modules, deprecated *\/\n+#define PW_KEY_USER_NAME        \"context.user-name\"    \/**< The user name that runs pipewire *\/\n+#define PW_KEY_HOST_NAME        \"context.host-name\"    \/**< The host name of the machine *\/\n+\n+\/* core *\/\n+#define PW_KEY_CORE_NAME        \"core.name\"        \/**< The name of the core. Default is\n+                                  *  `pipewire-<username>-<pid>`, overwritten\n+                                  *  by env(PIPEWIRE_CORE) *\/\n+#define PW_KEY_CORE_VERSION        \"core.version\"        \/**< The version of the core. *\/\n+#define PW_KEY_CORE_DAEMON        \"core.daemon\"        \/**< If the core is listening for connections. *\/\n+\n+#define PW_KEY_CORE_ID            \"core.id\"        \/**< the core id *\/\n+#define PW_KEY_CORE_MONITORS        \"core.monitors\"        \/**< the apis monitored by core. *\/\n+\n+\/* cpu *\/\n+#define PW_KEY_CPU_MAX_ALIGN        \"cpu.max-align\"        \/**< maximum alignment needed to support\n+                                  *  all CPU optimizations *\/\n+#define PW_KEY_CPU_CORES        \"cpu.cores\"        \/**< number of cores *\/\n+\n+\/* priorities *\/\n+#define PW_KEY_PRIORITY_SESSION        \"priority.session\"    \/**< priority in session manager *\/\n+#define PW_KEY_PRIORITY_DRIVER        \"priority.driver\"    \/**< priority to be a driver *\/\n+\n+\/* remote keys *\/\n+#define PW_KEY_REMOTE_NAME        \"remote.name\"        \/**< The name of the remote to connect to,\n+                                  *  default pipewire-0, overwritten by\n+                                  *  env(PIPEWIRE_REMOTE) *\/\n+#define PW_KEY_REMOTE_INTENTION        \"remote.intention\"    \/**< The intention of the remote connection,\n+                                  *  \"generic\", \"screencast\" *\/\n+\n+\/** application keys *\/\n+#define PW_KEY_APP_NAME            \"application.name\"    \/**< application name. Ex: \"Totem Music Player\" *\/\n+#define PW_KEY_APP_ID            \"application.id\"    \/**< a textual id for identifying an\n+                                  *  application logically. Ex: \"org.gnome.Totem\" *\/\n+#define PW_KEY_APP_VERSION        \"application.version\"   \/**< application version. Ex: \"1.2.0\" *\/\n+#define PW_KEY_APP_ICON            \"application.icon\"    \/**< aa base64 blob with PNG image data *\/\n+#define PW_KEY_APP_ICON_NAME        \"application.icon-name\"    \/**< an XDG icon name for the application.\n+                                  *  Ex: \"totem\" *\/\n+#define PW_KEY_APP_LANGUAGE        \"application.language\"    \/**< application language if applicable, in\n+                                  *  standard POSIX format. Ex: \"en_GB\" *\/\n+\n+#define PW_KEY_APP_PROCESS_ID        \"application.process.id\"    \/**< process id  (pid)*\/\n+#define PW_KEY_APP_PROCESS_BINARY    \"application.process.binary\"    \/**< binary name *\/\n+#define PW_KEY_APP_PROCESS_USER        \"application.process.user\"    \/**< user name *\/\n+#define PW_KEY_APP_PROCESS_HOST        \"application.process.host\"    \/**< host name *\/\n+#define PW_KEY_APP_PROCESS_MACHINE_ID    \"application.process.machine-id\" \/**< the D-Bus host id the\n+                                       *  application runs on *\/\n+#define PW_KEY_APP_PROCESS_SESSION_ID    \"application.process.session-id\" \/**< login session of the\n+                                       *  application, on Unix the\n+                                       *  value of $XDG_SESSION_ID. *\/\n+\/** window system *\/\n+#define PW_KEY_WINDOW_X11_DISPLAY    \"window.x11.display\"    \/**< the X11 display string. Ex. \":0.0\" *\/\n+\n+\/** Client properties *\/\n+#define PW_KEY_CLIENT_ID        \"client.id\"        \/**< a client id *\/\n+#define PW_KEY_CLIENT_NAME        \"client.name\"        \/**< the client name *\/\n+#define PW_KEY_CLIENT_API        \"client.api\"        \/**< the client api used to access\n+                                  *  PipeWire *\/\n+\n+\/** Node keys *\/\n+#define PW_KEY_NODE_ID            \"node.id\"        \/**< node id *\/\n+#define PW_KEY_NODE_NAME        \"node.name\"        \/**< node name *\/\n+#define PW_KEY_NODE_NICK        \"node.nick\"        \/**< short node name *\/\n+#define PW_KEY_NODE_DESCRIPTION        \"node.description\"    \/**< localized human readable node one-line\n+                                  *  description. Ex. \"Foobar USB Headset\" *\/\n+#define PW_KEY_NODE_PLUGGED        \"node.plugged\"        \/**< when the node was created. As a uint64 in\n+                                  *  nanoseconds. *\/\n+\n+#define PW_KEY_NODE_SESSION        \"node.session\"        \/**< the session id this node is part of *\/\n+#define PW_KEY_NODE_GROUP        \"node.group\"        \/**< the group id this node is part of. Nodes\n+                                  *  in the same group are always scheduled\n+                                  *  with the same driver. *\/\n+#define PW_KEY_NODE_EXCLUSIVE        \"node.exclusive\"    \/**< node wants exclusive access to resources *\/\n+#define PW_KEY_NODE_AUTOCONNECT        \"node.autoconnect\"    \/**< node wants to be automatically connected\n+                                  *  to a compatible node *\/\n+#define PW_KEY_NODE_LATENCY        \"node.latency\"        \/**< the requested latency of the node as\n+                                  *  a fraction. Ex: 128\/48000 *\/\n+#define PW_KEY_NODE_MAX_LATENCY        \"node.max-latency\"    \/**< the maximum supported latency of the\n+                                  *  node as a fraction. Ex: 1024\/48000 *\/\n+#define PW_KEY_NODE_LOCK_QUANTUM    \"node.lock-quantum\"    \/**< don't change quantum when this node\n+                                  *  is active *\/\n+#define PW_KEY_NODE_FORCE_QUANTUM    \"node.force-quantum\"    \/**< force a quantum while the node is\n+                                  *  active *\/\n+#define PW_KEY_NODE_RATE        \"node.rate\"        \/**< the requested rate of the graph as\n+                                  *  a fraction. Ex: 1\/48000 *\/\n+#define PW_KEY_NODE_LOCK_RATE        \"node.lock-rate\"    \/**< don't change rate when this node\n+                                  *  is active *\/\n+#define PW_KEY_NODE_FORCE_RATE        \"node.force-rate\"    \/**< force a rate while the node is\n+                                  *  active. A value of 0 takes the denominator\n+                                  *  of node.rate *\/\n+\n+#define PW_KEY_NODE_DONT_RECONNECT    \"node.dont-reconnect\"    \/**< don't reconnect this node. The node is\n+                                  *  initially linked to target.object or the\n+                                  *  default node. If the target is removed,\n+                                  *  the node is destroyed *\/\n+#define PW_KEY_NODE_ALWAYS_PROCESS    \"node.always-process\"    \/**< process even when unlinked *\/\n+#define PW_KEY_NODE_WANT_DRIVER        \"node.want-driver\"    \/**< the node wants to be grouped with a driver\n+                                  *  node in order to schedule the graph. *\/\n+#define PW_KEY_NODE_PAUSE_ON_IDLE    \"node.pause-on-idle\"    \/**< pause the node when idle *\/\n+#define PW_KEY_NODE_SUSPEND_ON_IDLE    \"node.suspend-on-idle\"    \/**< suspend the node when idle *\/\n+#define PW_KEY_NODE_CACHE_PARAMS    \"node.cache-params\"    \/**< cache the node params *\/\n+#define PW_KEY_NODE_TRANSPORT_SYNC    \"node.transport.sync\"    \/**< the node handles transport sync *\/\n+#define PW_KEY_NODE_DRIVER        \"node.driver\"        \/**< node can drive the graph *\/\n+#define PW_KEY_NODE_STREAM        \"node.stream\"        \/**< node is a stream, the server side should\n+                                  *  add a converter *\/\n+#define PW_KEY_NODE_VIRTUAL        \"node.virtual\"        \/**< the node is some sort of virtual\n+                                  *  object *\/\n+#define PW_KEY_NODE_PASSIVE        \"node.passive\"        \/**< indicate that a node wants passive links\n+                                  *  on output\/input\/all ports when the value is\n+                                  *  \"out\"\/\"in\"\/\"true\" respectively *\/\n+#define PW_KEY_NODE_LINK_GROUP        \"node.link-group\"    \/**< the node is internally linked to\n+                                  *  nodes with the same link-group *\/\n+#define PW_KEY_NODE_NETWORK        \"node.network\"        \/**< the node is on a network *\/\n+#define PW_KEY_NODE_TRIGGER        \"node.trigger\"        \/**< the node is not scheduled automatically\n+                                  *   based on the dependencies in the graph\n+                                  *   but it will be triggered explicitly. *\/\n+#define PW_KEY_NODE_CHANNELNAMES        \"node.channel-names\"        \/**< names of node's\n+                                    *   channels (unrelated to positions) *\/\n+#define PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX            \"node.device-port-name-prefix\"        \/** override\n+                                    *        port name prefix for device ports, like capture and playback\n+                                    *        or disable the prefix completely if an empty string is provided *\/\n+\n+\/** Port keys *\/\n+#define PW_KEY_PORT_ID            \"port.id\"        \/**< port id *\/\n+#define PW_KEY_PORT_NAME        \"port.name\"        \/**< port name *\/\n+#define PW_KEY_PORT_DIRECTION        \"port.direction\"    \/**< the port direction, one of \"in\" or \"out\"\n+                                  *  or \"control\" and \"notify\" for control ports *\/\n+#define PW_KEY_PORT_ALIAS        \"port.alias\"        \/**< port alias *\/\n+#define PW_KEY_PORT_PHYSICAL        \"port.physical\"        \/**< if this is a physical port *\/\n+#define PW_KEY_PORT_TERMINAL        \"port.terminal\"        \/**< if this port consumes the data *\/\n+#define PW_KEY_PORT_CONTROL        \"port.control\"        \/**< if this port is a control port *\/\n+#define PW_KEY_PORT_MONITOR        \"port.monitor\"        \/**< if this port is a monitor port *\/\n+#define PW_KEY_PORT_CACHE_PARAMS    \"port.cache-params\"    \/**< cache the node port params *\/\n+#define PW_KEY_PORT_EXTRA        \"port.extra\"        \/**< api specific extra port info, API name\n+                                  *  should be prefixed. \"jack:flags:56\" *\/\n+#define PW_KEY_PORT_PASSIVE        \"port.passive\"        \/**< the ports wants passive links, since 0.3.67 *\/\n+\n+\/** link properties *\/\n+#define PW_KEY_LINK_ID            \"link.id\"        \/**< a link id *\/\n+#define PW_KEY_LINK_INPUT_NODE        \"link.input.node\"    \/**< input node id of a link *\/\n+#define PW_KEY_LINK_INPUT_PORT        \"link.input.port\"    \/**< input port id of a link *\/\n+#define PW_KEY_LINK_OUTPUT_NODE        \"link.output.node\"    \/**< output node id of a link *\/\n+#define PW_KEY_LINK_OUTPUT_PORT        \"link.output.port\"    \/**< output port id of a link *\/\n+#define PW_KEY_LINK_PASSIVE        \"link.passive\"        \/**< indicate that a link is passive and\n+                                  *  does not cause the graph to be\n+                                  *  runnable. *\/\n+#define PW_KEY_LINK_FEEDBACK        \"link.feedback\"        \/**< indicate that a link is a feedback\n+                                  *  link and the target will receive data\n+                                  *  in the next cycle *\/\n+\n+\/** device properties *\/\n+#define PW_KEY_DEVICE_ID        \"device.id\"        \/**< device id *\/\n+#define PW_KEY_DEVICE_NAME        \"device.name\"        \/**< device name *\/\n+#define PW_KEY_DEVICE_PLUGGED        \"device.plugged\"    \/**< when the device was created. As a uint64 in\n+                                  *  nanoseconds. *\/\n+#define PW_KEY_DEVICE_NICK        \"device.nick\"        \/**< a short device nickname *\/\n+#define PW_KEY_DEVICE_STRING        \"device.string\"        \/**< device string in the underlying layer's\n+                                  *  format. Ex. \"surround51:0\" *\/\n+#define PW_KEY_DEVICE_API        \"device.api\"        \/**< API this device is accessed with.\n+                                  *  Ex. \"alsa\", \"v4l2\" *\/\n+#define PW_KEY_DEVICE_DESCRIPTION    \"device.description\"    \/**< localized human readable device one-line\n+                                  *  description. Ex. \"Foobar USB Headset\" *\/\n+#define PW_KEY_DEVICE_BUS_PATH        \"device.bus-path\"    \/**< bus path to the device in the OS'\n+                                  *  format. Ex. \"pci-0000:00:14.0-usb-0:3.2:1.0\" *\/\n+#define PW_KEY_DEVICE_SERIAL        \"device.serial\"        \/**< Serial number if applicable *\/\n+#define PW_KEY_DEVICE_VENDOR_ID        \"device.vendor.id\"    \/**< vendor ID if applicable *\/\n+#define PW_KEY_DEVICE_VENDOR_NAME    \"device.vendor.name\"    \/**< vendor name if applicable *\/\n+#define PW_KEY_DEVICE_PRODUCT_ID    \"device.product.id\"    \/**< product ID if applicable *\/\n+#define PW_KEY_DEVICE_PRODUCT_NAME    \"device.product.name\"    \/**< product name if applicable *\/\n+#define PW_KEY_DEVICE_CLASS        \"device.class\"        \/**< device class *\/\n+#define PW_KEY_DEVICE_FORM_FACTOR    \"device.form-factor\"    \/**< form factor if applicable. One of\n+                                  *  \"internal\", \"speaker\", \"handset\", \"tv\",\n+                                  *  \"webcam\", \"microphone\", \"headset\",\n+                                  *  \"headphone\", \"hands-free\", \"car\", \"hifi\",\n+                                  *  \"computer\", \"portable\" *\/\n+#define PW_KEY_DEVICE_BUS        \"device.bus\"        \/**< bus of the device if applicable. One of\n+                                  *  \"isa\", \"pci\", \"usb\", \"firewire\",\n+                                  *  \"bluetooth\" *\/\n+#define PW_KEY_DEVICE_SUBSYSTEM        \"device.subsystem\"    \/**< device subsystem *\/\n+#define PW_KEY_DEVICE_SYSFS_PATH    \"device.sysfs.path\"    \/**< device sysfs path *\/\n+#define PW_KEY_DEVICE_ICON        \"device.icon\"        \/**< icon for the device. A base64 blob\n+                                  *  containing PNG image data *\/\n+#define PW_KEY_DEVICE_ICON_NAME        \"device.icon-name\"    \/**< an XDG icon name for the device.\n+                                  *  Ex. \"sound-card-speakers-usb\" *\/\n+#define PW_KEY_DEVICE_INTENDED_ROLES    \"device.intended-roles\"    \/**< intended use. A space separated list of\n+                                  *  roles (see PW_KEY_MEDIA_ROLE) this device\n+                                  *  is particularly well suited for, due to\n+                                  *  latency, quality or form factor. *\/\n+#define PW_KEY_DEVICE_CACHE_PARAMS    \"device.cache-params\"    \/**< cache the device spa params *\/\n+\n+\/** module properties *\/\n+#define PW_KEY_MODULE_ID        \"module.id\"        \/**< the module id *\/\n+#define PW_KEY_MODULE_NAME        \"module.name\"        \/**< the name of the module *\/\n+#define PW_KEY_MODULE_AUTHOR        \"module.author\"        \/**< the author's name *\/\n+#define PW_KEY_MODULE_DESCRIPTION    \"module.description\"    \/**< a human readable one-line description\n+                                  *  of the module's purpose.*\/\n+#define PW_KEY_MODULE_USAGE        \"module.usage\"        \/**< a human readable usage description of\n+                                  *  the module's arguments. *\/\n+#define PW_KEY_MODULE_VERSION        \"module.version\"    \/**< a version string for the module. *\/\n+\n+\/** Factory properties *\/\n+#define PW_KEY_FACTORY_ID        \"factory.id\"        \/**< the factory id *\/\n+#define PW_KEY_FACTORY_NAME        \"factory.name\"        \/**< the name of the factory *\/\n+#define PW_KEY_FACTORY_USAGE        \"factory.usage\"        \/**< the usage of the factory *\/\n+#define PW_KEY_FACTORY_TYPE_NAME    \"factory.type.name\"    \/**< the name of the type created by a factory *\/\n+#define PW_KEY_FACTORY_TYPE_VERSION    \"factory.type.version\"    \/**< the version of the type created by a factory *\/\n+\n+\/** Stream properties *\/\n+#define PW_KEY_STREAM_IS_LIVE        \"stream.is-live\"    \/**< Indicates that the stream is live. *\/\n+#define PW_KEY_STREAM_LATENCY_MIN    \"stream.latency.min\"    \/**< The minimum latency of the stream. *\/\n+#define PW_KEY_STREAM_LATENCY_MAX    \"stream.latency.max\"    \/**< The maximum latency of the stream *\/\n+#define PW_KEY_STREAM_MONITOR        \"stream.monitor\"    \/**< Indicates that the stream is monitoring\n+                                  *  and might select a less accurate but faster\n+                                  *  conversion algorithm. *\/\n+#define PW_KEY_STREAM_DONT_REMIX    \"stream.dont-remix\"    \/**< don't remix channels *\/\n+#define PW_KEY_STREAM_CAPTURE_SINK    \"stream.capture.sink\"    \/**< Try to capture the sink output instead of\n+                                  *  source output *\/\n+\n+\/** Media *\/\n+#define PW_KEY_MEDIA_TYPE        \"media.type\"        \/**< Media type, one of\n+                                  *  Audio, Video, Midi *\/\n+#define PW_KEY_MEDIA_CATEGORY        \"media.category\"    \/**< Media Category:\n+                                  *  Playback, Capture, Duplex, Monitor, Manager *\/\n+#define PW_KEY_MEDIA_ROLE        \"media.role\"        \/**< Role: Movie, Music, Camera,\n+                                  *  Screen, Communication, Game,\n+                                  *  Notification, DSP, Production,\n+                                  *  Accessibility, Test *\/\n+#define PW_KEY_MEDIA_CLASS        \"media.class\"        \/**< class Ex: \"Video\/Source\" *\/\n+#define PW_KEY_MEDIA_NAME        \"media.name\"        \/**< media name. Ex: \"Pink Floyd: Time\" *\/\n+#define PW_KEY_MEDIA_TITLE        \"media.title\"        \/**< title. Ex: \"Time\" *\/\n+#define PW_KEY_MEDIA_ARTIST        \"media.artist\"        \/**< artist. Ex: \"Pink Floyd\" *\/\n+#define PW_KEY_MEDIA_COPYRIGHT        \"media.copyright\"    \/**< copyright string *\/\n+#define PW_KEY_MEDIA_SOFTWARE        \"media.software\"    \/**< generator software *\/\n+#define PW_KEY_MEDIA_LANGUAGE        \"media.language\"    \/**< language in POSIX format. Ex: en_GB *\/\n+#define PW_KEY_MEDIA_FILENAME        \"media.filename\"    \/**< filename *\/\n+#define PW_KEY_MEDIA_ICON        \"media.icon\"        \/**< icon for the media, a base64 blob with\n+                                  *  PNG image data *\/\n+#define PW_KEY_MEDIA_ICON_NAME        \"media.icon-name\"    \/**< an XDG icon name for the media.\n+                                  *  Ex: \"audio-x-mp3\" *\/\n+#define PW_KEY_MEDIA_COMMENT        \"media.comment\"        \/**< extra comment *\/\n+#define PW_KEY_MEDIA_DATE        \"media.date\"        \/**< date of the media *\/\n+#define PW_KEY_MEDIA_FORMAT        \"media.format\"        \/**< format of the media *\/\n+\n+\/** format related properties *\/\n+#define PW_KEY_FORMAT_DSP        \"format.dsp\"        \/**< a dsp format.\n+                                  *  Ex: \"32 bit float mono audio\" *\/\n+\/** audio related properties *\/\n+#define PW_KEY_AUDIO_CHANNEL        \"audio.channel\"        \/**< an audio channel. Ex: \"FL\" *\/\n+#define PW_KEY_AUDIO_RATE        \"audio.rate\"        \/**< an audio samplerate *\/\n+#define PW_KEY_AUDIO_CHANNELS        \"audio.channels\"    \/**< number of audio channels *\/\n+#define PW_KEY_AUDIO_FORMAT        \"audio.format\"        \/**< an audio format. Ex: \"S16LE\" *\/\n+#define PW_KEY_AUDIO_ALLOWED_RATES    \"audio.allowed-rates\"    \/**< a list of allowed samplerates\n+                                  *  ex. \"[ 44100 48000 ]\" *\/\n+\n+\/** video related properties *\/\n+#define PW_KEY_VIDEO_RATE        \"video.framerate\"    \/**< a video framerate *\/\n+#define PW_KEY_VIDEO_FORMAT        \"video.format\"        \/**< a video format *\/\n+#define PW_KEY_VIDEO_SIZE        \"video.size\"        \/**< a video size as \"<width>x<height\" *\/\n+\n+#define PW_KEY_TARGET_OBJECT        \"target.object\"        \/**< a target object to link to. This can be\n+                                  * and object name or object.serial *\/\n+\n+#ifndef PW_REMOVE_DEPRECATED\n+# ifdef PW_ENABLE_DEPRECATED\n+#  define PW_KEY_PRIORITY_MASTER    \"priority.master\"    \/**< deprecated, use priority.driver *\/\n+#  define PW_KEY_NODE_TARGET        \"node.target\"        \/**< deprecated since 0.3.64, use target.object. *\/\n+# else\n+#  define PW_KEY_PRIORITY_MASTER    PW_DEPRECATED(\"priority.master\")\n+#  define PW_KEY_NODE_TARGET        PW_DEPRECATED(\"node.target\")\n+# endif \/* PW_ENABLE_DEPRECATED *\/\n+#endif \/* PW_REMOVE_DEPRECATED *\/\n+\n+\/** \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_KEYS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/keys.h","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_LOOP_H\n+#define PIPEWIRE_LOOP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/support\/loop.h>\n+#include <spa\/utils\/dict.h>\n+\n+\/** \\defgroup pw_loop Loop\n+ *\n+ * PipeWire loop object provides an implementation of\n+ * the spa loop interfaces. It can be used to implement various\n+ * event loops.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_loop\n+ * \\{\n+ *\/\n+\n+struct pw_loop {\n+    struct spa_system *system;        \/**< system utils *\/\n+    struct spa_loop *loop;            \/**< wrapped loop *\/\n+    struct spa_loop_control *control;    \/**< loop control *\/\n+    struct spa_loop_utils *utils;        \/**< loop utils *\/\n+};\n+\n+struct pw_loop *\n+pw_loop_new(const struct spa_dict *props);\n+\n+void\n+pw_loop_destroy(struct pw_loop *loop);\n+\n+#define pw_loop_add_source(l,...)    spa_loop_add_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_update_source(l,...)    spa_loop_update_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_remove_source(l,...)    spa_loop_remove_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_invoke(l,...)        spa_loop_invoke((l)->loop,__VA_ARGS__)\n+\n+#define pw_loop_get_fd(l)        spa_loop_control_get_fd((l)->control)\n+#define pw_loop_add_hook(l,...)        spa_loop_control_add_hook((l)->control,__VA_ARGS__)\n+#define pw_loop_enter(l)        spa_loop_control_enter((l)->control)\n+#define pw_loop_iterate(l,...)        spa_loop_control_iterate((l)->control,__VA_ARGS__)\n+#define pw_loop_leave(l)        spa_loop_control_leave((l)->control)\n+\n+#define pw_loop_add_io(l,...)        spa_loop_utils_add_io((l)->utils,__VA_ARGS__)\n+#define pw_loop_update_io(l,...)    spa_loop_utils_update_io((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_idle(l,...)        spa_loop_utils_add_idle((l)->utils,__VA_ARGS__)\n+#define pw_loop_enable_idle(l,...)    spa_loop_utils_enable_idle((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_event(l,...)    spa_loop_utils_add_event((l)->utils,__VA_ARGS__)\n+#define pw_loop_signal_event(l,...)    spa_loop_utils_signal_event((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_timer(l,...)    spa_loop_utils_add_timer((l)->utils,__VA_ARGS__)\n+#define pw_loop_update_timer(l,...)    spa_loop_utils_update_timer((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_signal(l,...)    spa_loop_utils_add_signal((l)->utils,__VA_ARGS__)\n+#define pw_loop_destroy_source(l,...)    spa_loop_utils_destroy_source((l)->utils,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_LOOP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/loop.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PORT_H\n+#define PIPEWIRE_PORT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <errno.h>\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+#include <spa\/param\/param.h>\n+\n+#include <pipewire\/proxy.h>\n+\n+\/** \\defgroup pw_port Port\n+ * Port interface\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_port\n+ * \\{\n+ *\/\n+\n+#define PW_TYPE_INTERFACE_Port    PW_TYPE_INFO_INTERFACE_BASE \"Port\"\n+\n+#define PW_VERSION_PORT        3\n+struct pw_port;\n+\n+\/** The direction of a port *\/\n+#define pw_direction spa_direction\n+#define PW_DIRECTION_INPUT SPA_DIRECTION_INPUT\n+#define PW_DIRECTION_OUTPUT SPA_DIRECTION_OUTPUT\n+\n+\/** Convert a \\ref pw_direction to a readable string *\/\n+const char * pw_direction_as_string(enum pw_direction direction);\n+\n+struct pw_port_info {\n+    uint32_t id;                \/**< id of the global *\/\n+    enum pw_direction direction;        \/**< port direction *\/\n+#define PW_PORT_CHANGE_MASK_PROPS        (1 << 0)\n+#define PW_PORT_CHANGE_MASK_PARAMS        (1 << 1)\n+#define PW_PORT_CHANGE_MASK_ALL            ((1 << 2)-1)\n+    uint64_t change_mask;            \/**< bitfield of changed fields since last call *\/\n+    struct spa_dict *props;            \/**< the properties of the port *\/\n+    struct spa_param_info *params;        \/**< parameters *\/\n+    uint32_t n_params;            \/**< number of items in \\a params *\/\n+};\n+\n+struct pw_port_info *\n+pw_port_info_update(struct pw_port_info *info,\n+        const struct pw_port_info *update);\n+\n+struct pw_port_info *\n+pw_port_info_merge(struct pw_port_info *info,\n+        const struct pw_port_info *update, bool reset);\n+\n+void\n+pw_port_info_free(struct pw_port_info *info);\n+\n+#define PW_PORT_EVENT_INFO    0\n+#define PW_PORT_EVENT_PARAM    1\n+#define PW_PORT_EVENT_NUM    2\n+\n+\/** Port events *\/\n+struct pw_port_events {\n+#define PW_VERSION_PORT_EVENTS    0\n+    uint32_t version;\n+    \/**\n+     * Notify port info\n+     *\n+     * \\param info info about the port\n+     *\/\n+    void (*info) (void *data, const struct pw_port_info *info);\n+    \/**\n+     * Notify a port param\n+     *\n+     * Event emitted as a result of the enum_params method.\n+     *\n+     * \\param seq the sequence number of the request\n+     * \\param id the param id\n+     * \\param index the param index\n+     * \\param next the param index of the next param\n+     * \\param param the parameter\n+     *\/\n+    void (*param) (void *data, int seq,\n+               uint32_t id, uint32_t index, uint32_t next,\n+               const struct spa_pod *param);\n+};\n+\n+#define PW_PORT_METHOD_ADD_LISTENER    0\n+#define PW_PORT_METHOD_SUBSCRIBE_PARAMS    1\n+#define PW_PORT_METHOD_ENUM_PARAMS    2\n+#define PW_PORT_METHOD_NUM        3\n+\n+\/** Port methods *\/\n+struct pw_port_methods {\n+#define PW_VERSION_PORT_METHODS        0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_port_events *events,\n+            void *data);\n+    \/**\n+     * Subscribe to parameter changes\n+     *\n+     * Automatically emit param events for the given ids when\n+     * they are changed.\n+     *\n+     * \\param ids an array of param ids\n+     * \\param n_ids the number of ids in \\a ids\n+     *\/\n+    int (*subscribe_params) (void *object, uint32_t *ids, uint32_t n_ids);\n+\n+    \/**\n+     * Enumerate port parameters\n+     *\n+     * Start enumeration of port parameters. For each param, a\n+     * param event will be emitted.\n+     *\n+     * \\param seq a sequence number returned in the reply\n+     * \\param id the parameter id to enumerate\n+     * \\param start the start index or 0 for the first param\n+     * \\param num the maximum number of params to retrieve\n+     * \\param filter a param filter or NULL\n+     *\/\n+    int (*enum_params) (void *object, int seq,\n+            uint32_t id, uint32_t start, uint32_t num,\n+            const struct spa_pod *filter);\n+};\n+\n+#define pw_port_method(o,method,version,...)                \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_port_methods, _res,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define pw_port_add_listener(c,...)    pw_port_method(c,add_listener,0,__VA_ARGS__)\n+#define pw_port_subscribe_params(c,...)    pw_port_method(c,subscribe_params,0,__VA_ARGS__)\n+#define pw_port_enum_params(c,...)    pw_port_method(c,enum_params,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_PORT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/port.h","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROPERTIES_H\n+#define PIPEWIRE_PROPERTIES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+\n+#include <spa\/utils\/dict.h>\n+#include <spa\/utils\/string.h>\n+\n+\/** \\defgroup pw_properties Properties\n+ *\n+ * Properties are used to pass around arbitrary key\/value pairs.\n+ * Both keys and values are strings which keeps things simple.\n+ * Encoding of arbitrary values should be done by using a string\n+ * serialization such as base64 for binary blobs.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_properties\n+ * \\{\n+ *\/\n+struct pw_properties {\n+    struct spa_dict dict;    \/**< dictionary of key\/values *\/\n+    uint32_t flags;        \/**< extra flags *\/\n+};\n+\n+struct pw_properties *\n+pw_properties_new(const char *key, ...) SPA_SENTINEL;\n+\n+struct pw_properties *\n+pw_properties_new_dict(const struct spa_dict *dict);\n+\n+struct pw_properties *\n+pw_properties_new_string(const char *args);\n+\n+struct pw_properties *\n+pw_properties_copy(const struct pw_properties *properties);\n+\n+int pw_properties_update_keys(struct pw_properties *props,\n+             const struct spa_dict *dict, const char * const keys[]);\n+int pw_properties_update_ignore(struct pw_properties *props,\n+        const struct spa_dict *dict, const char * const ignore[]);\n+\n+\/* Update props with all key\/value pairs from dict *\/\n+int pw_properties_update(struct pw_properties *props,\n+             const struct spa_dict *dict);\n+\/* Update props with all key\/value pairs from str *\/\n+int pw_properties_update_string(struct pw_properties *props,\n+        const char *str, size_t size);\n+\n+int pw_properties_add(struct pw_properties *oldprops,\n+             const struct spa_dict *dict);\n+int pw_properties_add_keys(struct pw_properties *oldprops,\n+             const struct spa_dict *dict, const char * const keys[]);\n+\n+void pw_properties_clear(struct pw_properties *properties);\n+\n+void\n+pw_properties_free(struct pw_properties *properties);\n+\n+int\n+pw_properties_set(struct pw_properties *properties, const char *key, const char *value);\n+\n+int\n+pw_properties_setf(struct pw_properties *properties,\n+           const char *key, const char *format, ...) SPA_PRINTF_FUNC(3, 4);\n+int\n+pw_properties_setva(struct pw_properties *properties,\n+           const char *key, const char *format, va_list args) SPA_PRINTF_FUNC(3,0);\n+const char *\n+pw_properties_get(const struct pw_properties *properties, const char *key);\n+\n+int\n+pw_properties_fetch_uint32(const struct pw_properties *properties, const char *key, uint32_t *value);\n+\n+int\n+pw_properties_fetch_int32(const struct pw_properties *properties, const char *key, int32_t *value);\n+\n+int\n+pw_properties_fetch_uint64(const struct pw_properties *properties, const char *key, uint64_t *value);\n+\n+int\n+pw_properties_fetch_int64(const struct pw_properties *properties, const char *key, int64_t *value);\n+\n+int\n+pw_properties_fetch_bool(const struct pw_properties *properties, const char *key, bool *value);\n+\n+static inline uint32_t\n+pw_properties_get_uint32(const struct pw_properties *properties, const char *key, uint32_t deflt)\n+{\n+    uint32_t val = deflt;\n+    pw_properties_fetch_uint32(properties, key, &val);\n+    return val;\n+}\n+\n+static inline int32_t\n+pw_properties_get_int32(const struct pw_properties *properties, const char *key, int32_t deflt)\n+{\n+    int32_t val = deflt;\n+    pw_properties_fetch_int32(properties, key, &val);\n+    return val;\n+}\n+\n+static inline uint64_t\n+pw_properties_get_uint64(const struct pw_properties *properties, const char *key, uint64_t deflt)\n+{\n+    uint64_t val = deflt;\n+    pw_properties_fetch_uint64(properties, key, &val);\n+    return val;\n+}\n+\n+static inline int64_t\n+pw_properties_get_int64(const struct pw_properties *properties, const char *key, int64_t deflt)\n+{\n+    int64_t val = deflt;\n+    pw_properties_fetch_int64(properties, key, &val);\n+    return val;\n+}\n+\n+\n+static inline bool\n+pw_properties_get_bool(const struct pw_properties *properties, const char *key, bool deflt)\n+{\n+    bool val = deflt;\n+    pw_properties_fetch_bool(properties, key, &val);\n+    return val;\n+}\n+\n+const char *\n+pw_properties_iterate(const struct pw_properties *properties, void **state);\n+\n+#define PW_PROPERTIES_FLAG_NL    (1<<0)\n+int pw_properties_serialize_dict(FILE *f, const struct spa_dict *dict, uint32_t flags);\n+\n+static inline bool pw_properties_parse_bool(const char *value) {\n+    return spa_atob(value);\n+}\n+\n+static inline int pw_properties_parse_int(const char *value) {\n+    int v;\n+    return spa_atoi32(value, &v, 0) ? v: 0;\n+}\n+\n+static inline int64_t pw_properties_parse_int64(const char *value) {\n+    int64_t v;\n+    return spa_atoi64(value, &v, 0) ? v : 0;\n+}\n+\n+static inline uint64_t pw_properties_parse_uint64(const char *value) {\n+    uint64_t v;\n+    return spa_atou64(value, &v, 0) ? v : 0;\n+}\n+\n+static inline float pw_properties_parse_float(const char *value) {\n+    float v;\n+    return spa_atof(value, &v) ? v : 0.0f;\n+}\n+\n+static inline double pw_properties_parse_double(const char *value) {\n+    double v;\n+    return spa_atod(value, &v) ? v : 0.0;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_PROPERTIES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/properties.h","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROTOCOL_H\n+#define PIPEWIRE_PROTOCOL_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/list.h>\n+\n+\/** \\defgroup pw_protocol Protocol\n+ *\n+ * \\brief Manages protocols and their implementation\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_protocol\n+ * \\{\n+ *\/\n+\n+struct pw_protocol;\n+\n+#include <pipewire\/context.h>\n+#include <pipewire\/properties.h>\n+#include <pipewire\/utils.h>\n+\n+#define PW_TYPE_INFO_Protocol        \"PipeWire:Protocol\"\n+#define PW_TYPE_INFO_PROTOCOL_BASE    PW_TYPE_INFO_Protocol \":\"\n+\n+struct pw_protocol_client {\n+    struct spa_list link;        \/**< link in protocol client_list *\/\n+    struct pw_protocol *protocol;    \/**< the owner protocol *\/\n+\n+    struct pw_core *core;\n+\n+    int (*connect) (struct pw_protocol_client *client,\n+            const struct spa_dict *props,\n+            void (*done_callback) (void *data, int result),\n+            void *data);\n+    int (*connect_fd) (struct pw_protocol_client *client, int fd, bool close);\n+    int (*steal_fd) (struct pw_protocol_client *client);\n+    void (*disconnect) (struct pw_protocol_client *client);\n+    void (*destroy) (struct pw_protocol_client *client);\n+    int (*set_paused) (struct pw_protocol_client *client, bool paused);\n+};\n+\n+#define pw_protocol_client_connect(c,p,cb,d)    ((c)->connect(c,p,cb,d))\n+#define pw_protocol_client_connect_fd(c,fd,cl)    ((c)->connect_fd(c,fd,cl))\n+#define pw_protocol_client_steal_fd(c)        ((c)->steal_fd(c))\n+#define pw_protocol_client_disconnect(c)    ((c)->disconnect(c))\n+#define pw_protocol_client_destroy(c)        ((c)->destroy(c))\n+#define pw_protocol_client_set_paused(c,p)    ((c)->set_paused(c,p))\n+\n+struct pw_protocol_server {\n+    struct spa_list link;        \/**< link in protocol server_list *\/\n+    struct pw_protocol *protocol;    \/**< the owner protocol *\/\n+\n+    struct pw_impl_core *core;\n+\n+    struct spa_list client_list;    \/**< list of clients of this protocol *\/\n+\n+    void (*destroy) (struct pw_protocol_server *listen);\n+};\n+\n+#define pw_protocol_server_destroy(l)    ((l)->destroy(l))\n+\n+struct pw_protocol_marshal {\n+    const char *type;        \/**< interface type *\/\n+    uint32_t version;        \/**< version *\/\n+#define PW_PROTOCOL_MARSHAL_FLAG_IMPL    (1 << 0)    \/**< marshal for implementations *\/\n+    uint32_t flags;            \/**< version *\/\n+    uint32_t n_client_methods;    \/**< number of client methods *\/\n+    uint32_t n_server_methods;    \/**< number of server methods *\/\n+    const void *client_marshal;\n+    const void *server_demarshal;\n+    const void *server_marshal;\n+    const void *client_demarshal;\n+};\n+\n+struct pw_protocol_implementation {\n+#define PW_VERSION_PROTOCOL_IMPLEMENTATION    0\n+    uint32_t version;\n+\n+    struct pw_protocol_client * (*new_client) (struct pw_protocol *protocol,\n+                           struct pw_core *core,\n+                           const struct spa_dict *props);\n+    struct pw_protocol_server * (*add_server) (struct pw_protocol *protocol,\n+                           struct pw_impl_core *core,\n+                           const struct spa_dict *props);\n+};\n+\n+struct pw_protocol_events {\n+#define PW_VERSION_PROTOCOL_EVENTS        0\n+    uint32_t version;\n+\n+    void (*destroy) (void *data);\n+};\n+\n+#define pw_protocol_new_client(p,...)    (pw_protocol_get_implementation(p)->new_client(p,__VA_ARGS__))\n+#define pw_protocol_add_server(p,...)    (pw_protocol_get_implementation(p)->add_server(p,__VA_ARGS__))\n+#define pw_protocol_ext(p,type,method,...)    (((type*)pw_protocol_get_extension(p))->method( __VA_ARGS__))\n+\n+struct pw_protocol *pw_protocol_new(struct pw_context *context, const char *name, size_t user_data_size);\n+\n+void pw_protocol_destroy(struct pw_protocol *protocol);\n+\n+struct pw_context *pw_protocol_get_context(struct pw_protocol *protocol);\n+\n+void *pw_protocol_get_user_data(struct pw_protocol *protocol);\n+\n+const struct pw_protocol_implementation *\n+pw_protocol_get_implementation(struct pw_protocol *protocol);\n+\n+const void *\n+pw_protocol_get_extension(struct pw_protocol *protocol);\n+\n+\n+void pw_protocol_add_listener(struct pw_protocol *protocol,\n+                              struct spa_hook *listener,\n+                              const struct pw_protocol_events *events,\n+                              void *data);\n+\n+int pw_protocol_add_marshal(struct pw_protocol *protocol,\n+                const struct pw_protocol_marshal *marshal);\n+\n+const struct pw_protocol_marshal *\n+pw_protocol_get_marshal(struct pw_protocol *protocol, const char *type, uint32_t version, uint32_t flags);\n+\n+struct pw_protocol * pw_context_find_protocol(struct pw_context *context, const char *name);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_PROTOCOL_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/protocol.h","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROXY_H\n+#define PIPEWIRE_PROXY_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\page page_proxy Proxy\n+ *\n+ * \\section sec_page_proxy_overview Overview\n+ *\n+ * The proxy object is a client side representation of a resource\n+ * that lives on a remote PipeWire instance.\n+ *\n+ * It is used to communicate with the remote object.\n+ *\n+ * \\section sec_page_proxy_core Core proxy\n+ *\n+ * A proxy for a remote core object can be obtained by making\n+ * a remote connection with \\ref pw_context_connect.\n+ * See \\ref pw_proxy\n+ *\n+ * Some methods on proxy object allow creation of more proxy objects or\n+ * create a binding between a local proxy and global resource.\n+ *\n+ * \\section sec_page_proxy_create Create\n+ *\n+ * A client first creates a new proxy object with pw_proxy_new(). A\n+ * type must be provided for this object.\n+ *\n+ * The protocol of the context will usually install an interface to\n+ * translate method calls and events to the wire format.\n+ *\n+ * The creator of the proxy will usually also install an event\n+ * implementation of the particular object type.\n+ *\n+ * \\section sec_page_proxy_bind Bind\n+ *\n+ * To actually use the proxy object, one needs to create a server\n+ * side resource for it. This can be done by, for example, binding\n+ * to a global object or by calling a method that creates and binds\n+ * to a new remote object. In all cases, the local id is passed to\n+ * the server and is used to create a resource with the same id.\n+ *\n+ * \\section sec_page_proxy_methods Methods\n+ *\n+ * To call a method on the proxy use the interface methods. Calling\n+ * any interface method will result in a request to the server to\n+ * perform the requested action on the corresponding resource.\n+ *\n+ * \\section sec_page_proxy_events Events\n+ *\n+ * Events send from the server to the proxy will be demarshalled by\n+ * the protocol and will then result in a call to the installed\n+ * implementation of the proxy.\n+ *\n+ * \\section sec_page_proxy_destroy Destroy\n+ *\n+ * Use pw_proxy_destroy() to destroy the client side object. This\n+ * is usually done automatically when the server removes the resource\n+ * associated to the proxy.\n+ *\/\n+\n+\/** \\defgroup pw_proxy Proxy\n+ *\n+ * \\brief Represents an object on the client side.\n+ *\n+ * A pw_proxy acts as a client side proxy to an object existing in a remote\n+ * pipewire instance. The proxy is responsible for converting interface functions\n+ * invoked by the client to PipeWire messages. Events will call the handlers\n+ * set in listener.\n+ *\n+ * See \\ref page_proxy\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_proxy\n+ * \\{\n+ *\/\n+struct pw_proxy;\n+\n+#include <pipewire\/protocol.h>\n+\n+\/** Proxy events, use \\ref pw_proxy_add_listener *\/\n+struct pw_proxy_events {\n+#define PW_VERSION_PROXY_EVENTS        1\n+        uint32_t version;\n+\n+    \/** The proxy is destroyed *\/\n+        void (*destroy) (void *data);\n+\n+    \/** a proxy is bound to a global id *\/\n+        void (*bound) (void *data, uint32_t global_id);\n+\n+    \/** a proxy is removed from the server. Use pw_proxy_destroy to\n+     * free the proxy. *\/\n+        void (*removed) (void *data);\n+\n+    \/** a reply to a sync method completed *\/\n+        void (*done) (void *data, int seq);\n+\n+    \/** an error occurred on the proxy *\/\n+        void (*error) (void *data, int seq, int res, const char *message);\n+\n+        void (*bound_props) (void *data, uint32_t global_id, const struct spa_dict *props);\n+};\n+\n+\/* Make a new proxy object. The id can be used to bind to a remote object and\n+ * can be retrieved with \\ref pw_proxy_get_id . *\/\n+struct pw_proxy *\n+pw_proxy_new(struct pw_proxy *factory,\n+         const char *type,        \/* interface type *\/\n+         uint32_t version,        \/* interface version *\/\n+         size_t user_data_size    \/* size of user data *\/);\n+\n+\/** Add an event listener to proxy *\/\n+void pw_proxy_add_listener(struct pw_proxy *proxy,\n+               struct spa_hook *listener,\n+               const struct pw_proxy_events *events,\n+               void *data);\n+\n+\/** Add a listener for the events received from the remote object. The\n+  * events depend on the type of the remote object type. *\/\n+void pw_proxy_add_object_listener(struct pw_proxy *proxy,    \/**< the proxy *\/\n+                 struct spa_hook *listener,    \/**< listener *\/\n+                 const void *funcs,        \/**< proxied functions *\/\n+                 void *data            \/**< data passed to events *\/);\n+\n+\/** destroy a proxy *\/\n+void pw_proxy_destroy(struct pw_proxy *proxy);\n+\n+void pw_proxy_ref(struct pw_proxy *proxy);\n+void pw_proxy_unref(struct pw_proxy *proxy);\n+\n+\/** Get the user_data. The size was given in \\ref pw_proxy_new *\/\n+void *pw_proxy_get_user_data(struct pw_proxy *proxy);\n+\n+\/** Get the local id of the proxy *\/\n+uint32_t pw_proxy_get_id(struct pw_proxy *proxy);\n+\n+\/** Get the type and version of the proxy *\/\n+const char *pw_proxy_get_type(struct pw_proxy *proxy, uint32_t *version);\n+\n+\/** Get the protocol used for the proxy *\/\n+struct pw_protocol *pw_proxy_get_protocol(struct pw_proxy *proxy);\n+\n+\/** Generate an sync method for a proxy. This will generate a done event\n+ * with the same seq number of the reply. *\/\n+int pw_proxy_sync(struct pw_proxy *proxy, int seq);\n+\n+\/** Set the global id this proxy is bound to. This is usually used internally\n+ * and will also emit the bound event *\/\n+int pw_proxy_set_bound_id(struct pw_proxy *proxy, uint32_t global_id);\n+\/** Get the global id bound to this proxy of SPA_ID_INVALID when not bound\n+ * to a global *\/\n+uint32_t pw_proxy_get_bound_id(struct pw_proxy *proxy);\n+\n+\/** Generate an error for a proxy *\/\n+int pw_proxy_error(struct pw_proxy *proxy, int res, const char *error);\n+int pw_proxy_errorf(struct pw_proxy *proxy, int res, const char *error, ...) SPA_PRINTF_FUNC(3, 4);\n+\n+\/** Get the listener of proxy *\/\n+struct spa_hook_list *pw_proxy_get_object_listeners(struct pw_proxy *proxy);\n+\n+\/** Get the marshal functions for the proxy *\/\n+const struct pw_protocol_marshal *pw_proxy_get_marshal(struct pw_proxy *proxy);\n+\n+\/** Install a marshal function on a proxy *\/\n+int pw_proxy_install_marshal(struct pw_proxy *proxy, bool implementor);\n+\n+#define pw_proxy_notify(p,type,event,version,...)            \\\n+    spa_hook_list_call(pw_proxy_get_object_listeners(p),        \\\n+            type, event, version, ## __VA_ARGS__)\n+\n+#define pw_proxy_call(p,type,method,version,...)            \\\n+    spa_interface_call((struct spa_interface*)p,            \\\n+            type, method, version, ##__VA_ARGS__)\n+\n+#define pw_proxy_call_res(p,type,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)p,        \\\n+            type, _res, method, version, ##__VA_ARGS__);    \\\n+    _res;                                \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_PROXY_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/proxy.h","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,509 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_STREAM_H\n+#define PIPEWIRE_STREAM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\page page_streams Streams\n+ *\n+ * \\section sec_overview Overview\n+ *\n+ * \\ref pw_stream \"Streams\" are used to exchange data with the\n+ * PipeWire server. A stream is a wrapper around a proxy for a pw_client_node\n+ * with an adapter. This means the stream will automatically do conversion\n+ * to the type required by the server.\n+ *\n+ * Streams can be used to:\n+ *\n+ * \\li Consume a stream from PipeWire. This is a PW_DIRECTION_INPUT stream.\n+ * \\li Produce a stream to PipeWire. This is a PW_DIRECTION_OUTPUT stream\n+ *\n+ * You can connect the stream port to a specific server port or let PipeWire\n+ * choose a port for you.\n+ *\n+ * For more complicated nodes such as filters or ports with multiple\n+ * inputs and\/or outputs you will need to use the pw_filter or make\n+ * a pw_node yourself and export it with \\ref pw_core_export.\n+ *\n+ * Streams can also be used to:\n+ *\n+ * \\li Implement a Sink in PipeWire. This is a PW_DIRECTION_INPUT stream.\n+ * \\li Implement a Source in PipeWire. This is a PW_DIRECTION_OUTPUT stream\n+ *\n+ * In this case, the PW_KEY_MEDIA_CLASS property needs to be set to\n+ * \"Audio\/Sink\" or \"Audio\/Source\" respectively.\n+ *\n+ * \\section sec_create Create\n+ *\n+ * Make a new stream with \\ref pw_stream_new(). You will need to specify\n+ * a name for the stream and extra properties. The basic set of properties\n+ * each stream must provide is filled in automatically.\n+ *\n+ * Once the stream is created, the state_changed event should be used to\n+ * track the state of the stream.\n+ *\n+ * \\section sec_connect Connect\n+ *\n+ * The stream is initially unconnected. To connect the stream, use\n+ * \\ref pw_stream_connect(). Pass the desired direction as an argument.\n+ *\n+ * The direction is:\n+\n+ * \\li PW_DIRECTION_INPUT for a stream that *consumes* data. This can be a\n+ * stream that captures from a Source or a when the stream is used to\n+ * implement a Sink.\n+ *\n+ * \\li PW_DIRECTION_OUTPUT for a stream that *produces* data. This can be a\n+ * stream that plays to a Sink or when the stream is used to implement\n+ * a Source.\n+ *\n+ * \\subsection ssec_stream_target Stream target\n+ *\n+ * To make the newly connected stream automatically connect to an existing\n+ * PipeWire node, use the \\ref PW_STREAM_FLAG_AUTOCONNECT and set the\n+ * PW_KEY_OBJECT_SERIAL or the PW_KEY_NODE_NAME value of the target node\n+ * in the PW_KEY_TARGET_OBJECT property before connecting.\n+ *\n+ * \\subsection ssec_stream_formats Stream formats\n+ *\n+ * An array of possible formats that this stream can consume or provide\n+ * must be specified.\n+ *\n+ * \\section sec_format Format negotiation\n+ *\n+ * After connecting the stream, the server will want to configure some\n+ * parameters on the stream. You will be notified of these changes\n+ * with the param_changed event.\n+ *\n+ * When a format param change is emitted, the client should now prepare\n+ * itself to deal with the format and complete the negotiation procedure\n+ * with a call to \\ref pw_stream_update_params().\n+ *\n+ * As arguments to \\ref pw_stream_update_params() an array of spa_param\n+ * structures must be given. They contain parameters such as buffer size,\n+ * number of buffers, required metadata and other parameters for the\n+ * media buffers.\n+ *\n+ * \\section sec_buffers Buffer negotiation\n+ *\n+ * After completing the format negotiation, PipeWire will allocate and\n+ * notify the stream of the buffers that will be used to exchange data\n+ * between client and server.\n+ *\n+ * With the add_buffer event, a stream will be notified of a new buffer\n+ * that can be used for data transport. You can attach user_data to these\n+ * buffers. The buffers can only be used with the stream that emitted\n+ * the add_buffer event.\n+ *\n+ * After the buffers are negotiated, the stream will transition to the\n+ * \\ref PW_STREAM_STATE_PAUSED state.\n+ *\n+ * \\section sec_streaming Streaming\n+ *\n+ * From the \\ref PW_STREAM_STATE_PAUSED state, the stream can be set to\n+ * the \\ref PW_STREAM_STATE_STREAMING state by the PipeWire server when\n+ * data transport is started.\n+ *\n+ * Depending on how the stream was connected it will need to Produce or\n+ * Consume data for\/from PipeWire as explained in the following\n+ * subsections.\n+ *\n+ * \\subsection ssec_consume Consume data\n+ *\n+ * The process event is emitted for each new buffer that can be\n+ * consumed.\n+ *\n+ * \\ref pw_stream_dequeue_buffer() should be used to get the data and\n+ * metadata of the buffer.\n+ *\n+ * The buffer is owned by the stream and stays alive until the\n+ * remove_buffer callback has returned or the stream is destroyed.\n+ *\n+ * When the buffer has been processed, call \\ref pw_stream_queue_buffer()\n+ * to let PipeWire reuse the buffer.\n+ *\n+ * \\subsection ssec_produce Produce data\n+ *\n+ * \\ref pw_stream_dequeue_buffer() gives an empty buffer that can be filled.\n+ *\n+ * The buffer is owned by the stream and stays alive until the\n+ * remove_buffer event is emitted or the stream is destroyed.\n+ *\n+ * Filled buffers should be queued with \\ref pw_stream_queue_buffer().\n+ *\n+ * The process event is emitted when PipeWire has emptied a buffer that\n+ * can now be refilled.\n+ *\n+ * \\section sec_stream_disconnect Disconnect\n+ *\n+ * Use \\ref pw_stream_disconnect() to disconnect a stream after use.\n+ *\n+ * \\section sec_stream_configuration Configuration\n+ *\n+ * \\subsection ssec_config_properties Stream Properties\n+ *\n+ * \\subsection ssec_config_rules Stream Rules\n+ *\n+ * \\section sec_stream_environment Environment Variables\n+ *\n+ *\/\n+\/** \\defgroup pw_stream Stream\n+ *\n+ * \\brief PipeWire stream objects\n+ *\n+ * The stream object provides a convenient way to send and\n+ * receive data streams from\/to PipeWire.\n+ *\n+ * See also \\ref page_streams and \\ref api_pw_core\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_stream\n+ * \\{\n+ *\/\n+struct pw_stream;\n+\n+#include <spa\/buffer\/buffer.h>\n+#include <spa\/param\/param.h>\n+#include <spa\/pod\/command.h>\n+\n+\/** \\enum pw_stream_state The state of a stream *\/\n+enum pw_stream_state {\n+    PW_STREAM_STATE_ERROR = -1,        \/**< the stream is in error *\/\n+    PW_STREAM_STATE_UNCONNECTED = 0,    \/**< unconnected *\/\n+    PW_STREAM_STATE_CONNECTING = 1,        \/**< connection is in progress *\/\n+    PW_STREAM_STATE_PAUSED = 2,        \/**< paused *\/\n+    PW_STREAM_STATE_STREAMING = 3        \/**< streaming *\/\n+};\n+\n+\/** a buffer structure obtained from pw_stream_dequeue_buffer(). The size of this\n+  * structure can grow as more field are added in the future *\/\n+struct pw_buffer {\n+    struct spa_buffer *buffer;    \/**< the spa buffer *\/\n+    void *user_data;        \/**< user data attached to the buffer *\/\n+    uint64_t size;            \/**< This field is set by the user and the sum of\n+                      *  all queued buffer is returned in the time info.\n+                      *  For audio, it is advised to use the number of\n+                      *  samples in the buffer for this field. *\/\n+    uint64_t requested;        \/**< For playback streams, this field contains the\n+                      *  suggested amount of data to provide. For audio\n+                      *  streams this will be the amount of samples\n+                      *  required by the resampler. This field is 0\n+                      *  when no suggestion is provided. Since 0.3.49 *\/\n+};\n+\n+struct pw_stream_control {\n+    const char *name;        \/**< name of the control *\/\n+    uint32_t flags;            \/**< extra flags (unused) *\/\n+    float def;            \/**< default value *\/\n+    float min;            \/**< min value *\/\n+    float max;            \/**< max value *\/\n+    float *values;            \/**< array of values *\/\n+    uint32_t n_values;        \/**< number of values in array *\/\n+    uint32_t max_values;        \/**< max values that can be set on this control *\/\n+};\n+\n+\/** A time structure.\n+ *\n+ * Use pw_stream_get_time_n() to get an updated time snapshot of the stream.\n+ * The time snapshot can give information about the time in the driver of the\n+ * graph, the delay to the edge of the graph and the internal queuing in the\n+ * stream.\n+ *\n+ * pw_time.ticks gives a monotonic increasing counter of the time in the graph\n+ * driver. I can be used to generate a timetime to schedule samples as well\n+ * as detect discontinuities in the timeline caused by xruns.\n+ *\n+ * pw_time.delay is expressed as pw_time.rate, the time domain of the graph. This\n+ * value, and pw_time.ticks, were captured at pw_time.now and can be extrapolated\n+ * to the current time like this:\n+ *\n+ *    struct timespec ts;\n+ *    clock_gettime(CLOCK_MONOTONIC, &ts);\n+ *    int64_t diff = SPA_TIMESPEC_TO_NSEC(&ts) - pw_time.now;\n+ *    int64_t elapsed = (pw_time.rate.denom * diff) \/ (pw_time.rate.num * SPA_NSEC_PER_SEC);\n+ *\n+ * pw_time.delay contains the total delay that a signal will travel through the\n+ * graph. This includes the delay caused by filters in the graph as well as delays\n+ * caused by the hardware. The delay is usually quite stable and should only change when\n+ * the topology, quantum or samplerate of the graph changes.\n+ *\n+ * pw_time.queued and pw_time.buffered is expressed in the time domain of the stream,\n+ * or the format that is used for the buffers of this stream.\n+ *\n+ * pw_time.queued is the sum of all the pw_buffer.size fields of the buffers that are\n+ * currently queued in the stream but not yet processed. The application can choose\n+ * the units of this value, for example, time, samples or bytes (below expressed\n+ * as app.rate).\n+ *\n+ * pw_time.buffered is format dependent, for audio\/raw it contains the number of samples\n+ * that are buffered inside the resampler\/converter.\n+ *\n+ * The total delay of data in a stream is the sum of the queued and buffered data\n+ * (not yet processed data) and the delay to the edge of the graph, usually a\n+ * playback or capture device.\n+ *\n+ * For an audio playback stream, if you were to queue a buffer, the total delay\n+ * in milliseconds for the first sample in the newly queued buffer to be played\n+ * by the hardware can be calculated as:\n+ *\n+ *  (pw_time.buffered * 1000 \/ stream.samplerate) +\n+ *    (pw_time.queued * 1000 \/ app.rate) +\n+ *     ((pw_time.delay - elapsed) * 1000 * pw_time.rate.num \/ pw_time.rate.denom)\n+ *\n+ * The current extrapolated time (in ms) in the source or sink can be calculated as:\n+ *\n+ *  (pw_time.ticks + elapsed) * 1000 * pw_time.rate.num \/ pw_time.rate.denom\n+ *\n+ *\n+ *           stream time domain           graph time domain\n+ *         \/-----------------------\\\/-----------------------------\\\n+ *\n+ * queue     +-+ +-+  +-----------+                 +--------+\n+ * ---->     | | | |->| converter | ->   graph  ->  | kernel | -> speaker\n+ * <----     +-+ +-+  +-----------+                 +--------+\n+ * dequeue   buffers                \\-------------------\/\\--------\/\n+ *                                     graph              internal\n+ *                                    latency             latency\n+ *         \\--------\/\\-------------\/\\-----------------------------\/\n+ *           queued      buffered            delay\n+ *\/\n+struct pw_time {\n+    int64_t now;            \/**< the monotonic time in nanoseconds. This is the time\n+                      *  when this time report was updated. It is usually\n+                      *  updated every graph cycle. You can use the current\n+                      *  monotonic time to calculate the elapsed time between\n+                      *  this report and the current state and calculate\n+                      *  updated ticks and delay values. *\/\n+    struct spa_fraction rate;    \/**< the rate of \\a ticks and delay. This is usually\n+                      *  expressed in 1\/<samplerate>. *\/\n+    uint64_t ticks;            \/**< the ticks at \\a now. This is the current time that\n+                      *  the remote end is reading\/writing. This is monotonicaly\n+                      *  increasing. *\/\n+    int64_t delay;            \/**< delay to device. This is the time it will take for\n+                      *  the next output sample of the stream to be presented by\n+                      *  the playback device or the time a sample traveled\n+                      *  from the capture device. This delay includes the\n+                      *  delay introduced by all filters on the path between\n+                      *  the stream and the device. The delay is normally\n+                      *  constant in a graph and can change when the topology\n+                      *  of the graph or the quantum changes. This delay does\n+                      *  not include the delay caused by queued buffers. *\/\n+    uint64_t queued;        \/**< data queued in the stream, this is the sum\n+                      *  of the size fields in the pw_buffer that are\n+                      *  currently queued *\/\n+    uint64_t buffered;        \/**< for audio\/raw streams, this contains the extra\n+                      *  number of samples buffered in the resampler.\n+                      *  Since 0.3.50. *\/\n+    uint32_t queued_buffers;    \/**< The number of buffers that are queued. Since 0.3.50 *\/\n+    uint32_t avail_buffers;        \/**< The number of buffers that can be dequeued. Since 0.3.50 *\/\n+};\n+\n+#include <pipewire\/port.h>\n+\n+\/** Events for a stream. These events are always called from the mainloop\n+ * unless explicitly documented otherwise. *\/\n+struct pw_stream_events {\n+#define PW_VERSION_STREAM_EVENTS    2\n+    uint32_t version;\n+\n+    void (*destroy) (void *data);\n+    \/** when the stream state changes *\/\n+    void (*state_changed) (void *data, enum pw_stream_state old,\n+                enum pw_stream_state state, const char *error);\n+\n+    \/** Notify information about a control.  *\/\n+    void (*control_info) (void *data, uint32_t id, const struct pw_stream_control *control);\n+\n+    \/** when io changed on the stream. *\/\n+    void (*io_changed) (void *data, uint32_t id, void *area, uint32_t size);\n+    \/** when a parameter changed *\/\n+    void (*param_changed) (void *data, uint32_t id, const struct spa_pod *param);\n+\n+        \/** when a new buffer was created for this stream *\/\n+        void (*add_buffer) (void *data, struct pw_buffer *buffer);\n+        \/** when a buffer was destroyed for this stream *\/\n+        void (*remove_buffer) (void *data, struct pw_buffer *buffer);\n+\n+        \/** when a buffer can be queued (for playback streams) or\n+         *  dequeued (for capture streams). This is normally called from the\n+     *  mainloop but can also be called directly from the realtime data\n+     *  thread if the user is prepared to deal with this. *\/\n+        void (*process) (void *data);\n+\n+    \/** The stream is drained *\/\n+        void (*drained) (void *data);\n+\n+    \/** A command notify, Since 0.3.39:1 *\/\n+    void (*command) (void *data, const struct spa_command *command);\n+\n+    \/** a trigger_process completed. Since version 0.3.40:2 *\/\n+    void (*trigger_done) (void *data);\n+};\n+\n+\/** Convert a stream state to a readable string *\/\n+const char * pw_stream_state_as_string(enum pw_stream_state state);\n+\n+\/** \\enum pw_stream_flags Extra flags that can be used in \\ref pw_stream_connect() *\/\n+enum pw_stream_flags {\n+    PW_STREAM_FLAG_NONE = 0,            \/**< no flags *\/\n+    PW_STREAM_FLAG_AUTOCONNECT    = (1 << 0),    \/**< try to automatically connect\n+                              *  this stream *\/\n+    PW_STREAM_FLAG_INACTIVE        = (1 << 1),    \/**< start the stream inactive,\n+                              *  pw_stream_set_active() needs to be\n+                              *  called explicitly *\/\n+    PW_STREAM_FLAG_MAP_BUFFERS    = (1 << 2),    \/**< mmap the buffers except DmaBuf *\/\n+    PW_STREAM_FLAG_DRIVER        = (1 << 3),    \/**< be a driver *\/\n+    PW_STREAM_FLAG_RT_PROCESS    = (1 << 4),    \/**< call process from the realtime\n+                              *  thread. You MUST use RT safe functions\n+                              *  in the process callback. *\/\n+    PW_STREAM_FLAG_NO_CONVERT    = (1 << 5),    \/**< don't convert format *\/\n+    PW_STREAM_FLAG_EXCLUSIVE    = (1 << 6),    \/**< require exclusive access to the\n+                              *  device *\/\n+    PW_STREAM_FLAG_DONT_RECONNECT    = (1 << 7),    \/**< don't try to reconnect this stream\n+                              *  when the sink\/source is removed *\/\n+    PW_STREAM_FLAG_ALLOC_BUFFERS    = (1 << 8),    \/**< the application will allocate buffer\n+                              *  memory. In the add_buffer event, the\n+                              *  data of the buffer should be set *\/\n+    PW_STREAM_FLAG_TRIGGER        = (1 << 9),    \/**< the output stream will not be scheduled\n+                              *  automatically but _trigger_process()\n+                              *  needs to be called. This can be used\n+                              *  when the output of the stream depends\n+                              *  on input from other streams. *\/\n+};\n+\n+\/** Create a new unconneced \\ref pw_stream\n+ * \\return a newly allocated \\ref pw_stream *\/\n+struct pw_stream *\n+pw_stream_new(struct pw_core *core,        \/**< a \\ref pw_core *\/\n+          const char *name,            \/**< a stream media name *\/\n+          struct pw_properties *props    \/**< stream properties, ownership is taken *\/);\n+\n+struct pw_stream *\n+pw_stream_new_simple(struct pw_loop *loop,    \/**< a \\ref pw_loop to use *\/\n+             const char *name,        \/**< a stream media name *\/\n+             struct pw_properties *props,\/**< stream properties, ownership is taken *\/\n+             const struct pw_stream_events *events,    \/**< stream events *\/\n+             void *data                    \/**< data passed to events *\/);\n+\n+\/** Destroy a stream *\/\n+void pw_stream_destroy(struct pw_stream *stream);\n+\n+void pw_stream_add_listener(struct pw_stream *stream,\n+                struct spa_hook *listener,\n+                const struct pw_stream_events *events,\n+                void *data);\n+\n+enum pw_stream_state pw_stream_get_state(struct pw_stream *stream, const char **error);\n+\n+const char *pw_stream_get_name(struct pw_stream *stream);\n+\n+struct pw_core *pw_stream_get_core(struct pw_stream *stream);\n+\n+const struct pw_properties *pw_stream_get_properties(struct pw_stream *stream);\n+\n+int pw_stream_update_properties(struct pw_stream *stream, const struct spa_dict *dict);\n+\n+\/** Connect a stream for input or output on \\a port_path.\n+ * \\return 0 on success < 0 on error.\n+ *\n+ * You should connect to the process event and use pw_stream_dequeue_buffer()\n+ * to get the latest metadata and data. *\/\n+int\n+pw_stream_connect(struct pw_stream *stream,        \/**< a \\ref pw_stream *\/\n+          enum pw_direction direction,        \/**< the stream direction *\/\n+          uint32_t target_id,            \/**< should have the value PW_ID_ANY.\n+                              * To select a specific target\n+                              * node, specify the\n+                              * PW_KEY_OBJECT_SERIAL or the\n+                              * PW_KEY_NODE_NAME value of the target\n+                              * node in the PW_KEY_TARGET_OBJECT\n+                              * property of the stream.\n+                              * Specifying target nodes by\n+                              * their id is deprecated.\n+                              *\/\n+          enum pw_stream_flags flags,        \/**< stream flags *\/\n+          const struct spa_pod **params,    \/**< an array with params. The params\n+                              *  should ideally contain supported\n+                              *  formats. *\/\n+          uint32_t n_params            \/**< number of items in \\a params *\/);\n+\n+\/** Get the node ID of the stream.\n+ * \\return node ID. *\/\n+uint32_t\n+pw_stream_get_node_id(struct pw_stream *stream);\n+\n+\/** Disconnect \\a stream  *\/\n+int pw_stream_disconnect(struct pw_stream *stream);\n+\n+\/** Set the stream in error state *\/\n+int pw_stream_set_error(struct pw_stream *stream,    \/**< a \\ref pw_stream *\/\n+            int res,            \/**< a result code *\/\n+            const char *error,        \/**< an error message *\/\n+            ...) SPA_PRINTF_FUNC(3, 4);\n+\n+\/** Complete the negotiation process with result code \\a res\n+ *\n+ * This function should be called after notification of the format.\n+\n+ * When \\a res indicates success, \\a params contain the parameters for the\n+ * allocation state.  *\/\n+int\n+pw_stream_update_params(struct pw_stream *stream,    \/**< a \\ref pw_stream *\/\n+            const struct spa_pod **params,    \/**< an array of params. The params should\n+                              *  ideally contain parameters for doing\n+                              *  buffer allocation. *\/\n+            uint32_t n_params        \/**< number of elements in \\a params *\/);\n+\n+\/** Get control values *\/\n+const struct pw_stream_control *pw_stream_get_control(struct pw_stream *stream, uint32_t id);\n+\n+\/** Set control values *\/\n+int pw_stream_set_control(struct pw_stream *stream, uint32_t id, uint32_t n_values, float *values, ...);\n+\n+\/** Query the time on the stream *\/\n+int pw_stream_get_time_n(struct pw_stream *stream, struct pw_time *time, size_t size);\n+\n+\/** Query the time on the stream, deprecated since 0.3.50,\n+ * use pw_stream_get_time_n() to get the fields added since 0.3.50. *\/\n+SPA_DEPRECATED\n+int pw_stream_get_time(struct pw_stream *stream, struct pw_time *time);\n+\n+\/** Get a buffer that can be filled for playback streams or consumed\n+ * for capture streams. *\/\n+struct pw_buffer *pw_stream_dequeue_buffer(struct pw_stream *stream);\n+\n+\/** Submit a buffer for playback or recycle a buffer for capture. *\/\n+int pw_stream_queue_buffer(struct pw_stream *stream, struct pw_buffer *buffer);\n+\n+\/** Activate or deactivate the stream *\/\n+int pw_stream_set_active(struct pw_stream *stream, bool active);\n+\n+\/** Flush a stream. When \\a drain is true, the drained callback will\n+ * be called when all data is played or recorded *\/\n+int pw_stream_flush(struct pw_stream *stream, bool drain);\n+\n+\/** Check if the stream is driving. The stream needs to have the\n+ * PW_STREAM_FLAG_DRIVER set. When the stream is driving,\n+ * pw_stream_trigger_process() needs to be called when data is\n+ * available (output) or needed (input). Since 0.3.34 *\/\n+bool pw_stream_is_driving(struct pw_stream *stream);\n+\n+\/** Trigger a push\/pull on the stream. One iteration of the graph will\n+ * scheduled and process() will be called. Since 0.3.34 *\/\n+int pw_stream_trigger_process(struct pw_stream *stream);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_STREAM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/stream.h","additions":509,"deletions":0,"binary":false,"changes":509,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_UTILS_H\n+#define PIPEWIRE_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/un.h>\n+#ifndef _POSIX_C_SOURCE\n+# include <sys\/mount.h>\n+#endif\n+\n+#ifndef ENODATA\n+#define ENODATA 9919\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** \\defgroup pw_utils Utilities\n+ *\n+ * Various utility functions\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_utils\n+ * \\{\n+ *\/\n+\n+\/** a function to destroy an item *\/\n+typedef void (*pw_destroy_t) (void *object);\n+\n+const char *\n+pw_split_walk(const char *str, const char *delimiter, size_t *len, const char **state);\n+\n+char **\n+pw_split_strv(const char *str, const char *delimiter, int max_tokens, int *n_tokens);\n+\n+int\n+pw_split_ip(char *str, const char *delimiter, int max_tokens, char *tokens[]);\n+\n+void\n+pw_free_strv(char **str);\n+\n+char *\n+pw_strip(char *str, const char *whitespace);\n+\n+#if !defined(strndupa)\n+# define strndupa(s, n)                                      \\\n+    ({                                          \\\n+        const char *__old = (s);                          \\\n+        size_t __len = strnlen(__old, (n));                      \\\n+        char *__new = (char *) __builtin_alloca(__len + 1);              \\\n+        memcpy(__new, __old, __len);                          \\\n+        __new[__len] = '\\0';                              \\\n+        __new;                                      \\\n+    })\n+#endif\n+\n+#if !defined(strdupa)\n+# define strdupa(s)                                      \\\n+    ({                                          \\\n+        const char *__old = (s);                          \\\n+        size_t __len = strlen(__old) + 1;                      \\\n+        char *__new = (char *) alloca(__len);                      \\\n+        (char *) memcpy(__new, __old, __len);                      \\\n+    })\n+#endif\n+\n+SPA_WARN_UNUSED_RESULT\n+ssize_t pw_getrandom(void *buf, size_t buflen, unsigned int flags);\n+\n+void pw_random(void *buf, size_t buflen);\n+\n+#define pw_rand32() ({ uint32_t val; pw_random(&val, sizeof(val)); val; })\n+\n+void* pw_reallocarray(void *ptr, size_t nmemb, size_t size);\n+\n+#ifdef PW_ENABLE_DEPRECATED\n+#define PW_DEPRECATED(v)        (v)\n+#else\n+#define PW_DEPRECATED(v)    ({ __typeof__(v) _v SPA_DEPRECATED = (v); (void)_v; (v); })\n+#endif \/* PW_ENABLE_DEPRECATED *\/\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/utils.h","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BUFFER_H\n+#define SPA_BUFFER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/buffer\/meta.h>\n+\n+\/** \\defgroup spa_buffer Buffers\n+ *\n+ * Buffers describe the data and metadata that is exchanged between\n+ * ports of a node.\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+enum spa_data_type {\n+    SPA_DATA_Invalid,\n+    SPA_DATA_MemPtr,        \/**< pointer to memory, the data field in\n+                      *  struct spa_data is set. *\/\n+    SPA_DATA_MemFd,            \/**< generic fd, mmap to get to memory *\/\n+    SPA_DATA_DmaBuf,        \/**< fd to dmabuf memory *\/\n+    SPA_DATA_MemId,            \/**< memory is identified with an id *\/\n+\n+    _SPA_DATA_LAST,            \/**< not part of ABI *\/\n+};\n+\n+\/** Chunk of memory, can change for each buffer *\/\n+struct spa_chunk {\n+    uint32_t offset;        \/**< offset of valid data. Should be taken\n+                      *  modulo the data maxsize to get the offset\n+                      *  in the data memory. *\/\n+    uint32_t size;            \/**< size of valid data. Should be clamped to\n+                      *  maxsize. *\/\n+    int32_t stride;            \/**< stride of valid data *\/\n+#define SPA_CHUNK_FLAG_NONE        0\n+#define SPA_CHUNK_FLAG_CORRUPTED    (1u<<0)    \/**< chunk data is corrupted in some way *\/\n+#define SPA_CHUNK_FLAG_EMPTY        (1u<<1)    \/**< chunk data is empty with media specific\n+                          *  neutral data such as silence or black. This\n+                          *  could be used to optimize processing. *\/\n+    int32_t flags;            \/**< chunk flags *\/\n+};\n+\n+\/** Data for a buffer this stays constant for a buffer *\/\n+struct spa_data {\n+    uint32_t type;            \/**< memory type, one of enum spa_data_type, when\n+                      *  allocating memory, the type contains a bitmask\n+                      *  of allowed types. SPA_ID_INVALID is a special\n+                      *  value for the allocator to indicate that the\n+                      *  other side did not explicitly specify any\n+                      *  supported data types. It should probably use\n+                      *  a memory type that does not require special\n+                      *  handling in addition to simple mmap\/munmap. *\/\n+#define SPA_DATA_FLAG_NONE     0\n+#define SPA_DATA_FLAG_READABLE    (1u<<0)    \/**< data is readable *\/\n+#define SPA_DATA_FLAG_WRITABLE    (1u<<1)    \/**< data is writable *\/\n+#define SPA_DATA_FLAG_DYNAMIC    (1u<<2)    \/**< data pointer can be changed *\/\n+#define SPA_DATA_FLAG_READWRITE    (SPA_DATA_FLAG_READABLE|SPA_DATA_FLAG_WRITABLE)\n+    uint32_t flags;            \/**< data flags *\/\n+    int64_t fd;            \/**< optional fd for data *\/\n+    uint32_t mapoffset;        \/**< offset to map fd at *\/\n+    uint32_t maxsize;        \/**< max size of data *\/\n+    void *data;            \/**< optional data pointer *\/\n+    struct spa_chunk *chunk;    \/**< valid chunk of memory *\/\n+};\n+\n+\/** A Buffer *\/\n+struct spa_buffer {\n+    uint32_t n_metas;        \/**< number of metadata *\/\n+    uint32_t n_datas;        \/**< number of data members *\/\n+    struct spa_meta *metas;        \/**< array of metadata *\/\n+    struct spa_data *datas;        \/**< array of data members *\/\n+};\n+\n+\/** Find metadata in a buffer *\/\n+static inline struct spa_meta *spa_buffer_find_meta(const struct spa_buffer *b, uint32_t type)\n+{\n+    uint32_t i;\n+\n+    for (i = 0; i < b->n_metas; i++)\n+        if (b->metas[i].type == type)\n+            return &b->metas[i];\n+\n+    return NULL;\n+}\n+\n+static inline void *spa_buffer_find_meta_data(const struct spa_buffer *b, uint32_t type, size_t size)\n+{\n+    struct spa_meta *m;\n+    if ((m = spa_buffer_find_meta(b, type)) && m->size >= size)\n+        return m->data;\n+    return NULL;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BUFFER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/buffer.h","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_META_H\n+#define SPA_META_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+enum spa_meta_type {\n+    SPA_META_Invalid,\n+    SPA_META_Header,        \/**< struct spa_meta_header *\/\n+    SPA_META_VideoCrop,        \/**< struct spa_meta_region with cropping data *\/\n+    SPA_META_VideoDamage,        \/**< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end. *\/\n+    SPA_META_Bitmap,        \/**< struct spa_meta_bitmap *\/\n+    SPA_META_Cursor,        \/**< struct spa_meta_cursor *\/\n+    SPA_META_Control,        \/**< metadata contains a spa_meta_control\n+                      *  associated with the data *\/\n+    SPA_META_Busy,            \/**< don't write to buffer when count > 0 *\/\n+    SPA_META_VideoTransform,    \/**< struct spa_meta_transform *\/\n+\n+    _SPA_META_LAST,            \/**< not part of ABI\/API *\/\n+};\n+\n+\/**\n+ * A metadata element.\n+ *\n+ * This structure is available on the buffer structure and contains\n+ * the type of the metadata and a pointer\/size to the actual metadata\n+ * itself.\n+ *\/\n+struct spa_meta {\n+    uint32_t type;        \/**< metadata type, one of enum spa_meta_type *\/\n+    uint32_t size;        \/**< size of metadata *\/\n+    void *data;        \/**< pointer to metadata *\/\n+};\n+\n+static inline void *spa_meta_first(const struct spa_meta *m) {\n+    return m->data;\n+}\n+#define spa_meta_first spa_meta_first\n+static inline void *spa_meta_end(const struct spa_meta *m) {\n+    return SPA_PTROFF(m->data,m->size,void);\n+}\n+#define spa_meta_end spa_meta_end\n+#define spa_meta_check(p,m)    (SPA_PTROFF(p,sizeof(*(p)),void) <= spa_meta_end(m))\n+\n+\/**\n+ * Describes essential buffer header metadata such as flags and\n+ * timestamps.\n+ *\/\n+struct spa_meta_header {\n+#define SPA_META_HEADER_FLAG_DISCONT    (1 << 0)    \/**< data is not continuous with previous buffer *\/\n+#define SPA_META_HEADER_FLAG_CORRUPTED    (1 << 1)    \/**< data might be corrupted *\/\n+#define SPA_META_HEADER_FLAG_MARKER    (1 << 2)    \/**< media specific marker *\/\n+#define SPA_META_HEADER_FLAG_HEADER    (1 << 3)    \/**< data contains a codec specific header *\/\n+#define SPA_META_HEADER_FLAG_GAP    (1 << 4)    \/**< data contains media neutral data *\/\n+#define SPA_META_HEADER_FLAG_DELTA_UNIT    (1 << 5)    \/**< cannot be decoded independently *\/\n+    uint32_t flags;                \/**< flags *\/\n+    uint32_t offset;            \/**< offset in current cycle *\/\n+    int64_t pts;                \/**< presentation timestamp in nanoseconds *\/\n+    int64_t dts_offset;            \/**< decoding timestamp as a difference with pts *\/\n+    uint64_t seq;                \/**< sequence number, increments with a\n+                          *  media specific frequency *\/\n+};\n+\n+\/** metadata structure for Region or an array of these for RegionArray *\/\n+struct spa_meta_region {\n+    struct spa_region region;\n+};\n+\n+static inline bool spa_meta_region_is_valid(const struct spa_meta_region *m) {\n+    return m->region.size.width != 0 && m->region.size.height != 0;\n+}\n+#define spa_meta_region_is_valid spa_meta_region_is_valid\n+\n+\/** iterate all the items in a metadata *\/\n+#define spa_meta_for_each(pos,meta)                    \\\n+    for ((pos) = (__typeof(pos))spa_meta_first(meta);            \\\n+        spa_meta_check(pos, meta);                    \\\n+            (pos)++)\n+\n+#define spa_meta_bitmap_is_valid(m)    ((m)->format != 0)\n+\n+\/**\n+ * Bitmap information\n+ *\n+ * This metadata contains a bitmap image in the given format and size.\n+ * It is typically used for cursor images or other small images that are\n+ * better transferred inline.\n+ *\/\n+struct spa_meta_bitmap {\n+    uint32_t format;        \/**< bitmap video format, one of enum spa_video_format. 0 is\n+                      *  and invalid format and should be handled as if there is\n+                      *  no new bitmap information. *\/\n+    struct spa_rectangle size;    \/**< width and height of bitmap *\/\n+    int32_t stride;            \/**< stride of bitmap data *\/\n+    uint32_t offset;        \/**< offset of bitmap data in this structure. An offset of\n+                      *  0 means no image data (invisible), an offset >=\n+                      *  sizeof(struct spa_meta_bitmap) contains valid bitmap\n+                      *  info. *\/\n+};\n+\n+#define spa_meta_cursor_is_valid(m)    ((m)->id != 0)\n+\n+\/**\n+ * Cursor information\n+ *\n+ * Metadata to describe the position and appearance of a pointing device.\n+ *\/\n+struct spa_meta_cursor {\n+    uint32_t id;            \/**< cursor id. an id of 0 is an invalid id and means that\n+                      *  there is no new cursor data *\/\n+    uint32_t flags;            \/**< extra flags *\/\n+    struct spa_point position;    \/**< position on screen *\/\n+    struct spa_point hotspot;    \/**< offsets for hotspot in bitmap, this field has no meaning\n+                      *  when there is no valid bitmap (see below) *\/\n+    uint32_t bitmap_offset;        \/**< offset of bitmap meta in this structure. When the offset\n+                      *  is 0, there is no new bitmap information. When the offset is\n+                      *  >= sizeof(struct spa_meta_cursor) there is a\n+                      *  struct spa_meta_bitmap at the offset. *\/\n+};\n+\n+\/** a timed set of events associated with the buffer *\/\n+struct spa_meta_control {\n+    struct spa_pod_sequence sequence;\n+};\n+\n+\/** a busy counter for the buffer *\/\n+struct spa_meta_busy {\n+    uint32_t flags;\n+    uint32_t count;            \/**< number of users busy with the buffer *\/\n+};\n+\n+enum spa_meta_videotransform_value {\n+    SPA_META_TRANSFORMATION_None = 0,    \/**< no transform *\/\n+    SPA_META_TRANSFORMATION_90,        \/**< 90 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_180,        \/**< 180 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_270,        \/**< 270 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped,    \/**< 180 degree flipped around the vertical axis. Equivalent\n+                          * to a reflexion through the vertical line splitting the\n+                          * bufffer in two equal sized parts *\/\n+    SPA_META_TRANSFORMATION_Flipped90,    \/**< flip then rotate around 90 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped180,    \/**< flip then rotate around 180 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped270,    \/**< flip then rotate around 270 degree counter-clockwise *\/\n+};\n+\n+\/** a transformation of the buffer *\/\n+struct spa_meta_videotransform {\n+    uint32_t transform;            \/**< orientation transformation that was applied to the buffer,\n+                          *  one of enum spa_meta_videotransform_value *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_META_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/meta.h","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BUFFER_TYPES_H\n+#define SPA_BUFFER_TYPES_H\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/buffer\/buffer.h>\n+#include <spa\/buffer\/meta.h>\n+#include <spa\/utils\/type.h>\n+\n+#define SPA_TYPE_INFO_Buffer            SPA_TYPE_INFO_POINTER_BASE \"Buffer\"\n+#define SPA_TYPE_INFO_BUFFER_BASE        SPA_TYPE_INFO_Buffer \":\"\n+\n+\/** Buffers contain data of a certain type *\/\n+#define SPA_TYPE_INFO_Data            SPA_TYPE_INFO_ENUM_BASE \"Data\"\n+#define SPA_TYPE_INFO_DATA_BASE            SPA_TYPE_INFO_Data \":\"\n+\n+\/** base type for fd based memory *\/\n+#define SPA_TYPE_INFO_DATA_Fd            SPA_TYPE_INFO_DATA_BASE \"Fd\"\n+#define SPA_TYPE_INFO_DATA_FD_BASE        SPA_TYPE_INFO_DATA_Fd \":\"\n+\n+static const struct spa_type_info spa_type_data_type[] = {\n+    { SPA_DATA_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"Invalid\", NULL },\n+    { SPA_DATA_MemPtr, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"MemPtr\", NULL },\n+    { SPA_DATA_MemFd, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_FD_BASE \"MemFd\", NULL },\n+    { SPA_DATA_DmaBuf, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_FD_BASE \"DmaBuf\", NULL },\n+    { SPA_DATA_MemId, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"MemId\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_Meta            SPA_TYPE_INFO_POINTER_BASE \"Meta\"\n+#define SPA_TYPE_INFO_META_BASE            SPA_TYPE_INFO_Meta \":\"\n+\n+#define SPA_TYPE_INFO_META_Array        SPA_TYPE_INFO_META_BASE \"Array\"\n+#define SPA_TYPE_INFO_META_ARRAY_BASE        SPA_TYPE_INFO_META_Array \":\"\n+\n+#define SPA_TYPE_INFO_META_Region        SPA_TYPE_INFO_META_BASE \"Region\"\n+#define SPA_TYPE_INFO_META_REGION_BASE        SPA_TYPE_INFO_META_Region \":\"\n+\n+#define SPA_TYPE_INFO_META_ARRAY_Region        SPA_TYPE_INFO_META_ARRAY_BASE \"Region\"\n+#define SPA_TYPE_INFO_META_ARRAY_REGION_BASE    SPA_TYPE_INFO_META_ARRAY_Region \":\"\n+\n+static const struct spa_type_info spa_type_meta_type[] = {\n+    { SPA_META_Invalid, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Invalid\", NULL },\n+    { SPA_META_Header, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Header\", NULL },\n+    { SPA_META_VideoCrop, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_REGION_BASE \"VideoCrop\", NULL },\n+    { SPA_META_VideoDamage, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_ARRAY_REGION_BASE \"VideoDamage\", NULL },\n+    { SPA_META_Bitmap, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Bitmap\", NULL },\n+    { SPA_META_Cursor, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Cursor\", NULL },\n+    { SPA_META_Control, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Control\", NULL },\n+    { SPA_META_Busy, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Busy\", NULL },\n+    { SPA_META_VideoTransform, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"VideoTransform\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BUFFER_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/type-info.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_CONTROL_H\n+#define SPA_CONTROL_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** \\defgroup spa_control Control\n+ * Control type declarations\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_control\n+ * \\{\n+ *\/\n+\n+\/** Different Control types *\/\n+enum spa_control_type {\n+    SPA_CONTROL_Invalid,\n+    SPA_CONTROL_Properties,        \/**< data contains a SPA_TYPE_OBJECT_Props *\/\n+    SPA_CONTROL_Midi,        \/**< data contains a spa_pod_bytes with raw midi data *\/\n+    SPA_CONTROL_OSC,        \/**< data contains a spa_pod_bytes with an OSC packet *\/\n+\n+    _SPA_CONTROL_LAST,        \/**< not part of ABI *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_CONTROL_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/control\/control.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_CONTROL_TYPES_H\n+#define SPA_CONTROL_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_control\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/type-info.h>\n+#include <spa\/control\/control.h>\n+\n+\/* base for parameter object enumerations *\/\n+#define SPA_TYPE_INFO_Control        SPA_TYPE_INFO_ENUM_BASE \"Control\"\n+#define SPA_TYPE_INFO_CONTROL_BASE        SPA_TYPE_INFO_Control \":\"\n+\n+static const struct spa_type_info spa_type_control[] = {\n+    { SPA_CONTROL_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Invalid\", NULL },\n+    { SPA_CONTROL_Properties, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Properties\", NULL },\n+    { SPA_CONTROL_Midi, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Midi\", NULL },\n+    { SPA_CONTROL_OSC, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"OSC\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_CONTROL_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/control\/type-info.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DEBUG_TYPES_H\n+#define SPA_DEBUG_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_debug\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type-info.h>\n+\n+#include <string.h>\n+\n+static inline const struct spa_type_info *spa_debug_type_find(const struct spa_type_info *info, uint32_t type)\n+{\n+    const struct spa_type_info *res;\n+\n+    if (info == NULL)\n+        info = SPA_TYPE_ROOT;\n+\n+    while (info && info->name) {\n+        if (info->type == SPA_ID_INVALID) {\n+            if (info->values && (res = spa_debug_type_find(info->values, type)))\n+                return res;\n+        }\n+        else if (info->type == type)\n+            return info;\n+        info++;\n+    }\n+    return NULL;\n+}\n+\n+static inline const char *spa_debug_type_short_name(const char *name)\n+{\n+    const char *h;\n+    if ((h = strrchr(name, ':')) != NULL)\n+        name = h + 1;\n+    return name;\n+}\n+\n+static inline const char *spa_debug_type_find_name(const struct spa_type_info *info, uint32_t type)\n+{\n+    if ((info = spa_debug_type_find(info, type)) == NULL)\n+        return NULL;\n+    return info->name;\n+}\n+\n+static inline const char *spa_debug_type_find_short_name(const struct spa_type_info *info, uint32_t type)\n+{\n+    const char *str;\n+    if ((str = spa_debug_type_find_name(info, type)) == NULL)\n+        return NULL;\n+    return spa_debug_type_short_name(str);\n+}\n+\n+static inline uint32_t spa_debug_type_find_type(const struct spa_type_info *info, const char *name)\n+{\n+    if (info == NULL)\n+        info = SPA_TYPE_ROOT;\n+\n+    while (info && info->name) {\n+        uint32_t res;\n+        if (strcmp(info->name, name) == 0)\n+            return info->type;\n+        if (info->values && (res = spa_debug_type_find_type(info->values, name)) != SPA_ID_INVALID)\n+            return res;\n+        info++;\n+    }\n+    return SPA_ID_INVALID;\n+}\n+\n+static inline const struct spa_type_info *spa_debug_type_find_short(const struct spa_type_info *info, const char *name)\n+{\n+    while (info && info->name) {\n+        if (strcmp(spa_debug_type_short_name(info->name), name) == 0)\n+            return info;\n+        if (strcmp(info->name, name) == 0)\n+            return info;\n+        if (info->type != 0 && info->type == (uint32_t)atoi(name))\n+            return info;\n+        info++;\n+    }\n+    return NULL;\n+}\n+\n+static inline uint32_t spa_debug_type_find_type_short(const struct spa_type_info *info, const char *name)\n+{\n+    if ((info = spa_debug_type_find_short(info, name)) == NULL)\n+        return SPA_ID_INVALID;\n+    return info->type;\n+}\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DEBUG_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/debug\/types.h","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_DEVICE_H\n+#define SPA_EVENT_DEVICE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/pod\/event.h>\n+\n+\/**\n+ * \\addtogroup spa_device\n+ * \\{\n+ *\/\n+\n+\/* object id of SPA_TYPE_EVENT_Device *\/\n+enum spa_device_event {\n+    SPA_DEVICE_EVENT_ObjectConfig,\n+};\n+\n+#define SPA_DEVICE_EVENT_ID(ev)    SPA_EVENT_ID(ev, SPA_TYPE_EVENT_Device)\n+#define SPA_DEVICE_EVENT_INIT(id) SPA_EVENT_INIT(SPA_TYPE_EVENT_Device, id)\n+\n+\/* properties for SPA_TYPE_EVENT_Device *\/\n+enum spa_event_device {\n+    SPA_EVENT_DEVICE_START,\n+\n+    SPA_EVENT_DEVICE_Object,    \/* an object id (Int) *\/\n+    SPA_EVENT_DEVICE_Props,        \/* properties for an object (SPA_TYPE_OBJECT_Props) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_DEVICE *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/monitor\/event.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2021 Collabora Ltd. *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DEVICE_TYPE_INFO_H\n+#define SPA_DEVICE_TYPE_INFO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type-info.h>\n+\n+#include <spa\/monitor\/event.h>\n+\n+\/**\n+ * \\addtogroup spa_device\n+ * \\{\n+ *\/\n+\n+#define SPA_TYPE_INFO_DeviceEvent        SPA_TYPE_INFO_EVENT_BASE \"Device\"\n+#define SPA_TYPE_INFO_DEVICE_EVENT_BASE        SPA_TYPE_INFO_DeviceEvent \":\"\n+\n+#define SPA_TYPE_INFO_DeviceEventId        SPA_TYPE_INFO_ENUM_BASE \"DeviceEventId\"\n+#define SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE    SPA_TYPE_INFO_DeviceEventId \":\"\n+\n+static const struct spa_type_info spa_type_device_event_id[] = {\n+    { SPA_DEVICE_EVENT_ObjectConfig, SPA_TYPE_EVENT_Device, SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE \"ObjectConfig\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_device_event[] = {\n+    { SPA_EVENT_DEVICE_START, SPA_TYPE_Id, SPA_TYPE_INFO_DEVICE_EVENT_BASE, spa_type_device_event_id },\n+    { SPA_EVENT_DEVICE_Object, SPA_TYPE_Int, SPA_TYPE_INFO_DEVICE_EVENT_BASE \"Object\", NULL },\n+    { SPA_EVENT_DEVICE_Props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_DEVICE_EVENT_BASE \"Props\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DEVICE_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/monitor\/type-info.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_COMMAND_NODE_H\n+#define SPA_COMMAND_NODE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/command.h>\n+\n+\/* object id of SPA_TYPE_COMMAND_Node *\/\n+enum spa_node_command {\n+    SPA_NODE_COMMAND_Suspend,    \/**< suspend a node, this removes all configured\n+                      * formats and closes any devices *\/\n+    SPA_NODE_COMMAND_Pause,        \/**< pause a node. this makes it stop emitting\n+                      *  scheduling events *\/\n+    SPA_NODE_COMMAND_Start,        \/**< start a node, this makes it start emitting\n+                      *  scheduling events *\/\n+    SPA_NODE_COMMAND_Enable,\n+    SPA_NODE_COMMAND_Disable,\n+    SPA_NODE_COMMAND_Flush,\n+    SPA_NODE_COMMAND_Drain,\n+    SPA_NODE_COMMAND_Marker,\n+    SPA_NODE_COMMAND_ParamBegin,    \/**< begin a set of parameter enumerations or\n+                      *  configuration that require the device to\n+                      *  remain opened, like query formats and then\n+                      *  set a format *\/\n+    SPA_NODE_COMMAND_ParamEnd,    \/**< end a transaction *\/\n+    SPA_NODE_COMMAND_RequestProcess,\/**< Sent to a driver when some other node emitted\n+                      *  the RequestProcess event. *\/\n+};\n+\n+#define SPA_NODE_COMMAND_ID(cmd)    SPA_COMMAND_ID(cmd, SPA_TYPE_COMMAND_Node)\n+#define SPA_NODE_COMMAND_INIT(id)    SPA_COMMAND_INIT(SPA_TYPE_COMMAND_Node, id)\n+\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_COMMAND_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/command.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_NODE_H\n+#define SPA_EVENT_NODE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/event.h>\n+\n+\/* object id of SPA_TYPE_EVENT_Node *\/\n+enum spa_node_event {\n+    SPA_NODE_EVENT_Error,\n+    SPA_NODE_EVENT_Buffering,\n+    SPA_NODE_EVENT_RequestRefresh,\n+    SPA_NODE_EVENT_RequestProcess,        \/*< Ask the driver to start processing\n+                         *  the graph *\/\n+};\n+\n+#define SPA_NODE_EVENT_ID(ev)    SPA_EVENT_ID(ev, SPA_TYPE_EVENT_Node)\n+#define SPA_NODE_EVENT_INIT(id) SPA_EVENT_INIT(SPA_TYPE_EVENT_Node, id)\n+\n+\/* properties for SPA_TYPE_EVENT_Node *\/\n+enum spa_event_node {\n+    SPA_EVENT_NODE_START,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/event.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_IO_H\n+#define SPA_IO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** IO areas\n+ *\n+ * IO information for a port on a node. This is allocated\n+ * by the host and configured on a node or all ports for which\n+ * IO is requested.\n+ *\n+ * The plugin will communicate with the host through the IO\n+ * areas.\n+ *\/\n+\n+\/** Different IO area types *\/\n+enum spa_io_type {\n+    SPA_IO_Invalid,\n+    SPA_IO_Buffers,        \/**< area to exchange buffers, struct spa_io_buffers *\/\n+    SPA_IO_Range,        \/**< expected byte range, struct spa_io_range *\/\n+    SPA_IO_Clock,        \/**< area to update clock information, struct spa_io_clock *\/\n+    SPA_IO_Latency,        \/**< latency reporting, struct spa_io_latency *\/\n+    SPA_IO_Control,        \/**< area for control messages, struct spa_io_sequence *\/\n+    SPA_IO_Notify,        \/**< area for notify messages, struct spa_io_sequence *\/\n+    SPA_IO_Position,    \/**< position information in the graph, struct spa_io_position *\/\n+    SPA_IO_RateMatch,    \/**< rate matching between nodes, struct spa_io_rate_match *\/\n+    SPA_IO_Memory,        \/**< memory pointer, struct spa_io_memory *\/\n+};\n+\n+\/**\n+ * IO area to exchange buffers.\n+ *\n+ * A set of buffers should first be configured on the node\/port.\n+ * Further references to those buffers will be made by using the\n+ * id of the buffer.\n+ *\n+ * If status is SPA_STATUS_OK, the host should ignore\n+ * the io area.\n+ *\n+ * If status is SPA_STATUS_NEED_DATA, the host should:\n+ * 1) recycle the buffer in buffer_id, if possible\n+ * 2) prepare a new buffer and place the id in buffer_id.\n+ *\n+ * If status is SPA_STATUS_HAVE_DATA, the host should consume\n+ * the buffer in buffer_id and set the state to\n+ * SPA_STATUS_NEED_DATA when new data is requested.\n+ *\n+ * If status is SPA_STATUS_STOPPED, some error occurred on the\n+ * port.\n+ *\n+ * If status is SPA_STATUS_DRAINED, data from the io area was\n+ * used to drain.\n+ *\n+ * Status can also be a negative errno value to indicate errors.\n+ * such as:\n+ * -EINVAL: buffer_id is invalid\n+ * -EPIPE: no more buffers available\n+ *\/\n+struct spa_io_buffers {\n+#define SPA_STATUS_OK            0\n+#define SPA_STATUS_NEED_DATA        (1<<0)\n+#define SPA_STATUS_HAVE_DATA        (1<<1)\n+#define SPA_STATUS_STOPPED        (1<<2)\n+#define SPA_STATUS_DRAINED        (1<<3)\n+    int32_t status;            \/**< the status code *\/\n+    uint32_t buffer_id;        \/**< a buffer id *\/\n+};\n+\n+#define SPA_IO_BUFFERS_INIT  ((struct spa_io_buffers) { SPA_STATUS_OK, SPA_ID_INVALID, })\n+\n+\/**\n+ * IO area to exchange a memory region\n+ *\/\n+struct spa_io_memory {\n+    int32_t status;            \/**< the status code *\/\n+    uint32_t size;            \/**< the size of \\a data *\/\n+    void *data;            \/**< a memory pointer *\/\n+};\n+#define SPA_IO_MEMORY_INIT  ((struct spa_io_memory) { SPA_STATUS_OK, 0, NULL, })\n+\n+\/** A range, suitable for input ports that can suggest a range to output ports *\/\n+struct spa_io_range {\n+    uint64_t offset;    \/**< offset in range *\/\n+    uint32_t min_size;    \/**< minimum size of data *\/\n+    uint32_t max_size;    \/**< maximum size of data *\/\n+};\n+\n+\/**\n+ * Absolute time reporting.\n+ *\n+ * Nodes that can report clocking information will receive this io block.\n+ * The application sets the id. This is usually set as part of the\n+ * position information but can also be set separately.\n+ *\n+ * The clock counts the elapsed time according to the clock provider\n+ * since the provider was last started.\n+ *\/\n+struct spa_io_clock {\n+#define SPA_IO_CLOCK_FLAG_FREEWHEEL (1u<<0)\n+    uint32_t flags;            \/**< clock flags *\/\n+    uint32_t id;            \/**< unique clock id, set by application *\/\n+    char name[64];            \/**< clock name prefixed with API, set by node. The clock name\n+                      *  is unique per clock and can be used to check if nodes\n+                      *  share the same clock. *\/\n+    uint64_t nsec;            \/**< time in nanoseconds against monotonic clock *\/\n+    struct spa_fraction rate;    \/**< rate for position\/duration\/delay *\/\n+    uint64_t position;        \/**< current position *\/\n+    uint64_t duration;        \/**< duration of current cycle *\/\n+    int64_t delay;            \/**< delay between position and hardware,\n+                      *  positive for capture, negative for playback *\/\n+    double rate_diff;        \/**< rate difference between clock and monotonic time *\/\n+    uint64_t next_nsec;        \/**< estimated next wakeup time in nanoseconds *\/\n+\n+    struct spa_fraction target_rate;    \/**< target rate of next cycle *\/\n+    uint64_t target_duration;        \/**< target duration of next cycle *\/\n+    uint32_t target_seq;            \/**< seq counter. must be equal at start and\n+                          *  end of read and lower bit must be 0 *\/\n+\n+    uint32_t padding[3];\n+};\n+\n+\/* the size of the video in this cycle *\/\n+struct spa_io_video_size {\n+#define SPA_IO_VIDEO_SIZE_VALID        (1<<0)\n+    uint32_t flags;            \/**< optional flags *\/\n+    uint32_t stride;        \/**< video stride in bytes *\/\n+    struct spa_rectangle size;    \/**< the video size *\/\n+    struct spa_fraction framerate;  \/**< the minimum framerate, the cycle duration is\n+                      *  always smaller to ensure there is only one\n+                      *  video frame per cycle. *\/\n+    uint32_t padding[4];\n+};\n+\n+\/** latency reporting *\/\n+struct spa_io_latency {\n+    struct spa_fraction rate;    \/**< rate for min\/max *\/\n+    uint64_t min;            \/**< min latency *\/\n+    uint64_t max;            \/**< max latency *\/\n+};\n+\n+\/** control stream, io area for SPA_IO_Control and SPA_IO_Notify *\/\n+struct spa_io_sequence {\n+    struct spa_pod_sequence sequence;    \/**< sequence of timed events *\/\n+};\n+\n+\/** bar and beat segment *\/\n+struct spa_io_segment_bar {\n+#define SPA_IO_SEGMENT_BAR_FLAG_VALID        (1<<0)\n+    uint32_t flags;            \/**< extra flags *\/\n+    uint32_t offset;        \/**< offset in segment of this beat *\/\n+    float signature_num;        \/**< time signature numerator *\/\n+    float signature_denom;        \/**< time signature denominator *\/\n+    double bpm;            \/**< beats per minute *\/\n+    double beat;            \/**< current beat in segment *\/\n+    uint32_t padding[8];\n+};\n+\n+\/** video frame segment *\/\n+struct spa_io_segment_video {\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_VALID        (1<<0)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME    (1<<1)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN    (1<<2)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED    (1<<3)\n+    uint32_t flags;            \/**< flags *\/\n+    uint32_t offset;        \/**< offset in segment *\/\n+    struct spa_fraction framerate;\n+    uint32_t hours;\n+    uint32_t minutes;\n+    uint32_t seconds;\n+    uint32_t frames;\n+    uint32_t field_count;        \/**< 0 for progressive, 1 and 2 for interlaced *\/\n+    uint32_t padding[11];\n+};\n+\n+\/**\n+ * A segment converts a running time to a segment (stream) position.\n+ *\n+ * The segment position is valid when the current running time is between\n+ * start and start + duration. The position is then\n+ * calculated as:\n+ *\n+ *   (running time - start) * rate + position;\n+ *\n+ * Support for looping is done by specifying the LOOPING flags with a\n+ * non-zero duration. When the running time reaches start + duration,\n+ * duration is added to start and the loop repeats.\n+ *\n+ * Care has to be taken when the running time + clock.duration extends\n+ * past the start + duration from the segment; the user should correctly\n+ * wrap around and partially repeat the loop in the current cycle.\n+ *\n+ * Extra information can be placed in the segment by setting the valid flags\n+ * and filling up the corresponding structures.\n+ *\/\n+struct spa_io_segment {\n+    uint32_t version;\n+#define SPA_IO_SEGMENT_FLAG_LOOPING    (1<<0)    \/**< after the duration, the segment repeats *\/\n+#define SPA_IO_SEGMENT_FLAG_NO_POSITION    (1<<1)    \/**< position is invalid. The position can be invalid\n+                          *  after a seek, for example, when the exact mapping\n+                          *  of the extra segment info (bar, video, ...) to\n+                          *  position has not been determined yet *\/\n+    uint32_t flags;                \/**< extra flags *\/\n+    uint64_t start;                \/**< value of running time when this\n+                          *  info is active. Can be in the future for\n+                          *  pending changes. It does not have to be in\n+                          *  exact multiples of the clock duration. *\/\n+    uint64_t duration;            \/**< duration when this info becomes invalid expressed\n+                          *  in running time. If the duration is 0, this\n+                          *  segment extends to the next segment. If the\n+                          *  segment becomes invalid and the looping flag is\n+                          *  set, the segment repeats. *\/\n+    double rate;                \/**< overall rate of the segment, can be negative for\n+                          *  backwards time reporting. *\/\n+    uint64_t position;            \/**< The position when the running time == start.\n+                          *  can be invalid when the owner of the extra segment\n+                          *  information has not yet made the mapping. *\/\n+\n+    struct spa_io_segment_bar bar;\n+    struct spa_io_segment_video video;\n+};\n+\n+enum spa_io_position_state {\n+    SPA_IO_POSITION_STATE_STOPPED,\n+    SPA_IO_POSITION_STATE_STARTING,\n+    SPA_IO_POSITION_STATE_RUNNING,\n+};\n+\n+\/** the maximum number of segments visible in the future *\/\n+#define SPA_IO_POSITION_MAX_SEGMENTS    8\n+\n+\/**\n+ * The position information adds extra meaning to the raw clock times.\n+ *\n+ * It is set on all nodes and the clock id will contain the clock of the\n+ * driving node in the graph.\n+ *\n+ * The position information contains 1 or more segments that convert the\n+ * raw clock times to a stream time. They are sorted based on their\n+ * start times, and thus the order in which they will activate in\n+ * the future. This makes it possible to look ahead in the scheduled\n+ * segments and anticipate the changes in the timeline.\n+ *\/\n+struct spa_io_position {\n+    struct spa_io_clock clock;        \/**< clock position of driver, always valid and\n+                          *  read only *\/\n+    struct spa_io_video_size video;        \/**< size of the video in the current cycle *\/\n+    int64_t offset;                \/**< an offset to subtract from the clock position\n+                          *  to get a running time. This is the time that\n+                          *  the state has been in the RUNNING state and the\n+                          *  time that should be used to compare the segment\n+                          *  start values against. *\/\n+    uint32_t state;                \/**< one of enum spa_io_position_state *\/\n+\n+    uint32_t n_segments;            \/**< number of segments *\/\n+    struct spa_io_segment segments[SPA_IO_POSITION_MAX_SEGMENTS];    \/**< segments *\/\n+};\n+\n+\/** rate matching *\/\n+struct spa_io_rate_match {\n+    uint32_t delay;            \/**< extra delay in samples for resampler *\/\n+    uint32_t size;            \/**< requested input size for resampler *\/\n+    double rate;            \/**< rate for resampler *\/\n+#define SPA_IO_RATE_MATCH_FLAG_ACTIVE    (1 << 0)\n+    uint32_t flags;            \/**< extra flags *\/\n+    uint32_t padding[7];\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_IO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/io.h","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_NODE_TYPES_H\n+#define SPA_NODE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type.h>\n+\n+#include <spa\/node\/command.h>\n+#include <spa\/node\/event.h>\n+#include <spa\/node\/io.h>\n+\n+#define SPA_TYPE_INFO_IO            SPA_TYPE_INFO_ENUM_BASE \"IO\"\n+#define SPA_TYPE_INFO_IO_BASE        SPA_TYPE_INFO_IO \":\"\n+\n+static const struct spa_type_info spa_type_io[] = {\n+    { SPA_IO_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Invalid\", NULL },\n+    { SPA_IO_Buffers, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Buffers\", NULL },\n+    { SPA_IO_Range, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Range\", NULL },\n+    { SPA_IO_Clock, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Clock\", NULL },\n+    { SPA_IO_Latency, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Latency\", NULL },\n+    { SPA_IO_Control, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Control\", NULL },\n+    { SPA_IO_Notify, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Notify\", NULL },\n+    { SPA_IO_Position, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Position\", NULL },\n+    { SPA_IO_RateMatch, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"RateMatch\", NULL },\n+    { SPA_IO_Memory, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Memory\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_NodeEvent            SPA_TYPE_INFO_EVENT_BASE \"Node\"\n+#define SPA_TYPE_INFO_NODE_EVENT_BASE        SPA_TYPE_INFO_NodeEvent \":\"\n+\n+static const struct spa_type_info spa_type_node_event_id[] = {\n+    { SPA_NODE_EVENT_Error,         SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"Error\",   NULL },\n+    { SPA_NODE_EVENT_Buffering,     SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"Buffering\", NULL },\n+    { SPA_NODE_EVENT_RequestRefresh, SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"RequestRefresh\", NULL },\n+    { SPA_NODE_EVENT_RequestProcess, SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"RequestProcess\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_node_event[] = {\n+    { SPA_EVENT_NODE_START, SPA_TYPE_Id, SPA_TYPE_INFO_NODE_EVENT_BASE, spa_type_node_event_id },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_NodeCommand            SPA_TYPE_INFO_COMMAND_BASE \"Node\"\n+#define SPA_TYPE_INFO_NODE_COMMAND_BASE        SPA_TYPE_INFO_NodeCommand \":\"\n+\n+static const struct spa_type_info spa_type_node_command_id[] = {\n+    { SPA_NODE_COMMAND_Suspend,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Suspend\", NULL },\n+    { SPA_NODE_COMMAND_Pause,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Pause\",   NULL },\n+    { SPA_NODE_COMMAND_Start,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Start\",   NULL },\n+    { SPA_NODE_COMMAND_Enable,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Enable\",  NULL },\n+    { SPA_NODE_COMMAND_Disable,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Disable\", NULL },\n+    { SPA_NODE_COMMAND_Flush,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Flush\",   NULL },\n+    { SPA_NODE_COMMAND_Drain,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Drain\",   NULL },\n+    { SPA_NODE_COMMAND_Marker,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Marker\",  NULL },\n+    { SPA_NODE_COMMAND_ParamBegin,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"ParamBegin\",  NULL },\n+    { SPA_NODE_COMMAND_ParamEnd,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"ParamEnd\",  NULL },\n+    { SPA_NODE_COMMAND_RequestProcess, SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"RequestProcess\",  NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_node_command[] = {\n+    { 0, SPA_TYPE_Id, SPA_TYPE_INFO_NODE_COMMAND_BASE, spa_type_node_command_id },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_NODE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/type-info.h","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AAC_TYPES_H\n+#define SPA_AUDIO_AAC_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/aac.h>\n+\n+#define SPA_TYPE_INFO_AudioAACStreamFormat        SPA_TYPE_INFO_ENUM_BASE \"AudioAACStreamFormat\"\n+#define SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE    SPA_TYPE_INFO_AudioAACStreamFormat \":\"\n+\n+static const struct spa_type_info spa_type_audio_aac_stream_format[] = {\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_RAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"RAW\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP2ADTS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4ADTS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4LOAS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4LATM\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_ADIF, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"ADIF\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4FF\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AAC_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/aac-types.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AAC_H\n+#define SPA_AUDIO_AAC_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_aac_stream_format {\n+    SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN,\n+    \/* Raw AAC frames *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_RAW,\n+    \/* ISO\/IEC 13818-7 MPEG-2 Audio Data Transport Stream (ADTS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS,\n+    \/* ISO\/IEC 14496-3 MPEG-4 Audio Data Transport Stream (ADTS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS,\n+    \/* ISO\/IEC 14496-3 Low Overhead Audio Stream (LOAS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS,\n+    \/* ISO\/IEC 14496-3 Low Overhead Audio Transport Multiplex (LATM) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM,\n+    \/* ISO\/IEC 14496-3 Audio Data Interchange Format (ADIF) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_ADIF,\n+    \/* ISO\/IEC 14496-12 MPEG-4 file format *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF,\n+\n+    SPA_AUDIO_AAC_STREAM_FORMAT_CUSTOM = 0x10000,\n+};\n+\n+struct spa_audio_info_aac {\n+    uint32_t rate;                    \/*< sample rate *\/\n+    uint32_t channels;                \/*< number of channels *\/\n+    uint32_t bitrate;                \/*< stream bitrate *\/\n+    enum spa_audio_aac_stream_format stream_format;    \/*< AAC audio stream format *\/\n+};\n+\n+#define SPA_AUDIO_INFO_AAC_INIT(...)        ((struct spa_audio_info_aac) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AAC_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/aac.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AMR_TYPES_H\n+#define SPA_AUDIO_AMR_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/amr.h>\n+\n+#define SPA_TYPE_INFO_AudioAMRBandMode        SPA_TYPE_INFO_ENUM_BASE \"AudioAMRBandMode\"\n+#define SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE    SPA_TYPE_INFO_AudioAMRBandMode \":\"\n+\n+static const struct spa_type_info spa_type_audio_amr_band_mode[] = {\n+    { SPA_AUDIO_AMR_BAND_MODE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_AMR_BAND_MODE_NB, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"NB\", NULL },\n+    { SPA_AUDIO_AMR_BAND_MODE_WB, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"WB\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AMR_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/amr-types.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AMR_H\n+#define SPA_AUDIO_AMR_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_amr_band_mode {\n+    SPA_AUDIO_AMR_BAND_MODE_UNKNOWN,\n+    SPA_AUDIO_AMR_BAND_MODE_NB,\n+    SPA_AUDIO_AMR_BAND_MODE_WB,\n+};\n+\n+struct spa_audio_info_amr {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    enum spa_audio_amr_band_mode band_mode;\n+};\n+\n+#define SPA_AUDIO_INFO_AMR_INIT(...)        ((struct spa_audio_info_amr) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AMR_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/amr.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_IEC958_TYPES_H\n+#define SPA_AUDIO_IEC958_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/iec958.h>\n+\n+#define SPA_TYPE_INFO_AudioIEC958Codec        SPA_TYPE_INFO_ENUM_BASE \"AudioIEC958Codec\"\n+#define SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE    SPA_TYPE_INFO_AudioIEC958Codec \":\"\n+\n+static const struct spa_type_info spa_type_audio_iec958_codec[] = {\n+    { SPA_AUDIO_IEC958_CODEC_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_PCM, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"PCM\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_DTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"DTS\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_AC3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"AC3\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_MPEG, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"MPEG\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_MPEG2_AAC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"MPEG2-AAC\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_EAC3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"EAC3\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_TRUEHD, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"TrueHD\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_DTSHD, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"DTS-HD\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_IEC958_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/iec958-types.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2021 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_IEC958_H\n+#define SPA_AUDIO_IEC958_H\n+\n+#include <stdint.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+enum spa_audio_iec958_codec {\n+    SPA_AUDIO_IEC958_CODEC_UNKNOWN,\n+\n+    SPA_AUDIO_IEC958_CODEC_PCM,\n+    SPA_AUDIO_IEC958_CODEC_DTS,\n+    SPA_AUDIO_IEC958_CODEC_AC3,\n+    SPA_AUDIO_IEC958_CODEC_MPEG,        \/**< MPEG-1 or MPEG-2 (Part 3, not AAC) *\/\n+    SPA_AUDIO_IEC958_CODEC_MPEG2_AAC,    \/**< MPEG-2 AAC *\/\n+\n+    SPA_AUDIO_IEC958_CODEC_EAC3,\n+\n+    SPA_AUDIO_IEC958_CODEC_TRUEHD,        \/**< Dolby TrueHD *\/\n+    SPA_AUDIO_IEC958_CODEC_DTSHD,        \/**< DTS-HD Master Audio *\/\n+};\n+\n+struct spa_audio_info_iec958 {\n+    enum spa_audio_iec958_codec codec;    \/*< format, one of the DSP formats in enum spa_audio_format_dsp *\/\n+    uint32_t flags;                \/*< extra flags *\/\n+    uint32_t rate;                \/*< sample rate *\/\n+};\n+\n+#define SPA_AUDIO_INFO_IEC958_INIT(...)        ((struct spa_audio_info_iec958) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_IEC958_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/iec958.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_MP3_TYPES_H\n+#define SPA_AUDIO_MP3_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/mp3.h>\n+\n+#define SPA_TYPE_INFO_AudioMP3ChannelMode        SPA_TYPE_INFO_ENUM_BASE \"AudioMP3ChannelMode\"\n+#define SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE    SPA_TYPE_INFO_AudioMP3ChannelMode \":\"\n+\n+static const struct spa_type_info spa_type_audio_mp3_channel_mode[] = {\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_MONO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Mono\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_STEREO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Stereo\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Joint-stereo\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_DUAL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Dual\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_MP3_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/mp3-types.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_MP3_H\n+#define SPA_AUDIO_MP3_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_mp3_channel_mode {\n+    SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_MONO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_STEREO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_DUAL,\n+};\n+\n+struct spa_audio_info_mp3 {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+};\n+\n+#define SPA_AUDIO_INFO_MP3_INIT(...)        ((struct spa_audio_info_mp3) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_MP3_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/mp3.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_RAW_TYPES_H\n+#define SPA_AUDIO_RAW_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/raw.h>\n+\n+#define SPA_TYPE_INFO_AudioFormat        SPA_TYPE_INFO_ENUM_BASE \"AudioFormat\"\n+#define SPA_TYPE_INFO_AUDIO_FORMAT_BASE        SPA_TYPE_INFO_AudioFormat \":\"\n+\n+static const struct spa_type_info spa_type_audio_format[] = {\n+    { SPA_AUDIO_FORMAT_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_FORMAT_ENCODED, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ENCODED\", NULL },\n+    { SPA_AUDIO_FORMAT_S8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S8\", NULL },\n+    { SPA_AUDIO_FORMAT_U8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U8\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18BE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64LE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64BE\", NULL },\n+\n+    { SPA_AUDIO_FORMAT_ULAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ULAW\", NULL },\n+    { SPA_AUDIO_FORMAT_ALAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ALAW\", NULL },\n+\n+    { SPA_AUDIO_FORMAT_U8P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U8P\", NULL },\n+    { SPA_AUDIO_FORMAT_S16P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16P\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32P\", NULL },\n+    { SPA_AUDIO_FORMAT_S32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32P\", NULL },\n+    { SPA_AUDIO_FORMAT_S24P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24P\", NULL },\n+    { SPA_AUDIO_FORMAT_F32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32P\", NULL },\n+    { SPA_AUDIO_FORMAT_F64P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64P\", NULL },\n+    { SPA_AUDIO_FORMAT_S8P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S8P\", NULL },\n+\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    { SPA_AUDIO_FORMAT_S16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64\", NULL },\n+#elif __BYTE_ORDER == __LITTLE_ENDIAN\n+    { SPA_AUDIO_FORMAT_S16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64OE\", NULL },\n+#endif\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_AudioFlags    SPA_TYPE_INFO_FLAGS_BASE \"AudioFlags\"\n+#define SPA_TYPE_INFO_AUDIO_FLAGS_BASE    SPA_TYPE_INFO_AudioFlags \":\"\n+\n+static const struct spa_type_info spa_type_audio_flags[] = {\n+    { SPA_AUDIO_FLAG_NONE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FLAGS_BASE \"none\", NULL },\n+    { SPA_AUDIO_FLAG_UNPOSITIONED, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FLAGS_BASE \"unpositioned\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_AudioChannel        SPA_TYPE_INFO_ENUM_BASE \"AudioChannel\"\n+#define SPA_TYPE_INFO_AUDIO_CHANNEL_BASE    SPA_TYPE_INFO_AudioChannel \":\"\n+\n+static const struct spa_type_info spa_type_audio_channel[] = {\n+    { SPA_AUDIO_CHANNEL_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"UNK\", NULL },\n+    { SPA_AUDIO_CHANNEL_NA,    SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"NA\", NULL },\n+    { SPA_AUDIO_CHANNEL_MONO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"MONO\", NULL },\n+    { SPA_AUDIO_CHANNEL_FL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FL\", NULL },\n+    { SPA_AUDIO_CHANNEL_FR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FR\", NULL },\n+    { SPA_AUDIO_CHANNEL_FC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FC\", NULL },\n+    { SPA_AUDIO_CHANNEL_LFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LFE\", NULL },\n+    { SPA_AUDIO_CHANNEL_SL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"SL\", NULL },\n+    { SPA_AUDIO_CHANNEL_SR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"SR\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RL\", NULL },\n+    { SPA_AUDIO_CHANNEL_RR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RR\", NULL },\n+    { SPA_AUDIO_CHANNEL_TC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFR\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRR\", NULL },\n+    { SPA_AUDIO_CHANNEL_RLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLW\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRW\", NULL },\n+    { SPA_AUDIO_CHANNEL_LFE2, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LFE2\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLH\", NULL },\n+    { SPA_AUDIO_CHANNEL_FCH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FCH\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRH\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TSL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TSL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TSR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TSR\", NULL },\n+    { SPA_AUDIO_CHANNEL_LLFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LLFR\", NULL },\n+    { SPA_AUDIO_CHANNEL_RLFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RLFE\", NULL },\n+    { SPA_AUDIO_CHANNEL_BC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BC\", NULL },\n+    { SPA_AUDIO_CHANNEL_BLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_BRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BRC\", NULL },\n+\n+    { SPA_AUDIO_CHANNEL_AUX0, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX0\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX1, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX1\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX2, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX2\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX3\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX4, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX4\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX5, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX5\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX6, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX6\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX7, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX7\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX8\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX9, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX9\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX10, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX10\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX11, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX11\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX12, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX12\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX13, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX13\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX14, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX14\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX15, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX15\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX16\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX17, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX17\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX18\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX19, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX19\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX20\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX21, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX21\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX22, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX22\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX23, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX23\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX24\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX25, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX25\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX26, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX26\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX27, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX27\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX28, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX28\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX29, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX29\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX30, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX30\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX31, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX31\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX32\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX33, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX33\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX34, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX34\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX35, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX35\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX36, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX36\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX37, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX37\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX38, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX38\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX39, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX39\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX40, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX40\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX41, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX41\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX42, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX42\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX43, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX43\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX44, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX44\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX45, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX45\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX46, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX46\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX47, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX47\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX48, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX48\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX49, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX49\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX50, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX50\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX51, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX51\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX52, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX52\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX53, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX53\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX54, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX54\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX55, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX55\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX56, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX56\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX57, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX57\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX58, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX58\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX59, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX59\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX60, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX60\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX61, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX61\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX62, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX62\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX63, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX63\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_RAW_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/raw-types.h","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_RAW_H\n+#define SPA_AUDIO_RAW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+\n+#if !defined(__FreeBSD__) && !defined(__MidnightBSD__)\n+#include <endian.h>\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#define SPA_AUDIO_MAX_CHANNELS    64u\n+\n+enum spa_audio_format {\n+    SPA_AUDIO_FORMAT_UNKNOWN,\n+    SPA_AUDIO_FORMAT_ENCODED,\n+\n+    \/* interleaved formats *\/\n+    SPA_AUDIO_FORMAT_START_Interleaved    = 0x100,\n+    SPA_AUDIO_FORMAT_S8,\n+    SPA_AUDIO_FORMAT_U8,\n+    SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64_LE,\n+    SPA_AUDIO_FORMAT_F64_BE,\n+\n+    SPA_AUDIO_FORMAT_ULAW,\n+    SPA_AUDIO_FORMAT_ALAW,\n+\n+    \/* planar formats *\/\n+    SPA_AUDIO_FORMAT_START_Planar        = 0x200,\n+    SPA_AUDIO_FORMAT_U8P,\n+    SPA_AUDIO_FORMAT_S16P,\n+    SPA_AUDIO_FORMAT_S24_32P,\n+    SPA_AUDIO_FORMAT_S32P,\n+    SPA_AUDIO_FORMAT_S24P,\n+    SPA_AUDIO_FORMAT_F32P,\n+    SPA_AUDIO_FORMAT_F64P,\n+    SPA_AUDIO_FORMAT_S8P,\n+\n+    \/* other formats start here *\/\n+    SPA_AUDIO_FORMAT_START_Other        = 0x400,\n+\n+    \/* Aliases *\/\n+\n+    \/* DSP formats *\/\n+    SPA_AUDIO_FORMAT_DSP_S32 = SPA_AUDIO_FORMAT_S24_32P,\n+    SPA_AUDIO_FORMAT_DSP_F32 = SPA_AUDIO_FORMAT_F32P,\n+    SPA_AUDIO_FORMAT_DSP_F64 = SPA_AUDIO_FORMAT_F64P,\n+\n+    \/* native endian *\/\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    SPA_AUDIO_FORMAT_S16 = SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16 = SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32 = SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32 = SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32 = SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32 = SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24 = SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24 = SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20 = SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20 = SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18 = SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18 = SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32 = SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64 = SPA_AUDIO_FORMAT_F64_BE,\n+    SPA_AUDIO_FORMAT_S16_OE = SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_U16_OE = SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_S24_32_OE = SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32_OE = SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_S32_OE = SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_U32_OE = SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_S24_OE = SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_U24_OE = SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_S20_OE = SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_U20_OE = SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_S18_OE = SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_U18_OE = SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_F32_OE = SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F64_OE = SPA_AUDIO_FORMAT_F64_LE,\n+#elif __BYTE_ORDER == __LITTLE_ENDIAN\n+    SPA_AUDIO_FORMAT_S16 = SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_U16 = SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_S24_32 = SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32 = SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_S32 = SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_U32 = SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_S24 = SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_U24 = SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_S20 = SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_U20 = SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_S18 = SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_U18 = SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_F32 = SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F64 = SPA_AUDIO_FORMAT_F64_LE,\n+    SPA_AUDIO_FORMAT_S16_OE = SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16_OE = SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32_OE = SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32_OE = SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32_OE = SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32_OE = SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24_OE = SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24_OE = SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20_OE = SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20_OE = SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18_OE = SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18_OE = SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32_OE = SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64_OE = SPA_AUDIO_FORMAT_F64_BE,\n+#endif\n+};\n+\n+#define SPA_AUDIO_FORMAT_IS_INTERLEAVED(fmt)    ((fmt) > SPA_AUDIO_FORMAT_START_Interleaved && (fmt) < SPA_AUDIO_FORMAT_START_Planar)\n+#define SPA_AUDIO_FORMAT_IS_PLANAR(fmt)        ((fmt) > SPA_AUDIO_FORMAT_START_Planar && (fmt) < SPA_AUDIO_FORMAT_START_Other)\n+\n+enum spa_audio_channel {\n+    SPA_AUDIO_CHANNEL_UNKNOWN,    \/**< unspecified *\/\n+    SPA_AUDIO_CHANNEL_NA,        \/**< N\/A, silent *\/\n+\n+    SPA_AUDIO_CHANNEL_MONO,         \/**< mono stream *\/\n+\n+    SPA_AUDIO_CHANNEL_FL,           \/**< front left *\/\n+    SPA_AUDIO_CHANNEL_FR,           \/**< front right *\/\n+    SPA_AUDIO_CHANNEL_FC,           \/**< front center *\/\n+    SPA_AUDIO_CHANNEL_LFE,          \/**< LFE *\/\n+    SPA_AUDIO_CHANNEL_SL,           \/**< side left *\/\n+    SPA_AUDIO_CHANNEL_SR,           \/**< side right *\/\n+    SPA_AUDIO_CHANNEL_FLC,          \/**< front left center *\/\n+    SPA_AUDIO_CHANNEL_FRC,          \/**< front right center *\/\n+    SPA_AUDIO_CHANNEL_RC,           \/**< rear center *\/\n+    SPA_AUDIO_CHANNEL_RL,           \/**< rear left *\/\n+    SPA_AUDIO_CHANNEL_RR,           \/**< rear right *\/\n+    SPA_AUDIO_CHANNEL_TC,           \/**< top center *\/\n+    SPA_AUDIO_CHANNEL_TFL,          \/**< top front left *\/\n+    SPA_AUDIO_CHANNEL_TFC,          \/**< top front center *\/\n+    SPA_AUDIO_CHANNEL_TFR,          \/**< top front right *\/\n+    SPA_AUDIO_CHANNEL_TRL,          \/**< top rear left *\/\n+    SPA_AUDIO_CHANNEL_TRC,          \/**< top rear center *\/\n+    SPA_AUDIO_CHANNEL_TRR,          \/**< top rear right *\/\n+    SPA_AUDIO_CHANNEL_RLC,          \/**< rear left center *\/\n+    SPA_AUDIO_CHANNEL_RRC,          \/**< rear right center *\/\n+    SPA_AUDIO_CHANNEL_FLW,          \/**< front left wide *\/\n+    SPA_AUDIO_CHANNEL_FRW,          \/**< front right wide *\/\n+    SPA_AUDIO_CHANNEL_LFE2,        \/**< LFE 2 *\/\n+    SPA_AUDIO_CHANNEL_FLH,          \/**< front left high *\/\n+    SPA_AUDIO_CHANNEL_FCH,          \/**< front center high *\/\n+    SPA_AUDIO_CHANNEL_FRH,          \/**< front right high *\/\n+    SPA_AUDIO_CHANNEL_TFLC,         \/**< top front left center *\/\n+    SPA_AUDIO_CHANNEL_TFRC,         \/**< top front right center *\/\n+    SPA_AUDIO_CHANNEL_TSL,          \/**< top side left *\/\n+    SPA_AUDIO_CHANNEL_TSR,          \/**< top side right *\/\n+    SPA_AUDIO_CHANNEL_LLFE,         \/**< left LFE *\/\n+    SPA_AUDIO_CHANNEL_RLFE,         \/**< right LFE *\/\n+    SPA_AUDIO_CHANNEL_BC,           \/**< bottom center *\/\n+    SPA_AUDIO_CHANNEL_BLC,          \/**< bottom left center *\/\n+    SPA_AUDIO_CHANNEL_BRC,          \/**< bottom right center *\/\n+\n+    SPA_AUDIO_CHANNEL_START_Aux    = 0x1000,    \/**< aux channels *\/\n+    SPA_AUDIO_CHANNEL_AUX0 = SPA_AUDIO_CHANNEL_START_Aux,\n+    SPA_AUDIO_CHANNEL_AUX1,\n+    SPA_AUDIO_CHANNEL_AUX2,\n+    SPA_AUDIO_CHANNEL_AUX3,\n+    SPA_AUDIO_CHANNEL_AUX4,\n+    SPA_AUDIO_CHANNEL_AUX5,\n+    SPA_AUDIO_CHANNEL_AUX6,\n+    SPA_AUDIO_CHANNEL_AUX7,\n+    SPA_AUDIO_CHANNEL_AUX8,\n+    SPA_AUDIO_CHANNEL_AUX9,\n+    SPA_AUDIO_CHANNEL_AUX10,\n+    SPA_AUDIO_CHANNEL_AUX11,\n+    SPA_AUDIO_CHANNEL_AUX12,\n+    SPA_AUDIO_CHANNEL_AUX13,\n+    SPA_AUDIO_CHANNEL_AUX14,\n+    SPA_AUDIO_CHANNEL_AUX15,\n+    SPA_AUDIO_CHANNEL_AUX16,\n+    SPA_AUDIO_CHANNEL_AUX17,\n+    SPA_AUDIO_CHANNEL_AUX18,\n+    SPA_AUDIO_CHANNEL_AUX19,\n+    SPA_AUDIO_CHANNEL_AUX20,\n+    SPA_AUDIO_CHANNEL_AUX21,\n+    SPA_AUDIO_CHANNEL_AUX22,\n+    SPA_AUDIO_CHANNEL_AUX23,\n+    SPA_AUDIO_CHANNEL_AUX24,\n+    SPA_AUDIO_CHANNEL_AUX25,\n+    SPA_AUDIO_CHANNEL_AUX26,\n+    SPA_AUDIO_CHANNEL_AUX27,\n+    SPA_AUDIO_CHANNEL_AUX28,\n+    SPA_AUDIO_CHANNEL_AUX29,\n+    SPA_AUDIO_CHANNEL_AUX30,\n+    SPA_AUDIO_CHANNEL_AUX31,\n+    SPA_AUDIO_CHANNEL_AUX32,\n+    SPA_AUDIO_CHANNEL_AUX33,\n+    SPA_AUDIO_CHANNEL_AUX34,\n+    SPA_AUDIO_CHANNEL_AUX35,\n+    SPA_AUDIO_CHANNEL_AUX36,\n+    SPA_AUDIO_CHANNEL_AUX37,\n+    SPA_AUDIO_CHANNEL_AUX38,\n+    SPA_AUDIO_CHANNEL_AUX39,\n+    SPA_AUDIO_CHANNEL_AUX40,\n+    SPA_AUDIO_CHANNEL_AUX41,\n+    SPA_AUDIO_CHANNEL_AUX42,\n+    SPA_AUDIO_CHANNEL_AUX43,\n+    SPA_AUDIO_CHANNEL_AUX44,\n+    SPA_AUDIO_CHANNEL_AUX45,\n+    SPA_AUDIO_CHANNEL_AUX46,\n+    SPA_AUDIO_CHANNEL_AUX47,\n+    SPA_AUDIO_CHANNEL_AUX48,\n+    SPA_AUDIO_CHANNEL_AUX49,\n+    SPA_AUDIO_CHANNEL_AUX50,\n+    SPA_AUDIO_CHANNEL_AUX51,\n+    SPA_AUDIO_CHANNEL_AUX52,\n+    SPA_AUDIO_CHANNEL_AUX53,\n+    SPA_AUDIO_CHANNEL_AUX54,\n+    SPA_AUDIO_CHANNEL_AUX55,\n+    SPA_AUDIO_CHANNEL_AUX56,\n+    SPA_AUDIO_CHANNEL_AUX57,\n+    SPA_AUDIO_CHANNEL_AUX58,\n+    SPA_AUDIO_CHANNEL_AUX59,\n+    SPA_AUDIO_CHANNEL_AUX60,\n+    SPA_AUDIO_CHANNEL_AUX61,\n+    SPA_AUDIO_CHANNEL_AUX62,\n+    SPA_AUDIO_CHANNEL_AUX63,\n+\n+    SPA_AUDIO_CHANNEL_LAST_Aux    = 0x1fff,    \/**< aux channels *\/\n+\n+    SPA_AUDIO_CHANNEL_START_Custom    = 0x10000,\n+};\n+\n+enum spa_audio_volume_ramp_scale {\n+    SPA_AUDIO_VOLUME_RAMP_INVALID,\n+    SPA_AUDIO_VOLUME_RAMP_LINEAR,\n+    SPA_AUDIO_VOLUME_RAMP_CUBIC,\n+};\n+\n+\/** Extra audio flags *\/\n+#define SPA_AUDIO_FLAG_NONE        (0)        \/*< no valid flag *\/\n+#define SPA_AUDIO_FLAG_UNPOSITIONED    (1 << 0)    \/*< the position array explicitly\n+                             *  contains unpositioned channels. *\/\n+\/** Audio information description *\/\n+struct spa_audio_info_raw {\n+    enum spa_audio_format format;        \/*< format, one of enum spa_audio_format *\/\n+    uint32_t flags;                \/*< extra flags *\/\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    uint32_t position[SPA_AUDIO_MAX_CHANNELS];    \/*< channel position from enum spa_audio_channel *\/\n+};\n+\n+#define SPA_AUDIO_INFO_RAW_INIT(...)        ((struct spa_audio_info_raw) { __VA_ARGS__ })\n+\n+#define SPA_KEY_AUDIO_FORMAT        \"audio.format\"        \/**< an audio format as string,\n+                                  *  Ex. \"S16LE\" *\/\n+#define SPA_KEY_AUDIO_CHANNEL        \"audio.channel\"        \/**< an audio channel as string,\n+                                  *  Ex. \"FL\" *\/\n+#define SPA_KEY_AUDIO_CHANNELS        \"audio.channels\"    \/**< an audio channel count as int *\/\n+#define SPA_KEY_AUDIO_RATE        \"audio.rate\"        \/**< an audio sample rate as int *\/\n+#define SPA_KEY_AUDIO_POSITION        \"audio.position\"    \/**< channel positions as comma separated list\n+                                  *  of channels ex. \"FL,FR\" *\/\n+#define SPA_KEY_AUDIO_ALLOWED_RATES    \"audio.allowed-rates\"    \/**< a list of allowed samplerates\n+                                  *  ex. \"[ 44100 48000 ]\" *\/\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/raw.h","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_TYPES_H\n+#define SPA_AUDIO_TYPES_H\n+\n+#include <spa\/param\/audio\/raw-types.h>\n+#include <spa\/param\/audio\/iec958-types.h>\n+#include <spa\/param\/audio\/mp3-types.h>\n+#include <spa\/param\/audio\/aac-types.h>\n+#include <spa\/param\/audio\/wma-types.h>\n+#include <spa\/param\/audio\/amr-types.h>\n+\n+#endif \/* SPA_AUDIO_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/type-info.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_WMA_TYPES_H\n+#define SPA_AUDIO_WMA_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/wma.h>\n+\n+#define SPA_TYPE_INFO_AudioWMAProfile        SPA_TYPE_INFO_ENUM_BASE \"AudioWMAProfile\"\n+#define SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE    SPA_TYPE_INFO_AudioWMAProfile \":\"\n+\n+static const struct spa_type_info spa_type_audio_wma_profile[] = {\n+    { SPA_AUDIO_WMA_PROFILE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA7, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA7\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA8\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA10, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA10\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9_PRO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9-Pro\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9-Lossless\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA10-Lossless\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_WMA_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/wma-types.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_WMA_H\n+#define SPA_AUDIO_WMA_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_wma_profile {\n+    SPA_AUDIO_WMA_PROFILE_UNKNOWN,\n+\n+    SPA_AUDIO_WMA_PROFILE_WMA7,\n+    SPA_AUDIO_WMA_PROFILE_WMA8,\n+    SPA_AUDIO_WMA_PROFILE_WMA9,\n+    SPA_AUDIO_WMA_PROFILE_WMA10,\n+    SPA_AUDIO_WMA_PROFILE_WMA9_PRO,\n+    SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS,\n+    SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS,\n+\n+    SPA_AUDIO_WMA_PROFILE_CUSTOM = 0x10000,\n+};\n+\n+struct spa_audio_info_wma {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    uint32_t bitrate;            \/*< stream bitrate *\/\n+    uint32_t block_align;            \/*< block alignment *\/\n+    enum spa_audio_wma_profile profile;    \/*< WMA profile *\/\n+\n+};\n+\n+#define SPA_AUDIO_INFO_WMA_INIT(...)        ((struct spa_audio_info_wma) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_WMA_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/wma.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BLUETOOTH_AUDIO_H\n+#define SPA_BLUETOOTH_AUDIO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+enum spa_bluetooth_audio_codec {\n+    SPA_BLUETOOTH_AUDIO_CODEC_START,\n+\n+    \/* A2DP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_SBC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ,\n+    SPA_BLUETOOTH_AUDIO_CODEC_MPEG,\n+    SPA_BLUETOOTH_AUDIO_CODEC_AAC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD,\n+    SPA_BLUETOOTH_AUDIO_CODEC_LDAC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM,\n+    SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO,\n+\n+    \/* HFP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_CVSD = 0x100,\n+    SPA_BLUETOOTH_AUDIO_CODEC_MSBC,\n+\n+    \/* BAP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_LC3 = 0x200,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BLUETOOTH_AUDIO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/bluetooth\/audio.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BLUETOOTH_TYPES_H\n+#define SPA_BLUETOOTH_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/bluetooth\/audio.h>\n+\n+#define SPA_TYPE_INFO_BluetoothAudioCodec        SPA_TYPE_INFO_ENUM_BASE \"BluetoothAudioCodec\"\n+#define SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE    SPA_TYPE_INFO_BluetoothAudioCodec \":\"\n+\n+static const struct spa_type_info spa_type_bluetooth_audio_codec[] = {\n+    \/* A2DP *\/\n+    { SPA_BLUETOOTH_AUDIO_CODEC_SBC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"sbc\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"sbc_xq\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_MPEG, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"mpeg\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_AAC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aac\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_hd\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LDAC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"ldac\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_ll\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_ll_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"faststream\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"faststream_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"lc3plus_hr\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_51\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_71\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_pro\", NULL },\n+\n+    { SPA_BLUETOOTH_AUDIO_CODEC_CVSD, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"cvsd\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_MSBC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"msbc\", NULL },\n+\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LC3, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"lc3\", NULL },\n+\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BLUETOOTH_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/bluetooth\/type-info.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_BUFFERS_TYPES_H\n+#define SPA_PARAM_BUFFERS_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/node\/type-info.h>\n+\n+#include <spa\/param\/buffers.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Meta        SPA_TYPE_INFO_PARAM_BASE \"Meta\"\n+#define SPA_TYPE_INFO_PARAM_META_BASE        SPA_TYPE_INFO_PARAM_Meta \":\"\n+\n+static const struct spa_type_info spa_type_param_meta[] = {\n+    { SPA_PARAM_META_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_META_BASE, spa_type_param },\n+    { SPA_PARAM_META_type, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_META_BASE \"type\", spa_type_meta_type },\n+    { SPA_PARAM_META_size, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_META_BASE \"size\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/** Base for parameters that describe IO areas to exchange data,\n+ * control and properties with a node.\n+ *\/\n+#define SPA_TYPE_INFO_PARAM_IO        SPA_TYPE_INFO_PARAM_BASE \"IO\"\n+#define SPA_TYPE_INFO_PARAM_IO_BASE        SPA_TYPE_INFO_PARAM_IO \":\"\n+\n+static const struct spa_type_info spa_type_param_io[] = {\n+    { SPA_PARAM_IO_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_IO_BASE, spa_type_param, },\n+    { SPA_PARAM_IO_id, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_IO_BASE \"id\", spa_type_io },\n+    { SPA_PARAM_IO_size, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_IO_BASE \"size\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_Buffers            SPA_TYPE_INFO_PARAM_BASE \"Buffers\"\n+#define SPA_TYPE_INFO_PARAM_BUFFERS_BASE        SPA_TYPE_INFO_PARAM_Buffers \":\"\n+\n+#define SPA_TYPE_INFO_PARAM_BlockInfo            SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"BlockInfo\"\n+#define SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE        SPA_TYPE_INFO_PARAM_BlockInfo \":\"\n+\n+static const struct spa_type_info spa_type_param_buffers[] = {\n+    { SPA_PARAM_BUFFERS_START,    SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_BUFFERS_BASE, spa_type_param, },\n+    { SPA_PARAM_BUFFERS_buffers,  SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"buffers\", NULL },\n+    { SPA_PARAM_BUFFERS_blocks,   SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"blocks\", NULL },\n+    { SPA_PARAM_BUFFERS_size,     SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"size\", NULL },\n+    { SPA_PARAM_BUFFERS_stride,   SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"stride\", NULL },\n+    { SPA_PARAM_BUFFERS_align,    SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"align\", NULL },\n+    { SPA_PARAM_BUFFERS_dataType, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"dataType\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_BUFFERS_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/buffers-types.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_BUFFERS_H\n+#define SPA_PARAM_BUFFERS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamBuffers *\/\n+enum spa_param_buffers {\n+    SPA_PARAM_BUFFERS_START,\n+    SPA_PARAM_BUFFERS_buffers,    \/**< number of buffers (Int) *\/\n+    SPA_PARAM_BUFFERS_blocks,    \/**< number of data blocks per buffer (Int) *\/\n+    SPA_PARAM_BUFFERS_size,        \/**< size of a data block memory (Int)*\/\n+    SPA_PARAM_BUFFERS_stride,    \/**< stride of data block memory (Int) *\/\n+    SPA_PARAM_BUFFERS_align,    \/**< alignment of data block memory (Int) *\/\n+    SPA_PARAM_BUFFERS_dataType,    \/**< possible memory types (Int, mask of enum spa_data_type) *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamMeta *\/\n+enum spa_param_meta {\n+    SPA_PARAM_META_START,\n+    SPA_PARAM_META_type,    \/**< the metadata, one of enum spa_meta_type (Id enum spa_meta_type) *\/\n+    SPA_PARAM_META_size,    \/**< the expected maximum size the meta (Int) *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamIO *\/\n+enum spa_param_io {\n+    SPA_PARAM_IO_START,\n+    SPA_PARAM_IO_id,    \/**< type ID, uniquely identifies the io area (Id enum spa_io_type) *\/\n+    SPA_PARAM_IO_size,    \/**< size of the io area (Int) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_BUFFERS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/buffers.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_TYPES_H\n+#define SPA_PARAM_FORMAT_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/audio\/type-info.h>\n+#include <spa\/param\/video\/type-info.h>\n+\n+#define SPA_TYPE_INFO_Format            SPA_TYPE_INFO_PARAM_BASE \"Format\"\n+#define SPA_TYPE_INFO_FORMAT_BASE        SPA_TYPE_INFO_Format \":\"\n+\n+#define SPA_TYPE_INFO_MediaType        SPA_TYPE_INFO_ENUM_BASE \"MediaType\"\n+#define SPA_TYPE_INFO_MEDIA_TYPE_BASE    SPA_TYPE_INFO_MediaType \":\"\n+\n+static const struct spa_type_info spa_type_media_type[] = {\n+    { SPA_MEDIA_TYPE_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"unknown\", NULL },\n+    { SPA_MEDIA_TYPE_audio,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"audio\", NULL },\n+    { SPA_MEDIA_TYPE_video,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"video\", NULL },\n+    { SPA_MEDIA_TYPE_image,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"image\", NULL },\n+    { SPA_MEDIA_TYPE_binary,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"binary\", NULL },\n+    { SPA_MEDIA_TYPE_stream,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"stream\", NULL },\n+    { SPA_MEDIA_TYPE_application,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"application\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_MediaSubtype        SPA_TYPE_INFO_ENUM_BASE \"MediaSubtype\"\n+#define SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE    SPA_TYPE_INFO_MediaSubtype \":\"\n+\n+static const struct spa_type_info spa_type_media_subtype[] = {\n+    { SPA_MEDIA_SUBTYPE_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"unknown\", NULL },\n+    \/* generic subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_raw, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"raw\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dsp, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dsp\", NULL },\n+    { SPA_MEDIA_SUBTYPE_iec958, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"iec958\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dsd, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dsd\", NULL },\n+    \/* audio subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_mp3, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mp3\", NULL },\n+    { SPA_MEDIA_SUBTYPE_aac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"aac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vorbis, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vorbis\", NULL },\n+    { SPA_MEDIA_SUBTYPE_wma, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"wma\", NULL },\n+    { SPA_MEDIA_SUBTYPE_ra, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"ra\", NULL },\n+    { SPA_MEDIA_SUBTYPE_sbc, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"sbc\", NULL },\n+    { SPA_MEDIA_SUBTYPE_adpcm, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"adpcm\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g723, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g723\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g726, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g726\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g729, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g729\", NULL },\n+    { SPA_MEDIA_SUBTYPE_amr, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"amr\", NULL },\n+    { SPA_MEDIA_SUBTYPE_gsm, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"gsm\", NULL },\n+    { SPA_MEDIA_SUBTYPE_alac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"alac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_flac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"flac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_ape, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"ape\", NULL },\n+    { SPA_MEDIA_SUBTYPE_opus, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"opus\", NULL },\n+    \/* video subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_h264, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"h264\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mjpg, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mjpg\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dv, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dv\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpegts, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpegts\", NULL },\n+    { SPA_MEDIA_SUBTYPE_h263, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"h263\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg1, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg1\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg2, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg2\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg4, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg4\", NULL },\n+    { SPA_MEDIA_SUBTYPE_xvid, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"xvid\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vc1, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vc1\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vp8, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vp8\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vp9, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vp9\", NULL },\n+    { SPA_MEDIA_SUBTYPE_bayer, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"bayer\", NULL },\n+    \/* image subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_jpeg, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"jpeg\", NULL },\n+    \/* stream subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_midi, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"midi\", NULL },\n+    \/* application subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_control, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"control\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_FormatAudio        SPA_TYPE_INFO_FORMAT_BASE \"Audio\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_BASE        SPA_TYPE_INFO_FormatAudio \":\"\n+\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AAC        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"AAC\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_AAC \":\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_WMA        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"WMA\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_WMA \":\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AMR        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"AMR\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_AMR \":\"\n+\n+#define SPA_TYPE_INFO_FormatVideo        SPA_TYPE_INFO_FORMAT_BASE \"Video\"\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_BASE        SPA_TYPE_INFO_FormatVideo \":\"\n+\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_H264        SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"H264\"\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE    SPA_TYPE_INFO_FORMAT_VIDEO_H264 \":\"\n+\n+static const struct spa_type_info spa_type_format[] = {\n+    { SPA_FORMAT_START, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE, spa_type_param, },\n+\n+    { SPA_FORMAT_mediaType, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE \"mediaType\",\n+        spa_type_media_type, },\n+    { SPA_FORMAT_mediaSubtype, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE \"mediaSubtype\",\n+        spa_type_media_subtype, },\n+\n+    { SPA_FORMAT_AUDIO_format, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"format\",\n+        spa_type_audio_format },\n+    { SPA_FORMAT_AUDIO_flags, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"flags\",\n+        spa_type_audio_flags },\n+    { SPA_FORMAT_AUDIO_rate, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"rate\", NULL },\n+    { SPA_FORMAT_AUDIO_channels, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"channels\", NULL },\n+    { SPA_FORMAT_AUDIO_position, SPA_TYPE_Array, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"position\",\n+        spa_type_prop_channel_map },\n+\n+    { SPA_FORMAT_AUDIO_iec958Codec, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"iec958Codec\",\n+        spa_type_audio_iec958_codec },\n+\n+    { SPA_FORMAT_AUDIO_bitorder, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"bitorder\",\n+        spa_type_param_bitorder },\n+    { SPA_FORMAT_AUDIO_interleave, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"interleave\", NULL },\n+    { SPA_FORMAT_AUDIO_bitrate, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"bitrate\", NULL },\n+    { SPA_FORMAT_AUDIO_blockAlign, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"blockAlign\", NULL },\n+\n+    { SPA_FORMAT_AUDIO_AAC_streamFormat, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE \"streamFormat\",\n+        spa_type_audio_aac_stream_format },\n+    { SPA_FORMAT_AUDIO_WMA_profile, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE \"profile\",\n+        spa_type_audio_wma_profile },\n+    { SPA_FORMAT_AUDIO_AMR_bandMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE \"bandMode\",\n+        spa_type_audio_amr_band_mode },\n+\n+    { SPA_FORMAT_VIDEO_format, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"format\",\n+        spa_type_video_format, },\n+    { SPA_FORMAT_VIDEO_modifier, SPA_TYPE_Long, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"modifier\", NULL },\n+    { SPA_FORMAT_VIDEO_size,  SPA_TYPE_Rectangle, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"size\", NULL },\n+    { SPA_FORMAT_VIDEO_framerate, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"framerate\", NULL },\n+    { SPA_FORMAT_VIDEO_maxFramerate, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"maxFramerate\", NULL },\n+    { SPA_FORMAT_VIDEO_views, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"views\", NULL },\n+    { SPA_FORMAT_VIDEO_interlaceMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"interlaceMode\",\n+        spa_type_video_interlace_mode, },\n+    { SPA_FORMAT_VIDEO_pixelAspectRatio, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"pixelAspectRatio\", NULL },\n+    { SPA_FORMAT_VIDEO_multiviewMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"multiviewMode\", NULL },\n+    { SPA_FORMAT_VIDEO_multiviewFlags, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"multiviewFlags\", NULL },\n+    { SPA_FORMAT_VIDEO_chromaSite, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"chromaSite\", NULL },\n+    { SPA_FORMAT_VIDEO_colorRange, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorRange\", NULL },\n+    { SPA_FORMAT_VIDEO_colorMatrix, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorMatrix\", NULL },\n+    { SPA_FORMAT_VIDEO_transferFunction, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"transferFunction\", NULL },\n+    { SPA_FORMAT_VIDEO_colorPrimaries, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorPrimaries\", NULL },\n+    { SPA_FORMAT_VIDEO_profile, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"profile\", NULL },\n+    { SPA_FORMAT_VIDEO_level, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"level\", NULL },\n+\n+    { SPA_FORMAT_VIDEO_H264_streamFormat, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE \"streamFormat\", NULL },\n+    { SPA_FORMAT_VIDEO_H264_alignment, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE \"alignment\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format-types.h","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_UTILS_H\n+#define SPA_PARAM_FORMAT_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/param\/format.h>\n+\n+static inline int\n+spa_format_parse(const struct spa_pod *format, uint32_t *media_type, uint32_t *media_subtype)\n+{\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_mediaType,    SPA_POD_Id(media_type),\n+        SPA_FORMAT_mediaSubtype, SPA_POD_Id(media_subtype));\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format-utils.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_H\n+#define SPA_PARAM_FORMAT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** media type for SPA_TYPE_OBJECT_Format *\/\n+enum spa_media_type {\n+    SPA_MEDIA_TYPE_unknown,\n+    SPA_MEDIA_TYPE_audio,\n+    SPA_MEDIA_TYPE_video,\n+    SPA_MEDIA_TYPE_image,\n+    SPA_MEDIA_TYPE_binary,\n+    SPA_MEDIA_TYPE_stream,\n+    SPA_MEDIA_TYPE_application,\n+};\n+\n+\/** media subtype for SPA_TYPE_OBJECT_Format *\/\n+enum spa_media_subtype {\n+    SPA_MEDIA_SUBTYPE_unknown,\n+    SPA_MEDIA_SUBTYPE_raw,\n+    SPA_MEDIA_SUBTYPE_dsp,\n+    SPA_MEDIA_SUBTYPE_iec958,    \/** S\/PDIF *\/\n+    SPA_MEDIA_SUBTYPE_dsd,\n+\n+    SPA_MEDIA_SUBTYPE_START_Audio    = 0x10000,\n+    SPA_MEDIA_SUBTYPE_mp3,\n+    SPA_MEDIA_SUBTYPE_aac,\n+    SPA_MEDIA_SUBTYPE_vorbis,\n+    SPA_MEDIA_SUBTYPE_wma,\n+    SPA_MEDIA_SUBTYPE_ra,\n+    SPA_MEDIA_SUBTYPE_sbc,\n+    SPA_MEDIA_SUBTYPE_adpcm,\n+    SPA_MEDIA_SUBTYPE_g723,\n+    SPA_MEDIA_SUBTYPE_g726,\n+    SPA_MEDIA_SUBTYPE_g729,\n+    SPA_MEDIA_SUBTYPE_amr,\n+    SPA_MEDIA_SUBTYPE_gsm,\n+    SPA_MEDIA_SUBTYPE_alac,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_flac,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_ape,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_opus,        \/** since 0.3.68 *\/\n+\n+    SPA_MEDIA_SUBTYPE_START_Video    = 0x20000,\n+    SPA_MEDIA_SUBTYPE_h264,\n+    SPA_MEDIA_SUBTYPE_mjpg,\n+    SPA_MEDIA_SUBTYPE_dv,\n+    SPA_MEDIA_SUBTYPE_mpegts,\n+    SPA_MEDIA_SUBTYPE_h263,\n+    SPA_MEDIA_SUBTYPE_mpeg1,\n+    SPA_MEDIA_SUBTYPE_mpeg2,\n+    SPA_MEDIA_SUBTYPE_mpeg4,\n+    SPA_MEDIA_SUBTYPE_xvid,\n+    SPA_MEDIA_SUBTYPE_vc1,\n+    SPA_MEDIA_SUBTYPE_vp8,\n+    SPA_MEDIA_SUBTYPE_vp9,\n+    SPA_MEDIA_SUBTYPE_bayer,\n+\n+    SPA_MEDIA_SUBTYPE_START_Image    = 0x30000,\n+    SPA_MEDIA_SUBTYPE_jpeg,\n+\n+    SPA_MEDIA_SUBTYPE_START_Binary    = 0x40000,\n+\n+    SPA_MEDIA_SUBTYPE_START_Stream    = 0x50000,\n+    SPA_MEDIA_SUBTYPE_midi,\n+\n+    SPA_MEDIA_SUBTYPE_START_Application    = 0x60000,\n+    SPA_MEDIA_SUBTYPE_control,        \/**< control stream, data contains\n+                          *  spa_pod_sequence with control info. *\/\n+};\n+\n+\/** properties for audio SPA_TYPE_OBJECT_Format *\/\n+enum spa_format {\n+    SPA_FORMAT_START,\n+\n+    SPA_FORMAT_mediaType,        \/**< media type (Id enum spa_media_type) *\/\n+    SPA_FORMAT_mediaSubtype,    \/**< media subtype (Id enum spa_media_subtype) *\/\n+\n+    \/* Audio format keys *\/\n+    SPA_FORMAT_START_Audio = 0x10000,\n+    SPA_FORMAT_AUDIO_format,        \/**< audio format, (Id enum spa_audio_format) *\/\n+    SPA_FORMAT_AUDIO_flags,            \/**< optional flags (Int) *\/\n+    SPA_FORMAT_AUDIO_rate,            \/**< sample rate (Int) *\/\n+    SPA_FORMAT_AUDIO_channels,        \/**< number of audio channels (Int) *\/\n+    SPA_FORMAT_AUDIO_position,        \/**< channel positions (Id enum spa_audio_position) *\/\n+\n+    SPA_FORMAT_AUDIO_iec958Codec,        \/**< codec used (IEC958) (Id enum spa_audio_iec958_codec) *\/\n+\n+    SPA_FORMAT_AUDIO_bitorder,        \/**< bit order (Id enum spa_param_bitorder) *\/\n+    SPA_FORMAT_AUDIO_interleave,        \/**< Interleave bytes (Int) *\/\n+    SPA_FORMAT_AUDIO_bitrate,        \/**< bit rate (Int) *\/\n+    SPA_FORMAT_AUDIO_blockAlign,        \/**< audio data block alignment (Int) *\/\n+\n+    SPA_FORMAT_AUDIO_AAC_streamFormat,    \/**< AAC stream format, (Id enum spa_audio_aac_stream_format) *\/\n+\n+    SPA_FORMAT_AUDIO_WMA_profile,        \/**< WMA profile (Id enum spa_audio_wma_profile) *\/\n+\n+    SPA_FORMAT_AUDIO_AMR_bandMode,        \/**< AMR band mode (Id enum spa_audio_amr_band_mode) *\/\n+\n+\n+    \/* Video Format keys *\/\n+    SPA_FORMAT_START_Video = 0x20000,\n+    SPA_FORMAT_VIDEO_format,        \/**< video format (Id enum spa_video_format) *\/\n+    SPA_FORMAT_VIDEO_modifier,        \/**< format modifier (Long)\n+                          * use only with DMA-BUF and omit for other buffer types *\/\n+    SPA_FORMAT_VIDEO_size,            \/**< size (Rectangle) *\/\n+    SPA_FORMAT_VIDEO_framerate,        \/**< frame rate (Fraction) *\/\n+    SPA_FORMAT_VIDEO_maxFramerate,        \/**< maximum frame rate (Fraction) *\/\n+    SPA_FORMAT_VIDEO_views,            \/**< number of views (Int) *\/\n+    SPA_FORMAT_VIDEO_interlaceMode,        \/**< (Id enum spa_video_interlace_mode) *\/\n+    SPA_FORMAT_VIDEO_pixelAspectRatio,    \/**< (Rectangle) *\/\n+    SPA_FORMAT_VIDEO_multiviewMode,        \/**< (Id enum spa_video_multiview_mode) *\/\n+    SPA_FORMAT_VIDEO_multiviewFlags,    \/**< (Id enum spa_video_multiview_flags) *\/\n+    SPA_FORMAT_VIDEO_chromaSite,        \/**< \/Id enum spa_video_chroma_site) *\/\n+    SPA_FORMAT_VIDEO_colorRange,        \/**< \/Id enum spa_video_color_range) *\/\n+    SPA_FORMAT_VIDEO_colorMatrix,        \/**< \/Id enum spa_video_color_matrix) *\/\n+    SPA_FORMAT_VIDEO_transferFunction,    \/**< \/Id enum spa_video_transfer_function) *\/\n+    SPA_FORMAT_VIDEO_colorPrimaries,    \/**< \/Id enum spa_video_color_primaries) *\/\n+    SPA_FORMAT_VIDEO_profile,        \/**< (Int) *\/\n+    SPA_FORMAT_VIDEO_level,            \/**< (Int) *\/\n+    SPA_FORMAT_VIDEO_H264_streamFormat,    \/**< (Id enum spa_h264_stream_format) *\/\n+    SPA_FORMAT_VIDEO_H264_alignment,    \/**< (Id enum spa_h264_alignment) *\/\n+\n+    \/* Image Format keys *\/\n+    SPA_FORMAT_START_Image = 0x30000,\n+    \/* Binary Format keys *\/\n+    SPA_FORMAT_START_Binary = 0x40000,\n+    \/* Stream Format keys *\/\n+    SPA_FORMAT_START_Stream = 0x50000,\n+    \/* Application Format keys *\/\n+    SPA_FORMAT_START_Application = 0x60000,\n+};\n+\n+#define SPA_KEY_FORMAT_DSP        \"format.dsp\"        \/**< a predefined DSP format,\n+                                  *  Ex. \"32 bit float mono audio\" *\/\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format.h","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_LATENCY_TYPES_H\n+#define SPA_PARAM_LATENCY_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/latency.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Latency        SPA_TYPE_INFO_PARAM_BASE \"Latency\"\n+#define SPA_TYPE_INFO_PARAM_LATENCY_BASE    SPA_TYPE_INFO_PARAM_Latency \":\"\n+\n+static const struct spa_type_info spa_type_param_latency[] = {\n+    { SPA_PARAM_LATENCY_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE, spa_type_param, },\n+    { SPA_PARAM_LATENCY_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_LATENCY_minQuantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minQuantum\", NULL, },\n+    { SPA_PARAM_LATENCY_maxQuantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxQuantum\", NULL, },\n+    { SPA_PARAM_LATENCY_minRate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minRate\", NULL, },\n+    { SPA_PARAM_LATENCY_maxRate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxRate\", NULL, },\n+    { SPA_PARAM_LATENCY_minNs, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minNs\", NULL, },\n+    { SPA_PARAM_LATENCY_maxNs, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxNs\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_ProcessLatency        SPA_TYPE_INFO_PARAM_BASE \"ProcessLatency\"\n+#define SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE    SPA_TYPE_INFO_PARAM_ProcessLatency \":\"\n+\n+static const struct spa_type_info spa_type_param_process_latency[] = {\n+    { SPA_PARAM_PROCESS_LATENCY_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE, spa_type_param, },\n+    { SPA_PARAM_PROCESS_LATENCY_quantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"quantum\", NULL, },\n+    { SPA_PARAM_PROCESS_LATENCY_rate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"rate\", NULL, },\n+    { SPA_PARAM_PROCESS_LATENCY_ns, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"ns\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_LATENCY_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/latency-types.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_LATENY_H\n+#define SPA_PARAM_LATENY_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamLatency *\/\n+enum spa_param_latency {\n+    SPA_PARAM_LATENCY_START,\n+    SPA_PARAM_LATENCY_direction,        \/**< direction, input\/output (Id enum spa_direction) *\/\n+    SPA_PARAM_LATENCY_minQuantum,        \/**< min latency relative to quantum (Float) *\/\n+    SPA_PARAM_LATENCY_maxQuantum,        \/**< max latency relative to quantum (Float) *\/\n+    SPA_PARAM_LATENCY_minRate,        \/**< min latency (Int) relative to rate *\/\n+    SPA_PARAM_LATENCY_maxRate,        \/**< max latency (Int) relative to rate *\/\n+    SPA_PARAM_LATENCY_minNs,        \/**< min latency (Long) in nanoseconds *\/\n+    SPA_PARAM_LATENCY_maxNs,        \/**< max latency (Long) in nanoseconds *\/\n+};\n+\n+\/** helper structure for managing latency objects *\/\n+struct spa_latency_info {\n+    enum spa_direction direction;\n+    float min_quantum;\n+    float max_quantum;\n+    uint32_t min_rate;\n+    uint32_t max_rate;\n+    uint64_t min_ns;\n+    uint64_t max_ns;\n+};\n+\n+#define SPA_LATENCY_INFO(dir,...) ((struct spa_latency_info) { .direction = (dir), ## __VA_ARGS__ })\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamProcessLatency *\/\n+enum spa_param_process_latency {\n+    SPA_PARAM_PROCESS_LATENCY_START,\n+    SPA_PARAM_PROCESS_LATENCY_quantum,    \/**< latency relative to quantum (Float) *\/\n+    SPA_PARAM_PROCESS_LATENCY_rate,        \/**< latency (Int) relative to rate *\/\n+    SPA_PARAM_PROCESS_LATENCY_ns,        \/**< latency (Long) in nanoseconds *\/\n+};\n+\n+\/** Helper structure for managing process latency objects *\/\n+struct spa_process_latency_info {\n+    float quantum;\n+    uint32_t rate;\n+    uint64_t ns;\n+};\n+\n+#define SPA_PROCESS_LATENCY_INFO_INIT(...)    ((struct spa_process_latency_info) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_LATENY_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/latency.h","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TYPES_H\n+#define SPA_PARAM_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/props.h>\n+#include <spa\/param\/format.h>\n+#include <spa\/buffer\/type-info.h>\n+\n+\/* base for parameter object enumerations *\/\n+#define SPA_TYPE_INFO_ParamId        SPA_TYPE_INFO_ENUM_BASE \"ParamId\"\n+#define SPA_TYPE_INFO_PARAM_ID_BASE    SPA_TYPE_INFO_ParamId \":\"\n+\n+static const struct spa_type_info spa_type_param[] = {\n+    { SPA_PARAM_Invalid, SPA_TYPE_None, SPA_TYPE_INFO_PARAM_ID_BASE \"Invalid\", NULL },\n+    { SPA_PARAM_PropInfo, SPA_TYPE_OBJECT_PropInfo, SPA_TYPE_INFO_PARAM_ID_BASE \"PropInfo\", NULL },\n+    { SPA_PARAM_Props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_PARAM_ID_BASE \"Props\", NULL },\n+    { SPA_PARAM_EnumFormat, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumFormat\", NULL },\n+    { SPA_PARAM_Format, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_ID_BASE \"Format\", NULL },\n+    { SPA_PARAM_Buffers, SPA_TYPE_OBJECT_ParamBuffers, SPA_TYPE_INFO_PARAM_ID_BASE \"Buffers\", NULL },\n+    { SPA_PARAM_Meta, SPA_TYPE_OBJECT_ParamMeta, SPA_TYPE_INFO_PARAM_ID_BASE \"Meta\", NULL },\n+    { SPA_PARAM_IO, SPA_TYPE_OBJECT_ParamIO, SPA_TYPE_INFO_PARAM_ID_BASE \"IO\", NULL },\n+    { SPA_PARAM_EnumProfile, SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumProfile\", NULL },\n+    { SPA_PARAM_Profile, SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_INFO_PARAM_ID_BASE \"Profile\", NULL },\n+    { SPA_PARAM_EnumPortConfig, SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumPortConfig\", NULL },\n+    { SPA_PARAM_PortConfig, SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_INFO_PARAM_ID_BASE \"PortConfig\", NULL },\n+    { SPA_PARAM_EnumRoute, SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumRoute\", NULL },\n+    { SPA_PARAM_Route, SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_INFO_PARAM_ID_BASE \"Route\", NULL },\n+    { SPA_PARAM_Control, SPA_TYPE_Sequence, SPA_TYPE_INFO_PARAM_ID_BASE \"Control\", NULL },\n+    { SPA_PARAM_Latency, SPA_TYPE_OBJECT_ParamLatency, SPA_TYPE_INFO_PARAM_ID_BASE \"Latency\", NULL },\n+    { SPA_PARAM_ProcessLatency, SPA_TYPE_OBJECT_ParamProcessLatency, SPA_TYPE_INFO_PARAM_ID_BASE \"ProcessLatency\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/* base for parameter objects *\/\n+#define SPA_TYPE_INFO_Param            SPA_TYPE_INFO_OBJECT_BASE \"Param\"\n+#define SPA_TYPE_INFO_PARAM_BASE        SPA_TYPE_INFO_Param \":\"\n+\n+#include <spa\/param\/audio\/type-info.h>\n+\n+static const struct spa_type_info spa_type_prop_float_array[] = {\n+    { SPA_PROP_START, SPA_TYPE_Float, SPA_TYPE_INFO_BASE \"floatArray\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_prop_channel_map[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_BASE \"channelMap\", spa_type_audio_channel, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_prop_iec958_codec[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_BASE \"iec958Codec\", spa_type_audio_iec958_codec, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_ParamBitorder        SPA_TYPE_INFO_ENUM_BASE \"ParamBitorder\"\n+#define SPA_TYPE_INFO_PARAM_BITORDER_BASE    SPA_TYPE_INFO_ParamBitorder \":\"\n+\n+static const struct spa_type_info spa_type_param_bitorder[] = {\n+    { SPA_PARAM_BITORDER_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"unknown\", NULL },\n+    { SPA_PARAM_BITORDER_msb, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"msb\", NULL },\n+    { SPA_PARAM_BITORDER_lsb, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"lsb\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_ParamAvailability        SPA_TYPE_INFO_ENUM_BASE \"ParamAvailability\"\n+#define SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE    SPA_TYPE_INFO_ParamAvailability \":\"\n+\n+static const struct spa_type_info spa_type_param_availability[] = {\n+    { SPA_PARAM_AVAILABILITY_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"unknown\", NULL },\n+    { SPA_PARAM_AVAILABILITY_no, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"no\", NULL },\n+    { SPA_PARAM_AVAILABILITY_yes, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"yes\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/param-types.h","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_H\n+#define SPA_PARAM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\defgroup spa_param Parameters\n+ * Parameter value enumerations and type information\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/** different parameter types that can be queried *\/\n+enum spa_param_type {\n+    SPA_PARAM_Invalid,        \/**< invalid *\/\n+    SPA_PARAM_PropInfo,        \/**< property information as SPA_TYPE_OBJECT_PropInfo *\/\n+    SPA_PARAM_Props,        \/**< properties as SPA_TYPE_OBJECT_Props *\/\n+    SPA_PARAM_EnumFormat,        \/**< available formats as SPA_TYPE_OBJECT_Format *\/\n+    SPA_PARAM_Format,        \/**< configured format as SPA_TYPE_OBJECT_Format *\/\n+    SPA_PARAM_Buffers,        \/**< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers*\/\n+    SPA_PARAM_Meta,            \/**< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta*\/\n+    SPA_PARAM_IO,            \/**< configurable IO areas as SPA_TYPE_OBJECT_ParamIO *\/\n+    SPA_PARAM_EnumProfile,        \/**< profile enumeration as SPA_TYPE_OBJECT_ParamProfile *\/\n+    SPA_PARAM_Profile,        \/**< profile configuration as SPA_TYPE_OBJECT_ParamProfile *\/\n+    SPA_PARAM_EnumPortConfig,    \/**< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig *\/\n+    SPA_PARAM_PortConfig,        \/**< port configuration as SPA_TYPE_OBJECT_ParamPortConfig *\/\n+    SPA_PARAM_EnumRoute,        \/**< routing enumeration as SPA_TYPE_OBJECT_ParamRoute *\/\n+    SPA_PARAM_Route,        \/**< routing configuration as SPA_TYPE_OBJECT_ParamRoute *\/\n+    SPA_PARAM_Control,        \/**< Control parameter, a SPA_TYPE_Sequence *\/\n+    SPA_PARAM_Latency,        \/**< latency reporting, a SPA_TYPE_OBJECT_ParamLatency *\/\n+    SPA_PARAM_ProcessLatency,    \/**< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency *\/\n+};\n+\n+\/** information about a parameter *\/\n+struct spa_param_info {\n+    uint32_t id;            \/**< enum spa_param_type *\/\n+#define SPA_PARAM_INFO_SERIAL        (1<<0)    \/**< bit to signal update even when the\n+                         *   read\/write flags don't change *\/\n+#define SPA_PARAM_INFO_READ        (1<<1)\n+#define SPA_PARAM_INFO_WRITE        (1<<2)\n+#define SPA_PARAM_INFO_READWRITE    (SPA_PARAM_INFO_WRITE|SPA_PARAM_INFO_READ)\n+    uint32_t flags;\n+    uint32_t user;            \/**< private user field. You can use this to keep\n+                      *  state. *\/\n+    int32_t seq;            \/**< private seq field. You can use this to keep\n+                      *  state of a pending update. *\/\n+    uint32_t padding[4];\n+};\n+\n+#define SPA_PARAM_INFO(id,flags) ((struct spa_param_info){ (id), (flags) })\n+\n+enum spa_param_bitorder {\n+    SPA_PARAM_BITORDER_unknown,    \/**< unknown bitorder *\/\n+    SPA_PARAM_BITORDER_msb,        \/**< most significant bit *\/\n+    SPA_PARAM_BITORDER_lsb,        \/**< least significant bit *\/\n+};\n+\n+enum spa_param_availability {\n+    SPA_PARAM_AVAILABILITY_unknown,    \/**< unknown availability *\/\n+    SPA_PARAM_AVAILABILITY_no,    \/**< not available *\/\n+    SPA_PARAM_AVAILABILITY_yes,    \/**< available *\/\n+};\n+\n+#include <spa\/param\/buffers.h>\n+#include <spa\/param\/profile.h>\n+#include <spa\/param\/port-config.h>\n+#include <spa\/param\/route.h>\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/param.h","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PORT_CONFIG_TYPES_H\n+#define SPA_PARAM_PORT_CONFIG_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/port-config.h>\n+\n+#define SPA_TYPE_INFO_ParamPortConfigMode        SPA_TYPE_INFO_ENUM_BASE \"ParamPortConfigMode\"\n+#define SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE    SPA_TYPE_INFO_ParamPortConfigMode \":\"\n+\n+static const struct spa_type_info spa_type_param_port_config_mode[] = {\n+    { SPA_PARAM_PORT_CONFIG_MODE_none, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"none\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_passthrough, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"passthrough\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_convert, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"convert\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_dsp, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"dsp\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_PortConfig        SPA_TYPE_INFO_PARAM_BASE \"PortConfig\"\n+#define SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE    SPA_TYPE_INFO_PARAM_PortConfig \":\"\n+\n+static const struct spa_type_info spa_type_param_port_config[] = {\n+    { SPA_PARAM_PORT_CONFIG_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE, spa_type_param, },\n+    { SPA_PARAM_PORT_CONFIG_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_PORT_CONFIG_mode, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"mode\", spa_type_param_port_config_mode },\n+    { SPA_PARAM_PORT_CONFIG_monitor, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"monitor\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_control, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"control\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_format, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"format\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PORT_CONFIG_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/port-config-types.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PORT_CONFIG_H\n+#define SPA_PARAM_PORT_CONFIG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+enum spa_param_port_config_mode {\n+    SPA_PARAM_PORT_CONFIG_MODE_none,    \/**< no configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_passthrough,    \/**< passthrough configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_convert,    \/**< convert configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_dsp,        \/**< dsp configuration, depending on the external\n+                          *  format. For audio, ports will be configured for\n+                          *  the given number of channels with F32 format. *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamPortConfig *\/\n+enum spa_param_port_config {\n+    SPA_PARAM_PORT_CONFIG_START,\n+    SPA_PARAM_PORT_CONFIG_direction,    \/**< (Id enum spa_direction) direction *\/\n+    SPA_PARAM_PORT_CONFIG_mode,        \/**< (Id enum spa_param_port_config_mode) mode *\/\n+    SPA_PARAM_PORT_CONFIG_monitor,        \/**< (Bool) enable monitor output ports on input ports *\/\n+    SPA_PARAM_PORT_CONFIG_control,        \/**< (Bool) enable control ports *\/\n+    SPA_PARAM_PORT_CONFIG_format,        \/**< (Object) format filter *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PORT_CONFIG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/port-config.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILE_TYPES_H\n+#define SPA_PARAM_PROFILE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/profile.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Profile        SPA_TYPE_INFO_PARAM_BASE \"Profile\"\n+#define SPA_TYPE_INFO_PARAM_PROFILE_BASE    SPA_TYPE_INFO_PARAM_Profile \":\"\n+\n+static const struct spa_type_info spa_type_param_profile[] = {\n+    { SPA_PARAM_PROFILE_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PROFILE_BASE, spa_type_param, },\n+    { SPA_PARAM_PROFILE_index, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"index\", NULL },\n+    { SPA_PARAM_PROFILE_name, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"name\", NULL },\n+    { SPA_PARAM_PROFILE_description, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"description\", NULL },\n+    { SPA_PARAM_PROFILE_priority, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"priority\", NULL },\n+    { SPA_PARAM_PROFILE_available, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"available\", spa_type_param_availability, },\n+    { SPA_PARAM_PROFILE_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"info\", NULL, },\n+    { SPA_PARAM_PROFILE_classes, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"classes\", NULL, },\n+    { SPA_PARAM_PROFILE_save, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"save\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profile-types.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILE_H\n+#define SPA_PARAM_PROFILE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamProfile *\/\n+enum spa_param_profile {\n+    SPA_PARAM_PROFILE_START,\n+    SPA_PARAM_PROFILE_index,    \/**< profile index (Int) *\/\n+    SPA_PARAM_PROFILE_name,        \/**< profile name (String) *\/\n+    SPA_PARAM_PROFILE_description,    \/**< profile description (String) *\/\n+    SPA_PARAM_PROFILE_priority,    \/**< profile priority (Int) *\/\n+    SPA_PARAM_PROFILE_available,    \/**< availability of the profile\n+                      *  (Id enum spa_param_availability) *\/\n+    SPA_PARAM_PROFILE_info,        \/**< info (Struct(\n+                      *          Int : n_items,\n+                      *          (String : key,\n+                      *           String : value)*)) *\/\n+    SPA_PARAM_PROFILE_classes,    \/**< node classes provided by this profile\n+                      *  (Struct(\n+                      *       Int : number of items following\n+                      *        Struct(\n+                      *           String : class name (eg. \"Audio\/Source\"),\n+                      *           Int : number of nodes\n+                      *           String : property (eg. \"card.profile.devices\"),\n+                      *           Array of Int: device indexes\n+                      *         )*)) *\/\n+    SPA_PARAM_PROFILE_save,        \/**< If profile should be saved (Bool) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profile.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILER_TYPES_H\n+#define SPA_PARAM_PROFILER_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/profiler.h>\n+\n+#define SPA_TYPE_INFO_Profiler        SPA_TYPE_INFO_OBJECT_BASE \"Profiler\"\n+#define SPA_TYPE_INFO_PROFILER_BASE    SPA_TYPE_INFO_Profiler \":\"\n+\n+static const struct spa_type_info spa_type_profiler[] = {\n+    { SPA_PROFILER_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROFILER_BASE, spa_type_param, },\n+    { SPA_PROFILER_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"info\", NULL, },\n+    { SPA_PROFILER_clock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"clock\", NULL, },\n+    { SPA_PROFILER_driverBlock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"driverBlock\", NULL, },\n+    { SPA_PROFILER_followerBlock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"followerBlock\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILER_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profiler-types.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILER_H\n+#define SPA_PARAM_PROFILER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_Profiler *\/\n+enum spa_profiler {\n+    SPA_PROFILER_START,\n+\n+    SPA_PROFILER_START_Driver    = 0x10000,    \/**< driver related profiler properties *\/\n+    SPA_PROFILER_info,                \/**< Generic info, counter and CPU load,\n+                              * (Struct(\n+                              *      Long : counter,\n+                              *      Float : cpu_load fast,\n+                              *      Float : cpu_load medium,\n+                              *      Float : cpu_load slow),\n+                              *      Int : xrun-count))  *\/\n+    SPA_PROFILER_clock,                \/**< clock information\n+                              *  (Struct(\n+                              *      Int : clock flags,\n+                              *      Int : clock id,\n+                              *      String: clock name,\n+                              *      Long : clock nsec,\n+                              *      Fraction : clock rate,\n+                              *      Long : clock position,\n+                              *      Long : clock duration,\n+                              *      Long : clock delay,\n+                              *      Double : clock rate_diff,\n+                              *      Long : clock next_nsec)) *\/\n+    SPA_PROFILER_driverBlock,            \/**< generic driver info block\n+                              *  (Struct(\n+                              *      Int : driver_id,\n+                              *      String : name,\n+                              *      Long : driver prev_signal,\n+                              *      Long : driver signal,\n+                              *      Long : driver awake,\n+                              *      Long : driver finish,\n+                              *      Int : driver status),\n+                              *      Fraction : latency))  *\/\n+\n+    SPA_PROFILER_START_Follower    = 0x20000,    \/**< follower related profiler properties *\/\n+    SPA_PROFILER_followerBlock,            \/**< generic follower info block\n+                              *  (Struct(\n+                              *      Int : id,\n+                              *      String : name,\n+                              *      Long : prev_signal,\n+                              *      Long : signal,\n+                              *      Long : awake,\n+                              *      Long : finish,\n+                              *      Int : status,\n+                              *      Fraction : latency))  *\/\n+\n+    SPA_PROFILER_START_CUSTOM    = 0x1000000,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profiler.h","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROPS_TYPES_H\n+#define SPA_PARAM_PROPS_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/bluetooth\/type-info.h>\n+\n+\/** Props Param *\/\n+#define SPA_TYPE_INFO_Props            SPA_TYPE_INFO_PARAM_BASE \"Props\"\n+#define SPA_TYPE_INFO_PROPS_BASE        SPA_TYPE_INFO_Props \":\"\n+\n+static const struct spa_type_info spa_type_props[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE, spa_type_param, },\n+    { SPA_PROP_unknown, SPA_TYPE_None, SPA_TYPE_INFO_PROPS_BASE \"unknown\", NULL },\n+    { SPA_PROP_device, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"device\", NULL },\n+    { SPA_PROP_deviceName, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"deviceName\", NULL },\n+    { SPA_PROP_deviceFd, SPA_TYPE_Fd, SPA_TYPE_INFO_PROPS_BASE \"deviceFd\", NULL },\n+    { SPA_PROP_card, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"card\", NULL },\n+    { SPA_PROP_cardName, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"cardName\", NULL },\n+    { SPA_PROP_minLatency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"minLatency\", NULL },\n+    { SPA_PROP_maxLatency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"maxLatency\", NULL },\n+    { SPA_PROP_periods, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"periods\", NULL },\n+    { SPA_PROP_periodSize, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"periodSize\", NULL },\n+    { SPA_PROP_periodEvent, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"periodEvent\", NULL },\n+    { SPA_PROP_live, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"live\", NULL },\n+    { SPA_PROP_rate, SPA_TYPE_Double, SPA_TYPE_INFO_PROPS_BASE \"rate\", NULL },\n+    { SPA_PROP_quality, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"quality\", NULL },\n+    { SPA_PROP_bluetoothAudioCodec, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"bluetoothAudioCodec\", spa_type_bluetooth_audio_codec },\n+    { SPA_PROP_bluetoothOffloadActive, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"bluetoothOffloadActive\", NULL },\n+\n+    { SPA_PROP_waveType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"waveType\", NULL },\n+    { SPA_PROP_frequency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"frequency\", NULL },\n+    { SPA_PROP_volume, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volume\", NULL },\n+    { SPA_PROP_mute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"mute\", NULL },\n+    { SPA_PROP_patternType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"patternType\", NULL },\n+    { SPA_PROP_ditherType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"ditherType\", NULL },\n+    { SPA_PROP_truncate, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"truncate\", NULL },\n+    { SPA_PROP_channelVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"channelVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_volumeBase, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volumeBase\", NULL },\n+    { SPA_PROP_volumeStep, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volumeStep\", NULL },\n+    { SPA_PROP_channelMap, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"channelMap\", spa_type_prop_channel_map },\n+    { SPA_PROP_monitorMute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"monitorMute\", NULL },\n+    { SPA_PROP_monitorVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"monitorVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_latencyOffsetNsec, SPA_TYPE_Long, SPA_TYPE_INFO_PROPS_BASE \"latencyOffsetNsec\", NULL },\n+    { SPA_PROP_softMute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"softMute\", NULL },\n+    { SPA_PROP_softVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"softVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_iec958Codecs, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"iec958Codecs\", spa_type_prop_iec958_codec },\n+    { SPA_PROP_volumeRampSamples, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampSamples\", NULL },\n+    { SPA_PROP_volumeRampStepSamples, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampStepSamples\", NULL },\n+    { SPA_PROP_volumeRampTime, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampTime\", NULL },\n+    { SPA_PROP_volumeRampStepTime, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampStepTime\", NULL },\n+    { SPA_PROP_volumeRampScale, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"volumeRampScale\", NULL },\n+\n+    { SPA_PROP_brightness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"brightness\", NULL },\n+    { SPA_PROP_contrast, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"contrast\", NULL },\n+    { SPA_PROP_saturation, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"saturation\", NULL },\n+    { SPA_PROP_hue, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"hue\", NULL },\n+    { SPA_PROP_gamma, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"gamma\", NULL },\n+    { SPA_PROP_exposure, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"exposure\", NULL },\n+    { SPA_PROP_gain, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"gain\", NULL },\n+    { SPA_PROP_sharpness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"sharpness\", NULL },\n+\n+    { SPA_PROP_params, SPA_TYPE_Struct, SPA_TYPE_INFO_PROPS_BASE \"params\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/** Enum Property info *\/\n+#define SPA_TYPE_INFO_PropInfo            SPA_TYPE_INFO_PARAM_BASE \"PropInfo\"\n+#define SPA_TYPE_INFO_PROP_INFO_BASE        SPA_TYPE_INFO_PropInfo \":\"\n+\n+static const struct spa_type_info spa_type_prop_info[] = {\n+    { SPA_PROP_INFO_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE, spa_type_param, },\n+    { SPA_PROP_INFO_id, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE \"id\", spa_type_props },\n+    { SPA_PROP_INFO_name, SPA_TYPE_String, SPA_TYPE_INFO_PROP_INFO_BASE \"name\", NULL },\n+    { SPA_PROP_INFO_type, SPA_TYPE_Pod, SPA_TYPE_INFO_PROP_INFO_BASE \"type\", NULL },\n+    { SPA_PROP_INFO_labels, SPA_TYPE_Struct, SPA_TYPE_INFO_PROP_INFO_BASE \"labels\", NULL },\n+    { SPA_PROP_INFO_container, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE \"container\", NULL },\n+    { SPA_PROP_INFO_params, SPA_TYPE_Bool, SPA_TYPE_INFO_PROP_INFO_BASE \"params\", NULL },\n+    { SPA_PROP_INFO_description, SPA_TYPE_String, SPA_TYPE_INFO_PROP_INFO_BASE \"description\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROPS_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/props-types.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROPS_H\n+#define SPA_PARAM_PROPS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties of SPA_TYPE_OBJECT_PropInfo *\/\n+enum spa_prop_info {\n+    SPA_PROP_INFO_START,\n+    SPA_PROP_INFO_id,        \/**< associated id of the property *\/\n+    SPA_PROP_INFO_name,        \/**< name of the property *\/\n+    SPA_PROP_INFO_type,        \/**< type and range\/enums of property *\/\n+    SPA_PROP_INFO_labels,        \/**< labels of property if any, this is a\n+                      *  struct with pairs of values, the first one\n+                      *  is of the type of the property, the second\n+                      *  one is a string with a user readable label\n+                      *  for the value. *\/\n+    SPA_PROP_INFO_container,    \/**< type of container if any (Id) *\/\n+    SPA_PROP_INFO_params,        \/**< is part of params property (Bool) *\/\n+    SPA_PROP_INFO_description,    \/**< User readable description *\/\n+};\n+\n+\/** predefined properties for SPA_TYPE_OBJECT_Props *\/\n+enum spa_prop {\n+    SPA_PROP_START,\n+\n+    SPA_PROP_unknown,        \/**< an unknown property *\/\n+\n+    SPA_PROP_START_Device    = 0x100,    \/**< device related properties *\/\n+    SPA_PROP_device,\n+    SPA_PROP_deviceName,\n+    SPA_PROP_deviceFd,\n+    SPA_PROP_card,\n+    SPA_PROP_cardName,\n+\n+    SPA_PROP_minLatency,\n+    SPA_PROP_maxLatency,\n+    SPA_PROP_periods,\n+    SPA_PROP_periodSize,\n+    SPA_PROP_periodEvent,\n+    SPA_PROP_live,\n+    SPA_PROP_rate,\n+    SPA_PROP_quality,\n+    SPA_PROP_bluetoothAudioCodec,\n+    SPA_PROP_bluetoothOffloadActive,\n+\n+    SPA_PROP_START_Audio    = 0x10000,    \/**< audio related properties *\/\n+    SPA_PROP_waveType,\n+    SPA_PROP_frequency,\n+    SPA_PROP_volume,                \/**< a volume (Float), 0.0 silence, 1.0 normal *\/\n+    SPA_PROP_mute,                \/**< mute (Bool) *\/\n+    SPA_PROP_patternType,\n+    SPA_PROP_ditherType,\n+    SPA_PROP_truncate,\n+    SPA_PROP_channelVolumes,        \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+    SPA_PROP_volumeBase,            \/**< a volume base (Float) *\/\n+    SPA_PROP_volumeStep,            \/**< a volume step (Float) *\/\n+    SPA_PROP_channelMap,            \/**< a channelmap array\n+                          * (Array (Id enum spa_audio_channel)) *\/\n+    SPA_PROP_monitorMute,            \/**< mute (Bool) *\/\n+    SPA_PROP_monitorVolumes,        \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+    SPA_PROP_latencyOffsetNsec,        \/**< delay adjustment *\/\n+    SPA_PROP_softMute,            \/**< mute (Bool) *\/\n+    SPA_PROP_softVolumes,            \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+\n+    SPA_PROP_iec958Codecs,            \/**< enabled IEC958 (S\/PDIF) codecs,\n+                          *  (Array (Id enum spa_audio_iec958_codec) *\/\n+    SPA_PROP_volumeRampSamples,        \/**< Samples to ramp the volume over *\/\n+    SPA_PROP_volumeRampStepSamples,        \/**< Step or incremental Samples to ramp\n+                          *  the volume over *\/\n+    SPA_PROP_volumeRampTime,        \/**< Time in millisec to ramp the volume over *\/\n+    SPA_PROP_volumeRampStepTime,        \/**< Step or incremental Time in nano seconds\n+                          *  to ramp the *\/\n+    SPA_PROP_volumeRampScale,        \/**< the scale or graph to used to ramp the\n+                          *  volume *\/\n+\n+    SPA_PROP_START_Video    = 0x20000,    \/**< video related properties *\/\n+    SPA_PROP_brightness,\n+    SPA_PROP_contrast,\n+    SPA_PROP_saturation,\n+    SPA_PROP_hue,\n+    SPA_PROP_gamma,\n+    SPA_PROP_exposure,\n+    SPA_PROP_gain,\n+    SPA_PROP_sharpness,\n+\n+    SPA_PROP_START_Other    = 0x80000,    \/**< other properties *\/\n+    SPA_PROP_params,            \/**< simple control params\n+                          *    (Struct(\n+                          *      (String : key,\n+                          *       Pod    : value)*)) *\/\n+\n+\n+    SPA_PROP_START_CUSTOM    = 0x1000000,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROPS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/props.h","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_ROUTE_TYPES_H\n+#define SPA_PARAM_ROUTE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/route.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Route        SPA_TYPE_INFO_PARAM_BASE \"Route\"\n+#define SPA_TYPE_INFO_PARAM_ROUTE_BASE        SPA_TYPE_INFO_PARAM_Route \":\"\n+\n+static const struct spa_type_info spa_type_param_route[] = {\n+    { SPA_PARAM_ROUTE_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE, spa_type_param, },\n+    { SPA_PARAM_ROUTE_index, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"index\", NULL, },\n+    { SPA_PARAM_ROUTE_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_ROUTE_device, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"device\", NULL, },\n+    { SPA_PARAM_ROUTE_name, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"name\", NULL, },\n+    { SPA_PARAM_ROUTE_description, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"description\", NULL, },\n+    { SPA_PARAM_ROUTE_priority, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"priority\", NULL, },\n+    { SPA_PARAM_ROUTE_available, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"available\", spa_type_param_availability, },\n+    { SPA_PARAM_ROUTE_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"info\", NULL, },\n+    { SPA_PARAM_ROUTE_profiles, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profiles\", NULL, },\n+    { SPA_PARAM_ROUTE_props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"props\", NULL, },\n+    { SPA_PARAM_ROUTE_devices, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"devices\", NULL, },\n+    { SPA_PARAM_ROUTE_profile, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profile\", NULL, },\n+    { SPA_PARAM_ROUTE_save, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"save\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_ROUTE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/route-types.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_ROUTE_H\n+#define SPA_PARAM_ROUTE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamRoute *\/\n+enum spa_param_route {\n+    SPA_PARAM_ROUTE_START,\n+    SPA_PARAM_ROUTE_index,            \/**< index of the routing destination (Int) *\/\n+    SPA_PARAM_ROUTE_direction,        \/**< direction, input\/output (Id enum spa_direction) *\/\n+    SPA_PARAM_ROUTE_device,            \/**< device id (Int) *\/\n+    SPA_PARAM_ROUTE_name,            \/**< name of the routing destination (String) *\/\n+    SPA_PARAM_ROUTE_description,        \/**< description of the destination (String) *\/\n+    SPA_PARAM_ROUTE_priority,        \/**< priority of the destination (Int) *\/\n+    SPA_PARAM_ROUTE_available,        \/**< availability of the destination\n+                          *  (Id enum spa_param_availability) *\/\n+    SPA_PARAM_ROUTE_info,            \/**< info (Struct(\n+                          *          Int : n_items,\n+                          *          (String : key,\n+                          *           String : value)*)) *\/\n+    SPA_PARAM_ROUTE_profiles,        \/**< associated profile indexes (Array of Int) *\/\n+    SPA_PARAM_ROUTE_props,            \/**< properties SPA_TYPE_OBJECT_Props *\/\n+    SPA_PARAM_ROUTE_devices,        \/**< associated device indexes (Array of Int) *\/\n+    SPA_PARAM_ROUTE_profile,        \/**< profile id (Int) *\/\n+    SPA_PARAM_ROUTE_save,            \/**< If route should be saved (Bool) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_ROUTE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/route.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TYPE_INFO_H\n+#define SPA_PARAM_TYPE_INFO_H\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/buffers-types.h>\n+#include <spa\/param\/props-types.h>\n+#include <spa\/param\/format-types.h>\n+#include <spa\/param\/latency-types.h>\n+#include <spa\/param\/port-config-types.h>\n+#include <spa\/param\/profiler-types.h>\n+#include <spa\/param\/profile-types.h>\n+#include <spa\/param\/route-types.h>\n+\n+#endif \/* SPA_PARAM_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/type-info.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_CHROMA_H\n+#define SPA_VIDEO_CHROMA_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/** Various Chroma settings.\n+ *\/\n+enum spa_video_chroma_site {\n+    SPA_VIDEO_CHROMA_SITE_UNKNOWN = 0,        \/**< unknown cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_NONE = (1 << 0),        \/**< no cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_H_COSITED = (1 << 1),    \/**< chroma is horizontally cosited *\/\n+    SPA_VIDEO_CHROMA_SITE_V_COSITED = (1 << 2),    \/**< chroma is vertically cosited *\/\n+    SPA_VIDEO_CHROMA_SITE_ALT_LINE = (1 << 3),    \/**< chroma samples are sited on alternate lines *\/\n+    \/* some common chroma cositing *\/\n+    \/** chroma samples cosited with luma samples *\/\n+    SPA_VIDEO_CHROMA_SITE_COSITED = (SPA_VIDEO_CHROMA_SITE_H_COSITED | SPA_VIDEO_CHROMA_SITE_V_COSITED),\n+    \/** jpeg style cositing, also for mpeg1 and mjpeg *\/\n+    SPA_VIDEO_CHROMA_SITE_JPEG = (SPA_VIDEO_CHROMA_SITE_NONE),\n+    \/** mpeg2 style cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_MPEG2 = (SPA_VIDEO_CHROMA_SITE_H_COSITED),\n+    \/**< DV style cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_DV = (SPA_VIDEO_CHROMA_SITE_COSITED | SPA_VIDEO_CHROMA_SITE_ALT_LINE),\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_CHROMA_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/chroma.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_COLOR_H\n+#define SPA_VIDEO_COLOR_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/**\n+ * Possible color range values. These constants are defined for 8 bit color\n+ * values and can be scaled for other bit depths.\n+ *\/\n+enum spa_video_color_range {\n+    SPA_VIDEO_COLOR_RANGE_UNKNOWN = 0,    \/**< unknown range *\/\n+    SPA_VIDEO_COLOR_RANGE_0_255,        \/**< [0..255] for 8 bit components *\/\n+    SPA_VIDEO_COLOR_RANGE_16_235        \/**< [16..235] for 8 bit components. Chroma has\n+                             [16..240] range. *\/\n+};\n+\n+\/**\n+ * The color matrix is used to convert between Y'PbPr and\n+ * non-linear RGB (R'G'B')\n+ *\/\n+enum spa_video_color_matrix {\n+    SPA_VIDEO_COLOR_MATRIX_UNKNOWN = 0,    \/**< unknown matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_RGB,        \/**< identity matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_FCC,        \/**< FCC color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT709,        \/**< ITU BT.709 color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT601,        \/**< ITU BT.601 color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_SMPTE240M,    \/**< SMTPE  240M color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT2020,        \/**<  ITU-R BT.2020 color matrix. since 1.6. *\/\n+};\n+\n+\/**\n+ * The video transfer function defines the formula for converting between\n+ * non-linear RGB (R'G'B') and linear RGB\n+ *\/\n+enum spa_video_transfer_function {\n+    SPA_VIDEO_TRANSFER_UNKNOWN = 0,    \/**< unknown transfer function *\/\n+    SPA_VIDEO_TRANSFER_GAMMA10,    \/**< linear RGB, gamma 1.0 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA18,    \/**< Gamma 1.8 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA20,    \/**< Gamma 2.0 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA22,    \/**< Gamma 2.2 curve *\/\n+    SPA_VIDEO_TRANSFER_BT709,    \/**< Gamma 2.2 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_SMPTE240M,    \/**< Gamma 2.2 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_SRGB,    \/**< Gamma 2.4 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_GAMMA28,    \/**< Gamma 2.8 curve *\/\n+    SPA_VIDEO_TRANSFER_LOG100,    \/**< Logarithmic transfer characteristic 100:1 range *\/\n+    SPA_VIDEO_TRANSFER_LOG316,    \/**< Logarithmic transfer characteristic 316.22777:1 range *\/\n+    SPA_VIDEO_TRANSFER_BT2020_12,    \/**< Gamma 2.2 curve with a linear segment in the lower\n+                     *   range. Used for BT.2020 with 12 bits per\n+                     *   component. \\since 1.6. *\/\n+    SPA_VIDEO_TRANSFER_ADOBERGB,    \/**< Gamma 2.19921875. \\since 1.8 *\/\n+};\n+\n+\/**\n+ * The color primaries define the how to transform linear RGB values to and from\n+ * the CIE XYZ colorspace.\n+ *\/\n+enum spa_video_color_primaries {\n+    SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN = 0,    \/**< unknown color primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT709,    \/**< BT709 primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT470M,    \/**< BT470M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT470BG,    \/**< BT470BG primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M,    \/**< SMPTE170M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M,    \/**< SMPTE240M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_FILM,        \/**< Generic film *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT2020,    \/**< BT2020 primaries. \\since 1.6. *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB,    \/**< Adobe RGB primaries. \\since 1.8 *\/\n+};\n+\n+\/**\n+ * spa_video_colorimetry:\n+ *\n+ * Structure describing the color info.\n+ *\/\n+struct spa_video_colorimetry {\n+    enum spa_video_color_range range;    \/**< The color range. This is the valid range for the\n+                         *    samples. It is used to convert the samples to Y'PbPr\n+                         *    values. *\/\n+    enum spa_video_color_matrix matrix;    \/**< the color matrix. Used to convert between Y'PbPr and\n+                         *    non-linear RGB (R'G'B') *\/\n+    enum spa_video_transfer_function transfer; \/**< The transfer function. Used to convert between\n+                            *   R'G'B' and RGB *\/\n+    enum spa_video_color_primaries primaries; \/**< Color primaries. Used to convert between R'G'B'\n+                           *   and CIE XYZ *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_COLOR_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/color.h","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_DSP_UTILS_H\n+#define SPA_VIDEO_DSP_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/dsp.h>\n+\n+static inline int\n+spa_format_video_dsp_parse(const struct spa_pod *format,\n+               struct spa_video_info_dsp *info)\n+{\n+    info->flags = SPA_VIDEO_FLAG_NONE;\n+    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+        info->flags |= SPA_VIDEO_FLAG_MODIFIER;\n+    }\n+\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_VIDEO_format,        SPA_POD_OPT_Id(&info->format),\n+        SPA_FORMAT_VIDEO_modifier,        SPA_POD_OPT_Long(&info->modifier));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_dsp_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_dsp *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_dsp),\n+            0);\n+    if (info->format != SPA_VIDEO_FORMAT_UNKNOWN)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_format,    SPA_POD_Id(info->format), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_DSP_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/dsp-utils.h","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_DSP_H\n+#define SPA_VIDEO_DSP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/video\/raw.h>\n+\n+struct spa_video_info_dsp {\n+    enum spa_video_format format;\n+    uint32_t flags;\n+    uint64_t modifier;\n+};\n+\n+#define SPA_VIDEO_INFO_DSP_INIT(...)    ((struct spa_video_info_dsp) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_DSP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/dsp.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_ENCODED_H\n+#define SPA_VIDEO_ENCODED_H\n+\n+#include <spa\/param\/video\/h264.h>\n+#include <spa\/param\/video\/mjpg.h>\n+\n+#endif \/* SPA_VIDEO_ENCODED_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/encoded.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_VIDEO_FORMAT_UTILS_H\n+#define SPA_PARAM_VIDEO_FORMAT_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/format-utils.h>\n+#include <spa\/param\/video\/format.h>\n+#include <spa\/param\/video\/raw-utils.h>\n+#include <spa\/param\/video\/dsp-utils.h>\n+#include <spa\/param\/video\/h264-utils.h>\n+#include <spa\/param\/video\/mjpg-utils.h>\n+\n+static inline int\n+spa_format_video_parse(const struct spa_pod *format, struct spa_video_info *info)\n+{\n+    int res;\n+\n+    if ((res = spa_format_parse(format, &info->media_type, &info->media_subtype)) < 0)\n+        return res;\n+\n+    if (info->media_type != SPA_MEDIA_TYPE_video)\n+        return -EINVAL;\n+\n+    switch (info->media_subtype) {\n+    case SPA_MEDIA_SUBTYPE_raw:\n+        return spa_format_video_raw_parse(format, &info->info.raw);\n+    case SPA_MEDIA_SUBTYPE_dsp:\n+        return spa_format_video_dsp_parse(format, &info->info.dsp);\n+    case SPA_MEDIA_SUBTYPE_h264:\n+        return spa_format_video_h264_parse(format, &info->info.h264);\n+    case SPA_MEDIA_SUBTYPE_mjpg:\n+        return spa_format_video_mjpg_parse(format, &info->info.mjpg);\n+    }\n+    return -ENOTSUP;\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_build(struct spa_pod_builder *builder, uint32_t id, struct spa_video_info *info)\n+{\n+    switch (info->media_subtype) {\n+    case SPA_MEDIA_SUBTYPE_raw:\n+        return spa_format_video_raw_build(builder, id, &info->info.raw);\n+    case SPA_MEDIA_SUBTYPE_dsp:\n+        return spa_format_video_dsp_build(builder, id, &info->info.dsp);\n+    case SPA_MEDIA_SUBTYPE_h264:\n+        return spa_format_video_h264_build(builder, id, &info->info.h264);\n+    case SPA_MEDIA_SUBTYPE_mjpg:\n+        return spa_format_video_mjpg_build(builder, id, &info->info.mjpg);\n+    }\n+    errno = ENOTSUP;\n+    return NULL;\n+}\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_VIDEO_FORMAT_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/format-utils.h","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_VIDEO_FORMAT_H\n+#define SPA_PARAM_VIDEO_FORMAT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/video\/raw.h>\n+#include <spa\/param\/video\/dsp.h>\n+#include <spa\/param\/video\/encoded.h>\n+\n+struct spa_video_info {\n+    uint32_t media_type;\n+    uint32_t media_subtype;\n+    union {\n+        struct spa_video_info_raw raw;\n+        struct spa_video_info_dsp dsp;\n+        struct spa_video_info_h264 h264;\n+        struct spa_video_info_mjpg mjpg;\n+    } info;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_VIDEO_FORMAT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/format.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_H264_UTILS_H\n+#define SPA_VIDEO_H264_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/h264.h>\n+\n+static inline int\n+spa_format_video_h264_parse(const struct spa_pod *format,\n+                struct spa_video_info_h264 *info)\n+{\n+    return spa_pod_parse_object(format,\n+            SPA_TYPE_OBJECT_Format, NULL,\n+            SPA_FORMAT_VIDEO_size,            SPA_POD_OPT_Rectangle(&info->size),\n+            SPA_FORMAT_VIDEO_framerate,        SPA_POD_OPT_Fraction(&info->framerate),\n+            SPA_FORMAT_VIDEO_maxFramerate,        SPA_POD_OPT_Fraction(&info->max_framerate),\n+            SPA_FORMAT_VIDEO_H264_streamFormat,    SPA_POD_OPT_Id(&info->stream_format),\n+            SPA_FORMAT_VIDEO_H264_alignment,    SPA_POD_OPT_Id(&info->alignment));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_h264_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_h264 *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_h264),\n+            0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    if (info->stream_format != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_H264_streamFormat, SPA_POD_Id(info->stream_format), 0);\n+    if (info->alignment != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_H264_alignment, SPA_POD_Id(info->alignment), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_H264_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/h264-utils.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_H264_H\n+#define SPA_VIDEO_H264_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+\n+enum spa_h264_stream_format {\n+    SPA_H264_STREAM_FORMAT_UNKNOWN = 0,\n+    SPA_H264_STREAM_FORMAT_AVC,\n+    SPA_H264_STREAM_FORMAT_AVC3,\n+    SPA_H264_STREAM_FORMAT_BYTESTREAM\n+};\n+\n+enum spa_h264_alignment {\n+    SPA_H264_ALIGNMENT_UNKNOWN = 0,\n+    SPA_H264_ALIGNMENT_AU,\n+    SPA_H264_ALIGNMENT_NAL\n+};\n+\n+struct spa_video_info_h264 {\n+    struct spa_rectangle size;\n+    struct spa_fraction framerate;\n+    struct spa_fraction max_framerate;\n+    enum spa_h264_stream_format stream_format;\n+    enum spa_h264_alignment alignment;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_H264_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/h264.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MJPG_UTILS_H\n+#define SPA_VIDEO_MJPG_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/mjpg.h>\n+\n+static inline int\n+spa_format_video_mjpg_parse(const struct spa_pod *format,\n+                struct spa_video_info_mjpg *info)\n+{\n+    return spa_pod_parse_object(format,\n+            SPA_TYPE_OBJECT_Format, NULL,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_OPT_Rectangle(&info->size),\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_OPT_Fraction(&info->framerate),\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_OPT_Fraction(&info->max_framerate));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_mjpg_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_mjpg *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_mjpg),\n+            0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MJPG_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/mjpg-utils.h","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MJPG_H\n+#define SPA_VIDEO_MJPG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+\n+struct spa_video_info_mjpg {\n+    struct spa_rectangle size;\n+    struct spa_fraction framerate;\n+    struct spa_fraction max_framerate;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MJPG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/mjpg.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MULTIVIEW_H\n+#define SPA_VIDEO_MULTIVIEW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/**\n+ * All possible stereoscopic 3D and multiview representations.\n+ * In conjunction with \\ref spa_video_multiview_flags, describes how\n+ * multiview content is being transported in the stream.\n+ *\/\n+enum spa_video_multiview_mode {\n+    \/** A special value indicating no multiview information. Used in spa_video_info and other\n+     * places to indicate that no specific multiview handling has been requested or provided.\n+     * This value is never carried on caps. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_NONE = -1,\n+    SPA_VIDEO_MULTIVIEW_MODE_MONO = 0,        \/**< All frames are monoscopic *\/\n+    \/* Single view modes *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_LEFT,            \/**< All frames represent a left-eye view *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_RIGHT,            \/**< All frames represent a right-eye view *\/\n+    \/* Stereo view modes *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE,        \/**< Left and right eye views are provided\n+                             *   in the left and right half of the frame\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX, \/**< Left and right eye views are provided\n+                             *   in the left and right half of the\n+                             *   frame, but have been sampled using\n+                             *   quincunx method, with half-pixel offset\n+                             *   between the 2 views. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED,    \/**< Alternating vertical columns of pixels\n+                             *   represent the left and right eye view\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED,    \/**< Alternating horizontal rows of pixels\n+                             *   represent the left and right eye view\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM,        \/**< The top half of the frame contains the\n+                             *   left eye, and the bottom half the right\n+                             *   eye. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD,        \/**< Pixels are arranged with alternating\n+                             *   pixels representing left and right eye\n+                             *   views in a checkerboard fashion. *\/\n+    \/* Padding for new frame packing modes *\/\n+\n+    SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME = 32,    \/**< Left and right eye views are provided\n+                             *   in separate frames alternately. *\/\n+    \/* Multiview mode(s) *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME, \/**< Multipleindependent views are\n+                                *   provided in separate frames in\n+                                *   sequence. This method only applies to\n+                                *   raw video buffers at the moment.\n+                                *   Specific view identification is via\n+                                *   \\ref spa_video_multiview_meta on raw\n+                                *   video buffers. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SEPARATED,        \/**< Multiple views are provided as separate\n+                             *   \\ref spa_data framebuffers attached\n+                             *   to each \\ref spa_buffer, described\n+                             *   by the \\ref spa_video_multiview_meta *\/\n+    \/* future expansion for annotated modes *\/\n+};\n+\n+\/**\n+ * spa_video_multiview_flags are used to indicate extra properties of a\n+ * stereo\/multiview stream beyond the frame layout and buffer mapping\n+ * that is conveyed in the \\ref spa_video_multiview_mode.\n+ *\/\n+enum spa_video_multiview_flags {\n+    SPA_VIDEO_MULTIVIEW_FLAGS_NONE = 0,            \/**< No flags *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST = (1 << 0),    \/**< For stereo streams, the normal arrangement\n+                                 *   of left and right views is reversed *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED = (1 << 1),    \/**< The left view is vertically mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED = (1 << 2),    \/**< The left view is horizontally mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED = (1 << 3),    \/**< The right view is vertically mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED = (1 << 4),    \/**< The right view is horizontally mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT = (1 << 14),    \/**< For frame-packed multiview\n+                                 *   modes, indicates that the individual\n+                                 *   views have been encoded with half the true\n+                                 *   width or height and should be scaled back\n+                                 *   up for display. This flag is used for\n+                                 *   overriding input layout interpretation\n+                                 *   by adjusting pixel-aspect-ratio.\n+                                 *   For side-by-side, column interleaved or\n+                                 *   checkerboard packings, the\n+                                 *   pixel width will be doubled.\n+                                 *   For row interleaved and\n+                                 *   top-bottom encodings, pixel height will\n+                                 *   be doubled *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO = (1 << 15),    \/**< The video stream contains both\n+                                 *   mono and multiview portions,\n+                                 *   signalled on each buffer by the\n+                                 *   absence or presence of the\n+                                 *   \\ref SPA_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW\n+                                 *   buffer flag. *\/\n+};\n+\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MULTIVIEW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/multiview.h","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_TYPES_H\n+#define SPA_VIDEO_RAW_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/video\/raw.h>\n+\n+#define SPA_TYPE_INFO_VideoFormat        SPA_TYPE_INFO_ENUM_BASE \"VideoFormat\"\n+#define SPA_TYPE_INFO_VIDEO_FORMAT_BASE        SPA_TYPE_INFO_VideoFormat \":\"\n+\n+static const struct spa_type_info spa_type_video_format[] = {\n+    { SPA_VIDEO_FORMAT_ENCODED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"encoded\", NULL },\n+    { SPA_VIDEO_FORMAT_I420,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420\", NULL },\n+    { SPA_VIDEO_FORMAT_YV12,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YV12\", NULL },\n+    { SPA_VIDEO_FORMAT_YUY2,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YUY2\", NULL },\n+    { SPA_VIDEO_FORMAT_UYVY,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"UYVY\", NULL },\n+    { SPA_VIDEO_FORMAT_AYUV,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"AYUV\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBx,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBx\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRx,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRx\", NULL },\n+    { SPA_VIDEO_FORMAT_xRGB,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xRGB\", NULL },\n+    { SPA_VIDEO_FORMAT_xBGR,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xBGR\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRA\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB\", NULL },\n+    { SPA_VIDEO_FORMAT_ABGR,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ABGR\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR\", NULL },\n+    { SPA_VIDEO_FORMAT_Y41B,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y41B\", NULL },\n+    { SPA_VIDEO_FORMAT_Y42B,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y42B\", NULL },\n+    { SPA_VIDEO_FORMAT_YVYU,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YVYU\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444\", NULL },\n+    { SPA_VIDEO_FORMAT_v210,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v210\", NULL },\n+    { SPA_VIDEO_FORMAT_v216,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v216\", NULL },\n+    { SPA_VIDEO_FORMAT_NV12,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV12\", NULL },\n+    { SPA_VIDEO_FORMAT_NV21,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV21\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY8,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY8\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY16_BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY16_BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY16_LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY16_LE\", NULL },\n+    { SPA_VIDEO_FORMAT_v308,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v308\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB16\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR16\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB15,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB15\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR15,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR15\", NULL },\n+    { SPA_VIDEO_FORMAT_UYVP,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"UYVP\", NULL },\n+    { SPA_VIDEO_FORMAT_A420,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB8P,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB8P\", NULL },\n+    { SPA_VIDEO_FORMAT_YUV9,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YUV9\", NULL },\n+    { SPA_VIDEO_FORMAT_YVU9,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YVU9\", NULL },\n+    { SPA_VIDEO_FORMAT_IYU1,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"IYU1\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB64,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB64\", NULL },\n+    { SPA_VIDEO_FORMAT_AYUV64,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"AYUV64\", NULL },\n+    { SPA_VIDEO_FORMAT_r210,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"r210\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_NV16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV16\", NULL },\n+    { SPA_VIDEO_FORMAT_NV24,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV24\", NULL },\n+    { SPA_VIDEO_FORMAT_NV12_64Z32,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV12_64Z32\", NULL },\n+    { SPA_VIDEO_FORMAT_A420_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A420_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_A422_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A422_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A422_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A422_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_A444_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A444_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A444_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A444_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_NV61,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV61\", NULL },\n+    { SPA_VIDEO_FORMAT_P010_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"P010_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_P010_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"P010_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_IYU2,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"IYU2\", NULL },\n+    { SPA_VIDEO_FORMAT_VYUY,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"VYUY\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_F16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_F16\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_F32,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_F32\", NULL },\n+    { SPA_VIDEO_FORMAT_xRGB_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xRGB_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_xBGR_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xBGR_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBx_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBx_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRx_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRx_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_ABGR_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ABGR_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRA_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRA_102LE\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_VideoFlags    SPA_TYPE_INFO_FLAGS_BASE \"VideoFlags\"\n+#define SPA_TYPE_INFO_VIDEO_FLAGS_BASE    SPA_TYPE_INFO_VideoFlags \":\"\n+\n+static const struct spa_type_info spa_type_video_flags[] = {\n+\n+    { SPA_VIDEO_FLAG_NONE, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"none\", NULL },\n+    { SPA_VIDEO_FLAG_VARIABLE_FPS, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"variable-fps\", NULL },\n+    { SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"premultiplied-alpha\", NULL },\n+    { SPA_VIDEO_FLAG_MODIFIER, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"modifier\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_VideoInterlaceMode        SPA_TYPE_INFO_ENUM_BASE \"VideoInterlaceMode\"\n+#define SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE        SPA_TYPE_INFO_VideoInterlaceMode \":\"\n+\n+static const struct spa_type_info spa_type_video_interlace_mode[] = {\n+    { SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"progressive\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_INTERLEAVED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"interleaved\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_MIXED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"mixed\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_FIELDS,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"fields\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw-types.h","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_UTILS_H\n+#define SPA_VIDEO_RAW_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/raw.h>\n+\n+static inline int\n+spa_format_video_raw_parse(const struct spa_pod *format,\n+               struct spa_video_info_raw *info)\n+{\n+    info->flags = SPA_VIDEO_FLAG_NONE;\n+    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+        info->flags |= SPA_VIDEO_FLAG_MODIFIER;\n+    }\n+\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_VIDEO_format,        SPA_POD_OPT_Id(&info->format),\n+        SPA_FORMAT_VIDEO_modifier,        SPA_POD_OPT_Long(&info->modifier),\n+        SPA_FORMAT_VIDEO_size,            SPA_POD_OPT_Rectangle(&info->size),\n+        SPA_FORMAT_VIDEO_framerate,        SPA_POD_OPT_Fraction(&info->framerate),\n+        SPA_FORMAT_VIDEO_maxFramerate,        SPA_POD_OPT_Fraction(&info->max_framerate),\n+        SPA_FORMAT_VIDEO_views,            SPA_POD_OPT_Int(&info->views),\n+        SPA_FORMAT_VIDEO_interlaceMode,        SPA_POD_OPT_Id(&info->interlace_mode),\n+        SPA_FORMAT_VIDEO_pixelAspectRatio,    SPA_POD_OPT_Fraction(&info->pixel_aspect_ratio),\n+        SPA_FORMAT_VIDEO_multiviewMode,        SPA_POD_OPT_Id(&info->multiview_mode),\n+        SPA_FORMAT_VIDEO_multiviewFlags,    SPA_POD_OPT_Id(&info->multiview_flags),\n+        SPA_FORMAT_VIDEO_chromaSite,        SPA_POD_OPT_Id(&info->chroma_site),\n+        SPA_FORMAT_VIDEO_colorRange,        SPA_POD_OPT_Id(&info->color_range),\n+        SPA_FORMAT_VIDEO_colorMatrix,        SPA_POD_OPT_Id(&info->color_matrix),\n+        SPA_FORMAT_VIDEO_transferFunction,    SPA_POD_OPT_Id(&info->transfer_function),\n+        SPA_FORMAT_VIDEO_colorPrimaries,    SPA_POD_OPT_Id(&info->color_primaries));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_raw_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_raw *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),\n+            0);\n+    if (info->format != SPA_VIDEO_FORMAT_UNKNOWN)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_format,    SPA_POD_Id(info->format), 0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    if (info->views != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_views,        SPA_POD_Int(info->views), 0);\n+    if (info->interlace_mode != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_interlaceMode,    SPA_POD_Id(info->interlace_mode), 0);\n+    if (info->pixel_aspect_ratio.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_pixelAspectRatio,SPA_POD_Fraction(info->pixel_aspect_ratio), 0);\n+    if (info->multiview_mode != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_multiviewMode,    SPA_POD_Id(info->multiview_mode), 0);\n+    if (info->multiview_flags != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_multiviewFlags,SPA_POD_Id(info->multiview_flags), 0);\n+    if (info->chroma_site != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_chromaSite,    SPA_POD_Id(info->chroma_site), 0);\n+    if (info->color_range != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorRange,    SPA_POD_Id(info->color_range), 0);\n+    if (info->color_matrix != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorMatrix,    SPA_POD_Id(info->color_matrix), 0);\n+    if (info->transfer_function != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_transferFunction,SPA_POD_Id(info->transfer_function), 0);\n+    if (info->color_primaries != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorPrimaries,SPA_POD_Id(info->color_primaries), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw-utils.h","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_H\n+#define SPA_VIDEO_RAW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/video\/chroma.h>\n+#include <spa\/param\/video\/color.h>\n+#include <spa\/param\/video\/multiview.h>\n+\n+#define SPA_VIDEO_MAX_PLANES 4\n+#define SPA_VIDEO_MAX_COMPONENTS 4\n+\n+\/**\n+ * Video formats\n+ *\n+ * The components are in general described in big-endian order. There are some\n+ * exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n+ *\n+ * Most of the formats are identical to their GStreamer equivalent. See the\n+ * GStreamer video formats documentation for more details:\n+ *\n+ * https:\/\/gstreamer.freedesktop.org\/documentation\/additional\/design\/mediatype-video-raw.html#formats\n+ *\/\n+enum spa_video_format {\n+    SPA_VIDEO_FORMAT_UNKNOWN,\n+    SPA_VIDEO_FORMAT_ENCODED,\n+\n+    SPA_VIDEO_FORMAT_I420,\n+    SPA_VIDEO_FORMAT_YV12,\n+    SPA_VIDEO_FORMAT_YUY2,\n+    SPA_VIDEO_FORMAT_UYVY,\n+    SPA_VIDEO_FORMAT_AYUV,\n+    SPA_VIDEO_FORMAT_RGBx,\n+    SPA_VIDEO_FORMAT_BGRx,\n+    SPA_VIDEO_FORMAT_xRGB,\n+    SPA_VIDEO_FORMAT_xBGR,\n+    SPA_VIDEO_FORMAT_RGBA,\n+    SPA_VIDEO_FORMAT_BGRA,\n+    SPA_VIDEO_FORMAT_ARGB,\n+    SPA_VIDEO_FORMAT_ABGR,\n+    SPA_VIDEO_FORMAT_RGB,\n+    SPA_VIDEO_FORMAT_BGR,\n+    SPA_VIDEO_FORMAT_Y41B,\n+    SPA_VIDEO_FORMAT_Y42B,\n+    SPA_VIDEO_FORMAT_YVYU,\n+    SPA_VIDEO_FORMAT_Y444,\n+    SPA_VIDEO_FORMAT_v210,\n+    SPA_VIDEO_FORMAT_v216,\n+    SPA_VIDEO_FORMAT_NV12,\n+    SPA_VIDEO_FORMAT_NV21,\n+    SPA_VIDEO_FORMAT_GRAY8,\n+    SPA_VIDEO_FORMAT_GRAY16_BE,\n+    SPA_VIDEO_FORMAT_GRAY16_LE,\n+    SPA_VIDEO_FORMAT_v308,\n+    SPA_VIDEO_FORMAT_RGB16,\n+    SPA_VIDEO_FORMAT_BGR16,\n+    SPA_VIDEO_FORMAT_RGB15,\n+    SPA_VIDEO_FORMAT_BGR15,\n+    SPA_VIDEO_FORMAT_UYVP,\n+    SPA_VIDEO_FORMAT_A420,\n+    SPA_VIDEO_FORMAT_RGB8P,\n+    SPA_VIDEO_FORMAT_YUV9,\n+    SPA_VIDEO_FORMAT_YVU9,\n+    SPA_VIDEO_FORMAT_IYU1,\n+    SPA_VIDEO_FORMAT_ARGB64,\n+    SPA_VIDEO_FORMAT_AYUV64,\n+    SPA_VIDEO_FORMAT_r210,\n+    SPA_VIDEO_FORMAT_I420_10BE,\n+    SPA_VIDEO_FORMAT_I420_10LE,\n+    SPA_VIDEO_FORMAT_I422_10BE,\n+    SPA_VIDEO_FORMAT_I422_10LE,\n+    SPA_VIDEO_FORMAT_Y444_10BE,\n+    SPA_VIDEO_FORMAT_Y444_10LE,\n+    SPA_VIDEO_FORMAT_GBR,\n+    SPA_VIDEO_FORMAT_GBR_10BE,\n+    SPA_VIDEO_FORMAT_GBR_10LE,\n+    SPA_VIDEO_FORMAT_NV16,\n+    SPA_VIDEO_FORMAT_NV24,\n+    SPA_VIDEO_FORMAT_NV12_64Z32,\n+    SPA_VIDEO_FORMAT_A420_10BE,\n+    SPA_VIDEO_FORMAT_A420_10LE,\n+    SPA_VIDEO_FORMAT_A422_10BE,\n+    SPA_VIDEO_FORMAT_A422_10LE,\n+    SPA_VIDEO_FORMAT_A444_10BE,\n+    SPA_VIDEO_FORMAT_A444_10LE,\n+    SPA_VIDEO_FORMAT_NV61,\n+    SPA_VIDEO_FORMAT_P010_10BE,\n+    SPA_VIDEO_FORMAT_P010_10LE,\n+    SPA_VIDEO_FORMAT_IYU2,\n+    SPA_VIDEO_FORMAT_VYUY,\n+    SPA_VIDEO_FORMAT_GBRA,\n+    SPA_VIDEO_FORMAT_GBRA_10BE,\n+    SPA_VIDEO_FORMAT_GBRA_10LE,\n+    SPA_VIDEO_FORMAT_GBR_12BE,\n+    SPA_VIDEO_FORMAT_GBR_12LE,\n+    SPA_VIDEO_FORMAT_GBRA_12BE,\n+    SPA_VIDEO_FORMAT_GBRA_12LE,\n+    SPA_VIDEO_FORMAT_I420_12BE,\n+    SPA_VIDEO_FORMAT_I420_12LE,\n+    SPA_VIDEO_FORMAT_I422_12BE,\n+    SPA_VIDEO_FORMAT_I422_12LE,\n+    SPA_VIDEO_FORMAT_Y444_12BE,\n+    SPA_VIDEO_FORMAT_Y444_12LE,\n+\n+    SPA_VIDEO_FORMAT_RGBA_F16,\n+    SPA_VIDEO_FORMAT_RGBA_F32,\n+\n+    SPA_VIDEO_FORMAT_xRGB_210LE,    \/**< 32-bit x:R:G:B 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_xBGR_210LE,    \/**< 32-bit x:B:G:R 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_RGBx_102LE,    \/**< 32-bit R:G:B:x 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_BGRx_102LE,    \/**< 32-bit B:G:R:x 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_ARGB_210LE,    \/**< 32-bit A:R:G:B 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_ABGR_210LE,    \/**< 32-bit A:B:G:R 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_RGBA_102LE,    \/**< 32-bit R:G:B:A 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_BGRA_102LE,    \/**< 32-bit B:G:R:A 10:10:10:2 little endian *\/\n+\n+    \/* Aliases *\/\n+    SPA_VIDEO_FORMAT_DSP_F32 = SPA_VIDEO_FORMAT_RGBA_F32,\n+};\n+\n+\/**\n+ * Extra video flags\n+ *\/\n+enum spa_video_flags {\n+    SPA_VIDEO_FLAG_NONE = 0,            \/**< no flags *\/\n+    SPA_VIDEO_FLAG_VARIABLE_FPS = (1 << 0),        \/**< a variable fps is selected, fps_n and fps_d\n+                             *   denote the maximum fps of the video *\/\n+    SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA = (1 << 1),  \/**< Each color has been scaled by the alpha value. *\/\n+    SPA_VIDEO_FLAG_MODIFIER = (1 << 2),        \/**< use the format modifier *\/\n+};\n+\n+\/**\n+ * The possible values of the #spa_video_interlace_mode describing the interlace\n+ * mode of the stream.\n+ *\/\n+enum spa_video_interlace_mode {\n+    SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE = 0,    \/**< all frames are progressive *\/\n+    SPA_VIDEO_INTERLACE_MODE_INTERLEAVED,        \/**< 2 fields are interleaved in one video frame.\n+                             * Extra buffer flags describe the field order. *\/\n+    SPA_VIDEO_INTERLACE_MODE_MIXED,            \/**< frames contains both interlaced and progressive\n+                             *   video, the buffer flags describe the frame and\n+                             *   fields. *\/\n+    SPA_VIDEO_INTERLACE_MODE_FIELDS,        \/**< 2 fields are stored in one buffer, use the\n+                             *   frame ID to get access to the required\n+                             *   field. For multiview (the 'views'\n+                             *   property > 1) the fields of view N can\n+                             *   be found at frame ID (N * 2) and (N *\n+                             *   2) + 1. Each field has only half the\n+                             *   amount of lines as noted in the height\n+                             *   property. This mode requires multiple\n+                             *   spa_data to describe the fields. *\/\n+};\n+\n+\/**\n+ *\/\n+struct spa_video_info_raw {\n+    enum spa_video_format format;                \/**< the format *\/\n+    uint32_t flags;                        \/**< extra video flags *\/\n+    uint64_t modifier;                    \/**< format modifier\n+                                  * only used with DMA-BUF *\/\n+    struct spa_rectangle size;                \/**< the frame size of the video *\/\n+    struct spa_fraction framerate;                \/**< the framerate of the video, 0\/1 means variable rate *\/\n+    struct spa_fraction max_framerate;            \/**< the maximum framerate of the video. This is only valid when\n+                                     \\ref framerate is 0\/1 *\/\n+    uint32_t views;                        \/**< the number of views in this video *\/\n+    enum spa_video_interlace_mode interlace_mode;        \/**< the interlace mode *\/\n+    struct spa_fraction pixel_aspect_ratio;            \/**< the pixel aspect ratio *\/\n+    enum spa_video_multiview_mode multiview_mode;        \/**< multiview mode *\/\n+    enum spa_video_multiview_flags multiview_flags;        \/**< multiview flags *\/\n+    enum spa_video_chroma_site chroma_site;            \/**< the chroma siting *\/\n+    enum spa_video_color_range color_range;            \/**< the color range. This is the valid range for the samples.\n+                                 *   It is used to convert the samples to Y'PbPr values. *\/\n+    enum spa_video_color_matrix color_matrix;        \/**< the color matrix. Used to convert between Y'PbPr and\n+                                 *   non-linear RGB (R'G'B') *\/\n+    enum spa_video_transfer_function transfer_function;    \/**< the transfer function. used to convert between R'G'B' and RGB *\/\n+    enum spa_video_color_primaries color_primaries;        \/**< color primaries. used to convert between R'G'B' and CIE XYZ *\/\n+};\n+\n+#define SPA_VIDEO_INFO_RAW_INIT(...)    ((struct spa_video_info_raw) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw.h","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_TYPES_H\n+#define SPA_VIDEO_TYPES_H\n+\n+#include <spa\/param\/video\/raw-types.h>\n+\n+#endif \/* SPA_VIDEO_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/type-info.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,681 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_BUILDER_H\n+#define SPA_POD_BUILDER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\defgroup spa_pod POD\n+ * Binary data serialization format\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#include <stdarg.h>\n+\n+#include <spa\/utils\/hook.h>\n+#include <spa\/pod\/iter.h>\n+#include <spa\/pod\/vararg.h>\n+\n+struct spa_pod_builder_state {\n+    uint32_t offset;\n+#define SPA_POD_BUILDER_FLAG_BODY    (1<<0)\n+#define SPA_POD_BUILDER_FLAG_FIRST    (1<<1)\n+    uint32_t flags;\n+    struct spa_pod_frame *frame;\n+};\n+\n+struct spa_pod_builder;\n+\n+struct spa_pod_builder_callbacks {\n+#define SPA_VERSION_POD_BUILDER_CALLBACKS 0\n+    uint32_t version;\n+\n+    int (*overflow) (void *data, uint32_t size);\n+};\n+\n+struct spa_pod_builder {\n+    void *data;\n+    uint32_t size;\n+    uint32_t _padding;\n+    struct spa_pod_builder_state state;\n+    struct spa_callbacks callbacks;\n+};\n+\n+#define SPA_POD_BUILDER_INIT(buffer,size)  ((struct spa_pod_builder){ (buffer), (size), 0, {}, {} })\n+\n+static inline void\n+spa_pod_builder_get_state(struct spa_pod_builder *builder, struct spa_pod_builder_state *state)\n+{\n+    *state = builder->state;\n+}\n+\n+static inline void\n+spa_pod_builder_set_callbacks(struct spa_pod_builder *builder,\n+        const struct spa_pod_builder_callbacks *callbacks, void *data)\n+{\n+    builder->callbacks = SPA_CALLBACKS_INIT(callbacks, data);\n+}\n+\n+static inline void\n+spa_pod_builder_reset(struct spa_pod_builder *builder, struct spa_pod_builder_state *state)\n+{\n+    struct spa_pod_frame *f;\n+    uint32_t size = builder->state.offset - state->offset;\n+    builder->state = *state;\n+    for (f = builder->state.frame; f ; f = f->parent)\n+        f->pod.size -= size;\n+}\n+\n+static inline void spa_pod_builder_init(struct spa_pod_builder *builder, void *data, uint32_t size)\n+{\n+    *builder = SPA_POD_BUILDER_INIT(data, size);\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_builder_deref(struct spa_pod_builder *builder, uint32_t offset)\n+{\n+    uint32_t size = builder->size;\n+    if (offset + 8 <= size) {\n+        struct spa_pod *pod = SPA_PTROFF(builder->data, offset, struct spa_pod);\n+        if (offset + SPA_POD_SIZE(pod) <= size)\n+            return pod;\n+    }\n+    return NULL;\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_builder_frame(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    if (frame->offset + SPA_POD_SIZE(&frame->pod) <= builder->size)\n+        return SPA_PTROFF(builder->data, frame->offset, struct spa_pod);\n+    return NULL;\n+}\n+\n+static inline void\n+spa_pod_builder_push(struct spa_pod_builder *builder,\n+             struct spa_pod_frame *frame,\n+             const struct spa_pod *pod,\n+             uint32_t offset)\n+{\n+    frame->pod = *pod;\n+    frame->offset = offset;\n+    frame->parent = builder->state.frame;\n+    frame->flags = builder->state.flags;\n+    builder->state.frame = frame;\n+\n+    if (frame->pod.type == SPA_TYPE_Array || frame->pod.type == SPA_TYPE_Choice)\n+        builder->state.flags = SPA_POD_BUILDER_FLAG_FIRST | SPA_POD_BUILDER_FLAG_BODY;\n+}\n+\n+static inline int spa_pod_builder_raw(struct spa_pod_builder *builder, const void *data, uint32_t size)\n+{\n+    int res = 0;\n+    struct spa_pod_frame *f;\n+    uint32_t offset = builder->state.offset;\n+\n+    if (offset + size > builder->size) {\n+        res = -ENOSPC;\n+        if (offset <= builder->size)\n+            spa_callbacks_call_res(&builder->callbacks,\n+                    struct spa_pod_builder_callbacks, res,\n+                    overflow, 0, offset + size);\n+    }\n+    if (res == 0 && data)\n+        memcpy(SPA_PTROFF(builder->data, offset, void), data, size);\n+\n+    builder->state.offset += size;\n+\n+    for (f = builder->state.frame; f ; f = f->parent)\n+        f->pod.size += size;\n+\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_pad(struct spa_pod_builder *builder, uint32_t size)\n+{\n+    uint64_t zeroes = 0;\n+    size = SPA_ROUND_UP_N(size, 8) - size;\n+    return size ? spa_pod_builder_raw(builder, &zeroes, size) : 0;\n+}\n+\n+static inline int\n+spa_pod_builder_raw_padded(struct spa_pod_builder *builder, const void *data, uint32_t size)\n+{\n+    int r, res = spa_pod_builder_raw(builder, data, size);\n+    if ((r = spa_pod_builder_pad(builder, size)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline void *spa_pod_builder_pop(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    struct spa_pod *pod;\n+\n+    if (SPA_FLAG_IS_SET(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST)) {\n+        const struct spa_pod p = { 0, SPA_TYPE_None };\n+        spa_pod_builder_raw(builder, &p, sizeof(p));\n+    }\n+    if ((pod = (struct spa_pod*)spa_pod_builder_frame(builder, frame)) != NULL)\n+        *pod = frame->pod;\n+\n+    builder->state.frame = frame->parent;\n+    builder->state.flags = frame->flags;\n+    spa_pod_builder_pad(builder, builder->state.offset);\n+    return pod;\n+}\n+\n+static inline int\n+spa_pod_builder_primitive(struct spa_pod_builder *builder, const struct spa_pod *p)\n+{\n+    const void *data;\n+    uint32_t size;\n+    int r, res;\n+\n+    if (builder->state.flags == SPA_POD_BUILDER_FLAG_BODY) {\n+        data = SPA_POD_BODY_CONST(p);\n+        size = SPA_POD_BODY_SIZE(p);\n+    } else {\n+        data = p;\n+        size = SPA_POD_SIZE(p);\n+        SPA_FLAG_CLEAR(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST);\n+    }\n+    res = spa_pod_builder_raw(builder, data, size);\n+    if (builder->state.flags != SPA_POD_BUILDER_FLAG_BODY)\n+        if ((r = spa_pod_builder_pad(builder, size)) < 0)\n+            res = r;\n+    return res;\n+}\n+\n+#define SPA_POD_INIT(size,type) ((struct spa_pod) { (size), (type) })\n+\n+#define SPA_POD_INIT_None() SPA_POD_INIT(0, SPA_TYPE_None)\n+\n+static inline int spa_pod_builder_none(struct spa_pod_builder *builder)\n+{\n+    const struct spa_pod p = SPA_POD_INIT_None();\n+    return spa_pod_builder_primitive(builder, &p);\n+}\n+\n+static inline int spa_pod_builder_child(struct spa_pod_builder *builder, uint32_t size, uint32_t type)\n+{\n+    const struct spa_pod p = SPA_POD_INIT(size,type);\n+    SPA_FLAG_CLEAR(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST);\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+#define SPA_POD_INIT_Bool(val) ((struct spa_pod_bool){ { sizeof(uint32_t), SPA_TYPE_Bool }, (val) ? 1 : 0, 0 })\n+\n+static inline int spa_pod_builder_bool(struct spa_pod_builder *builder, bool val)\n+{\n+    const struct spa_pod_bool p = SPA_POD_INIT_Bool(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Id(val) ((struct spa_pod_id){ { sizeof(uint32_t), SPA_TYPE_Id }, (val), 0 })\n+\n+static inline int spa_pod_builder_id(struct spa_pod_builder *builder, uint32_t val)\n+{\n+    const struct spa_pod_id p = SPA_POD_INIT_Id(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Int(val) ((struct spa_pod_int){ { sizeof(int32_t), SPA_TYPE_Int }, (val), 0 })\n+\n+static inline int spa_pod_builder_int(struct spa_pod_builder *builder, int32_t val)\n+{\n+    const struct spa_pod_int p = SPA_POD_INIT_Int(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Long(val) ((struct spa_pod_long){ { sizeof(int64_t), SPA_TYPE_Long }, (val) })\n+\n+static inline int spa_pod_builder_long(struct spa_pod_builder *builder, int64_t val)\n+{\n+    const struct spa_pod_long p = SPA_POD_INIT_Long(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Float(val) ((struct spa_pod_float){ { sizeof(float), SPA_TYPE_Float }, (val), 0 })\n+\n+static inline int spa_pod_builder_float(struct spa_pod_builder *builder, float val)\n+{\n+    const struct spa_pod_float p = SPA_POD_INIT_Float(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Double(val) ((struct spa_pod_double){ { sizeof(double), SPA_TYPE_Double }, (val) })\n+\n+static inline int spa_pod_builder_double(struct spa_pod_builder *builder, double val)\n+{\n+    const struct spa_pod_double p = SPA_POD_INIT_Double(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_String(len) ((struct spa_pod_string){ { (len), SPA_TYPE_String } })\n+\n+static inline int\n+spa_pod_builder_write_string(struct spa_pod_builder *builder, const char *str, uint32_t len)\n+{\n+    int r, res;\n+    res = spa_pod_builder_raw(builder, str, len);\n+    if ((r = spa_pod_builder_raw(builder, \"\", 1)) < 0)\n+        res = r;\n+    if ((r = spa_pod_builder_pad(builder, builder->state.offset)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline int\n+spa_pod_builder_string_len(struct spa_pod_builder *builder, const char *str, uint32_t len)\n+{\n+    const struct spa_pod_string p = SPA_POD_INIT_String(len+1);\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_write_string(builder, str, len)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_string(struct spa_pod_builder *builder, const char *str)\n+{\n+    uint32_t len = str ? strlen(str) : 0;\n+    return spa_pod_builder_string_len(builder, str ? str : \"\", len);\n+}\n+\n+#define SPA_POD_INIT_Bytes(len) ((struct spa_pod_bytes){ { (len), SPA_TYPE_Bytes } })\n+\n+static inline int\n+spa_pod_builder_bytes(struct spa_pod_builder *builder, const void *bytes, uint32_t len)\n+{\n+    const struct spa_pod_bytes p = SPA_POD_INIT_Bytes(len);\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_raw_padded(builder, bytes, len)) < 0)\n+        res = r;\n+    return res;\n+}\n+static inline void *\n+spa_pod_builder_reserve_bytes(struct spa_pod_builder *builder, uint32_t len)\n+{\n+    uint32_t offset = builder->state.offset;\n+    if (spa_pod_builder_bytes(builder, NULL, len) < 0)\n+        return NULL;\n+    return SPA_POD_BODY(spa_pod_builder_deref(builder, offset));\n+}\n+\n+#define SPA_POD_INIT_Pointer(type,value) ((struct spa_pod_pointer){ { sizeof(struct spa_pod_pointer_body), SPA_TYPE_Pointer }, { (type), 0, (value) } })\n+\n+static inline int\n+spa_pod_builder_pointer(struct spa_pod_builder *builder, uint32_t type, const void *val)\n+{\n+    const struct spa_pod_pointer p = SPA_POD_INIT_Pointer(type, val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Fd(fd) ((struct spa_pod_fd){ { sizeof(int64_t), SPA_TYPE_Fd }, (fd) })\n+\n+static inline int spa_pod_builder_fd(struct spa_pod_builder *builder, int64_t fd)\n+{\n+    const struct spa_pod_fd p = SPA_POD_INIT_Fd(fd);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Rectangle(val) ((struct spa_pod_rectangle){ { sizeof(struct spa_rectangle), SPA_TYPE_Rectangle }, (val) })\n+\n+static inline int\n+spa_pod_builder_rectangle(struct spa_pod_builder *builder, uint32_t width, uint32_t height)\n+{\n+    const struct spa_pod_rectangle p = SPA_POD_INIT_Rectangle(SPA_RECTANGLE(width, height));\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Fraction(val) ((struct spa_pod_fraction){ { sizeof(struct spa_fraction), SPA_TYPE_Fraction }, (val) })\n+\n+static inline int\n+spa_pod_builder_fraction(struct spa_pod_builder *builder, uint32_t num, uint32_t denom)\n+{\n+    const struct spa_pod_fraction p = SPA_POD_INIT_Fraction(SPA_FRACTION(num, denom));\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+static inline int\n+spa_pod_builder_push_array(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod_array p =\n+        { {sizeof(struct spa_pod_array_body) - sizeof(struct spa_pod), SPA_TYPE_Array},\n+        {{0, 0}} };\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p) - sizeof(struct spa_pod));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+static inline int\n+spa_pod_builder_array(struct spa_pod_builder *builder,\n+              uint32_t child_size, uint32_t child_type, uint32_t n_elems, const void *elems)\n+{\n+    const struct spa_pod_array p = {\n+        {(uint32_t)(sizeof(struct spa_pod_array_body) + n_elems * child_size), SPA_TYPE_Array},\n+        {{child_size, child_type}}\n+    };\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_raw_padded(builder, elems, child_size * n_elems)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_CHOICE_BODY(type, flags, child_size, child_type)                \\\n+    ((struct spa_pod_choice_body) { (type), (flags), { (child_size), (child_type) }})\n+\n+#define SPA_POD_INIT_Choice(type, ctype, child_type, n_vals, ...)                \\\n+    ((struct { struct spa_pod_choice choice; ctype vals[(n_vals)];})            \\\n+    { { { (n_vals) * sizeof(ctype) + sizeof(struct spa_pod_choice_body), SPA_TYPE_Choice },    \\\n+        { (type), 0, { sizeof(ctype), (child_type) } } }, { __VA_ARGS__ } })\n+\n+static inline int\n+spa_pod_builder_push_choice(struct spa_pod_builder *builder, struct spa_pod_frame *frame,\n+        uint32_t type, uint32_t flags)\n+{\n+    const struct spa_pod_choice p =\n+        { {sizeof(struct spa_pod_choice_body) - sizeof(struct spa_pod), SPA_TYPE_Choice},\n+        { type, flags, {0, 0}} };\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p) - sizeof(struct spa_pod));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Struct(size) ((struct spa_pod_struct){ { (size), SPA_TYPE_Struct } })\n+\n+static inline int\n+spa_pod_builder_push_struct(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod_struct p = SPA_POD_INIT_Struct(0);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Object(size,type,id,...)    ((struct spa_pod_object){ { (size), SPA_TYPE_Object }, { (type), (id) }, ##__VA_ARGS__ })\n+\n+static inline int\n+spa_pod_builder_push_object(struct spa_pod_builder *builder, struct spa_pod_frame *frame,\n+        uint32_t type, uint32_t id)\n+{\n+    const struct spa_pod_object p =\n+        SPA_POD_INIT_Object(sizeof(struct spa_pod_object_body), type, id);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Prop(key,flags,size,type)    \\\n+    ((struct spa_pod_prop){ (key), (flags), { (size), (type) } })\n+\n+static inline int\n+spa_pod_builder_prop(struct spa_pod_builder *builder, uint32_t key, uint32_t flags)\n+{\n+    const struct { uint32_t key; uint32_t flags; } p = { key, flags };\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+#define SPA_POD_INIT_Sequence(size,unit)    \\\n+    ((struct spa_pod_sequence){ { (size), SPA_TYPE_Sequence}, {(unit), 0 } })\n+\n+static inline int\n+spa_pod_builder_push_sequence(struct spa_pod_builder *builder, struct spa_pod_frame *frame, uint32_t unit)\n+{\n+    const struct spa_pod_sequence p =\n+        SPA_POD_INIT_Sequence(sizeof(struct spa_pod_sequence_body), unit);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+static inline uint32_t\n+spa_pod_builder_control(struct spa_pod_builder *builder, uint32_t offset, uint32_t type)\n+{\n+    const struct { uint32_t offset; uint32_t type; } p = { offset, type };\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+static inline uint32_t spa_choice_from_id(char id)\n+{\n+    switch (id) {\n+    case 'r':\n+        return SPA_CHOICE_Range;\n+    case 's':\n+        return SPA_CHOICE_Step;\n+    case 'e':\n+        return SPA_CHOICE_Enum;\n+    case 'f':\n+        return SPA_CHOICE_Flags;\n+    case 'n':\n+    default:\n+        return SPA_CHOICE_None;\n+    }\n+}\n+\n+#define SPA_POD_BUILDER_COLLECT(builder,type,args)                \\\n+do {                                        \\\n+    switch (type) {                                \\\n+    case 'b':                                \\\n+        spa_pod_builder_bool(builder, !!va_arg(args, int));        \\\n+        break;                                \\\n+    case 'I':                                \\\n+        spa_pod_builder_id(builder, va_arg(args, uint32_t));        \\\n+        break;                                \\\n+    case 'i':                                \\\n+        spa_pod_builder_int(builder, va_arg(args, int));        \\\n+        break;                                \\\n+    case 'l':                                \\\n+        spa_pod_builder_long(builder, va_arg(args, int64_t));        \\\n+        break;                                \\\n+    case 'f':                                \\\n+        spa_pod_builder_float(builder, va_arg(args, double));        \\\n+        break;                                \\\n+    case 'd':                                \\\n+        spa_pod_builder_double(builder, va_arg(args, double));        \\\n+        break;                                \\\n+    case 's':                                \\\n+    {                                    \\\n+        char *strval = va_arg(args, char *);                \\\n+        if (strval != NULL) {                        \\\n+            size_t len = strlen(strval);                \\\n+            spa_pod_builder_string_len(builder, strval, len);    \\\n+        }                                \\\n+        else                                \\\n+            spa_pod_builder_none(builder);                \\\n+        break;                                \\\n+    }                                    \\\n+    case 'S':                                \\\n+    {                                    \\\n+        char *strval = va_arg(args, char *);                \\\n+        size_t len = va_arg(args, int);                    \\\n+        spa_pod_builder_string_len(builder, strval, len);        \\\n+        break;                                \\\n+    }                                    \\\n+    case 'y':                                \\\n+    {                                    \\\n+        void *ptr  = va_arg(args, void *);                \\\n+        int len = va_arg(args, int);                    \\\n+        spa_pod_builder_bytes(builder, ptr, len);            \\\n+        break;                                \\\n+    }                                    \\\n+    case 'R':                                \\\n+    {                                    \\\n+        struct spa_rectangle *rectval =                    \\\n+            va_arg(args, struct spa_rectangle *);            \\\n+        spa_pod_builder_rectangle(builder,                \\\n+                rectval->width, rectval->height);        \\\n+        break;                                \\\n+    }                                    \\\n+    case 'F':                                \\\n+    {                                    \\\n+        struct spa_fraction *fracval =                    \\\n+            va_arg(args, struct spa_fraction *);            \\\n+        spa_pod_builder_fraction(builder, fracval->num, fracval->denom);\\\n+        break;                                \\\n+    }                                    \\\n+    case 'a':                                \\\n+    {                                    \\\n+        int child_size = va_arg(args, int);                \\\n+        int child_type = va_arg(args, int);                \\\n+        int n_elems = va_arg(args, int);                \\\n+        void *elems = va_arg(args, void *);                \\\n+        spa_pod_builder_array(builder, child_size,            \\\n+                child_type, n_elems, elems);            \\\n+        break;                                \\\n+    }                                    \\\n+    case 'p':                                \\\n+    {                                    \\\n+        int t = va_arg(args, uint32_t);                    \\\n+        spa_pod_builder_pointer(builder, t, va_arg(args, void *));    \\\n+        break;                                \\\n+    }                                    \\\n+    case 'h':                                \\\n+        spa_pod_builder_fd(builder, va_arg(args, int));            \\\n+        break;                                \\\n+    case 'P':                                \\\n+    case 'O':                                \\\n+    case 'T':                                \\\n+    case 'V':                                \\\n+    {                                    \\\n+        struct spa_pod *pod = va_arg(args, struct spa_pod *);        \\\n+        if (pod == NULL)                        \\\n+            spa_pod_builder_none(builder);                \\\n+        else                                \\\n+            spa_pod_builder_primitive(builder, pod);        \\\n+        break;                                \\\n+    }                                    \\\n+    }                                    \\\n+} while(false)\n+\n+static inline int\n+spa_pod_builder_addv(struct spa_pod_builder *builder, va_list args)\n+{\n+    int res = 0;\n+    struct spa_pod_frame *frame = builder->state.frame;\n+    uint32_t ftype = frame ? frame->pod.type : (uint32_t)SPA_TYPE_None;\n+\n+    do {\n+        const char *format;\n+        int n_values = 1;\n+        struct spa_pod_frame f;\n+        bool choice;\n+\n+        switch (ftype) {\n+        case SPA_TYPE_Object:\n+        {\n+            uint32_t key = va_arg(args, uint32_t);\n+            if (key == 0)\n+                goto exit;\n+            spa_pod_builder_prop(builder, key, 0);\n+            break;\n+        }\n+        case SPA_TYPE_Sequence:\n+        {\n+            uint32_t offset = va_arg(args, uint32_t);\n+            uint32_t type = va_arg(args, uint32_t);\n+            if (type == 0)\n+                goto exit;\n+            spa_pod_builder_control(builder, offset, type);\n+            SPA_FALLTHROUGH\n+        }\n+        default:\n+            break;\n+        }\n+        if ((format = va_arg(args, const char *)) == NULL)\n+            break;\n+\n+        choice = *format == '?';\n+        if (choice) {\n+            uint32_t type = spa_choice_from_id(*++format);\n+            if (*format != '\\0')\n+                format++;\n+\n+            spa_pod_builder_push_choice(builder, &f, type, 0);\n+\n+            n_values = va_arg(args, int);\n+        }\n+        while (n_values-- > 0)\n+            SPA_POD_BUILDER_COLLECT(builder, *format, args);\n+\n+        if (choice)\n+            spa_pod_builder_pop(builder, &f);\n+    } while (true);\n+\n+      exit:\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_add(struct spa_pod_builder *builder, ...)\n+{\n+    int res;\n+    va_list args;\n+\n+    va_start(args, builder);\n+    res = spa_pod_builder_addv(builder, args);\n+    va_end(args);\n+\n+    return res;\n+}\n+\n+#define spa_pod_builder_add_object(b,type,id,...)                \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_object(_b, &_f, type, id);                \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, 0);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+#define spa_pod_builder_add_struct(b,...)                    \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_struct(_b, &_f);                    \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, NULL);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+#define spa_pod_builder_add_sequence(b,unit,...)                \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_sequence(_b, &_f, unit);                \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, 0, 0);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+\/** Copy a pod structure *\/\n+static inline struct spa_pod *\n+spa_pod_copy(const struct spa_pod *pod)\n+{\n+    size_t size;\n+    struct spa_pod *c;\n+\n+    size = SPA_POD_SIZE(pod);\n+    if ((c = (struct spa_pod *) malloc(size)) == NULL)\n+        return NULL;\n+    return (struct spa_pod *) memcpy(c, pod, size);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_BUILDER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/builder.h","additions":681,"deletions":0,"binary":false,"changes":681,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_COMMAND_H\n+#define SPA_COMMAND_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_command_body {\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_command {\n+    struct spa_pod        pod;\n+    struct spa_command_body body;\n+};\n+\n+#define SPA_COMMAND_TYPE(cmd)        ((cmd)->body.body.type)\n+#define SPA_COMMAND_ID(cmd,type)    (SPA_COMMAND_TYPE(cmd) == (type) ? \\\n+                        (cmd)->body.body.id : SPA_ID_INVALID)\n+\n+#define SPA_COMMAND_INIT_FULL(t,size,type,id,...) ((t)            \\\n+    { { (size), SPA_TYPE_Object },                    \\\n+      { { (type), (id) }, ##__VA_ARGS__ } })\n+\n+#define SPA_COMMAND_INIT(type,id)                    \\\n+    SPA_COMMAND_INIT_FULL(struct spa_command,            \\\n+            sizeof(struct spa_command_body), type, id)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_COMMAND_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/command.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_H\n+#define SPA_EVENT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_event_body {\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_event {\n+    struct spa_pod pod;\n+    struct spa_event_body body;\n+};\n+\n+#define SPA_EVENT_TYPE(ev)    ((ev)->body.body.type)\n+#define SPA_EVENT_ID(ev,type)    (SPA_EVENT_TYPE(ev) == (type) ? \\\n+                    (ev)->body.body.id : SPA_ID_INVALID)\n+\n+#define SPA_EVENT_INIT_FULL(t,size,type,id,...) ((t)            \\\n+    { { (size), SPA_TYPE_OBJECT },                    \\\n+      { { (type), (id) }, ##__VA_ARGS__ } })            \\\n+\n+#define SPA_EVENT_INIT(type,id)                        \\\n+    SPA_EVENT_INIT_FULL(struct spa_event,                \\\n+            sizeof(struct spa_event_body), type, id)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/event.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,455 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_ITER_H\n+#define SPA_POD_ITER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <errno.h>\n+#include <sys\/types.h>\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_pod_frame {\n+    struct spa_pod pod;\n+    struct spa_pod_frame *parent;\n+    uint32_t offset;\n+    uint32_t flags;\n+};\n+\n+static inline bool spa_pod_is_inside(const void *pod, uint32_t size, const void *iter)\n+{\n+    return SPA_POD_BODY(iter) <= SPA_PTROFF(pod, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_SIZE(iter), void) <= SPA_PTROFF(pod, size, void);\n+}\n+\n+static inline void *spa_pod_next(const void *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_SIZE(iter), 8), void);\n+}\n+\n+static inline struct spa_pod_prop *spa_pod_prop_first(const struct spa_pod_object_body *body)\n+{\n+    return SPA_PTROFF(body, sizeof(struct spa_pod_object_body), struct spa_pod_prop);\n+}\n+\n+static inline bool spa_pod_prop_is_inside(const struct spa_pod_object_body *body,\n+        uint32_t size, const struct spa_pod_prop *iter)\n+{\n+    return SPA_POD_CONTENTS(struct spa_pod_prop, iter) <= SPA_PTROFF(body, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_PROP_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+}\n+\n+static inline struct spa_pod_prop *spa_pod_prop_next(const struct spa_pod_prop *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_PROP_SIZE(iter), 8), struct spa_pod_prop);\n+}\n+\n+static inline struct spa_pod_control *spa_pod_control_first(const struct spa_pod_sequence_body *body)\n+{\n+    return SPA_PTROFF(body, sizeof(struct spa_pod_sequence_body), struct spa_pod_control);\n+}\n+\n+static inline bool spa_pod_control_is_inside(const struct spa_pod_sequence_body *body,\n+        uint32_t size, const struct spa_pod_control *iter)\n+{\n+    return SPA_POD_CONTENTS(struct spa_pod_control, iter) <= SPA_PTROFF(body, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_CONTROL_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+}\n+\n+static inline struct spa_pod_control *spa_pod_control_next(const struct spa_pod_control *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_CONTROL_SIZE(iter), 8), struct spa_pod_control);\n+}\n+\n+#define SPA_POD_ARRAY_BODY_FOREACH(body, _size, iter)                            \\\n+    for ((iter) = (__typeof__(iter))SPA_PTROFF((body), sizeof(struct spa_pod_array_body), void);    \\\n+         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (iter) = (__typeof__(iter))SPA_PTROFF((iter), (body)->child.size, void))\n+\n+#define SPA_POD_ARRAY_FOREACH(obj, iter)                            \\\n+    SPA_POD_ARRAY_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_CHOICE_BODY_FOREACH(body, _size, iter)                            \\\n+    for ((iter) = (__typeof__(iter))SPA_PTROFF((body), sizeof(struct spa_pod_choice_body), void);    \\\n+         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (iter) = (__typeof__(iter))SPA_PTROFF((iter), (body)->child.size, void))\n+\n+#define SPA_POD_CHOICE_FOREACH(obj, iter)                            \\\n+    SPA_POD_CHOICE_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_FOREACH(pod, size, iter)                    \\\n+    for ((iter) = (pod);                            \\\n+         spa_pod_is_inside(pod, size, iter);                \\\n+         (iter) = (__typeof__(iter))spa_pod_next(iter))\n+\n+#define SPA_POD_STRUCT_FOREACH(obj, iter)                            \\\n+    SPA_POD_FOREACH(SPA_POD_BODY(obj), SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_OBJECT_BODY_FOREACH(body, size, iter)                        \\\n+    for ((iter) = spa_pod_prop_first(body);                \\\n+         spa_pod_prop_is_inside(body, size, iter);            \\\n+         (iter) = spa_pod_prop_next(iter))\n+\n+#define SPA_POD_OBJECT_FOREACH(obj, iter)                            \\\n+    SPA_POD_OBJECT_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_SEQUENCE_BODY_FOREACH(body, size, iter)                        \\\n+    for ((iter) = spa_pod_control_first(body);                        \\\n+         spa_pod_control_is_inside(body, size, iter);                        \\\n+         (iter) = spa_pod_control_next(iter))\n+\n+#define SPA_POD_SEQUENCE_FOREACH(seq, iter)                            \\\n+    SPA_POD_SEQUENCE_BODY_FOREACH(&(seq)->body, SPA_POD_BODY_SIZE(seq), iter)\n+\n+\n+static inline void *spa_pod_from_data(void *data, size_t maxsize, off_t offset, size_t size)\n+{\n+    void *pod;\n+    if (size < sizeof(struct spa_pod) || offset + size > maxsize)\n+        return NULL;\n+    pod = SPA_PTROFF(data, offset, void);\n+    if (SPA_POD_SIZE(pod) > size)\n+        return NULL;\n+    return pod;\n+}\n+\n+static inline int spa_pod_is_none(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_None);\n+}\n+\n+static inline int spa_pod_is_bool(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Bool && SPA_POD_BODY_SIZE(pod) >= sizeof(int32_t));\n+}\n+\n+static inline int spa_pod_get_bool(const struct spa_pod *pod, bool *value)\n+{\n+    if (!spa_pod_is_bool(pod))\n+        return -EINVAL;\n+    *value = !!SPA_POD_VALUE(struct spa_pod_bool, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_id(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Id && SPA_POD_BODY_SIZE(pod) >= sizeof(uint32_t));\n+}\n+\n+static inline int spa_pod_get_id(const struct spa_pod *pod, uint32_t *value)\n+{\n+    if (!spa_pod_is_id(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_id, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_int(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Int && SPA_POD_BODY_SIZE(pod) >= sizeof(int32_t));\n+}\n+\n+static inline int spa_pod_get_int(const struct spa_pod *pod, int32_t *value)\n+{\n+    if (!spa_pod_is_int(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_int, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_long(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Long && SPA_POD_BODY_SIZE(pod) >= sizeof(int64_t));\n+}\n+\n+static inline int spa_pod_get_long(const struct spa_pod *pod, int64_t *value)\n+{\n+    if (!spa_pod_is_long(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_long, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_float(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Float && SPA_POD_BODY_SIZE(pod) >= sizeof(float));\n+}\n+\n+static inline int spa_pod_get_float(const struct spa_pod *pod, float *value)\n+{\n+    if (!spa_pod_is_float(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_float, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_double(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Double && SPA_POD_BODY_SIZE(pod) >= sizeof(double));\n+}\n+\n+static inline int spa_pod_get_double(const struct spa_pod *pod, double *value)\n+{\n+    if (!spa_pod_is_double(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_double, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_string(const struct spa_pod *pod)\n+{\n+    const char *s = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_String &&\n+            SPA_POD_BODY_SIZE(pod) > 0 &&\n+            s[SPA_POD_BODY_SIZE(pod)-1] == '\\0');\n+}\n+\n+static inline int spa_pod_get_string(const struct spa_pod *pod, const char **value)\n+{\n+    if (!spa_pod_is_string(pod))\n+        return -EINVAL;\n+    *value = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_copy_string(const struct spa_pod *pod, size_t maxlen, char *dest)\n+{\n+    const char *s = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    if (!spa_pod_is_string(pod) || maxlen < 1)\n+        return -EINVAL;\n+    strncpy(dest, s, maxlen-1);\n+    dest[maxlen-1]= '\\0';\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_bytes(const struct spa_pod *pod)\n+{\n+    return SPA_POD_TYPE(pod) == SPA_TYPE_Bytes;\n+}\n+\n+static inline int spa_pod_get_bytes(const struct spa_pod *pod, const void **value, uint32_t *len)\n+{\n+    if (!spa_pod_is_bytes(pod))\n+        return -EINVAL;\n+    *value = (const void *)SPA_POD_CONTENTS(struct spa_pod_bytes, pod);\n+    *len = SPA_POD_BODY_SIZE(pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_pointer(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Pointer &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_pointer_body));\n+}\n+\n+static inline int spa_pod_get_pointer(const struct spa_pod *pod, uint32_t *type, const void **value)\n+{\n+    if (!spa_pod_is_pointer(pod))\n+        return -EINVAL;\n+    *type = ((struct spa_pod_pointer*)pod)->body.type;\n+    *value = ((struct spa_pod_pointer*)pod)->body.value;\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_fd(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Fd &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(int64_t));\n+}\n+\n+static inline int spa_pod_get_fd(const struct spa_pod *pod, int64_t *value)\n+{\n+    if (!spa_pod_is_fd(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_fd, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_rectangle(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Rectangle &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_rectangle));\n+}\n+\n+static inline int spa_pod_get_rectangle(const struct spa_pod *pod, struct spa_rectangle *value)\n+{\n+    if (!spa_pod_is_rectangle(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_rectangle, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_fraction(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Fraction &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_fraction));\n+}\n+\n+static inline int spa_pod_get_fraction(const struct spa_pod *pod, struct spa_fraction *value)\n+{\n+    spa_return_val_if_fail(spa_pod_is_fraction(pod), -EINVAL);\n+    *value = SPA_POD_VALUE(struct spa_pod_fraction, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_bitmap(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Bitmap &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(uint8_t));\n+}\n+\n+static inline int spa_pod_is_array(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Array &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_array_body));\n+}\n+\n+static inline void *spa_pod_get_array(const struct spa_pod *pod, uint32_t *n_values)\n+{\n+    spa_return_val_if_fail(spa_pod_is_array(pod), NULL);\n+    *n_values = SPA_POD_ARRAY_N_VALUES(pod);\n+    return SPA_POD_ARRAY_VALUES(pod);\n+}\n+\n+static inline uint32_t spa_pod_copy_array(const struct spa_pod *pod, uint32_t type,\n+        void *values, uint32_t max_values)\n+{\n+    uint32_t n_values;\n+    void *v = spa_pod_get_array(pod, &n_values);\n+    if (v == NULL || max_values == 0 || SPA_POD_ARRAY_VALUE_TYPE(pod) != type)\n+        return 0;\n+    n_values = SPA_MIN(n_values, max_values);\n+    memcpy(values, v, SPA_POD_ARRAY_VALUE_SIZE(pod) * n_values);\n+    return n_values;\n+}\n+\n+static inline int spa_pod_is_choice(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Choice &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_choice_body));\n+}\n+\n+static inline struct spa_pod *spa_pod_get_values(const struct spa_pod *pod, uint32_t *n_vals, uint32_t *choice)\n+{\n+    if (pod->type == SPA_TYPE_Choice) {\n+        *n_vals = SPA_POD_CHOICE_N_VALUES(pod);\n+        if ((*choice = SPA_POD_CHOICE_TYPE(pod)) == SPA_CHOICE_None)\n+            *n_vals = SPA_MIN(1u, SPA_POD_CHOICE_N_VALUES(pod));\n+        return (struct spa_pod*)SPA_POD_CHOICE_CHILD(pod);\n+    } else {\n+        *n_vals = 1;\n+        *choice = SPA_CHOICE_None;\n+        return (struct spa_pod*)pod;\n+    }\n+}\n+\n+static inline int spa_pod_is_struct(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Struct);\n+}\n+\n+static inline int spa_pod_is_object(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Object &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_object_body));\n+}\n+\n+static inline bool spa_pod_is_object_type(const struct spa_pod *pod, uint32_t type)\n+{\n+    return (pod && spa_pod_is_object(pod) && SPA_POD_OBJECT_TYPE(pod) == type);\n+}\n+\n+static inline bool spa_pod_is_object_id(const struct spa_pod *pod, uint32_t id)\n+{\n+    return (pod && spa_pod_is_object(pod) && SPA_POD_OBJECT_ID(pod) == id);\n+}\n+\n+static inline int spa_pod_is_sequence(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Sequence &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_sequence_body));\n+}\n+\n+static inline const struct spa_pod_prop *spa_pod_object_find_prop(const struct spa_pod_object *pod,\n+        const struct spa_pod_prop *start, uint32_t key)\n+{\n+    const struct spa_pod_prop *first, *res;\n+\n+    first = spa_pod_prop_first(&pod->body);\n+    start = start ? spa_pod_prop_next(start) : first;\n+\n+    for (res = start; spa_pod_prop_is_inside(&pod->body, pod->pod.size, res);\n+         res = spa_pod_prop_next(res)) {\n+        if (res->key == key)\n+            return res;\n+    }\n+    for (res = first; res != start; res = spa_pod_prop_next(res)) {\n+        if (res->key == key)\n+            return res;\n+    }\n+    return NULL;\n+}\n+\n+static inline const struct spa_pod_prop *spa_pod_find_prop(const struct spa_pod *pod,\n+        const struct spa_pod_prop *start, uint32_t key)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return NULL;\n+    return spa_pod_object_find_prop((const struct spa_pod_object *)pod, start, key);\n+}\n+\n+static inline int spa_pod_object_fixate(struct spa_pod_object *pod)\n+{\n+    struct spa_pod_prop *res;\n+    SPA_POD_OBJECT_FOREACH(pod, res) {\n+        if (res->value.type == SPA_TYPE_Choice &&\n+            !SPA_FLAG_IS_SET(res->flags, SPA_POD_PROP_FLAG_DONT_FIXATE))\n+            ((struct spa_pod_choice*)&res->value)->body.type = SPA_CHOICE_None;\n+    }\n+    return 0;\n+}\n+\n+static inline int spa_pod_fixate(struct spa_pod *pod)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    return spa_pod_object_fixate((struct spa_pod_object *)pod);\n+}\n+\n+static inline int spa_pod_object_is_fixated(const struct spa_pod_object *pod)\n+{\n+    struct spa_pod_prop *res;\n+    SPA_POD_OBJECT_FOREACH(pod, res) {\n+        if (res->value.type == SPA_TYPE_Choice &&\n+           ((struct spa_pod_choice*)&res->value)->body.type != SPA_CHOICE_None)\n+            return 0;\n+    }\n+    return 1;\n+}\n+\n+static inline int spa_pod_is_fixated(const struct spa_pod *pod)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    return spa_pod_object_is_fixated((const struct spa_pod_object *)pod);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/iter.h","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/* Spa *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_PARSER_H\n+#define SPA_POD_PARSER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <errno.h>\n+#include <stdarg.h>\n+\n+#include <spa\/pod\/iter.h>\n+#include <spa\/pod\/vararg.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_pod_parser_state {\n+    uint32_t offset;\n+    uint32_t flags;\n+    struct spa_pod_frame *frame;\n+};\n+\n+struct spa_pod_parser {\n+    const void *data;\n+    uint32_t size;\n+    uint32_t _padding;\n+    struct spa_pod_parser_state state;\n+};\n+\n+#define SPA_POD_PARSER_INIT(buffer,size)  ((struct spa_pod_parser){ (buffer), (size), 0, {} })\n+\n+static inline void spa_pod_parser_init(struct spa_pod_parser *parser,\n+                       const void *data, uint32_t size)\n+{\n+    *parser = SPA_POD_PARSER_INIT(data, size);\n+}\n+\n+static inline void spa_pod_parser_pod(struct spa_pod_parser *parser,\n+                      const struct spa_pod *pod)\n+{\n+    spa_pod_parser_init(parser, pod, SPA_POD_SIZE(pod));\n+}\n+\n+static inline void\n+spa_pod_parser_get_state(struct spa_pod_parser *parser, struct spa_pod_parser_state *state)\n+{\n+    *state = parser->state;\n+}\n+\n+static inline void\n+spa_pod_parser_reset(struct spa_pod_parser *parser, struct spa_pod_parser_state *state)\n+{\n+    parser->state = *state;\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_parser_deref(struct spa_pod_parser *parser, uint32_t offset, uint32_t size)\n+{\n+    \/* Cast to uint64_t to avoid wraparound.  Add 8 for the pod itself. *\/\n+    const uint64_t long_offset = (uint64_t)offset + 8;\n+    if (long_offset <= size && (offset & 7) == 0) {\n+        \/* Use void* because creating a misaligned pointer is undefined. *\/\n+        void *pod = SPA_PTROFF(parser->data, offset, void);\n+        \/*\n+         * Check that the pointer is aligned and that the size (rounded\n+         * to the next multiple of 8) is in bounds.\n+         *\/\n+        if (SPA_IS_ALIGNED(pod, __alignof__(struct spa_pod)) &&\n+            long_offset + SPA_ROUND_UP_N((uint64_t)SPA_POD_BODY_SIZE(pod), 8) <= size)\n+            return (struct spa_pod *)pod;\n+    }\n+    return NULL;\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_frame(struct spa_pod_parser *parser, struct spa_pod_frame *frame)\n+{\n+    return SPA_PTROFF(parser->data, frame->offset, struct spa_pod);\n+}\n+\n+static inline void spa_pod_parser_push(struct spa_pod_parser *parser,\n+              struct spa_pod_frame *frame, const struct spa_pod *pod, uint32_t offset)\n+{\n+    frame->pod = *pod;\n+    frame->offset = offset;\n+    frame->parent = parser->state.frame;\n+    frame->flags = parser->state.flags;\n+    parser->state.frame = frame;\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_current(struct spa_pod_parser *parser)\n+{\n+    struct spa_pod_frame *f = parser->state.frame;\n+    uint32_t size = f ? f->offset + SPA_POD_SIZE(&f->pod) : parser->size;\n+    return spa_pod_parser_deref(parser, parser->state.offset, size);\n+}\n+\n+static inline void spa_pod_parser_advance(struct spa_pod_parser *parser, const struct spa_pod *pod)\n+{\n+    parser->state.offset += SPA_ROUND_UP_N(SPA_POD_SIZE(pod), 8);\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_next(struct spa_pod_parser *parser)\n+{\n+    struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod)\n+        spa_pod_parser_advance(parser, pod);\n+    return pod;\n+}\n+\n+static inline int spa_pod_parser_pop(struct spa_pod_parser *parser,\n+              struct spa_pod_frame *frame)\n+{\n+    parser->state.frame = frame->parent;\n+    parser->state.offset = frame->offset + SPA_ROUND_UP_N(SPA_POD_SIZE(&frame->pod), 8);\n+    return 0;\n+}\n+\n+static inline int spa_pod_parser_get_bool(struct spa_pod_parser *parser, bool *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_bool(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_id(struct spa_pod_parser *parser, uint32_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_id(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_int(struct spa_pod_parser *parser, int32_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_int(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_long(struct spa_pod_parser *parser, int64_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_long(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_float(struct spa_pod_parser *parser, float *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_float(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_double(struct spa_pod_parser *parser, double *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_double(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_string(struct spa_pod_parser *parser, const char **value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_string(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_bytes(struct spa_pod_parser *parser, const void **value, uint32_t *len)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_bytes(pod, value, len)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_pointer(struct spa_pod_parser *parser, uint32_t *type, const void **value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_pointer(pod, type, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_fd(struct spa_pod_parser *parser, int64_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_fd(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_rectangle(struct spa_pod_parser *parser, struct spa_rectangle *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_rectangle(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_fraction(struct spa_pod_parser *parser, struct spa_fraction *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_fraction(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_pod(struct spa_pod_parser *parser, struct spa_pod **value)\n+{\n+    struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    *value = pod;\n+    spa_pod_parser_advance(parser, pod);\n+    return 0;\n+}\n+static inline int spa_pod_parser_push_struct(struct spa_pod_parser *parser,\n+        struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    if (!spa_pod_is_struct(pod))\n+        return -EINVAL;\n+    spa_pod_parser_push(parser, frame, pod, parser->state.offset);\n+    parser->state.offset += sizeof(struct spa_pod_struct);\n+    return 0;\n+}\n+\n+static inline int spa_pod_parser_push_object(struct spa_pod_parser *parser,\n+        struct spa_pod_frame *frame, uint32_t type, uint32_t *id)\n+{\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    if (type != SPA_POD_OBJECT_TYPE(pod))\n+        return -EPROTO;\n+    if (id != NULL)\n+        *id = SPA_POD_OBJECT_ID(pod);\n+    spa_pod_parser_push(parser, frame, pod, parser->state.offset);\n+    parser->state.offset = parser->size;\n+    return 0;\n+}\n+\n+static inline bool spa_pod_parser_can_collect(const struct spa_pod *pod, char type)\n+{\n+    if (pod == NULL)\n+        return false;\n+\n+    if (SPA_POD_TYPE(pod) == SPA_TYPE_Choice) {\n+        if (!spa_pod_is_choice(pod))\n+            return false;\n+        if (type == 'V')\n+            return true;\n+        if (SPA_POD_CHOICE_TYPE(pod) != SPA_CHOICE_None)\n+            return false;\n+        pod = SPA_POD_CHOICE_CHILD(pod);\n+    }\n+\n+    switch (type) {\n+    case 'P':\n+        return true;\n+    case 'b':\n+        return spa_pod_is_bool(pod);\n+    case 'I':\n+        return spa_pod_is_id(pod);\n+    case 'i':\n+        return spa_pod_is_int(pod);\n+    case 'l':\n+        return spa_pod_is_long(pod);\n+    case 'f':\n+        return spa_pod_is_float(pod);\n+    case 'd':\n+        return spa_pod_is_double(pod);\n+    case 's':\n+        return spa_pod_is_string(pod) || spa_pod_is_none(pod);\n+    case 'S':\n+        return spa_pod_is_string(pod);\n+    case 'y':\n+        return spa_pod_is_bytes(pod);\n+    case 'R':\n+        return spa_pod_is_rectangle(pod);\n+    case 'F':\n+        return spa_pod_is_fraction(pod);\n+    case 'B':\n+        return spa_pod_is_bitmap(pod);\n+    case 'a':\n+        return spa_pod_is_array(pod);\n+    case 'p':\n+        return spa_pod_is_pointer(pod);\n+    case 'h':\n+        return spa_pod_is_fd(pod);\n+    case 'T':\n+        return spa_pod_is_struct(pod) || spa_pod_is_none(pod);\n+    case 'O':\n+        return spa_pod_is_object(pod) || spa_pod_is_none(pod);\n+    case 'V':\n+    default:\n+        return false;\n+    }\n+}\n+\n+#define SPA_POD_PARSER_COLLECT(pod,_type,args)                        \\\n+do {                                            \\\n+    switch (_type) {                                \\\n+    case 'b':                                    \\\n+        *va_arg(args, bool*) = SPA_POD_VALUE(struct spa_pod_bool, pod);        \\\n+        break;                                    \\\n+    case 'I':                                    \\\n+    case 'i':                                    \\\n+        *va_arg(args, int32_t*) = SPA_POD_VALUE(struct spa_pod_int, pod);    \\\n+        break;                                    \\\n+    case 'l':                                    \\\n+        *va_arg(args, int64_t*) = SPA_POD_VALUE(struct spa_pod_long, pod);    \\\n+        break;                                    \\\n+    case 'f':                                    \\\n+        *va_arg(args, float*) = SPA_POD_VALUE(struct spa_pod_float, pod);    \\\n+        break;                                    \\\n+    case 'd':                                    \\\n+        *va_arg(args, double*) = SPA_POD_VALUE(struct spa_pod_double, pod);    \\\n+        break;                                    \\\n+    case 's':                                    \\\n+        *va_arg(args, char**) =                            \\\n+            ((pod) == NULL || (SPA_POD_TYPE(pod) == SPA_TYPE_None)        \\\n+                ? NULL                            \\\n+                : (char *)SPA_POD_CONTENTS(struct spa_pod_string, pod));    \\\n+        break;                                    \\\n+    case 'S':                                    \\\n+    {                                        \\\n+        char *dest = va_arg(args, char*);                    \\\n+        uint32_t maxlen = va_arg(args, uint32_t);                \\\n+        strncpy(dest, (char *)SPA_POD_CONTENTS(struct spa_pod_string, pod), maxlen-1);    \\\n+        dest[maxlen-1] = '\\0';                            \\\n+        break;                                    \\\n+    }                                        \\\n+    case 'y':                                    \\\n+        *(va_arg(args, void **)) = SPA_POD_CONTENTS(struct spa_pod_bytes, pod);    \\\n+        *(va_arg(args, uint32_t *)) = SPA_POD_BODY_SIZE(pod);            \\\n+        break;                                    \\\n+    case 'R':                                    \\\n+        *va_arg(args, struct spa_rectangle*) =                    \\\n+                SPA_POD_VALUE(struct spa_pod_rectangle, pod);        \\\n+        break;                                    \\\n+    case 'F':                                    \\\n+        *va_arg(args, struct spa_fraction*) =                    \\\n+                SPA_POD_VALUE(struct spa_pod_fraction, pod);        \\\n+        break;                                    \\\n+    case 'B':                                    \\\n+        *va_arg(args, uint32_t **) =                        \\\n+            (uint32_t *) SPA_POD_CONTENTS(struct spa_pod_bitmap, pod);    \\\n+        break;                                    \\\n+    case 'a':                                    \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_VALUE_SIZE(pod);        \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_VALUE_TYPE(pod);        \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_N_VALUES(pod);            \\\n+        *va_arg(args, void**) = SPA_POD_ARRAY_VALUES(pod);            \\\n+        break;                                    \\\n+    case 'p':                                    \\\n+    {                                        \\\n+        struct spa_pod_pointer_body *b =                    \\\n+                (struct spa_pod_pointer_body *) SPA_POD_BODY(pod);    \\\n+        *(va_arg(args, uint32_t *)) = b->type;                    \\\n+        *(va_arg(args, const void **)) = b->value;                \\\n+        break;                                    \\\n+    }                                        \\\n+    case 'h':                                    \\\n+        *va_arg(args, int64_t*) = SPA_POD_VALUE(struct spa_pod_fd, pod);    \\\n+        break;                                    \\\n+    case 'P':                                    \\\n+    case 'T':                                    \\\n+    case 'O':                                    \\\n+    case 'V':                                    \\\n+    {                                        \\\n+        const struct spa_pod **d = va_arg(args, const struct spa_pod**);    \\\n+        if (d)                                    \\\n+            *d = ((pod) == NULL || (SPA_POD_TYPE(pod) == SPA_TYPE_None)    \\\n+                ? NULL : (pod));                        \\\n+        break;                                    \\\n+    }                                        \\\n+    default:                                    \\\n+        break;                                    \\\n+    }                                        \\\n+} while(false)\n+\n+#define SPA_POD_PARSER_SKIP(_type,args)                            \\\n+do {                                            \\\n+    switch (_type) {                                \\\n+    case 'S':                                    \\\n+        va_arg(args, char*);                            \\\n+        va_arg(args, uint32_t);                            \\\n+        break;                                    \\\n+    case 'a':                                    \\\n+        va_arg(args, void*);                            \\\n+        va_arg(args, void*);                            \\\n+        SPA_FALLTHROUGH                             \\\n+    case 'p':                                    \\\n+    case 'y':                                    \\\n+        va_arg(args, void*);                            \\\n+        SPA_FALLTHROUGH                             \\\n+    case 'b':                                    \\\n+    case 'I':                                    \\\n+    case 'i':                                    \\\n+    case 'l':                                    \\\n+    case 'f':                                    \\\n+    case 'd':                                    \\\n+    case 's':                                    \\\n+    case 'R':                                    \\\n+    case 'F':                                    \\\n+    case 'B':                                    \\\n+    case 'h':                                    \\\n+    case 'V':                                    \\\n+    case 'P':                                    \\\n+    case 'T':                                    \\\n+    case 'O':                                    \\\n+        va_arg(args, void*);                            \\\n+        break;                                    \\\n+    }                                        \\\n+} while(false)\n+\n+static inline int spa_pod_parser_getv(struct spa_pod_parser *parser, va_list args)\n+{\n+    struct spa_pod_frame *f = parser->state.frame;\n+        uint32_t ftype = f ? f->pod.type : (uint32_t)SPA_TYPE_Struct;\n+    const struct spa_pod_prop *prop = NULL;\n+    int count = 0;\n+\n+    do {\n+        bool optional;\n+        const struct spa_pod *pod = NULL;\n+        const char *format;\n+\n+        if (ftype == SPA_TYPE_Object) {\n+            uint32_t key = va_arg(args, uint32_t);\n+            const struct spa_pod_object *object;\n+\n+            if (key == 0)\n+                break;\n+\n+            object = (const struct spa_pod_object *)spa_pod_parser_frame(parser, f);\n+            prop = spa_pod_object_find_prop(object, prop, key);\n+            pod = prop ? &prop->value : NULL;\n+        }\n+\n+        if ((format = va_arg(args, char *)) == NULL)\n+            break;\n+\n+        if (ftype == SPA_TYPE_Struct)\n+            pod = spa_pod_parser_next(parser);\n+\n+        if ((optional = (*format == '?')))\n+            format++;\n+\n+        if (!spa_pod_parser_can_collect(pod, *format)) {\n+            if (!optional) {\n+                if (pod == NULL)\n+                    return -ESRCH;\n+                else\n+                    return -EPROTO;\n+            }\n+            SPA_POD_PARSER_SKIP(*format, args);\n+        } else {\n+            if (pod->type == SPA_TYPE_Choice && *format != 'V')\n+                pod = SPA_POD_CHOICE_CHILD(pod);\n+\n+            SPA_POD_PARSER_COLLECT(pod, *format, args);\n+            count++;\n+        }\n+    } while (true);\n+\n+    return count;\n+}\n+\n+static inline int spa_pod_parser_get(struct spa_pod_parser *parser, ...)\n+{\n+    int res;\n+    va_list args;\n+\n+    va_start(args, parser);\n+    res = spa_pod_parser_getv(parser, args);\n+    va_end(args);\n+\n+    return res;\n+}\n+\n+#define SPA_POD_OPT_Bool(val)                \"?\" SPA_POD_Bool(val)\n+#define SPA_POD_OPT_Id(val)                \"?\" SPA_POD_Id(val)\n+#define SPA_POD_OPT_Int(val)                \"?\" SPA_POD_Int(val)\n+#define SPA_POD_OPT_Long(val)                \"?\" SPA_POD_Long(val)\n+#define SPA_POD_OPT_Float(val)                \"?\" SPA_POD_Float(val)\n+#define SPA_POD_OPT_Double(val)                \"?\" SPA_POD_Double(val)\n+#define SPA_POD_OPT_String(val)                \"?\" SPA_POD_String(val)\n+#define SPA_POD_OPT_Stringn(val,len)            \"?\" SPA_POD_Stringn(val,len)\n+#define SPA_POD_OPT_Bytes(val,len)            \"?\" SPA_POD_Bytes(val,len)\n+#define SPA_POD_OPT_Rectangle(val)            \"?\" SPA_POD_Rectangle(val)\n+#define SPA_POD_OPT_Fraction(val)            \"?\" SPA_POD_Fraction(val)\n+#define SPA_POD_OPT_Array(csize,ctype,n_vals,vals)    \"?\" SPA_POD_Array(csize,ctype,n_vals,vals)\n+#define SPA_POD_OPT_Pointer(type,val)            \"?\" SPA_POD_Pointer(type,val)\n+#define SPA_POD_OPT_Fd(val)                \"?\" SPA_POD_Fd(val)\n+#define SPA_POD_OPT_Pod(val)                \"?\" SPA_POD_Pod(val)\n+#define SPA_POD_OPT_PodObject(val)            \"?\" SPA_POD_PodObject(val)\n+#define SPA_POD_OPT_PodStruct(val)            \"?\" SPA_POD_PodStruct(val)\n+#define SPA_POD_OPT_PodChoice(val)            \"?\" SPA_POD_PodChoice(val)\n+\n+#define spa_pod_parser_get_object(p,type,id,...)                \\\n+({                                        \\\n+    struct spa_pod_frame _f;                        \\\n+    int _res;                                \\\n+    if ((_res = spa_pod_parser_push_object(p, &_f, type, id)) == 0) {    \\\n+        _res = spa_pod_parser_get(p,##__VA_ARGS__, 0);            \\\n+        spa_pod_parser_pop(p, &_f);                    \\\n+    }                                    \\\n+    _res;                                    \\\n+})\n+\n+#define spa_pod_parser_get_struct(p,...)                \\\n+({                                    \\\n+    struct spa_pod_frame _f;                    \\\n+    int _res;                            \\\n+    if ((_res = spa_pod_parser_push_struct(p, &_f)) == 0) {        \\\n+        _res = spa_pod_parser_get(p,##__VA_ARGS__, NULL);    \\\n+        spa_pod_parser_pop(p, &_f);                \\\n+    }                                \\\n+    _res;                            \\\n+})\n+\n+#define spa_pod_parse_object(pod,type,id,...)            \\\n+({                                \\\n+    struct spa_pod_parser _p;                \\\n+    spa_pod_parser_pod(&_p, pod);                \\\n+    spa_pod_parser_get_object(&_p,type,id,##__VA_ARGS__);    \\\n+})\n+\n+#define spa_pod_parse_struct(pod,...)                \\\n+({                                \\\n+    struct spa_pod_parser _p;                \\\n+    spa_pod_parser_pod(&_p, pod);                \\\n+    spa_pod_parser_get_struct(&_p,##__VA_ARGS__);        \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_PARSER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/parser.h","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_H\n+#define SPA_POD_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/type.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#define SPA_POD_BODY_SIZE(pod)            (((struct spa_pod*)(pod))->size)\n+#define SPA_POD_TYPE(pod)            (((struct spa_pod*)(pod))->type)\n+#define SPA_POD_SIZE(pod)            ((uint64_t)sizeof(struct spa_pod) + SPA_POD_BODY_SIZE(pod))\n+#define SPA_POD_CONTENTS_SIZE(type,pod)        (SPA_POD_SIZE(pod)-sizeof(type))\n+\n+#define SPA_POD_CONTENTS(type,pod)        SPA_PTROFF((pod),sizeof(type),void)\n+#define SPA_POD_CONTENTS_CONST(type,pod)    SPA_PTROFF((pod),sizeof(type),const void)\n+#define SPA_POD_BODY(pod)            SPA_PTROFF((pod),sizeof(struct spa_pod),void)\n+#define SPA_POD_BODY_CONST(pod)            SPA_PTROFF((pod),sizeof(struct spa_pod),const void)\n+\n+struct spa_pod {\n+    uint32_t size;        \/* size of the body *\/\n+    uint32_t type;        \/* a basic id of enum spa_type *\/\n+};\n+\n+#define SPA_POD_VALUE(type,pod)            (((type*)(pod))->value)\n+\n+struct spa_pod_bool {\n+    struct spa_pod pod;\n+    int32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_id {\n+    struct spa_pod pod;\n+    uint32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_int {\n+    struct spa_pod pod;\n+    int32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_long {\n+    struct spa_pod pod;\n+    int64_t value;\n+};\n+\n+struct spa_pod_float {\n+    struct spa_pod pod;\n+    float value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_double {\n+    struct spa_pod pod;\n+    double value;\n+};\n+\n+struct spa_pod_string {\n+    struct spa_pod pod;\n+    \/* value here *\/\n+};\n+\n+struct spa_pod_bytes {\n+    struct spa_pod pod;\n+    \/* value here *\/\n+};\n+\n+struct spa_pod_rectangle {\n+    struct spa_pod pod;\n+    struct spa_rectangle value;\n+};\n+\n+struct spa_pod_fraction {\n+    struct spa_pod pod;\n+    struct spa_fraction value;\n+};\n+\n+struct spa_pod_bitmap {\n+    struct spa_pod pod;\n+    \/* array of uint8_t follows with the bitmap *\/\n+};\n+\n+#define SPA_POD_ARRAY_CHILD(arr)    (&((struct spa_pod_array*)(arr))->body.child)\n+#define SPA_POD_ARRAY_VALUE_TYPE(arr)    (SPA_POD_TYPE(SPA_POD_ARRAY_CHILD(arr)))\n+#define SPA_POD_ARRAY_VALUE_SIZE(arr)    (SPA_POD_BODY_SIZE(SPA_POD_ARRAY_CHILD(arr)))\n+#define SPA_POD_ARRAY_N_VALUES(arr)    (SPA_POD_ARRAY_VALUE_SIZE(arr) ? ((SPA_POD_BODY_SIZE(arr) - sizeof(struct spa_pod_array_body)) \/ SPA_POD_ARRAY_VALUE_SIZE(arr)) : 0)\n+#define SPA_POD_ARRAY_VALUES(arr)    SPA_POD_CONTENTS(struct spa_pod_array, arr)\n+\n+struct spa_pod_array_body {\n+    struct spa_pod child;\n+    \/* array with elements of child.size follows *\/\n+};\n+\n+struct spa_pod_array {\n+    struct spa_pod pod;\n+    struct spa_pod_array_body body;\n+};\n+\n+#define SPA_POD_CHOICE_CHILD(choice)        (&((struct spa_pod_choice*)(choice))->body.child)\n+#define SPA_POD_CHOICE_TYPE(choice)        (((struct spa_pod_choice*)(choice))->body.type)\n+#define SPA_POD_CHOICE_FLAGS(choice)        (((struct spa_pod_choice*)(choice))->body.flags)\n+#define SPA_POD_CHOICE_VALUE_TYPE(choice)    (SPA_POD_TYPE(SPA_POD_CHOICE_CHILD(choice)))\n+#define SPA_POD_CHOICE_VALUE_SIZE(choice)    (SPA_POD_BODY_SIZE(SPA_POD_CHOICE_CHILD(choice)))\n+#define SPA_POD_CHOICE_N_VALUES(choice)        (SPA_POD_CHOICE_VALUE_SIZE(choice) ? ((SPA_POD_BODY_SIZE(choice) - sizeof(struct spa_pod_choice_body)) \/ SPA_POD_CHOICE_VALUE_SIZE(choice)) : 0)\n+#define SPA_POD_CHOICE_VALUES(choice)        (SPA_POD_CONTENTS(struct spa_pod_choice, choice))\n+\n+enum spa_choice_type {\n+    SPA_CHOICE_None,        \/**< no choice, first value is current *\/\n+    SPA_CHOICE_Range,        \/**< range: default, min, max *\/\n+    SPA_CHOICE_Step,        \/**< range with step: default, min, max, step *\/\n+    SPA_CHOICE_Enum,        \/**< list: default, alternative,...  *\/\n+    SPA_CHOICE_Flags,        \/**< flags: default, possible flags,... *\/\n+};\n+\n+struct spa_pod_choice_body {\n+    uint32_t type;            \/**< type of choice, one of enum spa_choice_type *\/\n+    uint32_t flags;            \/**< extra flags *\/\n+    struct spa_pod child;\n+    \/* array with elements of child.size follows. Note that there might be more\n+     * elements than required by \\a type, which should be ignored. *\/\n+};\n+\n+struct spa_pod_choice {\n+    struct spa_pod pod;\n+    struct spa_pod_choice_body body;\n+};\n+\n+struct spa_pod_struct {\n+    struct spa_pod pod;\n+    \/* one or more spa_pod follow *\/\n+};\n+\n+#define SPA_POD_OBJECT_TYPE(obj)    (((struct spa_pod_object*)(obj))->body.type)\n+#define SPA_POD_OBJECT_ID(obj)        (((struct spa_pod_object*)(obj))->body.id)\n+\n+struct spa_pod_object_body {\n+    uint32_t type;        \/**< one of enum spa_type *\/\n+    uint32_t id;        \/**< id of the object, depends on the object type *\/\n+    \/* contents follow, series of spa_pod_prop *\/\n+};\n+\n+struct spa_pod_object {\n+    struct spa_pod pod;\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_pod_pointer_body {\n+    uint32_t type;        \/**< pointer id, one of enum spa_type *\/\n+    uint32_t _padding;\n+    const void *value;\n+};\n+\n+struct spa_pod_pointer {\n+    struct spa_pod pod;\n+    struct spa_pod_pointer_body body;\n+};\n+\n+struct spa_pod_fd {\n+    struct spa_pod pod;\n+    int64_t value;\n+};\n+\n+#define SPA_POD_PROP_SIZE(prop)        (sizeof(struct spa_pod_prop) + (prop)->value.size)\n+\n+\/* props can be inside an object *\/\n+struct spa_pod_prop {\n+    uint32_t key;            \/**< key of property, list of valid keys depends on the\n+                      *  object type *\/\n+#define SPA_POD_PROP_FLAG_READONLY    (1u<<0)        \/**< is read-only *\/\n+#define SPA_POD_PROP_FLAG_HARDWARE    (1u<<1)        \/**< some sort of hardware parameter *\/\n+#define SPA_POD_PROP_FLAG_HINT_DICT    (1u<<2)        \/**< contains a dictionary struct as\n+                             *   (Struct(\n+                             *      Int : n_items,\n+                             *      (String : key,\n+                             *       String : value)*)) *\/\n+#define SPA_POD_PROP_FLAG_MANDATORY    (1u<<3)        \/**< is mandatory *\/\n+#define SPA_POD_PROP_FLAG_DONT_FIXATE    (1u<<4)        \/**< choices need no fixation *\/\n+    uint32_t flags;            \/**< flags for property *\/\n+    struct spa_pod value;\n+    \/* value follows *\/\n+};\n+\n+#define SPA_POD_CONTROL_SIZE(ev)    (sizeof(struct spa_pod_control) + (ev)->value.size)\n+\n+\/* controls can be inside a sequence and mark timed values *\/\n+struct spa_pod_control {\n+    uint32_t offset;    \/**< media offset *\/\n+    uint32_t type;        \/**< type of control, enum spa_control_type *\/\n+    struct spa_pod value;    \/**< control value, depends on type *\/\n+    \/* value contents follow *\/\n+};\n+\n+struct spa_pod_sequence_body {\n+    uint32_t unit;\n+    uint32_t pad;\n+    \/* series of struct spa_pod_control follows *\/\n+};\n+\n+\/** a sequence of timed controls *\/\n+struct spa_pod_sequence {\n+    struct spa_pod pod;\n+    struct spa_pod_sequence_body body;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/pod.h","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_VARARG_H\n+#define SPA_POD_VARARG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#define SPA_POD_Prop(key,...)                \\\n+    key, ##__VA_ARGS__\n+\n+#define SPA_POD_Control(offset,type,...)        \\\n+    offset, type, ##__VA_ARGS__\n+\n+#define SPA_CHOICE_RANGE(def,min,max)            3,(def),(min),(max)\n+#define SPA_CHOICE_STEP(def,min,max,step)        4,(def),(min),(max),(step)\n+#define SPA_CHOICE_ENUM(n_vals,...)            (n_vals),##__VA_ARGS__\n+#define SPA_CHOICE_FLAGS(flags)                1, (flags)\n+#define SPA_CHOICE_BOOL(def)                3,(def),(def),!(def)\n+\n+#define SPA_POD_Bool(val)                \"b\", val\n+#define SPA_POD_CHOICE_Bool(def)            \"?eb\", SPA_CHOICE_BOOL(def)\n+\n+#define SPA_POD_Id(val)                    \"I\", val\n+#define SPA_POD_CHOICE_ENUM_Id(n_vals,...)        \"?eI\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+\n+#define SPA_POD_Int(val)                \"i\", val\n+#define SPA_POD_CHOICE_ENUM_Int(n_vals,...)        \"?ei\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Int(def,min,max)        \"?ri\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Int(def,min,max,step)    \"?si\", SPA_CHOICE_STEP(def, min, max, step)\n+#define SPA_POD_CHOICE_FLAGS_Int(flags)            \"?fi\", SPA_CHOICE_FLAGS(flags)\n+\n+#define SPA_POD_Long(val)                \"l\", val\n+#define SPA_POD_CHOICE_ENUM_Long(n_vals,...)        \"?el\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Long(def,min,max)        \"?rl\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Long(def,min,max,step)    \"?sl\", SPA_CHOICE_STEP(def, min, max, step)\n+#define SPA_POD_CHOICE_FLAGS_Long(flags)        \"?fl\", SPA_CHOICE_FLAGS(flags)\n+\n+#define SPA_POD_Float(val)                \"f\", val\n+#define SPA_POD_CHOICE_ENUM_Float(n_vals,...)        \"?ef\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Float(def,min,max)        \"?rf\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Float(def,min,max,step)    \"?sf\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_Double(val)                \"d\", val\n+#define SPA_POD_CHOICE_ENUM_Double(n_vals,...)        \"?ed\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Double(def,min,max)    \"?rd\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Double(def,min,max,step)    \"?sd\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_String(val)                \"s\",val\n+#define SPA_POD_Stringn(val,len)            \"S\",val,len\n+\n+#define SPA_POD_Bytes(val,len)                \"y\",val,len\n+\n+#define SPA_POD_Rectangle(val)                \"R\",val\n+#define SPA_POD_CHOICE_ENUM_Rectangle(n_vals,...)    \"?eR\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Rectangle(def,min,max)    \"?rR\", SPA_CHOICE_RANGE((def),(min),(max))\n+#define SPA_POD_CHOICE_STEP_Rectangle(def,min,max,step)    \"?sR\", SPA_CHOICE_STEP((def),(min),(max),(step))\n+\n+#define SPA_POD_Fraction(val)                \"F\",val\n+#define SPA_POD_CHOICE_ENUM_Fraction(n_vals,...)    \"?eF\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Fraction(def,min,max)    \"?rF\", SPA_CHOICE_RANGE((def),(min),(max))\n+#define SPA_POD_CHOICE_STEP_Fraction(def,min,max,step)    \"?sF\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_Array(csize,ctype,n_vals,vals)        \"a\", csize,ctype,n_vals,vals\n+#define SPA_POD_Pointer(type,val)            \"p\", type,val\n+#define SPA_POD_Fd(val)                    \"h\", val\n+#define SPA_POD_None()                    \"P\", NULL\n+#define SPA_POD_Pod(val)                \"P\", val\n+#define SPA_POD_PodObject(val)                \"O\", val\n+#define SPA_POD_PodStruct(val)                \"T\", val\n+#define SPA_POD_PodChoice(val)                \"V\", val\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_VARARG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/vararg.h","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_LOOP_H\n+#define SPA_LOOP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+#include <spa\/support\/system.h>\n+\n+\/** \\defgroup spa_loop Loop\n+ * Event loop interface\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_loop\n+ * \\{\n+ *\/\n+\n+#define SPA_TYPE_INTERFACE_Loop        SPA_TYPE_INFO_INTERFACE_BASE \"Loop\"\n+#define SPA_TYPE_INTERFACE_DataLoop    SPA_TYPE_INFO_INTERFACE_BASE \"DataLoop\"\n+#define SPA_VERSION_LOOP        0\n+struct spa_loop { struct spa_interface iface; };\n+\n+#define SPA_TYPE_INTERFACE_LoopControl    SPA_TYPE_INFO_INTERFACE_BASE \"LoopControl\"\n+#define SPA_VERSION_LOOP_CONTROL    1\n+struct spa_loop_control { struct spa_interface iface; };\n+\n+#define SPA_TYPE_INTERFACE_LoopUtils    SPA_TYPE_INFO_INTERFACE_BASE \"LoopUtils\"\n+#define SPA_VERSION_LOOP_UTILS        0\n+struct spa_loop_utils { struct spa_interface iface; };\n+\n+struct spa_source;\n+\n+typedef void (*spa_source_func_t) (struct spa_source *source);\n+\n+struct spa_source {\n+    struct spa_loop *loop;\n+    spa_source_func_t func;\n+    void *data;\n+    int fd;\n+    uint32_t mask;\n+    uint32_t rmask;\n+    \/* private data for the loop implementer *\/\n+    void *priv;\n+};\n+\n+typedef int (*spa_invoke_func_t) (struct spa_loop *loop,\n+                  bool async,\n+                  uint32_t seq,\n+                  const void *data,\n+                  size_t size,\n+                  void *user_data);\n+\n+\/**\n+ * Register sources and work items to an event loop\n+ *\/\n+struct spa_loop_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_METHODS    0\n+    uint32_t version;\n+\n+    \/** add a source to the loop *\/\n+    int (*add_source) (void *object,\n+               struct spa_source *source);\n+\n+    \/** update the source io mask *\/\n+    int (*update_source) (void *object,\n+            struct spa_source *source);\n+\n+    \/** remove a source from the loop *\/\n+    int (*remove_source) (void *object,\n+            struct spa_source *source);\n+\n+    \/** invoke a function in the context of this loop *\/\n+    int (*invoke) (void *object,\n+               spa_invoke_func_t func,\n+               uint32_t seq,\n+               const void *data,\n+               size_t size,\n+               bool block,\n+               void *user_data);\n+};\n+\n+#define spa_loop_method(o,method,version,...)                \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_methods, _res,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define spa_loop_add_source(l,...)    spa_loop_method(l,add_source,0,##__VA_ARGS__)\n+#define spa_loop_update_source(l,...)    spa_loop_method(l,update_source,0,##__VA_ARGS__)\n+#define spa_loop_remove_source(l,...)    spa_loop_method(l,remove_source,0,##__VA_ARGS__)\n+#define spa_loop_invoke(l,...)        spa_loop_method(l,invoke,0,##__VA_ARGS__)\n+\n+\n+\/** Control hooks. These hooks can't be removed from their\n+ *  callbacks and must be removed from a safe place (when the loop\n+ *  is not running or when it is locked). *\/\n+struct spa_loop_control_hooks {\n+#define SPA_VERSION_LOOP_CONTROL_HOOKS    0\n+    uint32_t version;\n+    \/** Executed right before waiting for events. It is typically used to\n+     * release locks. *\/\n+    void (*before) (void *data);\n+    \/** Executed right after waiting for events. It is typically used to\n+     * reacquire locks. *\/\n+    void (*after) (void *data);\n+};\n+\n+#define spa_loop_control_hook_before(l)                            \\\n+({                                            \\\n+    struct spa_hook_list *_l = l;                            \\\n+    struct spa_hook *_h;                                \\\n+    spa_list_for_each_reverse(_h, &_l->list, link)                    \\\n+        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, before, 0);    \\\n+})\n+\n+#define spa_loop_control_hook_after(l)                            \\\n+({                                            \\\n+    struct spa_hook_list *_l = l;                            \\\n+    struct spa_hook *_h;                                \\\n+    spa_list_for_each(_h, &_l->list, link)                        \\\n+        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, after, 0);    \\\n+})\n+\n+\/**\n+ * Control an event loop\n+ *\/\n+struct spa_loop_control_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_CONTROL_METHODS    1\n+    uint32_t version;\n+\n+    int (*get_fd) (void *object);\n+\n+    \/** Add a hook\n+     * \\param ctrl the control to change\n+     * \\param hooks the hooks to add\n+     *\n+     * Adds hooks to the loop controlled by \\a ctrl.\n+     *\/\n+    void (*add_hook) (void *object,\n+              struct spa_hook *hook,\n+              const struct spa_loop_control_hooks *hooks,\n+              void *data);\n+\n+    \/** Enter a loop\n+     * \\param ctrl the control\n+     *\n+     * Start an iteration of the loop. This function should be called\n+     * before calling iterate and is typically used to capture the thread\n+     * that this loop will run in.\n+     *\/\n+    void (*enter) (void *object);\n+    \/** Leave a loop\n+     * \\param ctrl the control\n+     *\n+     * Ends the iteration of a loop. This should be called after calling\n+     * iterate.\n+     *\/\n+    void (*leave) (void *object);\n+\n+    \/** Perform one iteration of the loop.\n+     * \\param ctrl the control\n+     * \\param timeout an optional timeout in milliseconds.\n+     *    0 for no timeout, -1 for infinite timeout.\n+     *\n+     * This function will block\n+     * up to \\a timeout milliseconds and then dispatch the fds with activity.\n+     * The number of dispatched fds is returned.\n+     *\/\n+    int (*iterate) (void *object, int timeout);\n+\n+    \/** Check context of the loop\n+     * \\param ctrl the control\n+     *\n+     * This function will check if the current thread is currently the\n+     * one that did the enter call. Since version 1:1.\n+     *\n+     * returns 1 on success, 0 or negative errno value on error.\n+     *\/\n+    int (*check) (void *object);\n+};\n+\n+#define spa_loop_control_method_v(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_loop_control *_o = o;                \\\n+    spa_interface_call(&_o->iface,                    \\\n+            struct spa_loop_control_methods,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+\n+#define spa_loop_control_method_r(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop_control *_o = o;                \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_control_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define spa_loop_control_get_fd(l)        spa_loop_control_method_r(l,get_fd,0)\n+#define spa_loop_control_add_hook(l,...)    spa_loop_control_method_v(l,add_hook,0,__VA_ARGS__)\n+#define spa_loop_control_enter(l)        spa_loop_control_method_v(l,enter,0)\n+#define spa_loop_control_leave(l)        spa_loop_control_method_v(l,leave,0)\n+#define spa_loop_control_iterate(l,...)        spa_loop_control_method_r(l,iterate,0,__VA_ARGS__)\n+#define spa_loop_control_check(l)        spa_loop_control_method_r(l,check,1)\n+\n+typedef void (*spa_source_io_func_t) (void *data, int fd, uint32_t mask);\n+typedef void (*spa_source_idle_func_t) (void *data);\n+typedef void (*spa_source_event_func_t) (void *data, uint64_t count);\n+typedef void (*spa_source_timer_func_t) (void *data, uint64_t expirations);\n+typedef void (*spa_source_signal_func_t) (void *data, int signal_number);\n+\n+\/**\n+ * Create sources for an event loop\n+ *\/\n+struct spa_loop_utils_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_UTILS_METHODS    0\n+    uint32_t version;\n+\n+    struct spa_source *(*add_io) (void *object,\n+                      int fd,\n+                      uint32_t mask,\n+                      bool close,\n+                      spa_source_io_func_t func, void *data);\n+\n+    int (*update_io) (void *object, struct spa_source *source, uint32_t mask);\n+\n+    struct spa_source *(*add_idle) (void *object,\n+                    bool enabled,\n+                    spa_source_idle_func_t func, void *data);\n+    int (*enable_idle) (void *object, struct spa_source *source, bool enabled);\n+\n+    struct spa_source *(*add_event) (void *object,\n+                     spa_source_event_func_t func, void *data);\n+    int (*signal_event) (void *object, struct spa_source *source);\n+\n+    struct spa_source *(*add_timer) (void *object,\n+                     spa_source_timer_func_t func, void *data);\n+    int (*update_timer) (void *object,\n+                 struct spa_source *source,\n+                 struct timespec *value,\n+                 struct timespec *interval,\n+                 bool absolute);\n+    struct spa_source *(*add_signal) (void *object,\n+                      int signal_number,\n+                      spa_source_signal_func_t func, void *data);\n+\n+    \/** destroy a source allocated with this interface. This function\n+     * should only be called when the loop is not running or from the\n+     * context of the running loop *\/\n+    void (*destroy_source) (void *object, struct spa_source *source);\n+};\n+\n+#define spa_loop_utils_method_v(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call(&_o->iface,                    \\\n+            struct spa_loop_utils_methods,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+\n+#define spa_loop_utils_method_r(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_utils_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+#define spa_loop_utils_method_s(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_source *_res = NULL;                    \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_utils_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\n+#define spa_loop_utils_add_io(l,...)        spa_loop_utils_method_s(l,add_io,0,__VA_ARGS__)\n+#define spa_loop_utils_update_io(l,...)        spa_loop_utils_method_r(l,update_io,0,__VA_ARGS__)\n+#define spa_loop_utils_add_idle(l,...)        spa_loop_utils_method_s(l,add_idle,0,__VA_ARGS__)\n+#define spa_loop_utils_enable_idle(l,...)    spa_loop_utils_method_r(l,enable_idle,0,__VA_ARGS__)\n+#define spa_loop_utils_add_event(l,...)        spa_loop_utils_method_s(l,add_event,0,__VA_ARGS__)\n+#define spa_loop_utils_signal_event(l,...)    spa_loop_utils_method_r(l,signal_event,0,__VA_ARGS__)\n+#define spa_loop_utils_add_timer(l,...)        spa_loop_utils_method_s(l,add_timer,0,__VA_ARGS__)\n+#define spa_loop_utils_update_timer(l,...)    spa_loop_utils_method_r(l,update_timer,0,__VA_ARGS__)\n+#define spa_loop_utils_add_signal(l,...)    spa_loop_utils_method_s(l,add_signal,0,__VA_ARGS__)\n+#define spa_loop_utils_destroy_source(l,...)    spa_loop_utils_method_v(l,destroy_source,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_LOOP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/support\/loop.h","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_SYSTEM_H\n+#define SPA_SYSTEM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct itimerspec;\n+\n+#include <time.h>\n+#include <sys\/types.h>\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup spa_system System\n+ * I\/O, clock, polling, timer, and signal interfaces\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_system\n+ * \\{\n+ *\/\n+\n+\/**\n+ * a collection of core system functions\n+ *\/\n+#define SPA_TYPE_INTERFACE_System    SPA_TYPE_INFO_INTERFACE_BASE \"System\"\n+#define SPA_TYPE_INTERFACE_DataSystem    SPA_TYPE_INFO_INTERFACE_BASE \"DataSystem\"\n+\n+#define SPA_VERSION_SYSTEM        0\n+struct spa_system { struct spa_interface iface; };\n+\n+\/* IO events *\/\n+#define SPA_IO_IN    (1 << 0)\n+#define SPA_IO_OUT    (1 << 2)\n+#define SPA_IO_ERR    (1 << 3)\n+#define SPA_IO_HUP    (1 << 4)\n+\n+\/* flags *\/\n+#define SPA_FD_CLOEXEC            (1<<0)\n+#define SPA_FD_NONBLOCK            (1<<1)\n+#define SPA_FD_EVENT_SEMAPHORE        (1<<2)\n+#define SPA_FD_TIMER_ABSTIME        (1<<3)\n+#define SPA_FD_TIMER_CANCEL_ON_SET    (1<<4)\n+\n+struct spa_poll_event {\n+    uint32_t events;\n+    void *data;\n+};\n+\n+struct spa_system_methods {\n+#define SPA_VERSION_SYSTEM_METHODS    0\n+    uint32_t version;\n+\n+    \/* read\/write\/ioctl *\/\n+    ssize_t (*read) (void *object, int fd, void *buf, size_t count);\n+    ssize_t (*write) (void *object, int fd, const void *buf, size_t count);\n+    int (*ioctl) (void *object, int fd, unsigned long request, ...);\n+    int (*close) (void *object, int fd);\n+\n+    \/* clock *\/\n+    int (*clock_gettime) (void *object,\n+            int clockid, struct timespec *value);\n+    int (*clock_getres) (void *object,\n+            int clockid, struct timespec *res);\n+\n+    \/* poll *\/\n+    int (*pollfd_create) (void *object, int flags);\n+    int (*pollfd_add) (void *object, int pfd, int fd, uint32_t events, void *data);\n+    int (*pollfd_mod) (void *object, int pfd, int fd, uint32_t events, void *data);\n+    int (*pollfd_del) (void *object, int pfd, int fd);\n+    int (*pollfd_wait) (void *object, int pfd,\n+            struct spa_poll_event *ev, int n_ev, int timeout);\n+\n+    \/* timers *\/\n+    int (*timerfd_create) (void *object, int clockid, int flags);\n+    int (*timerfd_settime) (void *object,\n+            int fd, int flags,\n+            const struct itimerspec *new_value,\n+            struct itimerspec *old_value);\n+    int (*timerfd_gettime) (void *object,\n+            int fd, struct itimerspec *curr_value);\n+    int (*timerfd_read) (void *object, int fd, uint64_t *expirations);\n+\n+    \/* events *\/\n+    int (*eventfd_create) (void *object, int flags);\n+    int (*eventfd_write) (void *object, int fd, uint64_t count);\n+    int (*eventfd_read) (void *object, int fd, uint64_t *count);\n+\n+    \/* signals *\/\n+    int (*signalfd_create) (void *object, int signal, int flags);\n+    int (*signalfd_read) (void *object, int fd, int *signal);\n+};\n+\n+#define spa_system_method_r(o,method,version,...)            \\\n+({                                    \\\n+    volatile int _res = -ENOTSUP;                    \\\n+    struct spa_system *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_system_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\n+#define spa_system_read(s,...)            spa_system_method_r(s,read,0,__VA_ARGS__)\n+#define spa_system_write(s,...)            spa_system_method_r(s,write,0,__VA_ARGS__)\n+#define spa_system_ioctl(s,...)            spa_system_method_r(s,ioctl,0,__VA_ARGS__)\n+#define spa_system_close(s,...)            spa_system_method_r(s,close,0,__VA_ARGS__)\n+\n+#define spa_system_clock_gettime(s,...)        spa_system_method_r(s,clock_gettime,0,__VA_ARGS__)\n+#define spa_system_clock_getres(s,...)        spa_system_method_r(s,clock_getres,0,__VA_ARGS__)\n+\n+#define spa_system_pollfd_create(s,...)        spa_system_method_r(s,pollfd_create,0,__VA_ARGS__)\n+#define spa_system_pollfd_add(s,...)        spa_system_method_r(s,pollfd_add,0,__VA_ARGS__)\n+#define spa_system_pollfd_mod(s,...)        spa_system_method_r(s,pollfd_mod,0,__VA_ARGS__)\n+#define spa_system_pollfd_del(s,...)        spa_system_method_r(s,pollfd_del,0,__VA_ARGS__)\n+#define spa_system_pollfd_wait(s,...)        spa_system_method_r(s,pollfd_wait,0,__VA_ARGS__)\n+\n+#define spa_system_timerfd_create(s,...)    spa_system_method_r(s,timerfd_create,0,__VA_ARGS__)\n+#define spa_system_timerfd_settime(s,...)    spa_system_method_r(s,timerfd_settime,0,__VA_ARGS__)\n+#define spa_system_timerfd_gettime(s,...)    spa_system_method_r(s,timerfd_gettime,0,__VA_ARGS__)\n+#define spa_system_timerfd_read(s,...)        spa_system_method_r(s,timerfd_read,0,__VA_ARGS__)\n+\n+#define spa_system_eventfd_create(s,...)    spa_system_method_r(s,eventfd_create,0,__VA_ARGS__)\n+#define spa_system_eventfd_write(s,...)        spa_system_method_r(s,eventfd_write,0,__VA_ARGS__)\n+#define spa_system_eventfd_read(s,...)        spa_system_method_r(s,eventfd_read,0,__VA_ARGS__)\n+\n+#define spa_system_signalfd_create(s,...)    spa_system_method_r(s,signalfd_create,0,__VA_ARGS__)\n+#define spa_system_signalfd_read(s,...)        spa_system_method_r(s,signalfd_read,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_SYSTEM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/support\/system.h","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,382 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_UTILS_DEFS_H\n+#define SPA_UTILS_DEFS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+# if __cplusplus >= 201103L\n+#  define SPA_STATIC_ASSERT_IMPL(expr, msg, ...) static_assert(expr, msg)\n+# endif\n+#else\n+# include <stdbool.h>\n+# if __STDC_VERSION__ >= 201112L\n+#  define SPA_STATIC_ASSERT_IMPL(expr, msg, ...) _Static_assert(expr, msg)\n+# endif\n+#endif\n+#ifndef SPA_STATIC_ASSERT_IMPL\n+#define SPA_STATIC_ASSERT_IMPL(expr, ...) \\\n+    ((void)sizeof(struct { int spa_static_assertion_failed : 2 * !!(expr) - 1; }))\n+#endif\n+\n+#define SPA_STATIC_ASSERT(expr, ...) SPA_STATIC_ASSERT_IMPL(expr, ## __VA_ARGS__, \"`\" #expr \"` evaluated to false\")\n+\n+#include <inttypes.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+\/**\n+ * \\defgroup spa_utils_defs Miscellaneous\n+ * Helper macros and functions\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_utils_defs\n+ * \\{\n+ *\/\n+\n+\/**\n+ * SPA_FALLTHROUGH is an annotation to suppress compiler warnings about switch\n+ * cases that fall through without a break or return statement. SPA_FALLTHROUGH\n+ * is only needed on cases that have code:\n+ *\n+ * switch (foo) {\n+ *   case 1: \/\/ These cases have no code. No fallthrough annotations are needed.\n+ *   case 2:\n+ *   case 3:\n+ *     foo = 4; \/\/ This case has code, so a fallthrough annotation is needed:\n+ *     SPA_FALLTHROUGH;\n+ *   default:\n+ *     return foo;\n+ * }\n+ *\/\n+#if defined(__clang__) && defined(__cplusplus) && __cplusplus >= 201103L\n+   \/* clang's fallthrough annotations are only available starting in C++11. *\/\n+#  define SPA_FALLTHROUGH [[clang::fallthrough]];\n+#elif __GNUC__ >= 7 || __clang_major__ >= 10\n+#  define SPA_FALLTHROUGH __attribute__ ((fallthrough));\n+#else\n+#  define SPA_FALLTHROUGH \/* FALLTHROUGH *\/\n+#endif\n+\n+#define SPA_FLAG_MASK(field,mask,flag)    (((field) & (mask)) == (flag))\n+#define SPA_FLAG_IS_SET(field,flag)    SPA_FLAG_MASK(field, flag, flag)\n+\n+#define SPA_FLAG_SET(field,flag)    ((field) |= (flag))\n+#define SPA_FLAG_CLEAR(field, flag)                    \\\n+({                                    \\\n+    SPA_STATIC_ASSERT(__builtin_constant_p(flag) ?            \\\n+                  (__typeof__(flag))(__typeof__(field))(__typeof__(flag))(flag) == (flag) : \\\n+              sizeof(field) >= sizeof(flag),            \\\n+            \"truncation problem when masking \" #field    \\\n+            \" with ~\" #flag);                \\\n+    ((field) &= ~(__typeof__(field))(flag));            \\\n+})\n+#define SPA_FLAG_UPDATE(field,flag,val)    ((val) ? SPA_FLAG_SET((field),(flag)) : SPA_FLAG_CLEAR((field),(flag)))\n+\n+enum spa_direction {\n+    SPA_DIRECTION_INPUT = 0,\n+    SPA_DIRECTION_OUTPUT = 1,\n+};\n+\n+#define SPA_DIRECTION_REVERSE(d)    ((d) ^ 1)\n+\n+#define SPA_RECTANGLE(width,height) ((struct spa_rectangle){ (width), (height) })\n+struct spa_rectangle {\n+    uint32_t width;\n+    uint32_t height;\n+};\n+\n+#define SPA_POINT(x,y) ((struct spa_point){ (x), (y) })\n+struct spa_point {\n+    int32_t x;\n+    int32_t y;\n+};\n+\n+#define SPA_REGION(x,y,width,height) ((struct spa_region){ SPA_POINT(x,y), SPA_RECTANGLE(width,height) })\n+struct spa_region {\n+    struct spa_point position;\n+    struct spa_rectangle size;\n+};\n+\n+#define SPA_FRACTION(num,denom) ((struct spa_fraction){ (num), (denom) })\n+struct spa_fraction {\n+    uint32_t num;\n+    uint32_t denom;\n+};\n+\n+#define SPA_N_ELEMENTS(arr)  (sizeof(arr) \/ sizeof((arr)[0]))\n+\/**\n+ * Array iterator macro. Usage:\n+ * ```c\n+ * struct foo array[16];\n+ * struct foo *f;\n+ * SPA_FOR_EACH_ELEMENT(array, f) {\n+ *    f->bar = baz;\n+ * }\n+ * ```\n+ *\/\n+#define SPA_FOR_EACH_ELEMENT(arr, ptr) \\\n+    for ((ptr) = arr; (void*)(ptr) < SPA_PTROFF(arr, sizeof(arr), void); (ptr)++)\n+\n+#define SPA_FOR_EACH_ELEMENT_VAR(arr, var) \\\n+    for (__typeof__((arr)[0])* var = arr; (void*)(var) < SPA_PTROFF(arr, sizeof(arr), void); (var)++)\n+\n+#define SPA_ABS(a)            \\\n+({                    \\\n+    __typeof__(a) _a = (a);        \\\n+    SPA_LIKELY(_a >= 0) ? _a : -_a;    \\\n+})\n+#define SPA_MIN(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _min_a = (a);            \\\n+    __typeof__(b) _min_b = (b);            \\\n+    SPA_LIKELY(_min_a <= _min_b) ? _min_a : _min_b;    \\\n+})\n+#define SPA_MAX(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _max_a = (a);            \\\n+    __typeof__(b) _max_b = (b);            \\\n+    SPA_LIKELY(_max_a >= _max_b) ? _max_a : _max_b;    \\\n+})\n+#define SPA_CLAMP(v,low,high)                \\\n+({                            \\\n+    __typeof__(v) _v = (v);                \\\n+    __typeof__(low) _low = (low);            \\\n+    __typeof__(high) _high = (high);        \\\n+    SPA_MIN(SPA_MAX(_v, _low), _high);        \\\n+})\n+\n+#define SPA_CLAMPF(v,low,high)                \\\n+({                            \\\n+    fminf(fmaxf(v, low), high);            \\\n+})\n+\n+\n+#define SPA_SWAP(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _t = (a);                \\\n+    (a) = b; (b) = _t;                \\\n+})\n+\n+#define SPA_TYPECHECK(type,x)        \\\n+({    type _dummy;            \\\n+    typeof(x) _dummy2;        \\\n+    (void)(&_dummy == &_dummy2);    \\\n+    x;                \\\n+})\n+\n+\/**\n+ * Return the address (buffer + offset) as pointer of \\a type\n+ *\/\n+#define SPA_PTROFF(ptr_,offset_,type_) ((type_*)((uintptr_t)(ptr_) + (ptrdiff_t)(offset_)))\n+#define SPA_PTROFF_ALIGN(ptr_,offset_,alignment_,type_) \\\n+   SPA_PTR_ALIGN(SPA_PTROFF(ptr_,offset_,type_),alignment_,type_)\n+\n+\n+\/**\n+ * Deprecated, use SPA_PTROFF and SPA_PTROFF_ALIGN instead\n+ *\/\n+#define SPA_MEMBER(b,o,t) SPA_PTROFF(b,o,t)\n+#define SPA_MEMBER_ALIGN(b,o,a,t) SPA_PTROFF_ALIGN(b,o,a,t)\n+\n+#define SPA_CONTAINER_OF(p,t,m) ((t*)((uintptr_t)(p) - offsetof(t,m)))\n+\n+#define SPA_PTRDIFF(p1,p2) ((intptr_t)(p1) - (intptr_t)(p2))\n+\n+#define SPA_PTR_TO_INT(p) ((int) ((intptr_t) (p)))\n+#define SPA_INT_TO_PTR(u) ((void*) ((intptr_t) (u)))\n+\n+#define SPA_PTR_TO_UINT32(p) ((uint32_t) ((uintptr_t) (p)))\n+#define SPA_UINT32_TO_PTR(u) ((void*) ((uintptr_t) (u)))\n+\n+#define SPA_TIME_INVALID  ((int64_t)INT64_MIN)\n+#define SPA_IDX_INVALID  ((unsigned int)-1)\n+#define SPA_ID_INVALID  ((uint32_t)0xffffffff)\n+\n+#define SPA_NSEC_PER_SEC  (1000000000LL)\n+#define SPA_NSEC_PER_MSEC (1000000ll)\n+#define SPA_NSEC_PER_USEC (1000ll)\n+#define SPA_USEC_PER_SEC  (1000000ll)\n+#define SPA_USEC_PER_MSEC (1000ll)\n+#define SPA_MSEC_PER_SEC  (1000ll)\n+\n+#define SPA_TIMESPEC_TO_NSEC(ts) ((ts)->tv_sec * SPA_NSEC_PER_SEC + (ts)->tv_nsec)\n+#define SPA_TIMESPEC_TO_USEC(ts) ((ts)->tv_sec * SPA_USEC_PER_SEC + (ts)->tv_nsec \/ SPA_NSEC_PER_USEC)\n+#define SPA_TIMEVAL_TO_NSEC(tv)  ((tv)->tv_sec * SPA_NSEC_PER_SEC + (tv)->tv_usec * SPA_NSEC_PER_USEC)\n+#define SPA_TIMEVAL_TO_USEC(tv)  ((tv)->tv_sec * SPA_USEC_PER_SEC + (tv)->tv_usec)\n+\n+#ifdef __GNUC__\n+#define SPA_PRINTF_FUNC(fmt, arg1) __attribute__((format(printf, fmt, arg1)))\n+#define SPA_FORMAT_ARG_FUNC(arg1) __attribute__((format_arg(arg1)))\n+#define SPA_ALIGNED(align) __attribute__((aligned(align)))\n+#define SPA_DEPRECATED __attribute__ ((deprecated))\n+#define SPA_EXPORT __attribute__((visibility(\"default\")))\n+#define SPA_SENTINEL __attribute__((__sentinel__))\n+#define SPA_UNUSED __attribute__ ((unused))\n+#define SPA_NORETURN __attribute__ ((noreturn))\n+#define SPA_WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))\n+#else\n+#define SPA_PRINTF_FUNC(fmt, arg1)\n+#define SPA_FORMAT_ARG_FUNC(arg1)\n+#define SPA_ALIGNED(align)\n+#define SPA_DEPRECATED\n+#define SPA_EXPORT\n+#define SPA_SENTINEL\n+#define SPA_UNUSED\n+#define SPA_NORETURN\n+#define SPA_WARN_UNUSED_RESULT\n+#endif\n+\n+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n+#define SPA_RESTRICT restrict\n+#elif defined(__GNUC__) && __GNUC__ >= 4\n+#define SPA_RESTRICT __restrict__\n+#else\n+#define SPA_RESTRICT\n+#endif\n+\n+#define SPA_ROUND_DOWN(num,value)        \\\n+({                        \\\n+    __typeof__(num) _num = (num);        \\\n+    ((_num) - ((_num) % (value)));        \\\n+})\n+#define SPA_ROUND_UP(num,value)            \\\n+({                        \\\n+    __typeof__(value) _v = (value);        \\\n+    ((((num) + (_v) - 1) \/ (_v)) * (_v));    \\\n+})\n+\n+#define SPA_ROUND_MASK(num,mask)    ((__typeof__(num))((mask)-1))\n+\n+#define SPA_ROUND_DOWN_N(num,align)    ((num) & ~SPA_ROUND_MASK(num, align))\n+#define SPA_ROUND_UP_N(num,align)    ((((num)-1) | SPA_ROUND_MASK(num, align))+1)\n+\n+#define SPA_SCALE32_UP(val,num,denom)                \\\n+({                                \\\n+    uint64_t _val = (val);                    \\\n+    uint64_t _denom = (denom);                \\\n+    (uint32_t)(((_val) * (num) + (_denom)-1) \/ (_denom));    \\\n+})\n+\n+\n+#define SPA_PTR_ALIGNMENT(p,align)    ((intptr_t)(p) & ((align)-1))\n+#define SPA_IS_ALIGNED(p,align)        (SPA_PTR_ALIGNMENT(p,align) == 0)\n+#define SPA_PTR_ALIGN(p,align,type)    ((type*)SPA_ROUND_UP_N((intptr_t)(p), (intptr_t)(align)))\n+\n+#ifndef SPA_LIKELY\n+#ifdef __GNUC__\n+#define SPA_LIKELY(x) (__builtin_expect(!!(x),1))\n+#define SPA_UNLIKELY(x) (__builtin_expect(!!(x),0))\n+#else\n+#define SPA_LIKELY(x) (x)\n+#define SPA_UNLIKELY(x) (x)\n+#endif\n+#endif\n+\n+#define SPA_STRINGIFY_1(...)    #__VA_ARGS__\n+#define SPA_STRINGIFY(...)    SPA_STRINGIFY_1(__VA_ARGS__)\n+\n+#define spa_return_if_fail(expr)                    \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            return;                        \\\n+        }                            \\\n+    } while(false)\n+\n+#define spa_return_val_if_fail(expr, val)                \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            return (val);                    \\\n+        }                            \\\n+    } while(false)\n+\n+\/* spa_assert_se() is an assert which guarantees side effects of x,\n+ * i.e. is never optimized away, regardless of NDEBUG or FASTPATH. *\/\n+#ifndef __COVERITY__\n+#define spa_assert_se(expr)                        \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            abort();                    \\\n+        }                            \\\n+    } while (false)\n+#else\n+#define spa_assert_se(expr)                        \\\n+    do {                                \\\n+        int _unique_var = (expr);                \\\n+        if (!_unique_var)                    \\\n+            abort();                    \\\n+        } while (false)\n+#endif\n+\n+\/* Does exactly nothing *\/\n+#define spa_nop() do {} while (false)\n+\n+#ifdef NDEBUG\n+#define spa_assert(expr) spa_nop()\n+#elif defined (FASTPATH)\n+#define spa_assert(expr) spa_assert_se(expr)\n+#else\n+#define spa_assert(expr) spa_assert_se(expr)\n+#endif\n+\n+#ifdef NDEBUG\n+#define spa_assert_not_reached() abort()\n+#else\n+#define spa_assert_not_reached()                        \\\n+    do {                                    \\\n+        fprintf(stderr, \"Code should not be reached at %s:%u %s()\\n\",    \\\n+                __FILE__, __LINE__, __func__);            \\\n+        abort();                            \\\n+    } while (false)\n+#endif\n+\n+#define spa_memzero(x,l) (memset((x), 0, (l)))\n+#define spa_zero(x) (spa_memzero(&(x), sizeof(x)))\n+\n+#ifdef SPA_DEBUG_MEMCPY\n+#define spa_memcpy(d,s,n)                        \\\n+({                                    \\\n+    fprintf(stderr, \"%s:%u %s() memcpy(%p, %p, %zd)\\n\",        \\\n+        __FILE__, __LINE__, __func__, (d), (s), (size_t)(n));    \\\n+    memcpy(d,s,n);                            \\\n+})\n+#define spa_memmove(d,s,n)                        \\\n+({                                    \\\n+    fprintf(stderr, \"%s:%u %s() memmove(%p, %p, %zd)\\n\",        \\\n+        __FILE__, __LINE__, __func__, (d), (s), (size_t)(n));    \\\n+    memmove(d,s,n);                            \\\n+})\n+#else\n+#define spa_memcpy(d,s,n)    memcpy(d,s,n)\n+#define spa_memmove(d,s,n)    memmove(d,s,n)\n+#endif\n+\n+#define spa_aprintf(_fmt, ...)                        \\\n+({                                    \\\n+    char *_strp;                            \\\n+    if (asprintf(&(_strp), (_fmt), ## __VA_ARGS__ ) == -1)        \\\n+        _strp = NULL;                        \\\n+    _strp;                                \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_UTILS_DEFS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/defs.h","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DICT_H\n+#define SPA_DICT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <string.h>\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\defgroup spa_dict Dictionary\n+ * Dictionary data structure\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_dict\n+ * \\{\n+ *\/\n+\n+struct spa_dict_item {\n+    const char *key;\n+    const char *value;\n+};\n+\n+#define SPA_DICT_ITEM_INIT(key,value) ((struct spa_dict_item) { (key), (value) })\n+\n+struct spa_dict {\n+#define SPA_DICT_FLAG_SORTED    (1<<0)        \/**< items are sorted *\/\n+    uint32_t flags;\n+    uint32_t n_items;\n+    const struct spa_dict_item *items;\n+};\n+\n+#define SPA_DICT_INIT(items,n_items) ((struct spa_dict) { 0, (n_items), (items) })\n+#define SPA_DICT_INIT_ARRAY(items) ((struct spa_dict) { 0, SPA_N_ELEMENTS(items), (items) })\n+\n+#define spa_dict_for_each(item, dict)                \\\n+    for ((item) = (dict)->items;                \\\n+         (item) < &(dict)->items[(dict)->n_items];        \\\n+         (item)++)\n+\n+static inline int spa_dict_item_compare(const void *i1, const void *i2)\n+{\n+    const struct spa_dict_item *it1 = (const struct spa_dict_item *)i1,\n+          *it2 = (const struct spa_dict_item *)i2;\n+    return strcmp(it1->key, it2->key);\n+}\n+\n+static inline void spa_dict_qsort(struct spa_dict *dict)\n+{\n+    if (dict->n_items > 0)\n+        qsort((void*)dict->items, dict->n_items, sizeof(struct spa_dict_item),\n+                spa_dict_item_compare);\n+    SPA_FLAG_SET(dict->flags, SPA_DICT_FLAG_SORTED);\n+}\n+\n+static inline const struct spa_dict_item *spa_dict_lookup_item(const struct spa_dict *dict,\n+                                   const char *key)\n+{\n+    const struct spa_dict_item *item;\n+\n+    if (SPA_FLAG_IS_SET(dict->flags, SPA_DICT_FLAG_SORTED) &&\n+            dict->n_items > 0) {\n+        struct spa_dict_item k = SPA_DICT_ITEM_INIT(key, NULL);\n+        item = (const struct spa_dict_item *)bsearch(&k,\n+                (const void *) dict->items, dict->n_items,\n+                sizeof(struct spa_dict_item),\n+                spa_dict_item_compare);\n+        if (item != NULL)\n+            return item;\n+    } else {\n+        spa_dict_for_each(item, dict) {\n+            if (!strcmp(item->key, key))\n+                return item;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+static inline const char *spa_dict_lookup(const struct spa_dict *dict, const char *key)\n+{\n+    const struct spa_dict_item *item = spa_dict_lookup_item(dict, key);\n+    return item ? item->value : NULL;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DICT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/dict.h","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_ENUM_TYPES_H\n+#define SPA_ENUM_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+\n+#define SPA_TYPE_INFO_Direction            SPA_TYPE_INFO_ENUM_BASE \"Direction\"\n+#define SPA_TYPE_INFO_DIRECTION_BASE        SPA_TYPE_INFO_Direction \":\"\n+\n+static const struct spa_type_info spa_type_direction[] = {\n+    { SPA_DIRECTION_INPUT, SPA_TYPE_Int, SPA_TYPE_INFO_DIRECTION_BASE \"Input\", NULL  },\n+    { SPA_DIRECTION_OUTPUT, SPA_TYPE_Int, SPA_TYPE_INFO_DIRECTION_BASE \"Output\", NULL  },\n+    { 0, 0, NULL, NULL }\n+};\n+\n+#include <spa\/pod\/pod.h>\n+\n+#define SPA_TYPE_INFO_Choice            SPA_TYPE_INFO_ENUM_BASE \"Choice\"\n+#define SPA_TYPE_INFO_CHOICE_BASE        SPA_TYPE_INFO_Choice \":\"\n+\n+static const struct spa_type_info spa_type_choice[] = {\n+    { SPA_CHOICE_None, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"None\", NULL  },\n+    { SPA_CHOICE_Range, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Range\", NULL  },\n+    { SPA_CHOICE_Step, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Step\", NULL  },\n+    { SPA_CHOICE_Enum, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Enum\", NULL  },\n+    { SPA_CHOICE_Flags, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Flags\", NULL  },\n+    { 0, 0, NULL, NULL }\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/enum-types.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,452 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_HOOK_H\n+#define SPA_HOOK_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/list.h>\n+\n+\/** \\defgroup spa_interfaces Interfaces\n+ *\n+ * \\brief Generic implementation of implementation-independent interfaces\n+ *\n+ * A SPA Interface is a generic struct that, together with a few macros,\n+ * provides a generic way of invoking methods on objects without knowing the\n+ * details of the implementation.\n+ *\n+ * The primary interaction with interfaces is through macros that expand into\n+ * the right method call. For the implementation of an interface, we need two\n+ * structs and a macro to invoke the `bar` method:\n+ *\n+ * \\code{.c}\n+ * \/\/ this struct must be public and defines the interface to a\n+ * \/\/ struct foo\n+ * struct foo_methods {\n+ *     uint32_t version;\n+ *     void (*bar)(void *object, const char *msg);\n+ * };\n+ *\n+ * \/\/ this struct does not need to be public\n+ * struct foo {\n+ *     struct spa_interface iface; \/\/ must be first element, see foo_bar()\n+ *     int some_other_field;\n+ *     ...\n+ * };\n+ *\n+ * \/\/ if struct foo is private, we need to cast to a\n+ * \/\/ generic spa_interface object\n+ * #define foo_bar(obj, ...) ({ \\\n+ *     struct foo *f = obj;\n+ *     spa_interface_call((struct spa_interface *)f, \/\/ pointer to spa_interface in foo\n+ *                        struct foo_methods, \/\/ type of callbacks\n+ *                        bar, \/\/ name of methods\n+ *                        0, \/\/ hardcoded version to match foo_methods->version\n+ *                        __VA_ARGS__ \/\/ pass rest of args through\n+ *                        );\/\n+ * })\n+ * \\endcode\n+ *\n+ * The `struct foo_methods` and the invocation macro `foo_bar()` must be\n+ * available to the caller. The implementation of `struct foo` can be private.\n+ *\n+ * \\code{.c}\n+ * void main(void) {\n+ *      struct foo *myfoo = get_foo_from_somewhere();\n+ *      foo_bar(myfoo, \"Invoking bar() on myfoo\");\n+ * }\n+ * \\endcode\n+ * The expansion of `foo_bar()` resolves roughly into this code:\n+ * \\code{.c}\n+ * void main(void) {\n+ *     struct foo *myfoo = get_foo_from_somewhere();\n+ *     \/\/ foo_bar(myfoo, \"Invoking bar() on myfoo\");\n+ *     const struct foo_methods *methods = ((struct spa_interface*)myfoo)->cb;\n+ *     if (0 >= methods->version && \/\/ version check\n+ *         methods->bar) \/\/ compile error if this function does not exist,\n+ *             methods->bar(myfoo, \"Invoking bar() on myfoo\");\n+ * }\n+ * \\endcode\n+ *\n+ * The typecast used in `foo_bar()` allows `struct foo` to be opaque to the\n+ * caller. The implementation may assign the callback methods at object\n+ * instantiation, and the caller will transparently invoke the method on the\n+ * given object. For example, the following code assigns a different `bar()` method on\n+ * Mondays - the caller does not need to know this.\n+ * \\code{.c}\n+ *\n+ * static void bar_stdout(struct foo *f, const char *msg) {\n+ *     printf(msg);\n+ * }\n+ * static void bar_stderr(struct foo *f, const char *msg) {\n+ *     fprintf(stderr, msg);\n+ * }\n+ *\n+ * struct foo* get_foo_from_somewhere() {\n+ *     struct foo *f = calloc(sizeof struct foo);\n+ *     \/\/ illustrative only, use SPA_INTERFACE_INIT()\n+ *     f->iface->cb = (struct foo_methods*) { .bar = bar_stdout };\n+ *     if (today_is_monday)\n+ *         f->iface->cb = (struct foo_methods*) { .bar = bar_stderr };\n+ *     return f;\n+ * }\n+ * \\endcode\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_interfaces\n+ * \\{\n+ *\/\n+\n+\/** \\struct spa_callbacks\n+ * Callbacks, contains the structure with functions and the data passed\n+ * to the functions.  The structure should also contain a version field that\n+ * is checked. *\/\n+struct spa_callbacks {\n+    const void *funcs;\n+    void *data;\n+};\n+\n+\/** Check if a callback \\a c is of at least version \\a v *\/\n+#define SPA_CALLBACK_VERSION_MIN(c,v) ((c) && ((v) == 0 || (c)->version > (v)-1))\n+\n+\/** Check if a callback \\a c has method \\a m of version \\a v *\/\n+#define SPA_CALLBACK_CHECK(c,m,v) (SPA_CALLBACK_VERSION_MIN(c,v) && (c)->m)\n+\n+\/**\n+ * Initialize the set of functions \\a funcs as a \\ref spa_callbacks, together\n+ * with \\a _data.\n+ *\/\n+#define SPA_CALLBACKS_INIT(_funcs,_data) ((struct spa_callbacks){ (_funcs), (_data), })\n+\n+\/** \\struct spa_interface\n+ *\/\n+struct spa_interface {\n+    const char *type;\n+    uint32_t version;\n+    struct spa_callbacks cb;\n+};\n+\n+\/**\n+ * Initialize a \\ref spa_interface.\n+ *\n+ * \\code{.c}\n+ * const static struct foo_methods foo_funcs = {\n+ *    .bar = some_bar_implementation,\n+ * };\n+ *\n+ * struct foo *f = malloc(...);\n+ * f->iface = SPA_INTERFACE_INIT(\"foo type\", 0, foo_funcs, NULL);\n+ * \\endcode\n+ *\n+ *\/\n+#define SPA_INTERFACE_INIT(_type,_version,_funcs,_data) \\\n+    ((struct spa_interface){ (_type), (_version), SPA_CALLBACKS_INIT(_funcs,_data), })\n+\n+\/**\n+ * Invoke method named \\a method in the \\a callbacks.\n+ * The \\a method_type defines the type of the method struct.\n+ * Returns true if the method could be called, false otherwise.\n+ *\/\n+#define spa_callbacks_call(callbacks,type,method,vers,...)            \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    bool _res = SPA_CALLBACK_CHECK(_f,method,vers);                \\\n+    if (SPA_LIKELY(_res))                            \\\n+        _f->method((callbacks)->data, ## __VA_ARGS__);            \\\n+    _res;                                    \\\n+})\n+\n+\/**\n+ * True if the \\a callbacks are of version \\a vers, false otherwise\n+ *\/\n+#define spa_callback_version_min(callbacks,type,vers)                \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    SPA_CALLBACK_VERSION_MIN(_f,vers);                    \\\n+})\n+\n+\/**\n+ * True if the \\a callbacks contains \\a method of version\n+ * \\a vers, false otherwise\n+ *\/\n+#define spa_callback_check(callbacks,type,method,vers)                \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    SPA_CALLBACK_CHECK(_f,method,vers);                    \\\n+})\n+\n+\/**\n+ * Invoke method named \\a method in the \\a callbacks.\n+ * The \\a method_type defines the type of the method struct.\n+ *\n+ * The return value is stored in \\a res.\n+ *\/\n+#define spa_callbacks_call_res(callbacks,type,res,method,vers,...)        \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    if (SPA_LIKELY(SPA_CALLBACK_CHECK(_f,method,vers)))            \\\n+        res = _f->method((callbacks)->data, ## __VA_ARGS__);        \\\n+    res;                                    \\\n+})\n+\n+\/**\n+ * True if the \\a iface's callbacks are of version \\a vers, false otherwise\n+ *\/\n+#define spa_interface_callback_version_min(iface,method_type,vers)        \\\n+   spa_callback_version_min(&(iface)->cb, method_type, vers)\n+\n+\/**\n+ * True if the \\a iface's callback \\a method is of version \\a vers\n+ * and exists, false otherwise\n+ *\/\n+#define spa_interface_callback_check(iface,method_type,method,vers)        \\\n+   spa_callback_check(&(iface)->cb, method_type, method, vers)\n+\n+\/**\n+ * Invoke method named \\a method in the callbacks on the given interface object.\n+ * The \\a method_type defines the type of the method struct, not the interface\n+ * itself.\n+ *\/\n+#define spa_interface_call(iface,method_type,method,vers,...)            \\\n+    spa_callbacks_call(&(iface)->cb,method_type,method,vers,##__VA_ARGS__)\n+\n+\/**\n+ * Invoke method named \\a method in the callbacks on the given interface object.\n+ * The \\a method_type defines the type of the method struct, not the interface\n+ * itself.\n+ *\n+ * The return value is stored in \\a res.\n+ *\/\n+#define spa_interface_call_res(iface,method_type,res,method,vers,...)            \\\n+    spa_callbacks_call_res(&(iface)->cb,method_type,res,method,vers,##__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/** \\defgroup spa_hooks Hooks\n+ *\n+ * A SPA Hook is a data structure to keep track of callbacks. It is similar to\n+ * the \\ref spa_interfaces and typically used where an implementation allows\n+ * for multiple external callback functions. For example, an implementation may\n+ * use a hook list to implement signals with each caller using a hook to\n+ * register callbacks to be invoked on those signals.\n+ *\n+ * The below (pseudo)code is a minimal example outlining the use of hooks:\n+ * \\code{.c}\n+ * \/\/ the public interface\n+ * #define VERSION_BAR_EVENTS 0 \/\/ version of the vtable\n+ * struct bar_events {\n+ *    uint32_t version; \/\/ NOTE: an integral member named `version`\n+ *                      \/\/       must be present in the vtable\n+ *    void (*boom)(void *data, const char *msg);\n+ * };\n+ *\n+ * \/\/ private implementation\n+ * struct party {\n+ *     struct spa_hook_list bar_list;\n+ * };\n+ *\n+ * void party_add_event_listener(struct party *p, struct spa_hook *listener,\n+ *                               const struct bar_events *events, void *data)\n+ * {\n+ *    spa_hook_list_append(&p->bar_list, listener, events, data);\n+ * }\n+ *\n+ * static void party_on(struct party *p)\n+ * {\n+ *     \/\/ NOTE: this is a macro, it evaluates to an integer,\n+ *     \/\/       which is the number of hooks called\n+ *     spa_hook_list_call(&p->list,\n+ *                        struct bar_events, \/\/ vtable type\n+ *                        boom,              \/\/ function name\n+ *                        0,                 \/\/ hardcoded version,\n+ *                                           \/\/     usually the version in which `boom`\n+ *                                           \/\/     has been added to the vtable\n+ *                        \"party on, wayne\"  \/\/ function argument(s)\n+ *                        );\n+ * }\n+ * \\endcode\n+ *\n+ * In the caller, the hooks can be used like this:\n+ * \\code{.c}\n+ * static void boom_cb(void *data, const char *msg) {\n+ *      \/\/ data is userdata from main()\n+ *      printf(\"%s\", msg);\n+ * }\n+ *\n+ * static const struct bar_events events = {\n+ *    .version = VERSION_BAR_EVENTS, \/\/ version of the implemented interface\n+ *    .boom = boom_cb,\n+ * };\n+ *\n+ * void main(void) {\n+ *      void *userdata = whatever;\n+ *      struct spa_hook hook;\n+ *      struct party *p = start_the_party();\n+ *\n+ *      party_add_event_listener(p, &hook, &events, userdata);\n+ *\n+ *      mainloop();\n+ *      return 0;\n+ * }\n+ *\n+ * \\endcode\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_hooks\n+ * \\{\n+ *\/\n+\n+\/** \\struct spa_hook_list\n+ * A list of hooks. This struct is primarily used by\n+ * implementation that use multiple caller-provided \\ref spa_hook. *\/\n+struct spa_hook_list {\n+    struct spa_list list;\n+};\n+\n+\n+\/** \\struct spa_hook\n+ * A hook, contains the structure with functions and the data passed\n+ * to the functions.\n+ *\n+ * A hook should be treated as opaque by the caller.\n+ *\/\n+struct spa_hook {\n+    struct spa_list link;\n+    struct spa_callbacks cb;\n+    \/** callback and data for the hook list, private to the\n+      * hook_list implementor *\/\n+    void (*removed) (struct spa_hook *hook);\n+    void *priv;\n+};\n+\n+\/** Initialize a hook list to the empty list*\/\n+static inline void spa_hook_list_init(struct spa_hook_list *list)\n+{\n+    spa_list_init(&list->list);\n+}\n+\n+static inline bool spa_hook_list_is_empty(struct spa_hook_list *list)\n+{\n+    return spa_list_is_empty(&list->list);\n+}\n+\n+\/** Append a hook. *\/\n+static inline void spa_hook_list_append(struct spa_hook_list *list,\n+                    struct spa_hook *hook,\n+                    const void *funcs, void *data)\n+{\n+    spa_zero(*hook);\n+    hook->cb = SPA_CALLBACKS_INIT(funcs, data);\n+    spa_list_append(&list->list, &hook->link);\n+}\n+\n+\/** Prepend a hook *\/\n+static inline void spa_hook_list_prepend(struct spa_hook_list *list,\n+                     struct spa_hook *hook,\n+                     const void *funcs, void *data)\n+{\n+    spa_zero(*hook);\n+    hook->cb = SPA_CALLBACKS_INIT(funcs, data);\n+    spa_list_prepend(&list->list, &hook->link);\n+}\n+\n+\/** Remove a hook *\/\n+static inline void spa_hook_remove(struct spa_hook *hook)\n+{\n+    if (spa_list_is_initialized(&hook->link))\n+        spa_list_remove(&hook->link);\n+    if (hook->removed)\n+        hook->removed(hook);\n+}\n+\n+\/** Remove all hooks from the list *\/\n+static inline void spa_hook_list_clean(struct spa_hook_list *list)\n+{\n+    struct spa_hook *h;\n+    spa_list_consume(h, &list->list, link)\n+        spa_hook_remove(h);\n+}\n+\n+static inline void\n+spa_hook_list_isolate(struct spa_hook_list *list,\n+        struct spa_hook_list *save,\n+        struct spa_hook *hook,\n+        const void *funcs, void *data)\n+{\n+    \/* init save list and move hooks to it *\/\n+    spa_hook_list_init(save);\n+    spa_list_insert_list(&save->list, &list->list);\n+    \/* init hooks and add single hook *\/\n+    spa_hook_list_init(list);\n+    spa_hook_list_append(list, hook, funcs, data);\n+}\n+\n+static inline void\n+spa_hook_list_join(struct spa_hook_list *list,\n+        struct spa_hook_list *save)\n+{\n+    spa_list_insert_list(&list->list, &save->list);\n+}\n+\n+#define spa_hook_list_call_simple(l,type,method,vers,...)            \\\n+({                                        \\\n+    struct spa_hook_list *_l = l;                        \\\n+    struct spa_hook *_h, *_t;                        \\\n+    spa_list_for_each_safe(_h, _t, &_l->list, link)                \\\n+        spa_callbacks_call(&_h->cb,type,method,vers, ## __VA_ARGS__);    \\\n+})\n+\n+\/** Call all hooks in a list, starting from the given one and optionally stopping\n+ * after calling the first non-NULL function, returns the number of methods\n+ * called *\/\n+#define spa_hook_list_do_call(l,start,type,method,vers,once,...)        \\\n+({                                        \\\n+    struct spa_hook_list *_list = l;                    \\\n+    struct spa_list *_s = start ? (struct spa_list *)start : &_list->list;    \\\n+    struct spa_hook _cursor = { 0 }, *_ci;                    \\\n+    int _count = 0;                                \\\n+    spa_list_cursor_start(_cursor, _s, link);                \\\n+    spa_list_for_each_cursor(_ci, _cursor, &_list->list, link) {        \\\n+        if (spa_callbacks_call(&_ci->cb,type,method,vers, ## __VA_ARGS__)) {        \\\n+            _count++;                        \\\n+            if (once)                        \\\n+                break;                        \\\n+        }                                \\\n+    }                                    \\\n+    spa_list_cursor_end(_cursor, link);                    \\\n+    _count;                                    \\\n+})\n+\n+\/**\n+ * Call the method named \\a m for each element in list \\a l.\n+ * \\a t specifies the type of the callback struct.\n+ *\/\n+#define spa_hook_list_call(l,t,m,v,...)            spa_hook_list_do_call(l,NULL,t,m,v,false,##__VA_ARGS__)\n+\/**\n+ * Call the method named \\a m for each element in list \\a l, stopping after\n+ * the first invocation.\n+ * \\a t specifies the type of the callback struct.\n+ *\/\n+#define spa_hook_list_call_once(l,t,m,v,...)        spa_hook_list_do_call(l,NULL,t,m,v,true,##__VA_ARGS__)\n+\n+#define spa_hook_list_call_start(l,s,t,m,v,...)        spa_hook_list_do_call(l,s,t,m,v,false,##__VA_ARGS__)\n+#define spa_hook_list_call_once_start(l,s,t,m,v,...)    spa_hook_list_do_call(l,s,t,m,v,true,##__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* SPA_HOOK_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/hook.h","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_LIST_H\n+#define SPA_LIST_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\defgroup spa_list List\n+ * Doubly linked list data structure\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_list List\n+ * \\{\n+ *\/\n+\n+struct spa_list {\n+    struct spa_list *next;\n+    struct spa_list *prev;\n+};\n+\n+#define SPA_LIST_INIT(list) ((struct spa_list){ (list), (list) })\n+\n+static inline void spa_list_init(struct spa_list *list)\n+{\n+    *list = SPA_LIST_INIT(list);\n+}\n+\n+static inline int spa_list_is_initialized(struct spa_list *list)\n+{\n+    return !!list->prev;\n+}\n+\n+#define spa_list_is_empty(l)  ((l)->next == (l))\n+\n+static inline void spa_list_insert(struct spa_list *list, struct spa_list *elem)\n+{\n+    elem->prev = list;\n+    elem->next = list->next;\n+    list->next = elem;\n+    elem->next->prev = elem;\n+}\n+\n+static inline void spa_list_insert_list(struct spa_list *list, struct spa_list *other)\n+{\n+    if (spa_list_is_empty(other))\n+        return;\n+    other->next->prev = list;\n+    other->prev->next = list->next;\n+    list->next->prev = other->prev;\n+    list->next = other->next;\n+}\n+\n+static inline void spa_list_remove(struct spa_list *elem)\n+{\n+    elem->prev->next = elem->next;\n+    elem->next->prev = elem->prev;\n+}\n+\n+#define spa_list_first(head, type, member)                \\\n+    SPA_CONTAINER_OF((head)->next, type, member)\n+\n+#define spa_list_last(head, type, member)                \\\n+    SPA_CONTAINER_OF((head)->prev, type, member)\n+\n+#define spa_list_append(list, item)                    \\\n+    spa_list_insert((list)->prev, item)\n+\n+#define spa_list_prepend(list, item)                    \\\n+    spa_list_insert(list, item)\n+\n+#define spa_list_is_end(pos, head, member)                \\\n+    (&(pos)->member == (head))\n+\n+#define spa_list_next(pos, member)                    \\\n+    SPA_CONTAINER_OF((pos)->member.next, __typeof__(*(pos)), member)\n+\n+#define spa_list_prev(pos, member)                    \\\n+    SPA_CONTAINER_OF((pos)->member.prev, __typeof__(*(pos)), member)\n+\n+#define spa_list_consume(pos, head, member)                \\\n+    for ((pos) = spa_list_first(head, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_empty(head);                    \\\n+         (pos) = spa_list_first(head, __typeof__(*(pos)), member))\n+\n+#define spa_list_for_each_next(pos, head, curr, member)            \\\n+    for ((pos) = spa_list_first(curr, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = spa_list_next(pos, member))\n+\n+#define spa_list_for_each_prev(pos, head, curr, member)            \\\n+    for ((pos) = spa_list_last(curr, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = spa_list_prev(pos, member))\n+\n+#define spa_list_for_each(pos, head, member)                \\\n+    spa_list_for_each_next(pos, head, head, member)\n+\n+#define spa_list_for_each_reverse(pos, head, member)            \\\n+    spa_list_for_each_prev(pos, head, head, member)\n+\n+#define spa_list_for_each_safe_next(pos, tmp, head, curr, member)    \\\n+    for ((pos) = spa_list_first(curr, __typeof__(*(pos)), member);    \\\n+         (tmp) = spa_list_next(pos, member),                \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = (tmp))\n+\n+#define spa_list_for_each_safe_prev(pos, tmp, head, curr, member)    \\\n+    for ((pos) = spa_list_last(curr, __typeof__(*(pos)), member);    \\\n+         (tmp) = spa_list_prev(pos, member),                \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = (tmp))\n+\n+#define spa_list_for_each_safe(pos, tmp, head, member)            \\\n+    spa_list_for_each_safe_next(pos, tmp, head, head, member)\n+\n+#define spa_list_for_each_safe_reverse(pos, tmp, head, member)        \\\n+    spa_list_for_each_safe_prev(pos, tmp, head, head, member)\n+\n+#define spa_list_cursor_start(cursor, head, member)                     \\\n+        spa_list_prepend(head, &(cursor).member)\n+\n+#define spa_list_for_each_cursor(pos, cursor, head, member)             \\\n+        for((pos) = spa_list_first(&(cursor).member, __typeof__(*(pos)), member); \\\n+            spa_list_remove(&(pos)->member),                            \\\n+            spa_list_append(&(cursor).member, &(pos)->member),          \\\n+            !spa_list_is_end(pos, head, member);                        \\\n+            (pos) = spa_list_next(&(cursor), member))\n+\n+#define spa_list_cursor_end(cursor, member)                             \\\n+        spa_list_remove(&(cursor).member)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_LIST_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/list.h","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2021 Red Hat, Inc. *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_UTILS_STRING_H\n+#define SPA_UTILS_STRING_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <locale.h>\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\defgroup spa_string String handling\n+ * String handling utilities\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_string\n+ * \\{\n+ *\/\n+\n+\/**\n+ * \\return true if the two strings are equal, false otherwise\n+ *\n+ * If both \\a a and \\a b are NULL, the two are considered equal.\n+ *\n+ *\/\n+static inline bool spa_streq(const char *s1, const char *s2)\n+{\n+    return SPA_LIKELY(s1 && s2) ? strcmp(s1, s2) == 0 : s1 == s2;\n+}\n+\n+\/**\n+ * \\return true if the two strings are equal, false otherwise\n+ *\n+ * If both \\a a and \\a b are NULL, the two are considered equal.\n+ *\/\n+static inline bool spa_strneq(const char *s1, const char *s2, size_t len)\n+{\n+    return SPA_LIKELY(s1 && s2) ? strncmp(s1, s2, len) == 0 : s1 == s2;\n+}\n+\n+\n+\/**\n+ * \\return true if \\a s starts with the \\a prefix or false otherwise.\n+ * A \\a s is NULL, it never starts with the given \\a prefix. A \\a prefix of\n+ * NULL is a bug in the caller.\n+ *\/\n+static inline bool spa_strstartswith(const char *s, const char *prefix)\n+{\n+    if (SPA_UNLIKELY(s == NULL))\n+        return false;\n+\n+    spa_assert_se(prefix);\n+\n+    return strncmp(s, prefix, strlen(prefix)) == 0;\n+}\n+\n+\n+\/**\n+ * \\return true if \\a s ends with the \\a suffix or false otherwise.\n+ * A \\a s is NULL, it never ends with the given \\a suffix. A \\a suffix of\n+ * NULL is a bug in the caller.\n+ *\/\n+static inline bool spa_strendswith(const char *s, const char *suffix)\n+{\n+    size_t l1, l2;\n+\n+    if (SPA_UNLIKELY(s == NULL))\n+        return false;\n+\n+    spa_assert_se(suffix);\n+\n+    l1 = strlen(s);\n+    l2 = strlen(suffix);\n+    return l1 >= l2 && spa_streq(s + l1 - l2, suffix);\n+}\n+\n+\/**\n+ * Convert \\a str to an int32_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atoi32(const char *str, int32_t *val, int base)\n+{\n+    char *endptr;\n+    long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtol(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    if (v != (int32_t)v)\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an uint32_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atou32(const char *str, uint32_t *val, int base)\n+{\n+    char *endptr;\n+    unsigned long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoull(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    if (v != (uint32_t)v)\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an int64_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atoi64(const char *str, int64_t *val, int base)\n+{\n+    char *endptr;\n+    long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoll(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an uint64_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atou64(const char *str, uint64_t *val, int base)\n+{\n+    char *endptr;\n+    unsigned long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoull(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to a boolean. Allowed boolean values are \"true\" and a\n+ * literal \"1\", anything else is false.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atob(const char *str)\n+{\n+    return spa_streq(str, \"true\") || spa_streq(str, \"1\");\n+}\n+\n+\/**\n+ * \"Safe\" version of vsnprintf. Exactly the same as vsnprintf but the\n+ * returned value is clipped to `size - 1` and a negative or zero size\n+ * will abort() the program.\n+ *\n+ * \\return The number of bytes printed, capped to `size-1`, or a negative\n+ * number on error.\n+ *\/\n+SPA_PRINTF_FUNC(3, 0)\n+static inline int spa_vscnprintf(char *buffer, size_t size, const char *format, va_list args)\n+{\n+    int r;\n+\n+    spa_assert_se((ssize_t)size > 0);\n+\n+    r = vsnprintf(buffer, size, format, args);\n+    if (SPA_UNLIKELY(r < 0))\n+        buffer[0] = '\\0';\n+    if (SPA_LIKELY(r < (ssize_t)size))\n+        return r;\n+    return size - 1;\n+}\n+\n+\/**\n+ * \"Safe\" version of snprintf. Exactly the same as snprintf but the\n+ * returned value is clipped to `size - 1` and a negative or zero size\n+ * will abort() the program.\n+ *\n+ * \\return The number of bytes printed, capped to `size-1`, or a negative\n+ * number on error.\n+ *\/\n+SPA_PRINTF_FUNC(3, 4)\n+static inline int spa_scnprintf(char *buffer, size_t size, const char *format, ...)\n+{\n+    int r;\n+    va_list args;\n+\n+    va_start(args, format);\n+    r = spa_vscnprintf(buffer, size, format, args);\n+    va_end(args);\n+\n+    return r;\n+}\n+\n+\/**\n+ * Convert \\a str to a float in the C locale.\n+ *\n+ * If \\a endptr is not NULL, a pointer to the character after the last character\n+ * used in the conversion is stored in the location referenced by endptr.\n+ *\n+ * \\return the result float.\n+ *\/\n+static inline float spa_strtof(const char *str, char **endptr)\n+{\n+#ifndef __LOCALE_C_ONLY\n+    static locale_t locale = NULL;\n+    locale_t prev;\n+#endif\n+    float v;\n+#ifndef __LOCALE_C_ONLY\n+    if (SPA_UNLIKELY(locale == NULL))\n+        locale = newlocale(LC_ALL_MASK, \"C\", NULL);\n+    prev = uselocale(locale);\n+#endif\n+    v = strtof(str, endptr);\n+#ifndef __LOCALE_C_ONLY\n+    uselocale(prev);\n+#endif\n+    return v;\n+}\n+\n+\/**\n+ * Convert \\a str to a float and store the result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atof(const char *str, float *val)\n+{\n+    char *endptr;\n+    float v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+    errno = 0;\n+    v = spa_strtof(str, &endptr);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to a double in the C locale.\n+ *\n+ * If \\a endptr is not NULL, a pointer to the character after the last character\n+ * used in the conversion is stored in the location referenced by endptr.\n+ *\n+ * \\return the result float.\n+ *\/\n+static inline double spa_strtod(const char *str, char **endptr)\n+{\n+#ifndef __LOCALE_C_ONLY\n+    static locale_t locale = NULL;\n+    locale_t prev;\n+#endif\n+    double v;\n+#ifndef __LOCALE_C_ONLY\n+    if (SPA_UNLIKELY(locale == NULL))\n+        locale = newlocale(LC_ALL_MASK, \"C\", NULL);\n+    prev = uselocale(locale);\n+#endif\n+    v = strtod(str, endptr);\n+#ifndef __LOCALE_C_ONLY\n+    uselocale(prev);\n+#endif\n+    return v;\n+}\n+\n+\/**\n+ * Convert \\a str to a double and store the result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atod(const char *str, double *val)\n+{\n+    char *endptr;\n+    double v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = spa_strtod(str, &endptr);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+static inline char *spa_dtoa(char *str, size_t size, double val)\n+{\n+    int i, l;\n+    l = spa_scnprintf(str, size, \"%f\", val);\n+    for (i = 0; i < l; i++)\n+        if (str[i] == ',')\n+            str[i] = '.';\n+    return str;\n+}\n+\n+struct spa_strbuf {\n+    char *buffer;\n+    size_t maxsize;\n+    size_t pos;\n+};\n+\n+static inline void spa_strbuf_init(struct spa_strbuf *buf, char *buffer, size_t maxsize)\n+{\n+    buf->buffer = buffer;\n+    buf->maxsize = maxsize;\n+    buf->pos = 0;\n+}\n+\n+SPA_PRINTF_FUNC(2, 3)\n+static inline int spa_strbuf_append(struct spa_strbuf *buf, const char *fmt, ...)\n+{\n+    size_t remain = buf->maxsize - buf->pos;\n+    ssize_t written;\n+    va_list args;\n+    va_start(args, fmt);\n+    written = vsnprintf(&buf->buffer[buf->pos], remain, fmt, args);\n+    va_end(args);\n+    if (written > 0)\n+        buf->pos += SPA_MIN(remain, (size_t)written);\n+    return written;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_UTILS_STRING_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/string.h","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_TYPE_INFO_H\n+#define SPA_TYPE_INFO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\addtogroup spa_types\n+ * \\{\n+ *\/\n+\n+#ifndef SPA_TYPE_ROOT\n+#define SPA_TYPE_ROOT    spa_types\n+#endif\n+\n+static inline bool spa_type_is_a(const char *type, const char *parent)\n+{\n+    return type != NULL && parent != NULL && strncmp(type, parent, strlen(parent)) == 0;\n+}\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/utils\/enum-types.h>\n+\n+#include <spa\/monitor\/type-info.h>\n+#include <spa\/node\/type-info.h>\n+#include <spa\/param\/type-info.h>\n+#include <spa\/control\/type-info.h>\n+\n+static const struct spa_type_info spa_types[] = {\n+        \/* Basic types *\/\n+    { SPA_TYPE_START, SPA_TYPE_START, SPA_TYPE_INFO_BASE, NULL },\n+    { SPA_TYPE_None, SPA_TYPE_None, SPA_TYPE_INFO_BASE \"None\", NULL },\n+    { SPA_TYPE_Bool, SPA_TYPE_Bool, SPA_TYPE_INFO_BASE \"Bool\", NULL },\n+    { SPA_TYPE_Id, SPA_TYPE_Int, SPA_TYPE_INFO_BASE \"Id\", NULL },\n+    { SPA_TYPE_Int, SPA_TYPE_Int, SPA_TYPE_INFO_BASE \"Int\", NULL },\n+    { SPA_TYPE_Long, SPA_TYPE_Long, SPA_TYPE_INFO_BASE \"Long\", NULL },\n+    { SPA_TYPE_Float, SPA_TYPE_Float, SPA_TYPE_INFO_BASE \"Float\", NULL },\n+    { SPA_TYPE_Double, SPA_TYPE_Double, SPA_TYPE_INFO_BASE \"Double\", NULL },\n+    { SPA_TYPE_String, SPA_TYPE_String, SPA_TYPE_INFO_BASE \"String\", NULL },\n+    { SPA_TYPE_Bytes, SPA_TYPE_Bytes, SPA_TYPE_INFO_BASE \"Bytes\", NULL },\n+    { SPA_TYPE_Rectangle, SPA_TYPE_Rectangle, SPA_TYPE_INFO_BASE \"Rectangle\", NULL },\n+    { SPA_TYPE_Fraction, SPA_TYPE_Fraction, SPA_TYPE_INFO_BASE \"Fraction\", NULL },\n+    { SPA_TYPE_Bitmap, SPA_TYPE_Bitmap, SPA_TYPE_INFO_BASE \"Bitmap\", NULL },\n+    { SPA_TYPE_Array, SPA_TYPE_Array, SPA_TYPE_INFO_BASE \"Array\", NULL },\n+    { SPA_TYPE_Pod, SPA_TYPE_Pod, SPA_TYPE_INFO_Pod, NULL },\n+    { SPA_TYPE_Struct, SPA_TYPE_Pod, SPA_TYPE_INFO_Struct, NULL },\n+    { SPA_TYPE_Object, SPA_TYPE_Pod, SPA_TYPE_INFO_Object, NULL },\n+    { SPA_TYPE_Sequence, SPA_TYPE_Pod, SPA_TYPE_INFO_POD_BASE \"Sequence\", NULL },\n+    { SPA_TYPE_Pointer, SPA_TYPE_Pointer, SPA_TYPE_INFO_Pointer, NULL },\n+    { SPA_TYPE_Fd, SPA_TYPE_Fd, SPA_TYPE_INFO_BASE \"Fd\", NULL },\n+    { SPA_TYPE_Choice, SPA_TYPE_Pod, SPA_TYPE_INFO_POD_BASE \"Choice\", NULL },\n+\n+    { SPA_TYPE_POINTER_START, SPA_TYPE_Pointer, SPA_TYPE_INFO_Pointer, NULL },\n+    { SPA_TYPE_POINTER_Buffer, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Buffer\", NULL },\n+    { SPA_TYPE_POINTER_Meta, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Meta\", NULL },\n+    { SPA_TYPE_POINTER_Dict, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Dict\", NULL },\n+\n+    { SPA_TYPE_EVENT_START, SPA_TYPE_Object, SPA_TYPE_INFO_Event, NULL },\n+    { SPA_TYPE_EVENT_Device, SPA_TYPE_Object, SPA_TYPE_INFO_EVENT_BASE \"Device\", spa_type_device_event },\n+    { SPA_TYPE_EVENT_Node, SPA_TYPE_Object, SPA_TYPE_INFO_EVENT_BASE \"Node\", spa_type_node_event },\n+\n+    { SPA_TYPE_COMMAND_START, SPA_TYPE_Object, SPA_TYPE_INFO_Command, NULL },\n+    { SPA_TYPE_COMMAND_Device, SPA_TYPE_Object, SPA_TYPE_INFO_COMMAND_BASE \"Device\", NULL },\n+    { SPA_TYPE_COMMAND_Node, SPA_TYPE_Object, SPA_TYPE_INFO_COMMAND_BASE \"Node\", spa_type_node_command },\n+\n+    { SPA_TYPE_OBJECT_START, SPA_TYPE_Object, SPA_TYPE_INFO_Object, NULL },\n+    { SPA_TYPE_OBJECT_PropInfo, SPA_TYPE_Object, SPA_TYPE_INFO_PropInfo, spa_type_prop_info, },\n+    { SPA_TYPE_OBJECT_Props, SPA_TYPE_Object, SPA_TYPE_INFO_Props, spa_type_props },\n+    { SPA_TYPE_OBJECT_Format, SPA_TYPE_Object, SPA_TYPE_INFO_Format, spa_type_format },\n+    { SPA_TYPE_OBJECT_ParamBuffers, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Buffers, spa_type_param_buffers, },\n+    { SPA_TYPE_OBJECT_ParamMeta, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Meta, spa_type_param_meta },\n+    { SPA_TYPE_OBJECT_ParamIO, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_IO, spa_type_param_io },\n+    { SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Profile, spa_type_param_profile },\n+    { SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_PortConfig, spa_type_param_port_config },\n+    { SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Route, spa_type_param_route },\n+    { SPA_TYPE_OBJECT_Profiler, SPA_TYPE_Object, SPA_TYPE_INFO_Profiler, spa_type_profiler },\n+    { SPA_TYPE_OBJECT_ParamLatency, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Latency, spa_type_param_latency },\n+    { SPA_TYPE_OBJECT_ParamProcessLatency, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_ProcessLatency, spa_type_param_process_latency },\n+\n+    { 0, 0, NULL, NULL }\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/type-info.h","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright  2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_TYPE_H\n+#define SPA_TYPE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/** \\defgroup spa_types Types\n+ * Data type information enumerations\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_types\n+ * \\{\n+ *\/\n+\n+enum {\n+    \/* Basic types *\/\n+    SPA_TYPE_START = 0x00000,\n+    SPA_TYPE_None,\n+    SPA_TYPE_Bool,\n+    SPA_TYPE_Id,\n+    SPA_TYPE_Int,\n+    SPA_TYPE_Long,\n+    SPA_TYPE_Float,\n+    SPA_TYPE_Double,\n+    SPA_TYPE_String,\n+    SPA_TYPE_Bytes,\n+    SPA_TYPE_Rectangle,\n+    SPA_TYPE_Fraction,\n+    SPA_TYPE_Bitmap,\n+    SPA_TYPE_Array,\n+    SPA_TYPE_Struct,\n+    SPA_TYPE_Object,\n+    SPA_TYPE_Sequence,\n+    SPA_TYPE_Pointer,\n+    SPA_TYPE_Fd,\n+    SPA_TYPE_Choice,\n+    SPA_TYPE_Pod,\n+    _SPA_TYPE_LAST,                \/**< not part of ABI *\/\n+\n+    \/* Pointers *\/\n+    SPA_TYPE_POINTER_START = 0x10000,\n+    SPA_TYPE_POINTER_Buffer,\n+    SPA_TYPE_POINTER_Meta,\n+    SPA_TYPE_POINTER_Dict,\n+    _SPA_TYPE_POINTER_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Events *\/\n+    SPA_TYPE_EVENT_START = 0x20000,\n+    SPA_TYPE_EVENT_Device,\n+    SPA_TYPE_EVENT_Node,\n+    _SPA_TYPE_EVENT_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Commands *\/\n+    SPA_TYPE_COMMAND_START = 0x30000,\n+    SPA_TYPE_COMMAND_Device,\n+    SPA_TYPE_COMMAND_Node,\n+    _SPA_TYPE_COMMAND_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Objects *\/\n+    SPA_TYPE_OBJECT_START = 0x40000,\n+    SPA_TYPE_OBJECT_PropInfo,\n+    SPA_TYPE_OBJECT_Props,\n+    SPA_TYPE_OBJECT_Format,\n+    SPA_TYPE_OBJECT_ParamBuffers,\n+    SPA_TYPE_OBJECT_ParamMeta,\n+    SPA_TYPE_OBJECT_ParamIO,\n+    SPA_TYPE_OBJECT_ParamProfile,\n+    SPA_TYPE_OBJECT_ParamPortConfig,\n+    SPA_TYPE_OBJECT_ParamRoute,\n+    SPA_TYPE_OBJECT_Profiler,\n+    SPA_TYPE_OBJECT_ParamLatency,\n+    SPA_TYPE_OBJECT_ParamProcessLatency,\n+    _SPA_TYPE_OBJECT_LAST,            \/**< not part of ABI *\/\n+\n+    \/* vendor extensions *\/\n+    SPA_TYPE_VENDOR_PipeWire    = 0x02000000,\n+\n+    SPA_TYPE_VENDOR_Other        = 0x7f000000,\n+};\n+\n+#define SPA_TYPE_INFO_BASE            \"Spa:\"\n+\n+#define SPA_TYPE_INFO_Flags            SPA_TYPE_INFO_BASE \"Flags\"\n+#define SPA_TYPE_INFO_FLAGS_BASE        SPA_TYPE_INFO_Flags \":\"\n+\n+#define SPA_TYPE_INFO_Enum            SPA_TYPE_INFO_BASE \"Enum\"\n+#define SPA_TYPE_INFO_ENUM_BASE            SPA_TYPE_INFO_Enum \":\"\n+\n+#define SPA_TYPE_INFO_Pod            SPA_TYPE_INFO_BASE \"Pod\"\n+#define SPA_TYPE_INFO_POD_BASE            SPA_TYPE_INFO_Pod \":\"\n+\n+#define SPA_TYPE_INFO_Struct            SPA_TYPE_INFO_POD_BASE \"Struct\"\n+#define SPA_TYPE_INFO_STRUCT_BASE        SPA_TYPE_INFO_Struct \":\"\n+\n+#define SPA_TYPE_INFO_Object            SPA_TYPE_INFO_POD_BASE \"Object\"\n+#define SPA_TYPE_INFO_OBJECT_BASE        SPA_TYPE_INFO_Object \":\"\n+\n+#define SPA_TYPE_INFO_Pointer            SPA_TYPE_INFO_BASE \"Pointer\"\n+#define SPA_TYPE_INFO_POINTER_BASE        SPA_TYPE_INFO_Pointer \":\"\n+\n+#define SPA_TYPE_INFO_Interface            SPA_TYPE_INFO_POINTER_BASE \"Interface\"\n+#define SPA_TYPE_INFO_INTERFACE_BASE        SPA_TYPE_INFO_Interface \":\"\n+\n+#define SPA_TYPE_INFO_Event            SPA_TYPE_INFO_OBJECT_BASE \"Event\"\n+#define SPA_TYPE_INFO_EVENT_BASE        SPA_TYPE_INFO_Event \":\"\n+\n+#define SPA_TYPE_INFO_Command            SPA_TYPE_INFO_OBJECT_BASE \"Command\"\n+#define SPA_TYPE_INFO_COMMAND_BASE        SPA_TYPE_INFO_Command \":\"\n+\n+struct spa_type_info {\n+    uint32_t type;\n+    uint32_t parent;\n+    const char *name;\n+    const struct spa_type_info *values;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/type.h","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -859,0 +859,5 @@\n+     * @implNote Returns {@code true} for {@code .lnk} shortcuts only.\n+     * For <i>symbolic links<\/i> and <i>junctions<\/i>, it returns\n+     * {@code false} even though {@code IShellFolder} returns\n+     * {@code true} now. It is a workaround for easier handling of\n+     * symbolic links and junctions.\n@@ -860,0 +865,1 @@\n+\n@@ -862,1 +868,3 @@\n-            cachedIsLink = hasAttribute(ATTRIB_LINK);\n+            cachedIsLink = hasAttribute(ATTRIB_LINK)\n+                           && (!isFileSystem()\n+                               || getPath().toLowerCase().endsWith(\".lnk\"));\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolder2.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * programs running on the JVM. The mechanism for instrumentation is modification\n- * of the byte-codes of methods.\n+ * programs running on the Java Virtual Machine (JVM). The mechanism for\n+ * instrumentation is modification of the bytecodes of methods.\n@@ -35,3 +35,6 @@\n- * <p> An agent is deployed as a JAR file. An attribute in the JAR file manifest\n- * specifies the agent class which will be loaded to start the agent. Agents can\n- * be started in several ways:\n+ * <p> The class files that comprise an agent are packaged into a JAR file, either\n+ * with the application in an executable JAR, or more commonly, as a separate JAR file\n+ * called an <em>agent JAR<\/em>. An attribute in the main manifest of the JAR file\n+ * identifies one of the class files in the JAR file as the <em>agent class<\/em>.\n+ * The agent class defines a special method that the JVM invokes to <em>start<\/em>\n+ * the agent.\n@@ -39,12 +42,4 @@\n- * <ol>\n- *   <li><p> For implementations that support a command-line interface, an agent\n- *   can be started by specifying an option on the command-line. <\/p><\/li>\n- *\n- *   <li><p> An implementation may support a mechanism to start agents some time\n- *   after the VM has started. For example, an implementation may provide a\n- *   mechanism that allows a tool to <i>attach<\/i> to a running application, and\n- *   initiate the loading of the tool's agent into the running application. <\/p><\/li>\n- *\n- *   <li><p> An agent may be packaged with an application in an executable JAR\n- *   file.<\/p><\/li>\n- * <\/ol>\n+ * <p> Agents that are packaged with an application in an executable JAR are started\n+ * at JVM statup time. Agents that are packaged into an agent JAR file may be started\n+ * at JVM startup time via a command line option, or where an implementation supports\n+ * it, started in a running JVM.\n@@ -59,1 +54,29 @@\n- * <p> The three ways to start an agent are described below.\n+ * <h2>Starting an agent<\/h2>\n+ *\n+ * <h3>Starting an agent packaged with an application in an executable JAR file<\/h3>\n+ *\n+ * <p> The <a href=\"{@docRoot}\/..\/specs\/jar\/jar.html\">JAR File Specification<\/a> defines\n+ * manifest attributes for standalone applications that are packaged as <em>executable\n+ * JAR files<\/em>. If an implementation supports a mechanism to start an application as\n+ * an executable JAR, then the main manifest of the JAR file can include the\n+ * {@code Launcher-Agent-Class} attribute to specify the binary name of the Java agent\n+ * class that is packaged with the application. If the attribute is present then the\n+ * JVM starts the agent by loading the agent class and invoking its {@code agentmain}\n+ * method. The method is invoked before the application {@code main} method is invoked.\n+ * The {@code agentmain} method has one of two possible signatures. The JVM first\n+ * attempts to invoke the following method on the agent class:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs, Instrumentation inst)\n+ * }<\/blockquote>\n+ *\n+ * <p> If the agent class does not define this method then the JVM will attempt\n+ * to invoke:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs)\n+ * }<\/blockquote>\n+ *\n+ * <p> The value of the {@code agentArgs} parameter is always the empty string. In\n+ * the first method, the {@code inst} parameter is an {@link Instrumentation} object\n+ * that the agent can use to instrument code.\n@@ -61,1 +84,6 @@\n- * <h2>Starting an Agent from the Command-Line Interface<\/h2>\n+ * <p> The {@code agentmain} method should do any necessary initialization\n+ * required to start the agent and return. If the agent cannot be started, for\n+ * example the agent class cannot be loaded, the agent class does not define a\n+ * conformant {@code agentmain} method, or the {@code agentmain} method throws\n+ * an uncaught exception or error, the JVM will abort before the application\n+ * {@code main} method is invoked.\n@@ -63,3 +91,4 @@\n- * <p> Where an implementation provides a means to start agents from the\n- * command-line interface, an agent is started by adding the following option\n- * to the command-line:\n+ * <h3>Starting an agent from the command-line interface<\/h3>\n+ *\n+ * <p> Where an implementation provides a means to start agents from the command-line\n+ * interface, an agent JAR is specified via the following command line option:\n@@ -74,11 +103,6 @@\n- * <p> The manifest of the agent JAR file must contain the attribute {@code\n- * Premain-Class} in its main manifest. The value of this attribute is the\n- * name of the <i>agent class<\/i>. The agent class must implement a public\n- * static {@code premain} method similar in principle to the {@code main}\n- * application entry point. After the Java Virtual Machine (JVM) has\n- * initialized, the {@code premain} method will be called, then the real\n- * application {@code main} method. The {@code premain} method must return\n- * in order for the startup to proceed.\n- *\n- * <p> The {@code premain} method has one of two possible signatures. The\n- * JVM first attempts to invoke the following method on the agent class:\n+ * <p> The main manifest of the agent JAR file must contain the attribute {@code\n+ * Premain-Class}. The value of this attribute is the binary name of the agent class\n+ * in the JAR file. The JVM starts the agent by loading the agent class and invoking its\n+ * {@code premain} method. The method is invoked before the application {@code main}\n+ * method is invoked. The {@code premain} method has one of two possible signatures.\n+ * The JVM first attempts to invoke the following method on the agent class:\n@@ -90,2 +114,1 @@\n- * <p> If the agent class does not implement this method then the JVM will\n- * attempt to invoke:\n+ * <p> If the agent class does not define this method then the JVM will attempt to invoke:\n@@ -95,4 +118,0 @@\n-\n- * <p> The agent class may also have an {@code agentmain} method for use when\n- * the agent is started after VM startup (see below). When the agent is started\n- * using a command-line option, the {@code agentmain} method is not invoked.\n@@ -100,1 +119,1 @@\n- * <p> Each agent is passed its agent options via the {@code agentArgs} parameter.\n+ * <p> The agent is passed its agent options via the {@code agentArgs} parameter.\n@@ -102,1 +121,3 @@\n- * should be performed by the agent itself.\n+ * should be performed by the agent itself. In the first method, the {@code inst}\n+ * parameter is an {@link Instrumentation} object that the agent can use to instrument\n+ * code.\n@@ -104,4 +125,4 @@\n- * <p> If the agent cannot be started (for example, because the agent class\n- * cannot be loaded, or because the agent class does not have an appropriate\n- * {@code premain} method), the JVM will abort. If a {@code premain} method\n- * throws an uncaught exception, the JVM will abort.\n+ * <p> If the agent cannot be started, for example the agent class cannot be loaded,\n+ * the agent class does not define a conformant {@code premain} method, or the {@code\n+ * premain} method throws an uncaught exception or error, the JVM will abort before\n+ * the application {@code main} method is invoked.\n@@ -117,6 +138,3 @@\n- * <p> There are no modeling restrictions on what the agent {@code premain}\n- * method may do. Anything application {@code main} can do, including creating\n- * threads, is legal from {@code premain}.\n- *\n- *\n- * <h2>Starting an Agent After VM Startup<\/h2>\n+ * <p> The agent class may also have an {@code agentmain} method for use when the agent\n+ * is started after in a running JVM (see below). When the agent is started using a\n+ * command-line option, the {@code agentmain} method is not invoked.\n@@ -124,6 +142,1 @@\n- * <p> An implementation may provide a mechanism to start agents sometime after\n- * the VM has started. The details as to how this is initiated are\n- * implementation specific but typically the application has already started and\n- * its {@code main} method has already been invoked. In cases where an\n- * implementation supports the starting of agents after the VM has started the\n- * following applies:\n+ * <h3>Starting an agent in a running JVM<\/h3>\n@@ -131,0 +144,5 @@\n+ * <p> An implementation may provide a mechanism to start agents in a running JVM (meaning\n+ * after JVM startup). The details as to how this is initiated are implementation specific\n+ * but typically the application has already started, and its {@code main} method has\n+ * already been invoked. Where an implementation supports starting an agent in a running\n+ * JVM, the following applies:\n@@ -133,3 +151,3 @@\n- *   <li><p> The manifest of the agent JAR must contain the attribute {@code\n- *   Agent-Class} in its main manfiest. The value of this attribute is the name\n- *   of the <i>agent class<\/i>. <\/p><\/li>\n+ *   <li><p> The agent class must be packaged into an agent JAR file. The main manifest\n+ *   of the agent JAR file must contain the attribute {@code Agent-Class}. The value of\n+ *   this attribute is the binary name of the agent class in the JAR file. <\/p><\/li>\n@@ -137,2 +155,12 @@\n- *   <li><p> The agent class must implement a public static {@code agentmain}\n- *   method. <\/p><\/li>\n+ *   <li><p> The agent class must define a public static {@code agentmain} method. <\/p><\/li>\n+ *\n+ *   <li><p> The JVM prints a warning on the standard error stream for each agent that it\n+ *   attempts to start in a running JVM. If an agent was previously started (at JVM\n+ *   startup, or started in a running JVM), then it is implementation specific as to whether\n+ *   a warning is printed when attempting to start the same agent a second or subsequent\n+ *   time. Warnings can be disabled by means of an implementation-specific command line\n+ *   option.\n+ *   <p><b>Implementation Note:<\/b> For the HotSpot VM, the JVM option\n+ *   {@code -XX:+EnableDynamicAgentLoading} is used to opt-in to allow dynamic loading of\n+ *   agents into a running JVM. This option suppresses the warning to standard error when\n+ *   starting an agent in a running JVM. <\/p><\/li>\n@@ -142,2 +170,3 @@\n- * <p> The {@code agentmain} method has one of two possible signatures. The JVM\n- * first attempts to invoke the following method on the agent class:\n+ * <p> The JVM starts the agent by loading the agent class and invoking its {@code\n+ * agentmain} method. The {@code agentmain} method has one of two possible signatures.\n+ * The JVM first attempts to invoke the following method on the agent class:\n@@ -149,1 +178,1 @@\n- * <p> If the agent class does not implement this method then the JVM will\n+ * <p> If the agent class does not define this method then the JVM will\n@@ -156,7 +185,5 @@\n- * <p> The agent class may also have a {@code premain} method for use when the\n- * agent is started using a command-line option. When the agent is started after\n- * VM startup the {@code premain} method is not invoked.\n- *\n- * <p> The agent is passed its agent options via the {@code agentArgs}\n- * parameter. The agent options are passed as a single string, any additional\n- * parsing should be performed by the agent itself.\n+ * <p> The agent is passed its agent options via the {@code agentArgs} parameter.\n+ * The agent options are passed as a single string, any additional parsing\n+ * should be performed by the agent itself. In the first method, the {@code inst}\n+ * parameter is an {@link Instrumentation} object that the agent can use to instrument\n+ * code.\n@@ -172,30 +199,3 @@\n- *\n- * <h2>Including an Agent in an Executable JAR file<\/h2>\n- *\n- * <p> The JAR File Specification defines manifest attributes for standalone\n- * applications that are packaged as <em>executable JAR files<\/em>. If an\n- * implementation supports a mechanism to start an application as an executable\n- * JAR then the main manifest may include the {@code Launcher-Agent-Class}\n- * attribute to specify the class name of an agent to start before the application\n- * {@code main} method is invoked. The Java virtual machine attempts to\n- * invoke the following method on the agent class:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs, Instrumentation inst)\n- * }<\/blockquote>\n- *\n- * <p> If the agent class does not implement this method then the JVM will\n- * attempt to invoke:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs)\n- * }<\/blockquote>\n- *\n- * <p> The value of the {@code agentArgs} parameter is always the empty string.\n- *\n- * <p> The {@code agentmain} method should do any necessary initialization\n- * required to start the agent and return. If the agent cannot be started, for\n- * example the agent class cannot be loaded, the agent class does not define a\n- * conformant {@code agentmain} method, or the {@code agentmain} method throws\n- * an uncaught exception or error, the JVM will abort.\n- *\n+ * <p> The agent class may also have a {@code premain} method for use when the agent\n+ * is started using a command-line option. The {@code premain} method is not invoked\n+ * when the agent is started in a running JVM.\n@@ -251,1 +251,1 @@\n- * <h2>Manifest Attributes<\/h2>\n+ * <h2>JAR File Manifest Attributes<\/h2>\n@@ -253,1 +253,2 @@\n- * <p> The following manifest attributes are defined for an agent JAR file:\n+ * <p> The following attributes in the main section of the application or agent\n+ * JAR file manifest are defined for Java agents:\n@@ -257,0 +258,7 @@\n+ * <dt>{@code Launcher-Agent-Class}<\/dt>\n+ * <dd> If an implementation supports a mechanism to start an application in an\n+ * executable JAR file, then this attribute, if present, specifies the binary name\n+ * of the agent class that is packaged with the application.\n+ * The agent is started by invoking the agent class {@code agentmain} method. It is\n+ * invoked before the application {@code main} method is invoked. <\/dd>\n+ *\n@@ -258,5 +266,5 @@\n- * <dd> When an agent is specified at JVM launch time this attribute specifies\n- * the agent class. That is, the class containing the {@code premain} method.\n- * When an agent is specified at JVM launch time this attribute is required. If\n- * the attribute is not present the JVM will abort. Note: this is a class name,\n- * not a file name or path. <\/dd>\n+ * <dd> If an agent JAR is specified at JVM launch time, this attribute specifies\n+ * the binary name of the agent class in the JAR file.\n+ * The agent is started by invoking the agent class {@code premain} method. It is\n+ * invoked before the application {@code main} method is invoked.\n+ * If the attribute is not present the JVM will abort. <\/dd>\n@@ -265,11 +273,5 @@\n- * <dd> If an implementation supports a mechanism to start agents sometime after\n- * the VM has started then this attribute specifies the agent class. That is,\n- * the class containing the {@code agentmain} method. This attribute is required\n- * if it is not present the agent will not be started. Note: this is a class name,\n- * not a file name or path. <\/dd>\n- *\n- * <dt>{@code Launcher-Agent-Class}<\/dt>\n- * <dd> If an implementation supports a mechanism to start an application as an\n- * executable JAR then the main manifest may include this attribute to specify\n- * the class name of an agent to start before the application {@code main}\n- * method is invoked. <\/dd>\n+ * <dd> If an implementation supports a mechanism to start an agent sometime after\n+ * the JVM has started, then this attribute specifies the binary name of the Java\n+ * agent class in the agent JAR file.\n+ * The agent is started by invoking the agent class {@code agentmain} method.\n+ * This attribute is required; if not present the agent will not be started. <\/dd>\n@@ -287,1 +289,1 @@\n- * started sometime after the VM has started then paths that do not represent a\n+ * started sometime after the JVM has started then paths that do not represent a\n@@ -313,1 +315,1 @@\n- * Premain-Class} attribute specifies the name of the agent class and the {@code\n+ * Premain-Class} attribute specifies the binary name of the agent class and the {@code\n@@ -315,2 +317,2 @@\n- * after the VM has started, then the {@code Agent-Class} attribute specifies\n- * the name of the agent class (the value of {@code Premain-Class} attribute is\n+ * after the JVM has started, then the {@code Agent-Class} attribute specifies\n+ * the binary name of the agent class (the value of {@code Premain-Class} attribute is\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/package-info.java","additions":127,"deletions":125,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.nio.file.InvalidPathException;\n+import java.net.URL;\n@@ -36,0 +40,1 @@\n+import java.security.CodeSource;\n@@ -46,1 +51,1 @@\n-\n+import java.util.stream.Collectors;\n@@ -62,0 +67,9 @@\n+    private static final String TRACE_USAGE_PROP_NAME = \"jdk.instrument.traceUsage\";\n+    private static final boolean TRACE_USAGE;\n+    static {\n+        PrivilegedAction<String> pa = () -> System.getProperty(TRACE_USAGE_PROP_NAME);\n+        @SuppressWarnings(\"removal\")\n+        String s = AccessController.doPrivileged(pa);\n+        TRACE_USAGE = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+    }\n+\n@@ -74,1 +88,2 @@\n-                        boolean environmentSupportsNativeMethodPrefix) {\n+                        boolean environmentSupportsNativeMethodPrefix,\n+                        boolean printWarning) {\n@@ -82,0 +97,30 @@\n+\n+        if (printWarning) {\n+            String source = jarFile(nativeAgent);\n+            try {\n+                Path path = Path.of(source);\n+                PrivilegedAction<Path> pa = path::toAbsolutePath;\n+                @SuppressWarnings(\"removal\")\n+                Path absolutePath = AccessController.doPrivileged(pa);\n+                source = absolutePath.toString();\n+            } catch (InvalidPathException e) {\n+                \/\/ use original path\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"WARNING: A Java agent has been loaded dynamically (\")\n+                    .append(source)\n+                    .append(\")\")\n+                    .append(System.lineSeparator());\n+            sb.append(\"WARNING: If a serviceability tool is in use, please run with\"\n+                            + \" -XX:+EnableDynamicAgentLoading to hide this warning\")\n+                    .append(System.lineSeparator());\n+            if (!TRACE_USAGE) {\n+                sb.append(\"WARNING: If a serviceability tool is not in use, please run with\"\n+                                + \" -D\" + TRACE_USAGE_PROP_NAME + \" for more information\")\n+                        .append(System.lineSeparator());\n+            }\n+            sb.append(\"WARNING: Dynamic loading of agents will be disallowed by default in a future release\");\n+            String warningMessage = sb.toString();\n+            System.err.println(warningMessage);\n+        }\n@@ -84,2 +129,2 @@\n-    public void\n-    addTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer) {\n@@ -89,2 +134,3 @@\n-    public synchronized void\n-    addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+        trace(\"addTransformer\");\n@@ -94,16 +140,18 @@\n-        if (canRetransform) {\n-            if (!isRetransformClassesSupported()) {\n-                throw new UnsupportedOperationException(\n-                  \"adding retransformable transformers is not supported in this environment\");\n-            }\n-            if (mRetransfomableTransformerManager == null) {\n-                mRetransfomableTransformerManager = new TransformerManager(true);\n-            }\n-            mRetransfomableTransformerManager.addTransformer(transformer);\n-            if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n-                setHasRetransformableTransformers(mNativeAgent, true);\n-            }\n-        } else {\n-            mTransformerManager.addTransformer(transformer);\n-            if (mTransformerManager.getTransformerCount() == 1) {\n-                setHasTransformers(mNativeAgent, true);\n+        synchronized (this) {\n+            if (canRetransform) {\n+                if (!isRetransformClassesSupported()) {\n+                    throw new UnsupportedOperationException(\n+                        \"adding retransformable transformers is not supported in this environment\");\n+                }\n+                if (mRetransfomableTransformerManager == null) {\n+                    mRetransfomableTransformerManager = new TransformerManager(true);\n+                }\n+                mRetransfomableTransformerManager.addTransformer(transformer);\n+                if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n+                    setHasRetransformableTransformers(mNativeAgent, true);\n+                }\n+            } else {\n+                mTransformerManager.addTransformer(transformer);\n+                if (mTransformerManager.getTransformerCount() == 1) {\n+                    setHasTransformers(mNativeAgent, true);\n+                }\n@@ -114,2 +162,3 @@\n-    public synchronized boolean\n-    removeTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public boolean removeTransformer(ClassFileTransformer transformer) {\n+        trace(\"removeTransformer\");\n@@ -119,8 +168,10 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr != null) {\n-            mgr.removeTransformer(transformer);\n-            if (mgr.getTransformerCount() == 0) {\n-                if (mgr.isRetransformable()) {\n-                    setHasRetransformableTransformers(mNativeAgent, false);\n-                } else {\n-                    setHasTransformers(mNativeAgent, false);\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr != null) {\n+                mgr.removeTransformer(transformer);\n+                if (mgr.getTransformerCount() == 0) {\n+                    if (mgr.isRetransformable()) {\n+                        setHasRetransformableTransformers(mNativeAgent, false);\n+                    } else {\n+                        setHasTransformers(mNativeAgent, false);\n+                    }\n@@ -128,0 +179,1 @@\n+                return true;\n@@ -129,1 +181,1 @@\n-            return true;\n+            return false;\n@@ -131,1 +183,0 @@\n-        return false;\n@@ -134,2 +185,3 @@\n-    public boolean\n-    isModifiableClass(Class<?> theClass) {\n+    @Override\n+    public boolean isModifiableClass(Class<?> theClass) {\n+        trace(\"isModifiableClass\");\n@@ -143,0 +195,1 @@\n+    @Override\n@@ -144,0 +197,1 @@\n+        trace(\"isModifiableModule\");\n@@ -150,2 +204,3 @@\n-    public boolean\n-    isRetransformClassesSupported() {\n+    @Override\n+    public boolean isRetransformClassesSupported() {\n+        trace(\"isRetransformClassesSupported\");\n@@ -160,2 +215,3 @@\n-    public void\n-    retransformClasses(Class<?>... classes) {\n+    @Override\n+    public void retransformClasses(Class<?>... classes) {\n+        trace(\"retransformClasses\");\n@@ -172,2 +228,3 @@\n-    public boolean\n-    isRedefineClassesSupported() {\n+    @Override\n+    public boolean isRedefineClassesSupported() {\n+        trace(\"isRedefineClassesSupported\");\n@@ -177,3 +234,3 @@\n-    public void\n-    redefineClasses(ClassDefinition...  definitions)\n-            throws  ClassNotFoundException {\n+    @Override\n+    public void redefineClasses(ClassDefinition... definitions) throws ClassNotFoundException {\n+        trace(\"retransformClasses\");\n@@ -194,1 +251,0 @@\n-\n@@ -198,0 +254,1 @@\n+    @Override\n@@ -199,2 +256,2 @@\n-    public Class[]\n-    getAllLoadedClasses() {\n+    public Class[] getAllLoadedClasses() {\n+        trace(\"getAllLoadedClasses\");\n@@ -204,0 +261,1 @@\n+    @Override\n@@ -205,2 +263,2 @@\n-    public Class[]\n-    getInitiatedClasses(ClassLoader loader) {\n+    public Class[] getInitiatedClasses(ClassLoader loader) {\n+        trace(\"getInitiatedClasses\");\n@@ -210,2 +268,3 @@\n-    public long\n-    getObjectSize(Object objectToSize) {\n+    @Override\n+    public long getObjectSize(Object objectToSize) {\n+        trace(\"getObjectSize\");\n@@ -218,2 +277,3 @@\n-    public void\n-    appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToBootstrapClassLoaderSearch\");\n@@ -223,2 +283,3 @@\n-    public void\n-    appendToSystemClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToSystemClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToSystemClassLoaderSearch\");\n@@ -228,2 +289,3 @@\n-    public boolean\n-    isNativeMethodPrefixSupported() {\n+    @Override\n+    public boolean isNativeMethodPrefixSupported() {\n+        trace(\"isNativeMethodPrefixSupported\");\n@@ -233,2 +295,3 @@\n-    public synchronized void\n-    setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+    @Override\n+    public void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+        trace(\"setNativeMethodPrefix\");\n@@ -243,4 +306,9 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr == null) {\n-            throw new IllegalArgumentException(\n-                       \"transformer not registered in setNativeMethodPrefix\");\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr == null) {\n+                throw new IllegalArgumentException(\n+                        \"transformer not registered in setNativeMethodPrefix\");\n+            }\n+            mgr.setNativeMethodPrefix(transformer, prefix);\n+            String[] prefixes = mgr.getNativeMethodPrefixes();\n+            setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -248,3 +316,0 @@\n-        mgr.setNativeMethodPrefix(transformer, prefix);\n-        String[] prefixes = mgr.getNativeMethodPrefixes();\n-        setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -261,0 +326,2 @@\n+        trace(\"redefineModule\");\n+\n@@ -300,1 +367,0 @@\n-\n@@ -354,2 +420,2 @@\n-    private TransformerManager\n-    findTransformerManager(ClassFileTransformer transformer) {\n+    private TransformerManager findTransformerManager(ClassFileTransformer transformer) {\n+        assert Thread.holdsLock(this);\n@@ -370,0 +436,3 @@\n+    private native\n+    String jarFile(long nativeAgent);\n+\n@@ -560,0 +629,57 @@\n+\n+    \/**\n+     * Prints a trace message and stack trace when tracing is enabled.\n+     *\/\n+    private void trace(String methodName) {\n+        if (!TRACE_USAGE) return;\n+\n+        \/\/ stack trace without frames in java.instrument module\n+        List<StackWalker.StackFrame> stack = HolderStackWalker.walker.walk(s ->\n+            s.dropWhile(f -> f.getDeclaringClass().getModule() == Instrumentation.class.getModule())\n+                .collect(Collectors.toList())\n+        );\n+\n+        \/\/ for tracing purposes, use the direct caller to code in java.instrument as the source\n+        if (stack.size() > 0) {\n+            Class<?> callerClass = stack.get(0).getDeclaringClass();\n+            URL callerUrl = codeSource(callerClass);\n+            String source;\n+            if (callerUrl == null) {\n+                source = callerClass.getName();\n+            } else {\n+                source = callerClass.getName() + \" (\" + callerUrl + \")\";\n+            }\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"java.lang.instrument.Instrumentation.\")\n+                    .append(methodName)\n+                    .append(\" has been called by \")\n+                    .append(source);\n+            stack.forEach(f -> sb.append(System.lineSeparator()).append(\"\\tat \" + f));\n+            String traceMessage = sb.toString();\n+            System.out.println(traceMessage);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the possibly-bnull code source of the given class.\n+     *\/\n+    private static URL codeSource(Class<?> clazz) {\n+        PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        return (cs != null) ? cs.getLocation() : null;\n+    }\n+\n+    \/**\n+     * Holder for StackWalker object.\n+     *\/\n+    private static class HolderStackWalker {\n+        static final StackWalker walker;\n+        static {\n+            PrivilegedAction<StackWalker> pa = () ->\n+                    StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            @SuppressWarnings(\"removal\")\n+            StackWalker w = AccessController.doPrivileged(pa);\n+            walker = w;\n+        }\n+    }\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":197,"deletions":71,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,12 @@\n+\n+\/*\n+ * Class:     sun_instrument_InstrumentationImpl\n+ * Method:    jarFile\n+ * Signature: (J)Ljava\/lang\/String;\n+ *\/\n+JNIEXPORT jstring JNICALL\n+Java_sun_instrument_InstrumentationImpl_jarFile\n+  (JNIEnv * jnienv, jobject implThis, jlong agent) {\n+    return jarFile(jnienv, (JPLISAgent*)(intptr_t)agent);\n+}\n+\n@@ -60,1 +72,1 @@\n- * Signature: (Ljava\/lang\/Class;)Z\n+ * Signature: (JLjava\/lang\/Class;)Z\n@@ -71,1 +83,1 @@\n- * Signature: ()Z\n+ * Signature: (J)Z\n@@ -82,1 +94,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -93,1 +105,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -104,1 +116,1 @@\n- * Signature: ([Ljava\/lang\/Class;)V\n+ * Signature: (J[Ljava\/lang\/Class;)V\n@@ -115,1 +127,1 @@\n- * Signature: ([Ljava\/lang\/instrument\/ClassDefinition;)V\n+ * Signature: (J[Ljava\/lang\/instrument\/ClassDefinition;)V\n@@ -125,1 +137,1 @@\n- * Signature: ()[Ljava\/lang\/Class;\n+ * Signature: (J)[Ljava\/lang\/Class;\n@@ -135,1 +147,1 @@\n- * Signature: (Ljava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n+ * Signature: (JLjava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n@@ -145,1 +157,1 @@\n- * Signature: (Ljava\/lang\/Object;)J\n+ * Signature: (JLjava\/lang\/Object;)J\n@@ -156,1 +168,1 @@\n- * Signature: (Ljava\/lang\/String;Z)V\n+ * Signature: (JLjava\/lang\/String;Z)V\n@@ -167,1 +179,1 @@\n- * Signature: ([Ljava\/lang\/String;Z)V\n+ * Signature: (J[Ljava\/lang\/String;Z)V\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InstrumentationImplNativeMethods.c","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -150,0 +150,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -151,1 +153,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n+        fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE);\n@@ -154,2 +164,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -160,8 +168,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n-            fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n-            return JNI_ERR;\n-        }\n-\n@@ -195,3 +195,0 @@\n-        \/* Save the jarfile name *\/\n-        agent->mJarfile = jarfile;\n-\n@@ -257,1 +254,0 @@\n-        if (options != NULL) free(options);\n@@ -262,0 +258,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -310,0 +311,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -318,1 +321,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(args, &jarfile, &options) != 0) {\n+        return JNI_ENOMEM;\n+    }\n+\n+    jboolean print_warning = JVM_PrintWarningAtDynamicAgentLoad();\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, print_warning);\n@@ -321,2 +332,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -328,7 +337,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(args, &jarfile, &options) != 0) {\n-            return JNI_ENOMEM;\n-        }\n-\n@@ -453,2 +455,0 @@\n-        free(jarfile);\n-        if (options != NULL) free(options);\n@@ -459,0 +459,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE || result != JNI_OK) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -489,5 +494,0 @@\n-    \/\/ create JPLISAgent with JVMTI environment\n-    if (createNewJPLISAgent(vm, &agent) != JPLIS_INIT_ERROR_NONE) {\n-        return JNI_ERR;\n-    }\n-\n@@ -500,0 +500,6 @@\n+    \/\/ create JPLISAgent with JVMTI environment\n+    if (createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE) != JPLIS_INIT_ERROR_NONE) {\n+        (*env)->ReleaseStringUTFChars(env, path, jarfile);\n+        return JNI_ERR;\n+    }\n+\n@@ -573,1 +579,1 @@\n-    if (jarfile != NULL) {\n+    if (result != JNI_OK && jarfile != NULL) {\n@@ -615,2 +621,0 @@\n-    free((void *)agent->mJarfile);\n-    agent->mJarfile = NULL;\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InvocationAdapter.c","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -66,1 +66,3 @@\n-                        jvmtiEnv *      jvmtienv);\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning);\n@@ -205,1 +207,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr) {\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning) {\n@@ -223,1 +225,3 @@\n-                                               jvmtienv);\n+                                               jvmtienv,\n+                                               jarfile,\n+                                               printWarning);\n@@ -254,1 +258,3 @@\n-                        jvmtiEnv *      jvmtienv) {\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning) {\n@@ -275,1 +281,2 @@\n-    agent->mJarfile                                  = NULL;\n+    agent->mJarfile                                  = jarfile;\n+    agent->mPrintWarning                             = printWarning;\n@@ -515,1 +522,2 @@\n-                                                agent->mNativeMethodPrefixAdded);\n+                                                agent->mNativeMethodPrefixAdded,\n+                                                agent->mPrintWarning);\n@@ -1608,0 +1616,5 @@\n+\n+jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent) {\n+    return (*jnienv)->NewStringUTF(jnienv, agent->mJarfile);\n+}\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.c","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZ)V\"\n+#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZZ)V\"\n@@ -111,0 +111,1 @@\n+    jboolean                mPrintWarning;          \/* print warning when started *\/\n@@ -154,1 +155,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr);\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning);\n@@ -275,0 +276,3 @@\n+extern jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent);\n+\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.h","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -345,0 +345,7 @@\n+    protected long getTotalThreadAllocatedBytes() {\n+        if (isThreadAllocatedMemoryEnabled()) {\n+            return getTotalThreadAllocatedMemory();\n+        }\n+        return -1;\n+    }\n+\n@@ -528,0 +535,1 @@\n+    private static native long getTotalThreadAllocatedMemory();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ThreadImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n+    return jmm_interface->GetOneThreadAllocatedMemory(env, tid);\n@@ -111,0 +111,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_ThreadImpl_getTotalThreadAllocatedMemory\n+  (JNIEnv *env, jclass cls)\n+{\n+    return jmm_interface->GetTotalThreadAllocatedMemory(env);\n+}\n+\n","filename":"src\/java.management\/share\/native\/libmanagement\/ThreadImpl.c","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,0 +114,5 @@\n+    @Override\n+    void close(Throwable cause) {\n+        plainConnection.close(cause);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLConnection.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,5 @@\n+    @Override\n+    void close(Throwable cause) {\n+        plainConnection.close(cause);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+        private volatile Throwable cause;\n@@ -159,1 +160,1 @@\n-            if (closeRequested) closeConnection(connection);\n+            if (closeRequested) closeConnection(connection, cause);\n@@ -162,1 +163,1 @@\n-        void closeConnection() {\n+        void closeConnection(Throwable error) {\n@@ -164,0 +165,1 @@\n+            Throwable cause;\n@@ -165,0 +167,4 @@\n+                cause = this.cause;\n+                if (cause == null) {\n+                    cause = error;\n+                }\n@@ -168,0 +174,1 @@\n+                    this.cause = cause;\n@@ -170,0 +177,1 @@\n+                    this.cause = null;\n@@ -172,1 +180,1 @@\n-            closeConnection(connection);\n+            closeConnection(connection, cause);\n@@ -181,0 +189,1 @@\n+                this.cause = null;\n@@ -185,1 +194,1 @@\n-        private static void closeConnection(HttpConnection connection) {\n+        private static void closeConnection(HttpConnection connection, Throwable cause) {\n@@ -188,1 +197,1 @@\n-                    connection.close();\n+                    connection.close(cause);\n@@ -267,1 +276,9 @@\n-            failed = cause;\n+            IOException failed = this.failed;\n+            if (failed == null) {\n+                synchronized (this) {\n+                    failed = this.failed;\n+                    if (failed == null) {\n+                        failed = this.failed = cause;\n+                    }\n+                }\n+            }\n@@ -271,1 +288,1 @@\n-            connectionAborter.closeConnection();\n+            connectionAborter.closeConnection(failed);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,3 +101,1 @@\n-        URI uri = req.uri();\n-        InetSocketAddress proxy = req.proxy();\n-        String key = Http2Connection.keyFor(uri, proxy);\n+        String key = Http2Connection.keyFor(req);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-             keyFor(request.uri(), request.proxy()));\n+             keyFor(request));\n@@ -598,6 +598,5 @@\n-    static String keyFor(URI uri, InetSocketAddress proxy) {\n-        boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n-\n-        String host = uri.getHost();\n-        int port = uri.getPort();\n-        return keyString(isSecure, proxy, host, port);\n+    static String keyFor(final HttpRequestImpl request) {\n+        final InetSocketAddress targetAddr = request.getAddress();\n+        final InetSocketAddress proxy = request.proxy();\n+        final boolean secure = request.secure();\n+        return keyString(secure, proxy, targetAddr.getHostString(), targetAddr.getPort());\n@@ -606,1 +605,0 @@\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,1 +430,1 @@\n-     * Closes this connection, by returning the socket to its connection pool.\n+     * Closes this connection.\n@@ -435,0 +435,8 @@\n+    \/**\n+     * Closes this connection due to the given cause.\n+     * @param cause the cause for which the connection is closed, may be null\n+     *\/\n+    void close(Throwable cause) {\n+        close();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -62,0 +63,1 @@\n+    private final ReentrantLock stateLock = new ReentrantLock();\n@@ -243,1 +245,2 @@\n-        synchronized (this) {\n+        stateLock.lock();\n+        try {\n@@ -245,3 +248,8 @@\n-        }\n-        if (!closed) {\n-            client().connectionOpened(this);\n+            if (!closed) {\n+                client().connectionOpened(this);\n+            }\n+            \/\/ connectionOpened might call close() if the client\n+            \/\/ is shutting down.\n+            closed = this.closed;\n+        } finally {\n+            stateLock.unlock();\n@@ -396,3 +404,0 @@\n-    \/**\n-     * Closes this connection\n-     *\/\n@@ -401,6 +406,8 @@\n-        synchronized (this) {\n-            if (closed) {\n-                return;\n-            }\n-            closed = true;\n-        }\n+        close(null);\n+    }\n+\n+    @Override\n+    void close(Throwable cause) {\n+        var closed = this.closed;\n+        if (closed) return;\n+        stateLock.lock();\n@@ -408,0 +415,2 @@\n+            if (closed = this.closed) return;\n+            closed = this.closed = true;\n@@ -411,0 +420,1 @@\n+            var connectTimerEvent = this.connectTimerEvent;\n@@ -418,1 +428,1 @@\n-                tube.signalClosed();\n+                tube.signalClosed(cause);\n@@ -423,0 +433,1 @@\n+            debug.log(\"Closing resulted in \" + e);\n@@ -424,0 +435,2 @@\n+        } finally {\n+            stateLock.unlock();\n@@ -434,1 +447,1 @@\n-    synchronized boolean connected() {\n+    boolean connected() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -160,1 +160,6 @@\n-        delegate.close();\n+        close(null);\n+    }\n+\n+    @Override\n+    void close(Throwable cause) {\n+        delegate.close(cause);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-    void signalClosed() {\n+    void signalClosed(Throwable cause) {\n@@ -160,1 +160,1 @@\n-                new IOException(\"connection closed locally\"));\n+                new IOException(\"connection closed locally\", cause));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-                handleResponse();\n+                handleResponse(hf);\n@@ -514,1 +514,1 @@\n-    protected void handleResponse() throws IOException {\n+    protected void handleResponse(HeaderFrame hf) throws IOException {\n@@ -522,1 +522,1 @@\n-            if (responseCode < 100 || responseCode > 199)\n+            if (responseCode < 100 || responseCode > 199) {\n@@ -524,0 +524,12 @@\n+            } else if (hf.getFlag(HeaderFrame.END_STREAM)) {\n+                \/\/ see RFC 9113 section 8.1:\n+                \/\/ A HEADERS frame with the END_STREAM flag set that carries an\n+                \/\/ informational status code is malformed\n+                String msg = (\"Stream %s PROTOCOL_ERROR: \" +\n+                        \"HEADERS frame with status %s has END_STREAM flag set\")\n+                        .formatted(streamid, responseCode);\n+                if (debug.on()) {\n+                    debug.log(msg);\n+                }\n+                cancelImpl(new IOException(msg), ResetFrame.PROTOCOL_ERROR);\n+            }\n@@ -570,0 +582,4 @@\n+                    if (debug.on()) {\n+                        debug.log(\"completing requestBodyCF exceptionally due to received\" +\n+                                \" RESET(%s) (stream=%s)\", frame.getErrorCode(), streamid);\n+                    }\n@@ -572,0 +588,4 @@\n+                    if (debug.on()) {\n+                        debug.log(\"completing requestBodyCF normally due to received\" +\n+                                \" RESET(NO_ERROR) (stream=%s)\", streamid);\n+                    }\n@@ -575,1 +595,1 @@\n-            if (response == null && subscriber == null) {\n+            if ((response == null || !finalResponseCodeReceived) && subscriber == null) {\n@@ -953,0 +973,4 @@\n+                if (debug.on()) {\n+                    debug.log(\"RequestSubscriber: requestBodyCf is done: \" +\n+                            \"cancelling subscription\");\n+                }\n@@ -1531,1 +1555,1 @@\n-        protected void handleResponse() {\n+        protected void handleResponse(HeaderFrame hf) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2107,4 +2107,4 @@\n-        \"The target VM may not support, or may only provide limited support, for \"\n-        \"this command when the thread is a virtual thread. It may, for example, \"\n-        \"only support this command when the virtual thread is suspended at a \"\n-        \"breakpoint or singlestep event.\"\n+        \"This command may be used to force a return from the current frame \"\n+        \"of a virtual thread when it is suspended at an event. \"\n+        \"An implementation may support forcing a return from the current frame \"\n+        \"of a suspended virtual thread in other cases.\"\n@@ -2150,1 +2150,1 @@\n-                                     \"the thread is a virtual thread and the target \"\n+                                     \"the thread is a suspended virtual thread and the target \"\n@@ -2644,1 +2644,1 @@\n-        \"suspended at a breakpoint or single step event. The target VM may support \"\n+        \"suspended at an event. The target VM may support \"\n@@ -2662,1 +2662,1 @@\n-            (Error OPAQUE_FRAME      \"The thread is a virtual thread and the target VM \"\n+            (Error OPAQUE_FRAME      \"The thread is a suspended virtual thread and the target VM \"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -674,0 +674,3 @@\n+        if (DEBUG) {\n+            System.out.println(\"Loading config file from \" + fileName);\n+        }\n@@ -784,0 +787,3 @@\n+            if (DEBUG) {\n+                System.out.println(line);\n+            }\n@@ -982,0 +988,3 @@\n+            if (DEBUG) {\n+                System.out.println(\"Getting permitted_enctypes from libdefaults\");\n+            }\n@@ -987,1 +996,1 @@\n-                System.out.println(\"Using builtin default etypes for \" +\n+                System.out.println(\"default_enctypes were null, using builtin default etypes for configuration \" +\n@@ -992,0 +1001,3 @@\n+            if (DEBUG) {\n+                System.out.println(\"default_enctypes:\" + default_enctypes);\n+            }\n@@ -1013,1 +1025,2 @@\n-                throw new KrbException(\"no supported default etypes for \"\n+                throw new KrbException(\"out of \" + len +\n+                        \" default etypes no supported etypes found for configuration \"\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Config.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Mar 2023\n@@ -208,1 +208,1 @@\n-            value = SecuritySupport.readJAXPProperty(systemProperty);\n+            value = SecuritySupport.readConfig(systemProperty);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/utils\/FeaturePropertyBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Mar 2023\n@@ -151,1 +151,1 @@\n-            return attributes.get(pName);\n+            return fSecurityManager.getLimitAsString(pName);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/DocumentBuilderFactoryImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,1 @@\n-     * Read from system properties, or those in jaxp.properties\n+     * Read system properties, or the configuration file\n@@ -518,1 +518,0 @@\n-\n@@ -520,8 +519,5 @@\n-            if (!getSystemProperty(limit, limit.systemProperty())) {\n-                \/\/if system property is not found, try the older form if any\n-                for (NameMap nameMap : NameMap.values()) {\n-                    String oldName = nameMap.getOldName(limit.systemProperty());\n-                    if (oldName != null) {\n-                        getSystemProperty(limit, oldName);\n-                    }\n-                }\n+            \/\/ attempts to read both the current and old system propery\n+            if (!getSystemProperty(limit, limit.systemProperty())\n+                    && (!getOldSystemProperty(limit))) {\n+                \/\/if system property is not found, try the config file\n+                getPropertyConfig(limit, limit.systemProperty());\n@@ -530,1 +526,0 @@\n-\n@@ -551,1 +546,1 @@\n-     * Read from system properties, or those in jaxp.properties\n+     * Reads a system property, sets value and state if found.\n@@ -553,1 +548,1 @@\n-     * @param property the type of the property\n+     * @param limit the limit property\n@@ -564,0 +559,6 @@\n+        } catch (NumberFormatException e) {\n+            \/\/invalid setting\n+            throw new NumberFormatException(\"Invalid setting for system property: \" + limit.systemProperty());\n+        }\n+        return false;\n+    }\n@@ -565,1 +566,29 @@\n-            value = SecuritySupport.readJAXPProperty(sysPropertyName);\n+    \/**\n+     * Reads the legacy system property.\n+     * @param limit a limit object\n+     * @return true if found, false otherwise\n+     *\/\n+    private boolean getOldSystemProperty(Limit limit) {\n+        boolean found = false;\n+        for (NameMap nameMap : NameMap.values()) {\n+            String oldName = nameMap.getOldName(limit.systemProperty());\n+            if (oldName != null) {\n+                if (getSystemProperty(limit, oldName)) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return found;\n+    }\n+\n+    \/**\n+     * Reads a property from a configuration file, if any.\n+     *\n+     * @param limit the limit property\n+     * @param sysPropertyName the name of system property\n+     * @return\n+     *\/\n+    private boolean getPropertyConfig(Limit limit, String sysPropertyName) {\n+        try {\n+            String value = SecuritySupport.readConfig(sysPropertyName);\n@@ -578,1 +607,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/utils\/XMLSecurityManager.java","additions":44,"deletions":16,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-            value = SecuritySupport.readJAXPProperty(systemProperty);\n+            value = SecuritySupport.readConfig(systemProperty);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/utils\/XMLSecurityPropertyManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,49 @@\n- * <p>Utility class to contain basic XML values as constants.\n+ * Defines constants for XML Processing APIs.\n+ *\n+ * <h2 id=\"EAP\">External Access Properties<\/h2>\n+ * The value of the external access properties, including {@link #ACCESS_EXTERNAL_DTD},\n+ * {@link #ACCESS_EXTERNAL_SCHEMA}, and {@link #ACCESS_EXTERNAL_STYLESHEET},\n+ * is defined as follows.\n+ *\n+ * <h3 id=\"EAPValue\">Value:<\/h3>\n+ * A list of protocols separated by comma. A protocol is the scheme portion of a\n+ * {@link java.net.URI}, or in the case of the JAR protocol, \"jar\" plus the scheme\n+ * portion separated by colon. A scheme is defined as:\n+ *\n+ * <blockquote>\n+ * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )<br>\n+ * where alpha = a-z and A-Z.<br><br>\n+ *\n+ * And the JAR protocol:<br>\n+ *\n+ * jar[:scheme]<br><br>\n+ *\n+ * Protocols including the keyword \"jar\" are case-insensitive. Any whitespaces as defined by\n+ * {@link java.lang.Character#isSpaceChar } in the value will be ignored.\n+ * Examples of protocols are file, http, jar:file.\n+ *\n+ * <\/blockquote>\n+ *\n+ * <h3>Default value:<\/h3>\n+ * The default value is implementation specific and therefore not specified.\n+ * The following options are provided for consideration:\n+ * <blockquote>\n+ * <UL>\n+ *     <LI>an empty string to deny all access to external references;<\/LI>\n+ *     <LI>a specific protocol, such as file, to give permission to only the protocol;<\/LI>\n+ *     <LI>the keyword \"all\" to grant  permission to all protocols.<\/LI>\n+ * <\/UL><br>\n+ *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations\n+ *      restrict external connections by default, though this may cause problems for applications\n+ *      that process XML\/XSD\/XSL with external references.\n+ * <\/blockquote>\n+ *\n+ * <h3>Granting all access:<\/h3>\n+ * The keyword \"all\" grants permission to all protocols.\n+ *\n+ * <h2 id=\"PropPrec\">Property Precedence<\/h2>\n+ * Properties, including the <a href=\"#EAP\">External Access Properties<\/a> and\n+ * {@link #USE_CATALOG}, can be specified through multiple configuration sources.\n+ * They follow the configuration process as defined in the\n+ * <a href=\"{@docRoot}\/java.xml\/module-summary.html#Conf\">Configuration<\/a> section\n+ * of the module summary.\n@@ -187,0 +235,4 @@\n+         *\n+         * @implNote\n+         * when the Java Security Manager is present, the JDK sets the value of\n+         * this feature to true and does not allow it to be turned off.\n@@ -201,35 +253,1 @@\n-         * <b>Value: <\/b> a list of protocols separated by comma. A protocol is the scheme portion of a\n-         * {@link java.net.URI}, or in the case of the JAR protocol, \"jar\" plus the scheme portion\n-         * separated by colon.\n-         * A scheme is defined as:\n-         *\n-         * <blockquote>\n-         * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )<br>\n-         * where alpha = a-z and A-Z.<br><br>\n-         *\n-         * And the JAR protocol:<br>\n-         *\n-         * jar[:scheme]<br><br>\n-         *\n-         * Protocols including the keyword \"jar\" are case-insensitive. Any whitespaces as defined by\n-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.\n-         * Examples of protocols are file, http, jar:file.\n-         *\n-         * <\/blockquote>\n-         *\n-         *<p>\n-         * <b>Default value:<\/b> The default value is implementation specific and therefore not specified.\n-         * The following options are provided for consideration:\n-         * <blockquote>\n-         * <UL>\n-         *     <LI>an empty string to deny all access to external references;<\/LI>\n-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;<\/LI>\n-         *     <LI>the keyword \"all\" to grant  permission to all protocols.<\/LI>\n-         * <\/UL><br>\n-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations\n-         *      restrict external connections by default, though this may cause problems for applications\n-         *      that process XML\/XSD\/XSL with external references.\n-         * <\/blockquote>\n-         *\n-         * <p>\n-         * <b>Granting all access:<\/b>  the keyword \"all\" grants permission to all protocols.\n+         * <b>Value: <\/b> as defined in <a href=\"#EAP\">the class description<\/a>.\n@@ -238,3 +256,1 @@\n-         * <b>System Property:<\/b> The value of this property can be set or overridden by\n-         * system property {@code javax.xml.accessExternalDTD}.\n-         *\n+         * <b>System Property:<\/b> {@code javax.xml.accessExternalDTD}.\n@@ -243,6 +259,3 @@\n-         * <b>jaxp.properties:<\/b> This configuration file is in standard\n-         * {@link java.util.Properties} format and typically located in the {@code conf}\n-         * directory of the Java installation. If the file exists and the system\n-         * property is specified, its value will be used to override the default\n-         * of the property.\n-         *\n+         * <b>Configuration File:<\/b>\n+         * Yes. The property can be set in the\n+         * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>.\n@@ -265,35 +278,1 @@\n-         * <b>Value:<\/b> a list of protocols separated by comma. A protocol is the scheme portion of a\n-         * {@link java.net.URI}, or in the case of the JAR protocol, \"jar\" plus the scheme portion\n-         * separated by colon.\n-         * A scheme is defined as:\n-         *\n-         * <blockquote>\n-         * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )<br>\n-         * where alpha = a-z and A-Z.<br><br>\n-         *\n-         * And the JAR protocol:<br>\n-         *\n-         * jar[:scheme]<br><br>\n-         *\n-         * Protocols including the keyword \"jar\" are case-insensitive. Any whitespaces as defined by\n-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.\n-         * Examples of protocols are file, http, jar:file.\n-         *\n-         * <\/blockquote>\n-         *\n-         * <p>\n-         * <b>Default value:<\/b> The default value is implementation specific and therefore not specified.\n-         * The following options are provided for consideration:\n-         * <blockquote>\n-         * <UL>\n-         *     <LI>an empty string to deny all access to external references;<\/LI>\n-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;<\/LI>\n-         *     <LI>the keyword \"all\" to grant  permission to all protocols.<\/LI>\n-         * <\/UL><br>\n-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations\n-         *      restrict external connections by default, though this may cause problems for applications\n-         *      that process XML\/XSD\/XSL with external references.\n-         * <\/blockquote>\n-         *\n-         * <p>\n-         * <b>Granting all access:<\/b>  the keyword \"all\" grants permission to all protocols.\n+         * <b>Value: <\/b> as defined in <a href=\"#EAP\">the class description<\/a>.\n@@ -302,2 +281,1 @@\n-         * <b>System Property:<\/b> The value of this property can be set or overridden by\n-         * system property {@code javax.xml.accessExternalSchema}\n+         * <b>System Property:<\/b> {@code javax.xml.accessExternalSchema}\n@@ -306,6 +284,4 @@\n-         * <b>jaxp.properties:<\/b> This configuration file is in standard\n-         * {@link java.util.Properties} format and typically located in the {@code conf}\n-         * directory of the Java installation. If the file exists and the system\n-         * property is specified, its value will be used to override the default\n-         * of the property.\n-         *\n+         * <b>Configuration File:<\/b>\n+         * Yes. The property can be set in the\n+         * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>.\n+        *\n@@ -329,35 +305,1 @@\n-         * <b>Value:<\/b> a list of protocols separated by comma. A protocol is the scheme portion of a\n-         * {@link java.net.URI}, or in the case of the JAR protocol, \"jar\" plus the scheme portion\n-         * separated by colon.\n-         * A scheme is defined as:\n-         *\n-         * <blockquote>\n-         * scheme = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )<br>\n-         * where alpha = a-z and A-Z.<br><br>\n-         *\n-         * And the JAR protocol:<br>\n-         *\n-         * jar[:scheme]<br><br>\n-         *\n-         * Protocols including the keyword \"jar\" are case-insensitive. Any whitespaces as defined by\n-         * {@link java.lang.Character#isSpaceChar } in the value will be ignored.\n-         * Examples of protocols are file, http, jar:file.\n-         *\n-         * <\/blockquote>\n-         *\n-         * <p>\n-         * <b>Default value:<\/b> The default value is implementation specific and therefore not specified.\n-         * The following options are provided for consideration:\n-         * <blockquote>\n-         * <UL>\n-         *     <LI>an empty string to deny all access to external references;<\/LI>\n-         *     <LI>a specific protocol, such as file, to give permission to only the protocol;<\/LI>\n-         *     <LI>the keyword \"all\" to grant  permission to all protocols.<\/LI>\n-         * <\/UL><br>\n-         *      When FEATURE_SECURE_PROCESSING is enabled,  it is recommended that implementations\n-         *      restrict external connections by default, though this may cause problems for applications\n-         *      that process XML\/XSD\/XSL with external references.\n-         * <\/blockquote>\n-         *\n-         * <p>\n-         * <b>Granting all access:<\/b>  the keyword \"all\" grants permission to all protocols.\n+         * <b>Value: <\/b> as defined in <a href=\"#EAP\">the class description<\/a>.\n@@ -366,2 +308,1 @@\n-         * <b>System Property:<\/b> The value of this property can be set or overridden by\n-         * system property {@code javax.xml.accessExternalStylesheet}\n+         * <b>System Property:<\/b> {@code javax.xml.accessExternalStylesheet}\n@@ -370,5 +311,3 @@\n-         * <b>jaxp.properties:<\/b> This configuration file is in standard\n-         * {@link java.util.Properties} format and typically located in the {@code conf}\n-         * directory of the Java installation. If the file exists and the system\n-         * property is specified, its value will be used to override the default\n-         * of the property.\n+         * <b>Configuration File:<\/b>\n+         * Yes. The property can be set in the\n+         * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>.\n@@ -387,1 +326,1 @@\n-         * jaxp.properties by using the {@code javax.xml.catalog.files} property\n+         * configuration file by using the {@code javax.xml.catalog.files} property\n@@ -390,1 +329,1 @@\n-         * <pre>{@code\n+         * {@snippet :\n@@ -395,1 +334,1 @@\n-         * }<\/pre>\n+         * }\n@@ -404,2 +343,1 @@\n-         * <b>System Property:<\/b> The value of this property can be set or overridden by\n-         * system property {@code javax.xml.useCatalog}\n+         * <b>System Property:<\/b> {@code javax.xml.useCatalog}\n@@ -408,5 +346,3 @@\n-         * <b>jaxp.properties:<\/b> This configuration file is in standard\n-         * {@link java.util.Properties} format and typically located in the {@code conf}\n-         * directory of the Java installation. If the file exists and the system\n-         * property is specified, its value will be used to override the default\n-         * value of the property.\n+         * <b>Configuration File:<\/b>\n+         * Yes. The property can be set in the\n+         * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/XMLConstants.java","additions":77,"deletions":141,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URISyntaxException;\n@@ -45,1 +43,0 @@\n- * <th scope=\"col\" rowspan=\"2\">jaxp.properties [1]<\/th>\n@@ -64,1 +61,0 @@\n- * <td>javax.xml.catalog.files<\/td>\n@@ -79,1 +75,0 @@\n- * <td rowspan=\"2\">N\/A<\/td>\n@@ -100,1 +95,0 @@\n- * <td rowspan=\"2\">javax.xml.catalog.defer<\/td>\n@@ -119,1 +113,0 @@\n- * <td rowspan=\"3\">javax.xml.catalog.resolve<\/td>\n@@ -143,1 +136,0 @@\n- *\n@@ -167,6 +159,11 @@\n- * <h2>Scope and Order<\/h2>\n- * Features and properties can be set through the catalog file, the Catalog API,\n- * system properties, and {@code jaxp.properties}, with a preference in the same order.\n- * <p>\n- * Properties that are specified as attributes in the catalog file for the\n- * catalog and group entries shall take preference over any of the other settings.\n+ * <h2>Property Precedence<\/h2>\n+ * The Catalog Features follow the\n+ * <a href=\"{@docRoot}\/java.xml\/module-summary.html#PP\">Property Precedence<\/a>\n+ * as described in the module summary with regards to the priority with which\n+ * their values are retrieved from the various configuration sources such as the\n+ * <a href=\"{@docRoot}\/java.xml\/module-summary.html#Conf_CF\">JAXP configuration file<\/a>,\n+ * system and API properties. In addition to the general configuration sources,\n+ * the Catalog Features are further supported in the catalog file itself where\n+ * they can be specified as attributes of the catalog and group entries. When the\n+ * attributes are specified, they shall take preference over any of the other\n+ * configuration sources.\n@@ -176,7 +173,0 @@\n- * <p>\n- * Properties set through the Catalog API override those that may have been set\n- * by system properties and\/or in {@code jaxp.properties}. In case of multiple\n- * interfaces, the latest in a procedure shall take preference. For\n- * {@link Feature#FILES}, this means that the URI(s) specified through the methods\n- * of the {@link CatalogManager} will override any that may have been entered\n- * through the {@link Builder}.\n@@ -185,9 +175,0 @@\n- * System properties when set shall override those in {@code jaxp.properties}.\n- * <p>\n- * The {@code jaxp.properties} file is typically in the conf directory of the Java\n- * installation. The file is read only once by the JAXP implementation and\n- * its values are then cached for future use. If the file does not exist\n- * when the first attempt is made to read from it, no further attempts are\n- * made to check for its existence. It is not possible to change the value\n- * of any properties in {@code jaxp.properties} after it has been read.\n- * <p>\n@@ -492,1 +473,1 @@\n-     * jaxp.properties file, jaxp system properties, and jaxp api properties\n+     * configuration file, jaxp system properties, and jaxp api properties\n@@ -625,1 +606,1 @@\n-            value = SecuritySupport.readJAXPProperty(sysPropertyName);\n+            value = SecuritySupport.readConfig(sysPropertyName);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/CatalogFeatures.java","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * or system property or the jaxp.properties file to take advantage of the feature.\n+ * or system property or the configuration file to take advantage of the feature.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -32,1 +31,0 @@\n-import java.util.Properties;\n@@ -54,11 +52,0 @@\n-    \/**\n-     * Cache for properties in java.home\/conf\/jaxp.properties\n-     *\/\n-    private final static Properties cacheProps = new Properties();\n-\n-    \/**\n-     * Flag indicating if properties from java.home\/conf\/jaxp.properties\n-     * have been cached.\n-     *\/\n-    private static volatile boolean firstTime = true;\n-\n@@ -236,25 +223,4 @@\n-        \/\/ try to read from $java.home\/conf\/jaxp.properties\n-        try {\n-            if (firstTime) {\n-                synchronized (cacheProps) {\n-                    if (firstTime) {\n-                        String configFile = SecuritySupport.getSystemProperty(\"java.home\") + File.separator +\n-                            \"conf\" + File.separator + \"jaxp.properties\";\n-                        File f = new File(configFile);\n-                        firstTime = false;\n-                        if (SecuritySupport.doesFileExist(f)) {\n-                            dPrint(()->\"Read properties file \"+f);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(f));\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(factoryId);\n-\n-            if (factoryClassName != null) {\n-                dPrint(()->\"found in ${java.home}\/conf\/jaxp.properties, value=\" + factoryClassName);\n-                return newInstance(type, factoryClassName, null, true);\n-            }\n-        }\n-        catch (Exception ex) {\n-            if (debug) ex.printStackTrace();\n+        \/\/ try to read from the configuration file\n+        String factoryClassName = SecuritySupport.readConfig(factoryId);\n+        if (factoryClassName != null) {\n+            return newInstance(type, factoryClassName, null, true);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/datatype\/FactoryFinder.java","additions":5,"deletions":39,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -32,1 +31,0 @@\n-import java.util.Properties;\n@@ -53,11 +51,0 @@\n-    \/**\n-     * Cache for properties in java.home\/conf\/jaxp.properties\n-     *\/\n-    private static final Properties cacheProps = new Properties();\n-\n-    \/**\n-     * Flag indicating if properties from java.home\/conf\/jaxp.properties\n-     * have been cached.\n-     *\/\n-    static volatile boolean firstTime = true;\n-\n@@ -234,25 +221,4 @@\n-        \/\/ try to read from $java.home\/conf\/jaxp.properties\n-        try {\n-            if (firstTime) {\n-                synchronized (cacheProps) {\n-                    if (firstTime) {\n-                        String configFile = SecuritySupport.getSystemProperty(\"java.home\") + File.separator +\n-                            \"conf\" + File.separator + \"jaxp.properties\";\n-                        File f = new File(configFile);\n-                        firstTime = false;\n-                        if (SecuritySupport.doesFileExist(f)) {\n-                            dPrint(()->\"Read properties file \"+f);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(f));\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(factoryId);\n-\n-            if (factoryClassName != null) {\n-                dPrint(()->\"found in ${java.home}\/conf\/jaxp.properties, value=\" + factoryClassName);\n-                return newInstance(type, factoryClassName, null, true);\n-            }\n-        }\n-        catch (Exception ex) {\n-            if (debug) ex.printStackTrace();\n+        \/\/ try to read from the configuration file\n+        String factoryClassName = SecuritySupport.readConfig(factoryId);\n+        if (factoryClassName != null) {\n+            return newInstance(type, factoryClassName, null, true);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/parsers\/FactoryFinder.java","additions":5,"deletions":39,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -32,1 +31,0 @@\n-import java.util.Properties;\n@@ -55,11 +53,0 @@\n-    \/**\n-     * Cache for properties in java.home\/conf\/jaxp.properties\n-     *\/\n-    final private static Properties cacheProps = new Properties();\n-\n-    \/**\n-     * Flag indicating if properties from java.home\/conf\/jaxp.properties\n-     * have been cached.\n-     *\/\n-    private static volatile boolean firstTime = true;\n-\n@@ -269,37 +256,4 @@\n-        \/\/ Try read $java.home\/conf\/stax.properties followed by\n-        \/\/ $java.home\/conf\/jaxp.properties if former not present\n-        String configFile = null;\n-        try {\n-            if (firstTime) {\n-                synchronized (cacheProps) {\n-                    if (firstTime) {\n-                        configFile = SecuritySupport.getSystemProperty(\"java.home\") + File.separator +\n-                            \"conf\" + File.separator + \"stax.properties\";\n-                        final File fStax = new File(configFile);\n-                        firstTime = false;\n-                        if (SecuritySupport.doesFileExist(fStax)) {\n-                            dPrint(()->\"Read properties file \"+fStax);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(fStax));\n-                        }\n-                        else {\n-                            configFile = SecuritySupport.getSystemProperty(\"java.home\") + File.separator +\n-                                \"conf\" + File.separator + \"jaxp.properties\";\n-                            final File fJaxp = new File(configFile);\n-                            if (SecuritySupport.doesFileExist(fJaxp)) {\n-                                dPrint(()->\"Read properties file \"+fJaxp);\n-                                cacheProps.load(SecuritySupport.getFileInputStream(fJaxp));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(factoryId);\n-\n-            if (factoryClassName != null) {\n-                final String foundIn = configFile;\n-                dPrint(()->\"found in \" + foundIn + \" value=\" + factoryClassName);\n-                return newInstance(type, factoryClassName, cl, true);\n-            }\n-        }\n-        catch (Exception ex) {\n-            if (debug) ex.printStackTrace();\n+        \/\/ try to read from the configuration file\n+        String factoryClassName = SecuritySupport.readConfig(factoryId, true);\n+        if (factoryClassName != null) {\n+            return newInstance(type, factoryClassName, cl, true);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/FactoryFinder.java","additions":5,"deletions":51,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-   * <a href=\"..\/..\/..\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n@@ -137,17 +137,4 @@\n-   *   Use the configuration file \"stax.properties\". The file is in standard\n-   *   {@link java.util.Properties} format and typically located in the\n-   *   conf directory of the Java installation. It contains the fully qualified\n-   *   name of the implementation class with the key being the system property\n-   *   defined above.\n-   *\n-   *   <p>\n-   *   The stax.properties file is read only once by the implementation\n-   *   and its values are then cached for future use.  If the file does not exist\n-   *   when the first attempt is made to read from it, no further attempts are\n-   *   made to check for its existence.  It is not possible to change the value\n-   *   of any property in stax.properties after it has been read for the first time.\n-   *\n-   *   <p>\n-   *   Use the jaxp configuration file \"jaxp.properties\". The file is in the same\n-   *   format as stax.properties and will only be read if stax.properties does\n-   *   not exist.\n+   *   Use the value of the property {@code factoryId} set in the\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>,\n+   * jaxp.properties by default. If the file exists and the property {@code factoryId}\n+   * is specified in the file, its value will be used as the implementation class.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLEventFactory.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-   * <a href=\"..\/..\/..\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n@@ -224,17 +224,4 @@\n-   *   Use the configuration file \"stax.properties\". The file is in standard\n-   *   {@link java.util.Properties} format and typically located in the\n-   *   {@code conf} directory of the Java installation. It contains the fully qualified\n-   *   name of the implementation class with the key being the system property\n-   *   defined above.\n-   *\n-   *   <p>\n-   *   The stax.properties file is read only once by the implementation\n-   *   and its values are then cached for future use.  If the file does not exist\n-   *   when the first attempt is made to read from it, no further attempts are\n-   *   made to check for its existence.  It is not possible to change the value\n-   *   of any property in stax.properties after it has been read for the first time.\n-   *\n-   *   <p>\n-   *   Use the jaxp configuration file \"jaxp.properties\". The file is in the same\n-   *   format as stax.properties and will only be read if stax.properties does\n-   *   not exist.\n+   *   Use the value of the property {@code factoryId} set in the\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>,\n+   * jaxp.properties by default. If the file exists and the property {@code factoryId}\n+   * is specified in the file, its value will be used as the implementation class.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLInputFactory.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-   * <a href=\"..\/..\/..\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n@@ -199,17 +199,4 @@\n-   *   Use the configuration file \"stax.properties\". The file is in standard\n-   *   {@link java.util.Properties} format and typically located in the\n-   *   {@code conf} directory of the Java installation. It contains the fully qualified\n-   *   name of the implementation class with the key being the system property\n-   *   defined above.\n-   *\n-   *   <p>\n-   *   The stax.properties file is read only once by the implementation\n-   *   and its values are then cached for future use.  If the file does not exist\n-   *   when the first attempt is made to read from it, no further attempts are\n-   *   made to check for its existence.  It is not possible to change the value\n-   *   of any property in stax.properties after it has been read for the first time.\n-   *\n-   *   <p>\n-   *   Use the jaxp configuration file \"jaxp.properties\". The file is in the same\n-   *   format as stax.properties and will only be read if stax.properties does\n-   *   not exist.\n+   *   Use the value of the property {@code factoryId} set in the\n+   * <a href=\"{@docRoot}\/java.xml\/module-summary.html#ConfigurationFile\">configuration file<\/a>,\n+   * jaxp.properties by default. If the file exists and the property {@code factoryId}\n+   * is specified in the file, its value will be used as the implementation class.\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLOutputFactory.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.io.File;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -34,1 +31,0 @@\n-import java.util.Properties;\n@@ -56,11 +52,0 @@\n-    \/**\n-     * Cache for properties in java.home\/conf\/jaxp.properties\n-     *\/\n-    private final static Properties cacheProps = new Properties();\n-\n-    \/**\n-     * Flag indicating if properties from java.home\/conf\/jaxp.properties\n-     * have been cached.\n-     *\/\n-    static volatile boolean firstTime = true;\n-\n@@ -220,25 +205,4 @@\n-        \/\/ try to read from $java.home\/conf\/jaxp.properties\n-        try {\n-            if (firstTime) {\n-                synchronized (cacheProps) {\n-                    if (firstTime) {\n-                        String configFile = SecuritySupport.getSystemProperty(\"java.home\") + File.separator +\n-                            \"conf\" + File.separator + \"jaxp.properties\";\n-                        File f = new File(configFile);\n-                        firstTime = false;\n-                        if (SecuritySupport.doesFileExist(f)) {\n-                            dPrint(()->\"Read properties file \"+f);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(f));\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(factoryId);\n-\n-            if (factoryClassName != null) {\n-                dPrint(()->\"found in ${java.home}\/conf\/jaxp.properties, value=\" + factoryClassName);\n-                return newInstance(type, factoryClassName, null, true);\n-            }\n-        }\n-        catch (Exception ex) {\n-            if (debug) ex.printStackTrace();\n+        \/\/ try to read from the configuration file\n+        String factoryClassName = SecuritySupport.readConfig(factoryId);\n+        if (factoryClassName != null) {\n+            return newInstance(type, factoryClassName, null, true);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/transform\/FactoryFinder.java","additions":5,"deletions":41,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.File;\n@@ -31,2 +30,0 @@\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -36,1 +33,0 @@\n-import java.util.Properties;\n@@ -54,9 +50,0 @@\n-    \/**\n-     * <p>Cache properties for performance.<\/p>\n-     *\/\n-    private static final Properties cacheProps = new Properties();\n-\n-    \/**\n-     * <p>First time requires initialization overhead.<\/p>\n-     *\/\n-    private static volatile boolean firstTime = true;\n@@ -182,31 +169,6 @@\n-        String javah = SecuritySupport.getSystemProperty( \"java.home\" );\n-        String configFile = javah + File.separator +\n-        \"conf\" + File.separator + \"jaxp.properties\";\n-\n-\n-        \/\/ try to read from $java.home\/conf\/jaxp.properties\n-        try {\n-            if(firstTime){\n-                synchronized(cacheProps){\n-                    if(firstTime){\n-                        File f=new File( configFile );\n-                        firstTime = false;\n-                        if(SecuritySupport.doesFileExist(f)){\n-                            debugPrintln(()->\"Read properties file \" + f);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(f));\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(propertyName);\n-            debugPrintln(()->\"found \" + factoryClassName + \" in $java.home\/conf\/jaxp.properties\");\n-\n-            if (factoryClassName != null) {\n-                sf = createInstance(factoryClassName);\n-                if(sf != null){\n-                    return sf;\n-                }\n-            }\n-        } catch (Exception ex) {\n-            if (debug) {\n-                ex.printStackTrace();\n+        \/\/ try to read from the configuration file\n+        String factoryClassName = SecuritySupport.readConfig(propertyName);\n+        if (factoryClassName != null) {\n+            sf = createInstance(factoryClassName);\n+            if(sf != null){\n+                return sf;\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/validation\/SchemaFactoryFinder.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.File;\n@@ -177,30 +176,5 @@\n-        String javah = SecuritySupport.getSystemProperty( \"java.home\" );\n-        String configFile = javah + File.separator +\n-        \"conf\" + File.separator + \"jaxp.properties\";\n-\n-        \/\/ try to read from $java.home\/conf\/jaxp.properties\n-        try {\n-            if(firstTime){\n-                synchronized(cacheProps){\n-                    if(firstTime){\n-                        File f=new File( configFile );\n-                        firstTime = false;\n-                        if(SecuritySupport.doesFileExist(f)){\n-                            debugPrintln(()->\"Read properties file \" + f);\n-                            cacheProps.load(SecuritySupport.getFileInputStream(f));\n-                        }\n-                    }\n-                }\n-            }\n-            final String factoryClassName = cacheProps.getProperty(propertyName);\n-            debugPrintln(()->\"found \" + factoryClassName + \" in $java.home\/conf\/jaxp.properties\");\n-\n-            if (factoryClassName != null) {\n-                xpathFactory = createInstance(factoryClassName);\n-                if(xpathFactory != null){\n-                    return xpathFactory;\n-                }\n-            }\n-        } catch (Exception ex) {\n-            if (debug) {\n-                ex.printStackTrace();\n+        String factoryClassName = SecuritySupport.readConfig(propertyName);\n+        if (factoryClassName != null) {\n+            xpathFactory = createInstance(factoryClassName);\n+            if(xpathFactory != null){\n+                return xpathFactory;\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/xpath\/XPathFactoryFinder.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -286,0 +286,6 @@\n+    \/**\n+     * System Property for the Configuration File\n+     * @since 21\n+     *\/\n+    public static final String CONFIG_FILE = \"java.xml.config.file\";\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkConstants.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,1 +410,1 @@\n-            value = SecuritySupport.readJAXPProperty(sysPropertyName);\n+            value = SecuritySupport.readConfig(sysPropertyName);\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlFeatures.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.file.Paths;\n@@ -162,1 +163,1 @@\n-            value = readJAXPProperty(propName);\n+            value = readConfig(propName);\n@@ -168,1 +169,4 @@\n-     * Reads the specified property from $java.home\/conf\/jaxp.properties\n+     * Returns the value of the specified property from the Configuration file.\n+     * The method reads the System Property \"java.xml.config.file\" for a custom\n+     * configuration file, if doesn't exist, falls back to the JDK default that\n+     * is typically located at $java.home\/conf\/jaxp.properties.\n@@ -170,2 +174,3 @@\n-     * @param propName the name of the property\n-     * @return the value of the property\n+     * @param propName the specified property\n+     * @return the value of the specified property, null if the property is not\n+     * found\n@@ -173,15 +178,40 @@\n-    public static String readJAXPProperty(String propName) {\n-        String value = null;\n-        InputStream is = null;\n-        try {\n-            if (firstTime) {\n-                synchronized (cacheProps) {\n-                    if (firstTime) {\n-                        String configFile = getSystemProperty(\"java.home\") + File.separator\n-                                + \"conf\" + File.separator + \"jaxp.properties\";\n-                        File f = new File(configFile);\n-                        if (isFileExists(f)) {\n-                            is = getFileInputStream(f);\n-                            cacheProps.load(is);\n-                        }\n-                        firstTime = false;\n+    public static String readConfig(String propName) {\n+        return readConfig(propName, false);\n+    }\n+\n+    \/**\n+     * Returns the value of the specified property from the Configuration file.\n+     * The method reads the JDK default configuration that is typically located\n+     * at $java.home\/conf\/jaxp.properties. On top of the default, if the System\n+     * Property \"java.xml.config.file\" exists, the configuration file it points\n+     * to will also be read. Any settings in it will then override those in the\n+     * default.\n+     *\n+     * @param propName the specified property\n+     * @param stax a flag indicating whether to read stax.properties\n+     * @return the value of the specified property, null if the property is not\n+     * found\n+     *\/\n+    public static String readConfig(String propName, boolean stax) {\n+        \/\/ always load the default configuration file\n+        if (firstTime) {\n+            synchronized (cacheProps) {\n+                if (firstTime) {\n+                    boolean found = loadProperties(\n+                            Paths.get(SecuritySupport.getSystemProperty(\"java.home\"),\n+                                \"conf\", \"jaxp.properties\")\n+                                .toAbsolutePath().normalize().toString());\n+\n+                    \/\/ attempts to find stax.properties only if jaxp.properties is not available\n+                    if (stax && !found) {\n+                        found = loadProperties(\n+                            Paths.get(SecuritySupport.getSystemProperty(\"java.home\"),\n+                                    \"conf\", \"stax.properties\")\n+                                    .toAbsolutePath().normalize().toString()\n+                        );\n+                    }\n+\n+                    \/\/ load the custom configure on top of the default if any\n+                    String configFile = SecuritySupport.getSystemProperty(JdkConstants.CONFIG_FILE);\n+                    if (configFile != null) {\n+                        loadProperties(configFile);\n@@ -189,0 +219,2 @@\n+\n+                    firstTime = false;\n@@ -191,9 +223,0 @@\n-            value = cacheProps.getProperty(propName);\n-\n-        } catch (IOException ex) {\n-        } finally {\n-            if (is != null) {\n-                try {\n-                    is.close();\n-                } catch (IOException ex) {}\n-            }\n@@ -202,1 +225,19 @@\n-        return value;\n+        return cacheProps.getProperty(propName);\n+    }\n+\n+    \/**\n+     * Loads the properties from the specified file into the cache.\n+     * @param file the specified file\n+     * @return true if success, false otherwise\n+     *\/\n+    private static boolean loadProperties(String file) {\n+        File f = new File(file);\n+        if (SecuritySupport.doesFileExist(f)) {\n+            try (final InputStream in = SecuritySupport.getFileInputStream(f)) {\n+                cacheProps.load(in);\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ shouldn't happen, but required by method getFileInputStream\n+            }\n+        }\n+        return false;\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/SecuritySupport.java","additions":71,"deletions":30,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -538,1 +538,1 @@\n-     * Read from system properties, or those in jaxp.properties\n+     * Read system properties, or the configuration file\n@@ -541,1 +541,0 @@\n-\n@@ -543,8 +542,5 @@\n-            if (!getSystemProperty(limit, limit.systemProperty())) {\n-                \/\/if system property is not found, try the older form if any\n-                for (NameMap nameMap : NameMap.values()) {\n-                    String oldName = nameMap.getOldName(limit.systemProperty());\n-                    if (oldName != null) {\n-                        getSystemProperty(limit, oldName);\n-                    }\n-                }\n+            \/\/ attempts to read both the current and old system propery\n+            if (!getSystemProperty(limit, limit.systemProperty())\n+                    && (!getOldSystemProperty(limit))) {\n+                \/\/if system property is not found, try the config file\n+                getPropertyConfig(limit, limit.systemProperty());\n@@ -553,1 +549,0 @@\n-\n@@ -574,1 +569,1 @@\n-     * Read from system properties, or those in jaxp.properties\n+     * Reads a system property, sets value and state if found.\n@@ -576,1 +571,1 @@\n-     * @param property the type of the property\n+     * @param limit the limit property\n@@ -587,0 +582,6 @@\n+        } catch (NumberFormatException e) {\n+            \/\/invalid setting\n+            throw new NumberFormatException(\"Invalid setting for system property: \" + limit.systemProperty());\n+        }\n+        return false;\n+    }\n@@ -588,1 +589,29 @@\n-            value = SecuritySupport.readJAXPProperty(sysPropertyName);\n+    \/**\n+     * Reads the legacy system property.\n+     * @param limit a limit object\n+     * @return true if found, false otherwise\n+     *\/\n+    private boolean getOldSystemProperty(Limit limit) {\n+        boolean found = false;\n+        for (NameMap nameMap : NameMap.values()) {\n+            String oldName = nameMap.getOldName(limit.systemProperty());\n+            if (oldName != null) {\n+                if (getSystemProperty(limit, oldName)) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return found;\n+    }\n+\n+    \/**\n+     * Reads a property from a configuration file, if any.\n+     *\n+     * @param limit the limit property\n+     * @param sysPropertyName the name of system property\n+     * @return\n+     *\/\n+    private boolean getPropertyConfig(Limit limit, String sysPropertyName) {\n+        try {\n+            String value = SecuritySupport.readConfig(sysPropertyName);\n@@ -601,1 +630,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/XMLSecurityManager.java","additions":44,"deletions":16,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,210 @@\n- * Defines the Java API for XML Processing (JAXP), the Streaming API for XML (StAX),\n- * the Simple API for XML (SAX), and the W3C Document Object Model (DOM) API.\n+ * Defines the Java APIs for XML Processing (JAXP).\n+ *\n+ * <ul>\n+ * <li><a href=\"#JAXP\">The JAXP APIs<\/a><\/li>\n+ * <li><a href=\"#FacPro\">Factories and Processors<\/a><\/li>\n+ * <li><a href=\"#Conf\">Configuration<\/a>\n+ *     <ul>\n+ *     <li><a href=\"#Conf_Properties\">JAXP Properties<\/a><\/li>\n+ *     <li><a href=\"#Conf_SystemProperties\">System Properties<\/a><\/li>\n+ *     <li><a href=\"#Conf_CF\">Configuration File<\/a>\n+ *         <ul>\n+ *         <li><a href=\"#Conf_CF_Default\">{@code jaxp.properties} File<\/a><\/li>\n+ *         <li><a href=\"#Conf_CF_SP\">User-defined Configuration File<\/a><\/li>\n+ *         <\/ul>\n+ *     <\/li>\n+ *     <li><a href=\"#PP\">Property Precedence<\/a><\/li>\n+ *     <\/ul>\n+ * <\/li>\n+ * <li><a href=\"#LookupMechanism\">JAXP Lookup Mechanism<\/a>\n+ *      <ul>\n+ *      <li><a href=\"#LookupProcedure\">Lookup Procedure<\/a><\/li>\n+ *      <\/ul>\n+ * <\/li>\n+ * <li><a href=\"#implNote\">Implementation Note<\/a><\/li>\n+ * <\/ul>\n+ *\n+ * <h2 id=\"JAXP\">The JAXP APIs<\/h2>\n+ * JAXP comprises a set of APIs built upon a number of XML technologies and\n+ * standards that are essential for XML processing. These include APIs for:\n+ *\n+ * <ul>\n+ * <li>Parsing: the {@link javax.xml.parsers JAXP Parsing API} based on\n+ * {@link org.w3c.dom Document Object Model (DOM)} and\n+ * {@link org.xml.sax Simple API for XML Parsing (SAX)}, and\n+ * {@link javax.xml.stream Streaming API for XML (StAX)};\n+ * <\/li>\n+ * <li>Serializing: StAX and\n+ * {@link javax.xml.transform Extensible Stylesheet Language Transformations (XSLT)};\n+ * <\/li>\n+ * <li>Validation: the {@link javax.xml.validation JAXP Validation API}\n+ * based on the XML Schema Definition Language;<\/li>\n+ * <li>Transformation: the {@link javax.xml.transform JAXP Transformation API}\n+ * or XSLT (Extensible Stylesheet Language Transformations);<\/li>\n+ * <li>Querying and traversing XML documents: the\n+ * {@link javax.xml.xpath XML XPath Language API (XPath)};<\/li>\n+ * <li>Resolving external resources: the {@link javax.xml.catalog XML Catalog API};<\/li>\n+ * <\/ul>\n+ *\n+ * <h2 id=\"FacPro\">Factories and Processors<\/h2>\n+ * Factories are the entry points of each API, providing methods to allow applications\n+ * to set <a href=\"#Conf_Properties\">JAXP Properties<\/a> programmatically, before\n+ * creating processors. The <a href=\"#Conf\">Configuration<\/a> section provides more\n+ * details on this. Factories also support the\n+ * <a href=\"#LookupMechanism\">JAXP Lookup Mechanism<\/a>, in which applications can be\n+ * deployed with third party implementations to use instead of JDK implementations\n+ * <p>\n+ *\n+ * Processors are aggregates of parsers (or readers), serializers (or writers),\n+ * validators, and transformers that control and perform the processing in their\n+ * respective areas. They are defined in their relevant packages.\n+ * In the {@link javax.xml.parsers parsers} package for example,\n+ * are the {@link javax.xml.parsers.DocumentBuilder DocumentBuilder} and\n+ * {@link javax.xml.parsers.SAXParser SAXParser}, that represent the DOM and\n+ * SAX processors.\n+ * <p>\n+ * The processors are configured and instantiated with their corresponding factories.\n+ * The DocumentBuilder and SAXParser for example are constructed with the\n+ * {@link javax.xml.parsers.DocumentBuilderFactory DocumentBuilderFactory}\n+ * and {@link javax.xml.parsers.SAXParserFactory SAXParserFactory} respectively.\n+ *\n+ * <h2 id=\"Conf\">Configuration<\/h2>\n+ * When a JAXP factory is invoked for the first time, it performs a configuration\n+ * process to determine the implementation to be used and its subsequent behaviors.\n+ * During configuration, the factory examines configuration sources such as the\n+ * <a href=\"#Conf_Properties\">JAXP Properties<\/a>,\n+ * <a href=\"#Conf_SystemProperties\">System Properties<\/a>,\n+ * and the <a href=\"#Conf_CF\">JAXP Configuration File<\/a>, and sets the values\n+ * following the <a href=\"#PP\">Property Precedence<\/a>. The terminologies and\n+ * process are defined below.\n+ *\n+ * <h3 id=\"Conf_Properties\">JAXP Properties<\/h3>\n+ * JAXP properties are configuration settings that are applied to XML processors.\n+ * They can be used to control and customize the behavior of a processor.\n+ * Depending on the JAXP API that is being used, JAXP properties may be referred\n+ * to as <em>Attributes, Properties<\/em>, or <em>Features<\/em>.\n+ *\n+ * <h3 id=\"Conf_SystemProperties\">System Properties<\/h3>\n+ * Select JAXP properties have corresponding System Properties allowing the properties\n+ * to be set at runtime, on the command line, or within the\n+ * <a href=\"#Conf_CF\">JAXP Configuration File<\/a>.\n+ * For example, the System Property {@code javax.xml.catalog.resolve} may be used\n+ * to set the {@link javax.xml.catalog.CatalogFeatures CatalogFeatures}' RESOLVE\n+ * property.\n+ * <p>\n+ * The exact time at which system properties are read is unspecified. In order to\n+ * ensure that the desired values are properly applied, applications should ensure\n+ * that system properties are set appropriately prior to the creation of the first\n+ * JAXP factory and are not modified thereafter.\n+ *\n+ * <h3 id=\"Conf_CF\">Configuration File<\/h3>\n+ * JAXP supports the use of configuration files for\n+ * <a href=\"#LookupMechanism\">specifying the implementation class to load for the JAXP factories<\/a>\n+ * as well as for setting JAXP properties.\n+ * <p>\n+ * Configuration files are Java {@link java.util.Properties} files that consist\n+ * of mappings between system properties and their values defined by various APIs\n+ * or processes. The following configuration file entries demonstrate setting the\n+ * {@code javax.xml.parsers.DocumentBuilderFactory}\n+ * and {@code CatalogFeatures.RESOLVE} properties:\n+ *\n+ * {@snippet :\n+ *    javax.xml.parsers.DocumentBuilderFactory=packagename.DocumentBuilderFactoryImpl\n+ *    javax.xml.catalog.resolve=strict\n+ * }\n+ *\n+ * <h4 id=\"Conf_CF_Default\">{@code jaxp.properties} File<\/h4>\n+ * By default, JAXP looks for the configuration file {@code jaxp.properties},\n+ * located in the ${java.home}\/conf directory; and if the file exists, loads the\n+ * specified properties to customize the behavior of the XML factories and processors.\n+ * <p>\n+ * The {@code jaxp.properties} file will be read only once during the initialization\n+ * of the JAXP implementation and cached in memory. If there is an error accessing\n+ * or reading the file, the configuration process proceeds as if the file does not exist.\n+ *\n+ * <h4 id=\"Conf_CF_SP\">User-defined Configuration File<\/h4>\n+ * In addition to the {@code jaxp.properties} file, the system property\n+ * {@systemProperty java.xml.config.file} can be set to specify the location of\n+ * a configuration file. If the {@code java.xml.config.file} property is included\n+ * within a configuration file, it will be ignored.\n+ *\n+ * <p>\n+ * When the {@code java.xml.config.file} is specified, the configuration file will be\n+ * read and the included properties will override the same properties that were\n+ * defined in the {@code jaxp.properties} file. If the {@code java.xml.config.file}\n+ * has not been set when the JAXP implementation is initialized, no further attempt\n+ * will be made to check for its existence.\n+ * <p>\n+ * The {@code java.xml.config.file} value must contain a valid pathname\n+ * to a configuration file. If the pathname is not absolute, it will be considered\n+ * relative to the working directory of the JVM.\n+ * If there is an error reading the configuration file, the configuration process\n+ * proceeds as if the {@code java.xml.config.file} property was not set.\n+ * Implementations may optionally issue a warning message.\n+ *\n+ * <h3 id=\"PP\">Property Precedence<\/h3>\n+ * JAXP properties can be set in multiple ways, including by API methods, system\n+ * properties, and the <a href=\"#Conf_CF\">JAXP Configuration File<\/a>. When not\n+ * explicitly set, they will be initialized with default values or more restrictive\n+ * values when\n+ * {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING FEATURE_SECURE_PROCESSING}\n+ * (FSP) is enabled. The configuration order of precedence for properties is as\n+ * follows, from highest to lowest:\n+ *\n+ * <ul>\n+ * <li><p>\n+ *      The APIs for factories or processors\n+ * <\/li>\n+ * <li><p>\n+ *      System Property\n+ * <\/li>\n+ * <li><p>\n+ *      User-defined <a href=\"#Conf_CF\">Configuration File<\/a>\n+ * <\/li>\n+ * <li><p>\n+ *      The default JAXP Configuration File <a href=\"#Conf_CF_Default\">{@code jaxp.properties}<\/a>\n+ * <\/li>\n+ * <li><p>\n+ *      The default values for JAXP Properties. If the\n+ * {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING FSP} is true,\n+ * the default values will be set to process XML securely.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * Using the {@link javax.xml.catalog.CatalogFeatures CatalogFeatures}' RESOLVE\n+ * property as an example, the following illustrates how these rules are applied:\n+ * <ul>\n+ * <li><p>\n+ *      Properties specified with factory or processor APIs have the highest\n+ * precedence. The following code effectively sets the RESOLVE property to\n+ * {@code strict}, regardless of settings in any other configuration sources.\n+ *\n+ * {@snippet :\n+ *    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+ *    dbf.setAttribute(CatalogFeatures.Feature.RESOLVE.getPropertyName(), \"strict\");\n+ * }\n+ *\n+ * <\/li>\n+ * <li><p>\n+ *      If the property is not set on the factory as in the above code, a\n+ * system property setting will be in effect.\n+ * {@snippet :\n+ *     \/\/ in the following example, the RESOLVE property is set to 'continue'\n+ *     \/\/ for the entire application\n+ *     java -Djavax.xml.catalog.resolve=continue myApp\n+ * }\n+ * <\/li>\n+ * <li><p>\n+ *      If the property is not set on the factory, or using a system property,\n+ * the setting in a configuration file will take effect. The following entry\n+ * sets the property to '{@code continue}'.\n+ * {@snippet :\n+ *     javax.xml.catalog.resolve=continue\n+ * }\n+ *\n+ * <\/li>\n+ * <li><p>\n+ *     If the property is not set anywhere, it will be resolved to its\n+ * default value that is '{@code strict}'.\n+ * <\/li>\n+ * <\/ul>\n@@ -33,2 +241,2 @@\n- * in the table below along with the method, System Property name, Configuration\n- * File, and System Default method to be used in the procedure.\n+ * in the table below along with the method, System Property, and System\n+ * Default method to be used in the procedure.\n@@ -42,2 +250,1 @@\n- * <th scope=\"col\">System Property Name<\/th>\n- * <th scope=\"col\">Configuration File<\/th>\n+ * <th scope=\"col\">System Property<\/th>\n@@ -55,1 +262,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -64,1 +270,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -73,1 +278,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -82,4 +286,0 @@\n- * <td style=\"text-align:center\">\n- *     <a href=\"#StAXProperties\">stax.properties<\/a> and then\n- *     <a href=\"#JaxpProperties\">jaxp.properties<\/a>\n- * <\/td>\n@@ -94,4 +294,0 @@\n- * <td style=\"text-align:center\">\n- *     <a href=\"#StAXProperties\">stax.properties<\/a> and then\n- *     <a href=\"#JaxpProperties\">jaxp.properties<\/a>\n- * <\/td>\n@@ -106,4 +302,0 @@\n- * <td style=\"text-align:center\">\n- *     <a href=\"#StAXProperties\">stax.properties<\/a> and then\n- *     <a href=\"#JaxpProperties\">jaxp.properties<\/a>\n- * <\/td>\n@@ -118,1 +310,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -127,1 +318,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -136,1 +326,0 @@\n- * <td style=\"text-align:center\"><a href=\"#JaxpProperties\">jaxp.properties<\/a><\/td>\n@@ -150,17 +339,0 @@\n- * <h3 id=\"JaxpProperties\">jaxp.properties<\/h3>\n- * {@code jaxp.properties} is a configuration file in standard\n- * {@link java.util.Properties} format and typically located in the {@code conf}\n- * directory of the Java installation. It contains the fully qualified\n- * name of the implementation class with the key being the system property name\n- * defined in <a href=\"#Factories\">the table<\/a> above.\n- * <p>\n- * The {@code jaxp.properties} file is read only once by the implementation and\n- * the values are then cached for future use.  If the file does not exist when\n- * the first attempt is made to read from it, no further attempts\n- * are made to check for its existence. It is not possible to change the value\n- * of any property after it has been read for the first time.\n- *\n- * <h3 id=\"StAXProperties\">stax.properties<\/h3>\n- * {@code stax.properties} is a configuration file that functions the same as\n- * {@code jaxp.properties} except that it is only used by StAX factory lookup.\n- *\n@@ -168,3 +340,2 @@\n- * The <a href=\"#Factories\">JAXP Factories<\/a> follow the procedure described\n- * below in order to locate and load the implementation class:\n- *\n+ * The order of precedence for locating the implementation class of a\n+ * <a href=\"#Factories\">JAXP Factory<\/a> is as follows, from highest to lowest:\n@@ -173,2 +344,2 @@\n- * Use the system property as described in column System Property of the table\n- * <a href=\"#Factories\">JAXP Factories<\/a> above.\n+ * The system property as listed in the column System Property of the table\n+ * <a href=\"#Factories\">JAXP Factories<\/a> above\n@@ -178,4 +349,1 @@\n- * Use the configuration file <a href=\"#JaxpProperties\">jaxp.properties<\/a> as\n- * indicated in the table <a href=\"#Factories\">JAXP Factories<\/a>. For StAX,\n- * if <a href=\"#StAXProperties\">stax.properties<\/a> exists, the factories will\n- * first attempt to read from it instead of <a href=\"#JaxpProperties\">jaxp.properties<\/a>.\n+ * The <a href=\"#Conf_CF\">Configuration File<\/a>\n@@ -185,1 +353,1 @@\n- * Use the service-provider loading facility, defined by the\n+ * The service-provider loading facility, defined by the\n@@ -232,0 +400,2 @@\n+ *\n+ * <div id=\"implNote\"><\/div>\n@@ -233,72 +403,16 @@\n- * <h2>Implementation Specific Features and Properties<\/h2>\n- *\n- * In addition to the standard features and properties described within the public\n- * APIs of this module, the JDK implementation supports a further number of\n- * implementation specific features and properties. This section describes the\n- * naming convention, System Properties, jaxp.properties, scope and order,\n- * and processors to which a property applies. A table listing the implementation\n- * specific features and properties which the implementation currently supports\n- * can be found at the end of this note.\n- *\n- * <h3 id=\"NamingConvention\">Naming Convention<\/h3>\n- * The names of the features and properties are fully qualified, composed of a\n- * prefix and name.\n- *\n- * <h4>Prefix<\/h4>\n- * The prefix for JDK features and properties, as well as their corresponding\n- * System Properties if any, is defined as:\n- * <pre>\n- *     {@code jdk.xml.}\n- * <\/pre>\n- *\n- * <h4>Name<\/h4>\n- * A name may consist of one or multiple words that are case-sensitive.\n- * All letters of the first word are in lowercase, while the first letter of\n- * each subsequent word is capitalized.\n- * <p>\n- * An example of a property that indicates whether an XML document is standalone\n- * would thus have a format:\n- * <pre>\n- *     {@code jdk.xml.isStandalone}\n- * <\/pre>\n- * and a corresponding System Property:\n- * <pre>\n- *     {@systemProperty jdk.xml.isStandalone}\n- * <\/pre>\n- *\n- * <h3>System Properties<\/h3>\n- * A property may have a corresponding System Property with the same name.\n- * A System Property should be set prior to the creation of a processor and\n- * may be cleared afterwards.\n- *\n- * <h3>jaxp.properties<\/h3>\n- * A system property can be specified in the <a href=\"#JaxpProperties\">jaxp.properties<\/a>\n- * file to set the behavior for all invocations of the JDK. The format is\n- * {@code system-property-name=value}. For example:\n- * <pre>\n- *     {@code jdk.xml.isStandalone=true}\n- * <\/pre>\n- *\n- * <h3 id=\"ScopeAndOrder\">Scope and Order<\/h3>\n- * The {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING} feature\n- * (hereafter referred to as secure processing) is required for XML processors\n- * including DOM, SAX, Schema Validation, XSLT, and XPath. When secure processing\n- * is set to true, security related features and properties, such as those flagged\n- * as {@code \"security: yes\"} (hereafter referred to as security properties) in\n- * table <a href=\"#Features\">Implementation Specific Features<\/a> and\n- * <a href=\"#Properties\">Properties<\/a>,\n- * are enforced. Such enforcement includes setting security properties and features\n- * to more restrictive values and limits as shown in {@code \"Value\"}'s\n- * subcolumn {@code \"Enforced\"} in the tables. When secure processing\n- * is set to false, however, the property values will not be affected.\n- * <p>\n- * When the Java Security Manager is present, secure processing is set to true\n- * and can not be turned off. The security properties are therefore enforced.\n- * <p>\n- * Properties specified in the jaxp.properties file affect all invocations of\n- * the JDK, and will override their default values, or those that may have been\n- * set by secure processing.\n- * <p>\n- * System properties, when set, affect the invocation of the JDK and override\n- * the default settings or those that may have been set in jaxp.properties or\n- * by secure processing.\n+ *\n+ * <ul>\n+ * <li><a href=\"#IN_ISFP\">Implementation Specific Properties<\/a>\n+ *      <ul>\n+ *      <li><a href=\"#Processor\">Processor Support<\/a><\/li>\n+ *      <li><a href=\"#IN_ISFPtable\">List of Implementation Specific Properties<\/a><\/li>\n+ *      <li><a href=\"#IN_Legacy\">Legacy Property Names (deprecated)<\/a><\/li>\n+ *      <\/ul>\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * <h2 id=\"IN_ISFP\">Implementation Specific Properties<\/h2>\n+ * In addition to the standard <a href=\"#Conf_Properties\">JAXP Properties<\/a>,\n+ * the JDK implementation supports a number of implementation specific properties\n+ * whose name is prefixed by \"{@code jdk.xml.}\". These properties also follow the\n+ * configuration process as defined in the <a href=\"#Conf\">Configuration<\/a> section.\n@@ -306,3 +420,2 @@\n- * JAXP properties specified through JAXP factories or processors (e.g. SAXParser)\n- * take preference over system properties, the jaxp.properties file, as well as\n- * secure processing.\n+ * Refer to the <a href=\"#Properties\">Implementation Specific Properties<\/a> table\n+ * for the list of properties supported by the JDK implementation.\n@@ -311,2 +424,4 @@\n- * Features and properties may be supported by one or more processors. The\n- * following table lists the processors by IDs that can be used for reference.\n+ * The properties may be supported by one or more processors as listed in the table\n+ * below. Depending on the type of the property, they may be set via\n+ * Method 1: setAttribute\/Parameter\/Property or 2: setFeature as illustrated\n+ * in the relevant columns.\n@@ -320,2 +435,2 @@\n- * <th scope=\"col\">How to set the property<\/th>\n- * <th scope=\"col\">How to set the feature<\/th>\n+ * <th scope=\"col\">Method 1: setAttribute\/Parameter\/Property<\/th>\n+ * <th scope=\"col\">Method 2: setFeature<\/th>\n@@ -422,8 +537,1 @@\n- * <h3>Implementation Specific Features and Properties<\/h3>\n- * The Implementation Specific Features and Properties reflect JDK's choice to\n- * manage the limitations on resources while complying with the API specification,\n- * or allow applications to alter behaviors beyond those required by the standards.\n- * <p>\n- * The table below lists the Implementation Specific Properties currently supported\n- * by the JDK. More properties may be added in the future if necessary.\n- *\n+ * <div id=\"IN_ISFPtable\"><\/div>\n@@ -434,1 +542,1 @@\n- * <th scope=\"col\" rowspan=\"2\">Full Name (<a href=\"#NamingConvention\">prefix + name<\/a>)\n+ * <th scope=\"col\" rowspan=\"2\">Full Name (prefix {@code jdk.xml.})\n@@ -437,7 +545,5 @@\n- * <th scope=\"col\" rowspan=\"2\">API Property <a href=\"#Note2\">[2]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">System Property <a href=\"#Note3\">[3]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">jaxp.properties <a href=\"#Note3\">[3]<\/a><\/th>\n- * <th scope=\"col\" colspan=\"4\" style=\"text-align:center\">Value <a href=\"#Note4\">[4]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Security <a href=\"#Note5\">[5]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Supported Processor <a href=\"#Note6\">[6]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Since <a href=\"#Note7\">[7]<\/a><\/th>\n+ * <th scope=\"col\" rowspan=\"2\">System Property <a href=\"#Note2\">[2]<\/a><\/th>\n+ * <th scope=\"col\" colspan=\"4\" style=\"text-align:center\">Value <a href=\"#Note3\">[3]<\/a><\/th>\n+ * <th scope=\"col\" rowspan=\"2\">Security <a href=\"#Note4\">[4]<\/a><\/th>\n+ * <th scope=\"col\" colspan=\"2\">Supported Processor <a href=\"#Note5\">[5]<\/a><\/th>\n+ * <th scope=\"col\" rowspan=\"2\">Since <a href=\"#Note6\">[6]<\/a><\/th>\n@@ -450,0 +556,2 @@\n+ * <th scope=\"col\">ID<\/th>\n+ * <th scope=\"col\">Set Method<\/th>\n@@ -459,3 +567,1 @@\n- * <td style=\"text-align:center\" rowspan=\"9\">yes<\/td>\n- * <td style=\"text-align:center\" rowspan=\"9\">yes<\/td>\n- * <td style=\"text-align:center\" rowspan=\"9\">yes<\/td>\n+ * <td style=\"text-align:center\" rowspan=\"11\">yes<\/td>\n@@ -477,0 +583,1 @@\n+ * <td style=\"text-align:center\" rowspan=\"16\"><a href=\"#Processor\">Method 1<\/a><\/td>\n@@ -549,3 +656,0 @@\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">yes<\/td>\n@@ -573,3 +677,0 @@\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">yes<\/td>\n@@ -592,2 +693,0 @@\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">yes<\/td>\n@@ -609,2 +708,0 @@\n- * <td style=\"text-align:center\">yes<\/td>\n- * <td style=\"text-align:center\">no<\/td>\n@@ -624,5 +721,0 @@\n- * <td style=\"text-align:center\" rowspan=\"2\">\n- *     <a href=\"#Transform\">Transform<\/a>:yes<br>\n- *     <a href=\"#XPATH\">XPath<\/a>:no\n- * <\/td>\n- * <td style=\"text-align:center\" rowspan=\"3\">yes<\/td>\n@@ -643,1 +735,1 @@\n- * <td id=\"xpathExprGrpLimit\">jdk.xml.xpathExprGrpLimit<\/td>\n+ * <td id=\"xpathExprOpLimit\">jdk.xml.xpathExprOpLimit<\/td>\n@@ -653,1 +745,0 @@\n- * <td style=\"text-align:center\">yes<\/td>\n@@ -660,29 +751,0 @@\n- * <\/tbody>\n- * <\/table>\n- * <p>\n- * The table below lists the Implementation Specific Features currently supported\n- * by the JDK. More features may be added in the future if necessary.\n- *\n- * <table class=\"striped\" id=\"Features\">\n- * <caption>Implementation Specific Features<\/caption>\n- * <thead>\n- * <tr>\n- * <th scope=\"col\" rowspan=\"2\">Full Name (<a href=\"#NamingConvention\">prefix + name<\/a>)\n- * <a href=\"#Note1\">[1]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Description<\/th>\n- * <th scope=\"col\" rowspan=\"2\">API Property <a href=\"#Note2\">[2]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">System Property <a href=\"#Note3\">[3]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">jaxp.properties <a href=\"#Note3\">[3]<\/a><\/th>\n- * <th scope=\"col\" colspan=\"4\" style=\"text-align:center\">Value <a href=\"#Note4\">[4]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Security <a href=\"#Note5\">[5]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Supported Processor <a href=\"#Note6\">[6]<\/a><\/th>\n- * <th scope=\"col\" rowspan=\"2\">Since <a href=\"#Note7\">[7]<\/a><\/th>\n- * <\/tr>\n- * <tr>\n- * <th scope=\"col\">Type<\/th>\n- * <th scope=\"col\">Value<\/th>\n- * <th scope=\"col\">Default<\/th>\n- * <th scope=\"col\">Enforced<\/th>\n- * <\/tr>\n- * <\/thead>\n- * <tbody>\n@@ -694,2 +756,0 @@\n- * <td style=\"text-align:center\" rowspan=\"3\">yes<\/td>\n- * <td style=\"text-align:center\" rowspan=\"3\">yes<\/td>\n@@ -707,0 +767,1 @@\n+ * <td style=\"text-align:center\"><a href=\"#Processor\">Method 2<\/a><\/td>\n@@ -728,0 +789,1 @@\n+ * <td style=\"text-align:center\"><a href=\"#Processor\">Method 2<\/a><\/td>\n@@ -746,0 +808,1 @@\n+ * <td style=\"text-align:center\"><a href=\"#Processor\">Method 2<\/a><\/td>\n@@ -753,5 +816,3 @@\n- * <b>[2]<\/b> A value \"yes\" indicates that the property can be set through the\n- * processor or its factory, \"no\" otherwise.\n- * <p id=\"Note3\">\n- * <b>[3]<\/b> A value \"yes\" indicates there is a corresponding System Property\n- * for the property, \"no\" otherwise.\n+ * <b>[2]<\/b> A value \"yes\" indicates there is a corresponding System Property\n+ * for the property, \"no\" otherwise. The name of the System Property is the same\n+ * as that of the property.\n@@ -759,2 +820,2 @@\n- * <p id=\"Note4\">\n- * <b>[4]<\/b> The value must be exactly as listed in this table, case-sensitive.\n+ * <p id=\"Note3\">\n+ * <b>[3]<\/b> The value must be exactly as listed in this table, case-sensitive.\n@@ -769,0 +830,6 @@\n+ * <p id=\"Note4\">\n+ * <b>[4]<\/b> A value \"yes\" indicates the property is a Security Property. As indicated\n+ * in the <a href=\"#PP\">Property Precedence<\/a>, the values listed in the column\n+ * {@code enforced} will be used to initialize these properties when\n+ * {@link javax.xml.XMLConstants#FEATURE_SECURE_PROCESSING FSP} is true.\n+ *\n@@ -770,3 +837,2 @@\n- * <b>[5]<\/b> A value \"yes\" indicates the property is a Security Property. Refer\n- * to the <a href=\"#ScopeAndOrder\">Scope and Order<\/a> on how secure processing\n- * may affect the value of a Security Property.\n+ * <b>[5]<\/b> One or more processors that support the property. The IDs and Set Method\n+ * are as shown in the table <a href=\"#Processor\">Processors<\/a>.\n@@ -774,4 +840,1 @@\n- * <b>[6]<\/b> One or more processors that support the property. The values of the\n- * field are IDs described in table <a href=\"#Processor\">Processors<\/a>.\n- * <p id=\"Note7\">\n- * <b>[7]<\/b> Indicates the initial release the property is introduced.\n+ * <b>[6]<\/b> Indicates the initial release the property is introduced.\n@@ -779,1 +842,1 @@\n- * <h3>Legacy Property Names (deprecated)<\/h3>\n+ * <h3 id=\"IN_Legacy\">Legacy Property Names (deprecated)<\/h3>\n@@ -784,2 +847,1 @@\n- * as defined in <a href=\"#ScopeAndOrder\">Scope and Order<\/a> thus becomes, in\n- * descending order:\n+ * as defined in <a href=\"#PropPrec\">Property Precedence<\/a> thus becomes:\n@@ -788,5 +850,0 @@\n- * <li>The default value;<\/li>\n- * <li>Value set by FEATURE_SECURE_PROCESSING;<\/li>\n- * <li>Value set in jaxp.properties;<\/li>\n- * <li>Value set as System Property;<\/li>\n- * <li>Value set on factories or processors using <b>legacy property names<\/b>;<\/li>\n@@ -794,0 +851,5 @@\n+ * <li>Value set on factories or processors using <b>legacy property names<\/b>;<\/li>\n+ * <li>Value set as System Property;<\/li>\n+ * <li>Value set in the configuration file;<\/li>\n+ * <li>Value set by FEATURE_SECURE_PROCESSING;<\/li>\n+ * <li>The default value;<\/li>\n","filename":"src\/java.xml\/share\/classes\/module-info.java","additions":282,"deletions":220,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+################################################################################\n+#           JAXP Configuration File\n+#\n+# jaxp.properties (this file) is the default configuration file for JAXP, the API\n+# defined in the java.xml module. It is in java.util.Properties format and typically\n+# located in the {java.home}\/conf directory. It may contain key\/value pairs for\n+# specifying the implementation classes of JAXP factories and\/or properties\n+# that have corresponding system properties.\n+#\n+# A user-specified configuration file can be set up using the system property\n+# java.xml.config.file to override any or all of the entries in jaxp.properties.\n+# The following statement provides myConfigurationFile as a custom configuration\n+# file:\n+#     java -Djava.xml.config.file=myConfigurationFile\n+################################################################################\n+\n+# ---- JAXP Default Configuration ----\n+#\n+# The JAXP default configuration (jaxp.properties) contains entries for the\n+# Factory Lookup Mechanism and properties with corresponding system properties.\n+# The values are generally set to the default values of the properties.\n+#\n+#\n+# JAXP Lookup Mechanism:\n+#\n+# The JAXP configuration file ranks 2nd to the System Property in the precedent\n+# order of the JAXP Lookup Mechanism. When the System Property is not specified,\n+# a JAXP factory reads the configuration file in order to locate an implementation\n+# class. If found, the class specified will be used as the factory implementation\n+# class.\n+#\n+# The format of an entry is key=value where the key is the fully qualified name\n+# of the factory and value that of the implementation class. The following entry\n+# set a DocumentBuilderFactory implementation class:\n+#\n+# javax.xml.parsers.DocumentBuilderFactory=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl\n+#\n+#\n+# Java SE and JDK Implementation Specific Properties:\n+#\n+# The JAXP configuration file ranks above the default settings in the Property\n+# Precedence in that its entries will override the default values of the corresponding\n+# properties.\n+#\n+# All properties that have System Properties defined in Java SE or supported\n+# by the JDK Implementation can be placed in the configuration file to override\n+# the default property values. The format is:\n+#     system-property-name=value\n+#\n+# For example, the FILES property in CatalogFeatures has an associated system\n+# property called javax.xml.catalog.files. An entry for the FILES property in the\n+# configuration file would therefore use javax.xml.catalog.files as the key, that\n+# is:\n+#     javax.xml.catalog.files=strict\n+#\n+#\n+# Extension Functions:\n+#\n+# This property determines whether XSLT and XPath extension functions are allowed.\n+# The value type is boolean and the default value is true (allowing\n+# extension functions). The following entry would override the default value and\n+# disallow extension functions:\n+#\n+# jdk.xml.enableExtensionFunctions=false\n+#\n+#\n+# Overriding the default parser:\n+#\n+# This property allows using a third party implementation to override the default\n+# parser provided by the JDK. The value type is boolean and the default value is\n+# false, disallowing overriding the default parser. The setting below reflects\n+# the default property setting:\n+#\n+jdk.xml.overrideDefaultParser=false\n+#\n+#\n+# External Access Properties:\n+#\n+# The External Access Properties are defined in javax.xml.XMLConstants. Their\n+# system properties are javax.xml.accessExternalDTD, javax.xml.accessExternalSchema,\n+# and javax.xml.accessExternalStylesheet. The values are a list of protocols separated\n+# by comma, plus empty string (\"\") to represent no protocol allowed and the key\n+# word \"all\" for all access. The default is \"all\", allowing all external resources\n+# to be fetched. The followings are example of external access settings:\n+#\n+# allow local (file) DTDs to be retrieved\n+# javax.xml.accessExternalDTD=file\n+#\n+# allow local (file) and remote (http) external schemas\n+# javax.xml.accessExternalSchema=file, http\n+#\n+# reject any external stylesheets\n+# javax.xml.accessExternalStylesheet=\"\"\n+#\n+# allow all external stylesheets\n+# javax.xml.accessExternalStylesheet=\"all\"\n+#\n+#\n+# Catalog Properties:\n+#\n+# The Catalog API defines four features: FILES, PREFER, DEFER and RESOLVE.\n+# Except PREFER, all other properties can be placed in the configuration file\n+# using the system properties defined for them.\n+#\n+# FILES: A semicolon-delimited list of URIs to locate the catalog files. The URIs\n+# must be absolute and have a URL protocol handler for the URI scheme. The following\n+# is an example of setting up a catalog file:\n+#\n+# javax.xml.catalog.files = file:\/\/\/users\/auser\/catalog\/catalog.xml\n+#\n+# DEFER: Indicates that the alternative catalogs including those specified in\n+# delegate entries or nextCatalog are not read until they are needed. The value\n+# is a boolean and the default value is true.\n+#\n+# javax.xml.catalog.defer=true\n+#\n+# RESOLVE: Determines the action if there is no matching entry found after all of\n+# the specified catalogs are exhausted. The values are key words: strict, continue,\n+# and ignore. The default is strict. The following setting reflects the default\n+# setting.\n+#\n+# javax.xml.catalog.resolve=strict\n+#\n+#\n+# useCatalog:\n+# This property instructs XML processors to use XML Catalogs to resolve entity\n+# references. The value is a boolean and the default value is true.\n+#\n+# javax.xml.useCatalog=true\n+#\n+#\n+# Implementation Specific Properties - Limits\n+#\n+# Limits have a value type Integer. The values must be positive integers. Zero\n+# means no limit.\n+#\n+# Limits the number of entity expansions. The default value is 64000\n+# jdk.xml.entityExpansionLimit=64000\n+#\n+# Limits the total size of all entities that include general and parameter entities.\n+# The size is calculated as an aggregation of all entities. The default value is 5x10^7.\n+# jdk.xml.totalEntitySizeLimit=5E7\n+#\n+# Limits the maximum size of any general entities. The default value is 0.\n+# jdk.xml.maxGeneralEntitySizeLimit=0\n+#\n+# Limits the maximum size of any parameter entities, including the result of\n+# nesting multiple parameter entities. The default value is 10^6.\n+# jdk.xml.maxParameterEntitySizeLimit=1E6\n+#\n+# Limits the total number of nodes in all entity references. The default value is 3x10^6.\n+# jdk.xml.entityReplacementLimit=3E6\n+#\n+# Limits the number of attributes an element can have. The default value is 10000.\n+# jdk.xml.elementAttributeLimit=10000\n+#\n+# Limits the number of content model nodes that may be created when building a\n+# grammar for a W3C XML Schema that contains maxOccurs attributes with values\n+# other than \"unbounded\". The default value is 5000.\n+# jdk.xml.maxOccurLimit=5000\n+#\n+# Limits the maximum element depth. The default value is 0.\n+# jdk.xml.maxElementDepth=0\n+#\n+# Limits the maximum size of XML names, including element name, attribute name\n+# and namespace prefix and URI. The default value is 1000.\n+jdk.xml.maxXMLNameLimit=1000\n+#\n+#\n+# XPath Limits\n+#\n+# Limits the number of groups an XPath expression can contain. The default value is 10.\n+jdk.xml.xpathExprGrpLimit=10\n+#\n+# Limits the number of operators an XPath expression can contain. The default value is 100.\n+jdk.xml.xpathExprOpLimit=100\n+#\n+# Limits the total number of XPath operators in an XSL Stylesheet. The default value is 10000.\n+jdk.xml.xpathTotalOpLimit=10000\n+\n","filename":"src\/java.xml\/share\/conf\/jaxp.properties","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -447,0 +447,3 @@\n+                if ((c.flags_field & UNNAMED_CLASS) != 0) {\n+                    syms.removeClass(ps.modle, flatname);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,4 @@\n+    \/** Class is a unnamed top level class.\n+     *\/\n+    public static final int UNNAMED_CLASS    = 1<<19;\n+\n@@ -493,0 +497,1 @@\n+        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case UNNAMED_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,0 +241,1 @@\n+        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1259,0 +1259,1 @@\n+    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1370,4 +1371,9 @@\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public Name getQualifiedName() {\n-            return fullname;\n-        }\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getQualifiedName() {\n+             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+         }\n+\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getSimpleName() {\n+             return name;\n+         }\n@@ -1548,1 +1554,1 @@\n-            if (owner.kind == PCK)\n+            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n@@ -1639,0 +1645,5 @@\n+\n+        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+        public boolean isUnnamed() {\n+            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1660,0 +1660,1 @@\n+            boolean intSwitch = types.isAssignable(seltype, syms.intType);\n@@ -1661,2 +1662,1 @@\n-            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n-                !types.isAssignable(seltype, syms.intType)) {\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch && !intSwitch) {\n@@ -1709,0 +1709,4 @@\n+                                    Symbol enumSym = TreeInfo.symbol(expr);\n+                                    if (enumSym == null || !enumSym.isEnum() || enumSym.kind != VAR) {\n+                                        log.error(expr.pos(), Errors.EnumLabelMustBeEnumConstant);\n+                                    }\n@@ -1731,1 +1735,1 @@\n-                                    if (s != null && s.kind == TYP && allowPatternSwitch) {\n+                                    if (s != null && s.kind == TYP) {\n@@ -1734,1 +1738,1 @@\n-                                    } else if ((s != null && !s.isEnum()) || !allowPatternSwitch) {\n+                                    } else if (s == null || !s.isEnum()) {\n@@ -1736,1 +1740,3 @@\n-                                                  (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));\n+                                                  (stringSwitch ? Errors.StringConstReq\n+                                                                : intSwitch ? Errors.ConstExprReq\n+                                                                            : Errors.PatternOrEnumReq));\n@@ -1738,1 +1744,1 @@\n-                                } else if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                } else if (!stringSwitch && !intSwitch) {\n@@ -5508,0 +5514,4 @@\n+\n+                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                    chk.checkHasMain(env.tree.pos(), c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2253,0 +2253,30 @@\n+    public void checkHasMain(DiagnosticPosition pos, ClassSymbol c) {\n+        boolean found = false;\n+\n+        for (Symbol sym : c.members().getSymbolsByName(names.main)) {\n+            if (sym.kind == MTH && (sym.flags() & PRIVATE) == 0) {\n+                MethodSymbol meth = (MethodSymbol)sym;\n+                if (!types.isSameType(meth.getReturnType(), syms.voidType)) {\n+                    continue;\n+                }\n+                if (meth.params.isEmpty()) {\n+                    found = true;\n+                    break;\n+                }\n+                if (meth.params.size() != 1) {\n+                    continue;\n+                }\n+                if (!types.isSameType(meth.params.head.type, types.makeArrayType(syms.stringType))) {\n+                    continue;\n+                }\n+\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) {\n+            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,2 +311,0 @@\n-\/\/        Assert.checkNonNull(tree.modle, tree.sourcefile.toString());\n-\n@@ -444,0 +442,3 @@\n+            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+                syms.removeClass(env.toplevel.modle, tree.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1097,0 +1097,3 @@\n+                if (!it.hasTag(CLASS)) {\n+                    continue;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -2435,1 +2433,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2733,0 +2733,8 @@\n+        if (previewClassFile) {\n+            if ((c.flags_field & SYNTHETIC) != 0 &&\n+                    c.owner.kind == PCK &&\n+                    (c.flags_field & AUXILIARY) == 0 &&\n+                    (c.flags_field & FINAL) != 0) {\n+                c.flags_field |= UNNAMED_CLASS;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.reflect.Constructor;\n@@ -87,0 +88,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -204,2 +207,2 @@\n-        String[] appArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, appArgs, context);\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        execute(mainClassName, mainArgs, context);\n@@ -406,1 +409,3 @@\n-        String mainClassName = l.mainClass.getQualifiedName().toString();\n+        TypeElement mainClass = l.mainClass;\n+        String mainClassName = (mainClass.isUnnamed() ? mainClass.getSimpleName()\n+                                                      : mainClass.getQualifiedName()).toString();\n@@ -415,1 +420,1 @@\n-     * @param appArgs the arguments for the {@code main} method\n+     * @param mainArgs the arguments for the {@code main} method\n@@ -420,1 +425,1 @@\n-    private void execute(String mainClassName, String[] appArgs, Context context)\n+    private void execute(String mainClassName, String[] mainArgs, Context context)\n@@ -424,0 +429,2 @@\n+\n+        Class<?> appClass;\n@@ -425,11 +432,1 @@\n-            Class<?> appClass = Class.forName(mainClassName, true, cl);\n-            Method main = appClass.getDeclaredMethod(\"main\", String[].class);\n-            int PUBLIC_STATIC = Modifier.PUBLIC | Modifier.STATIC;\n-            if ((main.getModifiers() & PUBLIC_STATIC) != PUBLIC_STATIC) {\n-                throw new Fault(Errors.MainNotPublicStatic);\n-            }\n-            if (!main.getReturnType().equals(void.class)) {\n-                throw new Fault(Errors.MainNotVoid);\n-            }\n-            main.setAccessible(true);\n-            main.invoke(0, (Object) appArgs);\n+            appClass = Class.forName(mainClassName, true, cl);\n@@ -438,0 +435,5 @@\n+        }\n+\n+        Method mainMethod;\n+        try {\n+            mainMethod = MainMethodFinder.findMainMethod(appClass);\n@@ -440,0 +442,44 @@\n+        }\n+\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n+            throw new Fault(Errors.MainNotPublicStatic);\n+        }\n+\n+        if (!mainMethod.getReturnType().equals(void.class)) {\n+            throw new Fault(Errors.MainNotVoid);\n+        }\n+\n+        Object instance = null;\n+\n+        if (!isStatic) {\n+            Constructor<?> constructor;\n+            try {\n+                constructor = appClass.getDeclaredConstructor();\n+            } catch (NoSuchMethodException e) {\n+                throw new Fault(Errors.CantFindConstructor(mainClassName));\n+            }\n+\n+            try {\n+                constructor.setAccessible(true);\n+                instance = constructor.newInstance();\n+            } catch (InstantiationException | IllegalAccessException e) {\n+                throw new Fault(Errors.CantAccessConstructor(mainClassName));\n+            }\n+        }\n+\n+        try {\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+            Object receiver = isStatic ? appClass : instance;\n+\n+            if (noArgs) {\n+                mainMethod.invoke(receiver);\n+            } else {\n+                mainMethod.invoke(receiver, (Object)mainArgs);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":63,"deletions":17,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import javax.lang.model.SourceVersion;\n+\n@@ -39,0 +41,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -185,1 +188,1 @@\n-        docComments = newDocCommentTable(keepDocComments, fac);\n+        this.docComments = newDocCommentTable(keepDocComments, fac);\n@@ -188,1 +191,24 @@\n-        endPosTable = newEndPosTable(keepEndPositions);\n+        this.endPosTable = newEndPosTable(keepEndPositions);\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n+    }\n+\n+    \/** Construct a parser from an existing parser, with minimal overhead.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected JavacParser(JavacParser parser,\n+                          Lexer S) {\n+        this.S = S;\n+        this.token = parser.token;\n+        this.F = parser.F;\n+        this.log = parser.log;\n+        this.names = parser.names;\n+        this.source = parser.source;\n+        this.preview = parser.preview;\n+        this.allowStringFolding = parser.allowStringFolding;\n+        this.keepDocComments = false;\n+        this.parseModuleInfo = false;\n+        this.docComments = null;\n+        this.errorTree = F.Erroneous();\n+        this.endPosTable = newEndPosTable(false);\n@@ -627,0 +653,3 @@\n+                if (peekToken(LBRACKET)) {\n+                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UseOfUnderscoreNotAllowedWithBrackets);\n+                }\n@@ -892,1 +921,5 @@\n-                JCVariableDecl var = variableDeclaratorRest(varPos, mods, e, identOrUnderscore(), false, null, false, false, true);\n+                Name name = identOrUnderscore();\n+                if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+                    name = names.empty;\n+                }\n+                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n@@ -2790,4 +2823,1 @@\n-            if (token.kind == INTERFACE ||\n-                token.kind == CLASS ||\n-                token.kind == ENUM ||\n-                isRecordStart()) {\n+            if (isDeclaration()) {\n@@ -3621,1 +3651,1 @@\n-        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false, false);\n+        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);\n@@ -3636,1 +3666,1 @@\n-        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true, false);\n+        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true);\n@@ -3646,1 +3676,1 @@\n-                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound, boolean isTypePattern) {\n+                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound) {\n@@ -3648,1 +3678,0 @@\n-        type = bracketsOpt(type);\n@@ -3650,0 +3679,1 @@\n+        type = bracketsOpt(type);\n@@ -3652,1 +3682,1 @@\n-            if (!localDecl && !isTypePattern) {\n+            if (!localDecl) {\n@@ -3671,23 +3701,20 @@\n-        JCVariableDecl result;\n-        if (!isTypePattern) {\n-            int startPos = Position.NOPOS;\n-            JCTree elemType = TreeInfo.innermostType(type, true);\n-            if (elemType.hasTag(IDENT)) {\n-                Name typeName = ((JCIdent) elemType).name;\n-                if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n-                    if (typeName != names.var) {\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n-                    } else if (type.hasTag(TYPEARRAY) && !compound) {\n-                        \/\/error - 'var' and arrays\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n-                    } else {\n-                        declaredUsingVar = true;\n-                        if (compound)\n-                            \/\/error - 'var' in compound local var decl\n-                            reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n-                        startPos = TreeInfo.getStartPos(mods);\n-                        if (startPos == Position.NOPOS)\n-                            startPos = TreeInfo.getStartPos(type);\n-                        \/\/implicit type\n-                        type = null;\n-                    }\n+        int startPos = Position.NOPOS;\n+        JCTree elemType = TreeInfo.innermostType(type, true);\n+        if (elemType.hasTag(IDENT)) {\n+            Name typeName = ((JCIdent) elemType).name;\n+            if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n+                if (typeName != names.var) {\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n+                } else if (type.hasTag(TYPEARRAY) && !compound) {\n+                    \/\/error - 'var' and arrays\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n+                } else {\n+                    declaredUsingVar = true;\n+                    if (compound)\n+                        \/\/error - 'var' in compound local var decl\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n+                    startPos = TreeInfo.getStartPos(mods);\n+                    if (startPos == Position.NOPOS)\n+                        startPos = TreeInfo.getStartPos(type);\n+                    \/\/implicit type\n+                    type = null;\n@@ -3696,5 +3723,0 @@\n-            result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n-            attach(result, dc);\n-            result.startPos = startPos;\n-        } else {\n-            result = toP(F.at(pos).VarDef(mods, name, type, null));\n@@ -3702,1 +3724,3 @@\n-\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+        attach(result, dc);\n+        result.startPos = startPos;\n@@ -3846,1 +3870,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n@@ -3851,1 +3875,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n@@ -3893,0 +3917,1 @@\n+        boolean isUnnamedClass = false;\n@@ -3951,0 +3976,1 @@\n+\n@@ -3952,4 +3978,29 @@\n-                JCTree def = typeDeclaration(mods, docComment);\n-                if (def instanceof JCExpressionStatement statement)\n-                    def = statement.expr;\n-                defs.append(def);\n+                boolean isTopLevelMethodOrField = false;\n+\n+                \/\/ Do to a significant number of existing negative tests\n+                \/\/ this code speculatively tests to see if a top level method\n+                \/\/ or field can parse. If the method or field can parse then\n+                \/\/ it is parsed. Otherwise, parsing continues as though\n+                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ is the same as in the past.\n+                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                    final JCModifiers finalMods = mods;\n+                    JavacParser speculative = new VirtualParser(this);\n+                    List<JCTree> speculativeResult =\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                    if (speculativeResult.head.hasTag(METHODDEF) ||\n+                        speculativeResult.head.hasTag(VARDEF)) {\n+                        isTopLevelMethodOrField = true;\n+                    }\n+                }\n+\n+                if (isTopLevelMethodOrField) {\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n+                    isUnnamedClass = true;\n+                } else {\n+                    JCTree def = typeDeclaration(mods, docComment);\n+                    if (def instanceof JCExpressionStatement statement)\n+                        def = statement.expr;\n+                    defs.append(def);\n+                }\n+\n@@ -3960,1 +4011,2 @@\n-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n+        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(topLevelDefs);\n@@ -3974,0 +4026,37 @@\n+    \/\/ Restructure top level to be an unnamed class.\n+    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+        checkSourceLevel(Feature.UNNAMED_CLASSES);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : origDefs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else if (!def.hasTag(Tag.SKIP)) {\n+                defs.append(def);\n+            }\n+        }\n+\n+        int primaryPos = defs.first().pos;\n+        String simplename = PathFileObject.getSimpleName(log.currentSourceFile());\n+\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(primaryPos, Errors.BadFileName(simplename));\n+        }\n+\n+        Name name = names.fromString(simplename);\n+        JCModifiers unnamedMods = F.at(primaryPos)\n+                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n+        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n+                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(unnamed);\n+        return topDefs.toList();\n+    }\n+\n@@ -4134,1 +4223,2 @@\n-            final JCErroneous erroneousTree;\n+\n+            JCDiagnostic.Error error;\n@@ -4136,1 +4226,3 @@\n-                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                error = Errors.ExpectedModuleOrOpen;\n+            } else if (allowRecords) {\n+                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n@@ -4138,5 +4230,1 @@\n-                if (allowRecords) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                } else {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                }\n+                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n@@ -4144,1 +4232,2 @@\n-            return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(syntaxError(pos, errs, error)));\n+\n@@ -4365,1 +4454,1 @@\n-                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,\n+                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, enumName,\n@@ -4471,1 +4560,1 @@\n-            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));\n+            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, className, isInterface, isRecord));\n@@ -4475,1 +4564,1 @@\n-           }\n+            }\n@@ -4510,1 +4599,3 @@\n-    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {\n+    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(JCModifiers mods, Name className,\n+                                                                   boolean isInterface,\n+                                                                   boolean isRecord) {\n@@ -4517,5 +4608,2 @@\n-            JCModifiers mods = modifiersOpt();\n-            if (token.kind == CLASS ||\n-                allowRecords && isRecordStart() ||\n-                token.kind == INTERFACE ||\n-                token.kind == ENUM) {\n+            mods = modifiersOpt(mods);\n+            if (isDeclaration()) {\n@@ -4533,9 +4621,4 @@\n-                pos = token.pos;\n-                List<JCTypeParameter> typarams = typeParametersOpt();\n-                \/\/ if there are type parameters but no modifiers, save the start\n-                \/\/ position of the method in the modifiers.\n-                if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n-                    mods.pos = pos;\n-                    storeEnd(mods, pos);\n-                }\n-                List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+                return constructorOrMethodOrFieldDeclaration(mods, className, isInterface, isRecord, dc);\n+            }\n+        }\n+    }\n@@ -4543,5 +4626,13 @@\n-                if (annosAfterParams.nonEmpty()) {\n-                    mods.annotations = mods.annotations.appendList(annosAfterParams);\n-                    if (mods.pos == Position.NOPOS)\n-                        mods.pos = mods.annotations.head.pos;\n-                }\n+    private List<JCTree> constructorOrMethodOrFieldDeclaration(JCModifiers mods, Name className,\n+                                                               boolean isInterface,\n+                                                               boolean isRecord, Comment dc) {\n+        int pos;\n+        pos = token.pos;\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n@@ -4549,71 +4640,30 @@\n-                Token tk = token;\n-                pos = token.pos;\n-                JCExpression type;\n-                boolean isVoid = token.kind == VOID;\n-                if (isVoid) {\n-                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n-                    nextToken();\n-                } else {\n-                    \/\/ method returns types are un-annotated types\n-                    type = unannotatedType(false);\n-                }\n-                if ((token.kind == LPAREN && !isInterface ||\n-                        isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n-                    if (isInterface || tk.name() != className)\n-                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n-                    else if (annosAfterParams.nonEmpty())\n-                        illegal(annosAfterParams.head.pos);\n-                    if (isRecord && token.kind == LBRACE) {\n-                        mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n-                    }\n-                    return List.of(methodDeclaratorRest(\n-                        pos, mods, null, names.init, typarams,\n-                        isInterface, true, isRecord, dc));\n-                } else if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n-                    \/\/ trying to define a compact constructor with a throws clause\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                            Errors.InvalidCanonicalConstructorInRecord(\n-                                    Fragments.Compact,\n-                                    className,\n-                                    Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n-                    skip(false, true, false, false);\n-                    return List.of(methodDeclaratorRest(\n-                            pos, mods, null, names.init, typarams,\n-                            isInterface, true, isRecord, dc));\n-                } else {\n-                    pos = token.pos;\n-                    Name name = ident();\n-                    if (token.kind == LPAREN) {\n-                        return List.of(methodDeclaratorRest(\n-                            pos, mods, type, name, typarams,\n-                            isInterface, isVoid, false, dc));\n-                    } else if (!isVoid && typarams.isEmpty()) {\n-                        if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n-                        List<JCTree> defs =\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                                    new ListBuffer<JCTree>(), false).toList();\n-                        accept(SEMI);\n-                        storeEnd(defs.last(), S.prevToken().endPos);\n-                        return defs;\n-                    } else {\n-                            int errPos = pos;\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                    new ListBuffer<JCTree>(), false).toList();\n-                            accept(SEMI);\n-                            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n-                        }\n-                    } else {\n-                        pos = token.pos;\n-                        List<JCTree> err;\n-                        if (isVoid || typarams.nonEmpty()) {\n-                            JCMethodDecl m =\n-                                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n-                                                            List.nil(), List.nil(), null, null));\n-                            attach(m, dc);\n-                            err = List.of(m);\n-                        } else {\n-                            err = List.nil();\n-                        }\n-                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n-                    }\n-                }\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        Token tk = token;\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            \/\/ method returns types are un-annotated types\n+            type = unannotatedType(false);\n+        }\n+\n+        \/\/ Constructor\n+        if ((token.kind == LPAREN && !isInterface ||\n+                isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n+            if (isInterface || tk.name() != className) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+            } else if (annosAfterParams.nonEmpty()) {\n+                illegal(annosAfterParams.head.pos);\n+            }\n+\n+            if (isRecord && token.kind == LBRACE) {\n+                mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n@@ -4621,0 +4671,28 @@\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        \/\/ Record constructor\n+        if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n+            \/\/ trying to define a compact constructor with a throws clause\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.InvalidCanonicalConstructorInRecord(\n+                            Fragments.Compact,\n+                            className,\n+                            Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n+            skip(false, true, false, false);\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        pos = token.pos;\n+        Name name = ident();\n+\n+        \/\/ Method\n+        if (token.kind == LPAREN) {\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, type, name, typarams,\n+                    isInterface, isVoid, false, dc));\n@@ -4622,0 +4700,34 @@\n+\n+        \/\/ Field\n+        if (!isVoid && typarams.isEmpty()) {\n+            if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n+                List<JCTree> defs =\n+                    variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                                            new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+                return defs;\n+            }\n+\n+            int errPos = pos;\n+            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                    new ListBuffer<JCTree>(), false).toList();\n+            accept(SEMI);\n+            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n+         }\n+\n+         pos = token.pos;\n+         List<JCTree> err;\n+\n+         \/\/ Error recovery\n+         if (isVoid || typarams.nonEmpty()) {\n+             JCMethodDecl m =\n+                     toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                                             List.nil(), List.nil(), null, null));\n+             attach(m, dc);\n+             err = List.of(m);\n+         } else {\n+             err = List.nil();\n+         }\n+\n+         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n@@ -4624,0 +4736,64 @@\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n+        int topPos = token.pos;\n+        int pos = token.pos;\n+        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            type = unannotatedType(false);\n+        }\n+\n+        if (token.kind == IDENTIFIER) {\n+            pos = token.pos;\n+            Name name = ident();\n+\n+            \/\/ Method\n+            if (token.kind == LPAREN) {\n+                return List.of(methodDeclaratorRest(pos, mods, type, name, typarams,\n+                        false, isVoid, false, dc));\n+            }\n+\n+            \/\/ Field\n+            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+                List<JCTree> defs =\n+                        variableDeclaratorsRest(pos, mods, type, name, false, dc,\n+                                new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+\n+                return defs;\n+            }\n+        }\n+\n+        return List.of(F.Erroneous());\n+    }\n+\n+    protected boolean isDeclaration() {\n+        return token.kind == CLASS ||\n+               token.kind == INTERFACE ||\n+               token.kind == ENUM ||\n+               isRecordStart() && allowRecords;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":326,"deletions":150,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private final Tokens tokens;\n+    protected Tokens tokens;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCErroneous;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.Error;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Position.LineMap;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The virtual parser allows for speculative parsing while not commiting to\n+ * consuming tokens unless the speculation is successful.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class VirtualParser extends JavacParser {\n+\n+    private boolean hasErrors;\n+\n+    public VirtualParser(JavacParser parser) {\n+        super(parser, new VirtualScanner(parser.S));\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(DiagnosticPosition diagPos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    public boolean hasErrors() {\n+        return hasErrors;\n+    }\n+\n+    \/**\n+     * Scanner that does token lookahead and throws AssertionErrors if an error\n+     * occurs.\n+     *\/\n+    public static class VirtualScanner implements Lexer {\n+        \/** Parent scanner.\n+         *\/\n+        Lexer S;\n+\n+        \/** Token offset from where parent scanner branched.\n+         *\/\n+        int offset = 0;\n+\n+        \/** The token, set by nextToken().\n+         *\/\n+        private Token token;\n+\n+        \/** The previous token, set by nextToken().\n+         *\/\n+        private Token prevToken;\n+\n+        public VirtualScanner(Lexer s) {\n+            while (s instanceof VirtualScanner virtualScanner) {\n+                s = virtualScanner.S;\n+                offset += virtualScanner.offset;\n+            }\n+            S = s;\n+            token = s.token();\n+            prevToken = S.prevToken();\n+        }\n+\n+        @Override\n+        public void nextToken() {\n+            prevToken = token;\n+            offset++;\n+            token = token();\n+        }\n+\n+        @Override\n+        public Token token() {\n+            return token(0);\n+        }\n+\n+        @Override\n+        public Token token(int lookahead) {\n+            return S.token(offset + lookahead);\n+        }\n+\n+        @Override\n+        public Token prevToken() {\n+            return prevToken;\n+        }\n+\n+        @Override\n+        public void setPrevToken(Token prevToken) {\n+            this.prevToken = prevToken;\n+        }\n+\n+        @Override\n+        public Token split() {\n+            Token[] splitTokens = token.split(((Scanner)S).tokens);\n+            prevToken = splitTokens[0];\n+            token = splitTokens[1];\n+            return token;\n+        }\n+\n+        @Override\n+        public int errPos() {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public void errPos(int pos) {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public LineMap getLineMap() {\n+            return S.getLineMap();\n+        }\n+\n+        public void commit() {\n+            for (int i = 0 ; i < offset ; i++) {\n+                S.nextToken(); \/\/ advance underlying lexer until position matches\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Attempts a parse action and returns true if successful or false if\n+     * a parse error is thrown.\n+     *\n+     * @param parser        parent parser\n+     * @param parserAction  function that takes a parser and invokes a method on that parser\n+     *\n+     * @return true if successful\n+     *\/\n+    public static boolean tryParse(JavacParser parser, Consumer<JavacParser> parserAction) {\n+        VirtualParser virtualParser = new VirtualParser(parser);\n+        try {\n+            parserAction.accept(virtualParser);\n+            return true;\n+        } catch (AssertionError ex) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -121,0 +121,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -128,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous class\n+                \/\/ Don't print out the constructor of an anonymous or unnamed class\n@@ -131,1 +132,1 @@\n-                    NestingKind.ANONYMOUS ==\n+                    (NestingKind.ANONYMOUS ==\n@@ -138,1 +139,8 @@\n-                    }).visit(enclosing))\n+                    }).visit(enclosing)\n+                    || \/\/ Don't print the constructor of an unnamed class\n+                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n+                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+                        public Boolean visitType(TypeElement e, Void p) {\n+                            return e.isUnnamed();\n+                        }\n+                    }).visit(enclosing)) ) {\n@@ -140,0 +148,1 @@\n+                }\n@@ -172,0 +181,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -205,0 +215,8 @@\n+            } else if (e.isUnnamed()) {\n+                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getSimpleName());\n+\n+                for(Element element : e.getEnclosedElements()) {\n+                    this.visit(element);\n+                }\n+\n+                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,0 +414,3 @@\n+compiler.err.pattern.or.enum.req=\\\n+    pattern or enum constant required\n+\n@@ -512,0 +515,10 @@\n+# 0: string\n+compiler.err.bad.file.name=\\\n+    bad file name: {0}\n+\n+compiler.err.unnamed.class.should.not.have.package.declaration=\\\n+    unnamed class should not have package declaration\n+\n+compiler.err.unnamed.class.does.not.have.main.method=\\\n+    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+\n@@ -579,0 +592,3 @@\n+compiler.err.enum.label.must.be.enum.constant=\\\n+    an enum switch constant case label must be an enumeration constant\n+\n@@ -3155,0 +3171,3 @@\n+compiler.misc.feature.unnamed.classes=\\\n+    unnamed classes\n+\n@@ -3165,0 +3184,3 @@\n+compiler.err.use.of.underscore.not.allowed.with.brackets=\\\n+    the underscore keyword ''_'' is not allowed to be followed by brackets\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -122,0 +122,8 @@\n+# 0: string\n+launcher.err.cant.find.constructor=\\\n+    can''t find no argument constructor in class: {0}\n+\n+# 0: string\n+launcher.err.cant.access.constructor=\\\n+    can''t access no argument constructor in class: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,2 @@\n+                || node instanceof JCMethodDecl\n+                || node instanceof JCVariableDecl\n@@ -1162,1 +1164,1 @@\n-        return false;\n+        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,2 +359,1 @@\n-        return name.subName(\n-            name.lastIndexOf((byte)'.') + 1, name.getByteLength());\n+        return name.subName(start, end);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,1 @@\n+    public final Name main;\n@@ -391,0 +392,1 @@\n+        main = fromString(\"main\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -265,1 +265,0 @@\n-                char[] tokenLabel = token.tokenInfo.label;\n@@ -267,2 +266,1 @@\n-                reqBlockUpdates = ((tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n-                        && tokenLabel[2] == 'S') ? true : false);\n+                reqBlockUpdates = P11Util.isNSS(token);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,3 +144,1 @@\n-        char[] tokenLabel = this.token.tokenInfo.label;\n-        isNSS = (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n-                && tokenLabel[2] == 'S');\n+        isNSS = P11Util.isNSS(this.token);\n@@ -357,0 +355,12 @@\n+    static SecretKey pbeKey(Session session, long keyID, String algorithm,\n+            int keyLength, CK_ATTRIBUTE[] attrs, char[] password, byte[] salt,\n+            int iterationCount) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+            new CK_ATTRIBUTE(CKA_TOKEN),\n+            new CK_ATTRIBUTE(CKA_SENSITIVE),\n+            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+        });\n+        return new P11PBEKey(session, keyID, algorithm, keyLength,\n+                attrs, password, salt, iterationCount);\n+    }\n+\n@@ -490,0 +500,39 @@\n+    static final class P11PBEKey extends P11SecretKey\n+            implements PBEKey {\n+        private static final long serialVersionUID = 6847576994253634876L;\n+        private char[] password;\n+        private final byte[] salt;\n+        private final int iterationCount;\n+        P11PBEKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attributes,\n+                char[] password, byte[] salt, int iterationCount) {\n+            super(session, keyID, algorithm, keyLength, attributes);\n+            this.password = password.clone();\n+            this.salt = salt.clone();\n+            this.iterationCount = iterationCount;\n+        }\n+\n+        @Override\n+        public char[] getPassword() {\n+            if (password == null) {\n+                throw new IllegalStateException(\"password has been cleared\");\n+            }\n+            return password.clone();\n+        }\n+\n+        @Override\n+        public byte[] getSalt() {\n+            return salt.clone();\n+        }\n+\n+        @Override\n+        public int getIterationCount() {\n+            return iterationCount;\n+        }\n+\n+        void clearPassword() {\n+            Arrays.fill(password, '\\0');\n+            password = null;\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":53,"deletions":4,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.security.spec.InvalidKeySpecException;\n@@ -34,0 +35,2 @@\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -42,0 +45,1 @@\n+import sun.security.util.PBEUtil;\n@@ -68,0 +72,3 @@\n+    \/\/ PBEKeyInfo if algorithm is PBE-related, otherwise null\n+    private final P11SecretKeyFactory.PBEKeyInfo svcPbeKi;\n+\n@@ -91,0 +98,1 @@\n+        this.svcPbeKi = P11SecretKeyFactory.getPBEKeyInfo(algorithm);\n@@ -195,0 +203,38 @@\n+        reset(true);\n+        p11Key = null;\n+        if (svcPbeKi != null) {\n+            if (key instanceof P11Key) {\n+                \/\/ If the key is a P11Key, it must come from a PBE derivation\n+                \/\/ because this is a PBE Mac service. In addition to checking\n+                \/\/ the key, check that params (if passed) are consistent.\n+                PBEUtil.checkKeyAndParams(key, params, algorithm);\n+            } else {\n+                \/\/ If the key is not a P11Key, a derivation is needed. Data for\n+                \/\/ derivation has to be carried either as part of the key or\n+                \/\/ params. Use SunPKCS11 PBE key derivation to obtain a P11Key.\n+                \/\/ Assign the derived key to p11Key because conversion is never\n+                \/\/ needed for this case.\n+                PBEKeySpec pbeKeySpec = PBEUtil.getPBAKeySpec(key, params);\n+                try {\n+                    P11Key.P11PBEKey p11PBEKey =\n+                            P11SecretKeyFactory.derivePBEKey(token,\n+                            pbeKeySpec, svcPbeKi);\n+                    \/\/ This Mac service uses the token where the derived key\n+                    \/\/ lives so there won't be any need to re-derive and use\n+                    \/\/ the password. The p11Key cannot be accessed out of this\n+                    \/\/ class.\n+                    p11PBEKey.clearPassword();\n+                    p11Key = p11PBEKey;\n+                } catch (InvalidKeySpecException e) {\n+                    throw new InvalidKeyException(e);\n+                } finally {\n+                    pbeKeySpec.clearPassword();\n+                }\n+            }\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                \/\/ For PBE services, reassign params to the underlying\n+                \/\/ service params. Notice that Mac services expect this\n+                \/\/ value to be null.\n+                params = pbeParams.getParameterSpec();\n+            }\n+        }\n@@ -196,2 +242,7 @@\n-            throw new InvalidAlgorithmParameterException\n-                (\"Parameters not supported\");\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Parameters not supported\");\n+        }\n+        \/\/ In non-PBE cases and PBE cases where we didn't derive,\n+        \/\/ a key conversion might be needed.\n+        if (p11Key == null) {\n+            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n@@ -199,2 +250,0 @@\n-        reset(true);\n-        p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.CipherSpi;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import sun.security.jca.JCAUtil;\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+import sun.security.util.PBEUtil;\n+\n+final class P11PBECipher extends CipherSpi {\n+    private final Token token;\n+    private final String pbeAlg;\n+    private final P11Cipher cipher;\n+    private final int blkSize;\n+    private final P11SecretKeyFactory.PBEKeyInfo svcPbeKi;\n+    private final PBEUtil.PBES2Params pbes2Params = new PBEUtil.PBES2Params();\n+\n+    P11PBECipher(Token token, String pbeAlg, long cipherMech)\n+                    throws PKCS11Exception, NoSuchAlgorithmException {\n+        super();\n+        String cipherTrans;\n+        if (cipherMech == CKM_AES_CBC_PAD || cipherMech == CKM_AES_CBC) {\n+            cipherTrans = \"AES\/CBC\/PKCS5Padding\";\n+        } else {\n+            throw new NoSuchAlgorithmException(\n+                    \"Cipher transformation not supported.\");\n+        }\n+        cipher = new P11Cipher(token, cipherTrans, cipherMech);\n+        blkSize = cipher.engineGetBlockSize();\n+        this.pbeAlg = pbeAlg;\n+        svcPbeKi = P11SecretKeyFactory.getPBEKeyInfo(pbeAlg);\n+        assert svcPbeKi != null : \"algorithm must be in KeyInfo map\";\n+        this.token = token;\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineSetMode(String mode)\n+            throws NoSuchAlgorithmException {\n+        cipher.engineSetMode(mode);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineSetPadding(String padding)\n+            throws NoSuchPaddingException {\n+        cipher.engineSetPadding(padding);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return cipher.engineGetBlockSize();\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        return cipher.engineGetOutputSize(inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return cipher.engineGetIV();\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return pbes2Params.getAlgorithmParameters(blkSize, pbeAlg,\n+                P11Util.getSunJceProvider(), JCAUtil.getSecureRandom());\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            SecureRandom random) throws InvalidKeyException {\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new InvalidKeyException(\"requires PBE parameters\", e);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+                    throws InvalidKeyException,\n+                    InvalidAlgorithmParameterException {\n+        if (key instanceof P11Key) {\n+            \/\/ If the key is a P11Key, it must come from a PBE derivation\n+            \/\/ because this is a PBE Cipher service. In addition to checking the\n+            \/\/ key, check that params (if passed) are consistent.\n+            PBEUtil.checkKeyAndParams(key, params, pbeAlg);\n+            \/\/ At this point, we know that the key is a P11PBEKey.\n+            P11Key.P11PBEKey p11PBEKey = (P11Key.P11PBEKey) key;\n+            \/\/ PBE services require a PBE key of the same algorithm and the\n+            \/\/ underlying service (non-PBE) won't check it.\n+            if (!pbeAlg.equals(p11PBEKey.getAlgorithm())) {\n+                throw new InvalidKeyException(\"Cannot use a \" +\n+                        p11PBEKey.getAlgorithm() + \" key for a \" + pbeAlg +\n+                        \" service\");\n+            }\n+            if (params instanceof PBEParameterSpec pbeParams) {\n+                params = pbeParams.getParameterSpec();\n+            }\n+            pbes2Params.initialize(blkSize, opmode,\n+                    p11PBEKey.getIterationCount(), p11PBEKey.getSalt(), params,\n+                    random);\n+        } else {\n+            \/\/ If the key is not a P11Key, a derivation is needed. Data for\n+            \/\/ derivation has to be carried either as part of the key or params.\n+            \/\/ Use SunPKCS11 PBE key derivation to obtain a P11Key.\n+            PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n+                    blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n+            try {\n+                P11Key.P11PBEKey p11PBEKey = P11SecretKeyFactory.derivePBEKey(\n+                        token, pbeSpec, svcPbeKi);\n+                \/\/ The internal Cipher service uses the token where the\n+                \/\/ derived key lives so there won't be any need to re-derive\n+                \/\/ and use the password. The key cannot be accessed out of this\n+                \/\/ class.\n+                p11PBEKey.clearPassword();\n+                key = p11PBEKey;\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            } finally {\n+                pbeSpec.clearPassword();\n+            }\n+        }\n+        cipher.engineInit(opmode, key, pbes2Params.getIvSpec(), random);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n+                    throws InvalidKeyException,\n+                    InvalidAlgorithmParameterException {\n+        engineInit(opmode, key, PBEUtil.PBES2Params.getParameterSpec(params),\n+                random);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset,\n+            int inputLen) {\n+        return cipher.engineUpdate(input, inputOffset, inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset,\n+            int inputLen, byte[] output, int outputOffset)\n+                    throws ShortBufferException {\n+        return cipher.engineUpdate(input, inputOffset, inputLen,\n+                output, outputOffset);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n+            int inputLen)\n+                    throws IllegalBlockSizeException, BadPaddingException {\n+        return cipher.engineDoFinal(input, inputOffset, inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset,\n+            int inputLen, byte[] output, int outputOffset)\n+                    throws ShortBufferException, IllegalBlockSizeException,\n+                    BadPaddingException {\n+        return cipher.engineDoFinal(input, inputOffset, inputLen, output,\n+                outputOffset);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetKeySize(Key key) {\n+        \/\/ It's guaranteed that when engineInit succeeds, the key length\n+        \/\/ for the underlying cipher is equal to the PBE service key length.\n+        \/\/ Otherwise, initialization fails.\n+        return svcPbeKi.keyLen;\n+    }\n+\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PBECipher.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -34,0 +35,1 @@\n+import javax.crypto.interfaces.PBEKey;\n@@ -37,0 +39,2 @@\n+\n+import jdk.internal.access.SharedSecrets;\n@@ -55,0 +59,3 @@\n+    \/\/ PBEKeyInfo if algorithm is PBE-related, otherwise null\n+    private final PBEKeyInfo svcPbeKi;\n+\n@@ -59,0 +66,82 @@\n+        this.svcPbeKi = getPBEKeyInfo(algorithm);\n+    }\n+\n+    private static final Map<String, KeyInfo> keyInfo = new HashMap<>();\n+    private static final KeyInfo HMAC = new KeyInfo(\"HMAC\", PCKK_HMAC);\n+    private static final KeyInfo SSLMAC = new KeyInfo(\"SSLMAC\", PCKK_SSLMAC);\n+\n+    static KeyInfo getKeyInfo(String algo) {\n+        KeyInfo ki = keyInfo.get(algo);\n+        if (ki == null) {\n+            String algoUpper = algo.toUpperCase(Locale.ENGLISH);\n+            ki = keyInfo.get(algoUpper);\n+            if (ki == null) {\n+                if (algoUpper.startsWith(\"HMAC\")) {\n+                    return HMAC;\n+                } else if (algoUpper.startsWith(\"SSLMAC\")) {\n+                    return SSLMAC;\n+                }\n+            }\n+        }\n+        return ki;\n+    }\n+\n+    static PBEKeyInfo getPBEKeyInfo(String algo) {\n+        if (getKeyInfo(algo) instanceof PBEKeyInfo pbeKi) {\n+            return pbeKi;\n+        }\n+        return null;\n+    }\n+\n+    private static void putKeyInfo(KeyInfo ki) {\n+        keyInfo.put(ki.algo, ki);\n+        keyInfo.put(ki.algo.toUpperCase(Locale.ENGLISH), ki);\n+    }\n+\n+    static sealed class KeyInfo permits PBEKeyInfo {\n+        public final String algo;\n+        public final long keyType;\n+\n+        KeyInfo(String algo, long keyType) {\n+            this.algo = algo;\n+            this.keyType = keyType;\n+        }\n+\n+        \/\/ The P11SecretKeyFactory::convertKey method needs to know if a service\n+        \/\/ type and a key are compatible. Trivial cases such as having the same\n+        \/\/ algorithm names are handled directly. KeyInfo::checkUse helps with\n+        \/\/ cases that require to retrieve the key's KeyInfo (ki), in addition to\n+        \/\/ the service's KeyInfo (si), to make a decision.\n+        static boolean checkUse(KeyInfo ki, KeyInfo si) {\n+            if (si instanceof PBEKeyInfo && !si.algo.equals(ki.algo)) {\n+                \/\/ PBE services require a PBE key of the same algorithm.\n+                return false;\n+            }\n+            if (ki instanceof PBKDF2KeyInfo) {\n+                \/\/ We cannot tell what the PBE key was derived for,\n+                \/\/ so any service is allowed in principle.\n+                return true;\n+            }\n+            \/\/ This path handles non-PBE cases where aliases are used (i.e:\n+            \/\/ RC4 vs ARCFOUR) and mixed PBE - non-PBE cases (i.e.: a\n+            \/\/ PBE-derived AES key used in an AES Cipher service).\n+            return ki.keyType == si.keyType;\n+        }\n+    }\n+\n+    static abstract sealed class PBEKeyInfo extends KeyInfo\n+            permits AESPBEKeyInfo, PBKDF2KeyInfo, P12MacPBEKeyInfo {\n+        public static final long INVALID_PRF = -1;\n+        public final long kdfMech;\n+        public final long prfMech;\n+        public final int keyLen;\n+        public final CK_ATTRIBUTE[] extraAttrs;\n+\n+        protected PBEKeyInfo(String algo, long kdfMech, long prfMech,\n+                long keyType, int keyLen, CK_ATTRIBUTE[] extraAttrs) {\n+            super(algo, keyType);\n+            this.kdfMech = kdfMech;\n+            this.prfMech = prfMech;\n+            this.keyLen = keyLen;\n+            this.extraAttrs = extraAttrs;\n+        }\n@@ -61,1 +150,27 @@\n-    private static final Map<String,Long> keyTypes;\n+    static final class AESPBEKeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.ENCRYPT_TRUE};\n+\n+        AESPBEKeyInfo(String algo, long prfMech, int keyLen) {\n+            super(algo, CKM_PKCS5_PBKD2, prfMech, CKK_AES, keyLen, attr);\n+        }\n+    }\n+\n+    static final class PBKDF2KeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.ENCRYPT_TRUE, CK_ATTRIBUTE.SIGN_TRUE};\n+\n+        PBKDF2KeyInfo(String algo, long prfMech) {\n+            super(algo, CKM_PKCS5_PBKD2, prfMech, CKK_GENERIC_SECRET, -1, attr);\n+        }\n+    }\n+\n+    static final class P12MacPBEKeyInfo extends PBEKeyInfo {\n+        private static final CK_ATTRIBUTE[] attr = new CK_ATTRIBUTE[] {\n+                CK_ATTRIBUTE.SIGN_TRUE};\n+\n+        P12MacPBEKeyInfo(String algo, long kdfMech, int keyLen) {\n+            super(algo, kdfMech, PBEKeyInfo.INVALID_PRF,\n+                    CKK_GENERIC_SECRET, keyLen, attr);\n+        }\n+    }\n@@ -64,9 +179,8 @@\n-        keyTypes = new HashMap<String,Long>();\n-        addKeyType(\"RC4\",      CKK_RC4);\n-        addKeyType(\"ARCFOUR\",  CKK_RC4);\n-        addKeyType(\"DES\",      CKK_DES);\n-        addKeyType(\"DESede\",   CKK_DES3);\n-        addKeyType(\"AES\",      CKK_AES);\n-        addKeyType(\"Blowfish\", CKK_BLOWFISH);\n-        addKeyType(\"ChaCha20\", CKK_CHACHA20);\n-        addKeyType(\"ChaCha20-Poly1305\", CKK_CHACHA20);\n+        putKeyInfo(new KeyInfo(\"RC4\", CKK_RC4));\n+        putKeyInfo(new KeyInfo(\"ARCFOUR\", CKK_RC4));\n+        putKeyInfo(new KeyInfo(\"DES\", CKK_DES));\n+        putKeyInfo(new KeyInfo(\"DESede\", CKK_DES3));\n+        putKeyInfo(new KeyInfo(\"AES\", CKK_AES));\n+        putKeyInfo(new KeyInfo(\"Blowfish\", CKK_BLOWFISH));\n+        putKeyInfo(new KeyInfo(\"ChaCha20\", CKK_CHACHA20));\n+        putKeyInfo(new KeyInfo(\"ChaCha20-Poly1305\", CKK_CHACHA20));\n@@ -76,2 +190,2 @@\n-        addKeyType(\"RC2\",      CKK_RC2);\n-        addKeyType(\"IDEA\",     CKK_IDEA);\n+        putKeyInfo(new KeyInfo(\"RC2\", CKK_RC2));\n+        putKeyInfo(new KeyInfo(\"IDEA\", CKK_IDEA));\n@@ -79,5 +193,25 @@\n-        addKeyType(\"TlsPremasterSecret\",    PCKK_TLSPREMASTER);\n-        addKeyType(\"TlsRsaPremasterSecret\", PCKK_TLSRSAPREMASTER);\n-        addKeyType(\"TlsMasterSecret\",       PCKK_TLSMASTER);\n-        addKeyType(\"Generic\",               CKK_GENERIC_SECRET);\n-    }\n+        putKeyInfo(new KeyInfo(\"TlsPremasterSecret\", PCKK_TLSPREMASTER));\n+        putKeyInfo(new KeyInfo(\"TlsRsaPremasterSecret\", PCKK_TLSRSAPREMASTER));\n+        putKeyInfo(new KeyInfo(\"TlsMasterSecret\", PCKK_TLSMASTER));\n+        putKeyInfo(new KeyInfo(\"Generic\", CKK_GENERIC_SECRET));\n+\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA1AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA224AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA256AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA384AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA512AndAES_128\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512, 128));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA1AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA224AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA256AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA384AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384, 256));\n+        putKeyInfo(new AESPBEKeyInfo(\"PBEWithHmacSHA512AndAES_256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512, 256));\n@@ -85,4 +219,21 @@\n-    private static void addKeyType(String name, long id) {\n-        Long l = Long.valueOf(id);\n-        keyTypes.put(name, l);\n-        keyTypes.put(name.toUpperCase(Locale.ENGLISH), l);\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA1\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA1));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA224\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA224));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA256\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA256));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA384\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA384));\n+        putKeyInfo(new PBKDF2KeyInfo(\"PBKDF2WithHmacSHA512\",\n+                CKP_PKCS5_PBKD2_HMAC_SHA512));\n+\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA1\",\n+                CKM_PBA_SHA1_WITH_SHA1_HMAC, 160));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA224\",\n+                CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN, 224));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA256\",\n+                CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN, 256));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA384\",\n+                CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN, 384));\n+        putKeyInfo(new P12MacPBEKeyInfo(\"HmacPBESHA512\",\n+                CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN, 512));\n@@ -91,2 +242,1 @@\n-    \/\/ returns the PKCS11 key type of the specified algorithm\n-    \/\/ no pseudo KeyTypes\n+    \/\/ No pseudo key types\n@@ -101,1 +251,0 @@\n-    \/\/ returns direct lookup result of keyTypes using algorithm\n@@ -103,13 +252,2 @@\n-        Long l = keyTypes.get(algorithm);\n-        if (l == null) {\n-            algorithm = algorithm.toUpperCase(Locale.ENGLISH);\n-            l = keyTypes.get(algorithm);\n-            if (l == null) {\n-                if (algorithm.startsWith(\"HMAC\")) {\n-                    return PCKK_HMAC;\n-                } else if (algorithm.startsWith(\"SSLMAC\")) {\n-                    return PCKK_SSLMAC;\n-                }\n-            }\n-        }\n-        return (l != null) ? l.longValue() : -1;\n+        KeyInfo ki = getKeyInfo(algorithm);\n+        return ki == null ? -1 : ki.keyType;\n@@ -122,1 +260,1 @@\n-    static P11Key convertKey(Token token, Key key, String algo)\n+    static P11Key convertKey(Token token, Key key, String svcAlgo)\n@@ -124,1 +262,1 @@\n-        return convertKey(token, key, algo, null);\n+        return convertKey(token, key, svcAlgo, null);\n@@ -132,3 +270,2 @@\n-    static P11Key convertKey(Token token, Key key, String algo,\n-            CK_ATTRIBUTE[] extraAttrs)\n-            throws InvalidKeyException {\n+    static P11Key convertKey(Token token, Key key, String svcAlgo,\n+            CK_ATTRIBUTE[] extraAttrs) throws InvalidKeyException {\n@@ -136,3 +273,0 @@\n-        if (key == null) {\n-            throw new InvalidKeyException(\"Key must not be null\");\n-        }\n@@ -142,14 +276,20 @@\n-        long algoType;\n-        if (algo == null) {\n-            algo = key.getAlgorithm();\n-            algoType = getKeyType(algo);\n-        } else {\n-            algoType = getKeyType(algo);\n-            long keyAlgorithmType = getKeyType(key.getAlgorithm());\n-            if (algoType != keyAlgorithmType) {\n-                if ((algoType == PCKK_HMAC) || (algoType == PCKK_SSLMAC)) {\n-                    \/\/ ignore key algorithm for MACs\n-                } else {\n-                    throw new InvalidKeyException\n-                            (\"Key algorithm must be \" + algo);\n-                }\n+        final String keyAlgo = key.getAlgorithm();\n+        if (keyAlgo == null) {\n+            throw new InvalidKeyException(\"Key must specify its algorithm\");\n+        }\n+        if (svcAlgo == null) {\n+            svcAlgo = keyAlgo;\n+        }\n+        KeyInfo ki = null;\n+        KeyInfo si = getKeyInfo(svcAlgo);\n+        if (si == null) {\n+            throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n+        }\n+        \/\/ Check if the key can be used for the service.\n+        \/\/ Any key can be used for a MAC service.\n+        if (svcAlgo != keyAlgo &&\n+                si.keyType != PCKK_HMAC && si.keyType != PCKK_SSLMAC) {\n+            ki = getKeyInfo(keyAlgo);\n+            if (ki == null || !KeyInfo.checkUse(ki, si)) {\n+                throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n+                        \" key for a \" + svcAlgo + \" service\");\n@@ -187,2 +327,29 @@\n-        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n-            throw new InvalidKeyException(\"Encoded format must be RAW\");\n+        if (key instanceof PBEKey pbeKey) {\n+            ki = ki == null ? getKeyInfo(keyAlgo) : ki;\n+            if (ki instanceof PBEKeyInfo pbeKi) {\n+                PBEKeySpec keySpec = getPbeKeySpec(pbeKey);\n+                try {\n+                    p11Key = derivePBEKey(token, keySpec, pbeKi);\n+                } catch (InvalidKeySpecException e) {\n+                    throw new InvalidKeyException(e);\n+                } finally {\n+                    keySpec.clearPassword();\n+                }\n+            } else {\n+                throw new InvalidKeyException(\"Cannot derive unknown \" +\n+                        keyAlgo + \" algorithm\");\n+            }\n+        } else {\n+            if (si instanceof PBEKeyInfo) {\n+                throw new InvalidKeyException(\"PBE service requires a PBE key\");\n+            }\n+            if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+                throw new InvalidKeyException(\"Encoded format must be RAW\");\n+            }\n+            byte[] encoded = key.getEncoded();\n+            try {\n+                p11Key = createKey(token, encoded, svcAlgo, si.keyType,\n+                        extraAttrs);\n+            } finally {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -190,2 +357,0 @@\n-        byte[] encoded = key.getEncoded();\n-        p11Key = createKey(token, encoded, algo, algoType, extraAttrs);\n@@ -196,0 +361,119 @@\n+    static P11Key.P11PBEKey derivePBEKey(Token token, PBEKeySpec keySpec,\n+            PBEKeyInfo pbeKi) throws InvalidKeySpecException {\n+        token.ensureValid();\n+        if (keySpec == null) {\n+            throw new InvalidKeySpecException(\"PBEKeySpec must not be null\");\n+        }\n+        Session session = null;\n+        char[] password = null;\n+        char[] encPassword = null;\n+        try {\n+            session = token.getObjSession();\n+            CK_MECHANISM ckMech;\n+            password = keySpec.getPassword();\n+            byte[] salt = keySpec.getSalt();\n+            int itCount = keySpec.getIterationCount();\n+            int keySize = keySpec.getKeyLength();\n+            assert password != null :\n+                    \"PBEKeySpec does not allow a null password\";\n+            if (salt == null) {\n+                throw new InvalidKeySpecException(\"Salt not found\");\n+            }\n+            assert salt.length > 0 : \"PBEKeySpec does not allow an empty salt\";\n+            if (itCount < 1) {\n+                throw new InvalidKeySpecException(\"Iteration count must be \" +\n+                        \"a non-zero positive integer\");\n+            }\n+            if (pbeKi.keyLen > 0) {\n+                if (keySize == 0) {\n+                    keySize = pbeKi.keyLen;\n+                } else if (keySize != pbeKi.keyLen) {\n+                    throw new InvalidKeySpecException(\n+                            \"Key length is invalid for \" + pbeKi.algo + \" (\" +\n+                            \"expecting \" + pbeKi.keyLen + \" but was \" +\n+                            keySize + \")\");\n+                }\n+            }\n+            if (keySize < 1 || keySize % 8 != 0) {\n+                throw new InvalidKeySpecException(\"Key length must be \" +\n+                        \"multiple of 8 and greater than zero\");\n+            }\n+\n+            if (pbeKi.kdfMech == CKM_PKCS5_PBKD2) {\n+                encPassword = P11Util.encodePassword(password,\n+                        StandardCharsets.UTF_8, 0);\n+                CK_VERSION p11Ver = token.p11.getVersion();\n+                if (P11Util.isNSS(token) || p11Ver.major < 2 ||\n+                        p11Ver.major == 2 && p11Ver.minor < 40) {\n+                    \/\/ NSS keeps using the old structure beyond PKCS #11 v2.40.\n+                    ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                            new CK_PKCS5_PBKD2_PARAMS(encPassword, salt,\n+                                    itCount, pbeKi.prfMech));\n+                } else {\n+                    ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                            new CK_PKCS5_PBKD2_PARAMS2(encPassword, salt,\n+                                    itCount, pbeKi.prfMech));\n+                }\n+            } else {\n+                \/*\n+                 * PKCS #12 \"General Method\" PBKD (RFC 7292, Appendix B.2).\n+                 *\n+                 * According to PKCS #11, \"password\" in CK_PBE_PARAMS is of\n+                 * CK_UTF8CHAR_PTR type. While this suggests a UTF-8 encoding,\n+                 * RFC 7292 Appendix B.1 indicates that the password has to be\n+                 * encoded as a BMPString with a 2-bytes NULL terminator.\n+                 *\/\n+                encPassword = P11Util.encodePassword(password,\n+                        StandardCharsets.UTF_16BE, 2);\n+                ckMech = new CK_MECHANISM(pbeKi.kdfMech,\n+                        new CK_PBE_PARAMS(encPassword, salt, itCount));\n+            }\n+\n+            CK_ATTRIBUTE[] attrs =\n+                    new CK_ATTRIBUTE[3 + pbeKi.extraAttrs.length];\n+            attrs[0] = new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY);\n+            attrs[1] = new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3);\n+            attrs[2] = new CK_ATTRIBUTE(CKA_KEY_TYPE, pbeKi.keyType);\n+            System.arraycopy(pbeKi.extraAttrs, 0, attrs, 3,\n+                    pbeKi.extraAttrs.length);\n+            CK_ATTRIBUTE[] attr = token.getAttributes(\n+                    O_GENERATE, CKO_SECRET_KEY, pbeKi.keyType, attrs);\n+            long keyID = token.p11.C_GenerateKey(session.id(), ckMech, attr);\n+            return (P11Key.P11PBEKey) P11Key.pbeKey(session, keyID, pbeKi.algo,\n+                    keySize, attr, password, salt, itCount);\n+        } catch (PKCS11Exception e) {\n+            throw new InvalidKeySpecException(\"Could not create key\", e);\n+        } finally {\n+            if (encPassword != null) {\n+                Arrays.fill(encPassword, '\\0');\n+            }\n+            if (password != null) {\n+                Arrays.fill(password, '\\0');\n+            }\n+            token.releaseSession(session);\n+        }\n+    }\n+\n+    private static PBEKeySpec getPbeKeySpec(PBEKey pbeKey) {\n+        int keyLength = 0;\n+        if (\"RAW\".equalsIgnoreCase(pbeKey.getFormat())) {\n+            byte[] encoded = pbeKey.getEncoded();\n+            if (encoded != null) {\n+                keyLength = encoded.length << 3;\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n+        }\n+        int ic = pbeKey.getIterationCount();\n+        byte[] salt = pbeKey.getSalt();\n+        char[] pwd = pbeKey.getPassword();\n+        try {\n+            return keyLength == 0 ?\n+                    new PBEKeySpec(pwd, salt, ic) :\n+                    new PBEKeySpec(pwd, salt, ic, keyLength);\n+        } finally {\n+            if (pwd != null) {\n+                Arrays.fill(pwd, '\\0');\n+            }\n+        }\n+    }\n+\n@@ -289,1 +573,1 @@\n-        if (keySpec instanceof SecretKeySpec) {\n+        if (keySpec instanceof SecretKeySpec secretKeySpec) {\n@@ -291,1 +575,1 @@\n-                Key key = convertKey(token, (SecretKey)keySpec, algorithm);\n+                Key key = convertKey(token, secretKeySpec, algorithm);\n@@ -296,0 +580,3 @@\n+        } else if (keySpec instanceof PBEKeySpec pbeKeySpec &&\n+                svcPbeKi != null) {\n+            return derivePBEKey(token, pbeKeySpec, svcPbeKi);\n@@ -297,4 +584,2 @@\n-            if (keySpec instanceof DESKeySpec) {\n-                byte[] keyBytes = ((DESKeySpec)keySpec).getKey();\n-                keySpec = new SecretKeySpec(keyBytes, \"DES\");\n-                return engineGenerateSecret(keySpec);\n+            if (keySpec instanceof DESKeySpec desKeySpec) {\n+                return generateDESSecret(desKeySpec.getKey(), \"DES\");\n@@ -303,4 +588,2 @@\n-            if (keySpec instanceof DESedeKeySpec) {\n-                byte[] keyBytes = ((DESedeKeySpec)keySpec).getKey();\n-                keySpec = new SecretKeySpec(keyBytes, \"DESede\");\n-                return engineGenerateSecret(keySpec);\n+            if (keySpec instanceof DESedeKeySpec desEdeKeySpec) {\n+                return generateDESSecret(desEdeKeySpec.getKey(), \"DESede\");\n@@ -313,0 +596,17 @@\n+    private SecretKey generateDESSecret(byte[] keyBytes, String desAlgo)\n+            throws InvalidKeySpecException {\n+        SecretKeySpec secretKeySpec = null;\n+        try {\n+            secretKeySpec = new SecretKeySpec(keyBytes, desAlgo);\n+            return engineGenerateSecret(secretKeySpec);\n+        } finally {\n+            if (secretKeySpec != null) {\n+                SharedSecrets.getJavaxCryptoSpecAccess()\n+                        .clearSecretKeySpec(secretKeySpec);\n+            }\n+            if (keyBytes != null) {\n+                Arrays.fill(keyBytes, (byte) 0);\n+            }\n+        }\n+    }\n+\n@@ -317,2 +617,1 @@\n-                throw new InvalidKeySpecException\n-                    (\"Could not obtain key bytes\");\n+                throw new InvalidKeySpecException(\"Could not obtain key bytes\");\n@@ -337,0 +636,3 @@\n+        } else if (keySpec.isAssignableFrom(PBEKeySpec.class) &&\n+                key instanceof PBEKey pbeKey && svcPbeKi != null) {\n+            return getPbeKeySpec(pbeKey);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":378,"deletions":76,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n@@ -54,0 +57,40 @@\n+    static boolean isNSS(Token token) {\n+        char[] tokenLabel = token.tokenInfo.label;\n+        if (tokenLabel != null && tokenLabel.length >= 3) {\n+            return (tokenLabel[0] == 'N' && tokenLabel[1] == 'S'\n+                    && tokenLabel[2] == 'S');\n+        }\n+        return false;\n+    }\n+\n+    static char[] encodePassword(char[] password, Charset cs,\n+            int nullTermBytes) {\n+        \/*\n+         * When a Java char (2 bytes) is converted to CK_UTF8CHAR (1 byte) for\n+         * a PKCS #11 (native) call, the high-order byte is discarded (see\n+         * jCharArrayToCKUTF8CharArray in p11_util.c). In order to have an\n+         * encoded string passed to C_GenerateKey, we need to account for\n+         * truncation and expand beforehand: high and low parts of each char\n+         * are split into 2 chars. As an example, this is the transformation\n+         * for a NULL terminated password \"a\" that has to be encoded in\n+         * UTF-16 BE:\n+         *     char[] password       => [    0x0061,         0x0000    ]\n+         *                                   \/    \\          \/    \\\n+         * ByteBuffer passwordBytes  => [ 0x00,   0x61,   0x00,   0x00 ]\n+         *                                  |       |       |       |\n+         *     char[] encPassword    => [0x0000, 0x0061, 0x0000, 0x0000]\n+         *                                  |       |       |       |\n+         *     PKCS #11 call (bytes) => [ 0x00,   0x61,   0x00,   0x00 ]\n+         *\/\n+        ByteBuffer passwordBytes = cs.encode(CharBuffer.wrap(password));\n+        char[] encPassword =\n+                new char[passwordBytes.remaining() + nullTermBytes];\n+        int i = 0;\n+        while (passwordBytes.hasRemaining()) {\n+            encPassword[i] = (char) (passwordBytes.get() & 0xFF);\n+            \/\/ Erase password bytes as we read during encoding.\n+            passwordBytes.put(i++, (byte) 0);\n+        }\n+        return encPassword;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Util.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -424,0 +424,1 @@\n+        final int[] requiredMechs;\n@@ -426,1 +427,8 @@\n-                List<String> aliases, int[] mechanisms) {\n+                           List<String> aliases, int[] mechanisms) {\n+            this(type, algorithm, className, aliases, mechanisms, null);\n+        }\n+        \/\/ mechanisms is a list of possible mechanisms that implement the\n+        \/\/ algorithm, at least one of them must be available. requiredMechs\n+        \/\/ is a list of auxiliary mechanisms, all of them must be available\n+        private Descriptor(String type, String algorithm, String className,\n+                List<String> aliases, int[] mechanisms, int[] requiredMechs) {\n@@ -432,0 +440,1 @@\n+            this.requiredMechs = requiredMechs;\n@@ -473,0 +482,6 @@\n+    private static void d(String type, String algorithm, String className,\n+            int[] m, int[] requiredMechs) {\n+        register(new Descriptor(type, algorithm, className, null, m,\n+                requiredMechs));\n+    }\n+\n@@ -479,0 +494,6 @@\n+    private static void dA(String type, String algorithm, String className,\n+            int[] m, int[] requiredMechs) {\n+        register(new Descriptor(type, algorithm, className,\n+                getAliases(algorithm), m, requiredMechs));\n+    }\n+\n@@ -529,0 +550,1 @@\n+        String P11PBECipher        = \"sun.security.pkcs11.P11PBECipher\";\n@@ -591,0 +613,18 @@\n+        \/*\n+        * PBA HMacs\n+        *\n+        * KeyDerivationMech must be supported\n+        * for these services to be available.\n+        *\n+        *\/\n+        d(MAC, \"HmacPBESHA1\",       P11Mac, m(CKM_SHA_1_HMAC),\n+                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n+        d(MAC, \"HmacPBESHA224\",     P11Mac, m(CKM_SHA224_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA256\",     P11Mac, m(CKM_SHA256_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA384\",     P11Mac, m(CKM_SHA384_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n+        d(MAC, \"HmacPBESHA512\",     P11Mac, m(CKM_SHA512_HMAC),\n+                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n+\n@@ -689,0 +729,54 @@\n+        \/*\n+         * PBE Secret Key Factories\n+         *\n+         * KeyDerivationPrf must be supported for these services\n+         * to be available.\n+         *\n+        *\/\n+        d(SKF, \"PBEWithHmacSHA1AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBEWithHmacSHA224AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBEWithHmacSHA256AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBEWithHmacSHA384AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBEWithHmacSHA512AndAES_128\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+        d(SKF, \"PBEWithHmacSHA1AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBEWithHmacSHA224AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBEWithHmacSHA256AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBEWithHmacSHA384AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBEWithHmacSHA512AndAES_256\",\n+                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+        \/*\n+         * PBA Secret Key Factories\n+         *\/\n+        d(SKF, \"HmacPBESHA1\",       P11SecretKeyFactory,\n+                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n+        d(SKF, \"HmacPBESHA224\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA256\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA384\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n+        d(SKF, \"HmacPBESHA512\",     P11SecretKeyFactory,\n+                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n+        \/*\n+         * PBKDF2 Secret Key Factories\n+         *\/\n+        dA(SKF, \"PBKDF2WithHmacSHA1\",  P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA224\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA256\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA384\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n+        d(SKF, \"PBKDF2WithHmacSHA512\", P11SecretKeyFactory,\n+                m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n+\n@@ -782,0 +876,38 @@\n+        \/*\n+         * PBE Ciphers\n+         *\n+         * KeyDerivationMech and KeyDerivationPrf must be supported\n+         * for these services to be available.\n+         *\n+        *\/\n+        d(CIP, \"PBEWithHmacSHA1AndAES_128\",   P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA_1_HMAC));\n+        d(CIP, \"PBEWithHmacSHA224AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA224_HMAC));\n+        d(CIP, \"PBEWithHmacSHA256AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA256_HMAC));\n+        d(CIP, \"PBEWithHmacSHA384AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA384_HMAC));\n+        d(CIP, \"PBEWithHmacSHA512AndAES_128\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA512_HMAC));\n+        d(CIP, \"PBEWithHmacSHA1AndAES_256\",   P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA_1_HMAC));\n+        d(CIP, \"PBEWithHmacSHA224AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA224_HMAC));\n+        d(CIP, \"PBEWithHmacSHA256AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA256_HMAC));\n+        d(CIP, \"PBEWithHmacSHA384AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA384_HMAC));\n+        d(CIP, \"PBEWithHmacSHA512AndAES_256\", P11PBECipher,\n+                m(CKM_AES_CBC_PAD, CKM_AES_CBC),\n+                m(CKM_PKCS5_PBKD2, CKM_SHA512_HMAC));\n+\n@@ -1172,0 +1304,1 @@\n+            descLoop:\n@@ -1175,0 +1308,11 @@\n+                    if (d.requiredMechs != null) {\n+                        \/\/ Check that other mechanisms required for the\n+                        \/\/ service are supported before listing it as\n+                        \/\/ available for the first time.\n+                        for (int requiredMech : d.requiredMechs) {\n+                            if (token.getMechanismInfo(\n+                                    requiredMech & 0xFFFFFFFFL) == null) {\n+                                continue descLoop;\n+                            }\n+                        }\n+                    }\n@@ -1275,0 +1419,2 @@\n+                } else if (algorithm.startsWith(\"PBE\")) {\n+                    return new P11PBECipher(token, algorithm, mechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":147,"deletions":1,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS.\n+     * Returns the string representation of CK_ECDH1_DERIVE_PARAMS.\n@@ -105,1 +105,1 @@\n-     * @return the string representation of CK_PKCS5_PBKD2_PARAMS\n+     * @return the string representation of CK_ECDH1_DERIVE_PARAMS\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_ECDH1_DERIVE_PARAMS.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,12 @@\n+    public CK_MECHANISM(long mechanism, CK_PBE_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n+    public CK_MECHANISM(long mechanism, CK_PKCS5_PBKD2_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n+    public CK_MECHANISM(long mechanism, CK_PKCS5_PBKD2_PARAMS2 params) {\n+        init(mechanism, params);\n+    }\n+\n@@ -196,1 +208,1 @@\n-        sb.append(mechanism);\n+        sb.append(Functions.getMechanismName(mechanism));\n@@ -200,1 +212,2 @@\n-        sb.append(\"pParameter: \");\n+        sb.append(\"pParameter:\");\n+        sb.append(Constants.NEWLINE);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * class CK_PBE_PARAMS provides all of the necessary information required byte\n+ * class CK_PBE_PARAMS provides all the necessary information required by\n@@ -58,2 +58,2 @@\n- *   CK_CHAR_PTR pInitVector;\n- *   CK_CHAR_PTR pPassword;\n+ *   CK_BYTE_PTR pInitVector;\n+ *   CK_UTF8CHAR_PTR pPassword;\n@@ -61,1 +61,1 @@\n- *   CK_CHAR_PTR pSalt;\n+ *   CK_BYTE_PTR pSalt;\n@@ -75,1 +75,1 @@\n-     *   CK_CHAR_PTR pInitVector;\n+     *   CK_BYTE_PTR pInitVector;\n@@ -78,1 +78,1 @@\n-    public char[] pInitVector;\n+    public byte[] pInitVector;\n@@ -83,1 +83,1 @@\n-     *   CK_CHAR_PTR pPassword;\n+     *   CK_UTF8CHAR_PTR pPassword;\n@@ -92,1 +92,1 @@\n-     *   CK_CHAR_PTR pSalt\n+     *   CK_BYTE_PTR pSalt\n@@ -96,1 +96,1 @@\n-    public char[] pSalt;\n+    public byte[] pSalt;\n@@ -106,0 +106,6 @@\n+    public CK_PBE_PARAMS(char[] pPassword, byte[] pSalt, long ulIteration) {\n+         this.pPassword = pPassword;\n+         this.pSalt = pSalt;\n+         this.ulIteration = ulIteration;\n+     }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PBE_PARAMS.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n@@ -58,1 +58,1 @@\n- *   CK_PKCS5_PBKD2_SALT_SOURCE_TYPE saltSource;\n+ *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n@@ -65,0 +65,2 @@\n+ *   CK_UTF8CHAR_PTR pPassword;\n+ *   CK_ULONG_PTR ulPasswordLen;\n@@ -115,0 +117,18 @@\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_UTF8CHAR_PTR pPassword\n+     *   CK_ULONG_PTR ulPasswordLen;\n+     * <\/pre>\n+     *\/\n+    public char[] pPassword;\n+\n+    public CK_PKCS5_PBKD2_PARAMS(char[] pPassword, byte[] pSalt,\n+            long iterations, long prf) {\n+        this.pPassword = pPassword;\n+        this.pSaltSourceData = pSalt;\n+        this.iterations = iterations;\n+        this.prf = prf;\n+        this.saltSource = CKZ_SALT_SPECIFIED;\n+    }\n+\n@@ -125,1 +145,1 @@\n-        sb.append(saltSource);\n+        sb.append(Functions.getParamSourcesName(saltSource));\n@@ -135,1 +155,1 @@\n-        sb.append(pSaltSourceData.length);\n+        sb.append(Functions.getLength(pSaltSourceData));\n@@ -145,1 +165,1 @@\n-        sb.append(prf);\n+        sb.append(Functions.getPrfName(prf));\n@@ -155,1 +175,1 @@\n-        sb.append(pPrfData.length);\n+        sb.append(Functions.getLength(pPrfData));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+\n+\/**\n+ * class CK_PKCS5_PBKD2_PARAMS2 provides the parameters to the CKM_PKCS5_PBKD2\n+ * mechanism.<p>\n+ * <b>PKCS#11 structure:<\/b>\n+ * <pre>\n+ * typedef struct CK_PKCS5_PBKD2_PARAMS2 {\n+ *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n+ *   CK_VOID_PTR pSaltSourceData;\n+ *   CK_ULONG ulSaltSourceDataLen;\n+ *   CK_ULONG iterations;\n+ *   CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;\n+ *   CK_VOID_PTR pPrfData;\n+ *   CK_ULONG ulPrfDataLen;\n+ *   CK_UTF8CHAR_PTR pPassword;\n+ *   CK_ULONG ulPasswordLen;\n+ * } CK_PKCS5_PBKD2_PARAMS2;\n+ * <\/pre>\n+ *\n+ *\/\n+public class CK_PKCS5_PBKD2_PARAMS2 {\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;\n+     * <\/pre>\n+     *\/\n+    public long saltSource;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_VOID_PTR pSaltSourceData;\n+     *   CK_ULONG ulSaltSourceDataLen;\n+     * <\/pre>\n+     *\/\n+    public byte[] pSaltSourceData;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_ULONG iterations;\n+     * <\/pre>\n+     *\/\n+    public long iterations;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;\n+     * <\/pre>\n+     *\/\n+    public long prf;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_VOID_PTR pPrfData;\n+     *   CK_ULONG ulPrfDataLen;\n+     * <\/pre>\n+     *\/\n+    public byte[] pPrfData;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_UTF8CHAR_PTR pPassword\n+     *   CK_ULONG ulPasswordLen;\n+     * <\/pre>\n+     *\/\n+    public char[] pPassword;\n+\n+    public CK_PKCS5_PBKD2_PARAMS2(char[] pPassword, byte[] pSalt,\n+            long iterations, long prf) {\n+        this.pPassword = pPassword;\n+        this.pSaltSourceData = pSalt;\n+        this.iterations = iterations;\n+        this.prf = prf;\n+        this.saltSource = CKZ_SALT_SPECIFIED;\n+    }\n+\n+    \/**\n+     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS2.\n+     *\n+     * @return the string representation of CK_PKCS5_PBKD2_PARAMS2\n+     *\/\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"saltSource: \");\n+        sb.append(Functions.getParamSourcesName(saltSource));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pSaltSourceData: \");\n+        sb.append(Functions.toHexString(pSaltSourceData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulSaltSourceDataLen: \");\n+        sb.append(Functions.getLength(pSaltSourceData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"iterations: \");\n+        sb.append(iterations);\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"prf: \");\n+        sb.append(Functions.getPrfName(prf));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pPrfData: \");\n+        sb.append(Functions.toHexString(pPrfData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulPrfDataLen: \");\n+        sb.append(Functions.getLength(pPrfData));\n+\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS2.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -97,1 +97,1 @@\n-     * Returns the string representation of CK_PKCS5_PBKD2_PARAMS.\n+     * Returns the string representation of CK_X9_42_DH1_DERIVE_PARAMS.\n@@ -99,1 +99,1 @@\n-     * @return the string representation of CK_PKCS5_PBKD2_PARAMS\n+     * @return the string representation of CK_X9_42_DH1_DERIVE_PARAMS\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_X9_42_DH1_DERIVE_PARAMS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,14 @@\n+    \/\/ Pseudo-random functions (CKP_*)\n+    private static final Map<Integer,String> prfNames =\n+            new HashMap<Integer,String>();\n+\n+    private static final Map<String,Integer> prfIds =\n+            new HashMap<String,Integer>();\n+\n+    \/\/ Salt\/Encoding parameter sources (CKZ_*)\n+    private static final Map<Integer,String> paramSourcesNames =\n+            new HashMap<Integer,String>();\n+\n+    private static final Map<String,Integer> paramSourcesIds =\n+            new HashMap<String,Integer>();\n+\n@@ -211,0 +225,10 @@\n+    \/**\n+     * get a byte array length as int\n+     *\n+     * @param value the byte array to get its length\n+     * @return the byte array length as int or 0 if null\n+     *\/\n+    public static int getLength(byte[] value) {\n+        return value == null ? 0 : value.length;\n+    }\n+\n@@ -486,0 +510,16 @@\n+    public static String getPrfName(long id) {\n+        return getName(prfNames, id);\n+    }\n+\n+    public static long getPrfId(String name) {\n+        return getId(prfIds, name);\n+    }\n+\n+    public static String getParamSourcesName(long id) {\n+        return getName(paramSourcesNames, id);\n+    }\n+\n+    public static long getParamSourcesId(String name) {\n+        return getId(paramSourcesIds, name);\n+    }\n+\n@@ -641,0 +681,8 @@\n+    private static void addPrf(long id, String name) {\n+        addMapping(prfNames, prfIds, id, name);\n+    }\n+\n+    private static void addParamSources(long id, String name) {\n+        addMapping(paramSourcesNames, paramSourcesIds, id, name);\n+    }\n+\n@@ -1101,0 +1149,8 @@\n+        addMech(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN\");\n+        addMech(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN,\n+                                    \"CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN\");\n@@ -1355,0 +1411,14 @@\n+\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA1,    \"CKP_PKCS5_PBKD2_HMAC_SHA1\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_GOSTR3411,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_GOSTR3411\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA224,  \"CKP_PKCS5_PBKD2_HMAC_SHA224\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA256,  \"CKP_PKCS5_PBKD2_HMAC_SHA256\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA384,  \"CKP_PKCS5_PBKD2_HMAC_SHA384\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512,  \"CKP_PKCS5_PBKD2_HMAC_SHA512\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512_224,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_SHA512_224\");\n+        addPrf(CKP_PKCS5_PBKD2_HMAC_SHA512_256,\n+                                             \"CKP_PKCS5_PBKD2_HMAC_SHA512_256\");\n+\n+        addParamSources(CKZ_SALT_SPECIFIED,  \"CKZ_SALT_SPECIFIED\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/Functions.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1002,0 +1002,9 @@\n+    \/\/ Additional PKCS #12 PBE key derivation algorithms defined in NSS v3.29\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 29) *\/ = 0xCE53436DL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 30) *\/ = 0xCE53436EL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 31) *\/ = 0xCE53436FL;\n+    public static final long  CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN\n+                                        \/* (CKM_NSS + 32) *\/ = 0xCE534370L;\n@@ -1106,0 +1115,1 @@\n+    *\/\n@@ -1107,0 +1117,1 @@\n+    \/\/ PBKDF2 support, used in P11Util\n@@ -1118,0 +1129,1 @@\n+    \/*\n@@ -1156,3 +1168,3 @@\n-    \/\/ base number of NSS private attributes\n-    public static final long  CKA_NETSCAPE_BASE \/*0x80000000L + 0x4E534350L*\/\n-                                                      = 0xCE534350L;\n+    \/\/ base number of NSS private attributes. CKA_NETSCAPE_BASE is now known as\n+    \/\/ CKM_NSS = CKM_VENDOR_DEFINED | NSSCK_VENDOR_NSS = 0x80000000 | 0x4E534350\n+    public static final long  CKA_NETSCAPE_BASE       = 0xCE534350L;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11Constants.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1515,2 +1515,0 @@\n-        case CKM_PBE_SHA1_DES3_EDE_CBC:\n-        case CKM_PBE_SHA1_DES2_EDE_CBC:\n@@ -1518,0 +1516,4 @@\n+        case CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN:\n+        case CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN:\n@@ -1661,1 +1663,1 @@\n-    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pInitVector\", \"[C\");\n+    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pInitVector\", \"[B\");\n@@ -1667,1 +1669,1 @@\n-    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pSalt\", \"[C\");\n+    fieldID = (*env)->GetFieldID(env, jPbeParamsClass, \"pSalt\", \"[B\");\n@@ -1683,1 +1685,1 @@\n-    jCharArrayToCKCharArray(env, jInitVector, &(ckParamPtr->pInitVector), &ckTemp);\n+    jByteArrayToCKByteArray(env, jInitVector, &(ckParamPtr->pInitVector), &ckTemp);\n@@ -1687,1 +1689,1 @@\n-    jCharArrayToCKCharArray(env, jPassword, &(ckParamPtr->pPassword), &(ckParamPtr->ulPasswordLen));\n+    jCharArrayToCKUTF8CharArray(env, jPassword, &(ckParamPtr->pPassword), &(ckParamPtr->ulPasswordLen));\n@@ -1691,1 +1693,1 @@\n-    jCharArrayToCKCharArray(env, jSalt, &(ckParamPtr->pSalt), &(ckParamPtr->ulSaltLen));\n+    jByteArrayToCKByteArray(env, jSalt, &(ckParamPtr->pSalt), &(ckParamPtr->ulSaltLen));\n@@ -1702,0 +1704,3 @@\n+    if (ckParamPtr->pPassword != NULL) {\n+        memset(ckParamPtr->pPassword, 0, ckParamPtr->ulPasswordLen);\n+    }\n@@ -1770,0 +1775,16 @@\n+#define PBKD2_PARAM_SET(member, value)                              \\\n+    do {                                                            \\\n+        if(ckParamPtr->version == PARAMS) {                         \\\n+            ckParamPtr->params.v1.member = value;                   \\\n+        } else {                                                    \\\n+            ckParamPtr->params.v2.member = value;                   \\\n+        }                                                           \\\n+    } while(0)\n+\n+#define PBKD2_PARAM_ADDR(member)                                    \\\n+    (                                                               \\\n+        (ckParamPtr->version == PARAMS) ?                           \\\n+        (void*) &ckParamPtr->params.v1.member :                     \\\n+        (void*) &ckParamPtr->params.v2.member                       \\\n+    )\n+\n@@ -1771,1 +1792,2 @@\n- * converts the Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS\n+ * converts a Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS\n+ * pointer, or a Java CK_PKCS5_PBKD2_PARAMS2 object to a CK_PKCS5_PBKD2_PARAMS2\n@@ -1774,2 +1796,2 @@\n- * @param env - used to call JNI funktions to get the Java classes and objects\n- * @param jParam - the Java CK_PKCS5_PBKD2_PARAMS object to convert\n+ * @param env - used to call JNI functions to get the Java classes and objects\n+ * @param jParam - the Java object to convert\n@@ -1777,1 +1799,1 @@\n- * @return pointer to the new CK_PKCS5_PBKD2_PARAMS structure\n+ * @return pointer to the new structure\n@@ -1779,1 +1801,1 @@\n-CK_PKCS5_PBKD2_PARAMS_PTR\n+CK_VOID_PTR\n@@ -1782,1 +1804,3 @@\n-    CK_PKCS5_PBKD2_PARAMS_PTR ckParamPtr;\n+    VersionedPbkd2ParamsPtr ckParamPtr;\n+    ParamVersion paramVersion;\n+    CK_ULONG_PTR pUlPasswordLen;\n@@ -1786,1 +1810,1 @@\n-    jobject jSaltSourceData, jPrfData;\n+    jobject jSaltSourceData, jPrfData, jPassword;\n@@ -1793,2 +1817,12 @@\n-    jPkcs5Pbkd2ParamsClass = (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS);\n-    if (jPkcs5Pbkd2ParamsClass == NULL) { return NULL; }\n+    if ((jPkcs5Pbkd2ParamsClass =\n+            (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS)) != NULL\n+            && (*env)->IsInstanceOf(env, jParam, jPkcs5Pbkd2ParamsClass)) {\n+        paramVersion = PARAMS;\n+    } else if ((jPkcs5Pbkd2ParamsClass =\n+            (*env)->FindClass(env, CLASS_PKCS5_PBKD2_PARAMS2)) != NULL\n+            && (*env)->IsInstanceOf(env, jParam, jPkcs5Pbkd2ParamsClass)) {\n+        paramVersion = PARAMS2;\n+    } else {\n+        p11ThrowPKCS11RuntimeException(env, \"Unknown PBKD2 mechanism parameters class.\");\n+        return NULL;\n+    }\n@@ -1810,0 +1844,3 @@\n+    fieldID = (*env)->GetFieldID(env, jPkcs5Pbkd2ParamsClass, \"pPassword\", \"[C\");\n+    if (fieldID == NULL) { return NULL; }\n+    jPassword = (*env)->GetObjectField(env, jParam, fieldID);\n@@ -1811,2 +1848,2 @@\n-    \/\/ allocate memory for CK_PKCS5_PBKD2_PARAMS pointer\n-    ckParamPtr = calloc(1, sizeof(CK_PKCS5_PBKD2_PARAMS));\n+    \/\/ allocate memory for VersionedPbkd2Params and store the structure version\n+    ckParamPtr = calloc(1, sizeof(VersionedPbkd2Params));\n@@ -1817,0 +1854,1 @@\n+    ckParamPtr->version = paramVersion;\n@@ -1819,3 +1857,4 @@\n-    ckParamPtr->saltSource = jLongToCKULong(jSaltSource);\n-    jByteArrayToCKByteArray(env, jSaltSourceData, (CK_BYTE_PTR *)\n-            &(ckParamPtr->pSaltSourceData), &(ckParamPtr->ulSaltSourceDataLen));\n+    PBKD2_PARAM_SET(saltSource, jLongToCKULong(jSaltSource));\n+    jByteArrayToCKByteArray(env, jSaltSourceData,\n+            (CK_BYTE_PTR *) PBKD2_PARAM_ADDR(pSaltSourceData),\n+            PBKD2_PARAM_ADDR(ulSaltSourceDataLen));\n@@ -1825,4 +1864,21 @@\n-    ckParamPtr->iterations = jLongToCKULong(jIteration);\n-    ckParamPtr->prf = jLongToCKULong(jPrf);\n-    jByteArrayToCKByteArray(env, jPrfData, (CK_BYTE_PTR *)\n-            &(ckParamPtr->pPrfData), &(ckParamPtr->ulPrfDataLen));\n+    PBKD2_PARAM_SET(iterations, jLongToCKULong(jIteration));\n+    PBKD2_PARAM_SET(prf, jLongToCKULong(jPrf));\n+    jByteArrayToCKByteArray(env, jPrfData,\n+            (CK_BYTE_PTR *) PBKD2_PARAM_ADDR(pPrfData),\n+            PBKD2_PARAM_ADDR(ulPrfDataLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+    if (ckParamPtr->version == PARAMS) {\n+        pUlPasswordLen = calloc(1, sizeof(CK_ULONG));\n+        if (pUlPasswordLen == NULL) {\n+            p11ThrowOutOfMemoryError(env, 0);\n+            goto cleanup;\n+        }\n+        ckParamPtr->params.v1.ulPasswordLen = pUlPasswordLen;\n+    } else {\n+        pUlPasswordLen = &ckParamPtr->params.v2.ulPasswordLen;\n+    }\n+    jCharArrayToCKUTF8CharArray(env, jPassword,\n+            (CK_CHAR_PTR *) PBKD2_PARAM_ADDR(pPassword),\n+            pUlPasswordLen);\n@@ -1834,1 +1890,3 @@\n-        *pLength = sizeof(CK_PKCS5_PBKD2_PARAMS);\n+        *pLength = (ckParamPtr->version == PARAMS ?\n+            sizeof(ckParamPtr->params.v1) :\n+            sizeof(ckParamPtr->params.v2));\n@@ -1836,0 +1894,1 @@\n+    \/\/ VersionedPbkd2ParamsPtr is equivalent to CK_PKCS5_PBKD2_PARAMS[2]_PTR\n@@ -1838,2 +1897,1 @@\n-    free(ckParamPtr->pSaltSourceData);\n-    free(ckParamPtr->pPrfData);\n+    FREE_VERSIONED_PBKD2_MEMBERS(ckParamPtr);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":86,"deletions":28,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -411,0 +411,21 @@\n+                 case CKM_PKCS5_PBKD2:\n+                     \/\/ get the versioned structure from behind memory\n+                     TRACE0(((VersionedPbkd2ParamsPtr)tmp)->version == PARAMS ?\n+                             \"[ CK_PKCS5_PBKD2_PARAMS ]\\n\" :\n+                             \"[ CK_PKCS5_PBKD2_PARAMS2 ]\\n\");\n+                     FREE_VERSIONED_PBKD2_MEMBERS((VersionedPbkd2ParamsPtr)tmp);\n+                     break;\n+                 case CKM_PBA_SHA1_WITH_SHA1_HMAC:\n+                 case CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN:\n+                 case CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN:\n+                     TRACE0(\"[ CK_PBE_PARAMS ]\\n\");\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pInitVector);\n+                     if (((CK_PBE_PARAMS_PTR)tmp)->pPassword != NULL) {\n+                         memset(((CK_PBE_PARAMS_PTR)tmp)->pPassword, 0,\n+                                 ((CK_PBE_PARAMS_PTR)tmp)->ulPasswordLen);\n+                     }\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pPassword);\n+                     free(((CK_PBE_PARAMS_PTR)tmp)->pSalt);\n+                     break;\n@@ -415,1 +436,1 @@\n-                     \/\/ CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP, CKM_PKCS5_PBKD2,\n+                     \/\/ CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP,\n@@ -518,1 +539,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -520,1 +542,0 @@\n-        *ckpLength = 0L;\n@@ -523,1 +544,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -560,1 +580,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -562,1 +583,0 @@\n-        *ckpLength = 0L;\n@@ -565,1 +585,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -607,1 +626,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -609,1 +629,0 @@\n-        *ckpLength = 0L;\n@@ -612,1 +631,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -649,1 +667,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -651,1 +670,0 @@\n-        *ckpLength = 0L;\n@@ -654,1 +672,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -691,1 +708,2 @@\n-    if(jArray == NULL) {\n+    *ckpLength = jArray == NULL ? 0L : (*env)->GetArrayLength(env, jArray);\n+    if(*ckpLength == 0L) {\n@@ -693,1 +711,0 @@\n-        *ckpLength = 0L;\n@@ -696,1 +713,0 @@\n-    *ckpLength = (*env)->GetArrayLength(env, jArray);\n@@ -704,2 +720,1 @@\n-        free(jTemp);\n-        return;\n+        goto cleanup;\n@@ -710,1 +725,0 @@\n-        free(jTemp);\n@@ -712,1 +726,1 @@\n-        return;\n+        goto cleanup;\n@@ -717,0 +731,3 @@\n+cleanup:\n+    \/\/ Clean possible temporary copies of passwords.\n+    memset(jTemp, 0, *ckpLength * sizeof(jchar));\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":37,"deletions":20,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\/* CKA_NETSCAPE_BASE is now known as CKM_NSS (CKM_VENDOR_DEFINED | NSSCK_VENDOR_NSS) *\/\n@@ -74,1 +75,1 @@\n-#define CKA_NETSCAPE_TRUST_CODE_SIGNING (CKA_NETSCAPE_TRUST_BASE + 10)\n+#define CKA_NETSCAPE_TRUST_CODE_SIGNING         (CKA_NETSCAPE_TRUST_BASE + 10)\n@@ -79,0 +80,6 @@\n+\/* additional PKCS #12 PBE key derivation algorithms defined in NSS v3.29 *\/\n+#define CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 29)\n+#define CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 30)\n+#define CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 31)\n+#define CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN  (CKA_NETSCAPE_BASE + 32)\n+\n@@ -274,0 +281,1 @@\n+#define CLASS_PKCS5_PBKD2_PARAMS2 \"sun\/security\/pkcs11\/wrapper\/CK_PKCS5_PBKD2_PARAMS2\"\n@@ -386,1 +394,1 @@\n-CK_PKCS5_PBKD2_PARAMS_PTR jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n+CK_VOID_PTR jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n@@ -396,0 +404,35 @@\n+\/* handling of CK_PKCS5_PBKD2_PARAMS and CK_PKCS5_PBKD2_PARAMS2 *\/\n+typedef enum {PARAMS=0, PARAMS2} ParamVersion;\n+\n+typedef struct {\n+    union {\n+        CK_PKCS5_PBKD2_PARAMS v1;\n+        CK_PKCS5_PBKD2_PARAMS2 v2;\n+    } params;\n+    ParamVersion version;\n+} VersionedPbkd2Params, *VersionedPbkd2ParamsPtr;\n+\n+#define FREE_VERSIONED_PBKD2_MEMBERS(verParamsPtr)                   \\\n+    do {                                                             \\\n+        if ((verParamsPtr)->version == PARAMS) {                     \\\n+            free((verParamsPtr)->params.v1.pSaltSourceData);         \\\n+            free((verParamsPtr)->params.v1.pPrfData);                \\\n+            if ((verParamsPtr)->params.v1.pPassword != NULL &&       \\\n+                    (verParamsPtr)->params.v1.ulPasswordLen          \\\n+                            != NULL) {                               \\\n+                memset((verParamsPtr)->params.v1.pPassword, 0,       \\\n+                        *((verParamsPtr)->params.v1.ulPasswordLen)); \\\n+            }                                                        \\\n+            free((verParamsPtr)->params.v1.pPassword);               \\\n+            free((verParamsPtr)->params.v1.ulPasswordLen);           \\\n+        } else {                                                     \\\n+            free((verParamsPtr)->params.v2.pSaltSourceData);         \\\n+            free((verParamsPtr)->params.v2.pPrfData);                \\\n+            if ((verParamsPtr)->params.v2.pPassword != NULL) {       \\\n+                memset((verParamsPtr)->params.v2.pPassword, 0,       \\\n+                        (verParamsPtr)->params.v2.ulPasswordLen);    \\\n+            }                                                        \\\n+            free((verParamsPtr)->params.v2.pPassword);               \\\n+        }                                                            \\\n+    } while(0)\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,1 @@\n-                    CurveDB.lookup(\"secp256r1\").getGenerator();\n+                    CurveDB.P_256.getGenerator();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,5 +215,2 @@\n-        for (NamedCurve namedCurve :\n-            List.of(\n-                CurveDB.lookup(\"secp256r1\"),\n-                CurveDB.lookup(\"secp384r1\"),\n-                CurveDB.lookup(\"secp521r1\"))) {\n+        for (NamedCurve namedCurve : List.of(\n+                CurveDB.P_256, CurveDB.P_384, CurveDB.P_521)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.shenandoah;\n+\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ShenandoahGeneration extends VMObject {\n+    private static CIntegerField used;\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+            public void update(Observable o, Object data) {\n+                initialize(VM.getVM().getTypeDataBase());\n+            }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ShenandoahGeneration\");\n+        used = type.getCIntegerField(\"_used\");\n+    }\n+\n+    public ShenandoahGeneration(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long used() {\n+        return used.getValue(addr);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahGeneration.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-    private static CIntegerField used;\n+    private static AddressField  globalGeneration;\n@@ -63,1 +63,1 @@\n-        used = type.getCIntegerField(\"_used\");\n+        globalGeneration = type.getAddressField(\"_global_generation\");\n@@ -92,1 +92,3 @@\n-        return used.getValue(addr);\n+        Address globalGenerationAddress = globalGeneration.getValue(addr);\n+        ShenandoahGeneration global = VMObjectFactory.newObject(ShenandoahGeneration.class, globalGenerationAddress);\n+        return global.used();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahHeap.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,838 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.concurrent;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.lang.ref.Reference;\n-import java.util.concurrent.Callable;\n-import java.util.function.Supplier;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Hidden;\n-import jdk.internal.vm.annotation.Stable;\n-import jdk.internal.vm.ScopedValueContainer;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * A value that is set once and is then available for reading for a bounded period of\n- * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n- * data for a bounded period of execution without passing the data as method arguments.\n- *\n- * <p> {@code ScopedValue} defines the {@link #where(ScopedValue, Object, Runnable)}\n- * method to set the value of a {@code ScopedValue} for the bouned period of execution by\n- * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n- * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n- * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n- * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n- * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n- * #get() get} method to read its value.\n- *\n- * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n- * incarnations, one per thread. The particular incarnation that is used depends on which\n- * thread calls its methods.\n- *\n- * <p> Consider the following example with a scoped value {@code USERNAME} that is\n- * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n- * method that invokes {@code doSomething()}.\n- * {@snippet lang=java :\n- *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n- *\n- *     ScopedValue.where(USERNAME, \"duke\", () -> doSomething());\n- * }\n- * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n- * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n- * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n- * completes (normally or with an exception). If one thread were to call {@code\n- * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n- * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n- * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n- * depending on which thread is executing.\n- *\n- * <p> In addition to the {@code where} method that executes a {@code run} method, {@code\n- * ScopedValue} defines the {@link #where(ScopedValue, Object, Callable)} method to execute\n- * a method that returns a result. It also defines the {@link #where(ScopedValue, Object)}\n- * method for cases where it is useful to accumulate mappings of {@code ScopedValue} to\n- * value.\n- *\n- * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n- * static} field. The accessibility of the field will determine which components can\n- * bind or read its value.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n- * class will cause a {@link NullPointerException} to be thrown.\n- *\n- * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n- *\n- * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n- * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n- * is bound to some value may be bound to a new value for the bounded execution of some\n- * method. The unfolding execution of code executed by that method defines the nested\n- * dynamic scope. When the method completes (normally or with an exception), the value of\n- * the {@code ScopedValue} reverts to its previous value.\n- *\n- * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n- * {@code USERNAME} to a new value with:\n- * {@snippet lang=java :\n- *     ScopedValue.where(USERNAME, \"duchess\", () -> doMore());\n- * }\n- * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n- * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n- * (normally or with an exception), the value of {@code USERNAME} reverts to\n- * \"{@code duke}\".\n- *\n- * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n- *\n- * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n- * structured cases where child threads are started and terminate within the bounded\n- * period of execution by a parent thread. More specifically, when using a {@link\n- * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n- * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n- * the {@link StructuredTaskScope#fork(Callable) fork} method.\n- *\n- * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n- * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n- * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n- * executed directly or indirectly by these threads running {@code childTask1()},\n- * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n- *\n- * {@snippet lang=java :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n-\n- *     ScopedValue.where(USERNAME, \"duke\", () -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n- *\n- *             scope.fork(() -> childTask1());\n- *             scope.fork(() -> childTask2());\n- *             scope.fork(() -> childTask3());\n- *\n- *             ...\n- *          }\n- *     });\n- * }\n- *\n- * @implNote\n- * Scoped values are designed to be used in fairly small\n- * numbers. {@link #get} initially performs a search through enclosing\n- * scopes to find a scoped value's innermost binding. It\n- * then caches the result of the search in a small thread-local\n- * cache. Subsequent invocations of {@link #get} for that scoped value\n- * will almost always be very fast. However, if a program has many\n- * scoped values that it uses cyclically, the cache hit rate\n- * will be low and performance will be poor. This design allows\n- * scoped-value inheritance by {@link StructuredTaskScope} threads to\n- * be very fast: in essence, no more than copying a pointer, and\n- * leaving a scoped-value binding also requires little more than\n- * updating a pointer.\n- *\n- * <p>Because the scoped-value per-thread cache is small, clients\n- * should minimize the number of bound scoped values in use. For\n- * example, if it is necessary to pass a number of values in this way,\n- * it makes sense to create a record class to hold those values, and\n- * then bind a single {@code ScopedValue} to an instance of that record.\n- *\n- * <p>For this incubator release, the reference implementation\n- * provides some system properties to tune the performance of scoped\n- * values.\n- *\n- * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n- * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n- * for the performance of scoped values. If it is too small,\n- * the runtime library will repeatedly need to scan for each\n- * {@link #get}. If it is too large, memory will be unnecessarily\n- * consumed. The default scoped-value cache size is 16 entries. It may\n- * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n- * must be an integer power of 2.\n- *\n- * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n- *\n- * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n- * This property determines whether the per-thread scoped-value\n- * cache is preserved when a virtual thread is blocked. By default\n- * this property is set to {@code true}, meaning that every virtual\n- * thread preserves its scoped-value cache when blocked. Like {@code\n- * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n- * situations where many virtual threads are blocked most of the time,\n- * setting this property to {@code false} might result in a useful\n- * memory saving, but each virtual thread's scoped-value cache would\n- * have to be regenerated after a blocking operation.\n- *\n- * @param <T> the type of the object bound to this {@code ScopedValue}\n- * @since 20\n- *\/\n-public final class ScopedValue<T> {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private final @Stable int hash;\n-\n-    @Override\n-    public int hashCode() { return hash; }\n-\n-    \/**\n-     * An immutable map from {@code ScopedValue} to values.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n-     * or method in this class will cause a {@link NullPointerException} to be thrown.\n-     *\/\n-    static final class Snapshot {\n-        final Snapshot prev;\n-        final Carrier bindings;\n-        final int bitmask;\n-\n-        private static final Object NIL = new Object();\n-\n-        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n-\n-        Snapshot(Carrier bindings, Snapshot prev) {\n-            this.prev = prev;\n-            this.bindings = bindings;\n-            this.bitmask = bindings.bitmask | prev.bitmask;\n-        }\n-\n-        protected Snapshot() {\n-            this.prev = null;\n-            this.bindings = null;\n-            this.bitmask = 0;\n-        }\n-\n-        Object find(ScopedValue<?> key) {\n-            int bits = key.bitmask();\n-            for (Snapshot snapshot = this;\n-                 containsAll(snapshot.bitmask, bits);\n-                 snapshot = snapshot.prev) {\n-                for (Carrier carrier = snapshot.bindings;\n-                     carrier != null && containsAll(carrier.bitmask, bits);\n-                     carrier = carrier.prev) {\n-                    if (carrier.getKey() == key) {\n-                        Object value = carrier.get();\n-                        return value;\n-                    }\n-                }\n-            }\n-            return NIL;\n-        }\n-    }\n-\n-    \/**\n-     * A mapping of scoped values, as <em>keys<\/em>, to values.\n-     *\n-     * <p> A {@code Carrier} is used to accumlate mappings so that an operation (a\n-     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n-     * mapping bound to values. The following example runs an operation with {@code k1}\n-     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n-     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n-     * }\n-     *\n-     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n-     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n-     * it does not mutate an existing mapping.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n-     * this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @since 20\n-     *\/\n-    public static final class Carrier {\n-        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n-        \/\/ hits that slot in the cache.\n-        final int bitmask;\n-        final ScopedValue<?> key;\n-        final Object value;\n-        final Carrier prev;\n-\n-        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n-            this.key = key;\n-            this.value = value;\n-            this.prev = prev;\n-            int bits = key.bitmask();\n-            if (prev != null) {\n-                bits |= prev.bitmask;\n-            }\n-            this.bitmask = bits;\n-        }\n-\n-        \/**\n-         * Add a binding to this map, returning a new Carrier instance.\n-         *\/\n-        private static final <T> Carrier where(ScopedValue<T> key, T value,\n-                                               Carrier prev) {\n-            return new Carrier(key, value, prev);\n-        }\n-\n-        \/**\n-         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n-         * new mapping from {@code key} to {@code value}. If this carrier already has a\n-         * mapping for the scoped value {@code key} then it will map to the new\n-         * {@code value}. The current carrier is immutable, so it is not changed by this\n-         * method.\n-         *\n-         * @param key the {@code ScopedValue} key\n-         * @param value the value, can be {@code null}\n-         * @param <T> the type of the value\n-         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n-         *\/\n-        public <T> Carrier where(ScopedValue<T> key, T value) {\n-            return where(key, value, this);\n-        }\n-\n-        \/*\n-         * Return a new set consisting of a single binding.\n-         *\/\n-        static <T> Carrier of(ScopedValue<T> key, T value) {\n-            return where(key, value, null);\n-        }\n-\n-        final Object get() {\n-            return value;\n-        }\n-\n-        final ScopedValue<?> getKey() {\n-            return key;\n-        }\n-\n-        \/**\n-         * Returns the value of a {@link ScopedValue} in this mapping.\n-         *\n-         * @param key the {@code ScopedValue} key\n-         * @param <T> the type of the value\n-         * @return the value\n-         * @throws NoSuchElementException if the key is not present in this mapping\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        public <T> T get(ScopedValue<T> key) {\n-            var bits = key.bitmask();\n-            for (Carrier carrier = this;\n-                 carrier != null && containsAll(carrier.bitmask, bits);\n-                 carrier = carrier.prev) {\n-                if (carrier.getKey() == key) {\n-                    Object value = carrier.get();\n-                    return (T)value;\n-                }\n-            }\n-            throw new NoSuchElementException();\n-        }\n-\n-        \/**\n-         * Calls a value-returning operation with each scoped value in this mapping bound\n-         * to its value in the current thread.\n-         * When the operation completes (normally or with an exception), each scoped value\n-         * in the mapping will revert to being unbound, or revert to its previous value\n-         * when previously bound, in the current thread.\n-         *\n-         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-         * underlying construct of each {@code StructuredTaskScope} created in the\n-         * dynamic scope to be closed. This may require blocking until all child threads\n-         * have completed their sub-tasks. The closing is done in the reverse order that\n-         * they were created. Once closed, {@link StructureViolationException} is thrown.\n-         *\n-         * @param op the operation to run\n-         * @param <R> the type of the result of the operation\n-         * @return the result\n-         * @throws Exception if {@code op} completes with an exception\n-         * @see ScopedValue#where(ScopedValue, Object, Callable)\n-         *\/\n-        public <R> R call(Callable<? extends R> op) throws Exception {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevSnapshot = scopedValueBindings();\n-            var newSnapshot = new Snapshot(this, prevSnapshot);\n-            return runWith(newSnapshot, op);\n-        }\n-\n-        \/**\n-         * Execute the action with a set of ScopedValue bindings.\n-         *\n-         * The VM recognizes this method as special, so any changes to the\n-         * name or signature require corresponding changes in\n-         * JVM_FindScopedValueBindings().\n-         *\/\n-        @Hidden\n-        @ForceInline\n-        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) throws Exception {\n-            try {\n-                JLA.setScopedValueBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                return ScopedValueContainer.call(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setScopedValueBindings(newSnapshot.prev);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-\n-        \/**\n-         * Runs an operation with each scoped value in this mapping bound to its value\n-         * in the current thread.\n-         * When the operation completes (normally or with an exception), each scoped value\n-         * in the mapping will revert to being unbound, or revert to its previous value\n-         * when previously bound, in the current thread.\n-         *\n-         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-         * underlying construct of each {@code StructuredTaskScope} created in the\n-         * dynamic scope to be closed. This may require blocking until all child threads\n-         * have completed their sub-tasks. The closing is done in the reverse order that\n-         * they were created. Once closed, {@link StructureViolationException} is thrown.\n-         *\n-         * @param op the operation to run\n-         * @see ScopedValue#where(ScopedValue, Object, Runnable)\n-         *\/\n-        public void run(Runnable op) {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevSnapshot = scopedValueBindings();\n-            var newSnapshot = new Snapshot(this, prevSnapshot);\n-            runWith(newSnapshot, op);\n-        }\n-\n-        \/**\n-         * Execute the action with a set of {@code ScopedValue} bindings.\n-         *\n-         * The VM recognizes this method as special, so any changes to the\n-         * name or signature require corresponding changes in\n-         * JVM_FindScopedValueBindings().\n-         *\/\n-        @Hidden\n-        @ForceInline\n-        private void runWith(Snapshot newSnapshot, Runnable op) {\n-            try {\n-                JLA.setScopedValueBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                ScopedValueContainer.run(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setScopedValueBindings(newSnapshot.prev);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n-     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n-     * that an operation can be executed with all scoped values in the mapping bound to\n-     * values. The following example runs an operation with {@code k1} bound (or rebound)\n-     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n-     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @return a new {@code Carrier} with a single mapping\n-     *\/\n-    public static <T> Carrier where(ScopedValue<T> key, T value) {\n-        return Carrier.of(key, value);\n-    }\n-\n-    \/**\n-     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n-     * in the current thread. When the operation completes (normally or with an\n-     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n-     * its previous value when previously bound, in the current thread.\n-     *\n-     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-     * underlying construct of each {@code StructuredTaskScope} created in the\n-     * dynamic scope to be closed. This may require blocking until all child threads\n-     * have completed their sub-tasks. The closing is done in the reverse order that\n-     * they were created. Once closed, {@link StructureViolationException} is thrown.\n-     *\n-     * @implNote\n-     * This method is implemented to be equivalent to:\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n-     *     ScopedValue.where(key, value).call(op);\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @param <R> the result type\n-     * @param op the operation to call\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n-     *\/\n-    public static <T, R> R where(ScopedValue<T> key,\n-                                 T value,\n-                                 Callable<? extends R> op) throws Exception {\n-        return where(key, value).call(op);\n-    }\n-\n-    \/**\n-     * Run an operation with a {@code ScopedValue} bound to a value in the current\n-     * thread. When the operation completes (normally or with an exception), the\n-     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n-     * when previously bound, in the current thread.\n-     *\n-     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-     * underlying construct of each {@code StructuredTaskScope} created in the\n-     * dynamic scope to be closed. This may require blocking until all child threads\n-     * have completed their sub-tasks. The closing is done in the reverse order that\n-     * they were created. Once closed, {@link StructureViolationException} is thrown.\n-     *\n-     * @implNote\n-     * This method is implemented to be equivalent to:\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n-     *     ScopedValue.where(key, value).run(op);\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @param op the operation to call\n-     *\/\n-    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n-        where(key, value).run(op);\n-    }\n-\n-    private ScopedValue() {\n-        this.hash = generateKey();\n-    }\n-\n-    \/**\n-     * Creates a scoped value that is initially unbound for all threads.\n-     *\n-     * @param <T> the type of the value\n-     * @return a new {@code ScopedValue}\n-     *\/\n-    public static <T> ScopedValue<T> newInstance() {\n-        return new ScopedValue<T>();\n-    }\n-\n-    \/**\n-     * {@return the value of the scoped value if bound in the current thread}\n-     *\n-     * @throws NoSuchElementException if the scoped value is not bound\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = scopedValueCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-        }\n-        return slowGet();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var value = findBinding();\n-        if (value == Snapshot.NIL) {\n-            throw new NoSuchElementException();\n-        }\n-        Cache.put(this, value);\n-        return (T)value;\n-    }\n-\n-    \/**\n-     * {@return {@code true} if this scoped value is bound in the current thread}\n-     *\/\n-    public boolean isBound() {\n-        Object[] objects = scopedValueCache();\n-        if (objects != null) {\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-        }\n-        var value = findBinding();\n-        boolean result = (value != Snapshot.NIL);\n-        if (result)  Cache.put(this, value);\n-        return result;\n-    }\n-\n-    \/**\n-     * Return the value of the scoped value or NIL if not bound.\n-     *\/\n-    private Object findBinding() {\n-        Object value = scopedValueBindings().find(this);\n-        return value;\n-    }\n-\n-    \/**\n-     * Returns the value of this scoped value if bound in the current thread, otherwise\n-     * returns {@code other}.\n-     *\n-     * @param other the value to return if not bound, can be {@code null}\n-     * @return the value of the scoped value if bound, otherwise {@code other}\n-     *\/\n-    public T orElse(T other) {\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            return other;\n-        }\n-    }\n-\n-    \/**\n-     * Returns the value of this scoped value if bound in the current thread, otherwise\n-     * throws an exception produced by the exception supplying function.\n-     *\n-     * @param <X> the type of the exception that may be thrown\n-     * @param exceptionSupplier the supplying function that produces the exception to throw\n-     * @return the value of the scoped value if bound in the current thread\n-     * @throws X if the scoped value is not bound in the current thread\n-     *\/\n-    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n-        Objects.requireNonNull(exceptionSupplier);\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            throw exceptionSupplier.get();\n-        }\n-    }\n-\n-    private static Object[] scopedValueCache() {\n-        return JLA.scopedValueCache();\n-    }\n-\n-    private static void setScopedValueCache(Object[] cache) {\n-        JLA.setScopedValueCache(cache);\n-    }\n-\n-    \/\/ Special value to indicate this is a newly-created Thread\n-    \/\/ Note that his must match the declaration in j.l.Thread.\n-    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n-\n-    private static Snapshot scopedValueBindings() {\n-        \/\/ Bindings can be in one of four states:\n-        \/\/\n-        \/\/ 1: class Thread: this is a new Thread instance, and no\n-        \/\/ scoped values have ever been bound in this Thread.\n-        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n-        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n-        \/\/ bindings.\n-        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n-        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n-        \/\/ the stack to find them.\n-\n-        Object bindings = JLA.scopedValueBindings();\n-        if (bindings == NEW_THREAD_BINDINGS) {\n-            \/\/ This must be a new thread\n-           return Snapshot.EMPTY_SNAPSHOT;\n-        }\n-        if (bindings == null) {\n-            \/\/ Search the stack\n-            bindings = JLA.findScopedValueBindings();\n-            if (bindings == null) {\n-                \/\/ Nothing on the stack.\n-                bindings = Snapshot.EMPTY_SNAPSHOT;\n-            }\n-        }\n-        assert (bindings != null);\n-        JLA.setScopedValueBindings(bindings);\n-        return (Snapshot) bindings;\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n-        return (nextKey = x);\n-    }\n-\n-    \/**\n-     * Return a bit mask that may be used to determine if this ScopedValue is\n-     * bound in the current context. Each Carrier holds a bit mask which is\n-     * the OR of all the bit masks of the bound ScopedValues.\n-     * @return the bitmask\n-     *\/\n-    int bitmask() {\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n-    }\n-\n-    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n-    \/\/ of the bits in targetBits.\n-    static boolean containsAll(int bitmask, int targetBits) {\n-        return (bitmask & targetBits) == targetBits;\n-    }\n-\n-    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n-    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n-    \/\/ for fast access in future.\n-    private static final class Cache {\n-        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n-\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n-            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n-            }\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n-        }\n-\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n-        }\n-\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n-        }\n-\n-        private static int primarySlot(ScopedValue<?> key) {\n-            return key.hashCode() & SLOT_MASK;\n-        }\n-\n-        private static int secondarySlot(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static int primarySlot(int hash) {\n-            return hash & SLOT_MASK;\n-        }\n-\n-        static int secondarySlot(int hash) {\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static void put(ScopedValue<?> key, Object value) {\n-            Object[] theCache = scopedValueCache();\n-            if (theCache == null) {\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n-                setScopedValueCache(theCache);\n-            }\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = primarySlot(key);\n-            int k2 = secondarySlot(key);\n-            var usePrimaryIndex = chooseVictim();\n-            int victim = usePrimaryIndex ? k1 : k2;\n-            int other = usePrimaryIndex ? k2 : k1;\n-            setKeyAndObjectAt(victim, key, value);\n-            if (getKey(theCache, other) == key) {\n-                setKeyAndObjectAt(other, key, value);\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            var cache = scopedValueCache();\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, int n) {\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, int n, Object key) {\n-            objs[n * 2] = key;\n-        }\n-\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n-        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n-        \/\/ This chooses either the primary or secondary cache slot, but the\n-        \/\/ primary slot is approximately twice as likely to be chosen as the\n-        \/\/ secondary one.\n-        private static boolean chooseVictim() {\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n-            return (r & 15) >= 5;\n-        }\n-\n-        \/\/ Null a set of cache entries, indicated by the 1-bits given\n-        static void invalidate(int toClearBits) {\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n-            Object[] objects;\n-            if ((objects = scopedValueCache()) != null) {\n-                for (int bits = toClearBits; bits != 0; ) {\n-                    int index = Integer.numberOfTrailingZeros(bits);\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n-                    bits &= ~1 << index;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":0,"deletions":838,"binary":false,"changes":838,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.concurrent;\n-\n-\/**\n- * Thrown when a structure violation is detected.\n- *\n- * @see StructuredTaskScope#close()\n- *\n- * @since 19\n- *\/\n-public final class StructureViolationException extends RuntimeException {\n-    @java.io.Serial\n-    private static final long serialVersionUID = -7705327650798235468L;\n-\n-    \/**\n-     * Constructs a {@code StructureViolationException} with no detail message.\n-     *\/\n-    public StructureViolationException() {\n-        super();\n-    }\n-\n-    \/**\n-     * Constructs a {@code StructureViolationException} with the specified\n-     * detail message.\n-     *\n-     * @param  message the detail message, can be null\n-     *\/\n-    public StructureViolationException(String message) {\n-        super(message);\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructureViolationException.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,1223 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.concurrent;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Comparator;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.Function;\n-import jdk.internal.misc.ThreadFlock;\n-\n-\/**\n- * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n- * cases where a task splits into several concurrent subtasks, to be executed in their\n- * own threads, and where the subtasks must complete before the main task continues. A\n- * {@code StructuredTaskScope} can be used to ensure that the lifetime of a concurrent\n- * operation is confined by a <em>syntax block<\/em>, just like that of a sequential\n- * operation in structured programming.\n- *\n- * <h2>Basic usage<\/h2>\n- *\n- * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n- * the {@link #fork(Callable) fork} method to start a thread to execute a task, the {@link\n- * #join() join} method to wait for all threads to finish, and the {@link #close() close}\n- * method to close the task scope. The API is intended to be used with the {@code\n- * try-with-resources} construct. The intention is that code in the <em>block<\/em> uses\n- * the {@code fork} method to fork threads to execute the subtasks, wait for the threads\n- * to finish with the {@code join} method, and then <em>process the results<\/em>.\n- * Processing of results may include handling or re-throwing of exceptions.\n- * {@snippet lang=java :\n- *     try (var scope = new StructuredTaskScope<Object>()) {\n- *\n- *         Future<Integer> future1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n- *         Future<String> future2 = scope.fork(task2);    \/\/ @highlight substring=\"fork\"\n- *\n- *         scope.join();                                  \/\/ @highlight substring=\"join\"\n- *\n- *         ... process results\/exceptions ...\n- *\n- *     } \/\/ close                                         \/\/ @highlight substring=\"close\"\n- * }\n- * To ensure correct usage, the {@code join} and {@code close} methods may only be invoked\n- * by the <em>owner<\/em> (the thread that opened\/created the task scope}, and the\n- * {@code close} method throws an exception after closing if the owner did not invoke the\n- * {@code join} method after forking.\n- *\n- * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n- * down a task scope without closing it. Shutdown is useful for cases where a subtask\n- * completes with a result (or exception) and the results of other unfinished subtasks are\n- * no longer needed. If a subtask invokes {@code shutdown} while the owner is waiting in\n- * the {@code join} method then it will cause {@code join} to wakeup, all unfinished\n- * threads to be {@linkplain Thread#interrupt() interrupted} and prevents new threads\n- * from starting in the task scope.\n- *\n- * <h2>Subclasses with policies for common cases<\/h2>\n- *\n- * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n- * common cases:\n- * <ol>\n- *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the first result and\n- *   shuts down the task scope to interrupt unfinished threads and wakeup the owner. This\n- *   class is intended for cases where the result of any subtask will do (\"invoke any\")\n- *   and where there is no need to wait for results of other unfinished tasks. It defines\n- *   methods to get the first result or throw an exception if all subtasks fail.\n- *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the first exception and\n- *   shuts down the task scope. This class is intended for cases where the results of all\n- *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n- *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n- *   any of the subtasks fail.\n- * <\/ol>\n- *\n- * <p> The following are two examples that use the two classes. In both cases, a pair of\n- * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n- * first example creates a ShutdownOnSuccess object to capture the result of the first\n- * subtask to complete normally, cancelling the other by way of shutting down the task\n- * scope. The main task waits in {@code join} until either subtask completes with a result\n- * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n- * result(Function)} method to get the captured result. If both subtasks fail then this\n- * method throws a {@code WebApplicationException} with the exception from one of the\n- * subtasks as the cause.\n- * {@snippet lang=java :\n- *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n- *\n- *         scope.fork(() -> fetch(left));\n- *         scope.fork(() -> fetch(right));\n- *\n- *         scope.join();\n- *\n- *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n- *         String result = scope.result(e -> new WebApplicationException(e));\n- *\n- *         ...\n- *     }\n- * }\n- * The second example creates a ShutdownOnFailure object to capture the exception of the\n- * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n- * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n- * result, either fails, or a deadline is reached. It invokes {@link\n- * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n- * when either subtask fails. This method is a no-op if no subtasks fail. The main task\n- * uses {@code Future}'s {@link Future#resultNow() resultNow()} method to retrieve the\n- * results.\n- *\n- * {@snippet lang=java :\n- *    Instant deadline = ...\n- *\n- *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n- *\n- *         Future<String> future1 = scope.fork(() -> query(left));\n- *         Future<String> future2 = scope.fork(() -> query(right));\n- *\n- *         scope.joinUntil(deadline);\n- *\n- *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n- *         scope.throwIfFailed(e -> new WebApplicationException(e));\n- *\n- *         \/\/ both subtasks completed successfully\n- *         String result = Stream.of(future1, future2)\n- *                 \/\/ @link substring=\"Future::resultNow\" target=\"Future#resultNow\" :\n- *                 .map(Future::resultNow)\n- *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n- *\n- *         ...\n- *     }\n- * }\n- *\n- * <h2>Extending StructuredTaskScope<\/h2>\n- *\n- * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Future)\n- * handleComplete} overridden, to implement policies other than those implemented by\n- * {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. The method may be overridden\n- * to, for example, collect the results of subtasks that complete with a result and ignore\n- * subtasks that fail. It may collect exceptions when subtasks fail. It may invoke the\n- * {@link #shutdown() shutdown} method to shut down and cause {@link #join() join} to\n- * wakeup when some condition arises.\n- *\n- * <p> A subclass will typically define methods to make available results, state, or other\n- * outcome to code that executes after the {@code join} method. A subclass that collects\n- * results and ignores subtasks that fail may define a method that returns a collection of\n- * results. A subclass that implements a policy to shut down when a subtask fails may\n- * define a method to retrieve the exception of the first subtask to fail.\n- *\n- * <p> The following is an example of a {@code StructuredTaskScope} implementation that\n- * collects the results of subtasks that complete successfully. It defines the method\n- * <b>{@code results()}<\/b> to be used by the main task to retrieve the results.\n- *\n- * {@snippet lang=java :\n- *     class MyScope<T> extends StructuredTaskScope<T> {\n- *         private final Queue<T> results = new ConcurrentLinkedQueue<>();\n- *\n- *         MyScope() {\n- *             super(null, Thread.ofVirtual().factory());\n- *         }\n- *\n- *         @Override\n- *         \/\/ @link substring=\"handleComplete\" target=\"handleComplete\" :\n- *         protected void handleComplete(Future<T> future) {\n- *             if (future.state() == Future.State.SUCCESS) {\n- *                 T result = future.resultNow();\n- *                 results.add(result);\n- *             }\n- *         }\n- *\n- *         \/\/ Returns a stream of results from the subtasks that completed successfully\n- *         public Stream<T> results() {     \/\/ @highlight substring=\"results\"\n- *             return results.stream();\n- *         }\n- *     }\n- *  }\n- *\n- * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n- *\n- * Task scopes form a tree where parent-child relations are established implicitly when\n- * opening a new task scope:\n- * <ul>\n- *   <li> A parent-child relation is established when a thread started in a task scope\n- *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n- *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n- *   scope \"B\".\n- *   <li> A parent-child relation is established with nesting. If a thread opens task\n- *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n- *   scope \"B\" is the parent of the nested task scope \"C\".\n- * <\/ul>\n- *\n- * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n- * of, plus the descendants of the child task scopes, recursively.\n- *\n- * <p> The tree structure supports:\n- * <ul>\n- *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n- *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n- *   descriptions means threads started in the task scope or descendant scopes.\n- * <\/ul>\n- *\n- * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n- * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n- * is created and its {@code fork} method invoked to start a thread to execute {@code\n- * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n- * creating the task scope. The code in {@code childTask} uses the value of the scoped\n- * value and so reads the value \"{@code duke}\".\n- * {@snippet lang=java :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n- *\n- *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object, Runnable)\" :\n- *     ScopedValue.where(USERNAME, \"duke\", () -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n- *\n- *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n- *             ...\n- *          }\n- *     });\n- *\n- *     ...\n- *\n- *     String childTask() {\n- *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n- *         String name = USERNAME.get();   \/\/ \"duke\"\n- *         ...\n- *     }\n- * }\n- *\n- * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n- * at this time.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n- *\n- * <h2>Memory consistency effects<\/h2>\n- *\n- * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n- * {@linkplain #fork forking} of a {@code Callable} task\n- * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n- * <i>happen-before<\/i><\/a> any actions taken by that task, which in turn <i>happen-before<\/i>\n- * the task result is retrieved via its {@code Future}, or <i>happen-before<\/i> any actions\n- * taken in a thread after {@linkplain #join() joining} of the task scope.\n- *\n- * @jls 17.4.5 Happens-before Order\n- *\n- * @param <T> the result type of tasks executed in the scope\n- * @since 19\n- *\/\n-public class StructuredTaskScope<T> implements AutoCloseable {\n-    private static final VarHandle FUTURES;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            FUTURES = l.findVarHandle(StructuredTaskScope.class, \"futures\", Set.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private final ThreadFactory factory;\n-    private final ThreadFlock flock;\n-    private final ReentrantLock shutdownLock = new ReentrantLock();\n-\n-    \/\/ lazily created set of Future objects with threads waiting in Future::get\n-    private volatile Set<Future<?>> futures;\n-\n-    \/\/ set by owner when it forks, reset by owner when it joins\n-    private boolean needJoin;\n-\n-    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n-    private static final int OPEN     = 0;   \/\/ initial state\n-    private static final int SHUTDOWN = 1;\n-    private static final int CLOSED   = 2;\n-\n-    \/\/ scope state, set by owner, read by any thread\n-    private volatile int state;\n-\n-    \/**\n-     * Creates a structured task scope with the given name and thread factory. The task\n-     * scope is optionally named for the purposes of monitoring and management. The thread\n-     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n-     * tasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n-     * current thread.\n-     *\n-     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-     * bindings for inheritance by threads created in the task scope. The\n-     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n-     * details how parent-child relations are established implicitly for the purpose of\n-     * inheritance of scoped value bindings.\n-     *\n-     * @param name the name of the task scope, can be null\n-     * @param factory the thread factory\n-     *\/\n-    public StructuredTaskScope(String name, ThreadFactory factory) {\n-        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n-        this.flock = ThreadFlock.open(name);\n-    }\n-\n-    \/**\n-     * Creates an unnamed structured task scope that creates virtual threads. The task\n-     * scope is owned by the current thread.\n-     *\n-     * <p> This constructor is equivalent to invoking the 2-arg constructor with a name\n-     * of {@code null} and a thread factory that creates virtual threads.\n-     *\/\n-    public StructuredTaskScope() {\n-        this.factory = Thread.ofVirtual().factory();\n-        this.flock = ThreadFlock.open(null);\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner.\n-     *\/\n-    private void ensureOwner() {\n-        if (Thread.currentThread() != flock.owner())\n-            throw new WrongThreadException(\"Current thread not owner\");\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner\n-     * or a thread contained in the tree.\n-     *\/\n-    private void ensureOwnerOrContainsThread() {\n-        Thread currentThread = Thread.currentThread();\n-        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n-            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n-    }\n-\n-    \/**\n-     * Tests if the task scope is shutdown.\n-     *\/\n-    private boolean isShutdown() {\n-        return state >= SHUTDOWN;\n-    }\n-\n-    \/**\n-     * Track the given Future.\n-     *\/\n-    private void track(Future<?> future) {\n-        \/\/ create the set of Futures if not already created\n-        Set<Future<?>> futures = this.futures;\n-        if (futures == null) {\n-            futures = ConcurrentHashMap.newKeySet();\n-            if (!FUTURES.compareAndSet(this, null, futures)) {\n-                \/\/ lost the race\n-                futures = this.futures;\n-            }\n-        }\n-        futures.add(future);\n-    }\n-\n-    \/**\n-     * Stop tracking the Future.\n-     *\/\n-    private void untrack(Future<?> future) {\n-        assert futures != null;\n-        futures.remove(future);\n-    }\n-\n-    \/**\n-     * Invoked when a task completes before the scope is shut down.\n-     *\n-     * <p> The {@code handleComplete} method should be thread safe. It may be invoked by\n-     * several threads concurrently.\n-     *\n-     * @implSpec The default implementation does nothing.\n-     *\n-     * @param future the completed task\n-     *\/\n-    protected void handleComplete(Future<T> future) { }\n-\n-    \/**\n-     * Starts a new thread to run the given task.\n-     *\n-     * <p> The new thread is created with the task scope's {@link ThreadFactory}. It\n-     * inherits the current thread's {@linkplain ScopedValue scoped value} bindings. The\n-     * bindings must match the bindings captured when the task scope was created.\n-     *\n-     * <p> If the task completes before the task scope is {@link #shutdown() shutdown}\n-     * then the {@link #handleComplete(Future) handleComplete} method is invoked to\n-     * consume the completed task. The {@code handleComplete} method is run when the task\n-     * completes with a result or exception. If the {@code Future}'s {@link\n-     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n-     * is shut down, then the {@code handleComplete} method is run by the thread that\n-     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n-     * that the task completes or is cancelled then the {@code handleComplete} method may\n-     * or may not be invoked.\n-     *\n-     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process\n-     * of shutting down) then {@code fork} returns a {@code Future} representing a {@link\n-     * Future.State#CANCELLED cancelled} task that was not run.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope. The {@link Future#cancel(boolean) cancel} method of the returned\n-     * {@code Future} object is also restricted to the task scope owner or threads contained\n-     * in the task scope. The {@code cancel} method throws {@link WrongThreadException}\n-     * if invoked from another thread. All other methods on the returned {@code Future}\n-     * object, such as {@link Future#get() get}, are not restricted.\n-     *\n-     * @param task the task to run\n-     * @param <U> the result type\n-     * @return a future\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the task scope\n-     * @throws StructureViolationException if the current scoped value bindings are not\n-     * the same as when the task scope was created\n-     * @throws RejectedExecutionException if the thread factory rejected creating a\n-     * thread to run the task\n-     *\/\n-    public <U extends T> Future<U> fork(Callable<? extends U> task) {\n-        Objects.requireNonNull(task, \"'task' is null\");\n-\n-        \/\/ create future\n-        var future = new FutureImpl<U>(this, task);\n-\n-        boolean shutdown = (state >= SHUTDOWN);\n-\n-        if (!shutdown) {\n-            \/\/ create thread\n-            Thread thread = factory.newThread(future);\n-            if (thread == null) {\n-                throw new RejectedExecutionException(\"Rejected by thread factory\");\n-            }\n-\n-            \/\/ attempt to start the thread\n-            try {\n-                flock.start(thread);\n-            } catch (IllegalStateException e) {\n-                \/\/ shutdown or in the process of shutting down\n-                shutdown = true;\n-            }\n-        }\n-\n-        if (shutdown) {\n-            if (state == CLOSED) {\n-                throw new IllegalStateException(\"Task scope is closed\");\n-            } else {\n-                future.cancel(false);\n-            }\n-        }\n-\n-        \/\/ if owner forks then it will need to join\n-        if (Thread.currentThread() == flock.owner() && !needJoin) {\n-            needJoin = true;\n-        }\n-\n-        return future;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down.\n-     *\/\n-    private void implJoin(Duration timeout)\n-        throws InterruptedException, TimeoutException\n-    {\n-        ensureOwner();\n-        needJoin = false;\n-        int s = state;\n-        if (s >= SHUTDOWN) {\n-            if (s == CLOSED)\n-                throw new IllegalStateException(\"Task scope is closed\");\n-            return;\n-        }\n-\n-        \/\/ wait for all threads, wakeup, interrupt, or timeout\n-        if (timeout != null) {\n-            flock.awaitAll(timeout);\n-        } else {\n-            flock.awaitAll();\n-        }\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down. This method waits\n-     * until all threads started in the task scope finish execution (of both task and\n-     * {@link #handleComplete(Future) handleComplete} method), the {@link #shutdown()\n-     * shutdown} method is invoked to shut down the task scope, or the current thread\n-     * is {@linkplain Thread#interrupt() interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws InterruptedException if interrupted while waiting\n-     *\/\n-    public StructuredTaskScope<T> join() throws InterruptedException {\n-        try {\n-            implJoin(null);\n-        } catch (TimeoutException e) {\n-            throw new InternalError();\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down, up to the given\n-     * deadline. This method waits until all threads started in the task scope finish\n-     * execution (of both task and {@link #handleComplete(Future) handleComplete} method),\n-     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n-     * the current thread is {@linkplain Thread#interrupt() interrupted}, or the deadline\n-     * is reached.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @param deadline the deadline\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws InterruptedException if interrupted while waiting\n-     * @throws TimeoutException if the deadline is reached while waiting\n-     *\/\n-    public StructuredTaskScope<T> joinUntil(Instant deadline)\n-        throws InterruptedException, TimeoutException\n-    {\n-        Duration timeout = Duration.between(Instant.now(), deadline);\n-        implJoin(timeout);\n-        return this;\n-    }\n-\n-    \/**\n-     * Cancel all tracked Future objects.\n-     *\/\n-    private void cancelTrackedFutures() {\n-        Set<Future<?>> futures = this.futures;\n-        if (futures != null) {\n-            futures.forEach(f -> f.cancel(false));\n-        }\n-    }\n-\n-    \/**\n-     * Interrupt all unfinished threads.\n-     *\/\n-    private void implInterruptAll() {\n-        flock.threads().forEach(t -> {\n-            if (t != Thread.currentThread()) {\n-                t.interrupt();\n-            }\n-        });\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private void interruptAll() {\n-        if (System.getSecurityManager() == null) {\n-            implInterruptAll();\n-        } else {\n-            PrivilegedAction<Void> pa = () -> {\n-                implInterruptAll();\n-                return null;\n-            };\n-            AccessController.doPrivileged(pa);\n-        }\n-    }\n-\n-    \/**\n-     * Shutdown the task scope if not already shutdown. Return true if this method\n-     * shutdowns the task scope, false if already shutdown.\n-     *\/\n-    private boolean implShutdown() {\n-        if (state < SHUTDOWN) {\n-            shutdownLock.lock();\n-            try {\n-                if (state < SHUTDOWN) {\n-\n-                    \/\/ prevent new threads from starting\n-                    flock.shutdown();\n-\n-                    \/\/ wakeup any threads waiting in Future::get\n-                    cancelTrackedFutures();\n-\n-                    \/\/ interrupt all unfinished threads\n-                    interruptAll();\n-\n-                    state = SHUTDOWN;\n-                    return true;\n-                }\n-            } finally {\n-                shutdownLock.unlock();\n-            }\n-        }\n-        assert state >= SHUTDOWN;\n-        return false;\n-    }\n-\n-    \/**\n-     * Shut down the task scope without closing it. Shutting down a task scope prevents\n-     * new threads from starting, interrupts all unfinished threads, and causes the\n-     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n-     * results of unfinished subtasks are no longer needed.\n-     *\n-     * <p> More specifically, this method:\n-     * <ul>\n-     * <li> {@linkplain Future#cancel(boolean) Cancels} the tasks that have threads\n-     * {@linkplain Future#get() waiting} on a result so that the waiting threads wakeup.\n-     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n-     * task scope (except the current thread).\n-     * <li> Wakes up the owner if it is waiting in {@link #join()} or {@link\n-     * #joinUntil(Instant)}. If the owner is not waiting then its next call to {@code\n-     * join} or {@code joinUntil} will return immediately.\n-     * <\/ul>\n-     *\n-     * <p> When this method completes then the {@code Future} objects for all tasks will\n-     * be {@linkplain Future#isDone() done}, normally or abnormally. There may still\n-     * be threads that have not finished because they are executing code that did not\n-     * respond (or respond promptly) to thread interrupt. This method does not wait\n-     * for these threads. When the owner invokes the {@link #close() close} method\n-     * to close the task scope then it will wait for the remaining threads to finish.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n-     *\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner or\n-     * a thread contained in the task scope\n-     *\/\n-    public void shutdown() {\n-        ensureOwnerOrContainsThread();\n-        if (state == CLOSED)\n-            throw new IllegalStateException(\"Task scope is closed\");\n-        if (implShutdown())\n-            flock.wakeup();\n-    }\n-\n-    \/**\n-     * Closes this task scope.\n-     *\n-     * <p> This method first shuts down the task scope (as if by invoking the {@link\n-     * #shutdown() shutdown} method). It then waits for the threads executing any\n-     * unfinished tasks to finish. If interrupted then this method will continue to\n-     * wait for the threads to finish before completing with the interrupt status set.\n-     *\n-     * <p> This method may only be invoked by the task scope owner. If the task scope\n-     * is already closed then the owner invoking this method has no effect.\n-     *\n-     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n-     * manner<\/em>. If this method is called to close a task scope before nested task\n-     * scopes are closed then it closes the underlying construct of each nested task scope\n-     * (in the reverse order that they were created in), closes this task scope, and then\n-     * throws {@link StructureViolationException}.\n-     *\n-     * Similarly, if this method is called to close a task scope while executing with\n-     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n-     * before the scoped values were bound, then {@code StructureViolationException} is\n-     * thrown after closing the task scope.\n-     *\n-     * If a thread terminates without first closing task scopes that it owns then\n-     * termination will cause the underlying construct of each of its open tasks scopes to\n-     * be closed. Closing is performed in the reverse order that the task scopes were\n-     * created in. Thread termination may therefore be delayed when the owner has to wait\n-     * for threads forked in these task scopes to finish.\n-     *\n-     * @throws IllegalStateException thrown after closing the task scope if the owner\n-     * did not invoke join after forking\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws StructureViolationException if a structure violation was detected\n-     *\/\n-    @Override\n-    public void close() {\n-        ensureOwner();\n-        if (state == CLOSED)\n-            return;\n-\n-        try {\n-            implShutdown();\n-            flock.close();\n-        } finally {\n-            state = CLOSED;\n-        }\n-\n-        if (needJoin) {\n-            throw new IllegalStateException(\"Owner did not invoke join or joinUntil after fork\");\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        String name = flock.name();\n-        if (name != null) {\n-            sb.append(name);\n-            sb.append('\/');\n-        }\n-        sb.append(Objects.toIdentityString(this));\n-        int s = state;\n-        if (s == CLOSED)\n-            sb.append(\"\/closed\");\n-        else if (s == SHUTDOWN)\n-            sb.append(\"\/shutdown\");\n-        return sb.toString();\n-    }\n-\n-    \/**\n-     * The Future implementation returned by the fork methods. Most methods are\n-     * overridden to support cancellation when the task scope is shutdown.\n-     * The blocking get methods register the Future with the task scope so that they\n-     * are cancelled when the task scope shuts down.\n-     *\/\n-    private static final class FutureImpl<V> extends FutureTask<V> {\n-        private final StructuredTaskScope<V> scope;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        FutureImpl(StructuredTaskScope<? super V> scope, Callable<? extends V> task) {\n-            super((Callable<V>) task);\n-            this.scope = (StructuredTaskScope<V>) scope;\n-        }\n-\n-        @Override\n-        protected void done() {\n-            if (!scope.isShutdown()) {\n-                scope.handleComplete(this);\n-            }\n-        }\n-\n-        private void cancelIfShutdown() {\n-            if (scope.isShutdown() && !super.isDone()) {\n-                super.cancel(false);\n-            }\n-        }\n-\n-        @Override\n-        public boolean isDone() {\n-            cancelIfShutdown();\n-            return super.isDone();\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            cancelIfShutdown();\n-            return super.isCancelled();\n-        }\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) {\n-            scope.ensureOwnerOrContainsThread();\n-            cancelIfShutdown();\n-            return super.cancel(mayInterruptIfRunning);\n-        }\n-\n-        @Override\n-        public V get() throws InterruptedException, ExecutionException {\n-            if (super.isDone())\n-                return super.get();\n-            scope.track(this);\n-            try {\n-                cancelIfShutdown();\n-                return super.get();\n-            } finally {\n-                scope.untrack(this);\n-            }\n-        }\n-\n-        @Override\n-        public V get(long timeout, TimeUnit unit)\n-                throws InterruptedException, ExecutionException, TimeoutException {\n-            Objects.requireNonNull(unit);\n-            if (super.isDone())\n-                return super.get();\n-            scope.track(this);\n-            try {\n-                cancelIfShutdown();\n-                return super.get(timeout, unit);\n-            } finally {\n-                scope.untrack(this);\n-            }\n-        }\n-\n-        @Override\n-        public V resultNow() {\n-            cancelIfShutdown();\n-            return super.resultNow();\n-        }\n-\n-        @Override\n-        public Throwable exceptionNow() {\n-            cancelIfShutdown();\n-            return super.exceptionNow();\n-        }\n-\n-        @Override\n-        public State state() {\n-            cancelIfShutdown();\n-            return super.state();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cancelIfShutdown();\n-            return super.toString();\n-        }\n-    }\n-\n-    \/**\n-     * Maps a Future.State to an int that can be compared.\n-     * RUNNING < CANCELLED < FAILED < SUCCESS.\n-     *\/\n-    private static int futureStateToInt(Future.State s) {\n-        return switch (s) {\n-            case RUNNING   -> 0;\n-            case CANCELLED -> 1;\n-            case FAILED    -> 2;\n-            case SUCCESS   -> 3;\n-        };\n-    }\n-\n-    \/\/ RUNNING < CANCELLED < FAILED < SUCCESS\n-    private static final Comparator<Future.State> FUTURE_STATE_COMPARATOR =\n-            Comparator.comparingInt(StructuredTaskScope::futureStateToInt);\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n-     * complete successfully. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n-     * method to interrupt unfinished threads and wakeup the owner. The policy\n-     * implemented by this class is intended for cases where the result of any subtask\n-     * will do (\"invoke any\") and where the results of other unfinished subtask are no\n-     * longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @param <T> the result type\n-     * @since 19\n-     *\/\n-    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n-        private static final VarHandle FUTURE;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FUTURE = l.findVarHandle(ShutdownOnSuccess.class, \"future\", Future.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-        private volatile Future<T> future;\n-\n-        \/**\n-         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope is\n-         * owned by the current thread.\n-         *\n-         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-         * bindings for inheritance by threads created in the task scope. The\n-         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n-         * the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n-         *\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n-         *\/\n-        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n-\n-        \/**\n-         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n-         *\n-         * <p> This constructor is equivalent to invoking the 2-arg constructor with a\n-         * name of {@code null} and a thread factory that creates virtual threads.\n-         *\/\n-        public ShutdownOnSuccess() {\n-            super(null, Thread.ofVirtual().factory());\n-        }\n-\n-        \/**\n-         * Shut down the given task scope when invoked for the first time with a {@code\n-         * Future} for a task that completed with a result.\n-         *\n-         * @param future the completed task\n-         * @see #shutdown()\n-         * @see Future.State#SUCCESS\n-         *\/\n-        @Override\n-        protected void handleComplete(Future<T> future) {\n-            Future.State state = future.state();\n-            if (state == Future.State.RUNNING) {\n-                throw new IllegalArgumentException(\"Task is not completed\");\n-            }\n-\n-            Future<T> f;\n-            while (((f = this.future) == null)\n-                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n-                if (FUTURE.compareAndSet(this, f, future)) {\n-                    if (state == Future.State.SUCCESS)\n-                        shutdown();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnSuccess<T> join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n-\n-        \/**\n-         * {@return the result of the first subtask that completed with a result}\n-         *\n-         * <p> When no subtask completed with a result but a task completed with an\n-         * exception then {@code ExecutionException} is thrown with the exception as the\n-         * {@linkplain Throwable#getCause() cause}. If only cancelled subtasks were\n-         * notified to the {@code handleComplete} method then {@code CancellationException}\n-         * is thrown.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @throws ExecutionException if no subtasks completed with a result but a subtask\n-         * completed with an exception\n-         * @throws CancellationException if all subtasks were cancelled\n-         * @throws IllegalStateException if the handle method was not invoked with a\n-         * completed subtask\n-         *\/\n-        public T result() throws ExecutionException {\n-            Future<T> f = future;\n-            if (f == null) {\n-                throw new IllegalStateException(\"No completed subtasks\");\n-            }\n-            return switch (f.state()) {\n-                case SUCCESS   -> f.resultNow();\n-                case FAILED    -> throw new ExecutionException(f.exceptionNow());\n-                case CANCELLED -> throw new CancellationException();\n-                default        -> throw new InternalError(\"Unexpected state: \" + f);\n-            };\n-\n-        }\n-\n-        \/**\n-         * Returns the result of the first subtask that completed with a result, otherwise\n-         * throws an exception produced by the given exception supplying function.\n-         *\n-         * <p> When no subtask completed with a result but a subtask completed with an\n-         * exception then the exception supplying function is invoked with the exception.\n-         * If only cancelled subtasks were notified to the {@code handleComplete} method\n-         * then the exception supplying function is invoked with a {@code CancellationException}.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @return the result of the first subtask that completed with a result\n-         * @throws X if no subtask completed with a result\n-         * @throws IllegalStateException if the handle method was not invoked with a\n-         * completed subtask\n-         *\/\n-        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            Future<T> f = future;\n-            if (f == null) {\n-                throw new IllegalStateException(\"No completed subtasks\");\n-            }\n-            Future.State state = f.state();\n-            if (state == Future.State.SUCCESS) {\n-                return f.resultNow();\n-            } else {\n-                Throwable throwable = (state == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n-     * complete abnormally. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n-     * method to interrupt unfinished threads and wakeup the owner. The policy implemented\n-     * by this class is intended for cases where the results for all subtasks are required\n-     * (\"invoke all\"); if any subtask fails then the results of other unfinished subtasks\n-     * are no longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @since 19\n-     *\/\n-    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n-        private static final VarHandle FUTURE;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FUTURE = l.findVarHandle(ShutdownOnFailure.class, \"future\", Future.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-        private volatile Future<Object> future;\n-\n-        \/**\n-         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n-         *\n-         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-         * bindings for inheritance by threads created in the task scope. The\n-         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n-         * the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n-         *\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n-         *\/\n-        public ShutdownOnFailure(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n-\n-        \/**\n-         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n-         *\n-         * <p> This constructor is equivalent to invoking the 2-arg constructor with a\n-         * name of {@code null} and a thread factory that creates virtual threads.\n-         *\/\n-        public ShutdownOnFailure() {\n-            super(null, Thread.ofVirtual().factory());\n-        }\n-\n-        \/**\n-         * Shut down the given task scope when invoked for the first time with a {@code\n-         * Future} for a task that completed abnormally (exception or cancelled).\n-         *\n-         * @param future the completed task\n-         * @see #shutdown()\n-         * @see Future.State#FAILED\n-         * @see Future.State#CANCELLED\n-         *\/\n-        @Override\n-        protected void handleComplete(Future<Object> future) {\n-            Future.State state = future.state();\n-            if (state == Future.State.RUNNING) {\n-                throw new IllegalArgumentException(\"Task is not completed\");\n-            } else if (state == Future.State.SUCCESS) {\n-                return;\n-            }\n-\n-            \/\/ A failed task overrides a cancelled task.\n-            \/\/ The first failed or cancelled task causes the scope to shutdown.\n-            Future<Object> f;\n-            while (((f = this.future) == null)\n-                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n-                if (FUTURE.compareAndSet(this, f, future)) {\n-                    shutdown();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n-\n-        \/**\n-         * Returns the exception for the first subtask that completed with an exception.\n-         * If no subtask completed with an exception but cancelled subtasks were notified\n-         * to the {@code handleComplete} method then a {@code CancellationException}\n-         * is returned. If no subtasks completed abnormally then an empty {@code Optional}\n-         * is returned.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @return the exception for a subtask that completed abnormally or an empty\n-         * optional if no subtasks completed abnormally\n-         *\/\n-        public Optional<Throwable> exception() {\n-            Future<Object> f = future;\n-            if (f != null) {\n-                Throwable throwable = (f.state() == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                return Optional.of(throwable);\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/**\n-         * Throws if a subtask completed abnormally. If any subtask completed with an\n-         * exception then {@code ExecutionException} is thrown with the exception of the\n-         * first subtask to fail as the {@linkplain Throwable#getCause() cause}. If no\n-         * subtask completed with an exception but cancelled subtasks were notified to the\n-         * {@code handleComplete} method then {@code CancellationException} is thrown.\n-         * This method does nothing if no subtasks completed abnormally.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @throws ExecutionException if a subtask completed with an exception\n-         * @throws CancellationException if no subtasks completed with an exception but\n-         * subtasks were cancelled\n-         *\/\n-        public void throwIfFailed() throws ExecutionException {\n-            Future<Object> f = future;\n-            if (f != null) {\n-                if (f.state() == Future.State.FAILED) {\n-                    throw new ExecutionException(f.exceptionNow());\n-                } else {\n-                    throw new CancellationException();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Throws the exception produced by the given exception supplying function if\n-         * a subtask completed abnormally. If any subtask completed with an exception then\n-         * the function is invoked with the exception of the first subtask to fail.\n-         * If no subtask completed with an exception but cancelled subtasks were notified\n-         * to the {@code handleComplete} method then the function is called with a {@code\n-         * CancellationException}. The exception returned by the function is thrown.\n-         * This method does nothing if no subtasks completed abnormally.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @throws X produced by the exception supplying function\n-         *\/\n-        public <X extends Throwable>\n-        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            Future<Object> f = future;\n-            if (f != null) {\n-                Throwable throwable = (f.state() == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":0,"deletions":1223,"binary":false,"changes":1223,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines non-final APIs for concurrent programming.\n- * {@Incubating}\n- *\/\n-package jdk.incubator.concurrent;\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/package-info.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines non-final APIs for concurrent programming.\n- * {@Incubating}\n- *\n- * @moduleGraph\n- *\/\n-module jdk.incubator.concurrent {\n-    exports jdk.incubator.concurrent;\n-}\n-\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/module-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import java.io.IOException;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+class JDKNativePty {\n+\n+    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported.\");\n+    }\n+\n+    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported.\");\n+    }\n+\n+    static int isatty(int fd) {\n+        throw new UnsupportedOperationException(\"Not supported.\");\n+    }\n+\n+    static String ttyname(int fd) {\n+        throw new UnsupportedOperationException(\"Not supported.\");\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/aix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -107,0 +107,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n@@ -1403,2 +1404,2 @@\n-                    if (node.getName().toString().matches(\"(?i)h[1-6]\") && !hasIdAttribute(node)) {\n-                        generateHeadingId(node, trees, attrs);\n+                    if (node.getName().toString().matches(\"(?i)h[1-6]\")) {\n+                        createSectionIdAndIndex(node, trees, attrs, element, context);\n@@ -1479,3 +1480,5 @@\n-    private boolean hasIdAttribute(StartElementTree node) {\n-        return node.getAttributes().stream().anyMatch(\n-                dt -> dt instanceof AttributeTree at && equalsIgnoreCase(at.getName(), \"id\"));\n+    private Optional<String> getIdAttributeValue(StartElementTree node) {\n+         return node.getAttributes().stream()\n+                 .filter(dt -> dt instanceof AttributeTree at && equalsIgnoreCase(at.getName(), \"id\"))\n+                 .map(dt -> ((AttributeTree)dt).getValue().toString())\n+                 .findFirst();\n@@ -1484,1 +1487,4 @@\n-    private void generateHeadingId(StartElementTree node, List<? extends DocTree> trees, Content content) {\n+    private void createSectionIdAndIndex(StartElementTree node, List<? extends DocTree> trees, Content attrs,\n+                                         Element element, TagletWriterImpl.Context context) {\n+        \/\/ Use existing id attribute if available\n+        String id = getIdAttributeValue(node).orElse(null);\n@@ -1487,0 +1493,1 @@\n+        \/\/ Go through heading content to collect content and look for existing id\n@@ -1495,0 +1502,4 @@\n+            } else if (id == null && docTree instanceof StartElementTree nested\n+                    && equalsIgnoreCase(nested.getName(), \"a\")) {\n+                \/\/ Use id of embedded anchor element if present\n+                id = getIdAttributeValue(nested).orElse(null);\n@@ -1498,4 +1509,0 @@\n-            } else if (docTree instanceof StartElementTree nested\n-                    && equalsIgnoreCase(nested.getName(), \"a\")\n-                    && hasIdAttribute(nested)) {\n-                return; \/\/ Avoid generating id if embedded <a id=...> is present\n@@ -1504,2 +1511,16 @@\n-        HtmlId htmlId = htmlIds.forHeading(sb, headingIds);\n-        content.add(\"id=\\\"\").add(htmlId.name()).add(\"\\\"\");\n+        String headingContent = sb.toString().trim();\n+        if (id == null) {\n+            \/\/ Generate id attribute\n+            HtmlId htmlId = htmlIds.forHeading(headingContent, headingIds);\n+            id = htmlId.name();\n+            attrs.add(\"id=\\\"\").add(htmlId.name()).add(\"\\\"\");\n+        }\n+        \/\/ Generate index item\n+        if (!headingContent.isEmpty() && configuration.mainIndex != null) {\n+            String tagText = headingContent.replaceAll(\"\\\\s+\", \" \");\n+            IndexItem item = IndexItem.of(element, node, tagText,\n+                    getTagletWriterInstance(context).getHolderName(element),\n+                    resources.getText(\"doclet.Section\"),\n+                    new DocLink(path, id));\n+            configuration.mainIndex.add(item);\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-                reportWarning.accept(\"doclet.link.see.no_label\", null);\n+                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n@@ -911,1 +911,8 @@\n-                String holder = new SimpleElementVisitor14<String, Void>() {\n+                String holder = getHolderName(element);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, id.name()));\n+                configuration.mainIndex.add(item);\n+            }\n+        }\n+        return result;\n+    }\n@@ -913,5 +920,2 @@\n-                    @Override\n-                    public String visitModule(ModuleElement e, Void p) {\n-                        return resources.getText(\"doclet.module\")\n-                                + \" \" + utils.getFullyQualifiedName(e);\n-                    }\n+    String getHolderName(Element element) {\n+        return new SimpleElementVisitor14<String, Void>() {\n@@ -919,5 +923,5 @@\n-                    @Override\n-                    public String visitPackage(PackageElement e, Void p) {\n-                        return resources.getText(\"doclet.package\")\n-                                + \" \" + utils.getFullyQualifiedName(e);\n-                    }\n+            @Override\n+            public String visitModule(ModuleElement e, Void p) {\n+                return resources.getText(\"doclet.module\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n@@ -925,5 +929,5 @@\n-                    @Override\n-                    public String visitType(TypeElement e, Void p) {\n-                        return utils.getTypeElementKindName(e, true)\n-                                + \" \" + utils.getFullyQualifiedName(e);\n-                    }\n+            @Override\n+            public String visitPackage(PackageElement e, Void p) {\n+                return resources.getText(\"doclet.package\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n@@ -931,6 +935,5 @@\n-                    @Override\n-                    public String visitExecutable(ExecutableElement e, Void p) {\n-                        return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                                + \".\" + utils.getSimpleName(e)\n-                                + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n-                    }\n+            @Override\n+            public String visitType(TypeElement e, Void p) {\n+                return utils.getTypeElementKindName(e, true)\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n@@ -938,5 +941,6 @@\n-                    @Override\n-                    public String visitVariable(VariableElement e, Void p) {\n-                        return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                                + \".\" + utils.getSimpleName(e);\n-                    }\n+            @Override\n+            public String visitExecutable(ExecutableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e)\n+                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+            }\n@@ -944,11 +948,5 @@\n-                    @Override\n-                    public String visitUnknown(Element e, Void p) {\n-                        if (e instanceof DocletElement de) {\n-                            return switch (de.getSubKind()) {\n-                                case OVERVIEW -> resources.getText(\"doclet.Overview\");\n-                                case DOCFILE -> getHolderName(de);\n-                            };\n-                        } else {\n-                            return super.visitUnknown(e, p);\n-                        }\n-                    }\n+            @Override\n+            public String visitVariable(VariableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e);\n+            }\n@@ -956,8 +954,10 @@\n-                    @Override\n-                    protected String defaultAction(Element e, Void p) {\n-                        return utils.getFullyQualifiedName(e);\n-                    }\n-                }.visit(element);\n-                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n-                        new DocLink(htmlWriter.path, id.name()));\n-                configuration.mainIndex.add(item);\n+            @Override\n+            public String visitUnknown(Element e, Void p) {\n+                if (e instanceof DocletElement de) {\n+                    return switch (de.getSubKind()) {\n+                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                        case DOCFILE -> getHolderName(de);\n+                    };\n+                } else {\n+                    return super.visitUnknown(e, p);\n+                }\n@@ -965,2 +965,6 @@\n-        }\n-        return result;\n+\n+            @Override\n+            protected String defaultAction(Element e, Void p) {\n+                return utils.getFullyQualifiedName(e);\n+            }\n+        }.visit(element);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1076,1 +1076,1 @@\n-                out.write(value);\n+                out.write(value.replace(\"\\\"\", \"&quot;\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+doclet.Section=Section\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-            case INDEX, SPEC, SYSTEM_PROPERTY -> { }\n+            case INDEX, SPEC, SYSTEM_PROPERTY, START_ELEMENT -> { }\n@@ -343,1 +343,1 @@\n-            case INDEX, SPEC, SYSTEM_PROPERTY -> Category.TAGS;\n+            case INDEX, SPEC, SYSTEM_PROPERTY, START_ELEMENT -> Category.TAGS;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/IndexItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2181,0 +2181,7 @@\n+        } else {\n+            var p = docTrees.getPath(e);\n+            \/\/ if docTrees.getPath itself has put a path for e into elementToTreePath\n+            \/\/ (see 8304878), we assume that the path already in the map is equivalent\n+            \/\/ to the path we are about to put: hence, no harm if replaced\n+            elementToTreePath.put(e, p);\n+            return p;\n@@ -2182,1 +2189,0 @@\n-        return elementToTreePath.computeIfAbsent(e, docTrees::getPath);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -495,2 +495,8 @@\n-                            env.messages.error(HTML, tree, \"dc.tag.not.allowed.inline.element\",\n-                                    treeName, name);\n+                            \/\/ Links may use block display style so issue warning instead of error\n+                            if (\"a\".equalsIgnoreCase(name.toString())) {\n+                                env.messages.warning(HTML, tree, \"dc.tag.not.allowed.element.default.style\",\n+                                        treeName, name);\n+                            } else {\n+                                env.messages.error(HTML, tree, \"dc.tag.not.allowed.inline.element\",\n+                                        treeName, name);\n+                            }\n@@ -503,1 +509,1 @@\n-                        env.messages.error(HTML, tree, \"dc.tag.not.allowed.inline.tag\",\n+                        env.messages.warning(HTML, tree, \"dc.tag.not.allowed.tag.default.style\",\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-dc.tag.not.allowed.inline.tag = block element not allowed within @{1}: {0}\n-dc.tag.not.allowed.inline.other = block element not allowed here: {0}\n+dc.tag.not.allowed.element.default.style = block element <{0}> not allowed within element <{1}> with default style\n+dc.tag.not.allowed.tag.default.style = block element <{0}> not allowed within @{1} with default style\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-     * is suspended at a breakpoint or single step event. The target VM may\n+     * is suspended at an event. The target VM may\n@@ -227,1 +227,1 @@\n-     * virtual thread and the target VM does not support setting the value of\n+     * suspended virtual thread, and the target VM does not support setting the value of\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/StackFrame.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -439,4 +439,4 @@\n-     * The target VM may not support, or may only provide limited support,\n-     * for forcing a method to return when the thread is a virtual thread.\n-     * It may, for example, only support this operation when the virtual\n-     * thread is suspended at a breakpoint or singlestep event.\n+     * This method may be used to force a return from the current frame\n+     * of a virtual thread when it is suspended at an event.\n+     * An implementation may support forcing a return from the current frame\n+     * of a suspended virtual thread in other cases.\n@@ -487,1 +487,1 @@\n-     * @throws OpaqueFrameException if this thread is a virtual thread and the\n+     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -600,4 +600,1 @@\n-                if (meth.isNative()) {\n-                    throw new NativeMethodException();\n-                } else {\n-                    assert isVirtual(); \/\/ can only happen with virtual threads\n+                if (isVirtual() && !meth.isNative()) {\n@@ -605,0 +602,2 @@\n+                } else {\n+                    throw new NativeMethodException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    \/\/ Tjis method can't handle Long.MIN_VALUE because absolute value is negative\n+    \/\/ handle Long.MIN_VALUE as a special case since its absolute value is negative\n@@ -126,1 +126,1 @@\n-        int exp = (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n+        int exp = (amount == Long.MIN_VALUE) ? 6 : (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    \/\/ Tjis method can't handle Long.MIN_VALUE because absolute value is negative\n+    \/\/ handle Long.MIN_VALUE as a special case since its absolute value is negative\n@@ -151,1 +151,1 @@\n-        int exp = (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n+        int exp = (amount == Long.MIN_VALUE) ? 6 : (int) (Math.log(Math.abs(amount)) \/ Math.log(1024));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10,0 +10,5 @@\n+    <event name=\"jdk.ResidentSetSize\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -10,0 +10,5 @@\n+    <event name=\"jdk.ResidentSetSize\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -511,1 +512,1 @@\n-        return Platform.isLinux() && (new ToolValidator(TOOL_DPKG_DEB).validate() == null);\n+        return OperatingSystem.isLinux() && (new ToolValidator(TOOL_DPKG_DEB).validate() == null);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -334,1 +335,1 @@\n-        return Platform.isLinux() && (createRpmbuildToolValidator().validate() == null);\n+        return OperatingSystem.isLinux() && (createRpmbuildToolValidator().validate() == null);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.internal.util.OSVersion;\n@@ -404,1 +406,1 @@\n-        } else if (Platform.isMac()) {\n+        } else if (OperatingSystem.isMacOS()) {\n@@ -611,3 +613,1 @@\n-        if (Platform.getMajorVersion() < 10 ||\n-                (Platform.getMajorVersion() == 10 &&\n-                Platform.getMinorVersion() < 12)) {\n+        if (OSVersion.current().compareTo(new OSVersion(10, 12)) < 0) {\n@@ -665,3 +665,1 @@\n-        if (Platform.getMajorVersion() < 10 ||\n-                (Platform.getMajorVersion() == 10 &&\n-                Platform.getMinorVersion() < 12)) {\n+        if (OSVersion.current().compareTo(new OSVersion(10, 12)) < 0) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.OSVersion;\n+\n@@ -321,1 +324,1 @@\n-                    Platform.isArmMac() ? \"arm64\" : \"x86_64\");\n+                    Architecture.isAARCH64() ? \"arm64\" : \"x86_64\");\n@@ -600,3 +603,1 @@\n-                if (Platform.getMajorVersion() > 10 ||\n-                    (Platform.getMajorVersion() == 10 &&\n-                    Platform.getMinorVersion() >= 12)) {\n+                if (OSVersion.current().compareTo(new OSVersion(10, 12)) >= 0) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -131,1 +134,1 @@\n-        if (Platform.isWindows())  {\n+        if (OperatingSystem.isWindows()) {\n@@ -141,1 +144,1 @@\n-        if (Platform.isLinux())  {\n+        if (OperatingSystem.isLinux()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -141,1 +143,1 @@\n-        if (Platform.isMac()) {\n+        if (OperatingSystem.isMacOS()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+\n+import jdk.internal.util.OperatingSystem;\n@@ -75,3 +77,4 @@\n-    private static final Map<Platform, String> PLATFORM_LABELS = Map.of(\n-            Platform.LINUX, \"linux\", Platform.WINDOWS, \"windows\", Platform.MAC,\n-            \"macOS\");\n+    private static final Map<OperatingSystem, String> PLATFORM_LABELS = Map.of(\n+            OperatingSystem.LINUX, \"linux\",\n+            OperatingSystem.WINDOWS, \"windows\",\n+            OperatingSystem.MACOS, \"macOS\");\n@@ -437,1 +440,1 @@\n-        return PLATFORM_LABELS.get(Platform.getPlatform());\n+        return PLATFORM_LABELS.get(OperatingSystem.current());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -182,1 +184,1 @@\n-        if (Platform.isWindows()) {\n+        if (OperatingSystem.isWindows()) {\n@@ -186,1 +188,1 @@\n-        if (Platform.isLinux()) {\n+        if (OperatingSystem.isLinux()) {\n@@ -190,1 +192,1 @@\n-        if (Platform.isMac()) {\n+        if (OperatingSystem.isMacOS()) {\n@@ -194,1 +196,1 @@\n-        throw Platform.throwUnknownPlatformError();\n+        throw new IllegalArgumentException(\"Unknown platform: \" + OperatingSystem.current());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayout.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -581,1 +583,1 @@\n-        boolean isMac = Platform.isMac();\n+        boolean isMac = OperatingSystem.isMacOS();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -49,2 +51,1 @@\n-            Platform platform = (Log.isVerbose()) ?\n-                    Platform.UNKNOWN : Platform.getPlatform();\n+            OperatingSystem platform = OperatingSystem.current();\n@@ -58,1 +59,1 @@\n-                case MAC:\n+                case MACOS:\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -44,1 +46,1 @@\n-        if (Platform.isLinux()) {\n+        if (OperatingSystem.isLinux()) {\n@@ -47,1 +49,1 @@\n-        } else if (Platform.isWindows()) {\n+        } else if (OperatingSystem.isWindows()) {\n@@ -50,1 +52,1 @@\n-        } else if (Platform.isMac()) {\n+        } else if (OperatingSystem.isMacOS()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/I18N.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -80,1 +82,1 @@\n-                if (Platform.getPlatform() == Platform.WINDOWS) {\n+                if (OperatingSystem.isWindows()) {\n@@ -94,1 +96,1 @@\n-                if (Platform.getPlatform() == Platform.WINDOWS) {\n+                if (OperatingSystem.isWindows()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -361,1 +363,1 @@\n-            if (!Platform.isMac()) {\n+            if (!OperatingSystem.isMacOS()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Platform\n- *\n- * Use <code>Platform<\/code> to detect the operating system\n- * that is currently running.\n- *\n- * Example:\n- *\n- *  Platform platform = Platform.getPlatform();\n- *\n- *  switch(platform) {\n- *    case Platform.MAC: {\n- *      \/\/ Do something\n- *      break;\n- *    }\n- *    case Platform.WINDOWS:\n- *    case Platform.LINUX: {\n- *      \/\/ Do something else\n- *    }\n- *  }\n- *\n- *\/\n-enum Platform {UNKNOWN, WINDOWS, LINUX, MAC;\n-    private static final Platform platform;\n-    private static final int majorVersion;\n-    private static final int minorVersion;\n-\n-    static {\n-        String os = System.getProperty(\"os.name\").toLowerCase();\n-\n-        if (os.indexOf(\"win\") >= 0) {\n-            platform = Platform.WINDOWS;\n-        }\n-        else if (os.indexOf(\"nix\") >= 0 || os.indexOf(\"nux\") >= 0) {\n-            platform = Platform.LINUX;\n-        }\n-        else if (os.indexOf(\"mac\") >= 0) {\n-            platform = Platform.MAC;\n-        }\n-        else {\n-            platform = Platform.UNKNOWN;\n-        }\n-\n-        String version = System.getProperty(\"os.version\");\n-        String[] parts = version.split(Pattern.quote(\".\"));\n-\n-        if (parts.length > 0) {\n-            majorVersion = Integer.parseInt(parts[0]);\n-\n-            if (parts.length > 1) {\n-                minorVersion = Integer.parseInt(parts[1]);\n-            }\n-            else {\n-                minorVersion = -1;\n-            }\n-        }\n-        else {\n-            majorVersion = -1;\n-            minorVersion = -1;\n-        }\n-    }\n-\n-    private Platform() {}\n-\n-    static Platform getPlatform() {\n-        return platform;\n-    }\n-\n-    static int getMajorVersion() {\n-        return majorVersion;\n-    }\n-\n-    static int getMinorVersion() {\n-        return minorVersion;\n-    }\n-\n-    static boolean isWindows() {\n-        return getPlatform() == WINDOWS;\n-    }\n-\n-    static boolean isMac() {\n-        return getPlatform() == MAC;\n-    }\n-\n-    static boolean isArmMac() {\n-        return (isMac() && \"aarch64\".equals(System.getProperty(\"os.arch\")));\n-    }\n-\n-    static boolean isLinux() {\n-        return getPlatform() == LINUX;\n-    }\n-\n-    static RuntimeException throwUnknownPlatformError() {\n-        throw new IllegalArgumentException(\"Unknown platform\");\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Platform.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -102,1 +104,1 @@\n-        if (Platform.isWindows()) {\n+        if (OperatingSystem.isWindows()) {\n@@ -109,1 +111,1 @@\n-        if (Platform.isWindows()) {\n+        if (OperatingSystem.isWindows()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ScriptRunner.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -585,1 +587,1 @@\n-        if (Platform.isMac()) {\n+        if (OperatingSystem.isMacOS()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -48,1 +50,1 @@\n-        if (Platform.getPlatform() == Platform.LINUX) {\n+        if (OperatingSystem.isLinux()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -97,1 +98,1 @@\n-                (Platform.getPlatform() == Platform.MAC) ?\n+                (OperatingSystem.isMacOS()) ?\n@@ -105,1 +106,1 @@\n-            (Platform.getPlatform() == Platform.MAC) ?  USE.ALL : USE.INSTALL);\n+            (OperatingSystem.isMacOS()) ? USE.ALL : USE.INSTALL);\n@@ -107,1 +108,1 @@\n-        if (Platform.getPlatform() == Platform.WINDOWS) {\n+        if (OperatingSystem.isWindows()) {\n@@ -123,1 +124,1 @@\n-        if (Platform.getPlatform() == Platform.MAC) {\n+        if (OperatingSystem.isMacOS()) {\n@@ -141,1 +142,1 @@\n-        if (Platform.getPlatform() == Platform.LINUX) {\n+        if (OperatingSystem.isLinux()) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ValidOptions.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.internal.util.OSVersion;\n@@ -37,2 +39,2 @@\n-        if (Platform.getPlatform() == Platform.WINDOWS &&\n-            Platform.getMajorVersion() == 10) {\n+        if (OperatingSystem.isWindows() &&\n+                OSVersion.current().major() == 10) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsDefender.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.util.Architecture;\n@@ -105,1 +106,1 @@\n-        return !(\"x86\".equals(System.getProperty(\"os.arch\")));\n+        return Architecture.is64bit();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixFragmentBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-PRINTING, or JAVASE.\\n\\\n+PRINTING, TOOLING, or JAVASE.\\n\\\n@@ -334,1 +334,1 @@\n-file names: DEFAULT, PRINTING, or JAVASE.\\n\\\n+file names: DEFAULT, PRINTING, TOOLING, or JAVASE.\\n\\\n@@ -336,2 +336,2 @@\n-definitions of print(), println(), and printf() method snippets, or\\n\\\n-imports of all Java SE packages.\\n\n+definitions of print(), println(), and printf() method snippets, definitions\\n\\\n+of method snippets running JDK tools, or imports of all Java SE packages.\\n\n@@ -1139,1 +1139,1 @@\n-startup file names: DEFAULT, PRINTING, or JAVASE.\\n\\\n+startup file names: DEFAULT, PRINTING, TOOLING, or JAVASE.\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+void jar(String... args) { run(\"jar\", args); }\n+void javac(String... args) { run(\"javac\", args); }\n+void javadoc(String... args) { run(\"javadoc\", args); }\n+void javap(String... args) { run(\"javap\", args); }\n+void jdeps(String... args) { run(\"jdeps\", args); }\n+void jlink(String... args) { run(\"jlink\", args); }\n+void jmod(String... args) { run(\"jmod\", args); }\n+void jpackage(String... args) { run(\"jpackage\", args); }\n+\n+void javap(Class<?> type) throws Exception {\n+    try {\n+        var name = type.getCanonicalName();\n+        if (name == null) throw new IllegalArgumentException(\"Type not supported: \" + type);\n+        if (type == Class.forName(name, false, ClassLoader.getSystemClassLoader())) {\n+            run(\"javap\", \"-c\", \"-v\", \"-s\", name);\n+            return;\n+        }\n+    } catch (ClassNotFoundException ignored) {\n+        \/\/ fall-through\n+    }\n+    var temp = java.nio.file.Files.createTempFile(\"TOOLING-\", \".class\");\n+    try {\n+        var name = type.getName().replace('.', '\/') + \".class\";\n+        try (var in = type.getClassLoader().getResourceAsStream(name);\n+             var out = java.nio.file.Files.newOutputStream(temp)) {\n+            if (in == null) throw new AssertionError(\"Resource not found: \" + name);\n+            in.transferTo(out);\n+        }\n+        run(\"javap\", \"-c\", \"-v\", \"-s\", temp.toString());\n+    } finally {\n+        java.nio.file.Files.delete(temp);\n+    }\n+}\n+\n+void run(String name, String... args) {\n+    var tool = java.util.spi.ToolProvider.findFirst(name);\n+    if (tool.isEmpty()) throw new RuntimeException(\"No such tool found: \" + name);\n+    var code = tool.get().run(System.out, System.err, args);\n+    if (code == 0) return;\n+    System.err.println(name + \" returned non-zero exit code: \" + code);\n+}\n+\n+void tools() {\n+  java.util.ServiceLoader.load(java.util.spi.ToolProvider.class).stream()\n+      .map(java.util.ServiceLoader.Provider::get)\n+      .map(java.util.spi.ToolProvider::name)\n+      .sorted()\n+      .forEach(System.out::println);\n+}\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/resources\/TOOLING.jsh","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-    private final List<SettingDescriptorInfo> settings;\n+    private final List<SettingDescriptorInfo> settingDescriptors;\n@@ -56,1 +56,1 @@\n-        this.settings = creatingSettingDescriptorInfos(eventType);\n+        this.settingDescriptors = creatingSettingDescriptorInfos(eventType);\n@@ -65,1 +65,5 @@\n-        this.settings = createSettings(cd.get(\"settings\"));\n+        if (cd.containsKey(\"settings\")) {\n+            this.settingDescriptors = createSettingDescriptors(cd.get(\"settings\"));\n+        } else {\n+            this.settingDescriptors = createSettingDescriptors(cd.get(\"settingDescriptors\"));\n+        }\n@@ -70,1 +74,5 @@\n-        this.categoryNames = createCategoryNames((Object[]) cd.get(\"category\"));\n+        if (cd.containsKey(\"category\")) {\n+            this.categoryNames = createCategoryNames((Object[]) cd.get(\"category\"));\n+        } else {\n+            this.categoryNames = createCategoryNames((Object[]) cd.get(\"categoryNames\"));\n+        }\n@@ -90,1 +98,1 @@\n-    private static List<SettingDescriptorInfo> createSettings(Object settings) {\n+    private static List<SettingDescriptorInfo> createSettingDescriptors(Object settings) {\n@@ -177,1 +185,1 @@\n-        return settings;\n+        return settingDescriptors;\n@@ -232,1 +240,1 @@\n-     * <th scope=\"row\">category<\/th>\n+     * <th scope=\"row\">categoryNames<\/th>\n@@ -236,1 +244,1 @@\n-     * <th scope=\"row\">settings<\/th>\n+     * <th scope=\"row\">settingDescriptors<\/th>\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/EventTypeInfo.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -108,0 +108,36 @@\n+    \/**\n+     * Returns an approximation of the total amount of memory, in bytes, allocated\n+     * in heap memory by all threads since the Java virtual machine started.\n+     * The returned value is an approximation because some Java virtual machine\n+     * implementations may use object allocation mechanisms that result in a\n+     * delay between the time an object is allocated and the time its size is\n+     * recorded.\n+     *\n+     * @implSpec The default implementation throws {@code UnsupportedOperationException}\n+     * if the Java virtual machine implementation does not support thread\n+     * memory allocation measurement, and otherwise acts as though thread\n+     * memory allocation measurement is disabled.\n+     *\n+     * @return an approximation of the total memory allocated, in bytes, in\n+     * heap memory since the Java virtual machine was started,\n+     * if thread memory allocation measurement is enabled;\n+     * {@code -1} otherwise.\n+     *\n+     * @throws UnsupportedOperationException if the Java virtual\n+     *         machine implementation does not support thread memory allocation\n+     *         measurement.\n+     *\n+     * @see #isThreadAllocatedMemorySupported\n+     * @see #isThreadAllocatedMemoryEnabled\n+     * @see #setThreadAllocatedMemoryEnabled\n+     *\n+     * @since 21\n+     *\/\n+    public default long getTotalThreadAllocatedBytes() {\n+        if (!isThreadAllocatedMemorySupported()) {\n+            throw new UnsupportedOperationException(\n+                \"Thread allocated memory measurement is not supported.\");\n+        }\n+        return -1;\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/ThreadMXBean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+    @Override\n+    public long getTotalThreadAllocatedBytes() {\n+        return super.getTotalThreadAllocatedBytes();\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/HotSpotThreadImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,0 +289,1 @@\n+extern jint sctpHandleSocketErrorWithMessage(JNIEnv *env, jint errorValue, const char* message);\n","filename":"src\/jdk.sctp\/unix\/native\/libsctp\/Sctp.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-jint\n-sctpHandleSocketError(JNIEnv *env, jint errorValue)\n+jint sctpHandleSocketErrorWithMessage(JNIEnv *env, jint errorValue,\n+                                      const char* message)\n@@ -130,2 +130,0 @@\n-            xn = JNU_JAVANETPKG \"ConnectException\";\n-            break;\n@@ -133,0 +131,1 @@\n+        case ENOTCONN:\n@@ -147,1 +146,5 @@\n-    JNU_ThrowByNameWithLastError(env, xn, \"NioSocketError\");\n+    if (message == NULL) {\n+        JNU_ThrowByNameWithLastError(env, xn, \"NioSocketError\");\n+    } else {\n+        JNU_ThrowByNameWithMessageAndLastError(env, xn, message);\n+    }\n@@ -151,0 +154,5 @@\n+jint sctpHandleSocketError(JNIEnv *env, jint errorValue)\n+{\n+    return sctpHandleSocketErrorWithMessage(env, errorValue, NULL);\n+}\n+\n@@ -197,1 +205,1 @@\n-            return sctpHandleSocketError(env, errno);\n+            return sctpHandleSocketErrorWithMessage(env, errno, \"socket call failed\");\n@@ -212,1 +220,1 @@\n-       sctpHandleSocketError(env, errno);\n+       sctpHandleSocketErrorWithMessage(env, errno, \"setsockopt failed\");\n","filename":"src\/jdk.sctp\/unix\/native\/libsctp\/SctpNet.c","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+    \/\/ Padding: riscv\n+    std::basic_string<char> tmp4  = std::regex_replace(tmp3, std::regex(\"\\\\s+<addr>:\\\\s+unimp\"), \"\");\n@@ -50,1 +52,1 @@\n-    std::basic_string<char> red  = std::regex_replace(tmp3, std::regex(\"\\\\s+<addr>:\\\\s+hlt[ \\\\t]+(?!\\\\n\\\\s+;;)\"), \"\");\n+    std::basic_string<char> red  = std::regex_replace(tmp4, std::regex(\"\\\\s+<addr>:\\\\s+hlt[ \\\\t]+(?!\\\\n\\\\s+;;)\"), \"\");\n","filename":"test\/hotspot\/gtest\/code\/test_codestrings.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3,1 +4,0 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,25 @@\n-  HdrSeq seq;\n+  const double err = 0.5;\n+\n+  HdrSeq seq1;\n+  HdrSeq seq2;\n+  HdrSeq seq3;\n+\n+  void print() {\n+    if (seq1.num() > 0) {\n+      print(seq1, \"seq1\");\n+    }\n+    if (seq2.num() > 0) {\n+      print(seq2, \"seq2\");\n+    }\n+    if (seq3.num() > 0) {\n+      print(seq3, \"seq3\");\n+    }\n+  }\n+\n+  void print(HdrSeq& seq, const char* msg) {\n+    std::cout << \"[\";\n+    for (int i = 0; i <= 100; i += 10) {\n+      std::cout << \"\\t\" << seq.percentile(i);\n+    }\n+    std::cout << \" ] : \" << msg << \"\\n\";\n+  }\n@@ -41,2 +65,1 @@\n- protected:\n-  const double err = 0.5;\n+ public:\n@@ -44,3 +67,3 @@\n-    seq.add(0);\n-    seq.add(1);\n-    seq.add(10);\n+    seq1.add(0);\n+    seq1.add(1);\n+    seq1.add(10);\n@@ -48,1 +71,12 @@\n-      seq.add(100);\n+      seq1.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n+  }\n+};\n+\n+class ShenandoahNumberSeqMergeTest: public ShenandoahNumberSeqTest {\n+ public:\n+  ShenandoahNumberSeqMergeTest() {\n+    for (int i = 0; i < 80; i++) {\n+      seq1.add(1);\n+      seq3.add(1);\n@@ -50,8 +84,6 @@\n-    std::cout << \" p0 = \" << seq.percentile(0);\n-    std::cout << \" p10 = \" << seq.percentile(10);\n-    std::cout << \" p20 = \" << seq.percentile(20);\n-    std::cout << \" p30 = \" << seq.percentile(30);\n-    std::cout << \" p50 = \" << seq.percentile(50);\n-    std::cout << \" p80 = \" << seq.percentile(80);\n-    std::cout << \" p90 = \" << seq.percentile(90);\n-    std::cout << \" p100 = \" << seq.percentile(100);\n+\n+    for (int i = 0; i < 20; i++) {\n+      seq2.add(100);\n+      seq3.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n@@ -62,1 +94,1 @@\n-  EXPECT_EQ(seq.maximum(), 100);\n+  EXPECT_EQ(seq1.maximum(), 100);\n@@ -66,1 +98,1 @@\n-  EXPECT_EQ(0, seq.percentile(0));\n+  EXPECT_EQ(0, seq1.percentile(0));\n@@ -70,8 +102,61 @@\n-  EXPECT_NEAR(0, seq.percentile(10), err);\n-  EXPECT_NEAR(1, seq.percentile(20), err);\n-  EXPECT_NEAR(10, seq.percentile(30), err);\n-  EXPECT_NEAR(100, seq.percentile(40), err);\n-  EXPECT_NEAR(100, seq.percentile(50), err);\n-  EXPECT_NEAR(100, seq.percentile(75), err);\n-  EXPECT_NEAR(100, seq.percentile(90), err);\n-  EXPECT_NEAR(100, seq.percentile(100), err);\n+  EXPECT_NEAR(0, seq1.percentile(10), err);\n+  EXPECT_NEAR(1, seq1.percentile(20), err);\n+  EXPECT_NEAR(10, seq1.percentile(30), err);\n+  EXPECT_NEAR(100, seq1.percentile(40), err);\n+  EXPECT_NEAR(100, seq1.percentile(50), err);\n+  EXPECT_NEAR(100, seq1.percentile(75), err);\n+  EXPECT_NEAR(100, seq1.percentile(90), err);\n+  EXPECT_NEAR(100, seq1.percentile(100), err);\n+}\n+\n+TEST_VM_F(BasicShenandoahNumberSeqTest, clear_test) {\n+  HdrSeq test;\n+  test.add(1);\n+\n+  EXPECT_NE(test.num(), 0);\n+  EXPECT_NE(test.sum(), 0);\n+  EXPECT_NE(test.maximum(), 0);\n+  EXPECT_NE(test.avg(), 0);\n+  EXPECT_EQ(test.sd(), 0);\n+  EXPECT_NE(test.davg(), 0);\n+  EXPECT_EQ(test.dvariance(), 0);\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NE(test.percentile(i), 0);\n+  }\n+\n+  test.clear();\n+\n+  EXPECT_EQ(test.num(), 0);\n+  EXPECT_EQ(test.sum(), 0);\n+  EXPECT_EQ(test.maximum(), 0);\n+  EXPECT_EQ(test.avg(), 0);\n+  EXPECT_EQ(test.sd(), 0);\n+  EXPECT_EQ(test.davg(), 0);\n+  EXPECT_EQ(test.dvariance(), 0);\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_EQ(test.percentile(i), 0);\n+  }\n+}\n+\n+TEST_VM_F(ShenandoahNumberSeqMergeTest, merge_test) {\n+  EXPECT_EQ(seq1.num(), 80);\n+  EXPECT_EQ(seq2.num(), 20);\n+  EXPECT_EQ(seq3.num(), 100);\n+\n+  HdrSeq merged;\n+  merged.add(seq1);\n+  merged.add(seq2);\n+\n+  EXPECT_EQ(merged.num(), seq3.num());\n+\n+  EXPECT_EQ(merged.maximum(), seq3.maximum());\n+  EXPECT_EQ(merged.percentile(0), seq3.percentile(0));\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NEAR(merged.percentile(i), seq3.percentile(i), err);\n+  }\n+  EXPECT_NEAR(merged.avg(), seq3.avg(), err);\n+  EXPECT_NEAR(merged.sd(),  seq3.sd(),  err);\n+\n+  \/\/ These are not implemented\n+  EXPECT_TRUE(isnan(merged.davg()));\n+  EXPECT_TRUE(isnan(merged.dvariance()));\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":111,"deletions":26,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp\"\n+#include <cstdarg>\n+\n+\/\/ These tests will all be skipped (unless Shenandoah becomes the default\n+\/\/ collector). To execute these tests, you must enable Shenandoah, which\n+\/\/ is done with:\n+\/\/\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\"\n+\/\/\n+\/\/ Please note that these 'unit' tests are really integration tests and rely\n+\/\/ on the JVM being initialized. These tests manipulate the state of the\n+\/\/ collector in ways that are not compatible with a normal collection run.\n+\/\/ If these tests take longer than the minimum time between gc intervals -\n+\/\/ or, more likely, if you have them paused in a debugger longer than this\n+\/\/ interval - you can expect trouble. These tests will also not run in a build\n+\/\/ with asserts enabled because they use APIs that expect to run on a safepoint.\n+#ifdef ASSERT\n+#define SKIP_IF_NOT_SHENANDOAH()           \\\n+  tty->print_cr(\"skipped (debug build)\" ); \\\n+  return;\n+#else\n+#define SKIP_IF_NOT_SHENANDOAH() \\\n+    if (!UseShenandoahGC) {      \\\n+      tty->print_cr(\"skipped\");  \\\n+      return;                    \\\n+    }\n+#endif\n+\n+class ShenandoahResetRegions : public ShenandoahHeapRegionClosure {\n+ public:\n+  virtual void heap_region_do(ShenandoahHeapRegion* region) override {\n+    if (!region->is_empty()) {\n+      region->make_trash();\n+      region->make_empty();\n+    }\n+    region->set_affiliation(FREE);\n+    region->clear_live_data();\n+    region->set_top(region->bottom());\n+  }\n+};\n+\n+class ShenandoahOldHeuristicTest : public ::testing::Test {\n+ protected:\n+  ShenandoahHeap* _heap;\n+  ShenandoahOldHeuristics* _heuristics;\n+  ShenandoahCollectionSet* _collection_set;\n+\n+  ShenandoahOldHeuristicTest()\n+    : _heap(nullptr),\n+      _heuristics(nullptr),\n+      _collection_set(nullptr) {\n+    SKIP_IF_NOT_SHENANDOAH();\n+    _heap = ShenandoahHeap::heap();\n+    _heuristics = _heap->old_heuristics();\n+    _collection_set = _heap->collection_set();\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    ShenandoahResetRegions reset;\n+    _heap->heap_region_iterate(&reset);\n+    _heap->set_old_evac_reserve(_heap->old_generation()->soft_max_capacity() \/ 4);\n+    _heuristics->abandon_collection_candidates();\n+    _collection_set->clear();\n+  }\n+\n+  ShenandoahOldGeneration::State old_generation_state() {\n+    return _heap->old_generation()->state();\n+  }\n+\n+  size_t make_garbage(size_t region_idx, size_t garbage_bytes) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->make_regular_allocation(OLD_GENERATION);\n+    region->increase_live_data_alloc_words(1);\n+    region->set_top(region->bottom() + garbage_bytes \/ HeapWordSize);\n+    return region->garbage();\n+  }\n+\n+  size_t create_too_much_garbage_for_one_mixed_evacuation() {\n+    size_t garbage_target = _heap->old_generation()->soft_max_capacity() \/ 2;\n+    size_t garbage_total = 0;\n+    size_t region_idx = 0;\n+    while (garbage_total < garbage_target && region_idx < _heap->num_regions()) {\n+      garbage_total += make_garbage_above_threshold(region_idx++);\n+    }\n+    return garbage_total;\n+  }\n+\n+  void make_pinned(size_t region_idx) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->record_pin();\n+    region->make_pinned();\n+  }\n+\n+  void make_unpinned(size_t region_idx) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    ShenandoahHeapRegion* region = _heap->get_region(region_idx);\n+    region->record_unpin();\n+    region->make_unpinned();\n+  }\n+\n+  size_t make_garbage_below_threshold(size_t region_idx) {\n+    return make_garbage(region_idx, collection_threshold() - 100);\n+  }\n+\n+  size_t make_garbage_above_threshold(size_t region_idx) {\n+    return make_garbage(region_idx, collection_threshold() + 100);\n+  }\n+\n+  size_t collection_threshold() const {\n+    return ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold \/ 100;\n+  }\n+\n+  bool collection_set_is(size_t r1) { return _collection_set_is(1, r1); }\n+  bool collection_set_is(size_t r1, size_t r2) { return _collection_set_is(2, r1, r2); }\n+  bool collection_set_is(size_t r1, size_t r2, size_t r3) { return _collection_set_is(3, r1, r2, r3); }\n+\n+  bool _collection_set_is(size_t count, ...) {\n+    va_list args;\n+    va_start(args, count);\n+    EXPECT_EQ(count, _collection_set->count());\n+    bool result = true;\n+    for (size_t i = 0; i < count; ++i) {\n+      size_t index = va_arg(args, size_t);\n+      if (!_collection_set->is_in(index)) {\n+        result = false;\n+        break;\n+      }\n+    }\n+    va_end(args);\n+    return result;\n+  }\n+};\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_no_old_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(0U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(0U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_no_old_region_above_threshold) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ In this case, we have zero regions to add to the collection set,\n+  \/\/ but we will have one region that must still be made parseable.\n+  make_garbage_below_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(1U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(0U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, select_one_old_region_above_threshold) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  make_garbage_above_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  EXPECT_EQ(1U, _heuristics->last_old_region_index());\n+  EXPECT_EQ(1U, _heuristics->last_old_collection_candidate_index());\n+  EXPECT_EQ(1U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, prime_one_old_region) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t garbage = make_garbage_above_threshold(10);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(10UL));\n+  EXPECT_EQ(garbage, _collection_set->get_old_garbage());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, prime_many_old_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t g1 = make_garbage_above_threshold(100);\n+  size_t g2 = make_garbage_above_threshold(101);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(100UL, 101UL));\n+  EXPECT_EQ(g1 + g2, _collection_set->get_old_garbage());\n+  EXPECT_EQ(0U, _heuristics->unprocessed_old_collection_candidates());\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, require_multiple_mixed_evacuations) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t garbage = create_too_much_garbage_for_one_mixed_evacuation();\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_LT(_collection_set->get_old_garbage(), garbage);\n+  EXPECT_GT(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, skip_pinned_regions) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  \/\/ A region can be pinned when we chose collection set candidates.\n+  make_pinned(1);\n+  _heuristics->prepare_for_old_collections();\n+\n+  \/\/ We only exclude pinned regions when we actually add regions to the collection set.\n+  ASSERT_EQ(3UL, _heuristics->unprocessed_old_collection_candidates());\n+\n+  \/\/ Here the region is still pinned, so it cannot be added to the collection set.\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  \/\/ The two unpinned regions should be added to the collection set and the pinned\n+  \/\/ region should be retained at the front of the list of candidates as it would be\n+  \/\/ likely to become unpinned by the next mixed collection cycle.\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  \/\/ Simulate another mixed collection after making region 1 unpinned. This time,\n+  \/\/ the now unpinned region should be added to the collection set.\n+  make_unpinned(1);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g2);\n+  EXPECT_TRUE(collection_set_is(1UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, pinned_region_is_first) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  make_pinned(0);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(1UL, 2UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  make_unpinned(0);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL));\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, pinned_region_is_last) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL, 1UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g2);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 1UL);\n+\n+  make_unpinned(2);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, unpinned_region_is_middle) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  \/\/ Create three old regions with enough garbage to be collected.\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  make_pinned(0);\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(1UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g2);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 2UL);\n+\n+  make_unpinned(0);\n+  make_unpinned(2);\n+  _collection_set->clear();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n+  EXPECT_EQ(_collection_set->get_old_garbage(), g1 + g3);\n+  EXPECT_EQ(_heuristics->unprocessed_old_collection_candidates(), 0UL);\n+}\n+\n+TEST_VM_F(ShenandoahOldHeuristicTest, all_candidates_are_pinned) {\n+  SKIP_IF_NOT_SHENANDOAH();\n+\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n+\n+  make_pinned(0);\n+  make_pinned(1);\n+  make_pinned(2);\n+  _heuristics->prepare_for_old_collections();\n+  _heuristics->prime_collection_set(_collection_set);\n+\n+  \/\/ In the case when all candidates are pinned, we want to abandon\n+  \/\/ this set of mixed collection candidates so that another old collection\n+  \/\/ can run. This is meant to defend against \"bad\" JNI code that permanently\n+  \/\/ leaves an old region in the pinned state.\n+  EXPECT_EQ(_collection_set->count(), 0UL);\n+  EXPECT_EQ(old_generation_state(), ShenandoahOldGeneration::WAITING_FOR_FILL);\n+}\n+#undef SKIP_IF_NOT_SHENANDOAH\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -96,10 +96,0 @@\n-####\n-## JVMTI ForceEarlyReturn not supported for vthreads (JVMTI_ERROR_OPAQUE_FRAME)\n-## Note forceEarlyReturn002 was converted to support vthreads. The rest were not\n-## since there is no added value (JVMTI_ERROR_OPAQUE_FRAME is expected).\n-\n-vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002.java\n-vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn014\/forceEarlyReturn014.java 8285415 generic-all\n-vmTestbase\/nsk\/jdi\/stress\/serial\/forceEarlyReturn001\/TestDescription.java 8285415 generic-all\n-vmTestbase\/nsk\/jdi\/stress\/serial\/forceEarlyReturn002\/TestDescription.java 8285415 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java 8308930 generic-all\n+compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java 8309073 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1495,2 +1495,1 @@\n-  vmTestbase\/gc\/lock\/jvmti\/alloc\/jvmtialloclock01\/TestDescription.java \\\n-  vmTestbase\/gc\/lock\/malloc\/malloclock01\/TestDescription.java\n+  vmTestbase\/gc\/lock\/jvmti\/alloc\/jvmtialloclock01\/TestDescription.java\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +43,9 @@\n-    @Run(test = {\"testMax1\", \"testMax2\", \"testMax3\", \"testMin1\", \"testMin2\", \"testMin3\"})\n-    public void runMethod() {\n+    @Run(test = {\"testMax1LL\", \"testMax1LR\", \"testMax1RL\", \"testMax1RR\",\n+                 \"testMax1LLNoInnerAdd\", \"testMax1LLNoInnerAdd2\", \"testMax1LLNoOuterAdd\", \"testMax1LLNoAdd\",\n+                 \"testMax2L\", \"testMax2R\",\n+                 \"testMax2LNoLeftAdd\",\n+                 \"testMax3\",\n+                 \"testMin1\",\n+                 \"testMin2\",\n+                 \"testMin3\"})\n+    public void runPositiveTests() {\n@@ -48,4 +56,4 @@\n-        assertResult(a);\n-        assertResult(0);\n-        assertResult(min);\n-        assertResult(max);\n+        assertPositiveResult(a);\n+        assertPositiveResult(0);\n+        assertPositiveResult(min);\n+        assertPositiveResult(max);\n@@ -55,3 +63,12 @@\n-    public void assertResult(int a) {\n-        Asserts.assertEQ(Math.max(((a >> 1) + 100), Math.max(((a >> 1) + 150), 200)), testMax1(a));\n-        Asserts.assertEQ(Math.max(((a >> 1) + 10), ((a >> 1) + 11))                 , testMax2(a));\n+    public void assertPositiveResult(int a) {\n+        Asserts.assertEQ(Math.max(Math.max(((a >> 1) + 150), 200), ((a >> 1) + 100)), testMax1LL(a));\n+        Asserts.assertEQ(testMax1LL(a)                                              , testMax1LR(a));\n+        Asserts.assertEQ(testMax1LL(a)                                              , testMax1RL(a));\n+        Asserts.assertEQ(testMax1LL(a)                                              , testMax1RR(a));\n+        Asserts.assertEQ(Math.max(Math.max((a >> 1), 200), (a >> 1) + 100)          , testMax1LLNoInnerAdd(a));\n+        Asserts.assertEQ(Math.max(Math.max((a >> 1), (a << 1)), (a >> 1) + 100)     , testMax1LLNoInnerAdd2(a));\n+        Asserts.assertEQ(Math.max(Math.max(((a >> 1) + 150), 200), a >> 1)          , testMax1LLNoOuterAdd(a));\n+        Asserts.assertEQ(Math.max(Math.max((a >> 1), 200), a >> 1)                  , testMax1LLNoAdd(a));\n+        Asserts.assertEQ(Math.max(((a >> 1) + 10), ((a >> 1) + 11))                 , testMax2L(a));\n+        Asserts.assertEQ(testMax2L(a)                                               , testMax2R(a));\n+        Asserts.assertEQ(Math.max(a >> 1, ((a >> 1) + 11))                          , testMax2LNoLeftAdd(a));\n@@ -75,1 +92,17 @@\n-    public int testMax1(int i) {\n+    public int testMax1LL(int i) {\n+        return Math.max(Math.max(((i >> 1) + 150), 200), ((i >> 1) + 100));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1LR(int i) {\n+        return Math.max(Math.max(200, ((i >> 1) + 150)), ((i >> 1) + 100));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1RL(int i) {\n@@ -79,0 +112,39 @@\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1RR(int i) {\n+        return Math.max(((i >> 1) + 100), Math.max(200, ((i >> 1) + 150)));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1LLNoInnerAdd(int i) {\n+        return Math.max(Math.max((i >> 1), 200), (i >> 1) + 100);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1LLNoInnerAdd2(int i) {\n+        return Math.max(Math.max((i >> 1), (i << 1)), (i >> 1) + 100);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n+                  IRNode.ADD  , \"1\",\n+                 })\n+    public int testMax1LLNoOuterAdd(int i) {\n+        return Math.max(Math.max(((i >> 1) + 150), 200), i >> 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.MAX_I, \"1\"})\n+    public int testMax1LLNoAdd(int i) {\n+        return Math.max(Math.max((i >> 1), 200), i >> 1);\n+    }\n+\n@@ -94,1 +166,1 @@\n-    public int testMax2(int i) {\n+    public int testMax2L(int i) {\n@@ -98,0 +170,14 @@\n+    @Test\n+    @IR(failOn = {IRNode.MAX_I})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    public int testMax2R(int i) {\n+        return Math.max((i >> 1) + 11, (i >> 1) + 10);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX_I})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    public int testMax2LNoLeftAdd(int i) {\n+        return Math.max(i >> 1, (i >> 1) + 11);\n+    }\n+\n@@ -119,0 +205,72 @@\n+\n+    @Run(test = {\"testTwoLevelsDifferentXY\",\n+                 \"testTwoLevelsNoLeftConstant\",\n+                 \"testTwoLevelsNoRightConstant\",\n+                 \"testDifferentXY\",\n+                 \"testNoLeftConstant\",\n+                 \"testNoRightConstant\"})\n+    public void runNegativeTests() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertNegativeResult(a);\n+        assertNegativeResult(0);\n+        assertNegativeResult(min);\n+        assertNegativeResult(max);\n+\n+        testTwoLevelsDifferentXY(10);\n+        testTwoLevelsNoLeftConstant(10, 42);\n+        testTwoLevelsNoRightConstant(10, 42);\n+        testDifferentXY(10);\n+        testNoLeftConstant(10, 42);\n+        testNoRightConstant(10, 42);\n+    }\n+\n+    @DontCompile\n+    public void assertNegativeResult(int a) {\n+        Asserts.assertEQ(Math.max(Math.max(((a >> 1) + 150), 200), ((a >> 2) + 100)), testTwoLevelsDifferentXY(a));\n+        Asserts.assertEQ(Math.max(Math.max(((a >> 1) + a*2), 200), ((a >> 1) + 100)),  testTwoLevelsNoLeftConstant(a, a*2));\n+        Asserts.assertEQ(Math.max(Math.max(((a >> 1) + 150), 200), ((a >> 1) + a*2)),  testTwoLevelsNoRightConstant(a, a*2));\n+        Asserts.assertEQ(Math.max((a >> 1) + 10, (a >> 2) + 11), testDifferentXY(a));\n+        Asserts.assertEQ(Math.max((a >> 1) + a*2, (a >> 1) + 11), testNoLeftConstant(a, a*2));\n+        Asserts.assertEQ(Math.max((a >> 1) + 10, (a >> 1) + a*2), testNoRightConstant(a, a*2));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"2\"})\n+    public int testTwoLevelsDifferentXY(int i) {\n+        return Math.max(Math.max(((i >> 1) + 150), 200), ((i >> 2) + 100));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"2\"})\n+    public int testTwoLevelsNoLeftConstant(int i, int c0) {\n+        return Math.max(Math.max(((i >> 1) + c0), 200), ((i >> 1) + 100));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"2\"})\n+    public int testTwoLevelsNoRightConstant(int i, int c1) {\n+        return Math.max(Math.max(((i >> 1) + 150), 200), ((i >> 1) + c1));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\"})\n+    public int testDifferentXY(int i) {\n+        return Math.max((i >> 1) + 10, (i >> 2) + 11);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\"})\n+    public int testNoLeftConstant(int i, int c0) {\n+        return Math.max((i >> 1) + c0, (i >> 1) + 11);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_I, \"1\"})\n+    public int testNoRightConstant(int i, int c1) {\n+        return Math.max((i >> 1) + 10, (i >> 1) + c1);\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MaxMinINodeIdealizationTests.java","additions":169,"deletions":11,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns leading to Conv2B are correctly expanded.\n+ * @bug 8051725\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"x86_64\" | os.arch == \"amd64\" | os.arch == \"aarch64\"\n+ * @run driver compiler.c2.irTests.TestConv2BExpansion\n+ *\/\n+public class TestConv2BExpansion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testIntEquals0(int x) {\n+        return x == 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testIntNotEquals0(int x) {\n+        return x != 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testObjEqualsNull(Object o) {\n+        return o == null;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testObjNotEqualsNull(Object o) {\n+        return o != null;\n+    }\n+\n+    @Run(test = {\"testIntEquals0\", \"testIntNotEquals0\"})\n+    public void runTestInts() {\n+        assertResult(0);\n+        assertResult(1);\n+    }\n+\n+    @Run(test = {\"testObjEqualsNull\", \"testObjNotEqualsNull\"})\n+    public void runTestObjs() {\n+        assertResult(new Object());\n+        assertResult(null);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x) {\n+        Asserts.assertEQ(x == 0, testIntEquals0(x));\n+        Asserts.assertEQ(x != 0, testIntNotEquals0(x));\n+    }\n+\n+    @DontCompile\n+    public void assertResult(Object o) {\n+        Asserts.assertEQ(o == null, testObjEqualsNull(o));\n+        Asserts.assertEQ(o != null, testObjNotEqualsNull(o));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -593,0 +594,26 @@\n+    \/\/ Use some constants in the comparison\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < b.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ A case that is currently not supported and is not expected to vectorize\n@@ -726,1 +753,3 @@\n-                 \"testCMoveDGTforD\"})\n+                 \"testCMoveDGTforD\",\n+                 \"testCMoveFGTforFCmpCon1\",\n+                 \"testCMoveFGTforFCmpCon2\"})\n@@ -845,0 +874,11 @@\n+\n+        \/\/ Use some constants\/invariants in the comparison\n+        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,8 @@\n+        if (args.length != 0) {\n+            \/\/ Called as subprocess. Print system properties named by\n+            \/\/ `args` and then exit.\n+            for (String arg : args) {\n+                System.out.printf(\"%s=%s%n\", arg, System.getProperty(arg));\n+            }\n+            return;\n+        }\n@@ -70,1 +78,1 @@\n-            new Expectation(\"EnableJVMCIProduct\", \"true\", \"command line\"),\n+            new Expectation(\"EnableJVMCIProduct\", \"true\", \"(?:command line|jimage)\"),\n@@ -76,12 +84,24 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+EnableJVMCIProduct\", \"-XX:-UnlockExperimentalVMOptions\",\n-            explicitFlag,\n-            \"-XX:+PrintFlagsFinal\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        for (Expectation expectation : expectations) {\n-            output.stdoutShouldMatch(expectation.pattern);\n-        }\n-        if (output.getExitValue() != 0) {\n-            \/\/ This should only happen when JVMCI compilation is requested and the VM has no\n-            \/\/ JVMCI compiler (e.g. Graal is not included in the build)\n-            output.stdoutShouldMatch(\"No JVMCI compiler found\");\n+        String[] flags = {\"-XX:+EnableJVMCIProduct\", \"-XX:+UseGraalJIT\"};\n+        String cwd = System.getProperty(\"user.dir\");\n+        for (String flag : flags) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+UnlockExperimentalVMOptions\", flag, \"-XX:-UnlockExperimentalVMOptions\",\n+                explicitFlag,\n+                \"-XX:+PrintFlagsFinal\",\n+                \"--class-path=\" + System.getProperty(\"java.class.path\"),\n+                \"TestEnableJVMCIProduct\", \"jvmci.Compiler\");\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            for (Expectation expectation : expectations) {\n+                output.stdoutShouldMatch(expectation.pattern);\n+            }\n+            if (output.getExitValue() != 0) {\n+                \/\/ This should only happen when JVMCI compilation is requested and the VM has no\n+                \/\/ JVMCI compiler (e.g. Graal is not included in the build)\n+                if (flag.equals(\"-XX:+UseGraalJIT\")) {\n+                    output.shouldContain(\"JVMCI compiler 'graal' specified by jvmci.Compiler not found\");\n+                } else {\n+                    output.stdoutShouldMatch(\"No JVMCI compiler found\");\n+                }\n+            } else if (flag.equals(\"-XX:+UseGraalJIT\")) {\n+                output.shouldContain(\"jvmci.Compiler=graal\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestEnableJVMCIProduct.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import java.io.IOException;\n@@ -54,0 +53,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -58,4 +58,1 @@\n-    \/**\n-     * Name of file whose existence implies that a JVMCICompiler has been created.\n-     *\/\n-    static String tmpFileName = \"ErrorCompilerCreated.\" + System.nanoTime();\n+    static volatile boolean compilerCreationErrorOccurred;\n@@ -71,1 +68,0 @@\n-            File watch = new File(tmpFileName);\n@@ -73,5 +69,2 @@\n-            long start = System.currentTimeMillis();\n-\n-            \/\/ Use a 10 sec timeout to prevent endless loop if\n-            \/\/ JVMCI compiler creation fails\n-            while (System.currentTimeMillis() - start < 10_000) {\n+            while (!compilerCreationErrorOccurred) {\n+                \/\/ Do some random work to trigger compilation\n@@ -79,5 +72,1 @@\n-                if (watch.exists()) {\n-                    System.err.println(\"saw \" + watch + \" - exiting loop\");\n-                    watch.delete();\n-                    break;\n-                }\n+                total += String.valueOf(total).hashCode();\n@@ -104,1 +93,10 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        Process p = pb.start();\n+        OutputAnalyzer output = new OutputAnalyzer(p);\n+\n+        if (!waitForProcess(p)) {\n+            \/\/ The subprocess might not enter JVMCI compilation.\n+            \/\/ Print the subprocess output and pass the test in this case.\n+            System.out.println(output.getOutput());\n+            return;\n+        }\n+\n@@ -140,0 +138,25 @@\n+    \/**\n+     * @return true if {@code p} exited on its own, false if it had to be destroyed\n+     *\/\n+    private static boolean waitForProcess(Process p) {\n+        while (true) {\n+            try {\n+                boolean exited = p.waitFor(10, TimeUnit.SECONDS);\n+                if (!exited) {\n+                    System.out.println(\"destroying process: \" + p);\n+                    p.destroy();\n+                    Thread.sleep(1000);\n+                    while (p.isAlive()) {\n+                        System.out.println(\"forcibly destroying process: \" + p);\n+                        Thread.sleep(1000);\n+                        p.destroyForcibly();\n+                    }\n+                    return false;\n+                }\n+                return true;\n+            } catch (InterruptedException e) {\n+                e.printStackTrace(System.out);\n+            }\n+        }\n+    }\n+\n@@ -164,3 +187,2 @@\n-                    if (attempt == 10) {\n-                        \/\/ Delay the creation of the file that causes the\n-                        \/\/ loop in main to exit so that compilation failures\n+                    if (attempt >= 10) {\n+                        \/\/ Delay notifying the loop in main so that compilation failures\n@@ -168,8 +190,1 @@\n-                        File watch = new File(tmpFileName);\n-                        try {\n-                            System.err.println(\"creating \" + watch);\n-                            watch.createNewFile();\n-                            System.err.println(\"created \" + watch);\n-                        } catch (IOException ex) {\n-                            ex.printStackTrace();\n-                        }\n+                        compilerCreationErrorOccurred = true;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java","additions":43,"deletions":28,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -797,0 +797,10 @@\n+    public static final String MIN_REDUCTION_V = PREFIX + \"MIN_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(MIN_REDUCTION_V, \"MinReductionV\");\n+    }\n+\n+    public static final String MAX_REDUCTION_V = PREFIX + \"MAX_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(MAX_REDUCTION_V, \"MaxReductionV\");\n+    }\n+\n@@ -1466,0 +1476,5 @@\n+    public static final String VSTOREMASK_TRUECOUNT = PREFIX + \"VSTOREMASK_TRUECOUNT\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VSTOREMASK_TRUECOUNT, \"vstoremask_truecount_neon\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8302673\n+ * @summary [SuperWord] MaxReduction and MinReduction should vectorize for int\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.MinMaxRed_Int\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class MinMaxRed_Int {\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"maxReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMaxTest() {\n+        int[] a = new int[1024];\n+        int[] b = new int[1024];\n+        ReductionInit(a, b);\n+        int res = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            res = maxReductionImplement(a, b, res);\n+        }\n+        if (res == Arrays.stream(a).max().getAsInt()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    @Run(test = {\"minReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMinTest() {\n+        int[] a = new int[1024];\n+        int[] b = new int[1024];\n+        ReductionInit(a, b);\n+        int res = 1;\n+        for (int j = 0; j < 2000; j++) {\n+            res = minReductionImplement(a, b, res);\n+        }\n+        if (res == Arrays.stream(a).min().getAsInt()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    public static void ReductionInit(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextInt();\n+            b[i] = 1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = {IRNode.MIN_REDUCTION_V, \" > 0\"})\n+    public static int minReductionImplement(int[] a, int[] b, int res) {\n+        for (int i = 0; i < a.length; i++) {\n+            res = Math.min(res, a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = {IRNode.MAX_REDUCTION_V, \" > 0\"})\n+    public static int maxReductionImplement(int[] a, int[] b, int res) {\n+        for (int i = 0; i < a.length; i++) {\n+            res = Math.max(res, a[i] * b[i]);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Int.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -85,2 +85,0 @@\n-    \/* Vectorization is expected but not enabled (SuperWord::implemented).\n-       A positive @IR test should be added later. *\/\n@@ -90,0 +88,3 @@\n+    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        applyIfCPUFeature = {\"sse2\", \"true\"},\n+        counts = {IRNode.MUL_REDUCTION_VD, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8309268\n+ * @summary Test loop invariant input to Cmp.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestCmpInvar::test*\n+ *      compiler.loopopts.superword.TestCmpInvar\n+ *\/\n+package compiler.loopopts.superword;\n+\n+public class TestCmpInvar {\n+    static int N = 400;\n+    static long myInvar;\n+\n+    static void test1(int limit, float fcon) {\n+        boolean a[] = new boolean[1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = fcon > i;\n+        }\n+    }\n+\n+    static void test2(int limit, float fcon) {\n+        boolean a[] = new boolean[1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i > fcon;\n+        }\n+    }\n+\n+    static int test3() {\n+        int[] a = new int[N];\n+        int acc = 0;\n+        for (int i = 1; i < 63; i++) {\n+            acc += Math.min(myInvar, a[i]--);\n+        }\n+        return acc;\n+    }\n+\n+    static int test4() {\n+        int[] a = new int[N];\n+        int acc = 0;\n+        for (int i = 1; i < 63; i++) {\n+            acc += Math.min(a[i]--, myInvar);\n+        }\n+        return acc;\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10_100; i++) {\n+            test1(500, 80.1f);\n+        }\n+\n+        for (int i = 0; i < 10_100; i++) {\n+            test2(500, 80.1f);\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test3();\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test4();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCmpInvar.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n+ *                   compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n+ *                   -XX:LoopMaxUnroll=0 compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestHoistedPredicateForNonRangeCheck calendar\n+ *\/\n+\n+package compiler.predicates;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+\n+public class TestHoistedPredicateForNonRangeCheck {\n+    static int iFld, iFld2;\n+    static int[] iArr = new int[100];\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            Integer.compareUnsigned(34, 34); \/\/ Ensure Integer class is loaded and we do not emit a trap inside test() for it.\n+\n+            for (int i = 0; i < 2; i++) {\n+                iFld = 0;\n+                iFld2 = 0;\n+                test();\n+                Asserts.assertEQ(iFld, 3604, \"wrong value\");\n+                Asserts.assertEQ(iFld2, 400, \"wrong value\");\n+            }\n+\n+            for (int i = 0; i < 2000; i++) {\n+                iFld = -100;\n+                testRangeCheckNode();\n+            }\n+            iFld = -1;\n+            iFld2 = 0;\n+            testRangeCheckNode();\n+            Asserts.assertEQ(iFld2, 36, \"wrong value\");\n+        } else {\n+            boolean flag = false;\n+            for (int i = 0; i < 10000; i++) {\n+                testCalendar1();\n+                testCalendar2(flag);\n+            }\n+        }\n+    }\n+\n+    public static void test() {\n+        for (int i = -1; i < 1000; i++) {\n+            \/\/ We hoist this check and insert a Hoisted Predicate for the lower and upper bound:\n+            \/\/ -1 >=u 100 && 1000 >= u 100 -> always true and the predicates are removed.\n+            \/\/ Template Assertion Predicates, however, are kept. When splitting this loop further, we insert an Assertion\n+            \/\/ Predicate which fails for i = 0 and we halt.\n+            \/\/ When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due to never executing\n+            \/\/ iFld2++ (we remove the check and the branch with the trap when creating the Hoisted Predicates).\n+            if (Integer.compareUnsigned(i, 100) < 0) {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            } else {\n+                iFld++;\n+            }\n+\n+            \/\/ Same but flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, 100) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode and flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+        }\n+    }\n+\n+    static void testRangeCheckNode() {\n+        int array[] = new int[34];\n+        \/\/ Hoisted Range Check Predicate with flipped bool because trap is on success proj and no trap on false proj due\n+        \/\/ to catching exception:\n+        \/\/ iFld >=u 34 && iFld+36 >=u 34\n+        \/\/ This is always false for first 2000 iterations where, initially, iFld = -100\n+        \/\/ It is still true in the last iteration where, initially, iFld = -1. But suddenly, in the second iteration,\n+        \/\/ where iFld = 0, we would take the true projection for the first time - but we removed that branch when\n+        \/\/ creating the Hoisted Range Check Predicate. We therefore run into the same problem as with test(): We either\n+        \/\/ halt due to Assertion Predicates catching this case or we have a wrong execution (iFld2 never updated).\n+        for (int i = 0; i < 37; i++) {\n+            try {\n+                array[iFld] = 34; \/\/ Normal RangeCheckNode\n+                iFld2++;\n+                Math.ceil(34); \/\/ Never taken and unloaded -> trap\n+            } catch (Exception e) {\n+                \/\/ False Proj of RangeCheckNode\n+                iFld++;\n+            }\n+        }\n+    }\n+\n+    \/\/ Reported in JDK-8307683\n+    static void testCalendar1() {\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.set(Calendar.HOUR_OF_DAY, 0);\n+        c.set(Calendar.MINUTE, 0);\n+        c.getTime();\n+    }\n+\n+    \/\/ Reported in JDK-8307978\n+    static void testCalendar2(boolean flag) {\n+        flag = !flag;\n+        Calendar timespan = removeTime(new Date(), flag);\n+        timespan.getTime();\n+    }\n+\n+    static Calendar removeTime(Date date, boolean flag) {\n+        Calendar calendar = Calendar.getInstance();\n+        if (flag) {\n+            calendar.setLenient(false);\n+        }\n+        calendar.setTime(date);\n+        calendar = removeTime(calendar);\n+        return calendar;\n+    }\n+\n+    static Calendar removeTime(Calendar calendar) {\n+        calendar.set(Calendar.HOUR_OF_DAY, 0);\n+        calendar.set(Calendar.MINUTE, 0);\n+        calendar.set(Calendar.SECOND, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        return calendar;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308892\n+ * @summary Test that Parse Predicates immediately following other Parse Predicates\n+            are cleaned up properly.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestWrongPredicateOrder\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestWrongPredicateOrder {\n+    static boolean flag;\n+    static int iFld = 0;\n+    static int iFld2 = 34;\n+    static int iArr[] = new int[1005];\n+    static int iArr2[] = new int[2];\n+\n+\n+    public static void main(String[] strArr) {\n+        \/\/ We will keep hitting the Profiled Loop Predicate for RC1 (Integer.MAX_VALUE - 1 - 3 > 1005) such that we will\n+        \/\/ not emit the Profile Loop Parse Predicate anymore. After that, we will also keep hitting the Loop Limit Check\n+        \/\/ Predicate (Interger.MAX_VALUE - 1 > Integer.MAX_VALUE - 2) such that we will also not emit the Loop Limit Check\n+        \/\/ Parse Predicate anymore. As a result, we'll only emit the Loop Parse Predicate in the next re-compilation.\n+        \/\/ In the next re-compilation, we'll hoist IC1 as Loop Predicate and IC2 as Profiled Loop Predicate.\n+        \/\/ They have a data dependency between them but this is normally okay because Profiled Loop Predicates are below\n+        \/\/ Loop Predicates in the graph. But due to the flipped order of Parse Predicates in this bug, we create the\n+        \/\/ Hoisted Predicates in the wrong order and we end up with a bad graph and assert.\n+        for (int i = 0; i < 10000; i++) {\n+            flag = !flag;\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        \/\/ Ensure to emit Loop Limit Check Predicate which is hit too often\n+        \/\/ -> no Loop Limit Check Parse Predicate is added in re-compilation anymore\n+        int limit = flag ? Integer.MAX_VALUE - 1 : 1000;\n+\n+        int i = 0;\n+        \/\/ Loop Limit Check Predicate: limit <= Integer.MAX_VALUE - stride + 1 = Integer.MAX_VALUE - 2\n+        while (i < limit) {\n+            i += 3;\n+            \/\/ Invariant check hoisted as Loop Predicate\n+            iArr2[iFld] = 1; \/\/ (IC1)\n+\n+            if (flag) {\n+                \/\/ Early exit -> enables Profiled Loop Predicate creation below\n+                return;\n+            }\n+\n+            \/\/ Invariant check hoisted as Profiled Loop Predicate\n+            \/\/ Data dependency on Loop Predicate for \"iArr2[0] = 1\"\n+            iArr2[1] = 5; \/\/ (IC2)\n+\n+            \/\/ Profiled Loop Predicate for range check hit too much -> no Profiled Loop Parse Predicate is added in\n+            \/\/ re-compilation anymore\n+            iArr[i] = 34; \/\/ (RC1)\n+\n+            if (iFld2 == 5555) {\n+                i++; \/\/ UCT -> ensures to emit Parse Predicates twice with an If in between that is folded after parsing\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestWrongPredicateOrder.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,1 @@\n-        testMismatched(c, setDefaultAction, false);\n+        testMismatched(c, setDefaultAction, false, true);\n@@ -230,3 +230,3 @@\n-    static void testMismatched(Callable<?> c, Runnable setDefaultAction, boolean objectArray) throws Exception {\n-        if (Compiler.isGraalEnabled() && !objectArray) {\n-            \/\/ Graal will constant fold mismatched reads from primitive stable arrays\n+    static void testMismatched(Callable<?> c, Runnable setDefaultAction, boolean objectArray, boolean aligned) throws Exception {\n+        if (Compiler.isGraalEnabled() && !objectArray && aligned) {\n+            \/\/ Graal will constant fold mismatched reads from primitive stable arrays, except unaligned ones\n@@ -322,2 +322,2 @@\n-        testMismatched(Test::testL_J, Test::changeL, true); \/\/ long & double are always as large as an OOP\n-        testMismatched(Test::testL_D, Test::changeL, true);\n+        testMismatched(Test::testL_J, Test::changeL, true, true); \/\/ long & double are always as large as an OOP\n+        testMismatched(Test::testL_D, Test::changeL, true, true);\n@@ -327,4 +327,4 @@\n-        testMismatched(Test::testS_U, Test::changeS);\n-        testMismatched(Test::testC_U, Test::changeC);\n-        testMismatched(Test::testI_U, Test::changeI);\n-        testMismatched(Test::testJ_U, Test::changeJ);\n+        testMismatched(Test::testS_U, Test::changeS, false, false);\n+        testMismatched(Test::testC_U, Test::changeC, false, false);\n+        testMismatched(Test::testI_U, Test::changeI, false, false);\n+        testMismatched(Test::testJ_U, Test::changeJ, true, false);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeGetStableArrayElement.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8307795\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires os.arch==\"aarch64\"\n+ * @summary AArch64: Optimize VectorMask.truecount() on Neon\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.TestVectorMaskTrueCount\n+ *\/\n+\n+public class TestVectorMaskTrueCount {\n+    private static final VectorSpecies<Float> SPECIES_F = FloatVector.SPECIES_64;\n+    private static final VectorSpecies<Double> SPECIES_D = DoubleVector.SPECIES_128;\n+    private static final VectorSpecies<Integer> SPECIES_I = IntVector.SPECIES_128;\n+    private static final int LENGTH = 1024;\n+    private static final Random RD = new Random();\n+    private static boolean[] ba;\n+    private static boolean[] bb;\n+\n+    static {\n+        ba = new boolean[LENGTH];\n+        bb = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = RD.nextBoolean();\n+            bb[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    static int maskAndTrueCount(boolean[] a, boolean[] b, int idx, int count) {\n+        int trueCount = 0;\n+        boolean[] c = new boolean[count];\n+\n+        for (int i = idx; i < idx + count; i++) {\n+            c[i - idx] = a[i] & b[i];\n+        }\n+\n+        for (int i = 0; i < c.length; i++) {\n+            trueCount += c[i] ? 1 : 0;\n+        }\n+\n+        return trueCount;\n+    }\n+\n+    static void assertArrayEqualsFloat(int[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < a.length; i += SPECIES_F.length()) {\n+            Asserts.assertEquals(r[i], maskAndTrueCount(a, b, i, SPECIES_F.length()));\n+        }\n+    }\n+\n+    static void assertArrayEqualsDouble(int[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < a.length; i += SPECIES_D.length()) {\n+            Asserts.assertEquals(r[i], maskAndTrueCount(a, b, i, SPECIES_D.length()));\n+        }\n+    }\n+\n+    static void assertArrayEqualsInteger(int[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < a.length; i += SPECIES_I.length()) {\n+            Asserts.assertEquals(r[i], maskAndTrueCount(a, b, i, SPECIES_I.length()));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VSTOREMASK_TRUECOUNT, \">= 1\" })\n+    public static void testFloat() {\n+        int[] r = new int[LENGTH];\n+        for (int i = 0; i < LENGTH; i += SPECIES_F.length()) {\n+            VectorMask<Float> ma = VectorMask.fromArray(SPECIES_F, ba, i);\n+            VectorMask<Float> mb = VectorMask.fromArray(SPECIES_F, bb, i);\n+            r[i] = ma.and(mb).trueCount();\n+        }\n+\n+        assertArrayEqualsFloat(r, ba, bb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VSTOREMASK_TRUECOUNT, \">= 1\" })\n+    public static void testDouble() {\n+        int[] r = new int[LENGTH];\n+        for (int i = 0; i < LENGTH; i += SPECIES_D.length()) {\n+            VectorMask<Double> ma = VectorMask.fromArray(SPECIES_D, ba, i);\n+            VectorMask<Double> mb = VectorMask.fromArray(SPECIES_D, bb, i);\n+            r[i] = ma.and(mb).trueCount();\n+        }\n+\n+        assertArrayEqualsDouble(r, ba, bb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VSTOREMASK_TRUECOUNT, \">= 1\" })\n+    public static void testInt() {\n+        int[] r = new int[LENGTH];\n+        for (int i = 0; i < LENGTH; i += SPECIES_I.length()) {\n+            VectorMask<Integer> ma = VectorMask.fromArray(SPECIES_I, ba, i);\n+            VectorMask<Integer> mb = VectorMask.fromArray(SPECIES_I, bb, i);\n+            r[i] = ma.and(mb).trueCount();\n+        }\n+\n+        assertArrayEqualsInteger(r, ba, bb);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .addFlags(\"-XX:UseSVE=0\")\n+                     .start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMaskTrueCount.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/\/ Check dynamic limits updating. HotSpot side.\n+public class LimitUpdateChecker {\n+\n+    private static final File UPDATE_FILE = new File(\"\/tmp\", \"limitsUpdated\");\n+    private static final File STARTED_FILE = new File(\"\/tmp\", \"started\");\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"LimitUpdateChecker: Entering\");\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        printMetrics(wb); \/\/ print initial limits\n+        createStartedFile();\n+        while (!UPDATE_FILE.exists()) {\n+            Thread.sleep(200);\n+        }\n+        System.out.println(\"'limitsUpdated' file appeared. Stopped loop.\");\n+        printMetrics(wb); \/\/ print limits after update\n+        System.out.println(\"LimitUpdateChecker DONE.\");\n+\n+    }\n+\n+    private static void printMetrics(WhiteBox wb) {\n+        wb.printOsInfo();\n+    }\n+\n+    private static void createStartedFile() throws Exception {\n+        FileOutputStream fout = new FileOutputStream(STARTED_FILE);\n+        fout.close();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/LimitUpdateChecker.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8308090\n+ * @key cgroups\n+ * @summary Test container limits updating as they get updated at runtime without restart\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox LimitUpdateChecker\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run driver TestLimitsUpdating\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestLimitsUpdating {\n+    private static final String TARGET_CONTAINER = \"limitsUpdatingHS_\" + Runtime.getRuntime().version().major();\n+    private static final String imageName = Common.imageName(\"limitsUpdating\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        Common.prepareWhiteBox();\n+        DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+        try {\n+            testLimitUpdates();\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void testLimitUpdates() throws Exception {\n+        File sharedtmpdir = new File(\"test-sharedtmp\");\n+        File flag = new File(sharedtmpdir, \"limitsUpdated\"); \/\/ shared with LimitUpdateChecker\n+        File started = new File(sharedtmpdir, \"started\"); \/\/ shared with LimitUpdateChecker\n+        sharedtmpdir.mkdir();\n+        flag.delete();\n+        started.delete();\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"LimitUpdateChecker\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addDockerOpts(\"--volume\", sharedtmpdir.getAbsolutePath() + \":\/tmp\");\n+        opts.addDockerOpts(\"--cpu-period\", \"100000\");\n+        opts.addDockerOpts(\"--cpu-quota\", \"200000\");\n+        opts.addDockerOpts(\"--memory\", \"500m\");\n+        opts.addDockerOpts(\"--memory-swap\", \"500m\");\n+        opts.addDockerOpts(\"--name\", TARGET_CONTAINER);\n+        opts.addJavaOpts(\"-cp\", \"\/test-classes\/\");\n+        Common.addWhiteBoxOpts(opts);\n+        final OutputAnalyzer out[] = new OutputAnalyzer[1];\n+        Thread t1 = new Thread() {\n+                public void run() {\n+                    try {\n+                        out[0] = DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            };\n+        t1.start();\n+\n+       \/\/ Wait for target container (that we later update) to complete its\n+       \/\/ initial starting-up phase. Prints initial container limits.\n+        while (!started.exists()) {\n+            System.out.println(\"Wait for target container to start\");\n+            Thread.sleep(100);\n+        }\n+\n+        final List<String> containerCommand = getContainerUpdate(300_000, 100_000, \"300m\");\n+        \/\/ Run the update command so as to increase resources once the container signaled it has started.\n+        Thread t2 = new Thread() {\n+                public void run() {\n+                    try {\n+                        DockerTestUtils.execute(containerCommand).shouldHaveExitValue(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            };\n+        t2.start();\n+        t2.join();\n+\n+        \/\/ Set the flag for the to-get updated container, indicating the update\n+        \/\/ has completed.\n+        FileOutputStream fout = new FileOutputStream(flag);\n+        fout.close();\n+\n+        t1.join();\n+\n+        \/\/ Do assertions based on the output in target container\n+        OutputAnalyzer targetOut = out[0];\n+        targetOut.shouldContain(\"active_processor_count: 2\"); \/\/ initial value\n+        targetOut.shouldContain(\"active_processor_count: 3\"); \/\/ updated value\n+        targetOut.shouldContain(\"memory_limit_in_bytes: 512000 k\"); \/\/ initial value\n+        targetOut.shouldContain(\"memory_and_swap_limit_in_bytes: 512000 k\"); \/\/ initial value\n+        targetOut.shouldContain(\"memory_limit_in_bytes: 307200 k\"); \/\/ updated value\n+        targetOut.shouldContain(\"memory_and_swap_limit_in_bytes: 307200 k\"); \/\/ updated value\n+    }\n+\n+    private static List<String> getContainerUpdate(int cpuQuota, int cpuPeriod, String memory) {\n+        List<String> cmd = DockerTestUtils.buildContainerCommand();\n+        cmd.add(\"update\");\n+        cmd.add(\"--cpu-period=\" + cpuPeriod);\n+        cmd.add(\"--cpu-quota=\" + cpuQuota);\n+        cmd.add(\"--memory=\" + memory);\n+        cmd.add(\"--memory-swap=\" + memory); \/\/ no swap\n+        cmd.add(TARGET_CONTAINER);\n+        return cmd;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestLimitsUpdating.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -97,0 +98,17 @@\n+*\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocHumongousFragment\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocHumongousFragment\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -100,0 +101,9 @@\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocIntArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocIntArrays\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -102,0 +103,29 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n+ *\/\n+\n@@ -137,0 +167,5 @@\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestAllocObjectArrays\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -107,0 +108,20 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestAllocObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestAllocObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahSuspendibleWorkers\n+ *      TestAllocObjects\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -31,0 +32,7 @@\n+\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:TieredStopAtLevel=0 -Xmx16m TestArrayCopyCheckCast -XX:ShenandoahGCMode=generational\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyCheckCast.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,1 +30,1 @@\n- * @test\n+ * @test id=default\n@@ -36,0 +37,9 @@\n+\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=0 -Xmx16m TestArrayCopyStress\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyStress.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -65,0 +66,11 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestDynamicSoftMaxHeapSize\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -42,0 +43,17 @@\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @summary Test that Shenandoah is able to work with elastic TLABs\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:-UseTLAB -XX:-ShenandoahElasticTLAB -XX:+ShenandoahVerify TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:-UseTLAB -XX:-ShenandoahElasticTLAB                       TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:-UseTLAB -XX:+ShenandoahElasticTLAB -XX:+ShenandoahVerify TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:-UseTLAB -XX:+ShenandoahElasticTLAB                       TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:+UseTLAB -XX:-ShenandoahElasticTLAB -XX:+ShenandoahVerify TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:+UseTLAB -XX:-ShenandoahElasticTLAB                       TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:+UseTLAB -XX:+ShenandoahElasticTLAB -XX:+ShenandoahVerify TestElasticTLAB\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -XX:+UseTLAB -XX:+ShenandoahElasticTLAB                       TestElasticTLAB\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestElasticTLAB.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -32,1 +33,11 @@\n- * @run driver\/timeout=480 TestEvilSyncBug\n+ * @run driver\/timeout=480 TestEvilSyncBug -XX:ShenandoahGCHeuristics=aggressive\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @summary Tests for crash\/assert when attaching init thread during shutdown\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver\/timeout=480 TestEvilSyncBug -XX:ShenandoahGCMode=generational\n@@ -49,1 +60,1 @@\n-        if (args.length > 0) {\n+        if (\"test\".equals(args[0])) {\n@@ -52,0 +63,1 @@\n+            String options = args[0];\n@@ -64,1 +76,1 @@\n-                            \"-XX:ShenandoahGCHeuristics=aggressive\",\n+                            options,\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestEvilSyncBug.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -79,0 +80,18 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test Shenandoah GC uses concurrent\/parallel threads correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:ConcGCThreads=2 -XX:ParallelGCThreads=4\n+ *      -Dtarget=1000 -XX:ShenandoahGCMode=generational\n+ *      TestGCThreadGroups\n+ *\n+ * @run main\/othervm -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC\n+ *      -XX:-UseDynamicNumberOfGCThreads\n+ *      -Dtarget=1000 -XX:ShenandoahGCMode=generational\n+ *      TestGCThreadGroups\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestGCThreadGroups.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -87,0 +88,22 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can withstand allocation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestHeapUncommit\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestHeapUncommit\n+ *\n+ * @run main\/othervm -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahUncommit -XX:ShenandoahUncommitDelay=0\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestHeapUncommit\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHeapUncommit.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -111,0 +112,79 @@\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:+ShenandoahVerify\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n+ *                   TestHumongousThreshold\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n+ *                   TestHumongousThreshold\n+ *\/\n+\n+\/*\n+ * @test id=generational-16b\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n+ *                   TestHumongousThreshold\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n+ *                   TestHumongousThreshold\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n+ *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n+ *                   TestHumongousThreshold\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -75,0 +76,12 @@\n+\/*\n+ * @test id=generational\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/com.sun.tools.attach\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestJcmdHeapDump\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestJcmdHeapDump.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test default\n@@ -37,0 +38,14 @@\n+ *\/\n+\n+\/*\n+ * @test generational\n+ * @summary Shenandoah crashes with -XX:ObjectAlignmentInBytes=16\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -Xint                   TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:-TieredCompilation  TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:TieredStopAtLevel=1 TestLargeObjectAlignment\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ObjectAlignmentInBytes=16 -XX:TieredStopAtLevel=4 TestLargeObjectAlignment\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLargeObjectAlignment.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -74,0 +75,10 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/timeout=480 -Xmx16m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -Dtarget=10000\n+ *      TestLotsOfCycles\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLotsOfCycles.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -59,3 +60,4 @@\n-             {{\"satb\"},    {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n-             {{\"iu\"},      {\"adaptive\", \"aggressive\"}},\n-             {{\"passive\"}, {\"passive\"}}\n+             {{\"satb\"},         {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n+             {{\"generational\"}, {\"adaptive\"}},\n+             {{\"iu\"},           {\"adaptive\", \"aggressive\"}},\n+             {{\"passive\"},      {\"passive\"}}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestObjItrWithHeapDump.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that reference processing works with both parallel and non-parallel variants.\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g                              TestParallelRefprocSanity\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g  -XX:-ParallelRefProcEnabled TestParallelRefprocSanity\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g -Xms1g  -XX:+ParallelRefProcEnabled TestParallelRefprocSanity\n- *\/\n-\n-import java.lang.ref.*;\n-\n-public class TestParallelRefprocSanity {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 32;\n-        for (long c = 0; c < count; c++) {\n-            sink = new WeakReference<Object>(new Object());\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestParallelRefprocSanity.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -49,1 +50,1 @@\n-        if (periodic && !output.getOutput().contains(\"Trigger: Time since last GC\")) {\n+        if (periodic && !output.getOutput().contains(\"Trigger (GLOBAL): Time since last GC\")) {\n@@ -52,1 +53,1 @@\n-        if (!periodic && output.getOutput().contains(\"Trigger: Time since last GC\")) {\n+        if (!periodic && output.getOutput().contains(\"Trigger (GLOBAL): Time since last GC\")) {\n@@ -57,0 +58,25 @@\n+    public static void testGenerational(boolean periodic, String... args) throws Exception {\n+        String[] cmds = Arrays.copyOf(args, args.length + 2);\n+        cmds[args.length] = TestPeriodicGC.class.getName();\n+        cmds[args.length + 1] = \"test\";\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmds);\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        if (periodic) {\n+            if (!output.getOutput().contains(\"Trigger (YOUNG): Time since last GC\")) {\n+                throw new AssertionError(\"Generational mode: Should have periodic young GC in logs\");\n+            }\n+            if (!output.getOutput().contains(\"Trigger (OLD): Time since last GC\")) {\n+                throw new AssertionError(\"Generational mode: Should have periodic old GC in logs\");\n+            }\n+        } else {\n+            if (output.getOutput().contains(\"Trigger (YOUNG): Time since last GC\")) {\n+                throw new AssertionError(\"Generational mode: Should not have periodic young GC in logs\");\n+            }\n+            if (output.getOutput().contains(\"Trigger (OLD): Time since last GC\")) {\n+                throw new AssertionError(\"Generational mode: Should not have periodic old GC in logs\");\n+            }\n+        }\n+    }\n+\n@@ -160,0 +186,20 @@\n+\n+        testGenerational(true,\n+                         \"-Xlog:gc\",\n+                         \"-XX:+UnlockDiagnosticVMOptions\",\n+                         \"-XX:+UnlockExperimentalVMOptions\",\n+                         \"-XX:+UseShenandoahGC\",\n+                         \"-XX:ShenandoahGCMode=generational\",\n+                         \"-XX:ShenandoahGuaranteedYoungGCInterval=1000\",\n+                         \"-XX:ShenandoahGuaranteedOldGCInterval=1500\"\n+        );\n+\n+        testGenerational(false,\n+                         \"-Xlog:gc\",\n+                         \"-XX:+UnlockDiagnosticVMOptions\",\n+                         \"-XX:+UnlockExperimentalVMOptions\",\n+                         \"-XX:+UseShenandoahGC\",\n+                         \"-XX:ShenandoahGCMode=generational\",\n+                         \"-XX:ShenandoahGuaranteedYoungGCInterval=0\",\n+                         \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+        );\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,14 @@\n-\/* @test id=iu\n+\/* @test id=satb-100\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.base\n+ * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=satb -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n+ *      gc.shenandoah.TestReferenceRefersToShenandoah\n+ *\/\n+\n+\/* @test id=generational\n@@ -46,1 +59,1 @@\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n@@ -50,1 +63,1 @@\n-\/* @test id=satb-100\n+\/* @test id=generational-100\n@@ -59,1 +72,13 @@\n- *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=satb -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n+ *      gc.shenandoah.TestReferenceRefersToShenandoah\n+ *\/\n+\n+\/* @test id=iu\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceRefersToShenandoah.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,13 @@\n+ *      gc.shenandoah.TestReferenceShortcutCycle\n+ *\/\n+\n+\/* @test id=generational-100\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.base\n+ * @run main jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:ShenandoahGarbageThreshold=100 -Xmx100m\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceShortcutCycle.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,15 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test that null references\/referents work fine\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestRefprocSanity\n+ *\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestRefprocSanity\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRefprocSanity.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -49,0 +50,9 @@\n+\/*\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ShenandoahRegionSampling\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRegionSampling\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSampling.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=default-rotation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+ShenandoahRegionSampling -XX:+ShenandoahRegionSampling\n+ *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestRegionSamplingLogging\n+ *\/\n+\n+\/*\n+ * @test id=generational-rotation\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+ShenandoahRegionSampling -XX:+ShenandoahRegionSampling\n+ *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRegionSamplingLogging\n+ *\/\n+import java.io.File;\n+import java.util.Arrays;\n+\n+public class TestRegionSamplingLogging {\n+\n+    static final long TARGET_MB = Long.getLong(\"target\", 2_000); \/\/ 2 Gb allocation\n+\n+    static volatile Object sink;\n+\n+    public static void main(String[] args) throws Exception {\n+        long count = TARGET_MB * 1024 * 1024 \/ 16;\n+        for (long c = 0; c < count; c++) {\n+            sink = new Object();\n+        }\n+\n+        File directory = new File(\".\");\n+        File[] files = directory.listFiles((dir, name) -> name.startsWith(\"region-snapshots\") && name.endsWith(\".log\"));\n+        System.out.println(Arrays.toString(files));\n+        if (files == null || files.length == 0) {\n+            throw new IllegalStateException(\"Did not find expected snapshot log file.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSamplingLogging.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -101,0 +102,20 @@\n+\/*\n+ * @test id=generational\n+ * @key randomness\n+ * @summary Test that Shenandoah is able to work with(out) resizeable TLABs\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      -XX:+ResizeTLAB\n+ *      TestResizeTLAB\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      -XX:-ResizeTLAB\n+ *      TestResizeTLAB\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestResizeTLAB.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -86,0 +87,25 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can deal with retained objects\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n+ *      TestRetainObjects\n+ *\/\n+\n@@ -111,1 +137,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+   \/*\n+    * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+    * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+    *\n+    * This code is free software; you can redistribute it and\/or modify it\n+    * under the terms of the GNU General Public License version 2 only, as\n+    * published by the Free Software Foundation.\n+    *\n+    * This code is distributed in the hope that it will be useful, but WITHOUT\n+    * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+    * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+    * version 2 for more details (a copy is included in the LICENSE file that\n+    * accompanied this code).\n+    *\n+    * You should have received a copy of the GNU General Public License version\n+    * 2 along with this work; if not, write to the Free Software Foundation,\n+    * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+    *\n+    * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+    * or visit www.oracle.com if you need additional information or have any\n+    * questions.\n+    *\n+    *\/\n+\n+   \/*\n+    * @test id=rotation\n+    * @requires vm.gc.Shenandoah\n+    *\n+    * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+    *      -XX:+ShenandoahRegionSampling -XX:+ShenandoahRegionSampling\n+    *      -Xlog:gc+region=trace:region-snapshots-%p.log::filesize=100,filecount=3\n+    *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n+    *      TestShenandoahLogRotation\n+    *\/\n+\n+   import java.io.File;\n+   import java.util.Arrays;\n+   import java.nio.file.Files;\n+\n+\n+\n+   public class TestShenandoahLogRotation {\n+\n+       static final long TARGET_MB = Long.getLong(\"target\", 1);\n+\n+       static volatile Object sink;\n+\n+       public static void main(String[] args) throws Exception {\n+           long count = TARGET_MB * 1024 * 1024 \/ 16;\n+           for (long c = 0; c < count; c++) {\n+               sink = new Object();\n+               Thread.sleep(1);\n+           }\n+\n+           File directory = new File(\".\");\n+           File[] files = directory.listFiles((dir, name) -> name.startsWith(\"region-snapshots\"));\n+           System.out.println(Arrays.toString(files));\n+           int smallFilesNumber = 0;\n+           for (File file : files) {\n+               if (file.length() < 100) {\n+                   smallFilesNumber++;\n+               }\n+           }\n+           \/\/ Expect one more log file since the ShenandoahLogFileCount doesn't include the active log file\n+           int expectedNumberOfFiles = 4;\n+           if (files.length != expectedNumberOfFiles) {\n+               throw new Error(\"There are \" + files.length + \" logs instead of the expected \" + expectedNumberOfFiles + \" \" + files[0].getAbsolutePath());\n+           }\n+           if (smallFilesNumber > 1) {\n+               throw new Error(\"There should maximum one log with size < \" + 100 + \"B\");\n+           }\n+       }\n+\n+   }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestShenandoahLogRotation.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -93,0 +94,22 @@\n+\/*\n+ * @test id=generational\n+ * @summary Acceptance tests: collector can deal with retained objects\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify\n+ *      TestSieveObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahAllocFailureALot -XX:+ShenandoahVerify\n+ *      TestSieveObjects\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestSieveObjects\n+ *\/\n+\n@@ -124,1 +147,1 @@\n- * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test default\n@@ -37,0 +38,11 @@\n+\/*\n+ * @test generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational         TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx64m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx32m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx16m TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx8m  TestSmallHeap\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx4m  TestSmallHeap\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSmallHeap.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -68,0 +69,14 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah string deduplication implementation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ *\n+ * @run main\/othervm -Xmx256m -Xlog:gc+stats -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:StringDeduplicationAgeThreshold=3\n+ *      TestStringDedup\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedup.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -45,0 +46,16 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah string deduplication implementation\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ *\n+ * @run main\/othervm -Xmx1g -Xlog:gc+stats -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseStringDeduplication\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -DtargetStrings=3000000\n+ *      TestStringDedupStress\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedupStress.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -78,0 +79,16 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that Shenandoah cleans up interned strings\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestStringInternCleanup\n+ *\n+ * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+ClassUnloadingWithConcurrentMark\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      TestStringInternCleanup\n+ *\/\n+\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringInternCleanup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -60,0 +61,5 @@\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify -XX:+ShenandoahVerifyOptoBarriers\n+ *      TestVerifyJCStress\n@@ -79,0 +85,5 @@\n+ *\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestVerifyJCStress\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyJCStress.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test default\n@@ -36,0 +37,10 @@\n+\/*\n+ * @test generational\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=0 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=1 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=2 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=3 TestVerifyLevels\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+UnlockDiagnosticVMOptions -Xmx128m -XX:+ShenandoahVerify -XX:ShenandoahVerifyLevel=4 TestVerifyLevels\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyLevels.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -37,0 +38,11 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test Shenandoah with different log levels\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=error   TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=warning TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=info    TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=debug   TestWithLogLevel\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms256M -Xmx1G -Xlog:gc*=trace   TestWithLogLevel\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWithLogLevel.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -29,2 +30,3 @@\n- * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC                         TestWrongArrayMember\n- * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC                                   TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu           TestWrongArrayMember\n+ * @run main\/othervm -Xmx128m -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational TestWrongArrayMember\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWrongArrayMember.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -208,0 +209,88 @@\n+\/*\n+ * @test id=generational\n+ * @summary Test clone barriers work correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -Xint\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:-TieredCompilation\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:TieredStopAtLevel=4\n+ *                   TestClone\n+ *\/\n+\n+\/*\n+ * @test id=generational-verify\n+ * @summary Test clone barriers work correctly\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -Xint\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:-TieredCompilation\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   TestClone\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+ *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *                   -XX:+ShenandoahVerify\n+ *                   -XX:TieredStopAtLevel=4\n+ *                   TestClone\n+ *\/\n+\n+ \/*\n+  * @test id=generational-no-coops\n+  * @summary Test clone barriers work correctly\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.bits == \"64\"\n+  *\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -Xint\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:-TieredCompilation\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:TieredStopAtLevel=1\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:TieredStopAtLevel=4\n+  *                   TestClone\n+  *\/\n@@ -209,0 +298,36 @@\n+ \/*\n+  * @test id=generational-no-coops-verify\n+  * @summary Test clone barriers work correctly\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.bits == \"64\"\n+  *\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -Xint\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:-TieredCompilation\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:TieredStopAtLevel=1\n+  *                   TestClone\n+  * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xms1g -Xmx1g\n+  *                   -XX:-UseCompressedOops\n+  *                   -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *                   -XX:+ShenandoahVerify\n+  *                   -XX:TieredStopAtLevel=4\n+  *                   TestClone\n+  *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestClone.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -56,0 +57,26 @@\n+\/*\n+ * @test id=generational\n+ * @summary Shenandoah reference CAS test\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational                                                 TestReferenceCAS\n+ * @run main\/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xint                                           TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-TieredCompilation                          TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=1                         TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:TieredStopAtLevel=4                         TestReferenceCAS\n+ *\/\n+\n+\/*\n+ * @test id=generational-no-coops\n+ * @summary Shenandoah reference CAS test\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops                          TestReferenceCAS\n+ * @run main\/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -Xint                    TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:-TieredCompilation   TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:TieredStopAtLevel=1  TestReferenceCAS\n+ * @run main\/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:-UseCompressedOops -XX:TieredStopAtLevel=4  TestReferenceCAS\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestReferenceCAS.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test TestCLIModeGenerational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Test argument processing for -XX:+ShenandoahGCMode=generational.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.generational.TestCLIModeGenerational\n+ *\/\n+\n+public class TestCLIModeGenerational {\n+\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+  public static void main(String args[]) throws Exception {\n+    Boolean using_shenandoah = wb.getBooleanVMFlag(\"UseShenandoahGC\");\n+    String gc_mode = wb.getStringVMFlag(\"ShenandoahGCMode\");\n+    if (!using_shenandoah || !gc_mode.equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestCLIModeGenerational.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.Random;\n+import java.util.HashMap;\n+\n+\/*\n+ *  To avoid the risk of false regressions identified by this test, the heap\n+ *  size is set artificially high.  Though this test is known to run reliably\n+ *  in 66 MB heap, the heap size for this test run is currently set to 256 MB.\n+ *\/\n+\n+\/*\n+ * @test TestConcurrentEvac\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -Xms256m -Xmx256m\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:NewRatio=1 -XX:+UnlockExperimentalVMOptions\n+ *      -XX:ShenandoahGuaranteedGCInterval=3000\n+ *      -XX:-UseDynamicNumberOfGCThreads -XX:-ShenandoahPacing\n+ *      gc.shenandoah.generational.TestConcurrentEvac\n+ *\/\n+\n+public class TestConcurrentEvac {\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+  static private final int SeedForRandom = 46;\n+  \/\/ Sequence of random numbers should end with same value\n+\n+  \/\/ Smaller table will cause creation of more old-gen garbage\n+  \/\/ as previous entries in table are overwritten with new values.\n+  static private final int TableSize = 53;\n+  static private final int MaxStringLength = 47;\n+  static private final int SentenceLength = 5;\n+\n+  static private Random random = new Random(SeedForRandom);\n+\n+  public static class Node {\n+    static private final int NeighborCount = 48;\n+    static private final int ChildOverwriteCount = 32;\n+    static private final int IntArraySize = 128;\n+\n+    private String name;\n+\n+    \/\/ Each Node instance holds an array containing all substrings of\n+    \/\/ its name\n+\n+    \/\/ This array has entries from 0 .. (name.length() - 1).\n+    \/\/ num_substrings[i] represents the number of substrings that\n+    \/\/ correspond to a name of length i+1.\n+    private static int [] num_substrings;\n+\n+    static {\n+      \/\/ Initialize num_substrings.\n+      \/\/ For a name of length N, there are\n+      \/\/  N substrings of length 1\n+      \/\/  N-1 substrings of length 2\n+      \/\/  N-2 substrings of length 3\n+      \/\/  ...\n+      \/\/  1 substring of length N\n+      \/\/ Note that:\n+      \/\/   num_substrings[0] = 1\n+      \/\/   num_substrings[1] = 3\n+      \/\/   num_substrings[i] = (i+1)+num_substrings[i-1]\n+\n+      num_substrings = new int[MaxStringLength];\n+      num_substrings[0] = 1;\n+      for (int i = 1; i < MaxStringLength; i++)\n+        num_substrings[i] = (i+1)+num_substrings[i-1];\n+    }\n+\n+    private String [] substrings;\n+    private Node [] neighbors;\n+\n+    public Node(String name) {\n+      this.name = name;\n+      this.substrings = new String[num_substrings[name.length() - 1]];\n+\n+      int index = 0;\n+      for (int substring_length = 1;\n+           substring_length <= name.length(); substring_length++) {\n+        for (int offset = 0;\n+             offset + substring_length <= name.length(); offset++) {\n+          this.substrings[index++] = name.substring(offset,\n+                                                    offset + substring_length);\n+        }\n+      }\n+    }\n+\n+    public String value() {\n+      return name;\n+    }\n+\n+    public String arbitrary_substring() {\n+      int index = TestConcurrentEvac.randomUnsignedInt() % substrings.length;\n+      return substrings[index];\n+    }\n+  }\n+\n+\n+  \/\/ Return random int between 1 and MaxStringLength inclusive\n+  static int randomStringLength() {\n+    int length = randomUnsignedInt();\n+    length %= (MaxStringLength - 1);\n+    length += 1;\n+    return length;\n+  }\n+\n+  static String randomCharacter() {\n+    int index = randomUnsignedInt() % 52;\n+    return (\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n+            substring(index, index+1));\n+  }\n+\n+  static String randomString() {\n+    int length = randomStringLength();\n+    String result = new String(); \/\/ make the compiler work for this garbage...\n+    for (int i = 0; i < length; i++)\n+      result += randomCharacter();\n+    return result;\n+  }\n+\n+  static int randomUnsignedInt() {\n+    int result = random.nextInt();\n+    if (result < 0) result = -result;\n+    if (result < 0) result = 0;\n+    return result;\n+  }\n+\n+  static int randomIndex() {\n+    int index = randomUnsignedInt();\n+    index %= TableSize;\n+    return index;\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    HashMap<Integer, Node> table = new HashMap<Integer, Node>(TableSize);\n+\n+    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n+        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+\n+    for (int count = java.lang.Integer.MAX_VALUE\/1024; count >= 0; count--) {\n+      int index = randomIndex();\n+      String name = randomString();\n+      table.put(index, new Node(name));\n+    }\n+\n+    String conclusion = \"\";\n+\n+    for (int i = 0; i < SentenceLength; i++) {\n+      Node a_node = table.get(randomIndex());\n+      if (a_node == null)\n+        i--;\n+      else {\n+        String a_string = a_node.arbitrary_substring();\n+        conclusion += a_string;\n+        conclusion += \" \";\n+      }\n+    }\n+    conclusion = conclusion.substring(0, conclusion.length() - 1);\n+\n+    System.out.println(\"Conclusion is [\" + conclusion + \"]\");\n+\n+    if (!conclusion.equals(\"cTy cTykJ kAkKAOWYEHbxFCmRIlyk xjYMdNmtAQXNGdIc sqHKsWnJIP\"))\n+      throw new IllegalStateException(\"Random sequence of words did not end well!\");\n+\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc.shenandoah.generational;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import java.util.Random;\n+\n+\/*\n+ * @test TestSimpleGenerational\n+ * @requires vm.gc.Shenandoah\n+ * @summary Confirm that card marking and remembered set scanning do not crash.\n+ * @library \/testlibrary \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.shenandoah.generational.TestSimpleGenerational\n+ *\/\n+public class TestSimpleGenerational {\n+  private static WhiteBox wb = WhiteBox.getWhiteBox();\n+  static private final int SeedForRandom = 46;\n+  \/\/ Sequence of random numbers should end with same value\n+  private static int ExpectedLastRandom = 272454100;\n+\n+\n+  public static class Node {\n+    static private final int NeighborCount = 5;\n+    static private final int IntArraySize = 8;\n+    static private Random random = new Random(SeedForRandom);\n+\n+    private int val;\n+    private Object field_o;\n+\n+    \/\/ Each Node instance holds references to two \"private\" arrays.\n+    \/\/ One array holds raw seething bits (primitive integers) and the\n+    \/\/ holds references.\n+\n+    private int[] field_ints;\n+    private Node [] neighbors;\n+\n+    public Node(int val) {\n+      this.val = val;\n+      this.field_o = new Object();\n+      this.field_ints = new int[IntArraySize];\n+      this.field_ints[0] = 0xca;\n+      this.field_ints[1] = 0xfe;\n+      this.field_ints[2] = 0xba;\n+      this.field_ints[3] = 0xbe;\n+      this.field_ints[4] = 0xba;\n+      this.field_ints[5] = 0xad;\n+      this.field_ints[6] = 0xba;\n+      this.field_ints[7] = 0xbe;\n+\n+      this.neighbors = new Node[NeighborCount];\n+    }\n+\n+    public int value() {\n+      return val;\n+    }\n+\n+    \/\/ Copy each neighbor of n into a new node's neighbor array.\n+    \/\/ Then overwrite arbitrarily selected neighbor with newly allocated\n+    \/\/ leaf node.\n+    public static Node upheaval(Node n) {\n+      int first_val = random.nextInt();\n+      if (first_val < 0) first_val = -first_val;\n+      if (first_val < 0) first_val = 0;\n+      Node result = new Node(first_val);\n+      if (n != null) {\n+        for (int i = 0; i < NeighborCount; i++)\n+          result.neighbors[i] = n.neighbors[i];\n+      }\n+      int second_val = random.nextInt();\n+      if (second_val < 0) second_val = -second_val;\n+      if (second_val < 0) second_val = 0;\n+\n+      int overwrite_index = first_val % NeighborCount;\n+      result.neighbors[overwrite_index] = new Node(second_val);\n+      return result;\n+    }\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    Node n = null;\n+\n+    if (!wb.getBooleanVMFlag(\"UseShenandoahGC\") ||\n+        !wb.getStringVMFlag(\"ShenandoahGCMode\").equals(\"generational\"))\n+      throw new IllegalStateException(\"Command-line options not honored!\");\n+\n+    for (int count = 10000; count > 0; count--) {\n+      n = Node.upheaval(n);\n+    }\n+\n+    if (n.value() != ExpectedLastRandom)\n+      throw new IllegalStateException(\"Random number sequence ended badly!\");\n+\n+  }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestSimpleGenerational.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -25,1 +26,1 @@\n-\/* @test\n+\/* @test id=default\n@@ -35,0 +36,10 @@\n+ \/* @test id=generational\n+  * @summary test JNI critical arrays support in Shenandoah\n+  * @key randomness\n+  * @requires vm.gc.Shenandoah\n+  * @library \/test\/lib\n+  *\n+  * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -XX:+ShenandoahVerify TestJNICritical\n+  * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational                       TestJNICritical\n+  *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNICritical.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,19 @@\n+\/* @test id=generational-verify\n+ * @summary Test JNI Global Refs with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestJNIGlobalRefs\n+ *\/\n+\n+\/* @test id=generational\n+ * @summary Test JNI Global Refs with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestJNIGlobalRefs\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -64,0 +65,16 @@\n+\/* @test id=generational\n+ * @summary Test that garbage in the pinned region does not crash VM\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestPinnedGarbage\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      TestPinnedGarbage\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestPinnedGarbage.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -66,0 +67,40 @@\n+\/**\n+ * @test id=generational\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      TestHeapDump\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=no-coops-generational\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @requires vm.bits == \"64\"\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseCompressedOops TestHeapDump\n+ *\/\n+\n+\/**\n+ * @test id=generational-strdedup\n+ * @summary Tests JVMTI heap dumps\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.jvmti\n+ * @compile TestHeapDump.java\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:+UseStringDeduplication TestHeapDump\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jvmti\/TestHeapDump.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -107,0 +108,12 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that MX notifications are reported for all cycles\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -Dprecise=false -Dmem.pool=Young\n+ *      TestChurnNotifications\n+ *\/\n+\n@@ -131,0 +144,2 @@\n+    private static final String POOL_NAME = \"Young\".equals(System.getProperty(\"mem.pool\")) ? \"Shenandoah Young Gen\" : \"Shenandoah\";\n+\n@@ -144,2 +159,2 @@\n-                    MemoryUsage before = mapBefore.get(\"Shenandoah\");\n-                    MemoryUsage after = mapAfter.get(\"Shenandoah\");\n+                    MemoryUsage before = mapBefore.get(POOL_NAME);\n+                    MemoryUsage after = mapAfter.get(POOL_NAME);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -38,0 +39,13 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test JMX memory beans\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational          -Xmx1g TestMemoryMXBeans   -1 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms1g   -Xmx1g TestMemoryMXBeans 1024 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms128m -Xmx1g TestMemoryMXBeans  128 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms1g   -Xmx1g -XX:ShenandoahUncommitDelay=0 TestMemoryMXBeans 1024 1024\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xms128m -Xmx1g -XX:ShenandoahUncommitDelay=0 TestMemoryMXBeans  128 1024\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryMXBeans.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,1 +27,1 @@\n- * @test\n+ * @test id=default\n@@ -34,0 +35,9 @@\n+\/**\n+ * @test id=generational\n+ * @summary Test JMX memory pools\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g -Xms1g TestMemoryPools\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryPools.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -101,0 +102,11 @@\n+\/*\n+ * @test id=generational\n+ * @summary Check that MX notifications are reported for all cycles\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      TestPauseNotifications\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test allocation of small object to result OOM, but not to crash JVM\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocLargeObj\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocLargeObj {\n-\n-    static final int SIZE = 1 * 1024 * 1024;\n-    static final int COUNT = 16;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        Object[] root = new Object[COUNT];\n-        sink = root;\n-        for (int c = 0; c < COUNT; c++) {\n-            root[c] = new Object[SIZE];\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargeObj.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargeObj.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargeObj.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test that allocation of the object larger than heap fails predictably\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocLargerThanHeap\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocLargerThanHeap {\n-\n-    static final int SIZE = 16 * 1024 * 1024;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        sink = new Object[SIZE];\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargerThanHeap.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocLargerThanHeap.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargerThanHeap.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=large\n+ * @summary Test allocation of large objects results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory large\n+ *\/\n+\n+\/**\n+ * @test id=heap\n+ * @summary Test allocation of a heap-sized object results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory heap\n+ *\/\n+\n+\/**\n+ * @test id=small\n+ * @summary Test allocation of small objects results in OOM, but will not crash the JVM\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @run driver TestAllocOutOfMemory small\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestAllocOutOfMemory {\n+\n+    static volatile Object sink;\n+\n+    public static void work(int size, int count) throws Exception {\n+        Object[] root = new Object[count];\n+        sink = root;\n+        for (int c = 0; c < count; c++) {\n+            root[c] = new Object[size];\n+        }\n+    }\n+\n+    private static void allocate(String size, int multiplier) throws Exception {\n+        switch (size) {\n+            case \"large\":\n+                work(1024 * 1024, 16 * multiplier);\n+                break;\n+            case \"heap\":\n+                work(16 * 1024 * 1024, multiplier);\n+                break;\n+            case \"small\":\n+                work(1, 16 * 1024 * 1024 * multiplier);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Usage: test [large|small|heap]\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 2) {\n+            \/\/ Called from test, size is second argument, heap requested is third\n+            String size = args[1];\n+            long spec_heap = Integer.parseInt(args[2]);\n+\n+            \/\/ The actual heap we get may be larger than the one we asked for\n+            \/\/ (particularly in the generational case)\n+            final long actual_heap = Runtime.getRuntime().maxMemory();\n+            int multiplier = 1;\n+            if (actual_heap > spec_heap) {\n+                \/\/ A suitable multiplier is used, so as to allocate an\n+                \/\/ amount appropriate to the larger actual heap size than what\n+                \/\/ was specified.\n+                multiplier = (int)((actual_heap + spec_heap - 1)\/spec_heap);\n+            }\n+\n+            allocate(size, multiplier);\n+            return;\n+        }\n+\n+        \/\/ Called from jtreg, size is first argument\n+        String size = args[0];\n+        {\n+            int heap = 16*1024*1024;      \/\/ -Xmx16m\n+            expectFailure(\"-Xmx16m\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+\n+            expectFailure(\"-Xmx16m\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+        }\n+\n+        {\n+            int heap = 1*1024*1024*1024;  \/\/ -Xmx1g\n+            expectSuccess(\"-Xmx1g\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+\n+            expectSuccess(\"-Xmx1g\",\n+                          \"-XX:+UnlockExperimentalVMOptions\",\n+                          \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                          TestAllocOutOfMemory.class.getName(),\n+                          \"test\", size, Integer.toString(heap));\n+        }\n+    }\n+\n+    private static void expectSuccess(String... args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n+    }\n+\n+    private static void expectFailure(String... args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(1);\n+        analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocOutOfMemory.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test allocation of small object to result OOM, but not to crash JVM\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @run driver TestAllocSmallObj\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestAllocSmallObj {\n-\n-    static final int COUNT = 16 * 1024 * 1024;\n-\n-    static volatile Object sink;\n-\n-    public static void work() throws Exception {\n-        Object[] root = new Object[COUNT];\n-        sink = root;\n-        for (int c = 0; c < COUNT; c++) {\n-            root[c] = new Object();\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            work();\n-            return;\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx16m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocSmallObj.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(1);\n-            analyzer.shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-\n-        {\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                    \"-Xmx1g\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    TestAllocSmallObj.class.getName(),\n-                    \"test\");\n-\n-            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n-            analyzer.shouldHaveExitValue(0);\n-            analyzer.shouldNotContain(\"java.lang.OutOfMemoryError: Java heap space\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocSmallObj.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -128,3 +129,4 @@\n-             {{\"satb\"},    {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n-             {{\"iu\"},      {\"adaptive\", \"aggressive\"}},\n-             {{\"passive\"}, {\"passive\"}}\n+             {{\"satb\"},         {\"adaptive\", \"compact\", \"static\", \"aggressive\"}},\n+             {{\"iu\"},           {\"adaptive\", \"aggressive\"}},\n+             {{\"passive\"},      {\"passive\"}},\n+             {{\"generational\"}, {\"adaptive\"}}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -77,0 +78,14 @@\n+\n+        {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                    \"-Xmx32m\",\n+                    \"-XX:+UnlockExperimentalVMOptions\",\n+                    \"-XX:+UseShenandoahGC\", \"-XX:ShenandoahGCMode=generational\",\n+                    TestThreadFailure.class.getName(),\n+                    \"test\");\n+\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+            analyzer.shouldHaveExitValue(0);\n+            analyzer.shouldContain(\"java.lang.OutOfMemoryError\");\n+            analyzer.shouldContain(\"All good\");\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -47,3 +48,4 @@\n-        testWith(\"-XX:ShenandoahGCMode=satb\",    Mode.PRODUCT);\n-        testWith(\"-XX:ShenandoahGCMode=iu\",      Mode.EXPERIMENTAL);\n-        testWith(\"-XX:ShenandoahGCMode=passive\", Mode.DIAGNOSTIC);\n+        testWith(\"-XX:ShenandoahGCMode=satb\",         Mode.PRODUCT);\n+        testWith(\"-XX:ShenandoahGCMode=iu\",           Mode.EXPERIMENTAL);\n+        testWith(\"-XX:ShenandoahGCMode=passive\",      Mode.DIAGNOSTIC);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -270,0 +271,37 @@\n+\/*\n+ * @test id=generational\n+ * @key stress\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.flavor == \"server\" & !vm.emulatedClient\n+ * @summary Stress the Shenandoah GC by trying to make old objects more likely to be garbage than young objects.\n+ *\n+ * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+ *\n+ * @run main\/othervm\/timeout=200 -Xlog:gc*=info -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+ *\/\n+\n+ \/*\n+  * @test id=generational-deopt-nmethod\n+  * @key stress\n+  * @library \/\n+  * @requires vm.gc.Shenandoah\n+  * @requires vm.flavor == \"server\" & !vm.emulatedClient & vm.opt.ClassUnloading != false\n+  * @summary Stress Shenandoah GC with nmethod barrier forced deoptimization enabled.\n+  *\n+  * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+  *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n+  *      -XX:+ShenandoahVerify\n+  *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+  *\n+  * @run main\/othervm\/timeout=200 -Xlog:gc*=info,nmethod+barrier=trace -Xmx1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+  *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+  *      -XX:+DeoptimizeNMethodBarriersALot -XX:-Inline\n+  *      gc.stress.gcbasher.TestGCBasherWithShenandoah 120000\n+  *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithShenandoah.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -41,0 +42,18 @@\n+ *\/\n+\n+\/*\n+ * @test id=generational\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress Shenandoah's JNI handling by calling GetPrimitiveArrayCritical while concurrently filling up old gen.\n+ *\n+ * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahMaxYoungPercentage=90\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.gclocker.TestGCLockerWithShenandoah\n+ *\n+ * @run main\/native\/othervm\/timeout=200 -Xlog:gc*=info -Xms1500m -Xmx1500m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahMaxYoungPercentage=90\n+ *      gc.stress.gclocker.TestGCLockerWithShenandoah\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+* Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -144,0 +145,16 @@\n+\/*\n+ * @test id=generational\n+ * @key stress randomness\n+ * @library \/ \/test\/lib\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress the GC by trying to make old objects more likely to be garbage than young objects.\n+ *\n+ * @run main\/othervm\/timeout=600 -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n+ *\n+ * @run main\/othervm -Xmx384M -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.gcold.TestGCOld 50 1 20 10 10000\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOldWithShenandoah.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.gc.detailed;\n+\n+\/**\n+ * @test id=default\n+ * @key randomness\n+ * @requires vm.hasJFR\n+ * @requires vm.gc == \"Shenandoah\"\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xmx256m jdk.jfr.event.gc.detailed.TestStressBigAllocationGCEventsWithShenandoah 1048576\n+ *\/\n+\n+ \/**\n+  * @test id=generational\n+  * @key randomness\n+  * @requires vm.hasJFR\n+  * @requires vm.gc == \"Shenandoah\"\n+  * @library \/test\/lib \/test\/jdk\n+  * @run main\/othervm -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx256m jdk.jfr.event.gc.detailed.TestStressBigAllocationGCEventsWithShenandoah 1048576\n+  *\/\n+public class TestStressBigAllocationGCEventsWithShenandoah {\n+\n+    public static void main(String[] args) throws Exception {\n+        new StressAllocationGCEvents().run(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/jfr\/TestStressBigAllocationGCEventsWithShenandoah.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -44,0 +45,17 @@\n+\/*\n+ * @test id=generational\n+ * @key stress\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress the Shenandoah GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        output.shouldContain(\"Exception in thread \\\"main\\\" java.lang.ExceptionInInitializerError\");\n+        output.shouldMatch(\"Exception in thread \\\".+\\\" java.lang.ExceptionInInitializerError\");\n","filename":"test\/hotspot\/jtreg\/runtime\/BootstrapMethod\/TestLambdaExceptionInInitializer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.cds\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestCDSVMCrash.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @requires os.family != \"Windows\"\n+ * @run driver TestGetCreatedJavaVMs\n+ *\/\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\n+public class TestGetCreatedJavaVMs {\n+    public static void main(String args[]) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"GetCreatedJavaVMs\");\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        output.shouldHaveExitValue(0);\n+        output.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/getCreatedJavaVMs\/TestGetCreatedJavaVMs.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* This code tests concurrent creation of and then attach to a JVM.\n+ * Two threads race to create the JVM, the loser then checks GetCreatedJavaVMs\n+ * and attaches to the returned JVM. Prior to the fix this could crash as the\n+ * JVM is not fully initialized.\n+ *\/\n+#include \"jni.h\"\n+#include <string.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+#define NUM_THREADS 2\n+\n+void *thread_runner(void *threadid) {\n+  int tid;\n+  tid = (int)(intptr_t)threadid;\n+\n+  JavaVM *vm;\n+  JNIEnv *env = 0;\n+\n+  JavaVMInitArgs vm_args;\n+  JavaVMOption options[0];\n+  vm_args.version = JNI_VERSION_1_2;\n+  vm_args.nOptions = 0;\n+  vm_args.options = options;\n+  vm_args.ignoreUnrecognized = JNI_FALSE;\n+\n+  printf(\"[%d] BEGIN JNI_CreateJavaVM\\n\", tid);\n+  jint create_res = JNI_CreateJavaVM(&vm, (void **)&env, &vm_args);\n+  printf(\"[%d] END JNI_CreateJavaVM\\n\", tid);\n+\n+  if (create_res != JNI_OK) {\n+    printf(\"[%d] Error creating JVM: %d\\n\", tid, create_res);\n+    if (create_res == JNI_EEXIST) {\n+      jsize count;\n+      printf(\"[%d] BEGIN JNI_GetCreatedJavaVMs\\n\", tid);\n+      jint get_res = JNI_GetCreatedJavaVMs(&vm, 1, &count);\n+      printf(\"[%d] END JNI_GetCreatedJavaVMs\\n\", tid);\n+\n+      if (get_res != JNI_OK) {\n+        printf(\"[%d] Error obtaining created VMs: %d\\n\", tid, get_res);\n+        pthread_exit(NULL);\n+      } else {\n+        printf(\"[%d] Obtained %d created VMs\\n\", tid, count);\n+      }\n+      if (count > 0) {\n+        printf(\"[%d] BEGIN AttachCurrentThread\\n\", tid);\n+        get_res = (*vm)->AttachCurrentThread(vm, (void **)&env, NULL);\n+        printf(\"[%d] END AttachCurrentThread - %s\\n\", tid,\n+               (get_res == JNI_OK ? \"succeeded\" : \"failed\"));\n+        if (get_res == JNI_OK) {\n+          (*vm)->DetachCurrentThread(vm);\n+        }\n+      }\n+      pthread_exit(NULL);\n+    } else {\n+      pthread_exit(NULL);\n+    }\n+  } else {\n+    printf(\"[%d] Created a JVM\\n\", tid);\n+  }\n+\n+  pthread_exit(NULL);\n+}\n+\n+int main (int argc, char* argv[]) {\n+  pthread_t threads[NUM_THREADS];\n+  for (int i = 0; i < NUM_THREADS; i++ ) {\n+    printf(\"[*] Creating thread %d\\n\", i);\n+    int status = pthread_create(&threads[i], NULL, thread_runner, (void *)(intptr_t)i);\n+    if (status != 0) {\n+      printf(\"[*] Error creating thread %d - %d\\n\", i, status);\n+      exit(-1);\n+    }\n+  }\n+  for (int i = 0; i < NUM_THREADS; i++ ) {\n+    pthread_join(threads[i], NULL);\n+  }\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/getCreatedJavaVMs\/exeGetCreatedJavaVMs.c","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-        threadDump(file, \"-format=json\").shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, \"-format=json\").shouldMatch(\"Created\");\n@@ -92,1 +92,1 @@\n-        threadDump(file, \"\").shouldMatch(\"exists\");\n+        jcmdThreadDumpToFile(file, \"\").shouldMatch(\"exists\");\n@@ -105,1 +105,1 @@\n-        testPlainThreadDump(file, \"-overwrite\");\n+        jcmdThreadDumpToFile(file, \"-overwrite\");\n@@ -112,1 +112,1 @@\n-        threadDump(file, options).shouldMatch(\"Created\");\n+        jcmdThreadDumpToFile(file, options).shouldMatch(\"Created\");\n@@ -121,0 +121,3 @@\n+    \/**\n+     * Generate a file path with the given suffix to use for the thread dump.\n+     *\/\n@@ -128,1 +131,4 @@\n-    private OutputAnalyzer threadDump(Path file, String... options) {\n+    \/**\n+     * Launches jcmd Thread.dump_to_file to obtain a thread dump of this VM.\n+     *\/\n+    private OutputAnalyzer jcmdThreadDumpToFile(Path file, String... options) {\n@@ -136,0 +142,3 @@\n+    \/**\n+     * Returns true if the given file contains a line with the string.\n+     *\/\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8295976\n+ * @summary GetThreadListStackTraces returns wrong state for blocked VirtualThread\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:ThreadListStackTracesTest ThreadListStackTracesTest\n+ *\/\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class TestTask implements Runnable {\n+    volatile boolean threadReady = false;\n+\n+    static void log(String msg) { System.out.println(msg); }\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    public void ensureReady(Thread vt, Thread.State expState) {\n+        \/\/ wait while the thread is not ready or thread state is unexpected\n+        while (!threadReady || (vt.getState() != expState)) {\n+            sleep(1);\n+        }\n+    }\n+\n+    public abstract void run();\n+}\n+\n+class ReentrantLockTestTask extends TestTask {\n+    public void run() {\n+        log(\"grabbing reentrantLock\");\n+        threadReady = true;\n+        ThreadListStackTracesTest.reentrantLock.lock();\n+        log(\"grabbed reentrantLock\");\n+    }\n+}\n+\n+class ObjectMonitorTestTask extends TestTask {\n+    public void run() {\n+        log(\"entering synchronized statement\");\n+        threadReady = true;\n+        synchronized (ThreadListStackTracesTest.objectMonitor) {\n+            log(\"entered synchronized statement\");\n+        }\n+    }\n+}\n+\n+public class ThreadListStackTracesTest {\n+    static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    static final int JVMTI_THREAD_STATE_WAITING = 0x0080;\n+\n+    static final ReentrantLock reentrantLock = new ReentrantLock();\n+    static final Object objectMonitor = new Object();\n+\n+    private static native int getStateSingle(Thread thread);\n+    private static native int getStateMultiple(Thread thread, Thread other);\n+\n+    static void log(String msg) { System.out.println(msg); }\n+    static void failed(String msg) { throw new RuntimeException(msg); }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        checkReentrantLock();\n+        checkSynchronized();\n+    }\n+\n+    private static void checkReentrantLock() throws InterruptedException {\n+        final Thread.State expState = Thread.State.WAITING;\n+        reentrantLock.lock();\n+        String name = \"ReentrantLockTestTask\";\n+        TestTask task = new ReentrantLockTestTask();\n+        Thread vt = Thread.ofVirtual().name(name).start(task);\n+        task.ensureReady(vt, expState);\n+        checkStates(vt, expState);\n+    }\n+\n+    private static void checkSynchronized() throws InterruptedException {\n+        final Thread.State expState = Thread.State.BLOCKED;\n+        synchronized (objectMonitor) {\n+            String name = \"ObjectMonitorTestTask\";\n+            TestTask task = new ObjectMonitorTestTask();\n+            Thread vt = Thread.ofVirtual().name(name).start(task);\n+            task.ensureReady(vt, expState);\n+            checkStates(vt, expState);\n+        }\n+    }\n+\n+    private static void checkStates(Thread vt, Thread.State expState) {\n+        int singleState = getStateSingle(vt);\n+        int multiState = getStateMultiple(vt, Thread.currentThread());\n+        int jvmtiExpState = (expState == Thread.State.WAITING) ?\n+                            JVMTI_THREAD_STATE_WAITING :\n+                            JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+\n+        System.out.printf(\"State: expected: %s single: %x multi: %x\\n\",\n+                          vt.getState(), singleState, multiState);\n+\n+        if (vt.getState() != expState) {\n+            failed(\"Java thread state is wrong\");\n+        }\n+        if ((singleState & jvmtiExpState) == 0) {\n+            failed(\"JVMTI single thread state is wrong\");\n+        }\n+        if ((multiState & jvmtiExpState) == 0) {\n+            failed(\"JVMTI multi thread state is wrong\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/ThreadListStackTracesTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.h\"\n+\n+static jvmtiEnv* jvmti = nullptr;\n+static const jint MAX_FRAME_COUNT = 32;\n+\n+extern \"C\" {\n+\n+JNIEXPORT jint JNICALL\n+Java_ThreadListStackTracesTest_getStateSingle(JNIEnv* jni, jclass clazz, jthread vthread) {\n+  jvmtiStackInfo* info = NULL;\n+\n+  jvmtiError err = jvmti->GetThreadListStackTraces(1, &vthread, MAX_FRAME_COUNT, &info);\n+  check_jvmti_status(jni, err, \"getStateSingle: error in JVMTI GetThreadListStackTraces\");\n+\n+  return info[0].state;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ThreadListStackTracesTest_getStateMultiple(JNIEnv* jni, jclass clazz, jthread vhread, jthread other) {\n+  jthread threads[2] = { vhread, other };\n+  jvmtiStackInfo* info = NULL;\n+\n+  jvmtiError err = jvmti->GetThreadListStackTraces(2, threads, MAX_FRAME_COUNT, &info);\n+  check_jvmti_status(jni, err, \"getStateMultiple: error in JVMTI GetThreadListStackTraces\");\n+\n+  return info[0].state;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Agent_OnLoad: error in GetEnv\");\n+    return JNI_ERR;\n+  }\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/libThreadListStackTracesTest.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/malloc\/malloclock01\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/lock\/malloc\/malloclock01.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -Xlog:gc=debug:gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.lock.LockerTest -lockers malloc -t 1\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/malloc\/malloclock01\/TestDescription.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n@@ -152,1 +152,1 @@\n-            \/\/ don't expect any exception, except for vthreads expect OpaqueFrameException\n+            \/\/ don't expect any exception\n@@ -154,4 +154,0 @@\n-            if (vthreadMode) {\n-                setSuccess(false);\n-                log.complain(\"Expected OpaqueFrameException\");\n-            }\n@@ -159,7 +155,3 @@\n-            if (vthreadMode && (e instanceof OpaqueFrameException)) {\n-                \/\/ pass\n-            } else {\n-                setSuccess(false);\n-                log.complain(\"Unexpected exception: \" + e);\n-                e.printStackTrace(log.getOutStream());\n-            }\n+            setSuccess(false);\n+            log.complain(\"Unexpected exception: \" + e);\n+            e.printStackTrace(log.getOutStream());\n@@ -168,6 +160,1 @@\n-        if (vthreadMode) {\n-            \/\/ MethodExit event won't be as expected if using vthreads, so just resume\n-            threadReference.resume();\n-        } else {\n-            testMethodExitEvent(threadReference, ClassUsingTestClass.breakpointMethodName);\n-        }\n+        testMethodExitEvent(threadReference, ClassUsingTestClass.breakpointMethodName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,3 +86,1 @@\n-            boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n-            \/\/ expectedValue should be set as expected unless in vthread mode\n-            if (vthreadMode == (ClassUsingTestClass.expectedValue == value)) {\n+            if (ClassUsingTestClass.expectedValue != value) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/forceEarlyReturn\/forceEarlyReturn002\/forceEarlyReturn002a.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import nsk.share.gc.lock.malloc.MallocLockers;\n@@ -55,2 +54,0 @@\n-                else if (id.equals(\"malloc\"))\n-                        return new MallocLockers();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/LockerUtils.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <jni.h>\n-#include <time.h>\n-#include <stdlib.h>\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-\/*\n- * Class:     nsk_share_gc_lock_malloc_MallocLocker\n- * Method:    mallocSection\n- * Signature: (JJ)V\n- *\/\n-JNIEXPORT void JNICALL Java_nsk_share_gc_lock_malloc_MallocLocker_mallocSection\n-(JNIEnv *env, jobject o, jlong enterTime, jlong sleepTime) {\n-        void *ptr;\n-        time_t current_time, old_time;\n-        old_time = time(NULL);\n-        enterTime \/= 1000;\n-        current_time = 0;\n-        while (current_time - old_time < enterTime) {\n-                ptr = malloc(1);\n-                mssleep((long) sleepTime);\n-                free(ptr);\n-                mssleep((long) sleepTime);\n-                current_time = time(NULL);\n-        }\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/malloc\/MallocLocker.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share.gc.lock.malloc;\n-\n-import nsk.share.TestBug;\n-import nsk.share.gc.lock.Locker;\n-import nsk.share.gc.lock.CriticalSectionTimedLocker;\n-\n-\/**\n- * Malloc locker tries to hold malloc lock (if there is any)\n- * by calling malloc() and free() in a loop.\n- *\/\n-public class MallocLocker extends CriticalSectionTimedLocker {\n-        static {\n-                System.loadLibrary(\"MallocLocker\");\n-        }\n-\n-        public MallocLocker() {\n-        }\n-\n-        public MallocLocker(long enterTime, long sleepTime) {\n-                super(enterTime, sleepTime);\n-        }\n-\n-        \/**\n-         * This native method does malloc() \/ free() in a loop\n-         * while java field locked is set to true, sleeping\n-         * for sleepTime between malloc() and free() and after\n-         * free().\n-         *\/\n-        private native void mallocSection(long enterTime, long sleepTime);\n-\n-        protected void criticalSection(long enterTime, long sleepTime) {\n-                mallocSection(enterTime, sleepTime);\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/malloc\/MallocLocker.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share.gc.lock.malloc;\n-\n-import nsk.share.TestBug;\n-import nsk.share.gc.lock.Lockers;\n-import nsk.share.gc.lock.Locker;\n-\n-public class MallocLockers implements Lockers {\n-        public Locker createLocker(Object obj) {\n-                return new MallocLocker();\n-        }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/malloc\/MallocLockers.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"MallocLocker.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"nsk_tools.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/malloc\/libMallocLocker.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -229,0 +229,4 @@\n+                cmdline += \" -waittime \" + argumentHandler.getWaitTime();\n+                if (argumentHandler.verbose()) {\n+                    cmdline += \" -verbose\";\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import org.testng.annotations.DataProvider;\n+\n+\/**\n+ * Verifies the configuration file and precedence:\n+ *     settings in the configuration file are used as the default values of properties;\n+ *     any settings in a custom configuration file override those in the default\n+ * configuration.\n+ *\/\n+public class ConfigurationTest {\n+    \/\/ system property for custom configuration file\n+    static final String SP_CONFIG = \"java.xml.config.file\";\n+    \/\/ Impl-Specific Property: entity expansion\n+    static final String ISP_ENTITY_EXPANSION = \"jdk.xml.entityExpansionLimit\";\n+    \/\/ Impl-Specific Property: parameter entity limit\n+    static final String ISP_PARAMETER_ENTITY = \"jdk.xml.maxParameterEntitySizeLimit\";\n+    \/\/ Impl-Specific Property: element attribute limit\n+    static final String ISP_ELEMENT_ATTRIBUTE = \"jdk.xml.elementAttributeLimit\";\n+    \/\/ Impl-Specific Property: XML name limit\n+    static final String ISP_NAME_LIMIT = \"jdk.xml.maxXMLNameLimit\";\n+\n+    \/\/ Impl-Specific Feature: extension functions\n+    static final String ISF_EXTENSION_FUNCTIONS = \"jdk.xml.enableExtensionFunctions\";\n+    \/\/ Catalog feature: resolve\n+    static final String CATALOG_RESOLVE = \"javax.xml.catalog.resolve\";\n+    \/\/ The USE_CATALOG property indicates whether Catalog is enabled for a processor\n+    static final String USE_CATALOG = \"http:\/\/javax.xml.XMLConstants\/feature\/useCatalog\";\n+    static final String SP_USE_CATALOG = \"javax.xml.useCatalog\";\n+\n+\n+    static final boolean IS_WINDOWS = System.getProperty(\"os.name\").contains(\"Windows\");\n+    static final String SRC_DIR;\n+    static final String TEST_SOURCE_DIR;\n+    static {\n+        String srcDir = System.getProperty(\"test.src\", \".\");\n+        if (IS_WINDOWS) {\n+            srcDir = srcDir.replace('\\\\', '\/');\n+        }\n+        SRC_DIR = srcDir;\n+        TEST_SOURCE_DIR = srcDir + \"\/files\/\";\n+    }\n+\n+    static enum PropertyType { FEATURE, PROPERTY };\n+\n+   \/*\n+     * DataProvider for testing the configuration file and system property.\n+     *\n+     * Fields:\n+     *     configuration file, property name, property type, property value\n+     *\/\n+    @DataProvider(name = \"getProperty\")\n+    public Object[][] getProperty() {\n+        \/**\n+         * Test cases for verifying the configuration file\n+         *\/\n+        return new Object[][]{\n+            \/\/ default value is expected for property (PARAMETER_ENTITY) not\n+            \/\/ set in the default and custom configuration files\n+            {null, ISP_PARAMETER_ENTITY, \"1000000\"},\n+            \/\/ this property is set in the default (jaxp.properties),\n+            \/\/ but not the custom configuration file. Expects readings from the\n+            \/\/ default config\n+            {null, ISP_NAME_LIMIT, \"1000\"},\n+            \/\/ the property in the default configuration file (jaxp.properties)\n+            \/\/ will be read and used as the default value of the property\n+            {null, ISP_ENTITY_EXPANSION, \"64000\"},\n+        };\n+    }\n+\n+    @DataProvider(name = \"getProperty0\")\n+    public Object[][] getProperty0() {\n+        \/**\n+         * Duplicate of getProperty to include the case that uses the system\n+         * property to set up a custom configuration file. This is to avoid\n+         * interfering with other test cases.\n+         *\/\n+        return new Object[][]{\n+            \/\/ the setting in the custom configuration file will override that\n+            \/\/ in the default one\n+            {\"customJaxp.properties\", ISP_ENTITY_EXPANSION, \"1000\"},\n+        };\n+    }\n+\n+\n+    static String getPath(String file) {\n+        String temp = TEST_SOURCE_DIR + file;\n+        if (IS_WINDOWS) {\n+            temp = \"\/\" + temp;\n+        }\n+        return temp;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/ConfigurationTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.SP_CONFIG;\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.DOMImplTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class DOMImplTest extends DocumentBuilderFactory {\n+    \/*\n+     * DataProvider for testing the configuration file and system property.\n+     *\n+     * Fields:\n+     *     configuration file, factory implementation class\n+     *\/\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.DOMImplTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testDOMImpl(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(SP_CONFIG, getPath(config));\n+        }\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        System.clearProperty(SP_CONFIG);\n+        Assert.assertEquals(dbf.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, Object value) throws IllegalArgumentException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) throws IllegalArgumentException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setFeature(String name, boolean value) throws ParserConfigurationException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean getFeature(String name) throws ParserConfigurationException {\n+        return false;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/DOMImplTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.SP_CONFIG;\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.DOMImplTest0\n+ * @summary the tests with the default and custom configurations files have to be\n+ * separate because they both are loaded once.\n+ *\/\n+public class DOMImplTest0 {\n+    \/*\n+     * DataProvider for testing the configuration file and system property.\n+     *\n+     * Fields:\n+     *     configuration file, factory implementation class\n+     *\/\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testDOMImpl(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(SP_CONFIG, getPath(config));\n+        }\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        System.clearProperty(SP_CONFIG);\n+        Assert.assertEquals(dbf.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/DOMImplTest0.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.DOMPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class DOMPropertyTest extends ConfigurationTest {\n+\n+   @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(SP_CONFIG, getPath(config));\n+        }\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        Assert.assertEquals(dbf.getAttribute(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/DOMPropertyTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.DOMPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of DOMPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class DOMPropertyTest0 extends ConfigurationTest {\n+\n+   @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(SP_CONFIG, getPath(config));\n+        }\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        Assert.assertEquals(dbf.getAttribute(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/DOMPropertyTest0.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import java.util.Iterator;\n+import javax.xml.namespace.NamespaceContext;\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.Location;\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.Characters;\n+import javax.xml.stream.events.Comment;\n+import javax.xml.stream.events.DTD;\n+import javax.xml.stream.events.EndDocument;\n+import javax.xml.stream.events.EndElement;\n+import javax.xml.stream.events.EntityDeclaration;\n+import javax.xml.stream.events.EntityReference;\n+import javax.xml.stream.events.Namespace;\n+import javax.xml.stream.events.ProcessingInstruction;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.EventFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class EventFactoryTest extends XMLEventFactory {\n+   @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.EventFactoryTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testEventFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLEventFactory ef = XMLEventFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(ef.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public void setLocation(Location location) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public Attribute createAttribute(String prefix, String namespaceURI, String localName, String value) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Attribute createAttribute(String localName, String value) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Attribute createAttribute(QName name, String value) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Namespace createNamespace(String namespaceURI) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Namespace createNamespace(String prefix, String namespaceUri) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartElement createStartElement(QName name, Iterator<? extends Attribute> attributes, Iterator<? extends Namespace> namespaces) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartElement createStartElement(String prefix, String namespaceUri, String localName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartElement createStartElement(String prefix, String namespaceUri, String localName, Iterator<? extends Attribute> attributes, Iterator<? extends Namespace> namespaces) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartElement createStartElement(String prefix, String namespaceUri, String localName, Iterator<? extends Attribute> attributes, Iterator<? extends Namespace> namespaces, NamespaceContext context) {\n+        return null;\n+    }\n+\n+    @Override\n+    public EndElement createEndElement(QName name, Iterator<? extends Namespace> namespaces) {\n+        return null;\n+    }\n+\n+    @Override\n+    public EndElement createEndElement(String prefix, String namespaceUri, String localName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public EndElement createEndElement(String prefix, String namespaceUri, String localName, Iterator<? extends Namespace> namespaces) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Characters createCharacters(String content) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Characters createCData(String content) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Characters createSpace(String content) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Characters createIgnorableSpace(String content) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartDocument createStartDocument() {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartDocument createStartDocument(String encoding, String version, boolean standalone) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartDocument createStartDocument(String encoding, String version) {\n+        return null;\n+    }\n+\n+    @Override\n+    public StartDocument createStartDocument(String encoding) {\n+        return null;\n+    }\n+\n+    @Override\n+    public EndDocument createEndDocument() {\n+        return null;\n+    }\n+\n+    @Override\n+    public EntityReference createEntityReference(String name, EntityDeclaration declaration) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Comment createComment(String text) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ProcessingInstruction createProcessingInstruction(String target, String data) {\n+        return null;\n+    }\n+\n+    @Override\n+    public DTD createDTD(String dtd) {\n+        return null;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/EventFactoryTest.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.stream.XMLEventFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.EventFactoryTest0\n+ * @summary the tests with the default and custom configurations files have to be\n+ * separate because they both are loaded once.\n+ *\/\n+public class EventFactoryTest0 {\n+   @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.xml.internal.stream.events.XMLEventFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testEventFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLEventFactory ef = XMLEventFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(ef.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/EventFactoryTest0.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import javax.xml.stream.EventFilter;\n+import javax.xml.stream.StreamFilter;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLReporter;\n+import javax.xml.stream.XMLResolver;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.stream.util.XMLEventAllocator;\n+import javax.xml.transform.Source;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.InputFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class InputFactoryTest extends XMLInputFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.InputFactoryTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testInputFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLInputFactory xif = XMLInputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xif.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(Reader reader) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(Source source) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(InputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(InputStream stream, String encoding) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(String systemId, InputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createXMLStreamReader(String systemId, Reader reader) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(Reader reader) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(String systemId, Reader reader) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(XMLStreamReader reader) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(Source source) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(InputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(InputStream stream, String encoding) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createXMLEventReader(String systemId, InputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamReader createFilteredReader(XMLStreamReader reader, StreamFilter filter) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventReader createFilteredReader(XMLEventReader reader, EventFilter filter) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLResolver getXMLResolver() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setXMLResolver(XMLResolver resolver) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public XMLReporter getXMLReporter() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setXMLReporter(XMLReporter reporter) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public void setProperty(String name, Object value) throws IllegalArgumentException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public Object getProperty(String name) throws IllegalArgumentException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isPropertySupported(String name) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setEventAllocator(XMLEventAllocator allocator) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public XMLEventAllocator getEventAllocator() {\n+        return null;\n+    }\n+\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/InputFactoryTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.stream.XMLInputFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.InputFactoryTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class InputFactoryTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.xml.internal.stream.XMLInputFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testInputFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLInputFactory xif = XMLInputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xif.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/InputFactoryTest0.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import javax.xml.transform.Result;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.OutputFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class OutputFactoryTest extends XMLOutputFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.OutputFactoryTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testOutputFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLOutputFactory xof = XMLOutputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xof.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public XMLStreamWriter createXMLStreamWriter(Writer stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamWriter createXMLStreamWriter(OutputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamWriter createXMLStreamWriter(OutputStream stream, String encoding) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLStreamWriter createXMLStreamWriter(Result result) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventWriter createXMLEventWriter(Result result) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventWriter createXMLEventWriter(OutputStream stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventWriter createXMLEventWriter(OutputStream stream, String encoding) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public XMLEventWriter createXMLEventWriter(Writer stream) throws XMLStreamException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setProperty(String name, Object value) throws IllegalArgumentException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public Object getProperty(String name) throws IllegalArgumentException {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isPropertySupported(String name) {\n+        return false;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/OutputFactoryTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.stream.XMLOutputFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.OutputFactoryTest0\n+ * @summary the tests with the default and custom configurations files have to be\n+ * separate because they both are loaded once.\n+ *\/\n+public class OutputFactoryTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.xml.internal.stream.XMLOutputFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testOutputFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XMLOutputFactory xof = XMLOutputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xof.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/OutputFactoryTest0.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.SP_CONFIG;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.PathTest\n+ * @summary verifies that the system property \"java.xml.config.file\" may be set\n+ * with a relative path.\n+ *\/\n+public class PathTest extends ConfigurationTest {\n+    private static final String FILE_DIR = \"files\";\n+    private static final String CUSTOM_CONFIG = \"customJaxp.properties\";\n+\n+    \/*\n+     * Sets up the test environment by copying the customJaxp.properties file\n+     * to a directory under the current working directory of the JVM.\n+    *\/\n+    @BeforeClass\n+    public static void setup() throws IOException {\n+        Path userDir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        Path fileDir = Paths.get(userDir.toString(), FILE_DIR);\n+\n+        if (Files.notExists(fileDir)) {\n+            Files.createDirectory(fileDir);\n+        }\n+\n+        Path source = Paths.get(TEST_SOURCE_DIR, CUSTOM_CONFIG);\n+        Path dest = Paths.get(fileDir.toString(), CUSTOM_CONFIG);\n+        Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    \/*\n+     * Verifies a user-defined configuration file can be set with a relative path.\n+     * This test is the same as other Property tests, except the java.xml.config.file\n+     * system property is set with a relative path.\n+    *\/\n+    @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            \/\/ set with a relative path instead of the absolute path from getPath\n+            System.setProperty(SP_CONFIG, FILE_DIR + \"\/\" + config);\n+        }\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        Assert.assertEquals(dbf.getAttribute(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/PathTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXNotRecognizedException;\n+import org.xml.sax.SAXNotSupportedException;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SAXImplTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SAXImplTest extends SAXParserFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.SAXImplTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testSAXImpl(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(spf.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public SAXParser newSAXParser() throws ParserConfigurationException, SAXException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setFeature(String name, boolean value)\n+            throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException {\n+        \/\/\n+    }\n+\n+    @Override\n+    public boolean getFeature(String name)\n+            throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException {\n+        return false;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SAXImplTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.parsers.SAXParserFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SAXImplTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SAXImplTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testSAXImpl(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(spf.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SAXImplTest0.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.xml.sax.XMLReader;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SAXPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SAXPropertyTest extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        SAXParser sp = spf.newSAXParser();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sp.getProperty(property), expected);\n+        XMLReader reader = sp.getXMLReader();\n+        Assert.assertEquals(reader.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SAXPropertyTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.xml.sax.XMLReader;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SAXPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of SAXPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class SAXPropertyTest0 extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        SAXParser sp = spf.newSAXParser();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sp.getProperty(property), expected);\n+        XMLReader reader = sp.getXMLReader();\n+        Assert.assertEquals(reader.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SAXPropertyTest0.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.XMLConstants;\n+import javax.xml.transform.Source;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.ls.LSResourceResolver;\n+import org.xml.sax.ErrorHandler;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SchemaFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SchemaFactoryTest extends SchemaFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.SchemaFactoryTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sf.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public boolean isSchemaLanguageSupported(String schemaLanguage) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setErrorHandler(ErrorHandler errorHandler) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public ErrorHandler getErrorHandler() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setResourceResolver(LSResourceResolver resourceResolver) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public LSResourceResolver getResourceResolver() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Schema newSchema(Source[] schemas) throws SAXException {\n+        return null;\n+    }\n+\n+    @Override\n+    public Schema newSchema() throws SAXException {\n+        return null;\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SchemaFactoryTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.XMLConstants;\n+import javax.xml.validation.SchemaFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SchemaFactoryTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SchemaFactoryTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xerces.internal.jaxp.validation.XMLSchemaFactory\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sf.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SchemaFactoryTest0.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.validation.SchemaFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SchemaPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class SchemaPropertyTest extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sf.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SchemaPropertyTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.validation.SchemaFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.SchemaPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of SchemaPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class SchemaPropertyTest0 extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(sf.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/SchemaPropertyTest0.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.stream.XMLInputFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.StAXPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class StAXPropertyTest extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        XMLInputFactory xif = XMLInputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xif.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/StAXPropertyTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.stream.XMLInputFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.StAXPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of DOMPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class StAXPropertyTest0 extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        XMLInputFactory xif = XMLInputFactory.newFactory();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xif.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/StAXPropertyTest0.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.transform.ErrorListener;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Templates;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerConfigurationException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.URIResolver;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.TransformerFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class TransformerFactoryTest extends TransformerFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(tf.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public Transformer newTransformer(Source source) throws TransformerConfigurationException {\n+        return null;\n+    }\n+\n+    @Override\n+    public Transformer newTransformer() throws TransformerConfigurationException {\n+        return null;\n+    }\n+\n+    @Override\n+    public Templates newTemplates(Source source) throws TransformerConfigurationException {\n+        return null;\n+    }\n+\n+    @Override\n+    public Source getAssociatedStylesheet(Source source, String media, String title, String charset) throws TransformerConfigurationException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setURIResolver(URIResolver resolver) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public URIResolver getURIResolver() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setFeature(String name, boolean value) throws TransformerConfigurationException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean getFeature(String name) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, Object value) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setErrorListener(ErrorListener listener) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public ErrorListener getErrorListener() {\n+        return null;\n+    }\n+\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/TransformerFactoryTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.transform.TransformerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.TransformerFactoryTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class TransformerFactoryTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(tf.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/TransformerFactoryTest0.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.transform.TransformerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.TransformerPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class TransformerPropertyTest extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(tf.getAttribute(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/TransformerPropertyTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.transform.TransformerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.TransformerPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of TransformerPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class TransformerPropertyTest0 extends ConfigurationTest {\n+    @Test(dataProvider = \"getProperty0\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(tf.getAttribute(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/TransformerPropertyTest0.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathFactory;\n+import javax.xml.xpath.XPathFactoryConfigurationException;\n+import javax.xml.xpath.XPathFunctionResolver;\n+import javax.xml.xpath.XPathVariableResolver;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.XPathFactoryTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class XPathFactoryTest extends XPathFactory {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {\"jaxpImpls.properties\", \"common.config.XPathFactoryTest\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XPathFactory xf = XPathFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xf.getClass().getName(), expected);\n+    }\n+\n+    @Override\n+    public boolean isObjectModelSupported(String objectModel) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setFeature(String name, boolean value) throws XPathFactoryConfigurationException {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean getFeature(String name) throws XPathFactoryConfigurationException {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setXPathVariableResolver(XPathVariableResolver resolver) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public void setXPathFunctionResolver(XPathFunctionResolver resolver) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public XPath newXPath() {\n+        return null;\n+    }\n+\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/XPathFactoryTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import static common.config.ConfigurationTest.getPath;\n+import javax.xml.xpath.XPathFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.XPathFactoryTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class XPathFactoryTest0 {\n+    @DataProvider(name = \"getImpl\")\n+    public Object[][] getImpl() {\n+\n+        return new Object[][]{\n+            {null, \"com.sun.org.apache.xpath.internal.jaxp.XPathFactoryImpl\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getImpl\")\n+    public void testFactory(String config, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+\n+        XPathFactory xf = XPathFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xf.getClass().getName(), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/XPathFactoryTest0.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.xpath.XPathFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.XPathPropertyTest\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ *\/\n+public class XPathPropertyTest extends ConfigurationTest {\n+   \/*\n+     * DataProvider for testing the configuration file and system property.\n+     *\n+     * Fields:\n+     *     configuration file, property name, property value\n+     *\/\n+    @DataProvider(name = \"getProperty\")\n+    public Object[][] getProperty() {\n+\n+        return new Object[][]{\n+            {null, \"jdk.xml.xpathExprOpLimit\", \"100\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        XPathFactory xf = XPathFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xf.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/XPathPropertyTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import javax.xml.xpath.XPathFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test @bug 8303530\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run testng\/othervm common.config.XPathPropertyTest0\n+ * @summary verifies that JAXP configuration file is customizable with a system\n+ * property \"java.xml.config.file\".\n+ * Note: this test is a duplicate of XPathPropertyTest. This test runs the\n+ * case with a custom configuration file only to avoid interfering with other\n+ * test cases.\n+ *\/\n+public class XPathPropertyTest0 extends ConfigurationTest {\n+   \/*\n+     * DataProvider for testing the configuration file and system property.\n+     *\n+     * Fields:\n+     *     configuration file, property name, property value\n+     *\/\n+    @DataProvider(name = \"getProperty\")\n+    public Object[][] getProperty() {\n+\n+        return new Object[][]{\n+            {\"customJaxp.properties\", \"jdk.xml.xpathExprOpLimit\", \"200\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getProperty\")\n+    public void testProperty(String config, String property, String expected) throws Exception {\n+        if (config != null) {\n+            System.setProperty(ConfigurationTest.SP_CONFIG, getPath(config));\n+        }\n+        XPathFactory xf = XPathFactory.newInstance();\n+        System.clearProperty(ConfigurationTest.SP_CONFIG);\n+        Assert.assertEquals(xf.getProperty(property), expected);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/XPathPropertyTest0.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+################################################################################\n+#       XML Library (java.xml) Configuration File\n+#\n+# This file is in java.util.Properties format and typically located in the conf \n+# directory of the Java installation. It may contain key\/value pairs for specifying\n+# the implementation class of a factory and\/or properties that have corresponding\n+# system properties. \n+#\n+# This file can be replaced by specifying a filename with the jdk.xml.config.file \n+# system property. For example java -Djava.xml.config.file=myfile \n+################################################################################\n+\n+# ---- Custom Configuration File ----\n+# Sets more restrictive values for: extension functions, overriding default\n+# parsers, and DTD related limits.\n+#\n+# Disable Extension Functions\n+jdk.xml.enableExtensionFunctions=false\n+# Disallow overriding the default parser\n+jdk.xml.overrideDefaultParser=false\n+#\n+# Implementation specific limits:\n+jdk.xml.entityExpansionLimit=1000\n+jdk.xml.totalEntitySizeLimit=100000\n+jdk.xml.maxGeneralEntitySizeLimit=1024\n+jdk.xml.maxParameterEntitySizeLimit=1024\n+jdk.xml.entityReplacementLimit=10000\n+#\n+# XPath limits\n+jdk.xml.xpathExprOpLimit=200\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/customJaxp.properties","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+################################################################################\n+#           JAXP Configuration File\n+#\n+# jaxp.properties (this file) is the default configuration file for JAXP, the API\n+# defined in the java.xml module. It is in java.util.Properties format and typically\n+# located in the {java.home}\/conf directory. It may contain key\/value pairs for\n+# specifying the implementation classes of JAXP factories and\/or properties\n+# that have corresponding system properties.\n+#\n+# A user-specified configuration file can be set up using the system property\n+# java.xml.config.file to override any or all of the entries in jaxp.properties.\n+# The following statement provides myConfigurationFile as a custom configuration\n+# file:\n+#     java -Djava.xml.config.file=myConfigurationFile\n+################################################################################\n+\n+# ---- JAXP Default Configuration ----\n+#\n+# The JAXP default configuration (jaxp.properties) contains entries for the\n+# Factory Lookup Mechanism and properties with corresponding system properties.\n+# The values are generally set to the default values of the properties.\n+#\n+#\n+# JAXP Lookup Mechanism:\n+#\n+# The JAXP configuration file ranks 2nd to the System Property in the precedent\n+# order of the JAXP Lookup Mechanism. When the System Property is not specified,\n+# a JAXP factory reads the configuration file in order to locate an implementation\n+# class. If found, the class specified will be used as the factory implementation\n+# class.\n+#\n+# The format of an entry is key=value where the key is the fully qualified name\n+# of the factory and value that of the implementation class. The following entry\n+# set a DocumentBuilderFactory implementation class:\n+#\n+# javax.xml.parsers.DocumentBuilderFactory=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl\n+#\n+#\n+# Java SE and JDK Implementation Specific Properties:\n+#\n+# The JAXP configuration file ranks above the default settings in the Property\n+# Precedence in that its entries will override the default values of the corresponding\n+# properties.\n+#\n+# All properties that have System Properties defined in Java SE or supported\n+# by the JDK Implementation can be placed in the configuration file to override\n+# the default property values. The format is:\n+#     system-property-name=value\n+#\n+# For example, the FILES property in CatalogFeatures has an associated system\n+# property called javax.xml.catalog.files. An entry for the FILES property in the\n+# configuration file would therefore use javax.xml.catalog.files as the key, that\n+# is:\n+#     javax.xml.catalog.files=strict\n+#\n+#\n+# Extension Functions:\n+#\n+# This property determines whether XSLT and XPath extension functions are allowed.\n+# The value type is boolean and the default value is true (allowing\n+# extension functions). The following entry would override the default value and\n+# disallow extension functions:\n+#\n+# jdk.xml.enableExtensionFunctions=false\n+#\n+#\n+# Overriding the default parser:\n+#\n+# This property allows using a third party implementation to override the default\n+# parser provided by the JDK. The value type is boolean and the default value is\n+# false, disallowing overriding the default parser. The setting below reflects\n+# the default property setting:\n+#\n+jdk.xml.overrideDefaultParser=false\n+#\n+#\n+# External Access Properties:\n+#\n+# The External Access Properties are defined in javax.xml.XMLConstants. Their\n+# system properties are javax.xml.accessExternalDTD, javax.xml.accessExternalSchema,\n+# and javax.xml.accessExternalStylesheet. The values are a list of protocols separated\n+# by comma, plus empty string (\"\") to represent no protocol allowed and the key\n+# word \"all\" for all access. The default is \"all\", allowing all external resources\n+# to be fetched. The followings are example of external access settings:\n+#\n+# allow local (file) DTDs to be retrieved\n+# javax.xml.accessExternalDTD=file\n+#\n+# allow local (file) and remote (http) external schemas\n+# javax.xml.accessExternalSchema=file, http\n+#\n+# reject any external stylesheets\n+# javax.xml.accessExternalStylesheet=\"\"\n+#\n+# allow all external stylesheets\n+# javax.xml.accessExternalStylesheet=\"all\"\n+#\n+#\n+# Catalog Properties:\n+#\n+# The Catalog API defines four features: FILES, PREFER, DEFER and RESOLVE.\n+# Except PREFER, all other properties can be placed in the configuration file\n+# using the system properties defined for them.\n+#\n+# FILES: A semicolon-delimited list of URIs to locate the catalog files. The URIs\n+# must be absolute and have a URL protocol handler for the URI scheme. The following\n+# is an example of setting up a catalog file:\n+#\n+# javax.xml.catalog.files = file:\/\/\/users\/auser\/catalog\/catalog.xml\n+#\n+# DEFER: Indicates that the alternative catalogs including those specified in\n+# delegate entries or nextCatalog are not read until they are needed. The value\n+# is a boolean and the default value is true.\n+#\n+# javax.xml.catalog.defer=true\n+#\n+# RESOLVE: Determines the action if there is no matching entry found after all of\n+# the specified catalogs are exhausted. The values are key words: strict, continue,\n+# and ignore. The default is strict. The following setting reflects the default\n+# setting.\n+#\n+# javax.xml.catalog.resolve=strict\n+#\n+#\n+# useCatalog:\n+# This property instructs XML processors to use XML Catalogs to resolve entity\n+# references. The value is a boolean and the default value is true.\n+#\n+# javax.xml.useCatalog=true\n+#\n+#\n+# Implementation Specific Properties - Limits\n+#\n+# Limits have a value type Integer. The values must be positive integers. Zero\n+# means no limit.\n+#\n+# Limits the number of entity expansions. The default value is 64000\n+# jdk.xml.entityExpansionLimit=64000\n+#\n+# Limits the total size of all entities that include general and parameter entities.\n+# The size is calculated as an aggregation of all entities. The default value is 5x10^7.\n+# jdk.xml.totalEntitySizeLimit=5E7\n+#\n+# Limits the maximum size of any general entities. The default value is 0.\n+# jdk.xml.maxGeneralEntitySizeLimit=0\n+#\n+# Limits the maximum size of any parameter entities, including the result of\n+# nesting multiple parameter entities. The default value is 10^6.\n+# jdk.xml.maxParameterEntitySizeLimit=1E6\n+#\n+# Limits the total number of nodes in all entity references. The default value is 3x10^6.\n+# jdk.xml.entityReplacementLimit=3E6\n+#\n+# Limits the number of attributes an element can have. The default value is 10000.\n+# jdk.xml.elementAttributeLimit=10000\n+#\n+# Limits the number of content model nodes that may be created when building a\n+# grammar for a W3C XML Schema that contains maxOccurs attributes with values\n+# other than \"unbounded\". The default value is 5000.\n+# jdk.xml.maxOccurLimit=5000\n+#\n+# Limits the maximum element depth. The default value is 0.\n+# jdk.xml.maxElementDepth=0\n+#\n+# Limits the maximum size of XML names, including element name, attribute name\n+# and namespace prefix and URI. The default value is 1000.\n+jdk.xml.maxXMLNameLimit=1000\n+#\n+#\n+# XPath Limits\n+#\n+# Limits the number of groups an XPath expression can contain. The default value is 10.\n+jdk.xml.xpathExprGrpLimit=10\n+#\n+# Limits the number of operators an XPath expression can contain. The default value is 100.\n+jdk.xml.xpathExprOpLimit=100\n+#\n+# Limits the total number of XPath operators in an XSL Stylesheet. The default value is 10000.\n+jdk.xml.xpathTotalOpLimit=10000\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/jaxp.properties","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+################################################################################\n+#       XML Library (java.xml) Configuration File\n+#\n+# This file is in java.util.Properties format and typically located in the conf \n+# directory of the Java installation. It may contain key\/value pairs for specifying\n+# the implementation class of a factory and\/or properties that have corresponding\n+# system properties. \n+#\n+# This file can be replaced by specifying a filename with the jdk.xml.config.file \n+# system property. For example java -Djava.xml.config.file=myfile\n+################################################################################\n+\n+# ---- Configuration for test ----\n+# \n+# Factory implementation class\n+javax.xml.parsers.DocumentBuilderFactory=common.config.DOMImplTest\n+javax.xml.parsers.SAXParserFactory=common.config.SAXImplTest\n+javax.xml.stream.XMLEventFactory=common.config.EventFactoryTest\n+javax.xml.stream.XMLInputFactory=common.config.InputFactoryTest\n+javax.xml.stream.XMLOutputFactory=common.config.OutputFactoryTest\n+javax.xml.transform.TransformerFactory=common.config.TransformerFactoryTest\n+javax.xml.validation.SchemaFactory\\:http\\:\/\/www.w3.org\/2001\/XMLSchema=common.config.SchemaFactoryTest\n+javax.xml.xpath.XPathFactory\\:http\\:\/\/java.sun.com\/jaxp\/xpath\/dom=common.config.XPathFactoryTest\n+#\n+# Disable Extension Functions\n+jdk.xml.enableExtensionFunctions=false\n+# Disallow overriding the default parser\n+jdk.xml.overrideDefaultParser=false\n+#\n+# Implementation specific limits:\n+#\n+jdk.xml.entityExpansionLimit=1000\n+jdk.xml.totalEntitySizeLimit=100000\n+jdk.xml.maxGeneralEntitySizeLimit=1024\n+jdk.xml.maxParameterEntitySizeLimit=1024\n+jdk.xml.entityReplacementLimit=10000\n+#\n+# General XML limits\n+jdk.xml.elementAttributeLimit=100\n+jdk.xml.maxOccurLimit=5000\n+jdk.xml.maxElementDepth=0\n+jdk.xml.maxXMLNameLimit=1000\n+#\n+# XPath Limits\n+jdk.xml.xpathExprGrpLimit=10\n+jdk.xml.xpathExprOpLimit=100\n+jdk.xml.xpathTotalOpLimit=10000\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/jaxpImpls.properties","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -30,11 +30,2 @@\n-com\/sun\/jdi\/DeferredStepTest.java 8285422 generic-all\n-com\/sun\/jdi\/EarlyReturnTest.java 8285422 generic-all\n-com\/sun\/jdi\/ExceptionEvents.java 8285422 generic-all\n-com\/sun\/jdi\/JdbMethodExitTest.java 8285422 generic-all\n-com\/sun\/jdi\/JdbStepTest.java 8285422 generic-all\n-com\/sun\/jdi\/JdbStopThreadTest.java 8285422 generic-all\n-com\/sun\/jdi\/JdbStopThreadidTest.java 8285422 generic-all\n-com\/sun\/jdi\/MethodEntryExitEvents.java 8285422 generic-all\n-com\/sun\/jdi\/MultiBreakpointsTest.java 8285422 generic-all\n-com\/sun\/jdi\/RedefineCrossStart.java 8285422 generic-all\n-com\/sun\/jdi\/RedefineG.java 8285422 generic-all\n+com\/sun\/jdi\/ExceptionEvents.java 8278470 generic-all\n+com\/sun\/jdi\/RedefineCrossStart.java 8278470 generic-all\n@@ -42,1 +33,0 @@\n-com\/sun\/jdi\/RedefineTTYLineNumber.java 8285422 generic-all\n@@ -62,1 +52,1 @@\n-## Tests incompatible with  with virtual test thread factory.\n+## Tests incompatible with virtual test thread factory.\n@@ -64,1 +54,1 @@\n-## So any test migth be added as incompatible, the bug is not required.\n+## So any test might be added as incompatible, the bug id is not required.\n@@ -75,0 +65,1 @@\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 0000000 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -462,1 +462,0 @@\n-java\/awt\/Toolkit\/GetScreenInsetsCustomGC\/GetScreenInsetsCustomGC.java 8308875 linux-x64\n@@ -491,0 +490,2 @@\n+java\/lang\/ScopedValue\/StressStackOverflow.java                  8303498 linux-s390x\n+\n@@ -608,1 +609,1 @@\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 linux-all\n+sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343,8309569 linux-all,macosx-x64,windows-x64\n@@ -743,3 +744,0 @@\n-\n-jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java   8303498 linux-s390x\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    vm.jvmti \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,1 +282,0 @@\n-    jdk\/incubator\/concurrent \\\n@@ -322,1 +321,0 @@\n-    jdk\/incubator\/concurrent \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297878\n+ * @summary Key Encapsulation Mechanism API\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+public class Compliance {\n+\n+    public static void main(String[] args) throws Exception {\n+        basic();\n+        conform();\n+        determined();\n+        try {\n+            Security.insertProviderAt(new ProviderImpl(), 1);\n+            delayed();\n+        } finally {\n+            Security.removeProvider(\"XP\");\n+        }\n+    }\n+\n+    \/\/ Encapsulated conformance checks\n+    private static void conform() {\n+        new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), new byte[0], new byte[0]);\n+        new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), new byte[0], null);\n+        Utils.runAndCheckException(\n+                () -> new KEM.Encapsulated(null, new byte[0], null),\n+                NullPointerException.class);\n+        Utils.runAndCheckException(\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n+                NullPointerException.class);\n+    }\n+\n+    \/\/ basic should and shouldn't behaviors\n+    static void basic() throws Exception {\n+        KeyPair kpRSA = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\n+        KeyPair kpX = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+\n+        KeyPairGenerator ecg = KeyPairGenerator.getInstance(\"EC\");\n+        ecg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyPair kpEC = ecg.generateKeyPair();\n+\n+        KEM.getInstance(\"DHKEM\", (String) null);\n+        KEM.getInstance(\"DHKEM\", (Provider) null);\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"OLALA\"),\n+                NoSuchAlgorithmException.class);\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n+                NoSuchProviderException.class);\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n+                NoSuchAlgorithmException.class);\n+\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(null),\n+                InvalidKeyException.class);\n+        Utils.runAndCheckException(\n+                () -> kem.newDecapsulator(null),\n+                InvalidKeyException.class);\n+\n+        \/\/ Still an EC key, rejected by implementation\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(badECKey()),\n+                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+\n+        \/\/ Not an EC key at all, rejected by framework coz it's not\n+        \/\/ listed in \"SupportedKeyClasses\" in SunJCE.java.\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(kpRSA.getPublic()),\n+                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+\n+        Utils.runAndCheckException(\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n+                InvalidKeyException.class);\n+\n+        kem.newEncapsulator(kpX.getPublic(), null);\n+        kem.newEncapsulator(kpX.getPublic(), null, null);\n+        KEM.Encapsulator e2 = kem.newEncapsulator(kpX.getPublic());\n+        KEM.Encapsulated enc1 = e2.encapsulate(0, e2.secretSize(), \"AES\");\n+        Asserts.assertEQ(enc1.key().getEncoded().length, e2.secretSize());\n+        Asserts.assertEQ(enc1.key().getAlgorithm(), \"AES\");\n+\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(-1, 12, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(0, e2.secretSize(), null),\n+                NullPointerException.class);\n+\n+        KEM.Encapsulated enc = e2.encapsulate();\n+        Asserts.assertEQ(enc.key().getEncoded().length, e2.secretSize());\n+        Asserts.assertEQ(enc.key().getAlgorithm(), \"Generic\");\n+\n+        kem.newDecapsulator(kpX.getPrivate(), null);\n+        KEM.Decapsulator d = kem.newDecapsulator(kpX.getPrivate());\n+        d.decapsulate(enc.encapsulation());\n+        SecretKey dec = d.decapsulate(enc.encapsulation());\n+        Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), dec.getEncoded()));\n+\n+        dec = d.decapsulate(enc.encapsulation(), 0, d.secretSize(), \"AES\");\n+        Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), dec.getEncoded()));\n+\n+        KEM.Encapsulated encHead = e2.encapsulate(0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encHead.key().getAlgorithm(), \"AES\");\n+        SecretKey decHead = d.decapsulate(encHead.encapsulation(), 0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key(), decHead);\n+\n+        KEM.Encapsulated encTail = e2.encapsulate(\n+                e2.secretSize() - 16, e2.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encTail.key().getAlgorithm(), \"AES\");\n+        SecretKey decTail = d.decapsulate(encTail.encapsulation(),\n+                d.secretSize() - 16, d.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key(), decTail);\n+\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(null),\n+                NullPointerException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n+                NullPointerException.class);\n+\n+        KEM.Encapsulator e3 = kem.newEncapsulator(kpEC.getPublic());\n+        KEM.Encapsulated enc2 = e3.encapsulate();\n+        KEM.Decapsulator d3 = kem.newDecapsulator(kpX.getPrivate());\n+        Utils.runAndCheckException(\n+                () -> d3.decapsulate(enc2.encapsulation()),\n+                DecapsulateException.class);\n+\n+        Utils.runAndCheckException(\n+                () -> d3.decapsulate(new byte[100]),\n+                DecapsulateException.class);\n+    }\n+\n+    static class MySecureRandom extends SecureRandom {\n+        final Random ran;\n+\n+        MySecureRandom(long seed) {\n+            ran = new Random(seed);\n+        }\n+\n+        @Override\n+        public void nextBytes(byte[] bytes) {\n+            ran.nextBytes(bytes);\n+        }\n+    }\n+\n+    \/\/ Same random should generate same key encapsulation messages\n+    static void determined() throws Exception {\n+        long seed = new Random().nextLong();\n+        byte[] enc1 = calcDetermined(seed);\n+        byte[] enc2 = calcDetermined(seed);\n+        Asserts.assertTrue(Arrays.equals(enc1, enc2),\n+                \"Undetermined for \" + seed);\n+    }\n+\n+    static byte[] calcDetermined(long seed) throws Exception {\n+        SecureRandom random = new MySecureRandom(seed);\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"XDH\");\n+        g.initialize(NamedParameterSpec.X25519, random);\n+        PublicKey pk = g.generateKeyPair().getPublic();\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        kem.newEncapsulator(pk, random); \/\/ skip one\n+        KEM.Encapsulator e = kem.newEncapsulator(pk, random);\n+        byte[] enc1 = e.encapsulate().encapsulation();\n+        byte[] enc2 = e.encapsulate().encapsulation();\n+        Asserts.assertFalse(Arrays.equals(enc1, enc2));\n+        return enc2;\n+    }\n+\n+    public static class ProviderImpl extends Provider {\n+        ProviderImpl() {\n+            super(\"XP\", \"1\", \"XP\");\n+            put(\"KEM.DHKEM\", \"Compliance$KEMImpl\");\n+        }\n+    }\n+\n+    static boolean isEven(Key k) {\n+        return Arrays.hashCode(k.getEncoded()) % 2 == 0;\n+    }\n+\n+    public static class KEMImpl extends DHKEM {\n+\n+        @Override\n+        public EncapsulatorSpi engineNewEncapsulator(PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!isEven(pk)) throw new InvalidKeyException(\"Only accept even keys\");\n+            return super.engineNewEncapsulator(pk, spec, secureRandom);\n+        }\n+\n+        @Override\n+        public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!isEven(sk)) throw new InvalidKeyException(\"Only accept even keys\");\n+            return super.engineNewDecapsulator(sk, spec);\n+        }\n+    }\n+\n+    \/\/ Ensure delayed provider selection\n+    static void delayed() throws Exception {\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+        PublicKey even = null, odd = null;\n+        while (even == null || odd == null) {\n+            KeyPair kp = g.generateKeyPair();\n+            if (isEven(kp.getPublic())) {\n+                even = kp.getPublic();\n+            }\n+            if (!isEven(kp.getPublic())) {\n+                odd = kp.getPublic();\n+            }\n+        }\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+\n+        KEM.Encapsulator eodd = kem.newEncapsulator(odd);\n+        KEM.Encapsulator eeven = kem.newEncapsulator(even);\n+        Asserts.assertEQ(eodd.providerName(), \"SunJCE\");\n+        Asserts.assertEQ(eeven.providerName(), \"XP\");\n+    }\n+\n+    static ECPublicKey badECKey() {\n+        return new ECPublicKey() {\n+            @Override\n+            public ECPoint getW() {\n+                return null;\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return null;\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return null;\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            public ECParameterSpec getParams() {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n+    record ExChecker(Class<? extends Throwable> ex, String caller)\n+            implements Consumer<Throwable> {\n+        ExChecker {\n+            Objects.requireNonNull(ex);\n+        }\n+        static ExChecker of(Class<? extends Throwable> ex) {\n+            return new ExChecker(ex, null);\n+        }\n+        ExChecker by(String caller) {\n+            return new ExChecker(ex(), caller);\n+        }\n+        ExChecker by(Class<?> caller) {\n+            return new ExChecker(ex(), caller.getName());\n+        }\n+        @Override\n+        public void accept(Throwable t) {\n+            if (t == null) {\n+                throw new AssertionError(\"no exception thrown\");\n+            } else if (!ex.isAssignableFrom(t.getClass())) {\n+                throw new AssertionError(\"exception thrown is \" + t.getClass());\n+            } else if (caller == null) {\n+                return;\n+            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n+                return;\n+            } else {\n+                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -77,2 +77,11 @@\n-        TestScaffold.newThread(obj1, \"jj1\").start();\n-        TestScaffold.newThread(obj2, \"jj2\").start();\n+        Thread thread1 = TestScaffold.newThread(obj1, \"jj1\");\n+        Thread thread2 = TestScaffold.newThread(obj2, \"jj2\");\n+        thread1.start();\n+        thread2.start();\n+        \/\/ Threads might be deamon threads, so wait here for them to complete.\n+        try {\n+            thread1.join();\n+            thread2.join();\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        }\n","filename":"test\/jdk\/com\/sun\/jdi\/DeferredStepTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Call forceEarlyReturn() on threads in various states not covered\n+ *          well by other tests. Most notably, this test includes a\n+ *          test case for a suspended but unmounted virtual thread.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g ForceEarlyReturnTest.java\n+ * @run driver ForceEarlyReturnTest NATIVE\n+ * @run driver ForceEarlyReturnTest LOOP\n+ * @run driver ForceEarlyReturnTest SLEEP\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import java.util.*;\n+\n+\/*\n+ * There are three test modes covered by this test:\n+ *   NATIVE: the debuggee sits in a native method.\n+ *   SLEEP:  the debuggee blocks in Thread.sleep().\n+ *   LOOP:   the debuggee sits in a tight loop.\n+ *\n+ * In all cases the thread is suspended and errors such as IllegalArgumentException\n+ * and InvalidStackFrameException should not happen. The forceEarlyReturn() calls should\n+ * either pass, or produce OpaqueFrameException or NativeMethodException.\n+ *\n+ * Call stacks for each test mode (and expected result):\n+ *\n+ * NATIVE (NativeMethodException):\n+ *   nativeMethod()  <-- native method, which sleeps\n+ *   loopOrSleep()\n+ *   main()\n+ *\n+ * LOOP (no exception):\n+ *   loopOrSleep()  <-- tight loop\n+ *   main()\n+ *\n+ * SLEEP (NativeMethodException for platform thread or OpaqueFrameException\n+ * for virtual thread. See explanation in runTests().):\n+ *   Thread.sleep() + methods called by Thread.sleep()\n+ *   loopOrSleep()\n+ *   main()\n+ *\/\n+\n+class ForceEarlyReturnTestTarg {\n+    static TestMode mode;\n+\n+    static {\n+        System.loadLibrary(\"ForceEarlyReturnTestTarg\");\n+    }\n+\n+    public static void loopOrSleep() {\n+        switch (mode) {\n+        case TestMode.LOOP:\n+            while (true);\n+        case TestMode.SLEEP:\n+            try {\n+                Thread.sleep(10000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            break;\n+        case TestMode.NATIVE:\n+            nativeMethod();\n+            break;\n+        }\n+    }\n+\n+    public static native void nativeMethod(); \/\/ native method that does a very long sleep\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"    debuggee: Howdy!\");\n+\n+        \/\/ We expect just one argument, which is the test mode, such as SLEEP.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass 1 arguments to ForceEarlyReturnTestTarg\");\n+        }\n+        System.out.println(\"    debuggee: args[0]: \" + args[0]);\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+        System.out.println(\"    debuggee: test mode: \" + mode);\n+\n+        loopOrSleep();\n+\n+        System.out.println(\"    debuggee: Goodbye from ForceEarlyReturnTest!\");\n+    }\n+}\n+\n+\/*\n+ * The different modes the test can be run in. See test description comment above.\n+ *\/\n+enum TestMode {\n+    NATIVE,\n+    SLEEP,\n+    LOOP;\n+}\n+\n+\/********** test program **********\/\n+\n+public class ForceEarlyReturnTest extends TestScaffold {\n+    private static TestMode mode;\n+\n+    ForceEarlyReturnTest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ We should get one argument that indicates the test mode, such as SLEEP.\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Must pass one argument to ForceEarlyReturnTestTarg\");\n+        }\n+        mode = Enum.valueOf(TestMode.class, args[0]); \/\/ convert test mode string to an enum\n+\n+        \/*\n+         * The @run command looks something like:\n+         *   @run driver ForceEarlyReturnTest SLEEP\n+         * We need to pass SLEEP to the debuggee. We also need to insert\n+         * -Djava.library.path so the native method can be accessed if called.\n+         *\/\n+        String nativePath = \"-Djava.library.path=\" + System.getProperty(\"java.library.path\");\n+        String[] newArgs = new String[2];\n+        newArgs[0] = nativePath;\n+        newArgs[1] = args[0]; \/\/ pass test mode, such as SLEEP_NONATIVE\n+\n+        new ForceEarlyReturnTest(newArgs).startTests();\n+    }\n+\n+    public void printStack(ThreadReference thread, String msg) throws Exception {\n+        System.out.println(msg);\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        String sourceName;\n+        for (StackFrame f : stack_frames) {\n+            try {\n+                sourceName = f.location().sourceName();\n+            } catch (AbsentInformationException aie) {\n+                sourceName = \"Unknown source\";\n+            }\n+            System.out.println(\"frame[\" + i++ +\"]: \" + f.location().method() +\n+                               \" (bci:\"+ f.location().codeIndex() + \")\" +\n+                               \" (\" + sourceName + \":\"+ f.location().lineNumber() + \")\");\n+        }\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        BreakpointEvent bpe = startTo(\"ForceEarlyReturnTestTarg\", \"loopOrSleep\", \"()V\");\n+        ThreadReference mainThread = bpe.thread();\n+        boolean is_vthread_mode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n+        \/\/ Resume main thread until it is in Thread.sleep() or the infinite loop.\n+        mainThread.resume();\n+        try {\n+            Thread.sleep(1000); \/\/ give thread chance to get into Thread.sleep() or loop\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        mainThread.suspend(); \/\/ Suspend thread while in Thread.sleep() or loop\n+        printStack(mainThread, \"Debuggee stack before forceEarlyReturn():\");\n+\n+        \/*\n+         * Figure out which exception forceEarlyReturn() should throw.\n+         *\/\n+        Class expected_exception;\n+        switch(mode) {\n+        case NATIVE:\n+            \/*\n+             * There is a native frame on the top of the stack, so we expect NativeMethodException.\n+             *\/\n+            expected_exception = NativeMethodException.class;\n+            break;\n+        case LOOP:\n+            \/*\n+             * There is a java frame on the top of the stack, so we expect no exception.\n+             *\/\n+            expected_exception = null;\n+            break;\n+        case SLEEP:\n+            \/*\n+             * For platform threads, Thread.sleep() results in the Thread.sleep0() native\n+             * frame on the stack, so the end result is NativeMethodException. For virtual\n+             * threads it is not quite so simple. If the thead is pinned (such as when\n+             * there is already a native method on the stack), you end up in\n+             * VirtualThread.parkOnCarrierThread(), which calls Unsafe.park(), which is a\n+             * native method, so again this results in NativeMethodException. However, for\n+             * a virtual thread that is not pinned (which is true for this test case), you\n+             * end up with no native methods on the stack due to how Continuation.yield()\n+             * works. So you have an unmounted virtual thread with no native frames, which\n+             * results in OpaqueFrameException being thrown.\n+             *\/\n+            if (is_vthread_mode) {\n+                expected_exception = OpaqueFrameException.class;\n+            } else {\n+                expected_exception = NativeMethodException.class;\n+            }\n+            break;\n+        default:\n+            throw new RuntimeException(\"Bad test mode: \" + mode);\n+        }\n+\n+        \/*\n+         * Call ThreadReference.forceEarlyReturn() and check for errors.\n+         *\/\n+        try {\n+            if (is_vthread_mode && mode == TestMode.SLEEP) {\n+                \/\/ For this test case with virtual threads, the topmost frame is for\n+                \/\/ Continuation.yield0(), which returns a boolean.\n+                BooleanValue theValue = vm().mirrorOf(true);\n+                mainThread.forceEarlyReturn(theValue);\n+            } else {\n+                \/\/ For all other cases, the topmost frame will be one that returns void.\n+                VoidValue theValue = vm().mirrorOfVoid();\n+                mainThread.forceEarlyReturn(theValue);\n+            }\n+            if (expected_exception != null) {\n+                failure(\"failure: forceEarlyReturn() did not get expected exception: \" + expected_exception);\n+            } else {\n+                System.out.println(\"success: no exception for forceEarlyReturn()\");\n+            }\n+        } catch (Exception ex) {\n+            if (expected_exception == ex.getClass()) {\n+                System.out.println(\"success: forceEarlyReturn() got expected exception: \" + ex);\n+            } else {\n+                failure(\"failure: forceEarlyReturn() got unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        \/*\n+         * Most tests do a listenUntilVMDisconnect() here, but there is no real need for it\n+         * with this test, and doing so would require finding a way to get the debuggee\n+         * to exit the endless loop it might be in. When we return, TestScaffold will\n+         * call TestScaffold.shutdown(), causing the debuggee process to be terminated quickly.\n+         *\/\n+\n+        if (testFailed) {\n+            throw new Exception(\"ForceEarlyReturnTest failed\");\n+        }\n+        System.out.println(\"Passed:\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ForceEarlyReturnTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,0 @@\n-        System.out.println(\"threadid=\"+Thread.currentThread().getId());\n@@ -205,3 +204,8 @@\n-        Integer threadId = Integer.parseInt(\n-                new OutputAnalyzer(getDebuggeeOutput())\n-                        .firstMatch(\"^threadid=(.*)$\", 1));\n+\n+        \/\/ In order to find the main threadId, we need to parse a line from the \"threads\"\n+        \/\/ command output that looks something like:\n+        \/\/    (java.lang.VirtualThread)694            main            running (at breakpoint)\n+        OutputAnalyzer o = execCommand(JdbCommand.threads());\n+        String match = o.firstMatch(\"^\\\\s*\\\\(.+\\\\)(\\\\d+)\\\\s+main\\\\s+running.+$\", 1);\n+        Integer threadId = Integer.parseInt(match);\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbMethodExitTest.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-     * Enter main() , then t2.<init>, then sayHello[1,2,3,4,5] 15 times 3 loops,\n+     * main() is already entered, so add t2.<init>, then sayHello[1,2,3,4,5] 15 times 3 loops,\n@@ -101,1 +101,1 @@\n-    final int expectedEntryCount = 1 + 1 + (15 * 3) + 1;\n+    final int expectedEntryCount = 1 + (15 * 3) + 1;\n@@ -223,2 +223,3 @@\n-        ClassPrepareEvent e = resumeToPrepareOf(\"MethodEntryExitEventsDebugee\");\n-        mainThread = e.thread();\n+        BreakpointEvent bpe = resumeTo(\"MethodEntryExitEventsDebugee\",\n+                                       \"main\", \"([Ljava\/lang\/String;)V\");;\n+        mainThread = bpe.thread();\n","filename":"test\/jdk\/com\/sun\/jdi\/MethodEntryExitEvents.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+        Thread threads[] = new Thread[numThreads];\n@@ -64,1 +65,8 @@\n-            console(ii, numHits);\n+            threads[ii] = console(ii, numHits);\n+        }\n+        for (int ii = 0; ii < numThreads; ii++) {\n+            try {\n+                threads[ii].join();\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n@@ -130,1 +138,1 @@\n-    void console(final int num, final int nhits) {\n+    Thread console(final int num, final int nhits) {\n@@ -138,2 +146,1 @@\n-        Thread thrd = new Thread( threadName ) {\n-                public void run() {\n+        Thread thrd = TestScaffold.newThread(() -> {\n@@ -191,1 +198,2 @@\n-            };\n+            );\n+        thrd.setName(threadName);\n@@ -194,0 +202,1 @@\n+        return thrd;\n","filename":"test\/jdk\/com\/sun\/jdi\/MultiBreakpointsTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * and InvalidStackFrameException should not happen. The popFrames() calls  should\n+ * and InvalidStackFrameException should not happen. The popFrames() calls should\n@@ -67,2 +67,3 @@\n- *    being at the top of the stack. However, for a mounted virtual thread\n- *    it does not result in any native frames due to how the VM parks virtual threads.\n+ *    being at the top of the stack. However, for a mounted virtual thread that is\n+ *    not pinned, it does not result in any native frames due to how the VM\n+ *    parks non-pinned virtual threads.\n@@ -269,1 +270,0 @@\n-        ClassType targetClass = (ClassType)bpe.location().declaringType();\n","filename":"test\/jdk\/com\/sun\/jdi\/PopFramesTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    nativeMethod\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_ForceEarlyReturnTestTarg_nativeMethod(JNIEnv *env, jobject obj) {\n+    \/* Just spin. We don't need to ever return from here. *\/\n+    while(JNI_TRUE);\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/libForceEarlyReturnTestTarg.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8287008\n+ * @bug 8284161 8287008 8309406\n@@ -28,0 +28,2 @@\n+ * @requires vm.continuations\n+ * @modules jdk.management\n@@ -32,1 +34,1 @@\n- * @run junit\/othervm -Djdk.trackAllThreadds=false DumpThreads\n+ * @run junit\/othervm -Djdk.trackAllThreads=false DumpThreads\n@@ -39,0 +41,1 @@\n+import java.util.Objects;\n@@ -40,0 +43,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -42,1 +46,2 @@\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ForkJoinPool;\n@@ -50,0 +55,3 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -53,2 +61,4 @@\n-    private static final boolean TRACK_ALL_THREADS;\n-    static {\n+    private static boolean trackAllThreads;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -56,1 +66,1 @@\n-        TRACK_ALL_THREADS = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+        trackAllThreads = (s == null) || s.isEmpty() || Boolean.parseBoolean(s);\n@@ -60,1 +70,2 @@\n-     * Thread dump in plain text format.\n+     * ExecutorService implementations that have their object identity in the container\n+     * name so they can be found in the JSON format.\n@@ -62,13 +73,6 @@\n-    @Test\n-    void testPlainText() throws Exception {\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        Path file = genOutputPath(\"txt\");\n-        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-            Thread vthread = forkParker(executor);\n-            try {\n-                mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n-                cat(file);\n-\n-                \/\/ pid should be on the first line\n-                String pid = \"\" + ProcessHandle.current().pid();\n-                assertTrue(line(file, 0).contains(pid));\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newFixedThreadPool(1),\n+                Executors.newVirtualThreadPerTaskExecutor()\n+        );\n+    }\n@@ -76,3 +80,13 @@\n-                \/\/ runtime version should be on third line\n-                String vs = Runtime.version().toString();\n-                assertTrue(line(file, 2).contains(vs));\n+    \/**\n+     * Test thread dump in plain text format contains information about the current\n+     * thread and a virtual thread created directly with the Thread API.\n+     *\/\n+    @Test\n+    void testRootContainerPlainTextFormat() throws Exception {\n+        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            testDumpThreadsPlainText(vthread, trackAllThreads);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n@@ -80,2 +94,13 @@\n-                \/\/ virtual thread should be found\n-                assertTrue(isPresent(file, vthread));\n+    \/**\n+     * Test thread dump in JSON format contains information about the current\n+     * thread and a virtual thread created directly with the Thread API.\n+     *\/\n+    @Test\n+    void testRootContainerJsonFormat() throws Exception {\n+        Thread vthread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            testDumpThreadsJson(null, vthread, trackAllThreads);\n+        } finally {\n+            LockSupport.unpark(vthread);\n+        }\n+    }\n@@ -83,5 +108,11 @@\n-                \/\/ if the current thread is a platform thread then it should be included\n-                Thread currentThread = Thread.currentThread();\n-                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n-                    assertTrue(isPresent(file, currentThread));\n-                }\n+    \/**\n+     * Test thread dump in plain text format includes a thread executing a task in the\n+     * given ExecutorService.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecutorServicePlainTextFormat(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Thread thread = forkParker(executor);\n+            try {\n+                testDumpThreadsPlainText(thread, true);\n@@ -89,1 +120,1 @@\n-                LockSupport.unpark(vthread);\n+                LockSupport.unpark(thread);\n@@ -91,2 +122,0 @@\n-        } finally {\n-            Files.deleteIfExists(file);\n@@ -97,1 +126,2 @@\n-     * Thread dump in JSON format.\n+     * Test thread dump in JSON format includes a thread executing a task in the\n+     * given ExecutorService.\n@@ -99,6 +129,5 @@\n-    @Test\n-    void testJson() throws Exception {\n-        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n-        Path file = genOutputPath(\"json\");\n-        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-            Thread vthread = forkParker(executor);\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecutorServiceJsonFormat(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Thread thread = forkParker(executor);\n@@ -106,34 +135,1 @@\n-                mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n-                cat(file);\n-\n-                \/\/ parse the JSON text\n-                String jsonText = Files.readString(file);\n-                ThreadDump threadDump = ThreadDump.parse(jsonText);\n-\n-                \/\/ test threadDump\/processId\n-                assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n-\n-                \/\/ test threadDump\/time can be parsed\n-                ZonedDateTime.parse(threadDump.time());\n-\n-                \/\/ test threadDump\/runtimeVersion\n-                assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n-\n-                \/\/ test root container\n-                var rootContainer = threadDump.rootThreadContainer();\n-                assertFalse(rootContainer.owner().isPresent());\n-                assertFalse(rootContainer.parent().isPresent());\n-\n-                \/\/ if the current thread is a platform thread then it will be in root container\n-                Thread currentThread = Thread.currentThread();\n-                if (!currentThread.isVirtual() || TRACK_ALL_THREADS) {\n-                    rootContainer.findThread(currentThread.threadId()).orElseThrow();\n-                }\n-\n-                \/\/ find the thread container for the executor. The name of this executor\n-                \/\/ is its String representaiton in this case.\n-                String name = executor.toString();\n-                var container = threadDump.findThreadContainer(name).orElseThrow();\n-                assertFalse(container.owner().isPresent());\n-                assertTrue(container.parent().get() == rootContainer);\n-                container.findThread(vthread.threadId()).orElseThrow();\n+                testDumpThreadsJson(Objects.toIdentityString(executor), thread, true);\n@@ -141,1 +137,1 @@\n-                LockSupport.unpark(vthread);\n+                LockSupport.unpark(thread);\n@@ -143,0 +139,13 @@\n+        }\n+    }\n+\n+    \/**\n+     * Test thread dump in JSON format includes a thread executing a task in the\n+     * fork-join common pool.\n+     *\/\n+    @Test\n+    void testForkJoinPool() throws Exception {\n+        ForkJoinPool pool = ForkJoinPool.commonPool();\n+        Thread thread = forkParker(pool);\n+        try {\n+            testDumpThreadsJson(\"ForkJoinPool.commonPool\", thread, true);\n@@ -144,1 +153,1 @@\n-            Files.deleteIfExists(file);\n+            LockSupport.unpark(thread);\n@@ -148,0 +157,93 @@\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in plain text\n+     * format, then sanity check that the thread dump includes expected strings, the\n+     * current thread, and maybe the given thread.\n+     * @param thread the thread to test if included\n+     * @param expectInDump true if the thread is expected to be included\n+     *\/\n+    private void testDumpThreadsPlainText(Thread thread, boolean expectInDump) throws Exception {\n+        Path file = genOutputPath(\".txt\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), ThreadDumpFormat.TEXT_PLAIN);\n+        System.err.format(\"Dumped to %s%n\", file);\n+\n+        \/\/ pid should be on the first line\n+        String line1 = line(file, 0);\n+        String pid = Long.toString(ProcessHandle.current().pid());\n+        assertTrue(line1.contains(pid));\n+\n+        \/\/ timestamp should be on the second line\n+        String line2 = line(file, 1);\n+        ZonedDateTime.parse(line2);\n+\n+        \/\/ runtime version should be on third line\n+        String line3 = line(file, 2);\n+        String vs = Runtime.version().toString();\n+        assertTrue(line3.contains(vs));\n+\n+        \/\/ test if thread is included in thread dump\n+        assertEquals(expectInDump, isPresent(file, thread));\n+\n+        \/\/ current thread should be included if platform thread or tracking all threads\n+        Thread currentThread = Thread.currentThread();\n+        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n+        assertEquals(currentThreadExpected, isPresent(file, currentThread));\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to create a thread dump in JSON format.\n+     * The thread dump is parsed as a JSON object and checked to ensure that it contains\n+     * expected data, the current thread, and maybe the given thread.\n+     * @param containerName the name of the container or null for the root container\n+     * @param thread the thread to test if included\n+     * @param expect true if the thread is expected to be included\n+     *\/\n+    private void testDumpThreadsJson(String containerName,\n+                                     Thread thread,\n+                                     boolean expectInDump) throws Exception {\n+        Path file = genOutputPath(\".json\");\n+        var mbean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        mbean.dumpThreads(file.toString(), ThreadDumpFormat.JSON);\n+        System.err.format(\"Dumped to %s%n\", file);\n+\n+        \/\/ parse the JSON text\n+        String jsonText = Files.readString(file);\n+        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+\n+        \/\/ test threadDump\/processId\n+        assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n+\n+        \/\/ test threadDump\/time can be parsed\n+        ZonedDateTime.parse(threadDump.time());\n+\n+        \/\/ test threadDump\/runtimeVersion\n+        assertEquals(Runtime.version().toString(), threadDump.runtimeVersion());\n+\n+        \/\/ test root container, has no parent and no owner\n+        var rootContainer = threadDump.rootThreadContainer();\n+        assertFalse(rootContainer.owner().isPresent());\n+        assertFalse(rootContainer.parent().isPresent());\n+\n+        \/\/ test that the container contains the given thread\n+        ThreadDump.ThreadContainer container;\n+        if (containerName == null) {\n+            \/\/ root container, the thread should be found if trackAllThreads is true\n+            container = rootContainer;\n+        } else {\n+            \/\/ find the container\n+            container = threadDump.findThreadContainer(containerName).orElse(null);\n+            assertNotNull(container, containerName + \" not found\");\n+            assertFalse(container.owner().isPresent());\n+            assertTrue(container.parent().get() == rootContainer);\n+\n+        }\n+        boolean found = container.findThread(thread.threadId()).isPresent();\n+        assertEquals(expectInDump, found);\n+\n+        \/\/ current thread should be in root container if platform thread or tracking all threads\n+        Thread currentThread = Thread.currentThread();\n+        boolean currentThreadExpected = trackAllThreads || !currentThread.isVirtual();\n+        found = rootContainer.findThread(currentThread.threadId()).isPresent();\n+        assertEquals(currentThreadExpected, found);\n+    }\n+\n@@ -189,2 +291,3 @@\n-    private static Thread forkParker(ExecutorService executor) throws Exception {\n-        var ref = new AtomicReference<Thread>();\n+    private static Thread forkParker(ExecutorService executor) {\n+        class Box { static volatile Thread thread;}\n+        var latch = new CountDownLatch(1);\n@@ -192,1 +295,2 @@\n-            ref.set(Thread.currentThread());\n+            Box.thread = Thread.currentThread();\n+            latch.countDown();\n@@ -195,3 +299,4 @@\n-        Thread thread;\n-        while ((thread = ref.get()) == null) {\n-            Thread.sleep(10);\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n@@ -199,1 +304,1 @@\n-        return thread;\n+        return Box.thread;\n@@ -203,1 +308,1 @@\n-     * Returns true if the file contains #<tid>\n+     * Returns true if a Thread is present in a plain text thread dump.\n@@ -238,9 +343,0 @@\n-\n-    \/**\n-     * Print the given file to standard output.\n-     *\/\n-    private static void cat(Path file) throws Exception {\n-        try (Stream<String> stream = Files.lines(file)) {\n-            stream.forEach(System.out::println);\n-        }\n-    }\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":189,"deletions":93,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     6173675 8231209\n+ * @bug     6173675 8231209 8304074\n@@ -36,0 +36,1 @@\n+    private static boolean testFailed = false;\n@@ -58,0 +59,7 @@\n+        \/\/ Test cumulative Java thread allocation since JVM launch\n+        testGetTotalThreadAllocatedBytes();\n+\n+        if (testFailed) {\n+            throw new RuntimeException(\"TEST FAILED\");\n+        }\n+\n@@ -95,0 +103,2 @@\n+        Thread curThread = Thread.currentThread();\n+\n@@ -96,1 +106,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -101,1 +111,1 @@\n-        checkResult(Thread.currentThread(), size,\n+        checkResult(curThread, size,\n@@ -110,1 +120,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -122,1 +132,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -131,1 +142,1 @@\n-        ensureValidSize(size);\n+        ensureValidSize(curThread, size);\n@@ -155,2 +166,1 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n-            e.printStackTrace(System.out);\n+            reportUnexpected(e, \"during join\");\n@@ -164,1 +174,2 @@\n-        done = false; done1 = false;\n+        done = false;\n+        done1 = false;\n@@ -175,1 +186,1 @@\n-            ensureValidSize(sizes[i]);\n+            ensureValidSize(threads[i], sizes[i]);\n@@ -204,2 +215,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n-                e.printStackTrace(System.out);\n+                reportUnexpected(e, \"during join\");\n@@ -211,1 +221,61 @@\n-    private static void ensureValidSize(long size) {\n+    private static void testGetTotalThreadAllocatedBytes()\n+        throws Exception {\n+\n+        \/\/ baseline should be positive\n+        Thread curThread = Thread.currentThread();\n+        long cumulativeSize = mbean.getTotalThreadAllocatedBytes();\n+        if (cumulativeSize <= 0) {\n+            throw new RuntimeException(\n+                \"Invalid allocated bytes returned for \" + curThread.getName() + \" = \" + cumulativeSize);\n+        }\n+\n+        \/\/ start threads\n+        done = false;\n+        done1 = false;\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            threads[i] = new MyThread(\"MyThread-\" + i);\n+            threads[i].start();\n+        }\n+\n+        \/\/ wait for threads to block after doing some allocation\n+        waitUntilThreadsBlocked();\n+\n+        \/\/ check after threads are blocked\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads go to do some more allocation\n+        synchronized (obj) {\n+            done = true;\n+            obj.notifyAll();\n+        }\n+\n+        \/\/ wait for threads to get going again. we don't care if we\n+        \/\/ catch them in mid-execution or if some of them haven't\n+        \/\/ restarted after we're done sleeping.\n+        goSleep(400);\n+\n+        System.out.println(\"Done sleeping\");\n+\n+        \/\/ check while threads are running\n+        cumulativeSize = checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+\n+        \/\/ let threads exit\n+        synchronized (obj) {\n+            done1 = true;\n+            obj.notifyAll();\n+        }\n+\n+        for (int i = 0; i < NUM_THREADS; i++) {\n+            try {\n+                threads[i].join();\n+            } catch (InterruptedException e) {\n+                reportUnexpected(e, \"during join\");\n+                break;\n+            }\n+        }\n+\n+        \/\/ check after threads exit\n+        checkResult(curThread, cumulativeSize, mbean.getTotalThreadAllocatedBytes());\n+    }\n+\n+    private static void ensureValidSize(Thread curThread, long size) {\n@@ -216,1 +286,2 @@\n-                \"Invalid allocated bytes returned = \" + size);\n+                \"Invalid allocated bytes returned for thread \" +\n+                curThread.getName() + \" = \" + size);\n@@ -220,6 +291,2 @@\n-    private static void checkResult(Thread curThread,\n-                                    long prev_size, long curr_size) {\n-        if (curr_size < prev_size) {\n-            throw new RuntimeException(\"Allocated bytes \" + curr_size +\n-                                       \" expected >= \" + prev_size);\n-        }\n+    private static long checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n@@ -227,2 +294,15 @@\n-                           \" Previous allocated bytes = \" + prev_size +\n-                           \" Current allocated bytes = \" + curr_size);\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+        }\n+        return currSize;\n+    }\n+\n+    private static void reportUnexpected(Exception e, String when) {\n+        System.out.println(\"Unexpected exception thrown \" + when + \".\");\n+        e.printStackTrace(System.out);\n+        testFailed = true;\n@@ -235,1 +315,0 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n@@ -290,2 +369,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n+                        reportUnexpected(e, \"while !done\");\n@@ -297,1 +375,1 @@\n-            long size1 = mbean.getThreadAllocatedBytes(getId());\n+            long prevSize = mbean.getThreadAllocatedBytes(getId());\n@@ -299,11 +377,2 @@\n-            long size2 = mbean.getThreadAllocatedBytes(getId());\n-\n-            System.out.println(getName() + \": \" +\n-                \"ThreadAllocatedBytes  = \" + size1 +\n-                \" ThreadAllocatedBytes  = \" + size2);\n-\n-            if (size1 > size2) {\n-                throw new RuntimeException(getName() +\n-                    \" ThreadAllocatedBytes = \" + size1 +\n-                    \" > ThreadAllocatedBytes = \" + size2);\n-            }\n+            long currSize = mbean.getThreadAllocatedBytes(getId());\n+            checkResult(this, prevSize, currSize);\n@@ -316,2 +385,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n+                        reportUnexpected(e, \"while !done1\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":108,"deletions":40,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n@@ -120,2 +118,1 @@\n-        long[] sizes1 = mbean.getThreadAllocatedBytes(ids);\n-\n+        long[] afterSizes = mbean.getThreadAllocatedBytes(ids);\n@@ -123,10 +120,1 @@\n-            long newSize = sizes1[i];\n-            if (sizes[i] > newSize) {\n-                throw new RuntimeException(\"TEST FAILED: \" +\n-                    threads[i].getName() +\n-                    \" previous allocated bytes = \" + sizes[i] +\n-                    \" > current allocated bytes = \" + newSize);\n-            }\n-            System.out.println(threads[i].getName() +\n-                \" Previous allocated bytes = \" + sizes[i] +\n-                \" Current allocated bytes = \" + newSize);\n+            checkResult(threads[i], sizes[i], afterSizes[i]);\n@@ -150,1 +138,0 @@\n-\n@@ -161,3 +148,1 @@\n-                System.out.println(\"Unexpected exception is thrown.\");\n-                e.printStackTrace(System.out);\n-                testFailed = true;\n+                reportUnexpected(e, \"during join\");\n@@ -176,0 +161,20 @@\n+    private static void checkResult(Thread curThread,\n+                                    long prevSize, long currSize) {\n+        System.out.println(curThread.getName() +\n+                           \" Previous allocated bytes = \" + prevSize +\n+                           \" Current allocated bytes = \" + currSize);\n+        if (currSize < prevSize) {\n+            throw new RuntimeException(\"TEST FAILED: \" +\n+                                       curThread.getName() +\n+                                       \" previous allocated bytes = \" + prevSize +\n+                                       \" > current allocated bytes = \" + currSize);\n+\n+        }\n+    }\n+\n+    private static void reportUnexpected(Exception e, String when) {\n+        System.out.println(\"Unexpected exception thrown \" + when + \".\");\n+        e.printStackTrace(System.out);\n+        testFailed = true;\n+    }\n+\n@@ -180,1 +185,0 @@\n-            System.out.println(\"Unexpected exception is thrown.\");\n@@ -224,3 +228,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n-                        testFailed = true;\n+                        reportUnexpected(e, \"while !done\");\n@@ -239,3 +241,1 @@\n-                        System.out.println(\"Unexpected exception is thrown.\");\n-                        e.printStackTrace(System.out);\n-                        testFailed = true;\n+                        reportUnexpected(e, \"while !done\");\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemoryArray.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.DataOutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+\n+\/**\n+ * The \"application\" launched by DyamicLoadWarningTest.\n+ *\n+ * The application phones home, sends its pid to the test, waits for a reply, then exits.\n+ *\/\n+public class Application {\n+    public static void main(String[] args) throws Exception {\n+        InetAddress lh = InetAddress.getLoopbackAddress();\n+        int port = Integer.parseInt(args[0]);\n+        try (Socket s = new Socket(lh, port);\n+             DataOutputStream out = new DataOutputStream(s.getOutputStream())) {\n+\n+            \/\/ send pid\n+            long pid = ProcessHandle.current().pid();\n+            out.writeLong(pid);\n+\n+            \/\/ wait for shutdown\n+            s.getInputStream().read();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/Application.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307478\n+ * @summary Test that a warning is printed when an agent is dynamically loaded\n+ * @requires vm.jvmti\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib \/test\/jdk\n+ * @build Application JavaAgent\n+ * @run junit\/othervm\/native DynamicLoadWarningTest\n+ *\/\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class DynamicLoadWarningTest {\n+    private static final String JVMTI_AGENT_WARNING = \"WARNING: A JVM TI agent has been loaded dynamically\";\n+    private static final String JAVA_AGENT_WARNING  = \"WARNING: A Java agent has been loaded dynamically\";\n+\n+    \/\/ JVM TI agents\n+    private static final String JVMTI_AGENT1_LIB = \"JvmtiAgent1\";\n+    private static final String JVMTI_AGENT2_LIB = \"JvmtiAgent2\";\n+    private static String jvmtiAgentPath1;\n+    private static String jvmtiAgentPath2;\n+\n+    \/\/ Java agent\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    private static String javaAgent;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        \/\/ get absolute path to JVM TI agents\n+        String prefix = Platform.isWindows() ? \"\" : \"lib\";\n+        String libname1 = prefix + JVMTI_AGENT1_LIB + \".\" + Platform.sharedLibraryExt();\n+        String libname2 = prefix + JVMTI_AGENT2_LIB + \".\" + Platform.sharedLibraryExt();\n+        jvmtiAgentPath1 = Path.of(Utils.TEST_NATIVE_PATH, libname1).toAbsolutePath().toString();\n+        jvmtiAgentPath2 = Path.of(Utils.TEST_NATIVE_PATH, libname2).toAbsolutePath().toString();\n+\n+        \/\/ create JAR file with Java agent\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(new Attributes.Name(\"Agent-Class\"), \"JavaAgent\");\n+        Path jarfile = Path.of(\"javaagent.jar\");\n+        Path classes = Path.of(TEST_CLASSES);\n+        JarUtils.createJarFile(jarfile, man, classes, Path.of(\"JavaAgent.class\"));\n+        javaAgent = jarfile.toString();\n+    }\n+\n+    \/**\n+     * Actions to load JvmtiAgent1 into a running VM.\n+     *\/\n+    private static Stream<OnAttachAction> loadJvmtiAgent1() {\n+        \/\/ load agent with the attach API\n+        OnAttachAction loadJvmtiAgent = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT1_LIB);\n+\n+        \/\/ jcmd <pid> JVMTI.agent_load <agent>\n+        OnAttachAction jcmdAgentLoad = jcmdAgentLoad(jvmtiAgentPath1);\n+\n+        return Stream.of(loadJvmtiAgent, jcmdAgentLoad);\n+    }\n+\n+    \/**\n+     * Test loading JvmtiAgent1 into a running VM.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"loadJvmtiAgent1\")\n+    void testLoadOneJvmtiAgent(OnAttachAction loadJvmtiAgent1) throws Exception {\n+        \/\/ dynamically load loadJvmtiAgent1\n+        test().whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n+\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Test loading JvmtiAgent1 and JvmtiAgent2 into a running VM.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"loadJvmtiAgent1\")\n+    void testLoadTwoJvmtiAgents(OnAttachAction loadJvmtiAgent1) throws Exception {\n+        OnAttachAction loadJvmtiAgent2 = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT2_LIB);\n+        OnAttachAction jcmdAgentLoad2 = jcmdAgentLoad(jvmtiAgentPath2);\n+\n+        \/\/ dynamically load loadJvmtiAgent1, then dynamically load loadJvmtiAgent2 with attach API\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 2);\n+\n+        \/\/ dynamically load loadJvmtiAgent1, then dynamically load loadJvmtiAgent2 with jcmd\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(jcmdAgentLoad2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 2);\n+\n+        \/\/ start loadJvmtiAgent2 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath2)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Test loading Java agent into a running VM.\n+     *\/\n+    @Test\n+    void testLoadJavaAgent() throws Exception {\n+        OnAttachAction loadJavaAgent = (pid, vm) -> vm.loadAgent(javaAgent);\n+\n+        \/\/ agent dynamically loaded\n+        test().whenRunning(loadJavaAgent)\n+                .stderrShouldContain(JAVA_AGENT_WARNING);\n+\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJavaAgent)\n+                .stderrShouldNotContain(JAVA_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Represents an operation that accepts a process identifier and a VirtualMachine\n+     * that the current JVM is attached to.\n+     *\/\n+    private interface OnAttachAction {\n+        void accept(long pid, VirtualMachine vm) throws Exception;\n+    }\n+\n+    \/**\n+     * Returns an operation that invokes \"jcmd <pid> JVMTI.agent_load <agentpath>\" to\n+     * load the given agent library into the JVM that the current JVM is attached to.\n+     *\/\n+    private static OnAttachAction jcmdAgentLoad(String agentPath) {\n+        return (pid, vm) -> {\n+            String[] jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(pid))\n+                    .addToolArg(\"JVMTI.agent_load\")\n+                    .addToolArg(agentPath)\n+                    .getCommand();\n+            System.out.println(Arrays.stream(jcmd).collect(Collectors.joining(\" \")));\n+            Process p = new ProcessBuilder(jcmd).inheritIO().start();\n+            assertEquals(0, p.waitFor());\n+        };\n+    }\n+\n+    \/**\n+     * Returns a new app runner.\n+     *\/\n+    private static AppRunner test() {\n+        return new AppRunner();\n+    }\n+\n+    \/**\n+     * Runs an application in its own VM. Once started, it attachs to the VM, runs a set\n+     * of actions, then checks that the output contains, or does not contain, a string.\n+     *\/\n+    private static class AppRunner {\n+        private String[] vmopts = new String[0];\n+        private List<OnAttachAction> actions = new ArrayList<>();\n+\n+        \/**\n+         * Specifies VM options to run the application.\n+         *\/\n+        AppRunner withOpts(String... vmopts) {\n+            this.vmopts = vmopts;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies an action to run when the attached to the running application.\n+         *\/\n+        AppRunner whenRunning(OnAttachAction action) {\n+            actions.add(action);\n+            return this;\n+        }\n+\n+        OutputAnalyzer run() throws Exception {\n+            \/\/ start a listener socket that the application will connect to\n+            try (ServerSocket listener = new ServerSocket()) {\n+                InetAddress lh = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(lh, 0));\n+\n+                var done = new AtomicBoolean();\n+\n+                \/\/ start a thread to wait for the application to phone home\n+                Thread.ofPlatform().daemon().start(() -> {\n+                    try (Socket s = listener.accept();\n+                         DataInputStream in = new DataInputStream(s.getInputStream())) {\n+\n+                        \/\/ read pid\n+                        long pid = in.readLong();\n+\n+                        \/\/ attach and run the actions with the vm object\n+                        VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n+                        try {\n+                            for (OnAttachAction action : actions) {\n+                                action.accept(pid, vm);\n+                            }\n+                        } finally {\n+                            vm.detach();\n+                        }\n+                        done.set(true);\n+\n+                        \/\/ shutdown\n+                        s.getOutputStream().write(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+\n+                \/\/ launch application with the given VM options, waiting for it to terminate\n+                Stream<String> s1 = Stream.of(vmopts);\n+                Stream<String> s2 = Stream.of(\"Application\", Integer.toString(listener.getLocalPort()));\n+                String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+                OutputAnalyzer outputAnalyzer = ProcessTools\n+                        .executeTestJava(opts)\n+                        .outputTo(System.out)\n+                        .errorTo(System.out);\n+                assertEquals(0, outputAnalyzer.getExitValue());\n+                assertTrue(done.get(), \"Attach or action failed, see log for details\");\n+                return outputAnalyzer;\n+            }\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error contains a string.\n+         *\/\n+        void stderrShouldContain(String s) throws Exception {\n+            run().stderrShouldContain(s);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error contains the given number of\n+         * occurrences of a string.\n+         *\/\n+        void stderrShouldContain(String s, int occurrences) throws Exception {\n+            List<String> lines = run().asLines();\n+            int count = (int) lines.stream().filter(line -> line.indexOf(s) >= 0).count();\n+            assertEquals(occurrences, count);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error does not contain a string.\n+         *\/\n+        void stderrShouldNotContain(String s) throws Exception {\n+            run().stderrShouldNotContain(s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * A no-op Java agent.\n+ *\/\n+public class JavaAgent {\n+    public static void agentmain(String args) {\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/JavaAgent.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent1.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent2.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,0 @@\n-        job.setPrintable(new DialogOrient());\n@@ -74,0 +73,1 @@\n+        job.setPrintable(new DialogOrient(), landscape);\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/DialogOrient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,7 +381,4 @@\n-\n-        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> {\n-            return arena.allocateUtf8String(\"str\");\n-        }, \"str\"),\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n+        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, Linker.Option[] options, String expectedExceptionMessage) {\n@@ -65,1 +65,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc, options);\n@@ -111,0 +111,1 @@\n+        Linker.Option[] NO_OPTIONS = new Linker.Option[0];\n@@ -114,0 +115,1 @@\n+                    NO_OPTIONS,\n@@ -118,0 +120,1 @@\n+                    NO_OPTIONS,\n@@ -122,0 +125,1 @@\n+                    NO_OPTIONS,\n@@ -126,0 +130,1 @@\n+                    NO_OPTIONS,\n@@ -130,0 +135,1 @@\n+                    NO_OPTIONS,\n@@ -138,0 +144,1 @@\n+                    NO_OPTIONS,\n@@ -147,0 +154,1 @@\n+                    NO_OPTIONS,\n@@ -154,0 +162,1 @@\n+                    NO_OPTIONS,\n@@ -161,0 +170,1 @@\n+                    NO_OPTIONS,\n@@ -165,0 +175,1 @@\n+                    NO_OPTIONS,\n@@ -169,0 +180,1 @@\n+                    NO_OPTIONS,\n@@ -173,0 +185,1 @@\n+                    NO_OPTIONS,\n@@ -179,0 +192,1 @@\n+                    NO_OPTIONS,\n@@ -185,0 +199,1 @@\n+                    NO_OPTIONS,\n@@ -189,0 +204,8 @@\n+        for (ValueLayout illegalLayout : List.of(C_CHAR, ValueLayout.JAVA_CHAR, C_BOOL, C_SHORT, C_FLOAT)) {\n+            cases.add(new Object[]{\n+                FunctionDescriptor.ofVoid(C_INT, illegalLayout),\n+                new Linker.Option[]{Linker.Option.firstVariadicArg(1)},\n+                \"Invalid variadic argument layout\"\n+            });\n+        }\n+\n@@ -195,0 +218,1 @@\n+                    NO_OPTIONS,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n+                                                                 C_DOUBLE, C_INT, C_DOUBLE, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3D, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -355,0 +356,14 @@\n+    @Test\n+    void testReinterpret() {\n+        AtomicInteger counter = new AtomicInteger();\n+        try (Arena arena = Arena.ofConfined()){\n+            \/\/ check size\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(100).byteSize(), 100);\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(100, Arena.ofAuto(), null).byteSize(), 100);\n+            \/\/ check scope and cleanup\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(100, arena, s -> counter.incrementAndGet()).scope(), arena.scope());\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, s -> counter.incrementAndGet()).scope(), arena.scope());\n+        }\n+        assertEquals(counter.get(), 2);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -164,0 +165,3 @@\n+            if (layout instanceof ValueLayout.OfFloat) {\n+                layout = C_DOUBLE; \/\/ promote to double, per C spec\n+            }\n@@ -235,1 +239,0 @@\n-            FLOAT,\n@@ -328,1 +331,1 @@\n-                    case \"float\" -> \"FLOAT\";\n+                    case \"float\" -> \"DOUBLE\"; \/\/ promote\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -88,0 +89,15 @@\n+    @Test(dataProvider = \"invalidCaptureSegmentCases\")\n+    public void testInvalidCaptureSegment(MemorySegment captureSegment,\n+                                          Class<?> expectedExceptionType, String expectedExceptionMessage) {\n+        Linker.Option stl = Linker.Option.captureCallState(\"errno\");\n+        MethodHandle handle = downcallHandle(\"set_errno_V\", FunctionDescriptor.ofVoid(C_INT), stl);\n+\n+        try {\n+            int testValue = 42;\n+            handle.invoke(captureSegment, testValue); \/\/ should throw\n+        } catch (Throwable t) {\n+            assertTrue(expectedExceptionType.isInstance(t));\n+            assertTrue(t.getMessage().matches(expectedExceptionMessage));\n+        }\n+    }\n+\n@@ -131,0 +147,9 @@\n+    @DataProvider\n+    public static Object[][] invalidCaptureSegmentCases() {\n+        return new Object[][]{\n+            {Arena.ofAuto().allocate(1), IndexOutOfBoundsException.class, \".*Out of bound access on segment.*\"},\n+            {MemorySegment.NULL, IllegalArgumentException.class, \".*Capture segment is NULL.*\"},\n+            {Arena.ofAuto().allocate(Linker.Option.captureStateLayout().byteSize() + 3).asSlice(3), \/\/ misaligned\n+                    IllegalArgumentException.class, \".*Target offset incompatible with alignment constraints.*\"},\n+        };\n+    }\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    T_FLOAT,\n@@ -144,1 +143,0 @@\n-            CASE(T_FLOAT, double) \/\/ vararg float is promoted to double per C spec\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4131169 4168988\n+   @bug 4131169 4168988 8290499\n@@ -254,0 +254,3 @@\n+            ck2(\"\/foo\", \"\/\", \"\/\", \"foo\", \"\/foo\");\n+            ck2(\"\/\/foo\", \"\/\", \"\/\", \"foo\", \"\/foo\");\n+            ck2(\"\/foo\", \"\/\/\", \"\/\", \"foo\", \"\/foo\");\n@@ -259,0 +262,3 @@\n+            ck2f(\"\/foo\", \"\/\", \"\/\", \"foo\", \"\/foo\");\n+            ck2f(\"\/\/foo\", \"\/\", \"\/\", \"foo\", \"\/foo\");\n+            ck2f(\"\/foo\", \"\/\/\", \"\/\", \"foo\", \"\/foo\");\n@@ -299,0 +305,4 @@\n+            ck2(\"z:\", \"\", null, \"\", \"z:\");\n+            ck2(\"z:\/\", \"\/\", null, \"\", \"z:\/\");\n+            ck2(\"z:\/\", \"a\/b\/c\", \"z:\/a\/b\", \"c\", \"z:\/a\/b\/c\");\n+            ck2(\"z:\/\", \"a\/b\/c\/\", \"z:\/a\/b\", \"c\", \"z:\/a\/b\/c\");\n@@ -302,1 +312,4 @@\n-\n+            ck2f(\"z:\", \"\", null, \"\", \"z:\");\n+            ck2f(\"z:\/\", \"\/\", null, \"\", \"z:\/\");\n+            ck2f(\"z:\/\", \"a\/b\/c\", \"z:\/a\/b\", \"c\", \"z:\/a\/b\/c\");\n+            ck2f(\"z:\/\", \"a\/b\/c\/\", \"z:\/a\/b\", \"c\", \"z:\/a\/b\/c\");\n","filename":"test\/jdk\/java\/io\/File\/Cons.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    const jchar* chars = (*env)->GetStringChars(env, root, NULL);\n-    if (chars == NULL) {\n+    const jchar* strchars = (*env)->GetStringChars(env, root, NULL);\n+    if (strchars == NULL) {\n@@ -80,1 +80,1 @@\n-    LPCWSTR path = (LPCWSTR)chars;\n+    LPCWSTR path = (LPCWSTR)strchars;\n@@ -86,0 +86,1 @@\n+        (*env)->ReleaseStringChars(env, root, strchars);\n@@ -111,2 +112,4 @@\n-        if (GetDiskFreeSpaceExW(path, &freeBytesAvailable, &totalNumberOfBytes,\n-            &totalNumberOfFreeBytes) == 0) {\n+        BOOL hres = GetDiskFreeSpaceExW(path, &freeBytesAvailable,\n+            &totalNumberOfBytes, &totalNumberOfFreeBytes);\n+        (*env)->ReleaseStringChars(env, root, strchars);\n+        if (FAILED(hres)) {\n@@ -127,0 +130,15 @@\n+    int len = (int)(*env)->GetStringLength(env, root);\n+    char* chars = (char*)malloc((len + 1)*sizeof(char));\n+    if (chars == NULL) {\n+        (*env)->ReleaseStringChars(env, root, strchars);\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"malloc\");\n+        return JNI_FALSE;\n+    }\n+\n+    for (int i = 0; i < len; i++) {\n+        chars[i] = (char)strchars[i];\n+    }\n+    chars[len] = '\\0';\n+    (*env)->ReleaseStringChars(env, root, strchars);\n+\n@@ -128,2 +146,2 @@\n-    int result = statfs((const char*)chars, &buf);\n-    (*env)->ReleaseStringChars(env, root, chars);\n+    int result = statfs(chars, &buf);\n+    free(chars);\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ *        jdk.test.lib.util.ForceGC\n@@ -37,3 +38,1 @@\n-import java.lang.ref.PhantomReference;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -54,0 +53,1 @@\n+import jdk.test.lib.util.ForceGC;\n@@ -63,1 +63,0 @@\n-    private static final ReferenceQueue<ClassLoader> rq = new ReferenceQueue<>();\n@@ -65,9 +64,2 @@\n-    static class TestLoader {\n-        private final PhantomReference<ClassLoader> ref;\n-        TestLoader() {\n-            this.ref = loadAndRun();\n-        }\n-\n-        \/\/ Use a new classloader to load the ClassForName class, then run its\n-        \/\/ Runnable.\n-        PhantomReference<ClassLoader> loadAndRun() {\n+    static class TestLoader extends URLClassLoader {\n+        static URL[] toURLs() {\n@@ -75,10 +67,2 @@\n-                ClassLoader classLoader =\n-                    new URLClassLoader(\"LeakedClassLoader\",\n-                        new URL[]{jarFilePath.toUri().toURL()},\n-                        ClassLoader.getPlatformClassLoader());\n-\n-                Class<?> loadClass = Class.forName(\"ClassForName\", true, classLoader);\n-                ((Runnable) loadClass.newInstance()).run();\n-\n-                return new PhantomReference<>(classLoader, rq);\n-            } catch (MalformedURLException|ReflectiveOperationException e) {\n+                return new URL[]{jarFilePath.toUri().toURL()};\n+            } catch (MalformedURLException e) {\n@@ -89,2 +73,14 @@\n-        PhantomReference<ClassLoader> getRef() {\n-            return ref;\n+        TestLoader() {\n+            super(\"LeakedClassLoader\", toURLs(), ClassLoader.getPlatformClassLoader());\n+        }\n+    }\n+\n+    \/\/ Use a new classloader to load the ClassForName class, then run its\n+    \/\/ Runnable.\n+    static WeakReference<TestLoader> loadAndRun() {\n+        TestLoader classLoader = new TestLoader();\n+        try {\n+            Class<?> loadClass = Class.forName(\"ClassForName\", true, classLoader);\n+            ((Runnable) loadClass.newInstance()).run();\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n@@ -92,0 +88,1 @@\n+        return new WeakReference<>(classLoader);\n@@ -101,1 +98,1 @@\n-        List<Callable<TestLoader>> callables =\n+        List<Callable<WeakReference<TestLoader>>> callables =\n@@ -103,1 +100,1 @@\n-                    Callable<TestLoader> cprcl = TestLoader::new;\n+                    Callable<WeakReference<TestLoader>> cprcl = ClassForNameLeak::loadAndRun;\n@@ -107,14 +104,4 @@\n-        List<Future<TestLoader>> futures = es.invokeAll(callables);\n-\n-        \/\/ Give the GC a chance to enqueue the PhantomReferences\n-        for (int i = 0; i < 10; i++) {\n-            System.gc();\n-        }\n-\n-        \/\/ Make sure all PhantomReferences to the leaked classloader are enqueued\n-        for (int j = 0; j < futures.size(); j++) {\n-            Reference rmRef = rq.remove(TIMEOUT);\n-            if (rmRef == null) {\n-                throw new RuntimeException(\"ClassLoader was never enqueued!\");\n-            } else {\n-                System.out.println(\"Enqueued \" + rmRef);\n+        for (Future<WeakReference<TestLoader>> future : es.invokeAll(callables)) {\n+            WeakReference<TestLoader> ref = future.get();\n+            if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+                throw new RuntimeException(ref.get() + \" not unloaded\");\n@@ -124,1 +111,0 @@\n-        System.out.println(\"All ClassLoaders successfully enqueued\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/forNameLeak\/ClassForNameLeak.java","additions":29,"deletions":43,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307990\n+ * @requires (os.family == \"linux\") | (os.family == \"aix\")\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 JspawnhelperProtocol\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class JspawnhelperProtocol {\n+    \/\/ Timout in seconds\n+    private static final int TIMEOUT = 60;\n+    \/\/ Base error code to communicate various error states from the parent process to the top-level test\n+    private static final int ERROR = 10;\n+    private static final String[] CMD = { \"pwd\" };\n+    private static final String ENV_KEY = \"JTREG_JSPAWNHELPER_PROTOCOL_TEST\";\n+\n+    private static void parentCode(String arg) throws IOException, InterruptedException {\n+        System.out.println(\"Recursively executing 'JspawnhelperProtocol \" + arg + \"'\");\n+        Process p = null;\n+        try {\n+            p = Runtime.getRuntime().exec(CMD);\n+        } catch (Exception e) {\n+            e.printStackTrace(System.out);\n+            System.exit(ERROR);\n+        }\n+        if (!p.waitFor(TIMEOUT, TimeUnit.SECONDS)) {\n+            System.out.println(\"Child process timed out\");\n+            System.exit(ERROR + 1);\n+        }\n+        if (p.exitValue() == 0) {\n+            String pwd = p.inputReader().readLine();\n+            String realPwd = Path.of(\"\").toAbsolutePath().toString();\n+            if (!realPwd.equals(pwd)) {\n+                System.out.println(\"Child process returned '\" + pwd + \"' (expected '\" + realPwd + \"')\");\n+                System.exit(ERROR + 2);\n+            }\n+            System.out.println(\"  Successfully executed '\" + CMD[0] + \"'\");\n+            System.exit(0);\n+        } else {\n+            System.out.println(\"  Failed to executed '\" + CMD[0] + \"' (exitValue=\" + p.exitValue() + \")\");\n+            System.exit(ERROR + 3);\n+        }\n+    }\n+\n+    private static void normalExec() throws Exception {\n+        ProcessBuilder pb;\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Djdk.lang.Process.launchMechanism=posix_spawn\",\n+                                                   \"JspawnhelperProtocol\",\n+                                                   \"normalExec\");\n+        pb.inheritIO();\n+        Process p = pb.start();\n+        if (!p.waitFor(TIMEOUT, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Parent process timed out\");\n+        }\n+        if (p.exitValue() != 0) {\n+            throw new Exception(\"Parent process exited with \" + p.exitValue());\n+        }\n+    }\n+\n+    private static void simulateCrashInChild(int stage) throws Exception {\n+        ProcessBuilder pb;\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Djdk.lang.Process.launchMechanism=posix_spawn\",\n+                                                   \"JspawnhelperProtocol\",\n+                                                   \"simulateCrashInChild\" + stage);\n+        pb.environment().put(ENV_KEY, Integer.toString(stage));\n+        Process p = pb.start();\n+\n+        boolean foundCrashInfo = false;\n+        try (BufferedReader br = p.inputReader()) {\n+            String line = br.readLine();\n+            while (line != null) {\n+                System.out.println(line);\n+                if (line.equals(\"posix_spawn:0\")) {\n+                    foundCrashInfo = true;\n+                }\n+                line = br.readLine();\n+            }\n+        }\n+        if (!foundCrashInfo) {\n+            throw new Exception(\"Wrong output from child process\");\n+        }\n+        if (!p.waitFor(TIMEOUT, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Parent process timed out\");\n+        }\n+\n+        int ret = p.exitValue();\n+        if (ret == 0) {\n+            throw new Exception(\"Expected error during child execution\");\n+        }\n+        System.out.println(\"Parent exit code: \" + ret);\n+    }\n+\n+    private static void simulateCrashInParent(int stage) throws Exception {\n+        ProcessBuilder pb;\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Djdk.lang.Process.launchMechanism=posix_spawn\",\n+                                                   \"JspawnhelperProtocol\",\n+                                                   \"simulateCrashInParent\" + stage);\n+        pb.environment().put(ENV_KEY, Integer.toString(stage));\n+        Process p = pb.start();\n+\n+        String line = null;\n+        try (BufferedReader br = p.inputReader()) {\n+            line = br.readLine();\n+            while (line != null && !line.startsWith(\"posix_spawn:\")) {\n+                System.out.println(line);\n+                line = br.readLine();\n+            }\n+        }\n+        if (line == null) {\n+            throw new Exception(\"Wrong output from parent process\");\n+        }\n+        System.out.println(line);\n+        long childPid = Integer.parseInt(line.substring(line.indexOf(':') + 1));\n+\n+        if (!p.waitFor(TIMEOUT, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Parent process timed out\");\n+        }\n+\n+        Optional<ProcessHandle> oph = ProcessHandle.of(childPid);\n+        if (!oph.isEmpty()) {\n+            ProcessHandle ph = oph.get();\n+            try {\n+                \/\/ Give jspawnhelper a chance to exit gracefully\n+                ph.onExit().get(TIMEOUT, TimeUnit.SECONDS);\n+            } catch (TimeoutException te) {\n+                Optional<String> cmd = ph.info().command();\n+                if (cmd.isPresent() && cmd.get().endsWith(\"jspawnhelper\")) {\n+                    throw new Exception(\"jspawnhelper still alive after parent Java process terminated\");\n+                }\n+            }\n+        }\n+        int ret = p.exitValue();\n+        if (ret != stage) {\n+            throw new Exception(\"Expected exit code \" + stage + \" but got \" + ret);\n+        }\n+        System.out.println(\"Parent exit code: \" + ret);\n+    }\n+\n+    private static void simulateTruncatedWriteInParent(int stage) throws Exception {\n+        ProcessBuilder pb;\n+        pb = ProcessTools.createJavaProcessBuilder(\"-Djdk.lang.Process.launchMechanism=posix_spawn\",\n+                                                   \"JspawnhelperProtocol\",\n+                                                   \"simulateTruncatedWriteInParent\" + stage);\n+        pb.environment().put(ENV_KEY, Integer.toString(stage));\n+        Process p = pb.start();\n+\n+        BufferedReader br = p.inputReader();\n+        String line = br.readLine();\n+        while (line != null && !line.startsWith(\"posix_spawn:\")) {\n+            System.out.println(line);\n+            line = br.readLine();\n+        }\n+        if (line == null) {\n+            throw new Exception(\"Wrong output from parent process\");\n+        }\n+        System.out.println(line);\n+\n+        if (!p.waitFor(TIMEOUT, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Parent process timed out\");\n+        }\n+        line = br.readLine();\n+        while (line != null) {\n+            System.out.println(line);\n+            line = br.readLine();\n+        }\n+\n+        int ret = p.exitValue();\n+        if (ret != ERROR) {\n+            throw new Exception(\"Expected exit code \" + ERROR + \" but got \" + ret);\n+        }\n+        System.out.println(\"Parent exit code: \" + ret);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ This test works as follows:\n+        \/\/  - jtreg executes the test class `JspawnhelperProtocol` without arguments.\n+        \/\/    This is the initial \"grandparent\" process.\n+        \/\/  - For each sub-test (i.e. `normalExec()`, `simulateCrashInParent()` and\n+        \/\/    `simulateCrashInChild()`), a new sub-process (called the \"parent\") will be\n+        \/\/    forked which executes `JspawnhelperProtocol` recursively with a corresponding\n+        \/\/    command line argument.\n+        \/\/  - The forked `JspawnhelperProtocol` process (i.e. the \"parent\") runs\n+        \/\/    `JspawnhelperProtocol::parentCode()` which forks off yet another sub-process\n+        \/\/    (called the \"child\").\n+        \/\/  - The sub-tests in the \"grandparent\" check that various abnormal program\n+        \/\/    terminations in the \"parent\" or the \"child\" process are handled gracefully and\n+        \/\/    don't lead to deadlocks or zombie processes.\n+        if (args.length > 0) {\n+            \/\/ Entry point for recursive execution in the \"parent\" process\n+            parentCode(args[0]);\n+        } else {\n+            \/\/ Main test entry for execution from jtreg\n+            normalExec();\n+            simulateCrashInParent(1);\n+            simulateCrashInParent(2);\n+            simulateCrashInParent(3);\n+            simulateCrashInChild(4);\n+            simulateCrashInChild(5);\n+            simulateCrashInChild(6);\n+            simulateTruncatedWriteInParent(99);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -26,2 +26,2 @@\n- * @summary Stress test ScopedValue with many bindings and rebinings\n- * @modules jdk.incubator.concurrent\n+ * @summary Stress test ScopedValue with many bindings and rebindings\n+ * @enablePreview\n@@ -33,2 +33,1 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.ScopedValue.Carrier;\n+import java.lang.ScopedValue.Carrier;\n@@ -132,1 +131,1 @@\n-        \/\/ check that the scoped values have the origina values\n+        \/\/ check that the scoped values have the original values\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/ManyBindings.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","status":"renamed"},{"patch":"@@ -0,0 +1,561 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ScopedValue API\n+ * @enablePreview\n+ * @run junit ScopedValueAPI\n+ *\/\n+\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ScopedValueAPI {\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n+    }\n+\n+    \/**\n+     * Test that the run method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRun(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class Box { static boolean executed; }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue.runWhere(name, \"duke\", () -> { Box.executed = true; });\n+            assertTrue(Box.executed);\n+        });\n+    }\n+\n+    \/**\n+     * Test the run method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRunThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Runnable op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.runWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test that the call method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCall(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.callWhere(name, \"duke\", name::get);\n+            assertEquals(\"duke\", result);\n+        });\n+    }\n+\n+    \/**\n+     * Test that the get method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGetWhere(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.getWhere(name, \"duke\", (Supplier<String>)(name::get));\n+            assertEquals(\"duke\", result);\n+        });\n+    }\n+\n+    \/**\n+     * Test the call method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCallThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Callable<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.callWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test the get(Supplier) method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGetThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Supplier<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.getWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test get method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ get\n+            ScopedValue.getWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+        });\n+    }\n+\n+    \/**\n+     * Test isBound method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testIsBound(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test orElse method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElse(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertNull(name.orElse(null));\n+            assertEquals(\"default\", name.orElse(\"default\"));\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n+            });\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test orElseThrow method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElseThrow(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException { }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n+            });\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test two bindings.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testTwoBindings(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ get\n+            ScopedValue.where(name, \"duke\").where(age, 100).get(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebinding(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.callWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ get\n+            ScopedValue.getWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.where(name, \"duchess\").get(() -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding from null vaue to another value.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.callWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ getWhere\n+            ScopedValue.getWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.getWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding to null value.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingToNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.runWhere(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.callWhere(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ get\n+            ScopedValue.where(name, \"duke\").get(() -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.where(name, null).get(() -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test Carrier.get.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCarrierGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ one scoped value\n+            var carrier1 = ScopedValue.where(name, \"duke\");\n+            assertEquals(\"duke\", carrier1.get(name));\n+            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n+\n+            \/\/ two scoped values\n+            var carrier2 = carrier1.where(age, 20);\n+            assertEquals(\"duke\", carrier2.get(name));\n+            assertEquals(20, (int) carrier2.get(age));\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    @Test\n+    void testNullPointerException() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.runWhere(null, \"value\", () -> { }));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.getWhere(null, \"value\", () -> null));\n+\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+\n+        var carrier = ScopedValue.where(name, \"duke\");\n+        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> carrier.get((ScopedValue<?>)null));\n+        assertThrows(NullPointerException.class, () -> carrier.get((Supplier<?>)null));\n+        assertThrows(NullPointerException.class, () -> carrier.run(null));\n+        assertThrows(NullPointerException.class, () -> carrier.call(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Run the given task in a thread created with the given thread factory.\n+     * @throws Exception if the task throws an exception\n+     *\/\n+    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n+        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+            var future = executor.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+            try {\n+                future.get();\n+            } catch (ExecutionException ee) {\n+                Throwable cause = ee.getCause();\n+                if (cause instanceof Exception e)\n+                    throw e;\n+                if (cause instanceof Error e)\n+                    throw e;\n+                throw new RuntimeException(cause);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/ScopedValueAPI.java","additions":561,"deletions":0,"binary":false,"changes":561,"status":"added"},{"patch":"@@ -27,2 +27,1 @@\n- * @modules jdk.incubator.concurrent\n- * @compile StressStackOverflow.java\n+ * @enablePreview\n@@ -37,3 +36,3 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.function.Supplier;\n@@ -56,1 +55,9 @@\n-    class DeepRecursion implements Callable, Runnable {\n+    class DeepRecursion implements Callable, Supplier, Runnable {\n+\n+        static enum Behaviour {\n+            CALL, GET, RUN;\n+            private static Behaviour[] values = values();\n+            public static Behaviour choose(ThreadLocalRandom tlr) {\n+                return values[tlr.nextInt(3)];\n+            }\n+        }\n@@ -58,1 +65,0 @@\n-        static enum Behaviour {CALL, RUN}\n@@ -73,0 +79,2 @@\n+                    case GET ->\n+                        ScopedValue.where(el, el.get() + 1).get(() -> fibonacci_pad(20, this));\n@@ -99,1 +107,1 @@\n-        public Object call() {\n+        public Object get() {\n@@ -103,0 +111,4 @@\n+\n+        public Object call() {\n+            return get();\n+        }\n@@ -145,1 +157,1 @@\n-            var future = scope.fork(() -> {\n+            var handle = scope.fork(() -> {\n@@ -149,1 +161,0 @@\n-            future.get();\n@@ -151,0 +162,1 @@\n+            handle.get();\n@@ -162,1 +174,1 @@\n-                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call() and ScopedValue::run()\n+                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call(), get(), and run()\n@@ -164,1 +176,1 @@\n-                                    = new DeepRecursion(tlr.nextBoolean() ? DeepRecursion.Behaviour.CALL : DeepRecursion.Behaviour.RUN);\n+                                = new DeepRecursion(DeepRecursion.Behaviour.choose(tlr));\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":24,"deletions":12,"binary":false,"changes":36,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java","status":"renamed"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.ArrayList;\n@@ -35,2 +36,1 @@\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -39,3 +39,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertThrows;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -45,0 +43,1 @@\n+ * @bug 8304932\n@@ -118,1 +117,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -120,4 +119,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -147,0 +143,9 @@\n+\n+            \/\/ drop multiple params\n+            for (int j = i; j < paramTypes.length; j++) {\n+                var t = new ArrayList<>(Arrays.asList(paramTypes));\n+                t.subList(i, j).clear();\n+                MethodTypeDesc multiDrop = mtDesc.dropParameterTypes(i, j);\n+                assertEquals(multiDrop, MethodTypeDesc.of(returnType, t.toArray(ClassDesc[]::new)));\n+                testMethodTypeDesc(multiDrop, mt.dropParameterTypes(i, j));\n+            }\n@@ -162,0 +167,15 @@\n+\n+            \/\/ add multiple params\n+            ClassDesc[] addition = {CD_int, CD_String};\n+            var a = new ArrayList<>(Arrays.asList(paramTypes));\n+            a.addAll(i, Arrays.asList(addition));\n+\n+            MethodTypeDesc newDesc = mtDesc.insertParameterTypes(i, addition);\n+            assertEquals(newDesc, MethodTypeDesc.of(returnType, a.toArray(ClassDesc[]::new)));\n+            testMethodTypeDesc(newDesc, mt.insertParameterTypes(i, Arrays.stream(addition).map(d -> {\n+                try {\n+                    return (Class<?>) d.resolveConstantDesc(LOOKUP);\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+            }).toArray(Class[]::new)));\n@@ -172,1 +192,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -174,4 +194,1 @@\n-            fail(\"pos < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -179,1 +196,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -181,4 +198,1 @@\n-            fail(\"pos > current arguments length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -186,1 +200,1 @@\n-        try {\n+        expectThrows(IllegalArgumentException.class, () -> {\n@@ -191,4 +205,1 @@\n-            fail(\"shouldn't allow parameters with class descriptor CD_void\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -196,1 +207,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -199,4 +210,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -204,1 +212,1 @@\n-        try {\n+        expectThrows(NullPointerException.class, () -> {\n@@ -209,4 +217,1 @@\n-            fail(\"should fail with NPE\");\n-        } catch (NullPointerException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -220,1 +225,2 @@\n-        try {\n+\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -222,4 +228,1 @@\n-            fail(\"start index < 0 should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -227,1 +230,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -229,4 +232,1 @@\n-            fail(\"start index = arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -234,1 +234,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -236,4 +236,1 @@\n-            fail(\"start index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -241,1 +238,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -243,4 +240,1 @@\n-            fail(\"end index > arguments.length should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -248,1 +242,1 @@\n-        try {\n+        expectThrows(IndexOutOfBoundsException.class, () -> {\n@@ -250,4 +244,1 @@\n-            fail(\"start index > end index should have failed\");\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ good\n-        }\n+        });\n@@ -277,0 +268,1 @@\n+\n@@ -285,2 +277,0 @@\n-        \/\/ try with void arguments, this will stress another code path in particular\n-        \/\/ ConstantMethodTypeDesc::init\n@@ -294,0 +284,23 @@\n+\n+    public void testOfArrayImmutability() {\n+        ClassDesc[] args = {CD_Object, CD_int};\n+        var mtd = MethodTypeDesc.of(CD_void, args);\n+\n+        args[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+\n+        mtd.parameterArray()[1] = CD_void;\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+    }\n+\n+    public void testOfListImmutability() {\n+        List<ClassDesc> args = Arrays.asList(CD_Object, CD_int);\n+        var mtd = MethodTypeDesc.of(CD_void, args);\n+\n+        args.set(1, CD_void);\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                mtd.parameterList().set(1, CD_void));\n+        assertEquals(mtd, MethodTypeDesc.of(CD_void, CD_Object, CD_int));\n+    }\n","filename":"test\/jdk\/java\/lang\/constant\/MethodTypeDescTest.java","additions":75,"deletions":62,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * Agent used by TraceUsageTest. The premain and agentmain methods invoke Instrumentation\n+ * methods so the usages can be traced by the test.\n+ *\/\n+public class TraceUsageAgent {\n+    public static void premain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    public static void agentmain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    private static void test(String methodNames, Instrumentation inst) throws Exception {\n+        for (String methodName : methodNames.split(\",\")) {\n+            switch (methodName) {\n+                case \"addTransformer\" -> {\n+                    var transformer = new ClassFileTransformer() { };\n+                    inst.addTransformer(transformer);\n+                }\n+                case \"retransformClasses\" -> {\n+                    inst.retransformClasses(Object.class);\n+                }\n+                case \"redefineModule\" -> {\n+                    Module base = Object.class.getModule();\n+                    inst.redefineModule(base, Set.of(), Map.of(), Map.of(), Set.of(), Map.of());\n+                }\n+                default -> {\n+                    throw new RuntimeException(\"Unknown method name: \" + methodName);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageAgent.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307478\n+ * @summary Test Instrumentation tracing is enabled with a system property\n+ * @library \/test\/lib\n+ * @run shell MakeJAR3.sh TraceUsageAgent 'Agent-Class: TraceUsageAgent' 'Can-Retransform-Classes: true'\n+ * @run junit TraceUsageTest\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TraceUsageTest {\n+    private static final String JAVA_AGENT = \"TraceUsageAgent.jar\";\n+\n+    \/\/ Instrumentation methods to test\n+    private static final String[] INSTRUMENTATION_METHODS = {\n+            \"addTransformer\",\n+            \"retransformClasses\",\n+            \"redefineModule\"\n+    };\n+\n+    \/**\n+     * If launched with the argument \"attach\" then it loads the java agent into the\n+     * current VM with the given options.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0 && args[0].equals(\"attach\")) {\n+            String options = args[1];\n+            long pid = ProcessHandle.current().pid();\n+            VirtualMachine vm = VirtualMachine.attach(\"\"+pid);\n+            try {\n+                vm.loadAgent(JAVA_AGENT, options);\n+            } finally {\n+                vm.detach();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test agent started on the command line with -javaagent.\n+     *\/\n+    @Test\n+    void testPremain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-javaagent:\" + JAVA_AGENT + \"=\" + String.join(\",\", INSTRUMENTATION_METHODS),\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\"\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.premain\");\n+    }\n+\n+    \/**\n+     * Test agent loaded into a running VM with the attach mechanism.\n+     *\/\n+    @Test\n+    void testAgentmain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-Djdk.attach.allowAttachSelf=true\",\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\",\n+                \"attach\",\n+                String.join(\",\", INSTRUMENTATION_METHODS)\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.agentmain\");\n+    }\n+\n+    private OutputAnalyzer execute(String... command) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        assertEquals(0, outputAnalyzer.getExitValue());\n+        return outputAnalyzer;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307944\n+ * @library \/test\/lib\n+ * @build DumpMethodHandleInternals\n+ * @run main DumpMethodHandleInternals\n+\n+ * @summary Test startup with -Djdk.invoke.MethodHandle.dumpMethodHandleInternals\n+ *          to work properly\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DumpMethodHandleInternals {\n+\n+    private static final Path DUMP_DIR = Path.of(\"DUMP_METHOD_HANDLE_INTERNALS\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (ProcessTools.executeTestJava(\"-Djdk.invoke.MethodHandle.dumpMethodHandleInternals\",\n+                                         \"-version\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue() != 0)\n+            throw new RuntimeException(\"Test failed - see output\");\n+\n+        if (Files.notExists(DUMP_DIR))\n+            throw new RuntimeException(DUMP_DIR + \" not created\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/DumpMethodHandleInternals.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,6 +190,1 @@\n-        \/\/ ##### FIXME - disable tests for clone until we figure out how they should work with modules\n-\n-        \/*\n-        testFindVirtual(true, PUBLIC, Object[].class, Object.class, \"clone\");\n-        testFindVirtual(true, PUBLIC, int[].class, Object.class, \"clone\");\n-        for (Class<?> cls : new Class<?>[]{ boolean[].class, long[].class, float[].class, char[].class })\n+        for (Class<?> cls : new Class<?>[]{ Object[].class, int[].class, boolean[].class, long[].class, float[].class, char[].class }) {\n@@ -197,1 +192,1 @@\n-         *\/\n+        }\n@@ -267,2 +262,2 @@\n-            if (res instanceof Object[])\n-                assertArrayEquals((Object[])res, (Object[])argsWithSelf[0]);\n+            if (res instanceof Object[] arr)\n+                assertArrayEquals(arr, (Object[])argsWithSelf[0]);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesGeneralTest.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8301721\n+ * @library \/test\/lib\n+ * @run main FindSpecialObjectMethod\n+ * @summary Test findSpecial on Object methods calling from a class or interface.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Objects;\n+\n+import static java.lang.invoke.MethodType.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+public class FindSpecialObjectMethod {\n+    static class C {\n+        public static Object test(C o) throws Throwable {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodHandle mh = lookup.findSpecial(Object.class, \"toString\", methodType(String.class), C.class);\n+            return mh.invoke(o);\n+        }\n+\n+        public String toString() {\n+            return \"C\";\n+        }\n+    }\n+\n+    interface I {\n+        static Object test(I o) throws Throwable {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodHandle mh = lookup.findSpecial(Object.class, \"toString\", methodType(String.class), I.class);\n+            return mh.invoke(o);\n+        }\n+\n+        static void noAccess() throws Throwable {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                MethodHandle mh = lookup.findSpecial(String.class, \"hashCode\", methodType(int.class), I.class);\n+                throw new RuntimeException(\"IllegalAccessException not thrown\");\n+            } catch (IllegalAccessException ex) {}\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        \/\/ Object.toString can be called from invokespecial from within\n+        \/\/ a special caller class C or interface I\n+        C c = new C();\n+        I i = new I() {};\n+        assertEquals(C.test(c), Objects.toIdentityString(c));\n+        assertEquals(I.test(i), Objects.toIdentityString(i));\n+\n+        \/\/ I has no access to methods in other class besides Object\n+        I.noAccess();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/findSpecial\/FindSpecialObjectMethod.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299505\n+ * @run junit FindVirtualArrayCloneTest\n+ * @summary Test invocation of Object.clone for arrays\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class FindVirtualArrayCloneTest {\n+\n+    \/**\n+     * array clone should be bound to the array class (public)\n+     *\/\n+    @ValueSource(classes = {Object[].class, int[].class, long[].class, byte[].class, double[].class})\n+    @ParameterizedTest\n+    public void checkArrayCloneReceiver(Class<?> arrayClass) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var cloneMh = lookup.findVirtual(arrayClass, \"clone\", MethodType.methodType(Object.class));\n+        assertSame(arrayClass, cloneMh.type().parameterType(0));\n+    }\n+\n+    \/**\n+     * Object.clone should be bound to the lookup class (protected)\n+     *\/\n+    @Test\n+    public void checkProtectedCloneReceiver() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var cloneMh = lookup.findVirtual(Object.class, \"clone\", MethodType.methodType(Object.class));\n+        assertSame(lookup.lookupClass(), cloneMh.type().parameterType(0));\n+    }\n+\n+    @Test\n+    public void checkArrayClone() throws Throwable {\n+        var array = new String[] {\"apple\", \"pear\", \"banana\"};\n+        var regularClone = array.clone();\n+        var cloneMh = MethodHandles.lookup()\n+                .findVirtual(String[].class, \"clone\", MethodType.methodType(Object.class))\n+                .asType(MethodType.methodType(String[].class, String[].class));\n+        var mhClone = (String[]) cloneMh.invokeExact((String[]) array);\n+        assertArrayEquals(array, mhClone);\n+        assertArrayEquals(regularClone, mhClone);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/findVirtual\/FindVirtualArrayCloneTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -178,1 +178,1 @@\n-                                  .filter(s -> s.contains(\"java.nio.file.FileAlreadyExistsException\"))\n+                                  .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not a directory\"))\n@@ -181,1 +181,1 @@\n-        assertTrue(tr.exitValue !=0);\n+        assertTrue(tr.exitValue != 0);\n@@ -240,1 +240,1 @@\n-                                      .filter(s -> s.contains(\"is not writable\"))\n+                                      .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not writable\"))\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+        testType(\"\", 0, 0);\n@@ -134,0 +135,6 @@\n+        testEnum(E1.B, 0, 0, \"B\", \"A\");\n+        testEnum(E1.A, 0, 1, \"B\", \"A\");\n+        testEnum(E1.A, 0, 0, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 1, 1, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 2, 3, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 0, 0);\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1026,3 +1026,4 @@\n-                            int c;\n-                            while ((c = is.read()) != -1) {\n-                                os.write(c);\n+                            int len;\n+                            byte[] buf = new byte[16 * 1024];\n+                            while ((len = is.read(buf)) != -1) {\n+                                os.write(buf, 0, len);\n@@ -1032,1 +1033,1 @@\n-                                if (DEBUG) System.out.print(tag);\n+                                if (DEBUG) System.out.print(String.valueOf(tag).repeat(len));\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPTestServer.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8267140\n+ * @bug 8267140 8309120\n@@ -142,0 +142,2 @@\n+        \/\/ exception from cancelling an HTTP\/2 stream\n+        if (message.matches(\"Stream [0-9]+ cancelled\")) return true;\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncShutdownNow.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-            .newBuilder(new URI(\"http:\/\/hg.openjdk.java.net\/jdk9\/sandbox\/jdk\/shortlog\/http-client-branch\/\"))\n+            .newBuilder(new URI(\"https:\/\/hg.openjdk.org\/jdk9\/sandbox\/jdk\/shortlog\/http-client-branch\/\"))\n","filename":"test\/jdk\/java\/net\/httpclient\/BodyProcessorInputStreamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1446,1 +1446,2 @@\n-                        int c = 0;\n+                        int len = 0;\n+                        byte[] buf = new byte[16 * 1024];\n@@ -1448,2 +1449,2 @@\n-                            while ((c = is.read()) != -1) {\n-                                os.write(c);\n+                            while ((len = is.read(buf)) != -1) {\n+                                os.write(buf, 0, len);\n@@ -1453,1 +1454,1 @@\n-                                if (DEBUG) System.out.print(tag);\n+                                if (DEBUG) System.out.print(String.valueOf(tag).repeat(len));\n@@ -1457,1 +1458,1 @@\n-                            if (DEBUG || !stopped && c >  -1)\n+                            if (DEBUG || !stopped && len > -1)\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoServer.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8286171\n+ * @bug 8286171 8307648\n@@ -59,0 +59,1 @@\n+import java.net.http.HttpClient.Builder;\n@@ -109,0 +110,4 @@\n+        System.out.println(\"HTTP\/1.1 server listening at: \" + http1TestServer.serverAuthority());\n+        System.out.println(\"HTTP\/1.1 hang server listening at: \" + hangUri.getRawAuthority());\n+        System.out.println(\"HTTP\/2 clear server listening at: \" + http2TestServer.serverAuthority());\n+\n@@ -127,0 +132,1 @@\n+                System.err.println(\"Server reading body\");\n@@ -129,0 +135,1 @@\n+                System.err.println(\"Server sending 200  (length=\"+bytes.length+\")\");\n@@ -142,0 +149,1 @@\n+                System.err.println(\"Server sending 100 (length = 0)\");\n@@ -148,0 +156,1 @@\n+                System.err.println(\"Server reading body\");\n@@ -149,0 +158,1 @@\n+                System.err.println(\"Server send 200 (length=0)\");\n@@ -162,0 +172,1 @@\n+                System.err.println(\"Server send 417 (length=\"+bytes.length+\")\");\n@@ -187,0 +198,1 @@\n+            boolean closed = this.closed;\n@@ -191,1 +203,3 @@\n-                    client = ss.accept();\n+                    System.err.println(\"Http1HangServer accepting connections\");\n+                    var client = this.client = ss.accept();\n+                    System.err.println(\"Http1HangServer accepted connection: \" + client);\n@@ -216,1 +230,2 @@\n-                        closed = true;\n+                        System.err.println(\"Http1HangServer sending 417\");\n+                        closed = this.closed = true;\n@@ -227,0 +242,1 @@\n+                        System.err.println(\"Http1HangServer received invalid request: closing\");\n@@ -230,1 +246,1 @@\n-                    closed = true;\n+                    closed = this.closed = true;\n@@ -232,0 +248,6 @@\n+                } finally {\n+                    if (closed = this.closed) {\n+                        System.err.println(\"Http1HangServer: finished\");\n+                    } else {\n+                        System.err.println(\"Http1HangServer: looping for accepting next connection\");\n+                    }\n@@ -238,0 +260,1 @@\n+            var client = this.client;\n@@ -247,1 +270,1 @@\n-                { h2getUri,  h2postUri, h2hangUri, HttpClient.Version.HTTP_2 }\n+                { h2getUri,  h2postUri, h2hangUri, HTTP_2 }\n@@ -253,0 +276,1 @@\n+        System.out.println(\"Testing with version: \" + version);\n@@ -254,0 +278,1 @@\n+                .proxy(Builder.NO_PROXY)\n@@ -271,0 +296,2 @@\n+        System.out.printf(\"Sending request (%s): %s%n\", version, getRequest);\n+        System.err.println(\"Sending request: \" + getRequest);\n@@ -277,0 +304,2 @@\n+        System.out.printf(\"Sending request (%s): %s%n\", version, postRequest);\n+        System.err.println(\"Sending request: \" + postRequest);\n@@ -283,0 +312,2 @@\n+        System.out.printf(\"Sending request (%s): %s%n\", version, hangRequest);\n+        System.err.println(\"Sending request: \" + hangRequest);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,1 +289,1 @@\n-            .newBuilder(new URI(\"http:\/\/hg.openjdk.java.net\/jdk9\/sandbox\/jdk\/shortlog\/http-client-branch\/\"))\n+            .newBuilder(new URI(\"https:\/\/hg.openjdk.org\/jdk9\/sandbox\/jdk\/shortlog\/http-client-branch\/\"))\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpInputStreamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,3 +259,4 @@\n-                            int c;\n-                            while ((c = is.read()) != -1) {\n-                                os.write(c);\n+                            int len;\n+                            byte[] buf = new byte[16 * 1024];\n+                            while ((len = is.read(buf)) != -1) {\n+                                os.write(buf, 0, len);\n@@ -265,1 +266,1 @@\n-                                if (DEBUG) System.out.print(tag);\n+                                if (DEBUG) System.out.print(String.valueOf(tag).repeat(len));\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        if (message.matches(\"stream [0-9]+ cancelled\")) return true;\n+        if (message.matches(\"Stream [0-9]+ cancelled\")) return true;\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8305906\n+ * @summary verify that the HttpClient pools and reuses a connection for HTTP\/2 requests\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.test.lib.net.IPSupport\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *\n+ * @run junit ConnectionReuseTest\n+ * @run junit\/othervm -Djava.net.preferIPv6Addresses=true\n+ *                    -Djdk.internal.httpclient.debug=true ConnectionReuseTest\n+ *\/\n+public class ConnectionReuseTest {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer http2_Server; \/\/ h2 server over HTTP\n+    private static HttpTestServer https2_Server; \/\/ h2 server over HTTPS\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        if (IPSupport.preferIPv6Addresses()) {\n+            IPSupport.printPlatformSupport(System.err); \/\/ for debug purposes\n+            \/\/ this test is run with -Djava.net.preferIPv6Addresses=true, so skip (all) tests\n+            \/\/ if IPv6 isn't supported on this host\n+            Assumptions.assumeTrue(IPSupport.hasIPv6(), \"Skipping tests - IPv6 is not supported\");\n+        }\n+        sslContext = new SimpleSSLContext().get();\n+        assertNotNull(sslContext, \"Unexpected null sslContext\");\n+\n+        http2_Server = HttpTestServer.create(HTTP_2);\n+        http2_Server.addHandler(new Handler(), \"\/\");\n+        http2_Server.start();\n+        System.out.println(\"Started HTTP v2 server at \" + http2_Server.serverAuthority());\n+\n+        https2_Server = HttpTestServer.create(HTTP_2, sslContext);\n+        https2_Server.addHandler(new Handler(), \"\/\");\n+        https2_Server.start();\n+        System.out.println(\"Started HTTPS v2 server at \" + https2_Server.serverAuthority());\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() {\n+        if (https2_Server != null) {\n+            System.out.println(\"Stopping server \" + https2_Server);\n+            https2_Server.stop();\n+        }\n+        if (http2_Server != null) {\n+            System.out.println(\"Stopping server \" + http2_Server);\n+            http2_Server.stop();\n+        }\n+    }\n+\n+    private static Stream<Arguments> requestURIs() throws Exception {\n+        final List<Arguments> arguments = new ArrayList<>();\n+        \/\/ h2 over HTTPS\n+        arguments.add(Arguments.of(new URI(\"https:\/\/\" + https2_Server.serverAuthority() + \"\/\")));\n+        \/\/ h2 over HTTP\n+        arguments.add(Arguments.of(new URI(\"http:\/\/\" + http2_Server.serverAuthority() + \"\/\")));\n+        if (IPSupport.preferIPv6Addresses()) {\n+            if (https2_Server.getAddress().getAddress().isLoopbackAddress()) {\n+                \/\/ h2 over HTTPS, use the short form of the host, in the request URI\n+                arguments.add(Arguments.of(new URI(\"https:\/\/[::1]:\" +\n+                        https2_Server.getAddress().getPort() + \"\/\")));\n+            }\n+            if (http2_Server.getAddress().getAddress().isLoopbackAddress()) {\n+                \/\/ h2 over HTTP, use the short form of the host, in the request URI\n+                arguments.add(Arguments.of(new URI(\"http:\/\/[::1]:\" +\n+                        http2_Server.getAddress().getPort() + \"\/\")));\n+            }\n+        }\n+        return arguments.stream();\n+    }\n+\n+    \/**\n+     * Uses a single instance of a HttpClient and issues multiple requests to {@code requestURI}\n+     * and expects that each of the request internally uses the same connection\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"requestURIs\")\n+    public void testConnReuse(final URI requestURI) throws Exception {\n+        final HttpClient.Builder builder = HttpClient.newBuilder()\n+                .proxy(NO_PROXY).sslContext(sslContext);\n+        final HttpRequest req = HttpRequest.newBuilder().uri(requestURI)\n+                .GET().version(HTTP_2).build();\n+        try (final HttpClient client = builder.build()) {\n+            String clientConnAddr = null;\n+            for (int i = 1; i <= 5; i++) {\n+                System.out.println(\"Issuing request(\" + i + \") \" + req);\n+                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                assertEquals(200, resp.statusCode(), \"unexpected response code\");\n+                final String respBody = resp.body();\n+                System.out.println(\"Server side handler responded to a request from \" + respBody);\n+                assertNotEquals(Handler.UNKNOWN_CLIENT_ADDR, respBody,\n+                        \"server handler couldn't determine client address in request\");\n+                if (i == 1) {\n+                    \/\/ for the first request we just keep track of the client connection address\n+                    \/\/ that got used for this request\n+                    clientConnAddr = respBody;\n+                } else {\n+                    \/\/ verify that the client connection used to issue the request is the same\n+                    \/\/ as the previous request's client connection\n+                    assertEquals(clientConnAddr, respBody, \"HttpClient unexpectedly used a\" +\n+                            \" different connection for request(\" + i + \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        private static final String UNKNOWN_CLIENT_ADDR = \"unknown\";\n+\n+        @Override\n+        public void handle(final HttpTestExchange t) throws IOException {\n+            final InetSocketAddress clientAddr = t.getRemoteAddress();\n+            System.out.println(\"Handling request \" + t.getRequestURI() + \" from \" + clientAddr);\n+            \/\/ we write out the client address into the response body\n+            final byte[] responseBody = clientAddr == null\n+                    ? UNKNOWN_CLIENT_ADDR.getBytes(StandardCharsets.UTF_8)\n+                    : clientAddr.toString().getBytes(StandardCharsets.UTF_8);\n+            t.sendResponseHeaders(200, responseBody.length);\n+            try (final OutputStream os = t.getResponseBody()) {\n+                os.write(responseBody);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionReuseTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -190,3 +190,4 @@\n-                            int c;\n-                            while ((c = is.read()) != -1) {\n-                                os.write(c);\n+                            int len;\n+                            byte[] buf = new byte[16 * 1024];\n+                            while ((len = is.read(buf)) != -1) {\n+                                os.write(buf, 0, len);\n@@ -196,1 +197,1 @@\n-                                if (DEBUG) System.out.print(tag);\n+                                if (DEBUG) System.out.print(String.valueOf(tag).repeat(len));\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ProxyTest2.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -136,0 +136,3 @@\n+        \/\/ Do not set Content-Length for 100, and do not set END_STREAM\n+        if (rCode == 100) responseLength = 0;\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+grant {\n+    permission java.io.FilePermission \"${java.io.tmpdir}\", \"read,write\";\n+    permission java.io.FilePermission \"${java.io.tmpdir}\/-\", \"read,write,delete\";\n+};\n","filename":"test\/jdk\/java\/nio\/file\/Path\/MacToRealPath.policy","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8308678\n+ * @requires (os.family == \"mac\")\n+ * @summary Verify UnixPath::toRealPath falls back if no perms on macOS\n+ * @run junit\/othervm -Djava.security.manager=allow MacToRealPathWithSM\n+ *\/\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class MacToRealPathWithSM {\n+    private static final String POLICY_FILE = \"MacToRealPath.policy\";\n+\n+    private static Path src;\n+    private static Path path;\n+\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        String testSrc = System.getProperty(\"test.src\");\n+        String tmpDir = System.getProperty(\"java.io.tmpdir\");\n+        if (testSrc == null || tmpDir == null)\n+            throw new RuntimeException(\"This test must be run by jtreg\");\n+        System.out.printf(\"testSrc: %s%ntmpDir:  %s%n\", testSrc, tmpDir);\n+\n+        src = Path.of(testSrc);\n+        Path tmp = Path.of(tmpDir);\n+\n+        path = Files.createTempFile(tmp, \"bonjour\", \".txt\");\n+        path.toFile().deleteOnExit();\n+\n+        \/\/ Write to the path\n+        Files.writeString(path, \"\\nBonjour, tout le monde!\\n\");\n+        System.out.println(Files.readString(path));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", POLICY_FILE})\n+    @SuppressWarnings(\"removal\")\n+    public void testToRealPath(String policyFile) throws IOException {\n+        \/\/ Install security manager with the given policy file\n+        if (!policyFile.isEmpty()) {\n+            System.setProperty(\"java.security.policy\",\n+                src.resolve(policyFile).toString());\n+            System.setSecurityManager(new SecurityManager());\n+        }\n+\n+        \/\/ Derive real path. Without the source change for this issue applied,\n+        \/\/ if a SecurityManager is used which does not grant read permission\n+        \/\/ for traversing \"path\" down from its root, an AccessContolException\n+        \/\/ is thrown by UnixPath::toRealPath\n+        assertDoesNotThrow(() ->\n+            System.out.printf(\"real path: %s%n\", path.toRealPath()),\n+            \"UnixPath::toRealPath() failed\");\n+        assertDoesNotThrow(() ->\n+            System.out.printf(\"real path no follow: %s%n\",\n+                              path.toRealPath(LinkOption.NOFOLLOW_LINKS)),\n+            \"UnixPath::toRealPath(LinkOption.NOFOLLOW_LINKS) failed\");\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/MacToRealPathWithSM.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.KeyStore;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8303465\n+ * @library \/test\/lib\n+ * @requires os.family == \"mac\"\n+ * @summary Check whether loading of certificates from MacOS Keychain correctly\n+ *          honors trust settings\n+ *\/\n+public class CheckMacOSKeyChainTrust {\n+    private static Set<String> trusted = new HashSet<>();\n+    private static Set<String> distrusted = new HashSet<>();\n+\n+    public static void main(String[] args) throws Throwable {\n+        loadUser();\n+        loadAdmin();\n+        System.out.println(\"Trusted Certs: \" + trusted);\n+        System.out.println(\"Distrusted Certs: \" + distrusted);\n+        KeyStore ks = KeyStore.getInstance(\"KEYCHAINSTORE\");\n+        ks.load(null, null);\n+        for (String alias : trusted) {\n+            if (!ks.containsAlias(alias)) {\n+                throw new RuntimeException(\"Not found: \" + alias);\n+            }\n+        }\n+        for (String alias : distrusted) {\n+            if (ks.containsAlias(alias)) {\n+                throw new RuntimeException(\"Found: \" + alias);\n+            }\n+        }\n+    }\n+\n+    private static void loadUser() throws Throwable {\n+        populate(ProcessTools.executeProcess(\"security\", \"dump-trust-settings\"));\n+    }\n+\n+    private static void loadAdmin() throws Throwable {\n+        populate(ProcessTools.executeProcess(\"security\", \"dump-trust-settings\", \"-d\"));\n+    }\n+\n+    private static void populate(OutputAnalyzer output) throws Throwable {\n+        if (output.getExitValue() != 0) {\n+            return; \/\/ No Trust Settings were found\n+        }\n+        String certName = null;\n+        boolean trustRootFound = false;\n+        boolean trustAsRootFound = false;\n+        boolean denyFound = false;\n+        boolean unspecifiedFound = false;\n+        for (String line : output.asLines()) {\n+            if (line.startsWith(\"Cert \")) {\n+                if (certName != null) {\n+                    if (!denyFound &&\n+                        !(unspecifiedFound && !(trustRootFound || trustAsRootFound)) &&\n+                        !distrusted.contains(certName)) {\n+                        trusted.add(certName);\n+                    } else {\n+                        distrusted.add(certName);\n+                        trusted.remove(certName);\n+                    }\n+                }\n+                certName = line.split(\":\", 2)[1].trim().toLowerCase();\n+                trustRootFound = false;\n+                trustAsRootFound = false;\n+                denyFound = false;\n+                unspecifiedFound = false;\n+            } else if (line.contains(\"kSecTrustSettingsResultTrustRoot\")) {\n+                trustRootFound = true;\n+            } else if (line.contains(\"kSecTrustSettingsResultTrustAsRoot\")) {\n+                trustAsRootFound = true;\n+            } else if (line.contains(\"kSecTrustSettingsResultDeny\")) {\n+                denyFound = true;\n+            } else if (line.contains(\"kSecTrustSettingsResultUnspecified\")) {\n+                unspecifiedFound = true;\n+            }\n+        }\n+        if (certName != null) {\n+            if (!denyFound &&\n+                !(unspecifiedFound && !(trustRootFound || trustAsRootFound)) &&\n+                !distrusted.contains(certName)) {\n+                trusted.add(certName);\n+            } else {\n+                distrusted.add(certName);\n+                trusted.remove(certName);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/KeyStore\/CheckMacOSKeyChainTrust.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -26,2 +26,3 @@\n- * @bug 4904074 6328220 6330389\n- * @summary Basic tests for SimpleEntry, SimpleImmutableEntry\n+ * @bug 4904074 6328220 6330389 8308167\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Basic tests for several Map.Entry implementations\n@@ -32,0 +33,1 @@\n+import jdk.internal.util.NullableKeyValueHolder;\n@@ -43,0 +45,3 @@\n+        testEntry(Map.entry(k,v));\n+        testEntry(Map.Entry.copyOf(Map.entry(k,v)));\n+        testEntry(new NullableKeyValueHolder(k,v));\n@@ -45,0 +50,1 @@\n+        testNullEntry(new NullableKeyValueHolder(null,null));\n@@ -55,0 +61,1 @@\n+        check(e.hashCode() == 101575); \/\/ hash(\"foo\") ^ hash(1L)\n@@ -73,0 +80,1 @@\n+        check(e.hashCode() == 0);\n","filename":"test\/jdk\/java\/util\/AbstractMap\/SimpleEntries.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -261,0 +261,10 @@\n+    @DataProvider(name=\"nullableEntries\")\n+    public Iterator<Object[]> nullableEntries() {\n+        return Arrays.asList(\n+            new Object[] { \"firstEntry\" },\n+            new Object[] { \"lastEntry\" },\n+            new Object[] { \"pollFirstEntry\" },\n+            new Object[] { \"pollLastEntry\" }\n+        ).iterator();\n+    }\n+\n@@ -390,0 +400,14 @@\n+\n+        assertEquals(map.keySet().hashCode(), rmap.keySet().hashCode());\n+        assertEquals(map.keySet().hashCode(), map.sequencedKeySet().hashCode());\n+        assertEquals(rmap.keySet().hashCode(), rmap.sequencedKeySet().hashCode());\n+\n+        \/\/ Don't use assertEquals(), as we really want to test the equals() methods.\n+        assertTrue(map.keySet().equals(map.sequencedKeySet()));\n+        assertTrue(map.sequencedKeySet().equals(map.keySet()));\n+        assertTrue(rmap.keySet().equals(map.sequencedKeySet()));\n+        assertTrue(rmap.sequencedKeySet().equals(map.keySet()));\n+        assertTrue(map.keySet().equals(rmap.sequencedKeySet()));\n+        assertTrue(map.sequencedKeySet().equals(rmap.keySet()));\n+        assertTrue(rmap.keySet().equals(rmap.sequencedKeySet()));\n+        assertTrue(rmap.sequencedKeySet().equals(rmap.keySet()));\n@@ -415,0 +439,15 @@\n+\n+        \/\/ No assertions over hashCode(), as Collection inherits Object.hashCode\n+        \/\/ which is usually but not guaranteed to give unequal results.\n+\n+        \/\/ It's permissible for an implementation to return the same instance for values()\n+        \/\/ as for sequencedValues(). Either they're the same instance, or they must be\n+        \/\/ unequal, because distinct collections should always be unequal.\n+\n+        var v = map.values();\n+        var sv = map.sequencedValues();\n+        assertTrue((v == sv) || ! (v.equals(sv) || sv.equals(v)));\n+\n+        var rv = rmap.values();\n+        var rsv = rmap.sequencedValues();\n+        assertTrue((rv == rsv) || ! (rv.equals(rsv) || rsv.equals(rv)));\n@@ -439,0 +478,13 @@\n+\n+        assertEquals(map.entrySet().hashCode(), rmap.entrySet().hashCode());\n+        assertEquals(map.entrySet().hashCode(), map.sequencedEntrySet().hashCode());\n+        assertEquals(map.sequencedEntrySet().hashCode(), map.entrySet().hashCode());\n+\n+        assertTrue(map.entrySet().equals(map.sequencedEntrySet()));\n+        assertTrue(map.sequencedEntrySet().equals(map.entrySet()));\n+        assertTrue(rmap.entrySet().equals(map.sequencedEntrySet()));\n+        assertTrue(rmap.sequencedEntrySet().equals(map.entrySet()));\n+        assertTrue(map.entrySet().equals(rmap.sequencedEntrySet()));\n+        assertTrue(map.sequencedEntrySet().equals(rmap.entrySet()));\n+        assertTrue(rmap.entrySet().equals(rmap.sequencedEntrySet()));\n+        assertTrue(rmap.sequencedEntrySet().equals(rmap.entrySet()));\n@@ -522,0 +574,5 @@\n+    public void checkEntry(Map.Entry<String, Integer> entry, String key, Integer value) {\n+        assertEquals(entry.getKey(), key);\n+        assertEquals(entry.getValue(), value);\n+    }\n+\n@@ -892,0 +949,17 @@\n+\n+    @Test(dataProvider=\"nullableEntries\")\n+    public void testNullableKeyValue(String mode) {\n+        \/\/ TODO this relies on LHM to inherit SequencedMap default\n+        \/\/ methods which are actually being tested here.\n+        SequencedMap<String, Integer> map = new LinkedHashMap<>();\n+        map.put(null, 1);\n+        map.put(\"two\", null);\n+\n+        switch (mode) {\n+            case \"firstEntry\"     -> checkEntry(map.firstEntry(), null, 1);\n+            case \"lastEntry\"      -> checkEntry(map.lastEntry(), \"two\", null);\n+            case \"pollFirstEntry\" -> checkEntry(map.pollFirstEntry(), null, 1);\n+            case \"pollLastEntry\"  -> checkEntry(map.pollLastEntry(), \"two\", null);\n+            default               -> throw new AssertionError(\"illegal mode \" + mode);\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/SequencedCollection\/BasicMap.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4173528 5068772 8148936 8196334\n+ * @bug 4173528 5068772 8148936 8196334 8308803\n@@ -28,2 +28,4 @@\n- * @run main\/othervm -XX:+CompactStrings UUIDTest\n- * @run main\/othervm -XX:-CompactStrings UUIDTest\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main\/othervm -Xmx1g -XX:+CompactStrings UUIDTest\n+ * @run main\/othervm -Xmx1g -XX:-CompactStrings UUIDTest\n@@ -33,0 +35,2 @@\n+import java.util.stream.IntStream;\n+import jdk.test.lib.RandomFactory;\n@@ -36,1 +40,4 @@\n-    static Random generator = new Random();\n+    \/\/ Single UUID instance is ~32 bytes, 1M instances take ~256M in the set\n+    private static final int COUNT = 1_000_000;\n+\n+    static final Random generator = RandomFactory.getRandom();\n@@ -39,1 +46,1 @@\n-        containsTest();\n+        negativeTest();\n@@ -41,0 +48,1 @@\n+        randomUUIDTest_Multi();\n@@ -52,6 +60,6 @@\n-    \/\/ Verify that list.contains detects UUID collisons\n-    private static void containsTest() throws Exception {\n-        List list = new LinkedList();\n-        list.add(new UUID(4,4));\n-        if (!list.contains(new UUID(4,4)))\n-            throw new Exception(\"contains test did not work as expected\");\n+    private static void negativeTest() throws Exception {\n+        Set<UUID> set = new HashSet<>();\n+        set.add(new UUID(4, 4));\n+        if (set.add(new UUID(4, 4))) {\n+            throw new Exception(\"Contains test does not work as expected\");\n+        }\n@@ -61,5 +69,38 @@\n-        List list = new LinkedList();\n-        for (int i=0; i<100; i++) {\n-            UUID u1 = UUID.randomUUID();\n-            if (4 != u1.version()) {\n-                throw new Exception(\"bad version\");\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            UUID u = UUID.randomUUID();\n+            if (u.version() != 4) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n+            }\n+            if (!set.add(u)) {\n+                collisions.add(u);\n+            }\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+           \/\/ This is extremely unlikely to happen. If you see this failure,\n+           \/\/ this highly likely points to the implementation bug, rather than\n+           \/\/ the odd chance.\n+           throw new Exception(\"UUID collisions detected: \" + collisions);\n+        }\n+    }\n+\n+    private static void randomUUIDTest_Multi() throws Exception {\n+        List<UUID> uuids = IntStream.range(0, COUNT).parallel()\n+                                    .mapToObj(i -> UUID.randomUUID())\n+                                    .toList();\n+\n+        List<UUID> collisions = new ArrayList<>();\n+\n+        Set<UUID> set = new HashSet<>();\n+        for (UUID u : uuids) {\n+            if (u.version() != 4) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n@@ -67,2 +108,2 @@\n-            if (2 != u1.variant()) {\n-                throw new Exception(\"bad variant\");\n+            if (!set.add(u)) {\n+                collisions.add(u);\n@@ -70,3 +111,7 @@\n-            if (list.contains(u1))\n-                throw new Exception(\"random UUID collision very unlikely\");\n-            list.add(u1);\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+           \/\/ This is extremely unlikely to happen. If you see this failure,\n+           \/\/ this highly likely points to the implementation bug, rather than\n+           \/\/ the odd chance.\n+           throw new Exception(\"UUID collisions detected: \" + collisions);\n@@ -76,0 +121,1 @@\n+\n@@ -77,1 +123,2 @@\n-        Random byteSource = new Random();\n+        List<UUID> collisions = new ArrayList<>();\n+\n@@ -79,6 +126,9 @@\n-        List list = new LinkedList();\n-        for (int i=0; i<100; i++) {\n-            byteSource.nextBytes(someBytes);\n-            UUID u1 = UUID.nameUUIDFromBytes(someBytes);\n-            if (3 != u1.version()) {\n-                throw new Exception(\"bad version\");\n+        Set<UUID> set = new HashSet<>();\n+        for (int i = 0; i < COUNT; i++) {\n+            generator.nextBytes(someBytes);\n+            UUID u = UUID.nameUUIDFromBytes(someBytes);\n+            if (u.version() != 3) {\n+                throw new Exception(\"Bad version: \" + u);\n+            }\n+            if (u.variant() != 2) {\n+                throw new Exception(\"Bad variant: \" + u);\n@@ -86,2 +136,2 @@\n-            if (2 != u1.variant()) {\n-                throw new Exception(\"bad variant\");\n+            if (!set.add(u)) {\n+                collisions.add(u);\n@@ -89,3 +139,7 @@\n-            if (list.contains(u1))\n-                throw new Exception(\"byte UUID collision very unlikely\");\n-            list.add(u1);\n+        }\n+\n+        if (!collisions.isEmpty()) {\n+           \/\/ This is extremely unlikely to happen. If you see this failure,\n+           \/\/ this highly likely points to the implementation bug, rather than\n+           \/\/ the odd chance.\n+           throw new Exception(\"UUID collisions detected: \" + collisions);\n@@ -96,1 +150,1 @@\n-        for (int i=0; i<100; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -100,2 +154,3 @@\n-            if (!u1.equals(u2) || !u1.equals(u3))\n-                throw new Exception(\"UUID -> string -> UUID failed\");\n+            if (!u1.equals(u2) || !u1.equals(u3)) {\n+                throw new Exception(\"UUID -> string -> UUID failed: \" + u1 + \" -> \" + u2 + \" -> \" + u3);\n+            }\n@@ -124,3 +179,4 @@\n-        if (test.version() != 4)\n-            throw new Exception(\"randomUUID not type 4\");\n-        Random byteSource = new Random();\n+        if (test.version() != 4) {\n+            throw new Exception(\"randomUUID not type 4: \" + test);\n+        }\n+\n@@ -128,1 +184,1 @@\n-        byteSource.nextBytes(someBytes);\n+        generator.nextBytes(someBytes);\n@@ -130,2 +186,4 @@\n-        if (test.version() != 3)\n-            throw new Exception(\"nameUUIDFromBytes not type 3\");\n+        if (test.version() != 3) {\n+            throw new Exception(\"nameUUIDFromBytes not type 3: \" + test);\n+        }\n+\n@@ -133,1 +191,1 @@\n-        if (test.version() != 1)\n+        if (test.version() != 1) {\n@@ -135,0 +193,2 @@\n+        }\n+\n@@ -136,1 +196,1 @@\n-        if (test.version() != 2)\n+        if (test.version() != 2) {\n@@ -138,0 +198,2 @@\n+        }\n+\n@@ -139,1 +201,1 @@\n-        if (test.version() != 3)\n+        if (test.version() != 3) {\n@@ -141,0 +203,2 @@\n+        }\n+\n@@ -142,1 +206,1 @@\n-        if (test.version() != 4)\n+        if (test.version() != 4) {\n@@ -144,0 +208,2 @@\n+        }\n+\n@@ -145,1 +211,1 @@\n-        if (test.version() != 1)\n+        if (test.version() != 1) {\n@@ -147,0 +213,2 @@\n+        }\n+\n@@ -148,1 +216,1 @@\n-        if (test.version() != 2)\n+        if (test.version() != 2) {\n@@ -150,0 +218,2 @@\n+        }\n+\n@@ -151,1 +221,1 @@\n-        if (test.version() != 3)\n+        if (test.version() != 3) {\n@@ -153,0 +223,2 @@\n+        }\n+\n@@ -154,1 +226,1 @@\n-        if (test.version() != 4)\n+        if (test.version() != 4) {\n@@ -156,0 +228,1 @@\n+        }\n@@ -160,1 +233,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -162,1 +235,2 @@\n-        Random byteSource = new Random();\n+        }\n+\n@@ -164,1 +238,1 @@\n-        byteSource.nextBytes(someBytes);\n+        generator.nextBytes(someBytes);\n@@ -166,1 +240,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -168,0 +242,2 @@\n+        }\n+\n@@ -169,1 +245,1 @@\n-        if (test.variant() != 0)\n+        if (test.variant() != 0) {\n@@ -171,0 +247,2 @@\n+        }\n+\n@@ -172,1 +250,1 @@\n-        if (test.variant() != 2)\n+        if (test.variant() != 2) {\n@@ -174,2 +252,4 @@\n-       test = new UUID(55L, 0xc000000000001000L);\n-        if (test.variant() != 6)\n+        }\n+\n+        test = new UUID(55L, 0xc000000000001000L);\n+        if (test.variant() != 6) {\n@@ -177,2 +257,4 @@\n-       test = new UUID(55L, 0xe000000000001000L);\n-        if (test.variant() != 7)\n+        }\n+\n+        test = new UUID(55L, 0xe000000000001000L);\n+        if (test.variant() != 7) {\n@@ -180,0 +262,1 @@\n+        }\n@@ -190,0 +273,1 @@\n+\n@@ -191,1 +275,1 @@\n-        if (test.timestamp() != 1)\n+        if (test.timestamp() != 1) {\n@@ -193,0 +277,2 @@\n+        }\n+\n@@ -194,1 +280,1 @@\n-        if (test.timestamp() != 1024)\n+        if (test.timestamp() != 1024) {\n@@ -196,0 +282,2 @@\n+        }\n+\n@@ -197,1 +285,1 @@\n-        if (test.timestamp() != Long.MAX_VALUE>>3)\n+        if (test.timestamp() != (Long.MAX_VALUE >> 3)) {\n@@ -199,0 +287,1 @@\n+        }\n@@ -209,0 +298,1 @@\n+\n@@ -210,1 +300,1 @@\n-        if (test.clockSequence() != 1)\n+        if (test.clockSequence() != 1) {\n@@ -212,0 +302,2 @@\n+        }\n+\n@@ -213,1 +305,1 @@\n-        if (test.clockSequence() != 2)\n+        if (test.clockSequence() != 2) {\n@@ -215,0 +307,2 @@\n+        }\n+\n@@ -216,1 +310,1 @@\n-        if (test.clockSequence() != 16)\n+        if (test.clockSequence() != 16) {\n@@ -218,0 +312,2 @@\n+        }\n+\n@@ -219,1 +315,1 @@\n-        if (test.clockSequence() != ((2L<<13)-1)) \/\/ 2^14 - 1\n+        if (test.clockSequence() != ((1L << 14) - 1)) {\n@@ -221,0 +317,1 @@\n+        }\n@@ -231,0 +328,1 @@\n+\n@@ -232,1 +330,1 @@\n-        if (test.node() != 1)\n+        if (test.node() != 1) {\n@@ -234,0 +332,2 @@\n+        }\n+\n@@ -235,1 +335,1 @@\n-        if (test.node() != ((2L<<47)-1)) \/\/ 2^48 - 1\n+        if (test.node() != ((1L << 48) - 1)) {\n@@ -237,0 +337,1 @@\n+        }\n@@ -241,1 +342,1 @@\n-        for (int i=0; i<100; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -244,2 +345,4 @@\n-            if (u1.hashCode() != u2.hashCode())\n-                throw new Exception(\"Equal UUIDs with different hashcodes\");\n+            if (u1.hashCode() != u2.hashCode()) {\n+                throw new Exception(\"Equal UUIDs with different hash codes: \" + u1 + \"(\" + u1.hashCode() + \") \" +\n+                                    \"and \" + u2 + \"(\" + u2.hashCode() + \")\");\n+            }\n@@ -247,0 +350,1 @@\n+\n@@ -248,1 +352,1 @@\n-        for (int i=0; i<1000; i++) {\n+        for (int i = 0; i < COUNT; i++) {\n@@ -255,2 +359,3 @@\n-            if (u1.equals(u2))\n-                throw new Exception(\"UUIDs with different bits equal\");\n+            if (u1.equals(u2)) {\n+                throw new Exception(\"UUIDs with different bits equal: \" + u1 + \" and \" + u2);\n+            }\n@@ -270,1 +375,1 @@\n-            (id4.compareTo(id5) >= 0))\n+            (id4.compareTo(id5) >= 0)) {\n@@ -272,0 +377,1 @@\n+        }\n@@ -276,1 +382,1 @@\n-            (id2.compareTo(id) <= 0))\n+            (id2.compareTo(id) <= 0)) {\n@@ -278,0 +384,1 @@\n+        }\n@@ -279,1 +386,1 @@\n-        if (id.compareTo(id) != 0)\n+        if (id.compareTo(id) != 0) {\n@@ -281,1 +388,1 @@\n-\n+        }\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":187,"deletions":80,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -0,0 +1,1712 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @bug 8284199 8296779 8306647\n+ * @summary Basic tests for StructuredTaskScope\n+ * @enablePreview\n+ * @run junit\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n+ *\/\n+\n+\/*\n+ * @test id=virtual\n+ * @enablePreview\n+ * @run junit\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n+import java.util.concurrent.StructuredTaskScope.ShutdownOnFailure;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import static java.lang.Thread.State.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StructuredTaskScopeTest {\n+    private static ScheduledExecutorService scheduler;\n+    private static List<ThreadFactory> threadFactories;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+\n+        \/\/ thread factories\n+        String value = System.getProperty(\"threadFactory\");\n+        List<ThreadFactory> list = new ArrayList<>();\n+        if (value == null || value.equals(\"platform\"))\n+            list.add(Thread.ofPlatform().factory());\n+        if (value == null || value.equals(\"virtual\"))\n+            list.add(Thread.ofVirtual().factory());\n+        assertTrue(list.size() > 0, \"No thread factories for tests\");\n+        threadFactories = list;\n+    }\n+\n+    @AfterAll\n+    static void shutdown() {\n+        scheduler.shutdown();\n+    }\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return threadFactories.stream();\n+    }\n+\n+    \/**\n+     * Test that fork creates a new thread for each task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkCreatesThread(ThreadFactory factory) throws Exception {\n+        Set<Long> tids = ConcurrentHashMap.newKeySet();\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> {\n+                    tids.add(Thread.currentThread().threadId());\n+                    return null;\n+                });\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, tids.size());\n+    }\n+\n+    \/**\n+     * Test that fork creates a new virtual thread for each task.\n+     *\/\n+    @Test\n+    void testForkCreateVirtualThread() throws Exception {\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                    return null;\n+                });\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, threads.size());\n+        threads.forEach(t -> assertTrue(t.isVirtual()));\n+    }\n+\n+    \/**\n+     * Test that fork creates a new thread with the given thread factory.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkUsesFactory(ThreadFactory factory) throws Exception {\n+        var count = new AtomicInteger();\n+        ThreadFactory countingFactory = task -> {\n+            count.incrementAndGet();\n+            return factory.newThread(task);\n+        };\n+        try (var scope = new StructuredTaskScope<Object>(null, countingFactory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> null);\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, count.get());\n+    }\n+\n+    \/**\n+     * Test fork is confined to threads in the scope \"tree\".\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Boolean>();\n+             var scope2 = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope1 cannot fork thread in scope2\n+            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope2.fork(() -> null);\n+                });\n+                return true;\n+            });\n+\n+            \/\/ thread in scope2 can fork thread in scope1\n+            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n+                scope1.fork(() -> null);\n+                return true;\n+            });\n+\n+            scope2.join();\n+            scope1.join();\n+\n+            assertTrue(subtask1.get());\n+            assertTrue(subtask2.get());\n+\n+            \/\/ random thread cannot fork\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope1.fork(() -> null);\n+                    });\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope2.fork(() -> null);\n+                    });\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after join completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoin(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            \/\/ round 1\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, subtask1::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+\n+            \/\/ round 2\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            assertEquals(\"foo\", subtask1.get());\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+\n+            \/\/ round 3\n+            var subtask3 = scope.fork(() -> \"baz\");\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+            assertThrows(IllegalStateException.class, subtask3::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+            assertEquals(\"baz\", subtask3.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after join throws.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoinThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            \/\/ allow subtask1 to finish\n+            latch.countDown();\n+\n+            \/\/ continue to fork\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            assertThrows(IllegalStateException.class, subtask1::get);\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after scope is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n+        var executed = new AtomicBoolean();\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.shutdown();\n+            Subtask<String> subtask = scope.fork(() -> {\n+                executed.set(true);\n+                return null;\n+            });\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+        assertFalse(executed.get());\n+    }\n+\n+    \/**\n+     * Test fork after scope is closed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterClose(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when the thread factory rejects creating a thread.\n+     *\/\n+    @Test\n+    void testForkRejectedExecutionException() throws Exception {\n+        ThreadFactory factory = task -> null;\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            assertThrows(RejectedExecutionException.class, () -> scope.fork(() -> null));\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with no subtasks.\n+     *\/\n+    @Test\n+    void testJoinWithNoSubtasks() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithSubtasks(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            });\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test join is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope cannot join\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n+                return true;\n+            });\n+\n+            scope.join();\n+\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot join\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope::join);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.join();\n+                fail(\"join did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.join\");\n+            try {\n+                scope.join();\n+                fail(\"join did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test join when scope is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var interrupted = new CountDownLatch(1);\n+            var finish = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                finish.await();\n+                return \"foo\";\n+            });\n+\n+            scope.shutdown();      \/\/ should interrupt task\n+\n+            interrupted.await();\n+\n+            scope.join();\n+\n+            \/\/ signal task to finish\n+            finish.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown when owner is blocked in join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            @Override\n+            protected void handleComplete(Subtask<? extends T> subtask) {\n+                shutdown();\n+            }\n+        }\n+\n+        try (var scope = new MyScope<String>(factory)) {\n+            Subtask<String> subtask1 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            });\n+            Subtask<String> subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+\n+            \/\/ join should wakeup when shutdown is called\n+            scope.join();\n+\n+            \/\/ task1 should have completed successfully\n+            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n+            assertEquals(\"foo\", subtask1.get());\n+            assertThrows(IllegalStateException.class, subtask1::exception);\n+\n+            \/\/ task2 result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            assertThrows(IllegalStateException.class, subtask2::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test join after scope is closed.\n+     *\/\n+    @Test\n+    void testJoinAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.join());\n+            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, subtasks finish before deadline expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(2));\n+                } catch (InterruptedException e) { }\n+                return \"foo\";\n+            });\n+\n+            long startMillis = millisTime();\n+            scope.joinUntil(Instant.now().plusSeconds(30));\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, deadline expires before subtasks finish.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            long startMillis = millisTime();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(2));\n+            } catch (TimeoutException e) {\n+                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            }\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil many times.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            for (int i = 0; i < 3; i++) {\n+                try {\n+                    scope.joinUntil(Instant.now().plusMillis(50));\n+                    fail(\"joinUntil did not throw\");\n+                } catch (TimeoutException expected) {\n+                    assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with a deadline that has already expired.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil4(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ now\n+            try {\n+                scope.joinUntil(Instant.now());\n+                fail(\"joinUntil did not throw\");\n+            } catch (TimeoutException expected) {\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            }\n+\n+            \/\/ in the past\n+            try {\n+                scope.joinUntil(Instant.now().minusSeconds(1));\n+                fail(\"joinUntil did not throw\");\n+            } catch (TimeoutException expected) {\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ joinUntil should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(30));\n+                fail(\"joinUntil did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in joinUntil.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ joinUntil should throw\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.joinUntil\");\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(30));\n+                fail(\"joinUntil did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown prevents new threads from starting.\n+     *\/\n+    @Test\n+    void testShutdownWithFork() throws Exception {\n+        ThreadFactory factory = task -> null;\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.shutdown();\n+            \/\/ should not invoke the ThreadFactory to create thread\n+            Subtask<Void> subtask = scope.fork(() -> null);\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown interrupts unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownInterruptsThreads1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var interrupted = new AtomicBoolean();\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.set(true);\n+                } finally {\n+                    latch.countDown();\n+                }\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+\n+            \/\/ wait for task to complete\n+            latch.await();\n+            assertTrue(interrupted.get());\n+\n+            scope.join();\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown does not interrupt current thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownInterruptsThreads2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var interrupted = new AtomicBoolean();\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                try {\n+                    scope.shutdown();\n+                    interrupted.set(Thread.currentThread().isInterrupted());\n+                } finally {\n+                    latch.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to complete\n+            latch.await();\n+            assertFalse(interrupted.get());\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown wakes join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownWakesJoin(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(100));  \/\/ give time for join to block\n+                scope.shutdown();\n+                latch.await();\n+                return null;\n+            });\n+\n+            scope.join();\n+\n+            \/\/ join woke up, allow task to complete\n+            latch.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown after scope is closed.\n+     *\/\n+    @Test\n+    void testShutdownAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, scope::shutdown);\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown is confined to threads in the scope \"tree\".\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Boolean>();\n+             var scope2 = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope1 cannot shutdown scope2\n+            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope2::shutdown);\n+                return true;\n+            });\n+\n+            \/\/ wait for task in scope1 to complete to avoid racing with task in scope2\n+            while (subtask1.state() == Subtask.State.UNAVAILABLE) {\n+                Thread.sleep(10);\n+            }\n+\n+            \/\/ thread in scope2 shutdown scope1\n+            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n+                scope1.shutdown();\n+                return true;\n+            });\n+\n+            scope2.join();\n+            scope1.join();\n+\n+            assertTrue(subtask1.get());\n+            assertTrue(subtask1.get());\n+\n+            \/\/ random thread cannot shutdown\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope1::shutdown);\n+                    assertThrows(WrongThreadException.class, scope2::shutdown);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test isShutdown.\n+     *\/\n+    @Test\n+    void testIsShutdown() {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            assertFalse(scope.isShutdown());   \/\/ before shutdown\n+            scope.shutdown();\n+            assertTrue(scope.isShutdown());    \/\/ after shutdown\n+            scope.close();\n+            assertTrue(scope.isShutdown());    \/\/ after cose\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, no subtasks forked.\n+     *\/\n+    @Test\n+    void testCloseWithoutJoin1() {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            \/\/ do nothing\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin2(ThreadFactory factory) {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, unfinished subtasks forked after join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test close after join throws. Close should not throw as join attempted.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseAfterJoinThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+            assertThrows(IllegalStateException.class, subtask::get);\n+        }\n+    }\n+\n+    \/**\n+     * Test close after joinUntil throws. Close should not throw as join attempted.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseAfterJoinUntilThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ joinUntil throws\n+            assertThrows(TimeoutException.class, () -> scope.joinUntil(Instant.now()));\n+            assertThrows(IllegalStateException.class, subtask::get);\n+        }\n+    }\n+\n+    \/**\n+     * Test close is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ attempt to close from thread in scope\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::close);\n+                return true;\n+            });\n+\n+            scope.join();\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot close scope\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Boolean> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope::close);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test close with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var done = new AtomicBoolean();\n+            scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupted by shutdown, expected\n+                }\n+                Thread.sleep(Duration.ofMillis(100)); \/\/ force close to wait\n+                done.set(true);\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+            scope.join();\n+\n+            \/\/ invoke close with interrupt status set\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n+                assertTrue(done.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupting thread waiting in close.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var done = new AtomicBoolean();\n+            Thread mainThread = Thread.currentThread();\n+            scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupted by shutdown, expected\n+                }\n+\n+                \/\/ interrupt main thread when it blocks in close\n+                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScope.close\");\n+\n+                Thread.sleep(Duration.ofMillis(100)); \/\/ force close to wait\n+                done.set(true);\n+                return null;\n+            });\n+\n+            scope.shutdown();   \/\/ interrupts task\n+            scope.join();\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted()); \/\/ clear interrupt status\n+                assertTrue(done.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that closing an enclosing scope closes the thread flock of a nested scope.\n+     *\/\n+    @Test\n+    void testCloseThrowsStructureViolation() throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Object>()) {\n+            try (var scope2 = new StructuredTaskScope<Object>()) {\n+\n+                \/\/ join + close enclosing scope\n+                scope1.join();\n+                try {\n+                    scope1.close();\n+                    fail(\"close did not throw\");\n+                } catch (StructureViolationException expected) { }\n+\n+                \/\/ underlying flock should be closed, fork should return a cancelled task\n+                var executed = new AtomicBoolean();\n+                Subtask<Void> subtask = scope2.fork(() -> {\n+                    executed.set(true);\n+                    return null;\n+                });\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+                scope2.join();\n+                assertFalse(executed.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A StructuredTaskScope that collects the subtasks notified to the handleComplete method.\n+     *\/\n+    private static class CollectAll<T> extends StructuredTaskScope<T> {\n+        private final Set<Subtask<? extends T>> subtasks = ConcurrentHashMap.newKeySet();\n+\n+        CollectAll(ThreadFactory factory) {\n+            super(null, factory);\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            subtasks.add(subtask);\n+        }\n+\n+        Set<Subtask<? extends T>> subtasks() {\n+            return subtasks;\n+        }\n+\n+        Subtask<? extends T> find(Callable<T> task) {\n+            return subtasks.stream()\n+                    .filter(h -> task.equals(h.task()))\n+                    .findAny()\n+                    .orElseThrow();\n+        }\n+    }\n+\n+    \/**\n+     * Test that handleComplete method is invoked for tasks that complete before shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleCompleteBeforeShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll<String>(factory)) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            scope.fork(task1);\n+            scope.fork(task2);\n+            scope.join();\n+\n+            var subtask1 = scope.find(task1);\n+            assertEquals(\"foo\", subtask1.get());\n+\n+            var subtask2 = scope.find(task2);\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n+\n+    \/**\n+     * Test that handleComplete method is not invoked for tasks that finish after shutdown\n+     * or are forked after shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleCompleteAfterShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll<String>(factory)) {\n+            Callable<String> task1 = () -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException ignore) { }\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            };\n+            Callable<String> task3 = () -> \"baz\";\n+\n+            \/\/ forked before shutdown, will complete after shutdown\n+            var subtask1 = scope.fork(task1);\n+            var subtask2 = scope.fork(task2);\n+\n+            scope.shutdown();\n+\n+            \/\/ forked after shutdown\n+            var subtask3 = scope.fork(task3);\n+\n+            scope.join();\n+\n+            \/\/ handleComplete should not be called\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(0, scope.subtasks().size());\n+                Thread.sleep(20);\n+            }\n+\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask3.state());\n+        }\n+    }\n+\n+    \/**\n+     * Test that the default handleComplete throws IllegalArgumentException if called\n+     * with a running task.\n+     *\/\n+    @Test\n+    void testHandleCompleteThrows() throws Exception {\n+        class TestScope<T> extends StructuredTaskScope<T> {\n+            protected void handleComplete(Subtask<? extends T> subtask) {\n+                super.handleComplete(subtask);\n+            }\n+        }\n+\n+        try (var scope = new TestScope<String>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"foo\";\n+            });\n+\n+            \/\/ running task\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalArgumentException.class, () -> scope.handleComplete(subtask));\n+            scope.shutdown();\n+\n+            \/\/ null task\n+            assertThrows(NullPointerException.class, () -> scope.handleComplete(null));\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test ensureOwnerAndJoined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testEnsureOwnerAndJoined(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            void invokeEnsureOwnerAndJoined() {\n+                super.ensureOwnerAndJoined();\n+            }\n+        }\n+\n+        try (var scope = new MyScope<Boolean>(factory)) {\n+            \/\/ owner thread, before join\n+            scope.fork(() -> true);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.invokeEnsureOwnerAndJoined();\n+            });\n+\n+            \/\/ owner thread, after join\n+            scope.join();\n+            scope.invokeEnsureOwnerAndJoined();\n+\n+            \/\/ thread in scope cannot invoke ensureOwnerAndJoined\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.invokeEnsureOwnerAndJoined();\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot invoke ensureOwnerAndJoined\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope.invokeEnsureOwnerAndJoined();\n+                    });\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ensureOwnerAndJoined after the task scope has been closed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testEnsureOwnerAndJoinedAfterClose(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            public void invokeEnsureOwnerAndJoined() {\n+                super.ensureOwnerAndJoined();\n+            }\n+        }\n+\n+        \/\/ ensureOwnerAndJoined after close, join invoked\n+        try (var scope = new MyScope<String>(factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+            scope.close();\n+            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n+        }\n+\n+        \/\/ ensureOwnerAndJoined after close, join not invoked\n+        try (var scope = new MyScope<String>(factory)) {\n+            scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, scope::close);\n+            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n+        }\n+    }\n+\n+\n+    \/**\n+     * Test toString.\n+     *\/\n+    @Test\n+    void testToString() throws Exception {\n+        ThreadFactory factory = Thread.ofVirtual().factory();\n+        try (var scope = new StructuredTaskScope<Object>(\"duke\", factory)) {\n+            \/\/ open\n+            assertTrue(scope.toString().contains(\"duke\"));\n+\n+            \/\/ shutdown\n+            scope.shutdown();\n+            assertTrue(scope.toString().contains(\"duke\"));\n+\n+            \/\/ closed\n+            scope.join();\n+            scope.close();\n+            assertTrue(scope.toString().contains(\"duke\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with task that completes successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenSuccess(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Callable<String> task = () -> \"foo\";\n+            Subtask<String> subtask = scope.fork(task);\n+\n+            \/\/ before join, owner thread\n+            assertEquals(task, subtask.task());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            scope.join();\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.SUCCESS, subtask.state());\n+            assertEquals(\"foo\", subtask.get());\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with task that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenFailed(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Callable<String> task = () -> { throw new FooException(); };\n+            Subtask<String> subtask = scope.fork(task);\n+\n+            \/\/ before join, owner thread\n+            assertEquals(task, subtask.task());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            scope.join();\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.FAILED, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertTrue(subtask.exception() instanceof FooException);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with a task that has not completed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenNotCompleted(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Callable<Void> task = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+            Subtask<Void> subtask = scope.fork(task);\n+\n+            \/\/ before join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            \/\/ attempt join, join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask when forked after shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Callable<Void> task = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+\n+            scope.shutdown();\n+\n+            \/\/ fork after shutdown\n+            Subtask<Void> subtask = scope.fork(task);\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask::toString.\n+     *\/\n+    @Test\n+    void testSubtaskToString() throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            \/\/ success\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            scope.join();\n+            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n+\n+            \/\/ failed\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+            scope.join();\n+            assertTrue(subtask2.toString().contains(\"Failed\"));\n+\n+            \/\/ not completed\n+            Callable<Void> sleepForDay = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+            var subtask3 = scope.fork(sleepForDay);\n+            assertTrue(subtask3.toString().contains(\"Unavailable\"));\n+\n+            scope.shutdown();\n+\n+            \/\/ forked after shutdown\n+            var subtask4 = scope.fork(sleepForDay);\n+            assertTrue(subtask4.toString().contains(\"Unavailable\"));\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with no completed tasks.\n+     *\/\n+    @Test\n+    void testShutdownOnSuccess1() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>()) {\n+            assertThrows(IllegalStateException.class, () -> scope.result());\n+            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess2(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();  \/\/ ensures foo completes first\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a task that completes successfully with a null result.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess3(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+            scope.fork(() -> null);\n+            scope.join();\n+            assertNull(scope.result());\n+            assertNull(scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that complete succcessfully and tasks that fail.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess4(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a task that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess5(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess methods are confined to the owner.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccessConfined(ThreadFactory factory) throws Exception {\n+        \/\/ owner before join\n+        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n+            scope.fork(() -> { throw new FooException(); });\n+            assertThrows(IllegalStateException.class, scope::result);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.result(e -> new RuntimeException(e));\n+            });\n+            scope.join();\n+        }\n+\n+        \/\/ non-owner\n+        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::result);\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.result(e -> new RuntimeException(e));\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with no completed tasks.\n+     *\/\n+    @Test\n+    void testShutdownOnFailure1() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailure2(ThreadFactory factory) throws Throwable {\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            \/\/ no exception\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that complete succcessfully and tasks that fail.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailure3(ThreadFactory factory) throws Throwable {\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+\n+            \/\/ one task completes successfully, the other fails\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+\n+            Throwable ex = scope.exception().orElse(null);\n+            assertTrue(ex instanceof ArithmeticException);\n+\n+            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+\n+            ex = assertThrows(FooException.class,\n+                              () -> scope.throwIfFailed(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure methods are confined to the owner.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailureConfined(ThreadFactory factory) throws Exception {\n+        \/\/ owner before join\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, scope::exception);\n+            assertThrows(IllegalStateException.class, scope::throwIfFailed);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.throwIfFailed(e -> new RuntimeException(e));\n+            });\n+            scope.join();\n+        }\n+\n+        \/\/ non-owner\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::exception);\n+                assertThrows(WrongThreadException.class, scope::throwIfFailed);\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.throwIfFailed(e -> new RuntimeException(e));\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test for NullPointerException.\n+     *\/\n+    @Test\n+    void testNulls() throws Exception {\n+        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess<Object>(\"\", null));\n+        try (var scope = new ShutdownOnSuccess<Object>()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.result(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n+        }\n+    }\n+\n+    \/**\n+     * A runtime exception for tests.\n+     *\/\n+    private static class FooException extends RuntimeException {\n+        FooException() { }\n+        FooException(Throwable cause) { super(cause); }\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private long expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+        return duration;\n+    }\n+\n+    \/**\n+     * Interrupts a thread when it waits (timed or untimed) at location \"{@code c.m}\".\n+     * {@code c} is the fully qualified class name and {@code m} is the method name.\n+     *\/\n+    private void interruptThreadAt(Thread target, String location) throws InterruptedException {\n+        int index = location.lastIndexOf('.');\n+        String className = location.substring(0, index);\n+        String methodName = location.substring(index + 1);\n+\n+        boolean found = false;\n+        while (!found) {\n+            Thread.State state = target.getState();\n+            assertTrue(state != TERMINATED);\n+            if ((state == WAITING || state == TIMED_WAITING)\n+                    && contains(target.getStackTrace(), className, methodName)) {\n+                found = true;\n+            } else {\n+                Thread.sleep(20);\n+            }\n+        }\n+        target.interrupt();\n+    }\n+\n+    \/**\n+     * Schedules the current thread to be interrupted when it waits (timed or untimed)\n+     * at the given location.\n+     *\/\n+    private void scheduleInterruptAt(String location) {\n+        Thread target = Thread.currentThread();\n+        scheduler.submit(() -> {\n+            interruptThreadAt(target, location);\n+            return null;\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given class\n+     * and method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String className, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> className.equals(e.getClassName())\n+                        && methodName.equals(e.getMethodName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":1712,"deletions":0,"binary":false,"changes":1712,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284199\n+ * @bug 8284199 8296779 8306647\n@@ -28,1 +28,1 @@\n- * @modules jdk.incubator.concurrent\n+ * @enablePreview\n@@ -33,1 +33,1 @@\n-import jdk.incubator.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope;\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284199 8296779 8306647\n+ * @summary Basic tests for StructuredTaskScope with scoped values\n+ * @enablePreview\n+ * @run junit WithScopedValue\n+ *\/\n+\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class WithScopedValue {\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a child thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask = scope.fork(() -> {\n+                    return name.get(); \/\/ child should read \"x\"\n+                });\n+                scope.join();\n+                return subtask.get();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a grandchild thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        Subtask<String> subtask2 = scope2.fork(() -> {\n+                            return name.get(); \/\/ grandchild should read \"x\"\n+                        });\n+                        scope2.join();\n+                        return subtask2.get();\n+                    }\n+                });\n+                scope1.join();\n+                return subtask1.get();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a rebound scoped value into a grandchild thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask1 = scope1.fork(() -> {\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+\n+                    \/\/ rebind name to \"y\"\n+                    String grandchildValue = ScopedValue.callWhere(name, \"y\", () -> {\n+                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                            Subtask<String> subtask2 = scope2.fork(() -> {\n+                                return name.get(); \/\/ grandchild should read \"y\"\n+                            });\n+                            scope2.join();\n+                            return subtask2.get();\n+                        }\n+                    });\n+\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+                    return grandchildValue;\n+                });\n+                scope1.join();\n+                return subtask1.get();\n+            }\n+        });\n+        assertEquals(value, \"y\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with an open task scope.\n+     *\/\n+    @Test\n+    void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.runWhere(name, \"x\", () -> {\n+                    box.scope = new StructuredTaskScope<Object>();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed and fork should fail to start a thread\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Subtask<Object> subtask = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            scope.join();\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertFalse(ran.get());\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n+     *\/\n+    @Test\n+    void testStructureViolation2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.runWhere(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class, scope::close);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    void testStructureViolation3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.runWhere(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    void testStructureViolation4() throws Exception {\n+        ScopedValue<String> name1 = ScopedValue.newInstance();\n+        ScopedValue<String> name2 = ScopedValue.newInstance();\n+\n+        \/\/ rebind\n+        ScopedValue.runWhere(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.runWhere(name1, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.runWhere(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.runWhere(name2, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary Generate large number of Secret Keys using same KEM\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom GenLargeNumberOfKeys\n+ *\/\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+\n+import java.security.spec.ECGenParameterSpec;\n+import jdk.test.lib.Asserts;\n+\n+public class GenLargeNumberOfKeys {\n+\n+    private static final int COUNT = 1000;\n+\n+    public static void main(String[] args) throws Exception {\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        testAlgo(kem, \"X448\", null);\n+        testAlgo(kem, \"EC\", \"secp521r1\");\n+    }\n+\n+    private static void testAlgo(KEM kem, String algo, String curveId) throws Exception {\n+        KeyPair kp = genKeyPair(algo, curveId);\n+        KEM.Encapsulator e = kem.newEncapsulator(kp.getPublic());\n+        KEM.Decapsulator d = kem.newDecapsulator(kp.getPrivate());\n+        for (int i = 0; i < COUNT; i++) {\n+            test(e, d);\n+        }\n+        System.out.println(algo + \": test Successful\");\n+    }\n+\n+    private static KeyPair genKeyPair(String algo, String curveId) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+        if (curveId != null) {\n+            kpg.initialize(new ECGenParameterSpec(curveId));\n+        }\n+        return kpg.generateKeyPair();\n+    }\n+\n+    private static void test(KEM.Encapsulator e, KEM.Decapsulator d)\n+            throws Exception {\n+        KEM.Encapsulated enc = e.encapsulate();\n+        SecretKey sk = enc.key();\n+        Asserts.assertEQ(d.encapsulationSize(), enc.encapsulation().length);\n+        Asserts.assertEQ(d.secretSize(), enc.key().getEncoded().length);\n+        Asserts.assertTrue(Arrays.equals(d.decapsulate(enc.encapsulation()).getEncoded(),\n+                sk.getEncoded()));\n+        \/\/ Repeated calls to encapsulation() on Encapsulated object don't change anything\n+        Asserts.assertTrue(Arrays.equals(d.decapsulate(enc.encapsulation()).getEncoded(),\n+                sk.getEncoded()));\n+        Asserts.assertTrue(Arrays.equals(d.decapsulate(enc.encapsulation()).getEncoded(),\n+                enc.key().getEncoded()));\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/GenLargeNumberOfKeys.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary KEM using KeyPair generated through SunPKCS11 provider using NSS\n+ * @library \/test\/lib ..\/..\/..\/sun\/security\/pkcs11\n+ *\/\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.Arrays;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import jdk.test.lib.Asserts;\n+\n+public class KemInterop extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new KemInterop(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        test(\"EC\", \"secp256r1\", p);\n+        test(\"EC\", \"secp384r1\", p);\n+        test(\"EC\", \"secp521r1\", p);\n+        test(\"X25519\", null, p);\n+        test(\"X448\", null, p);\n+        test(\"XDH\", null, p);\n+    }\n+\n+    private static void test(String algo, String curveId, Provider p) throws Exception {\n+\n+        @FunctionalInterface\n+        interface KemTest<KP, SR> {\n+\n+            void test(KP kp, SR scr);\n+        }\n+\n+        KemTest<KeyPair, SecureRandom> kemWithPKCSKeys = (kpr, scr) -> {\n+            try {\n+                KEM kem = KEM.getInstance(\"DHKEM\", \"SunJCE\");\n+                KEM.Encapsulator encT = encapsulator(kem, kpr.getPublic(), scr);\n+                KEM.Encapsulator encT1 = encapsulator(kem, kpr.getPublic(), scr);\n+                KEM.Encapsulated enc = encT.encapsulate();\n+                KEM.Encapsulated enc1 = encT.encapsulate();\n+                KEM.Encapsulated enc2 = encT1.encapsulate();\n+\n+                Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), enc.key().getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(enc.encapsulation(), enc.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc1.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc1.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc2.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc2.encapsulation()));\n+\n+                KEM.Decapsulator decT = kem.newDecapsulator(kpr.getPrivate());\n+                SecretKey dsk = decT.decapsulate(enc.encapsulation());\n+                Asserts.assertTrue(Arrays.equals(dsk.getEncoded(), enc.key().getEncoded()));\n+\n+                Asserts.assertEQ(encT.encapsulationSize(), enc.encapsulation().length);\n+                Asserts.assertEQ(encT.encapsulationSize(), decT.encapsulationSize());\n+                Asserts.assertEQ(encT.secretSize(), enc.key().getEncoded().length);\n+                Asserts.assertEQ(encT.secretSize(), decT.secretSize());\n+                Asserts.assertEQ(decT.secretSize(), dsk.getEncoded().length);\n+                Asserts.assertEQ(decT.secretSize(),\n+                        decT.decapsulate(enc.encapsulation()).getEncoded().length);\n+                Asserts.assertEQ(decT.decapsulate(enc.encapsulation()).getEncoded().length,\n+                        enc.key().getEncoded().length);\n+\n+                KEM.Encapsulated enc3 = encT.encapsulate(0, encT.secretSize(), \"AES\");\n+                KEM.Decapsulator decT1 = kem.newDecapsulator(kpr.getPrivate());\n+                SecretKey dsk1 = decT1.decapsulate(enc3.encapsulation(), 0, decT1.secretSize(), \"AES\");\n+                Asserts.assertTrue(Arrays.equals(dsk1.getEncoded(), enc3.key().getEncoded()));\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+            System.out.println(\"Success\");\n+        };\n+\n+        KeyPair kp = null;\n+        SecureRandom sr = null;\n+        try {\n+            System.out.print(\"Algo-\" + algo + \":\" + \"Curve-\" + curveId + \":\");\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo, p);\n+            try {\n+                sr = SecureRandom.getInstance(\"PKCS11\");\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ Get default SecureRandom incase PKCS11 not found\n+                sr = new SecureRandom();\n+            }\n+            if (curveId != null) {\n+                kpg.initialize(new ECGenParameterSpec(curveId), sr);\n+            }\n+            kp = kpg.generateKeyPair();\n+        } catch (NoSuchAlgorithmException e) {\n+            System.out.println(\"Unsupported. Test execution Ignored\");\n+            return;\n+        }\n+\n+        kemWithPKCSKeys.test(kp, null);\n+        kemWithPKCSKeys.test(kp, sr);\n+    }\n+\n+    private static KEM.Encapsulator encapsulator(KEM kem, PublicKey pk, SecureRandom sr)\n+            throws Exception {\n+        if (sr == null) {\n+            return kem.newEncapsulator(pk);\n+        } else {\n+            return kem.newEncapsulator(pk, sr);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/KemInterop.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary KEM API test\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom KemTest\n+ *\/\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.ExecutorCompletionService;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import javax.crypto.DecapsulateException;\n+import jdk.test.lib.Asserts;\n+\n+public class KemTest {\n+\n+    private static final int THREAD_COUNT = 100;\n+    private static final int THREAD_POOL_SIZE = 20;\n+    private static final String ALGO = \"DHKEM\";\n+    private static final String PROVIDER = \"SunJCE\";\n+\n+    public static void main(String[] args) throws Exception {\n+        KEM kem = KEM.getInstance(ALGO, PROVIDER);\n+        Asserts.assertEQ(kem.getAlgorithm(), ALGO);\n+        testSize(kem);\n+        testParallelEncapsulator(kem, \"EC\", \"secp256r1\");\n+        testParallelEncapsulate(kem, \"EC\", \"secp256r1\");\n+        testParallelDecapsulator(kem, \"EC\", \"secp256r1\");\n+        testParallelDecapsulate(kem, \"EC\", \"secp256r1\");\n+    }\n+\n+    @FunctionalInterface\n+    interface GenKeyPair<A, C, K> {\n+\n+        K gen(A a, C c);\n+    }\n+    private static final GenKeyPair<String, String, KeyPair> keyPair = (algo, curveId) -> {\n+        try {\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+            if (curveId != null) {\n+                kpg.initialize(new ECGenParameterSpec(curveId));\n+            }\n+            return kpg.generateKeyPair();\n+        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+            throw new RuntimeException(e);\n+        }\n+    };\n+\n+    \/*\n+     * As per https:\/\/www.rfc-editor.org\/rfc\/rfc9180#name-key-encapsulation-mechanism\n+     * Nsecret: The length in bytes of a KEM shared secret produced by this KEM.\n+     * Nenc: The length in bytes of an encapsulated key produced by this KEM.\n+     *\/\n+    private static void testSize(KEM kem) throws Exception {\n+\n+        @FunctionalInterface\n+        interface LengthTest<A, C, S, E> {\n+\n+            void test(A a, C c, S s, E e);\n+        }\n+        LengthTest<String, String, Integer, Integer> secretLen = (algo, curveId, nSecret, nEnc) -> {\n+            try {\n+                KeyPair kp = keyPair.gen(algo, curveId);\n+                KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+                Asserts.assertEQ(encT.providerName(), PROVIDER);\n+                KEM.Encapsulated enc = encT.encapsulate();\n+                KEM.Encapsulated enc1 = encT.encapsulate();\n+\n+                KEM kem1 = KEM.getInstance(ALGO, PROVIDER);\n+                KEM.Encapsulator encT2 = kem1.newEncapsulator(kp.getPublic());\n+                KEM.Encapsulated enc2 = encT2.encapsulate();\n+\n+                Asserts.assertEQ(enc.key().getEncoded().length, nSecret);\n+                Asserts.assertEQ(enc.encapsulation().length, nEnc);\n+\n+                Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), enc.key().getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(enc.encapsulation(), enc.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc1.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc1.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc2.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc2.encapsulation()));\n+\n+                SecretKey sk = enc.key();\n+                KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+                SecretKey dsk = decT.decapsulate(enc.encapsulation());\n+                Asserts.assertEQ(decT.providerName(), PROVIDER);\n+                Asserts.assertTrue(Arrays.equals(sk.getEncoded(), dsk.getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(sk.getEncoded(),\n+                        decT.decapsulate(enc.encapsulation()).getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(),\n+                        decT.decapsulate(enc.encapsulation()).getEncoded()));\n+\n+                Asserts.assertEQ(encT.encapsulationSize(), enc.encapsulation().length);\n+                Asserts.assertEQ(encT.encapsulationSize(), decT.encapsulationSize());\n+                Asserts.assertEQ(encT.secretSize(), enc.key().getEncoded().length);\n+                Asserts.assertEQ(encT.secretSize(), decT.secretSize());\n+                Asserts.assertEQ(decT.secretSize(), dsk.getEncoded().length);\n+                Asserts.assertEQ(decT.secretSize(),\n+                        decT.decapsulate(enc.encapsulation()).getEncoded().length);\n+                Asserts.assertEQ(decT.decapsulate(enc.encapsulation()).getEncoded().length,\n+                        enc.key().getEncoded().length);\n+\n+                KEM.Encapsulated enc3 = encT.encapsulate(0, encT.secretSize(), \"AES\");\n+                KEM.Decapsulator decT1 = kem.newDecapsulator(kp.getPrivate());\n+                SecretKey dsk1 = decT1.decapsulate(\n+                        enc3.encapsulation(), 0, decT1.secretSize(), \"AES\");\n+                Asserts.assertTrue(Arrays.equals(dsk1.getEncoded(), enc3.key().getEncoded()));\n+\n+                try {\n+                    decT.decapsulate(new byte[enc.encapsulation().length]);\n+                    throw new RuntimeException(\"Shouldn't reach here\");\n+                } catch (DecapsulateException de) {\n+                    \/\/de.printStackTrace();\n+                    System.out.println(\"Expected Failure: mismatched encapsulation\");\n+                }\n+\n+                System.out.println(\"KEM Secret length:\" + algo + \":\" + curveId\n+                        + \":nSecret:\" + nSecret + \":nEnc:\" + nEnc);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+        \/\/ Secret length in bytes.\n+        secretLen.test(\"EC\", \"secp256r1\", 32, 65);\n+        secretLen.test(\"EC\", \"secp384r1\", 48, 97);\n+        secretLen.test(\"EC\", \"secp521r1\", 64, 133);\n+        secretLen.test(\"X25519\", null, 32, 32);\n+        secretLen.test(\"X448\", null, 64, 56);\n+        secretLen.test(\"XDH\", null, 32, 32);\n+        try {\n+            secretLen.test(\"Ed25519\", null, 32, 32);\n+        } catch (Exception e) {\n+            if (!e.getMessage().contains(\"java.security.InvalidKeyException\")) {\n+                throw e;\n+            }\n+            System.out.println(\"Expected Exception: Bad Key type: Ed25519\");\n+        }\n+        try {\n+            secretLen.test(\"RSA\", null, 256, 256);\n+        } catch (Exception e) {\n+            if (!e.getMessage().contains(\"java.security.InvalidKeyException\")) {\n+                throw e;\n+            }\n+            System.out.println(\"Expected Exception: Bad Key type: RSA\");\n+        }\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * A KEM object is immutable. It is safe to call multiple newEncapsulator and\n+     * newDecapsulator methods on the same KEM object at the same time.\n+     *\/\n+    private static void testParallelEncapsulator(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Encapsulator> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Encapsulator>> futures = new ArrayList<>();\n+\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Encapsulator> task = () -> kem.newEncapsulator(kp.getPublic());\n+                futures.add(cs.submit(task));\n+            }\n+\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            for (Future<KEM.Encapsulator> future : futures) {\n+                KEM.Encapsulated enc = future.get().encapsulate();\n+                Asserts.assertTrue(Arrays.equals(\n+                        decT.decapsulate(enc.encapsulation()).getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Encapsulator Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelEncapsulate(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Encapsulated> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Encapsulated>> futures = new ArrayList<>();\n+            KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Encapsulated> task = () -> encT.encapsulate();\n+                futures.add(cs.submit(task));\n+            }\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            for (Future<KEM.Encapsulated> future : futures) {\n+                Asserts.assertTrue(Arrays.equals(\n+                        decT.decapsulate(future.get().encapsulation()).getEncoded(),\n+                        future.get().key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Encapsulate Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelDecapsulator(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Decapsulator> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Decapsulator>> futures = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Decapsulator> task = () -> kem.newDecapsulator(kp.getPrivate());\n+                futures.add(cs.submit(task));\n+            }\n+\n+            KEM.Encapsulated enc = kem.newEncapsulator(kp.getPublic()).encapsulate();\n+            for (Future<KEM.Decapsulator> decT : futures) {\n+                Asserts.assertTrue(Arrays.equals(\n+                        decT.get().decapsulate(enc.encapsulation()).getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Decapsulator Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelDecapsulate(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<SecretKey> cs = new ExecutorCompletionService<>(executor);\n+            KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+            KEM.Encapsulated enc = encT.encapsulate();\n+\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            List<Future<SecretKey>> futures = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<SecretKey> task = () -> decT.decapsulate(enc.encapsulation());\n+                futures.add(cs.submit(task));\n+            }\n+            for (Future<SecretKey> future : futures) {\n+                Asserts.assertTrue(Arrays.equals(future.get().getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Decapsulate Test: Success\");\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/KemTest.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297878\n+ * @summary RSA_KEM example\n+ * @modules java.base\/sun.security.jca\n+ *          java.base\/sun.security.rsa\n+ *          java.base\/sun.security.util\n+ *\/\n+import sun.security.jca.JCAUtil;\n+import sun.security.rsa.RSACore;\n+import sun.security.util.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/\/ This test implements RSA-KEM as described in RFC 5990. In this KEM, the\n+\/\/ sender configures the encapsulator with an RSAKEMParameterSpec object.\n+\/\/ This object is encoded as a byte array and included in the Encapsulated\n+\/\/ output. The receiver is then able to recover the same RSAKEMParameterSpec\n+\/\/ object from the encoding using an AlgorithmParameters implementation\n+\/\/ and use the object to configure the decapsulator.\n+public class RSA_KEM {\n+    public static void main(String[] args) throws Exception {\n+        Provider p = new ProviderImpl();\n+        RSAKEMParameterSpec[] kspecs = new RSAKEMParameterSpec[] {\n+                RSAKEMParameterSpec.kdf1(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf1(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[10], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-512\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+        };\n+        for (RSAKEMParameterSpec kspec : kspecs) {\n+            System.err.println(\"---------\");\n+            System.err.println(kspec);\n+            AlgorithmParameters d = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            d.init(kspec);\n+            AlgorithmParameters s = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            s.init(d.getEncoded());\n+            AlgorithmParameterSpec spec = s.getParameterSpec(AlgorithmParameterSpec.class);\n+            if (!spec.toString().equals(kspec.toString())) {\n+                throw new RuntimeException(spec.toString());\n+            }\n+        }\n+        byte[] msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        byte[] iv = new byte[16];\n+        for (int size : List.of(1024, 2048)) {\n+            KeyPairGenerator g = KeyPairGenerator.getInstance(\"RSA\");\n+            g.initialize(size);\n+            KeyPair kp = g.generateKeyPair();\n+            for (RSAKEMParameterSpec kspec : kspecs) {\n+                SecretKey cek = KeyGenerator.getInstance(\"AES\").generateKey();\n+                KEM kem1 = KEM.getInstance(\"RSA-KEM\", p);\n+                Cipher c = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c.init(Cipher.ENCRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] ciphertext = c.doFinal(msg);\n+\n+                KEM.Encapsulator e = kem1.newEncapsulator(kp.getPublic(), kspec, null);\n+                KEM.Encapsulated enc = e.encapsulate(0, e.secretSize(), \"AES\");\n+                Cipher c2 = Cipher.getInstance(kspec.encAlg);\n+                c2.init(Cipher.WRAP_MODE, enc.key());\n+                byte[] ek = c2.wrap(cek);\n+\n+                AlgorithmParameters a = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+                a.init(enc.params());\n+                KEM kem2 = KEM.getInstance(\"RSA-KEM\", p);\n+                KEM.Decapsulator d = kem2.newDecapsulator(kp.getPrivate(), a.getParameterSpec(AlgorithmParameterSpec.class));\n+                SecretKey k = d.decapsulate(enc.encapsulation(), 0, d.secretSize(), \"AES\");\n+                Cipher c3 = Cipher.getInstance(kspec.encAlg);\n+                c3.init(Cipher.UNWRAP_MODE, k);\n+                cek = (SecretKey) c3.unwrap(ek, \"AES\", Cipher.SECRET_KEY);\n+                Cipher c4 = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c4.init(Cipher.DECRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] cleartext = c4.doFinal(ciphertext);\n+\n+                if (!Arrays.equals(cleartext, msg)) {\n+                    throw new RuntimeException();\n+                }\n+                System.out.printf(\"%4d %20s - %11d %11d %11d %11d %s\\n\",\n+                        size, kspec,\n+                        e.secretSize(), e.encapsulationSize(),\n+                        d.secretSize(), d.encapsulationSize(), k.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    static final String RSA_KEM = \"1.2.840.113549.1.9.16.3.14\";\n+    static final String KEM_RSA = \"1.0.18033.2.2.4\";\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"MYKEM\", \"1\", \"RSA-KEM\");\n+            List<String> alias = List.of(RSA_KEM, \"OID.\" + RSA_KEM);\n+            Map<String, String> attrs = Map.of(\n+                    \"SupportedKeyClasses\", \"java.security.interfaces.RSAKey\");\n+            putService(new Service(this, \"KEM\", \"RSA-KEM\",\n+                    \"RSA_KEM$KEMImpl\", alias, attrs));\n+            putService(new Service(this, \"AlgorithmParameters\", \"RSA-KEM\",\n+                    \"RSA_KEM$AlgorithmParametersImpl\", alias, attrs));\n+        }\n+    }\n+\n+    public static class AlgorithmParametersImpl extends AlgorithmParametersSpi {\n+        RSAKEMParameterSpec spec;\n+        @Override\n+        protected void engineInit(AlgorithmParameterSpec paramSpec)\n+                throws InvalidParameterSpecException {\n+            if (paramSpec instanceof RSAKEMParameterSpec rspec) {\n+                spec = rspec;\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params, String format) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected <T extends AlgorithmParameterSpec> T engineGetParameterSpec(\n+                Class<T> paramSpec) throws InvalidParameterSpecException {\n+            if (paramSpec.isAssignableFrom(RSAKEMParameterSpec.class)) {\n+                return paramSpec.cast(spec);\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded() {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded(String format) {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected String engineToString() {\n+            return spec == null ? \"<null>\" : spec.toString();\n+        }\n+\n+        static final ObjectIdentifier id_rsa_kem;\n+        static final ObjectIdentifier id_kem_rsa;\n+        static final ObjectIdentifier id_kdf1;\n+        static final ObjectIdentifier id_kdf2;\n+        static final ObjectIdentifier id_kdf3;\n+\n+        static {\n+            try {\n+                id_rsa_kem = ObjectIdentifier.of(\"1.2.840.113549.1.9.16.3.14\");\n+                id_kem_rsa = ObjectIdentifier.of(\"1.0.18033.2.2.4\");\n+                id_kdf1 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.0\"); \/\/ fake\n+                id_kdf2 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.1\");\n+                id_kdf3 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.2\");\n+            } catch (IOException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static byte[] encode(RSAKEMParameterSpec spec) {\n+            DerOutputStream kdf = new DerOutputStream()\n+                    .write(DerValue.tag_Sequence, new DerOutputStream()\n+                        .putOID(oid4(spec.kdfAlg))\n+                        .write(DerValue.tag_Sequence, new DerOutputStream()\n+                            .putOID(oid4(spec.hashAlg))))\n+                    .putInteger(spec.kdfLen());\n+            \/\/ The next line is not in RFC 5990\n+            if (spec.fixedInfo != null) {\n+                kdf.putOctetString(spec.fixedInfo);\n+            }\n+            return new DerOutputStream()\n+                    .write(DerValue.tag_Sequence, new DerOutputStream()\n+                            .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                    .putOID(id_kem_rsa)\n+                                    .write(DerValue.tag_Sequence, kdf))\n+                            .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                    .putOID(oid4(spec.encAlg)))).toByteArray();\n+        }\n+\n+        static RSAKEMParameterSpec decode(byte[] der) throws IOException {\n+            String kdfAlg, encAlg, hashAlg;\n+            int kdfLen;\n+            byte[] fixedInfo;\n+            DerInputStream d2 = new DerValue(der).toDerInputStream();\n+            DerInputStream d3 = d2.getDerValue().toDerInputStream();\n+            if (!d3.getOID().equals(id_kem_rsa)) {\n+                throw new IOException(\"not id_kem_rsa\");\n+            }\n+            DerInputStream d4 = d3.getDerValue().toDerInputStream();\n+            DerInputStream d5 = d4.getDerValue().toDerInputStream();\n+            kdfLen = d4.getInteger();\n+            fixedInfo = d4.available() > 0 ? d4.getOctetString() : null;\n+            d4.atEnd();\n+            ObjectIdentifier kdfOid = d5.getOID();\n+            if (kdfOid.equals(id_kdf1)) {\n+                kdfAlg = \"kdf1\";\n+            } else if (kdfOid.equals(id_kdf2)) {\n+                kdfAlg = \"kdf2\";\n+            } else if (kdfOid.equals(id_kdf3)) {\n+                kdfAlg = \"kdf3\";\n+            } else {\n+                throw new IOException(\"unknown kdf\");\n+            }\n+            DerInputStream d6 = d5.getDerValue().toDerInputStream();\n+            String hashOID = d6.getOID().toString();\n+            KnownOIDs k = KnownOIDs.findMatch(hashOID);\n+            hashAlg = k == null ? hashOID : k.stdName();\n+            d6.atEnd();\n+            d5.atEnd();\n+\n+            d3.atEnd();\n+            DerInputStream d7 = d2.getDerValue().toDerInputStream();\n+            String encOID = d7.getOID().toString();\n+            KnownOIDs e = KnownOIDs.findMatch(encOID);\n+            encAlg = e == null ? encOID : e.stdName();\n+            d7.atEnd();\n+            d2.atEnd();\n+            if (kdfLen != RSAKEMParameterSpec.kdfLen(encAlg)) {\n+                throw new IOException(\"kdfLen does not match encAlg\");\n+            }\n+            return new RSAKEMParameterSpec(kdfAlg, hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        static ObjectIdentifier oid4(String s) {\n+            return switch (s) {\n+                case \"kdf1\" -> id_kdf1;\n+                case \"kdf2\" -> id_kdf2;\n+                case \"kdf3\" -> id_kdf3;\n+                default -> {\n+                    KnownOIDs k = KnownOIDs.findMatch(s);\n+                    if (k == null) throw new UnsupportedOperationException();\n+                    yield ObjectIdentifier.of(k);\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class RSAKEMParameterSpec implements AlgorithmParameterSpec {\n+        private final String kdfAlg;\n+        private final String hashAlg;\n+        private final byte[] fixedInfo;\n+        private final String encAlg;\n+\n+        private RSAKEMParameterSpec(String kdfAlg, String hashAlg, byte[] fixedInfo, String encAlg) {\n+            this.hashAlg = hashAlg;\n+            this.kdfAlg = kdfAlg;\n+            this.fixedInfo = fixedInfo == null ? null : fixedInfo.clone();\n+            this.encAlg = encAlg;\n+        }\n+\n+        public static RSAKEMParameterSpec kdf1(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf1\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf2(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf2\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf3(String hashAlg, byte[] fixedInfo, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf3\", hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        public int kdfLen() {\n+            return RSAKEMParameterSpec.kdfLen(encAlg);\n+        }\n+\n+        public static int kdfLen(String encAlg) {\n+            return Integer.parseInt(encAlg, 4, 7, 10) \/ 8;\n+        }\n+\n+        public String hashAlgorithm() {\n+            return hashAlg;\n+        }\n+        public String kdfAlgorithm() {\n+            return kdfAlg;\n+        }\n+        public byte[] fixedInfo() {\n+            return fixedInfo == null ? null : fixedInfo.clone();\n+        }\n+\n+        public String getEncAlg() {\n+            return encAlg;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s,%s,%s]\", kdfAlg, hashAlg, encAlg);\n+        }\n+    }\n+\n+    public static class KEMImpl implements KEMSpi {\n+\n+        @Override\n+        public KEMSpi.EncapsulatorSpi engineNewEncapsulator(\n+                PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(pk instanceof RSAPublicKey rpk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newEncapsulator(spec, rpk, secureRandom);\n+        }\n+\n+        @Override\n+        public KEMSpi.DecapsulatorSpi engineNewDecapsulator(\n+                PrivateKey sk, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(sk instanceof RSAPrivateCrtKey rsk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newDecapsulator(spec, rsk);\n+        }\n+\n+        static class Handler implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+\n+            private final RSAPublicKey rpk; \/\/ not null for encapsulator\n+            private final RSAPrivateKey rsk; \/\/ not null for decapsulator\n+            private final RSAKEMParameterSpec kspec; \/\/ not null\n+            private final SecureRandom sr; \/\/ not null for encapsulator\n+\n+            Handler(AlgorithmParameterSpec spec, RSAPublicKey rpk, RSAPrivateCrtKey rsk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                this.rpk = rpk;\n+                this.rsk = rsk;\n+                this.sr = sr;\n+                if (spec != null) {\n+                    if (spec instanceof RSAKEMParameterSpec rs) {\n+                        this.kspec = rs;\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException();\n+                    }\n+                } else {\n+                    this.kspec = RSAKEMParameterSpec\n+                            .kdf2(\"SHA-256\", \"AES_256\/KW\/NoPadding\");\n+                }\n+            }\n+\n+            static Handler newEncapsulator(AlgorithmParameterSpec spec, RSAPublicKey rpk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                if (sr == null) {\n+                    sr = JCAUtil.getDefSecureRandom();\n+                }\n+                return new Handler(spec, rpk, null, sr);\n+            }\n+\n+            static Handler newDecapsulator(AlgorithmParameterSpec spec, RSAPrivateCrtKey rsk)\n+                    throws InvalidAlgorithmParameterException {\n+                return new Handler(spec, null, rsk, null);\n+            }\n+\n+            @Override\n+            public SecretKey engineDecapsulate(byte[] encapsulation,\n+                    int from, int to, String algorithm)\n+                    throws DecapsulateException {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+                if (encapsulation.length != KeyUtil.getKeySize(rsk) \/ 8) {\n+                    throw new DecapsulateException(\"incorrect encapsulation size\");\n+                }\n+                try {\n+                    byte[] Z = RSACore.rsa(encapsulation, rsk, false);\n+                    return new SecretKeySpec(kdf(Z), from, to - from, algorithm);\n+                } catch (BadPaddingException e) {\n+                    throw new DecapsulateException(\"cannot decrypt\", e);\n+                }\n+            }\n+\n+            @Override\n+            public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                int nLen = rpk.getModulus().bitLength();\n+                int nSize = (nLen + 7) \/ 8;\n+                BigInteger z;\n+                int tried = 0;\n+                while (true) {\n+                    z = new BigInteger(nLen, sr);\n+                    if (z.compareTo(rpk.getModulus()) < 0) {\n+                        break;\n+                    }\n+                    if (tried++ > 20) {\n+                        throw new ProviderException(\"Cannot get good random number\");\n+                    }\n+                }\n+                byte[] Z = z.toByteArray();\n+                if (Z.length > nSize) {\n+                    Z = Arrays.copyOfRange(Z, Z.length - nSize, Z.length);\n+                } else if (Z.length < nSize) {\n+                    byte[] tmp = new byte[nSize];\n+                    System.arraycopy(Z, 0, tmp, nSize - Z.length, Z.length);\n+                    Z = tmp;\n+                }\n+                byte[] c;\n+                try {\n+                    c = RSACore.rsa(Z, rpk);\n+                } catch (BadPaddingException e) {\n+                    throw new AssertionError(e);\n+                }\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(kdf(Z), from, to - from, algorithm),\n+                        c, AlgorithmParametersImpl.encode(kspec));\n+            }\n+\n+            byte[] kdf(byte[] input) {\n+                String hashAlg = kspec.hashAlgorithm();\n+                MessageDigest md;\n+                try {\n+                    md = MessageDigest.getInstance(hashAlg);\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new ProviderException(e);\n+                }\n+                String kdfAlg = kspec.kdfAlgorithm();\n+                byte[] fixedInput = kspec.fixedInfo();\n+                int length = kspec.kdfLen();\n+\n+                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                int n = kdfAlg.equals(\"kdf1\") ? 0 : 1;\n+                while (true) {\n+                    switch (kdfAlg) {\n+                        case \"kdf1\", \"kdf2\" -> {\n+                            md.update(input);\n+                            md.update(u32str(n));\n+                        }\n+                        case \"kdf3\" -> {\n+                            md.update(u32str(n));\n+                            md.update(input);\n+                            md.update(fixedInput);\n+                        }\n+                        default -> throw new ProviderException();\n+                    }\n+                    bout.writeBytes(md.digest());\n+                    if (bout.size() > length) break;\n+                    n++;\n+                }\n+                byte[] result = bout.toByteArray();\n+                return result.length == length\n+                        ? result\n+                        : Arrays.copyOf(result, length);\n+            }\n+\n+            @Override\n+            public int engineSecretSize() {\n+                return kspec.kdfLen();\n+            }\n+\n+            @Override\n+            public int engineEncapsulationSize() {\n+                return KeyUtil.getKeySize(rsk == null ? rpk : rsk) \/ 8;\n+            }\n+        }\n+    }\n+\n+    static byte[] u32str(int i) {\n+        return new byte[] {\n+                (byte)(i >> 24), (byte)(i >> 16), (byte)(i >> 8), (byte)i };\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/*\n+ * @test\n+ * @bug 8307105\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if the certain windows like \"This PC\",\n+ * \"Library\", \"Network\" does not throw Invalid Path Exception on selection.\n+ * @run main\/manual FileChooserInvalidPathExceptionTest\n+ *\/\n+\n+public class FileChooserInvalidPathExceptionTest {\n+    static JFrame frame;\n+    static JFileChooser jfc;\n+    static PassFailJFrame passFailJFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                initialize();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws Exception {\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Navigate to any windows specific folders like My PC\/Libraries\/\n+                Network.\n+                2. Select and traverse through those folders.\n+                3. On click of the mentioned folder if InvalidPathException\n+                occurs does not occur then test is PASS.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser IPE test\");\n+        jfc = new JFileChooser();\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS, 5L, 8, 40);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        jfc.setControlButtonsAreShown(false);\n+        jfc.setDialogType(JFileChooser.CUSTOM_DIALOG);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileChooserInvalidPathExceptionTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -36,1 +38,0 @@\n-import java.awt.event.MouseEvent;\n@@ -38,0 +39,2 @@\n+import java.awt.event.MouseEvent;\n+\n@@ -50,1 +53,0 @@\n-import javax.swing.event.PopupMenuListener;\n@@ -52,0 +54,3 @@\n+import javax.swing.event.PopupMenuListener;\n+\n+import jtreg.SkippedException;\n@@ -53,1 +58,1 @@\n-\/**\n+\/*\n@@ -59,0 +64,2 @@\n+ * The test uses Ctrl+Down Arrow which is a system shortcut on macOS,\n+ * disable it in system settings, otherwise the test will fail\n@@ -60,0 +67,1 @@\n+ * @library \/test\/lib\n@@ -61,0 +69,1 @@\n+ * @build jtreg.SkippedException\n@@ -65,3 +74,0 @@\n-    private boolean done;\n-    private Throwable error;\n-    private static TaskbarPositionTest test;\n@@ -71,0 +77,1 @@\n+\n@@ -73,1 +80,1 @@\n-    private static JMenuBar menubar;\n+\n@@ -76,0 +83,2 @@\n+    private static JMenu submenu;\n+\n@@ -79,1 +88,2 @@\n-    private static String[] numData = {\n+\n+    private static final String[] numData = {\n@@ -82,1 +92,1 @@\n-    private static String[] dayData = {\n+    private static final String[] dayData = {\n@@ -85,1 +95,1 @@\n-    private static char[] mnDayData = {\n+    private static final char[] mnDayData = {\n@@ -92,1 +102,1 @@\n-        frame.setJMenuBar(createMenuBar(\"1 - First Menu\", true));\n+        frame.setJMenuBar(createMenuBar());\n@@ -97,1 +107,1 @@\n-                KeyEvent.VK_DOWN, InputEvent.CTRL_MASK), \"OPEN_POPUP\");\n+                KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK), \"OPEN_POPUP\");\n@@ -106,1 +116,0 @@\n-\n@@ -119,1 +128,2 @@\n-        frame.setLocation(0, screenBounds.y + screenBounds.height - frame.getHeight());\n+        frame.setLocation(screenBounds.x,\n+                screenBounds.y + screenBounds.height - frame.getHeight());\n@@ -123,1 +133,1 @@\n-    public static class ComboPopupCheckListener implements PopupMenuListener {\n+    private static class ComboPopupCheckListener implements PopupMenuListener {\n@@ -125,0 +135,1 @@\n+        @Override\n@@ -128,0 +139,1 @@\n+        @Override\n@@ -131,0 +143,1 @@\n+        @Override\n@@ -132,12 +145,27 @@\n-            Point cpos = combo1.getLocation();\n-            SwingUtilities.convertPointToScreen(cpos, panel);\n-\n-            JPopupMenu pm = (JPopupMenu) combo1.getUI().getAccessibleChild(combo1, 0);\n-\n-            if (pm != null) {\n-                Point p = pm.getLocation();\n-                SwingUtilities.convertPointToScreen(p, pm);\n-                if (p.y+1 < cpos.y) {\n-                    System.out.println(\"p.y \" + p.y + \" cpos.y \" + cpos.y);\n-                    throw new RuntimeException(\"ComboBox popup is wrongly aligned\");\n-                }  \/\/ check that popup was opened down\n+            JComboBox<?> combo = (JComboBox<?>) ev.getSource();\n+            Point comboLoc = combo.getLocationOnScreen();\n+\n+            JPopupMenu popupMenu = (JPopupMenu) combo.getUI().getAccessibleChild(combo, 0);\n+\n+            Point popupMenuLoc = popupMenu.getLocationOnScreen();\n+            Dimension popupSize = popupMenu.getSize();\n+\n+            isPopupOnScreen(popupMenu, fullScreenBounds);\n+\n+            if (comboLoc.x > 0) {\n+                \/\/ The frame is located at the bottom of the screen,\n+                \/\/ the combo popups should open upwards\n+                if (popupMenuLoc.y + popupSize.height < comboLoc.y) {\n+                    System.err.println(\"popup \" + popupMenuLoc\n+                            + \" combo \" + comboLoc);\n+                    throw new RuntimeException(\"ComboBox popup should open upwards\");\n+                }\n+            } else {\n+                \/\/ The frame has been moved to negative position away from\n+                \/\/ the bottom of the screen, the combo popup should\n+                \/\/ open downwards in this case\n+                if (popupMenuLoc.y + 1 < comboLoc.y) {\n+                    System.err.println(\"popup \" + popupMenuLoc\n+                            + \" combo \" + comboLoc);\n+                    throw new RuntimeException(\"ComboBox popup should open downwards\");\n+                }\n@@ -148,2 +176,2 @@\n-    private class PopupHandler extends AbstractAction {\n-\n+    private static class PopupHandler extends AbstractAction {\n+        @Override\n@@ -158,1 +186,1 @@\n-    class PopupListener extends MouseAdapter {\n+    private static class PopupListener extends MouseAdapter {\n@@ -160,1 +188,1 @@\n-        private JPopupMenu popup;\n+        private final JPopupMenu popup;\n@@ -166,0 +194,1 @@\n+        @Override\n@@ -170,0 +199,1 @@\n+        @Override\n@@ -185,1 +215,4 @@\n-    public static void isPopupOnScreen(JPopupMenu popup, Rectangle checkBounds) {\n+    private static void isPopupOnScreen(JPopupMenu popup, Rectangle checkBounds) {\n+        if (!popup.isVisible()) {\n+            throw new RuntimeException(\"Popup not visible\");\n+        }\n@@ -187,2 +220,1 @@\n-        Point pt = new Point();\n-        SwingUtilities.convertPointToScreen(pt, popup);\n+        Point pt = popup.getLocationOnScreen();\n@@ -192,1 +224,2 @@\n-            throw new RuntimeException(\"We do not match! \" + checkBounds + \" \/ \" + bounds);\n+            throw new RuntimeException(\"Popup is outside of screen bounds \"\n+                    + checkBounds + \" \/ \" + bounds);\n@@ -194,0 +227,1 @@\n+    }\n@@ -195,0 +229,6 @@\n+    private static void isComboPopupOnScreen(JComboBox<?> comboBox) {\n+        if (!comboBox.isPopupVisible()) {\n+            throw new RuntimeException(\"ComboBox popup not visible\");\n+        }\n+        JPopupMenu popupMenu = (JPopupMenu) comboBox.getUI().getAccessibleChild(comboBox, 0);\n+        isPopupOnScreen(popupMenu, screenBounds);\n@@ -197,2 +237,0 @@\n-    private JPanel createContentPane() {\n-        JPanel panel = new JPanel();\n@@ -200,0 +238,1 @@\n+    private JPanel createContentPane() {\n@@ -201,1 +240,2 @@\n-        panel.add(combo1);\n+        combo1.addPopupMenuListener(new ComboPopupCheckListener());\n+\n@@ -204,2 +244,1 @@\n-        panel.add(combo2);\n-        panel.setSize(300, 200);\n+        combo2.addPopupMenuListener(new ComboPopupCheckListener());\n@@ -208,1 +247,0 @@\n-        JMenuItem item;\n@@ -210,1 +248,1 @@\n-            item = popupMenu.add(new JMenuItem(dayData[i], mnDayData[i]));\n+            JMenuItem item = popupMenu.add(new JMenuItem(dayData[i], mnDayData[i]));\n@@ -213,1 +251,0 @@\n-        panel.addMouseListener(new PopupListener(popupMenu));\n@@ -218,1 +255,1 @@\n-                KeyEvent.VK_DOWN, InputEvent.CTRL_MASK), \"OPEN_POPUP\");\n+                KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK), \"OPEN_POPUP\");\n@@ -221,0 +258,5 @@\n+        JPanel panel = new JPanel();\n+        panel.add(combo1);\n+        panel.add(combo2);\n+        panel.setSize(300, 200);\n+        panel.addMouseListener(new PopupListener(popupMenu));\n@@ -226,10 +268,2 @@\n-    \/**\n-     * @param str name of Menu\n-     * @param bFlag set mnemonics on menu items\n-     *\/\n-    private JMenuBar createMenuBar(String str, boolean bFlag) {\n-        menubar = new JMenuBar();\n-\n-        menu1 = new JMenu(str);\n-        menu1.setMnemonic(str.charAt(0));\n-        menu1.addActionListener(this);\n+    private JMenuBar createMenuBar() {\n+        JMenuBar menubar = new JMenuBar();\n@@ -237,0 +271,3 @@\n+        menu1 = new JMenu(\"1 - First Menu\");\n+        menu1.setMnemonic('1');\n+        createSubMenu(menu1, \"1 JMenuItem\", 8, null);\n@@ -238,8 +275,0 @@\n-        for (int i = 0; i < 8; i++) {\n-            JMenuItem menuitem = new JMenuItem(\"1 JMenuItem\" + i);\n-            menuitem.addActionListener(this);\n-            if (bFlag) {\n-                menuitem.setMnemonic('0' + i);\n-            }\n-            menu1.add(menuitem);\n-        }\n@@ -247,1 +276,0 @@\n-        \/\/ second menu\n@@ -249,1 +277,0 @@\n-        menu2.addActionListener(this);\n@@ -251,1 +278,2 @@\n-\n+        createSubMenu(menu2, \"2 JMenuItem\", 4, null);\n+        menu2.add(new JSeparator());\n@@ -253,3 +281,0 @@\n-        for (int i = 0; i < 5; i++) {\n-            JMenuItem menuitem = new JMenuItem(\"2 JMenuItem\" + i);\n-            menuitem.addActionListener(this);\n@@ -257,6 +282,1 @@\n-            if (bFlag) {\n-                menuitem.setMnemonic('0' + i);\n-            }\n-            menu2.add(menuitem);\n-        }\n-        JMenu submenu = new JMenu(\"Sub Menu\");\n+        submenu = new JMenu(\"Sub Menu\");\n@@ -264,10 +284,1 @@\n-        submenu.addActionListener(this);\n-        for (int i = 0; i < 5; i++) {\n-            JMenuItem menuitem = new JMenuItem(\"S JMenuItem\" + i);\n-            menuitem.addActionListener(this);\n-            if (bFlag) {\n-                menuitem.setMnemonic('0' + i);\n-            }\n-            submenu.add(menuitem);\n-        }\n-        menu2.add(new JSeparator());\n+        createSubMenu(submenu, \"S JMenuItem\", 4, this);\n@@ -279,0 +290,11 @@\n+    private static void createSubMenu(JMenu menu, String prefix, int count, ActionListener action) {\n+        for (int i = 0; i < count; ++i) {\n+            JMenuItem menuitem = new JMenuItem(prefix + i);\n+            menu.add(menuitem);\n+            if (action != null) {\n+                menuitem.addActionListener(action);\n+            }\n+        }\n+    }\n+\n+\n@@ -282,1 +304,1 @@\n-            \/\/ put the focus on the noneditable combo.\n+            \/\/ put the focus on the non-editable combo.\n@@ -287,0 +309,5 @@\n+    private static void hidePopup(Robot robot) {\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+    }\n+\n@@ -288,0 +315,24 @@\n+        GraphicsDevice mainScreen = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                                       .getDefaultScreenDevice();\n+        Rectangle mainScreenBounds = mainScreen.getDefaultConfiguration()\n+                                               .getBounds();\n+        GraphicsDevice[] screens = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                                      .getScreenDevices();\n+        for (GraphicsDevice screen : screens) {\n+            if (screen == mainScreen) {\n+                continue;\n+            }\n+\n+            Rectangle bounds = screen.getDefaultConfiguration()\n+                                     .getBounds();\n+            if (bounds.x < 0) {\n+                \/\/ The test may fail if a screen have negative origin\n+                throw new SkippedException(\"Configurations with negative screen\"\n+                                           + \" origin are not supported\");\n+            }\n+            if (bounds.y >= mainScreenBounds.height) {\n+                \/\/ The test may fail if there's a screen to bottom of the main monitor\n+                throw new SkippedException(\"Configurations with a screen beneath\"\n+                                           + \" the main one are not supported\");\n+            }\n+        }\n@@ -291,2 +342,1 @@\n-            Robot robot;\n-            robot = new Robot();\n+            Robot robot = new Robot();\n@@ -295,5 +345,1 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                public void run() {\n-                    test = new TaskbarPositionTest();\n-                }\n-            });\n+            SwingUtilities.invokeAndWait(TaskbarPositionTest::new);\n@@ -313,1 +359,3 @@\n-            Util.hitMnemonics(robot, KeyEvent.VK_S);\n+            \/\/ Open the submenu\n+            robot.keyPress(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_S);\n@@ -317,0 +365,1 @@\n+            SwingUtilities.invokeAndWait(() -> isPopupOnScreen(submenu.getPopupMenu(), screenBounds));\n@@ -318,0 +367,3 @@\n+            \/\/ Hit Enter to perform the action of\n+            \/\/ a selected menu item in the submenu\n+            \/\/ which requests focus on combo1, non-editable combo box\n@@ -321,1 +373,0 @@\n-            \/\/ Focus should go to non editable combo box\n@@ -323,1 +374,0 @@\n-            robot.delay(500);\n@@ -325,0 +375,2 @@\n+            \/\/ Focus should go to combo1\n+            \/\/ Open combo1 popup\n@@ -326,0 +378,1 @@\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n@@ -327,1 +380,3 @@\n-            \/\/ How do we check combo boxes?\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> isComboPopupOnScreen(combo1));\n+            hidePopup(robot);\n@@ -329,1 +384,1 @@\n-            \/\/ Editable combo box\n+            \/\/ Move focus to combo2, editable combo box\n@@ -332,0 +387,4 @@\n+\n+            robot.waitForIdle();\n+\n+            \/\/ Open combo2 popup\n@@ -335,1 +394,3 @@\n-            \/\/ combo1.getUI();\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> isComboPopupOnScreen(combo2));\n+            hidePopup(robot);\n@@ -337,1 +398,1 @@\n-            \/\/ Popup from Text field\n+            \/\/ Move focus to the text field\n@@ -340,0 +401,4 @@\n+\n+            robot.waitForIdle();\n+\n+            \/\/ Open its popup\n@@ -345,6 +410,12 @@\n-            \/\/ Popup from a mouse click.\n-            Point pt = new Point(2, 2);\n-            SwingUtilities.convertPointToScreen(pt, panel);\n-            robot.mouseMove(pt.x, pt.y);\n-            robot.mousePress(InputEvent.BUTTON3_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON3_MASK);\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> isPopupOnScreen(popupMenu, fullScreenBounds));\n+            hidePopup(robot);\n+\n+            \/\/ Popup from a mouse click\n+            SwingUtilities.invokeAndWait(() -> {\n+                Point pt = panel.getLocationOnScreen();\n+                pt.translate(4, 4);\n+                robot.mouseMove(pt.x, pt.y);\n+            });\n+            robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n@@ -352,0 +423,1 @@\n+            \/\/ Ensure popupMenu is shown within screen bounds\n@@ -353,6 +425,7 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                public void run() {\n-                    frame.setLocation(-30, 100);\n-                    combo1.addPopupMenuListener(new ComboPopupCheckListener());\n-                    combo1.requestFocus();\n-                }\n+            SwingUtilities.invokeAndWait(() -> isPopupOnScreen(popupMenu, fullScreenBounds));\n+            hidePopup(robot);\n+\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame.setLocation(-30, 100);\n+                combo1.requestFocus();\n@@ -361,0 +434,3 @@\n+            robot.waitForIdle();\n+\n+            \/\/ Open combo1 popup again\n@@ -363,2 +439,4 @@\n-            robot.keyPress(KeyEvent.VK_ESCAPE);\n-            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+\n+            robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> isComboPopupOnScreen(combo1));\n+            hidePopup(robot);\n","filename":"test\/jdk\/javax\/swing\/Popup\/TaskbarPositionTest.java","additions":192,"deletions":114,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8306119\n+ * @summary Verifies FocusEvent cause when components requests focus\n+ *          via mouse events\n+ * @run main FocusEventCauseTest\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+\n+public class FocusEventCauseTest {\n+    static JFrame frame;\n+    static JButton button1;\n+    static JButton button2;\n+    static volatile Point pt;\n+    static volatile Dimension dim;\n+    static volatile boolean expected;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame(\"FocusEventCauseTest\");\n+                JPanel panel = new JPanel();\n+                button1 = new JButton(\"Button1\");\n+                button2 = new JButton(\"Button2\");\n+                button2.addFocusListener(new FocusAdapter() {\n+                    @Override\n+                    public void focusGained(FocusEvent e) {\n+                        System.out.println(\"FocusEvent getCause \" + e.getCause());\n+                        if (e.getCause() == FocusEvent.Cause.MOUSE_EVENT) {\n+                            expected = true;\n+                        }\n+                    }\n+                });\n+                panel.add(button1);\n+                panel.add(button2);\n+                frame.add(panel);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                pt = button2.getLocationOnScreen();\n+                dim = button2.getSize();\n+            });\n+            robot.mouseMove(pt.x + dim.width\/2, pt.y + dim.height\/2);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            if (!expected) {\n+                throw new RuntimeException(\"Focus requested without \" +\n+                                           \"supplying expected cause\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/event\/FocusEventCauseTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -193,1 +193,1 @@\n-                            assertThrows(IllegalStateException.class, () -> {\n+                            assertThrows(IllegalArgumentException.class, () -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        assertThrows(IllegalStateException.class, () ->\n+        assertThrows(IllegalArgumentException.class, () ->\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        assertThrows(IllegalStateException.class, () -> Classfile.build(ClassDesc.of(\"cls\"), clb ->\n+        assertThrows(IllegalArgumentException.class, () -> Classfile.build(ClassDesc.of(\"cls\"), clb ->\n","filename":"test\/jdk\/jdk\/classfile\/FilterDeadLabelsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        assertThrows(IllegalStateException.class, () -> generateFwd(sample, true, Classfile.Option.fixShortJumps(false)));\n+        assertThrows(IllegalArgumentException.class, () -> generateFwd(sample, true, Classfile.Option.fixShortJumps(false)));\n@@ -124,1 +124,1 @@\n-        assertThrows(IllegalStateException.class, () -> generateBack(sample, true, Classfile.Option.fixShortJumps(false)));\n+        assertThrows(IllegalArgumentException.class, () -> generateBack(sample, true, Classfile.Option.fixShortJumps(false)));\n@@ -148,1 +148,1 @@\n-        assertThrows(IllegalStateException.class, () ->\n+        assertThrows(IllegalArgumentException.class, () ->\n@@ -158,1 +158,1 @@\n-        assertThrows(IllegalStateException.class, () ->\n+        assertThrows(IllegalArgumentException.class, () ->\n@@ -186,1 +186,1 @@\n-        assertThrows(IllegalStateException.class, () ->\n+        assertThrows(IllegalArgumentException.class, () ->\n@@ -196,1 +196,1 @@\n-        assertThrows(IllegalStateException.class, () ->\n+        assertThrows(IllegalArgumentException.class, () ->\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        var error = assertThrows(IllegalStateException.class, () -> testTransformedStackMaps(buildDeadCode(), Classfile.Option.patchDeadCode(false)));\n+        var error = assertThrows(IllegalArgumentException.class, () -> testTransformedStackMaps(buildDeadCode(), Classfile.Option.patchDeadCode(false)));\n@@ -175,1 +175,1 @@\n-        var error = assertThrows(IllegalStateException.class, () ->\n+        var error = assertThrows(IllegalArgumentException.class, () ->\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,452 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ScopedValue API\n- * @modules jdk.incubator.concurrent\n- * @run junit ScopeValueAPI\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class ScopeValueAPI {\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n-    }\n-\n-    \/**\n-     * Test that the run method is invoked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRun(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class Box { static boolean executed; }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue.where(name, \"duke\", () -> { Box.executed = true; });\n-            assertTrue(Box.executed);\n-        });\n-    }\n-\n-    \/**\n-     * Test the run method throwing an exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRunThrows(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException {  }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            Runnable op = () -> { throw new FooException(); };\n-            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test that the call method is invoked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCall(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            String result = ScopedValue.where(name, \"duke\", name::get);\n-            assertEquals(\"duke\", result);\n-        });\n-    }\n-\n-    \/**\n-     * Test the call method throwing an exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCallThrows(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException {  }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            Callable<Void> op = () -> { throw new FooException(); };\n-            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test get method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testGet(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name1 = ScopedValue.newInstance();\n-            ScopedValue<String> name2 = ScopedValue.newInstance();\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-\n-            \/\/ run\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertEquals(\"duke\", name1.get());\n-                assertThrows(NoSuchElementException.class, name2::get);\n-\n-            });\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-\n-            \/\/ call\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertEquals(\"duke\", name1.get());\n-                assertThrows(NoSuchElementException.class, name2::get);\n-                return null;\n-            });\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-        });\n-    }\n-\n-    \/**\n-     * Test isBound method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testIsBound(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name1 = ScopedValue.newInstance();\n-            ScopedValue<String> name2 = ScopedValue.newInstance();\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-\n-            \/\/ run\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertTrue(name1.isBound());\n-                assertFalse(name2.isBound());\n-            });\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertTrue(name1.isBound());\n-                assertFalse(name2.isBound());\n-                return null;\n-            });\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test orElse method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testOrElse(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            assertNull(name.orElse(null));\n-            assertEquals(\"default\", name.orElse(\"default\"));\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElse(null));\n-                assertEquals(\"duke\", name.orElse(\"default\"));\n-            });\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElse(null));\n-                assertEquals(\"duke\", name.orElse(\"default\"));\n-                return null;\n-            });\n-        });\n-    }\n-\n-    \/**\n-     * Test orElseThrow method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testOrElseThrow(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException { }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n-            });\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n-                return null;\n-            });\n-        });\n-    }\n-\n-    \/**\n-     * Test two bindings.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testTwoBindings(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n-                assertTrue(name.isBound());\n-                assertTrue(age.isBound());\n-                assertEquals(\"duke\", name.get());\n-                assertEquals(100, (int) age.get());\n-            });\n-            assertFalse(name.isBound());\n-            assertFalse(age.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n-                assertTrue(name.isBound());\n-                assertTrue(age.isBound());\n-                assertEquals(\"duke\", name.get());\n-                assertEquals(100, (int) age.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-            assertFalse(age.isBound());\n-\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebinding(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertEquals(\"duchess\", name.get());\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertEquals(\"duchess\", name.get());\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding from null vaue to another value.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebindingFromNull(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertTrue(\"duchess\".equals(name.get()));\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertTrue(\"duchess\".equals(name.get()));\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding to null value.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebindingToNull(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, null, () -> {\n-                    assertTrue(name.isBound());\n-                    assertNull(name.get());\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, null, () -> {\n-                    assertTrue(name.isBound());\n-                    assertNull(name.get());\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test Carrier.get.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCarrierGet(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-            \/\/ one scoped value\n-            var carrier1 = ScopedValue.where(name, \"duke\");\n-            assertEquals(\"duke\", carrier1.get(name));\n-            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n-\n-            \/\/ two scoped values\n-            var carrier2 = carrier1.where(age, 20);\n-            assertEquals(\"duke\", carrier2.get(name));\n-            assertEquals(20, (int) carrier2.get(age));\n-        });\n-    }\n-\n-    \/**\n-     * Test NullPointerException.\n-     *\/\n-    @Test\n-    void testNullPointerException() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n-\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-\n-        var carrier = ScopedValue.where(name, \"duke\");\n-        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> carrier.get(null));\n-        assertThrows(NullPointerException.class, () -> carrier.run(null));\n-        assertThrows(NullPointerException.class, () -> carrier.call(null));\n-    }\n-\n-    @FunctionalInterface\n-    private interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    \/**\n-     * Run the given task in a thread created with the given thread factory.\n-     * @throws Exception if the task throws an exception\n-     *\/\n-    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n-        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-            var future = executor.submit(() -> {\n-                task.run();\n-                return null;\n-            });\n-            try {\n-                future.get();\n-            } catch (ExecutionException ee) {\n-                Throwable cause = ee.getCause();\n-                if (cause instanceof Exception e)\n-                    throw e;\n-                if (cause instanceof Error e)\n-                    throw e;\n-                throw new RuntimeException(cause);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":0,"deletions":452,"binary":false,"changes":452,"status":"deleted"},{"patch":"@@ -1,1305 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=platform\n- * @bug 8284199\n- * @summary Basic tests for StructuredTaskScope\n- * @modules jdk.incubator.concurrent\n- * @run junit\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n- *\/\n-\n-\/*\n- * @test id=virtual\n- * @modules jdk.incubator.concurrent\n- * @run junit\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n- *\/\n-\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n-import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnFailure;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.time.Duration;\n-import java.io.IOException;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.NoSuchElementException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StructuredTaskScopeTest {\n-    private static ScheduledExecutorService scheduler;\n-    private static List<ThreadFactory> threadFactories;\n-\n-    @BeforeAll\n-    static void setup() throws Exception {\n-        scheduler = Executors.newSingleThreadScheduledExecutor();\n-\n-        \/\/ thread factories\n-        String value = System.getProperty(\"threadFactory\");\n-        List<ThreadFactory> list = new ArrayList<>();\n-        if (value == null || value.equals(\"platform\"))\n-            list.add(Thread.ofPlatform().factory());\n-        if (value == null || value.equals(\"virtual\"))\n-            list.add(Thread.ofVirtual().factory());\n-        assertTrue(list.size() > 0, \"No thread factories for tests\");\n-        threadFactories = list;\n-    }\n-\n-    @AfterAll\n-    static void shutdown() {\n-        scheduler.shutdown();\n-    }\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return threadFactories.stream();\n-    }\n-\n-    \/**\n-     * Test that each fork creates a thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFork1(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> count.incrementAndGet());\n-            }\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 100);\n-    }\n-\n-    \/**\n-     * Test that fork uses the specified thread factory.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFork2(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        ThreadFactory countingFactory = task -> {\n-            count.incrementAndGet();\n-            return factory.newThread(task);\n-        };\n-        try (var scope = new StructuredTaskScope(null, countingFactory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> null);\n-            }\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 100);\n-    }\n-\n-    \/**\n-     * Test fork is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope();\n-             var scope2 = new StructuredTaskScope()) {\n-\n-            \/\/ thread in scope1 cannot fork thread in scope2\n-            Future<Void> future1 = scope1.fork(() -> {\n-                scope2.fork(() -> null).get();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ thread in scope2 can fork thread in scope1\n-            Future<Void> future2 = scope2.fork(() -> {\n-                scope1.fork(() -> null).get();\n-                return null;\n-            });\n-            future2.get();\n-            assertNull(future2.resultNow());\n-\n-            \/\/ random thread cannot fork\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future = pool.submit(() -> {\n-                    scope1.fork(() -> null);\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope2.join();\n-            scope1.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when scope is shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.shutdown();\n-            Future<String> future = scope.fork(() -> {\n-                count.incrementAndGet();\n-                return \"foo\";\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 0);   \/\/ check that task did not run.\n-    }\n-\n-    \/**\n-     * Test fork when scope is closed.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterClose(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.fork(() -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when the thread factory rejects creating a thread.\n-     *\/\n-    @Test\n-    void testForkReject() throws Exception {\n-        ThreadFactory factory = task -> null;\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            assertThrows(RejectedExecutionException.class, () -> scope.fork(() -> null));\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * A StructuredTaskScope that collects all Future objects notified to the\n-     * handleComplete method.\n-     *\/\n-    private static class CollectAll<T> extends StructuredTaskScope<T> {\n-        private final List<Future<T>> futures = new CopyOnWriteArrayList<>();\n-\n-        CollectAll(ThreadFactory factory) {\n-            super(null, factory);\n-        }\n-\n-        @Override\n-        protected void handleComplete(Future<T> future) {\n-            assertTrue(future.isDone());\n-            futures.add(future);\n-        }\n-\n-        Stream<Future<T>> futures() {\n-            return futures.stream();\n-        }\n-\n-        Set<Future<T>> futuresAsSet() {\n-            return futures.stream().collect(Collectors.toSet());\n-        }\n-    }\n-\n-    \/**\n-     * Test that handleComplete method is invoked for tasks that complete normally\n-     * and abnormally.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleComplete1(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll(factory)) {\n-\n-            \/\/ completes normally\n-            Future<String> future1 = scope.fork(() -> \"foo\");\n-\n-            \/\/ completes with exception\n-            Future<String> future2 = scope.fork(() -> { throw new FooException(); });\n-\n-            \/\/ cancelled\n-            Future<String> future3 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            future3.cancel(true);\n-\n-            scope.join();\n-\n-            Set<Future<String>> futures = scope.futuresAsSet();\n-            assertEquals(Set.of(future1, future2, future3), futures);\n-        }\n-    }\n-\n-    \/**\n-     * Test that the handeComplete method is not invoked after the scope has been shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleComplete2(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll(factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            Future<String> future1 = scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            \/\/ start a second task to shutdown the scope after a short delay\n-            Future<String> future2 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(100));\n-                scope.shutdown();\n-                return null;\n-            });\n-\n-            scope.join();\n-\n-            \/\/ let task finish\n-            latch.countDown();\n-\n-            \/\/ handleComplete should not have been called\n-            assertTrue(future1.isDone());\n-            assertTrue(scope.futures().count() == 0L);\n-        }\n-    }\n-\n-    \/**\n-     * Test join with no threads.\n-     *\/\n-    @Test\n-    void testJoinWithNoThreads() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join with threads running.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithThreads(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return \"foo\";\n-            });\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test join is owner confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ attempt to join on thread in scope\n-            Future<Void> future1 = scope.fork(() -> {\n-                scope.join();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ random thread cannot join\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    scope.join();\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoin1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ join should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.join();\n-                fail(\"join did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupt of thread blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoin2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ join should throw\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            try {\n-                scope.join();\n-                fail(\"join did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test join when scope is already shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-            scope.shutdown();  \/\/ interrupts task\n-            scope.join();\n-\n-            \/\/ task should have completed abnormally\n-            assertTrue(future.isDone() && future.state() != Future.State.SUCCESS);\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown when owner is blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n-            }\n-            @Override\n-            protected void handleComplete(Future<T> future) {\n-                shutdown();\n-            }\n-        }\n-\n-        try (var scope = new MyScope(factory)) {\n-            Future<String> future1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-            Future<String> future2 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return null;\n-            });\n-            scope.join();\n-\n-            \/\/ task1 should have completed abnormally\n-            assertTrue(future1.isDone() && future1.state() != Future.State.SUCCESS);\n-\n-            \/\/ task2 should have completed normally\n-            assertTrue(future2.isDone() && future2.state() == Future.State.SUCCESS);\n-        }\n-    }\n-\n-    \/**\n-     * Test join after scope is shutdown.\n-     *\/\n-    @Test\n-    void testJoinAfterShutdown() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.shutdown();\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join after scope is closed.\n-     *\/\n-    @Test\n-    void testJoinAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.join());\n-            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil, threads finish before deadline expires.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(2));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            long startMillis = millisTime();\n-            scope.joinUntil(Instant.now().plusSeconds(30));\n-            assertTrue(future.isDone());\n-            assertNull(future.resultNow());\n-            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil, deadline expires before threads finish.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            long startMillis = millisTime();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(2));\n-            } catch (TimeoutException e) {\n-                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-            }\n-            assertFalse(future.isDone());\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil many times.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            try {\n-                for (int i = 0; i < 3; i++) {\n-                    try {\n-                        scope.joinUntil(Instant.now().plusMillis(50));\n-                        fail(\"joinUntil did not throw\");\n-                    } catch (TimeoutException expected) {\n-                        assertFalse(future.isDone());\n-                    }\n-                }\n-            } finally {\n-                future.cancel(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil with a deadline that has already expired.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil4(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            try {\n-\n-                \/\/ now\n-                try {\n-                    scope.joinUntil(Instant.now());\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertFalse(future.isDone());\n-                }\n-\n-                \/\/ in the past\n-                try {\n-                    scope.joinUntil(Instant.now().minusSeconds(1));\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertFalse(future.isDone());\n-                }\n-\n-            } finally {\n-                future.cancel(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ joinUntil should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupt of thread blocked in joinUntil.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ joinUntil should throw\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(10));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown after scope is closed.\n-     *\/\n-    @Test\n-    void testShutdownAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.shutdown());\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope();\n-             var scope2 = new StructuredTaskScope()) {\n-\n-            \/\/ random thread cannot shutdown\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future = pool.submit(() -> {\n-                    scope1.shutdown();\n-                    return null;\n-                });\n-                Throwable ex = assertThrows(ExecutionException.class, future::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            \/\/ thread in scope1 cannot shutdown scope2\n-            Future<Void> future1 = scope1.fork(() -> {\n-                scope2.shutdown();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ thread in scope2 can shutdown scope1\n-            Future<Void> future2 = scope2.fork(() -> {\n-                scope1.shutdown();\n-                return null;\n-            });\n-            future2.get();\n-            assertNull(future2.resultNow());\n-\n-            scope2.join();\n-            scope1.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test close without join, no threads forked.\n-     *\/\n-    @Test\n-    void testCloseWithoutJoin1() {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ do nothing\n-        }\n-    }\n-\n-    \/**\n-     * Test close without join, threads forked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin2(ThreadFactory factory) {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            assertThrows(IllegalStateException.class, scope::close);\n-            assertTrue(future.isDone() && future.exceptionNow() != null);\n-        }\n-    }\n-\n-    \/**\n-     * Test close with threads forked after join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.join();\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            assertThrows(IllegalStateException.class, scope::close);\n-            assertTrue(future.isDone() && future.exceptionNow() != null);\n-        }\n-    }\n-\n-    \/**\n-     * Test close is owner confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ attempt to close on thread in scope\n-            Future<Void> future1 = scope.fork(() -> {\n-                scope.close();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ random thread cannot close scope\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    scope.close();\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test close with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptClose1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-            scope.join();\n-\n-            \/\/ release task after a delay\n-            scheduler.schedule(latch::countDown, 100, TimeUnit.MILLISECONDS);\n-\n-            \/\/ invoke close with interrupt status set\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.close();\n-            } finally {\n-                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupting thread waiting in close.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptClose2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-            scope.join();\n-\n-            \/\/ release task after a delay\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            scheduler.schedule(latch::countDown, 3, TimeUnit.SECONDS);\n-            try {\n-                scope.close();\n-            } finally {\n-                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test that closing an enclosing scope closes the thread flock of a\n-     * nested scope.\n-     *\/\n-    @Test\n-    void testStructureViolation1() throws Exception {\n-        try (var scope1 = new StructuredTaskScope()) {\n-            try (var scope2 = new StructuredTaskScope()) {\n-\n-                \/\/ join + close enclosing scope\n-                scope1.join();\n-                try {\n-                    scope1.close();\n-                    fail(\"close did not throw\");\n-                } catch (StructureViolationException expected) { }\n-\n-                \/\/ underlying flock should be closed, fork should return a cancelled task\n-                AtomicBoolean ran = new AtomicBoolean();\n-                Future<String> future = scope2.fork(() -> {\n-                    ran.set(true);\n-                    return null;\n-                });\n-                assertTrue(future.isCancelled());\n-                scope2.join();\n-                assertFalse(ran.get());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task completes normally.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(20));\n-                return \"foo\";\n-            });\n-\n-            assertEquals(\"foo\", future.get());\n-            assertTrue(future.state() == Future.State.SUCCESS);\n-            assertEquals(\"foo\", future.resultNow());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task completes with exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(20));\n-                throw new FooException();\n-            });\n-\n-            Throwable ex = assertThrows(ExecutionException.class, future::get);\n-            assertTrue(ex.getCause() instanceof FooException);\n-            assertTrue(future.state() == Future.State.FAILED);\n-            assertTrue(future.exceptionNow() instanceof FooException);\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task is cancelled.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            \/\/ timed-get, should timeout\n-            try {\n-                future.get(20, TimeUnit.MILLISECONDS);\n-                fail(\"Future.get did not throw\");\n-            } catch (TimeoutException expected) { }\n-\n-            future.cancel(true);\n-            assertThrows(CancellationException.class, future::get);\n-            assertTrue(future.state() == Future.State.CANCELLED);\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test scope shutdown with a thread blocked in Future::get.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFutureWithShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            \/\/ long running task\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            \/\/ start a thread to wait in Future::get\n-            AtomicBoolean waitDone = new AtomicBoolean();\n-            Thread waiter = Thread.startVirtualThread(() -> {\n-                try {\n-                    future.get();\n-                } catch (ExecutionException | CancellationException e) {\n-                    waitDone.set(true);\n-                } catch (InterruptedException e) {\n-                    System.out.println(\"waiter thread interrupted!\");\n-                }\n-            });\n-\n-            \/\/ shutdown scope\n-            scope.shutdown();\n-\n-            \/\/ Future should be done and thread should be awakened\n-            assertTrue(future.isDone());\n-            waiter.join();\n-            assertTrue(waitDone.get());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::cancel throws if invoked by a thread that is not in the tree.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFutureCancelConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            Future<String> future1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-\n-            \/\/ random thread cannot cancel\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    future1.cancel(true);\n-                    return null;\n-                });\n-                Throwable ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            } finally {\n-                future1.cancel(true);\n-            }\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test StructuredTaskScope::toString includes the scope name.\n-     *\/\n-    @Test\n-    void testToString() throws Exception {\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope(\"xxx\", factory)) {\n-            \/\/ open\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-\n-            \/\/ shutdown\n-            scope.shutdown();\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-\n-            \/\/ closed\n-            scope.join();\n-            scope.close();\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-        }\n-    }\n-\n-    \/**\n-     * Test for NullPointerException.\n-     *\/\n-    @Test\n-    void testNulls() throws Exception {\n-        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n-        try (var scope = new StructuredTaskScope()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-        }\n-\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess(\"\", null));\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.result(null));\n-        }\n-\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with no completed tasks.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess1() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-            assertThrows(IllegalStateException.class, () -> scope.result());\n-            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with tasks that completed normally.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess2() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ two tasks complete normally\n-            scope.fork(() -> \"foo\");\n-            scope.join();  \/\/ ensures foo completes first\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with tasks that completed normally and abnormally.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess3() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ one task completes normally, the other with an exception\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with a task that completed with an exception.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess4() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ tasks completes with exception\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n-            assertTrue(ex.getCause() instanceof  ArithmeticException);\n-\n-            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof  ArithmeticException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with a cancelled task.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess5() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ cancelled task\n-            var future = scope.fork(() -> {\n-                Thread.sleep(60_000);\n-                return null;\n-            });\n-            future.cancel(false);\n-\n-            scope.join();\n-\n-            assertThrows(CancellationException.class, () -> scope.result());\n-            Throwable ex = assertThrows(FooException.class,\n-                                        () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof CancellationException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with no completed tasks.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure1() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with tasks that completed normally.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure2() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-\n-            \/\/ no exception\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with tasks that completed normally and abnormally.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure3() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-\n-            \/\/ one task completes normally, the other with an exception\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof ArithmeticException);\n-\n-            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with a cancelled task.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure4() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-\n-            var future = scope.fork(() -> {\n-                Thread.sleep(60_000);\n-                return null;\n-            });\n-            future.cancel(false);\n-\n-            scope.join();\n-\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof CancellationException);\n-\n-            assertThrows(CancellationException.class, () -> scope.throwIfFailed());\n-\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof CancellationException);\n-        }\n-    }\n-\n-    \/**\n-     * A runtime exception for tests.\n-     *\/\n-    private static class FooException extends RuntimeException {\n-        FooException() { }\n-        FooException(Throwable cause) { super(cause); }\n-    }\n-\n-    \/**\n-     * Schedules a thread to be interrupted after the given delay.\n-     *\/\n-    private void scheduleInterrupt(Thread thread, Duration delay) {\n-        long millis = delay.toMillis();\n-        scheduler.schedule(thread::interrupt, millis, TimeUnit.MILLISECONDS);\n-    }\n-\n-    \/**\n-     * Returns the current time in milliseconds.\n-     *\/\n-    private static long millisTime() {\n-        long now = System.nanoTime();\n-        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n-    }\n-\n-    \/**\n-     * Check the duration of a task\n-     * @param start start time, in milliseconds\n-     * @param min minimum expected duration, in milliseconds\n-     * @param max maximum expected duration, in milliseconds\n-     * @return the duration (now - start), in milliseconds\n-     *\/\n-    private static long expectDuration(long start, long min, long max) {\n-        long duration = millisTime() - start;\n-        assertTrue(duration >= min,\n-                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n-        assertTrue(duration <= max,\n-                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n-        return duration;\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":0,"deletions":1305,"binary":false,"changes":1305,"status":"deleted"},{"patch":"@@ -1,219 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Basic tests for StructuredTaskScope with scoped values\n- * @modules jdk.incubator.concurrent\n- * @run junit WithScopedValue\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class WithScopedValue {\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n-    }\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a child thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future = scope.fork(() -> {\n-                    return name.get(); \/\/ child should read \"x\"\n-                });\n-                scope.join();\n-                return future.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a grandchild thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n-                        Future<String> future2 = scope2.fork(() -> {\n-                            return name.get(); \/\/ grandchild should read \"x\"\n-                        });\n-                        scope2.join();\n-                        return future2.resultNow();\n-                    }\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a rebound scoped value into a grandchild thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-\n-                    \/\/ rebind name to \"y\"\n-                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n-                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n-                            Future<String> future2 = scope2.fork(() -> {\n-                                return name.get(); \/\/ grandchild should read \"y\"\n-                            });\n-                            scope2.join();\n-                            return future2.resultNow();\n-                        }\n-                    });\n-\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-                    return grandchildValue;\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"y\");\n-    }\n-\n-    \/**\n-     * Test exiting a dynamic scope with an open task scope.\n-     *\/\n-    @Test\n-    void testStructureViolation1() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        class Box {\n-            StructuredTaskScope<Object> scope;\n-        }\n-        var box = new Box();\n-        try {\n-            try {\n-                ScopedValue.where(name, \"x\", () -> {\n-                    box.scope = new StructuredTaskScope<Object>();\n-                });\n-                fail();\n-            } catch (StructureViolationException expected) { }\n-\n-            \/\/ underlying flock should be closed, fork should return a cancelled task\n-            StructuredTaskScope<Object> scope = box.scope;\n-            AtomicBoolean ran = new AtomicBoolean();\n-            Future<Object> future = scope.fork(() -> {\n-                ran.set(true);\n-                return null;\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-            assertFalse(ran.get());\n-\n-        } finally {\n-            StructuredTaskScope<Object> scope = box.scope;\n-            if (scope != null) {\n-                scope.close();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n-     *\/\n-    @Test\n-    void testStructureViolation2() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class, scope::close);\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    void testStructureViolation3() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class,\n-                        () -> scope.fork(() -> \"foo\"));\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    void testStructureViolation4() throws Exception {\n-        ScopedValue<String> name1 = ScopedValue.newInstance();\n-        ScopedValue<String> name2 = ScopedValue.newInstance();\n-\n-        \/\/ rebind\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name1, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-\n-        \/\/ new binding\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name2, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":0,"deletions":219,"binary":false,"changes":219,"status":"deleted"},{"patch":"@@ -1045,1 +1045,1 @@\n-            assertTrue(flock.toString().contains(\"xxx\"));\n+            assertTrue(flock.toString().contains(\"xxxx\"));\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.concurrent\n@@ -33,2 +33,0 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructureViolationException;\n@@ -36,0 +34,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -57,1 +56,1 @@\n-        String value = ScopedValue.where(name, \"duke\", () -> {\n+        String value = ScopedValue.callWhere(name, \"duke\", () -> {\n@@ -83,1 +82,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -101,1 +100,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -103,1 +102,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -105,1 +104,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -133,1 +132,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -135,1 +134,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -137,1 +136,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -165,1 +164,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -167,1 +166,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -169,1 +168,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -197,1 +196,1 @@\n-            ScopedValue.where(name, \"duke\", () -> {\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n@@ -211,1 +210,1 @@\n-        ScopedValue.where(name, \"duke\", () -> {\n+        ScopedValue.runWhere(name, \"duke\", () -> {\n@@ -213,1 +212,1 @@\n-                ScopedValue.where(name, \"duchess\", () -> {\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import com.sun.management.OperatingSystemMXBean;\n+import java.lang.management.ManagementFactory;\n+import jdk.internal.platform.Metrics;\n+\n+\n+\/\/ Check dynamic limits updating. Metrics (java) side.\n+public class LimitUpdateChecker {\n+\n+    private static final File UPDATE_FILE = new File(\"\/tmp\", \"limitsUpdated\");\n+    private static final File STARTED_FILE = new File(\"\/tmp\", \"started\");\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Running LimitUpdateChecker...\");\n+        Metrics metrics = jdk.internal.platform.Container.metrics();\n+        OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();\n+        printMetrics(osBean, metrics); \/\/ initial limits\n+        createStartedFile();\n+        while (!UPDATE_FILE.exists()) {\n+            Thread.sleep(200);\n+        }\n+        System.out.println(\"'limitsUpdated' file appeared. Stopped loop.\");\n+        printMetrics(osBean, metrics); \/\/ updated limits\n+        System.out.println(\"LimitUpdateChecker DONE.\");\n+    }\n+\n+    private static void printMetrics(OperatingSystemMXBean osBean, Metrics metrics) {\n+        System.out.println(String.format(\"Runtime.availableProcessors: %d\", Runtime.getRuntime().availableProcessors()));\n+        System.out.println(String.format(\"OperatingSystemMXBean.getAvailableProcessors: %d\", osBean.getAvailableProcessors()));\n+        System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n+        System.out.println(String.format(\"OperatingSystemMXBean.getTotalMemorySize: %d\", osBean.getTotalMemorySize()));\n+    }\n+\n+    private static void createStartedFile() throws Exception {\n+        FileOutputStream fout = new FileOutputStream(STARTED_FILE);\n+        fout.close();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/LimitUpdateChecker.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8308090\n+ * @key cgroups\n+ * @summary Test container limits updating as they get updated at runtime without restart\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build LimitUpdateChecker\n+ * @run driver TestLimitsUpdating\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestLimitsUpdating {\n+    private static final long M = 1024 * 1024;\n+    private static final String TARGET_CONTAINER = \"limitsUpdatingJDK_\" + Runtime.getRuntime().version().major();\n+    private static final String imageName = Common.imageName(\"limitsUpdatingJDK\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+        try {\n+            testLimitUpdates();\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void testLimitUpdates() throws Exception {\n+        File sharedtmpdir = new File(\"jdk-sharedtmp\");\n+        File flag = new File(sharedtmpdir, \"limitsUpdated\"); \/\/ shared with LimitUpdateChecker\n+        File started = new File(sharedtmpdir, \"started\"); \/\/ shared with LimitUpdateChecker\n+        sharedtmpdir.mkdir();\n+        flag.delete();\n+        started.delete();\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"LimitUpdateChecker\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addDockerOpts(\"--volume\", sharedtmpdir.getAbsolutePath() + \":\/tmp\");\n+        opts.addDockerOpts(\"--cpu-period\", \"100000\");\n+        opts.addDockerOpts(\"--cpu-quota\", \"200000\");\n+        opts.addDockerOpts(\"--memory\", \"500m\");\n+        opts.addDockerOpts(\"--memory-swap\", \"500m\");\n+        opts.addDockerOpts(\"--name\", TARGET_CONTAINER);\n+        opts.addJavaOpts(\"-cp\", \"\/test-classes\/\");\n+        \/\/ LimitUpdateChecker uses Metrics (jdk.internal.platform) for\n+        \/\/ printing JDK container limits\n+        opts.addJavaOpts(\"--add-exports\");\n+        opts.addJavaOpts(\"java.base\/jdk.internal.platform=ALL-UNNAMED\");\n+        final OutputAnalyzer out[] = new OutputAnalyzer[1];\n+        Thread t1 = new Thread() {\n+                public void run() {\n+                    try {\n+                        out[0] = DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            };\n+        t1.start();\n+\n+       \/\/ Wait for target container (that we later update) to complete its\n+       \/\/ initial starting-up phase. Prints initial container limits using\n+       \/\/ OS MXBean and Metrics API\n+        while (!started.exists()) {\n+            System.out.println(\"Wait for target container to start\");\n+            Thread.sleep(100);\n+        }\n+\n+        final List<String> containerCommand = getContainerUpdate(300_000, 100_000, \"300m\");\n+        \/\/ Run the update command so as to increase resources once the container signaled it has started.\n+        Thread t2 = new Thread() {\n+                public void run() {\n+                    try {\n+                        DockerTestUtils.execute(containerCommand).shouldHaveExitValue(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            };\n+        t2.start();\n+        t2.join();\n+\n+        \/\/ Set the flag for the to-get updated container, indicating the update\n+        \/\/ has completed.\n+        FileOutputStream fout = new FileOutputStream(flag);\n+        fout.close();\n+\n+        t1.join();\n+\n+        \/\/ Do assertions based on the output in target container\n+        OutputAnalyzer targetOut = out[0];\n+        targetOut.shouldContain(\"Runtime.availableProcessors: 2\");                  \/\/ initial value\n+        targetOut.shouldContain(\"OperatingSystemMXBean.getAvailableProcessors: 2\"); \/\/ initial value\n+        targetOut.shouldContain(\"Runtime.availableProcessors: 3\");                  \/\/ updated value\n+        targetOut.shouldContain(\"OperatingSystemMXBean.getAvailableProcessors: 3\"); \/\/ updated value\n+        long memoryInBytes = 500 * M;\n+        targetOut.shouldContain(\"Metrics.getMemoryLimit() == \" + memoryInBytes);    \/\/ initial value\n+        targetOut.shouldContain(\"OperatingSystemMXBean.getTotalMemorySize: \" + memoryInBytes); \/\/ initial value\n+        long updatedValue = 300 * M;\n+        targetOut.shouldContain(\"Metrics.getMemoryLimit() == \" + updatedValue);    \/\/ updated value\n+        targetOut.shouldContain(\"OperatingSystemMXBean.getTotalMemorySize: \" + updatedValue); \/\/ updated value\n+    }\n+\n+    private static List<String> getContainerUpdate(int cpuQuota, int cpuPeriod, String memory) {\n+        List<String> cmd = DockerTestUtils.buildContainerCommand();\n+        cmd.add(\"update\");\n+        cmd.add(\"--cpu-period=\" + cpuPeriod);\n+        cmd.add(\"--cpu-quota=\" + cpuQuota);\n+        cmd.add(\"--memory=\" + memory);\n+        cmd.add(\"--memory-swap=\" + memory); \/\/ no swap\n+        cmd.add(TARGET_CONTAINER);\n+        return cmd;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -92,1 +92,1 @@\n-        Version ver = OperatingSystem.version();\n+        OSVersion ver = OSVersion.current();\n","filename":"test\/jdk\/jdk\/internal\/util\/OSTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -32,1 +32,1 @@\n-import org.junit.jupiter.api.Test;\n+\n@@ -48,8 +48,8 @@\n-                Arguments.of(\"1\", new Version(1, 0)),\n-                Arguments.of(\"1.2\", new Version(1, 2)),\n-                Arguments.of(\"1.2\", new Version(1, 2, 0)),\n-                Arguments.of(\"1.2.3\", new Version(1, 2, 3)),\n-                Arguments.of(\"1-abc\", new Version(1, 0, 0)), \/\/ Ignore extra\n-                Arguments.of(\"1.2-abc\", new Version(1, 2, 0)), \/\/ Ignore extra\n-                Arguments.of(\"1.2.3.4\", new Version(1, 2, 3)), \/\/ Ignore extra\n-                Arguments.of(\"1.2.3-abc\", new Version(1, 2, 3)) \/\/ Ignore extra\n+                Arguments.of(\"1\", new OSVersion(1, 0)),\n+                Arguments.of(\"1.2\", new OSVersion(1, 2)),\n+                Arguments.of(\"1.2\", new OSVersion(1, 2, 0)),\n+                Arguments.of(\"1.2.3\", new OSVersion(1, 2, 3)),\n+                Arguments.of(\"1-abc\", new OSVersion(1, 0, 0)), \/\/ Ignore extra\n+                Arguments.of(\"1.2-abc\", new OSVersion(1, 2, 0)), \/\/ Ignore extra\n+                Arguments.of(\"1.2.3.4\", new OSVersion(1, 2, 3)), \/\/ Ignore extra\n+                Arguments.of(\"1.2.3-abc\", new OSVersion(1, 2, 3)) \/\/ Ignore extra\n@@ -61,2 +61,2 @@\n-    public void checkParse(String verName, Version expected) {\n-        Version actual = Version.parse(verName);\n+    public void checkParse(String verName, OSVersion expected) {\n+        OSVersion actual = OSVersion.parse(verName);\n@@ -77,1 +77,1 @@\n-        Throwable th = assertThrows(IllegalArgumentException.class, () -> Version.parse(verName));\n+        Throwable th = assertThrows(IllegalArgumentException.class, () -> OSVersion.parse(verName));\n@@ -84,8 +84,8 @@\n-                Arguments.of(new Version(2, 1), new Version(2, 1), 0),\n-                Arguments.of(new Version(2, 1), new Version(2, 0), +1),\n-                Arguments.of(new Version(2, 0), new Version(2, 1), -1),\n-                Arguments.of(new Version(3, 3, 1), new Version(3, 3, 1), 0),\n-                Arguments.of(new Version(3, 3, 1), new Version(3, 3, 0), +1),\n-                Arguments.of(new Version(3, 3, 0), new Version(3, 3, 1), -1),\n-                Arguments.of(new Version(2, 0), new Version(3, 0), -1),\n-                Arguments.of(new Version(3, 0), new Version(2, 0), +1)\n+                Arguments.of(new OSVersion(2, 1), new OSVersion(2, 1), 0),\n+                Arguments.of(new OSVersion(2, 1), new OSVersion(2, 0), +1),\n+                Arguments.of(new OSVersion(2, 0), new OSVersion(2, 1), -1),\n+                Arguments.of(new OSVersion(3, 3, 1), new OSVersion(3, 3, 1), 0),\n+                Arguments.of(new OSVersion(3, 3, 1), new OSVersion(3, 3, 0), +1),\n+                Arguments.of(new OSVersion(3, 3, 0), new OSVersion(3, 3, 1), -1),\n+                Arguments.of(new OSVersion(2, 0), new OSVersion(3, 0), -1),\n+                Arguments.of(new OSVersion(3, 0), new OSVersion(2, 0), +1)\n@@ -97,1 +97,1 @@\n-    public void checkVersionCompare(Version v1, Version v2, int expected) {\n+    public void checkVersionCompare(OSVersion v1, OSVersion v2, int expected) {\n","filename":"test\/jdk\/jdk\/internal\/util\/VersionTest.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+import static jdk.test.lib.Asserts.assertLessThanOrEqual;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestResidentSetSizeEvent true\n+ *\/\n+public class TestResidentSetSizeEvent {\n+    private final static String ResidentSetSizeEvent = EventNames.ResidentSetSize;\n+\n+    private final static int Period = 1000;\n+    private final static int K = 1024;\n+\n+  private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateHeapContents() {\n+        for (int i = 0 ; i < 64; i++) {\n+            for (int j = 0; j < K; j++) {\n+                data.add(new byte[K]);\n+            }\n+        }\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        recording.enable(ResidentSetSizeEvent).with(\"period\", \"everyChunk\");\n+\n+        recording.start();\n+\n+        \/\/ Generate data to force heap to grow.\n+        generateHeapContents();\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEventTypes(List<RecordedEvent> events) throws Exception {\n+        List<RecordedEvent> filteredEvents = events.stream().filter(e -> e.getEventType().getName().equals(ResidentSetSizeEvent)).toList();\n+\n+        assertGreaterThan(filteredEvents.size(), 0, \"Should exist events of type: \" + ResidentSetSizeEvent);\n+\n+        for (RecordedEvent event : filteredEvents) {\n+            long size = event.getLong(\"size\");\n+            long peak = event.getLong(\"peak\");\n+            assertGreaterThan(size, 0L, \"Should be non-zero\");\n+            assertGreaterThan(peak, 0L, \"Should be non-zero\");\n+            assertLessThanOrEqual(size, peak, \"The size should be less than or equal to peak\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+\n+            var events = Events.fromRecording(recording);\n+            verifyExpectedEventTypes(events);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestResidentSetSizeEvent.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm jdk.jfr.jmx.info.TestEventTypeInfo\n+ * @run main\/othervm -Djdk.attach.allowAttachSelf=true -Dcom.sun.management.jmxremote jdk.jfr.jmx.info.TestEventTypeInfo\n@@ -51,1 +51,2 @@\n-        FlightRecorderMXBean bean = JmxHelper.getFlighteRecorderMXBean();\n+        long selfPID = JmxHelper.getPID();\n+        FlightRecorderMXBean bean = JmxHelper.getFlighteRecorderMXBean(selfPID);\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/info\/TestEventTypeInfo.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Asserts;\n@@ -65,0 +66,10 @@\n+        String text = info.toString();\n+        assertContains(text, \"name\");\n+        assertContains(text, String.valueOf(info.getName()));\n+        assertContains(text, \"id\");\n+        assertContains(text, String.valueOf(info.getId()));\n+        assertContains(text, \"maxAge\");\n+        assertContains(text, String.valueOf(info.getMaxAge()));\n+        assertContains(text, \"maxSize\");\n+        assertContains(text, String.valueOf(info.getMaxSize()));\n+\n@@ -73,0 +84,5 @@\n+    private static void assertContains(String text, String match) {\n+        if (!text.contains(match)) {\n+            Asserts.fail(\"Expected '\" + text + \"' to contain '\" + match + '\"');\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/info\/TestRecordingInfo.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,3 +217,4 @@\n-                            int c;\n-                            while ((c = is.read()) != -1) {\n-                                os.write(c);\n+                            int len;\n+                            byte[] buf = new byte[16 * 1024];\n+                            while ((len = is.read(buf)) != -1) {\n+                                os.write(buf, 0, len);\n@@ -223,1 +224,1 @@\n-                                if (DEBUG) System.out.print(tag);\n+                                if (DEBUG) System.out.print(String.valueOf(tag).repeat(len));\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/B8209178.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test password based encryption on SunPKCS11's Cipher service\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=30 PBECipher\n+ *\/\n+\n+public final class PBECipher extends PKCS11Test {\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final byte[] salt = \"abcdefgh\".getBytes(\n+            StandardCharsets.UTF_8);\n+    private static final int iterations = 1000;\n+    private static final int AES_BLOCK_SIZE = 16;\n+    private static final PBEParameterSpec pbeSpec = new PBEParameterSpec(salt,\n+            iterations, new IvParameterSpec(new byte[AES_BLOCK_SIZE]));\n+    private static final String plainText = \"This is a known plain text!\";\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass salt and iterations to a Cipher through a PBEParameterSpec.\n+        PBEParameterSpec,\n+\n+        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n+        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Cipher.\n+        SecretKeyFactoryDerivedKey,\n+\n+        \/\/ Pass salt and iterations to a Cipher through an AlgorithmParameters.\n+        AlgorithmParameters,\n+\n+        \/\/ Pass password, salt and iterations and iterations to\n+        \/\/ a Cipher through an anonymous class implementing the\n+        \/\/ javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private record AssertionData(String pbeCipherAlgo, String cipherAlgo,\n+            BigInteger expectedCiphertext) {}\n+\n+    private static AssertionData cipherAssertionData(String pbeCipherAlgo,\n+            String cipherAlgo, String staticExpectedCiphertextString) {\n+        BigInteger staticExpectedCiphertext =\n+                new BigInteger(staticExpectedCiphertextString, 16);\n+        BigInteger expectedCiphertext = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedCiphertext = computeCipherText(sunJCE, pbeCipherAlgo,\n+                        pbeCipherAlgo, Configuration.PBEParameterSpec);\n+                checkAssertionValues(expectedCiphertext,\n+                        staticExpectedCiphertext);\n+            } catch (GeneralSecurityException e) {\n+                \/\/ Move to staticExpectedCiphertext as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedCiphertext == null) {\n+            expectedCiphertext = staticExpectedCiphertext;\n+        }\n+        return new AssertionData(pbeCipherAlgo, cipherAlgo, expectedCiphertext);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    \/\/ Generated with SunJCE.\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            cipherAssertionData(\"PBEWithHmacSHA1AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"ba1c9614d550912925d99e0bc8969032\" +\n+                    \"7ac6258b72117dcf750c19ee6ca73dd4\"),\n+            cipherAssertionData(\"PBEWithHmacSHA224AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"41960c43ca99cf2184511aaf2f0508a9\" +\n+                    \"7da3762ee6c2b7e2027c8076811f2e52\"),\n+            cipherAssertionData(\"PBEWithHmacSHA256AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"6bb6a3dc3834e81e5ca6b5e70073ff46\" +\n+                    \"903b188940a269ed26db2ffe622b8e16\"),\n+            cipherAssertionData(\"PBEWithHmacSHA384AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"22aabf7a6a059415dc4ca7d985f3de06\" +\n+                    \"8f8300ca48d8de585d802670f4c1d9bd\"),\n+            cipherAssertionData(\"PBEWithHmacSHA512AndAES_128\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"b523e7c462a0b7fd74e492b3a6550464\" +\n+                    \"ceebe81f08649ae163673afc242ad8a2\"),\n+            cipherAssertionData(\"PBEWithHmacSHA1AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"1e7c25e166afae069cec68ef9affca61\" +\n+                    \"aea02ab1c3dc7471cb767ed7d6e37af0\"),\n+            cipherAssertionData(\"PBEWithHmacSHA224AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"6701f1cc75b6494ec4bd27158aa2c15d\" +\n+                    \"7d10bc2f1fbb7d92d8277c7edfd1dd57\"),\n+            cipherAssertionData(\"PBEWithHmacSHA256AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"f82eb2fc016505baeb23ecdf85163933\" +\n+                    \"5e8d6d48b48631185641febb75898a1d\"),\n+            cipherAssertionData(\"PBEWithHmacSHA384AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"ee9528022e58cdd9be80cd88443e03b3\" +\n+                    \"de13376cf97c53d946d5c5dfc88097be\"),\n+            cipherAssertionData(\"PBEWithHmacSHA512AndAES_256\",\n+                    \"AES\/CBC\/PKCS5Padding\", \"18f472912ffaa31824e20a5486324e14\" +\n+                    \"0225e20cb158762e8647b1216fe0ab7e\"),\n+    };\n+\n+    private static final class NoRandom extends SecureRandom {\n+        @Override\n+        public void nextBytes(byte[] bytes) {}\n+    }\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testWith(sunPKCS11, data, true, conf);\n+                if (conf != Configuration.PBEParameterSpec &&\n+                        conf != Configuration.AlgorithmParameters) {\n+                    testWith(sunPKCS11, data, false, conf);\n+                }\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testWith(Provider sunPKCS11, AssertionData data,\n+            boolean testPBEService, Configuration conf) throws Exception {\n+        String svcAlgo = testPBEService ? data.pbeCipherAlgo : data.cipherAlgo;\n+        System.out.println(sep + System.lineSeparator() + svcAlgo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        BigInteger cipherText = computeCipherText(sunPKCS11, svcAlgo,\n+                data.pbeCipherAlgo, conf);\n+        printHex(\"Cipher Text\", cipherText);\n+\n+        if (!cipherText.equals(data.expectedCiphertext)) {\n+            printHex(\"Expected Cipher Text\", data.expectedCiphertext);\n+            throw new Exception(\"Expected Cipher Text did not match\");\n+        }\n+    }\n+\n+    private static BigInteger computeCipherText(Provider p, String svcAlgo,\n+            String keyAlgo, Configuration conf)\n+            throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(svcAlgo, p);\n+        switch (conf) {\n+            case PBEParameterSpec, AlgorithmParameters -> {\n+                SecretKey key = getPasswordOnlyPBEKey();\n+                switch (conf) {\n+                    case PBEParameterSpec -> {\n+                        cipher.init(Cipher.ENCRYPT_MODE, key, pbeSpec);\n+                    }\n+                    case AlgorithmParameters -> {\n+                        AlgorithmParameters algoParams =\n+                                AlgorithmParameters.getInstance(\"PBES2\");\n+                        algoParams.init(pbeSpec);\n+                        cipher.init(Cipher.ENCRYPT_MODE, key, algoParams);\n+                    }\n+                }\n+            }\n+            case SecretKeyFactoryDerivedKey -> {\n+                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n+                cipher.init(Cipher.ENCRYPT_MODE, key,\n+                        pbeSpec.getParameterSpec());\n+            }\n+            case AnonymousPBEKey -> {\n+                SecretKey key = getAnonymousPBEKey(keyAlgo,\n+                        svcAlgo.equals(keyAlgo));\n+                cipher.init(Cipher.ENCRYPT_MODE, key, new NoRandom());\n+            }\n+        }\n+        return new BigInteger(1, cipher.doFinal(\n+                plainText.getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    private static SecretKey getPasswordOnlyPBEKey()\n+            throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(\"PBE\")\n+                .generateSecret(new PBEKeySpec(password));\n+    }\n+\n+    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n+            String algorithm) throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n+                .generateSecret(new PBEKeySpec(password, salt, iterations));\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm,\n+            boolean isPbeCipherSvc) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return salt.clone(); }\n+            public int getIterationCount() { return iterations; }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return password.clone(); }\n+            public byte[] getEncoded() {\n+                byte[] encodedKey = null;\n+                if (isPbeCipherSvc) {\n+                    encodedKey = new byte[password.length];\n+                    for (int i = 0; i < password.length; i++) {\n+                        encodedKey[i] = (byte) (password[i] & 0x7f);\n+                    }\n+                }\n+                return encodedKey;\n+            }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new PBECipher());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/PBECipher.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test SunPKCS11's password based privacy and integrity\n+ *          applied to PKCS #12 keystores\n+ * @library \/test\/lib ..\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm\/timeout=30 ImportKeyToP12\n+ *\/\n+\n+public final class ImportKeyToP12 extends PKCS11Test {\n+    private static final String alias = \"alias\";\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final Key key = new SecretKeySpec(new byte[] {\n+            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,\n+            0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf }, \"AES\");\n+    private static final String[] pbeCipherAlgs = new String[] {\n+            \"PBEWithHmacSHA1AndAES_128\", \"PBEWithHmacSHA224AndAES_128\",\n+            \"PBEWithHmacSHA256AndAES_128\", \"PBEWithHmacSHA384AndAES_128\",\n+            \"PBEWithHmacSHA512AndAES_128\", \"PBEWithHmacSHA1AndAES_256\",\n+            \"PBEWithHmacSHA224AndAES_256\", \"PBEWithHmacSHA256AndAES_256\",\n+            \"PBEWithHmacSHA384AndAES_256\", \"PBEWithHmacSHA512AndAES_256\"\n+    };\n+    private static final String[] pbeMacAlgs = new String[] {\n+            \"HmacPBESHA1\", \"HmacPBESHA224\", \"HmacPBESHA256\",\n+            \"HmacPBESHA384\", \"HmacPBESHA512\"\n+    };\n+    private static final KeyStore p12;\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    static {\n+        KeyStore tP12 = null;\n+        try {\n+            tP12 = KeyStore.getInstance(\"PKCS12\");\n+        } catch (KeyStoreException e) {}\n+        p12 = tP12;\n+    }\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        \/\/ Test all privacy PBE algorithms with an integrity algorithm fixed\n+        for (String pbeCipherAlg : pbeCipherAlgs) {\n+            \/\/ Make sure that SunPKCS11 implements the Cipher algorithm\n+            Cipher.getInstance(pbeCipherAlg, sunPKCS11);\n+            testWith(sunPKCS11, pbeCipherAlg, pbeMacAlgs[0]);\n+        }\n+        \/\/ Test all integrity PBE algorithms with a privacy algorithm fixed\n+        for (String pbeMacAlg : pbeMacAlgs) {\n+            \/\/ Make sure that SunPKCS11 implements the Mac algorithm\n+            Mac.getInstance(pbeMacAlg, sunPKCS11);\n+            testWith(sunPKCS11, pbeCipherAlgs[0], pbeMacAlg);\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    \/*\n+     * Consistency test: 1) store a secret key in a PKCS #12 keystore using\n+     * PBE algorithms from SunPKCS11 and, 2) read the secret key from the\n+     * PKCS #12 keystore using PBE algorithms from other security providers\n+     * such as SunJCE.\n+     *\/\n+    private void testWith(Provider sunPKCS11, String pbeCipherAlg,\n+            String pbeMacAlg) throws Exception {\n+        System.out.println(sep + System.lineSeparator() +\n+                \"Cipher PBE: \" + pbeCipherAlg + System.lineSeparator() +\n+                \"Mac PBE: \" + pbeMacAlg);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", pbeMacAlg);\n+        System.setProperty(\"keystore.pkcs12.keyProtectionAlgorithm\",\n+                pbeCipherAlg);\n+\n+        \/\/ Create an empty PKCS #12 keystore\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        p12.load(null, password);\n+\n+        \/\/ Use PBE privacy and integrity algorithms from SunPKCS11 to store\n+        \/\/ the secret key\n+        Security.insertProviderAt(sunPKCS11, 1);\n+        p12.setKeyEntry(alias, key, password, null);\n+        p12.store(baos, password);\n+\n+        \/\/ Use PBE privacy and integrity algorithms from other security\n+        \/\/ providers, such as SunJCE, to read the secret key\n+        Security.removeProvider(sunPKCS11.getName());\n+        p12.load(new ByteArrayInputStream(baos.toByteArray()), password);\n+        Key k = p12.getKey(alias, password);\n+\n+        if (!MessageDigest.isEqual(key.getEncoded(), k.getEncoded())) {\n+            throw new Exception(\"Keys differ. Consistency check failed.\");\n+        }\n+        System.out.println(\"Secret key import successful\"\n+                + System.lineSeparator() + sep);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new ImportKeyToP12());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ImportKeyToP12.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.security.SecureRandom;\n@@ -45,1 +44,0 @@\n-import javax.crypto.spec.SecretKeySpec;\n@@ -72,1 +70,0 @@\n-        SecureRandom srdm = new SecureRandom();\n@@ -76,4 +73,1 @@\n-            byte[] keyVal = new byte[KEY_SIZE];\n-            srdm.nextBytes(keyVal);\n-            SecretKey skey = new SecretKeySpec(keyVal, alg);\n-\n+            SecretKey skey = generateKey(alg, KEY_SIZE);\n@@ -89,0 +83,1 @@\n+                \/\/ No KeyGenerator support for PBE\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/MacSameTest.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test password based authentication on SunPKCS11's Mac service\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=30 PBAMac\n+ *\/\n+\n+public final class PBAMac extends PKCS11Test {\n+    private static final char[] password = \"123456\".toCharArray();\n+    private static final byte[] salt = \"abcdefgh\".getBytes(\n+            StandardCharsets.UTF_8);\n+    private static final int iterations = 1000;\n+    private static final String plainText = \"This is a known plain text!\";\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass salt and iterations to a Mac through a PBEParameterSpec.\n+        PBEParameterSpec,\n+\n+        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n+        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Mac.\n+        SecretKeyFactoryDerivedKey,\n+\n+        \/\/ Pass password, salt and iterations and iterations to\n+        \/\/ a Mac through an anonymous class implementing the\n+        \/\/ javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private record AssertionData(String pbeHmacAlgo, String hmacAlgo,\n+            BigInteger expectedMac) {}\n+\n+    private static AssertionData macAssertionData(String pbeHmacAlgo,\n+            String hmacAlgo, String staticExpectedMacString) {\n+        BigInteger staticExpectedMac = new BigInteger(staticExpectedMacString,\n+                16);\n+        BigInteger expectedMac = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedMac = computeMac(sunJCE, pbeHmacAlgo,\n+                        pbeHmacAlgo, Configuration.PBEParameterSpec);\n+                checkAssertionValues(expectedMac, staticExpectedMac);\n+            } catch (GeneralSecurityException e) {\n+                \/\/ Move to staticExpectedMac as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedMac == null) {\n+            expectedMac = staticExpectedMac;\n+        }\n+        return new AssertionData(pbeHmacAlgo, hmacAlgo, expectedMac);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    \/\/ Generated with SunJCE.\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            macAssertionData(\"HmacPBESHA1\", \"HmacSHA1\",\n+                    \"707606929395e4297adc63d520ac7d22f3f5fa66\"),\n+            macAssertionData(\"HmacPBESHA224\", \"HmacSHA224\",\n+                    \"4ffb5ad4974a7a9fca5a36ebe3e34dd443c07fb68c392f8b611657e6\"),\n+            macAssertionData(\"HmacPBESHA256\", \"HmacSHA256\",\n+                    \"9e8c102c212d2fd1334dc497acb4e002b04e84713b7eda5a63807af2\" +\n+                    \"989d3e50\"),\n+            macAssertionData(\"HmacPBESHA384\", \"HmacSHA384\",\n+                    \"77f31a785d4f2220251143a4ba80f5610d9d0aeaebb4a278b8a7535c\" +\n+                    \"8cea8e8211809ba450458e351c5b66d691839c23\"),\n+            macAssertionData(\"HmacPBESHA512\", \"HmacSHA512\",\n+                    \"a53f942a844b234a69c1f92cba20ef272c4394a3cf4024dc16d9dbac\" +\n+                    \"1969870b1c2b28b897149a1a3b9ad80a7ca8c547dfabf3ed5f144c6b\" +\n+                    \"593900b62e120c45\"),\n+    };\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testWith(sunPKCS11, data, true, conf);\n+                if (conf != Configuration.PBEParameterSpec) {\n+                    testWith(sunPKCS11, data, false, conf);\n+                }\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testWith(Provider sunPKCS11, AssertionData data,\n+            boolean testPBEService, Configuration conf) throws Exception {\n+        String svcAlgo = testPBEService ? data.pbeHmacAlgo : data.hmacAlgo;\n+        System.out.println(sep + System.lineSeparator() + svcAlgo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        BigInteger mac = computeMac(sunPKCS11, svcAlgo, data.pbeHmacAlgo, conf);\n+        printHex(\"HMAC\", mac);\n+\n+        if (!mac.equals(data.expectedMac)) {\n+            printHex(\"Expected HMAC\", data.expectedMac);\n+            throw new Exception(\"Expected HMAC did not match\");\n+        }\n+    }\n+\n+    private static BigInteger computeMac(Provider p, String svcAlgo,\n+            String keyAlgo, Configuration conf)\n+            throws GeneralSecurityException {\n+        Mac mac = Mac.getInstance(svcAlgo, p);\n+        switch (conf) {\n+            case PBEParameterSpec -> {\n+                SecretKey key = getPasswordOnlyPBEKey();\n+                mac.init(key, new PBEParameterSpec(salt, iterations));\n+            }\n+            case SecretKeyFactoryDerivedKey -> {\n+                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n+                mac.init(key);\n+            }\n+            case AnonymousPBEKey -> {\n+                SecretKey key = getAnonymousPBEKey(keyAlgo);\n+                mac.init(key);\n+            }\n+        }\n+        return new BigInteger(1, mac.doFinal(\n+                plainText.getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    private static SecretKey getPasswordOnlyPBEKey()\n+            throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(\"PBE\")\n+                .generateSecret(new PBEKeySpec(password));\n+    }\n+\n+    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n+            String algorithm) throws GeneralSecurityException {\n+        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n+                .generateSecret(new PBEKeySpec(password, salt, iterations));\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return salt.clone(); }\n+            public int getIterationCount() { return iterations; }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return password.clone(); }\n+            public byte[] getEncoded() { return null; }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new PBAMac());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/PBAMac.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.SecretKey;\n@@ -54,2 +54,0 @@\n-        byte[] keyVal = new byte[16];\n-        random.nextBytes(keyVal);\n@@ -59,0 +57,1 @@\n+            SecretKey skey = generateKey(alg, 16);\n@@ -60,1 +59,1 @@\n-                doTest(alg, p, keyVal, data);\n+                doTest(alg, p, skey, data);\n@@ -75,1 +74,1 @@\n-    private void doTest(String alg, Provider p, byte[] keyVal, byte[] data)\n+    private void doTest(String alg, Provider p, SecretKey key, byte[] data)\n@@ -78,1 +77,0 @@\n-        SecretKeySpec key = new SecretKeySpec(keyVal, alg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/ReinitMac.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.security.SecureRandom;\n@@ -58,0 +59,3 @@\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n@@ -831,0 +835,52 @@\n+    private static final SecureRandom srdm = new SecureRandom();\n+\n+    static SecretKey generateKey(String alg, int keySize) {\n+        if (alg.contains(\"PBE\")) {\n+            return generateKeyPBE(alg, keySize);\n+        } else {\n+            return generateKeyNonPBE(alg, keySize);\n+        }\n+    }\n+\n+    private static SecretKey generateKeyNonPBE(String alg, int keySize) {\n+        byte[] keyVal = new byte[keySize];\n+        srdm.nextBytes(keyVal);\n+        return new SecretKeySpec(keyVal, alg);\n+    }\n+\n+    private static SecretKey generateKeyPBE(String alg, int keySize) {\n+        char[] pass = new char[keySize];\n+        for (int i = 0; i < pass.length; i++) {\n+            pass[i] = (char) ('0' + srdm.nextInt(74));\n+        }\n+        byte[] salt = new byte[srdm.nextInt(8, 16)];\n+        srdm.nextBytes(salt);\n+        int iterations = srdm.nextInt(1, 1000);\n+        return new javax.crypto.interfaces.PBEKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"PBE\";\n+            }\n+            @Override\n+            public String getFormat() {\n+                return null;\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                throw new RuntimeException(\"Should not be called\");\n+            }\n+            @Override\n+            public char[] getPassword() {\n+                return pass;\n+            }\n+            @Override\n+            public byte[] getSalt() {\n+                return salt;\n+            }\n+            @Override\n+            public int getIterationCount() {\n+                return iterations;\n+            }\n+        };\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.ReflectiveOperationException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.interfaces.PBEKey;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/*\n+ * @test\n+ * @bug 8301553\n+ * @summary test key derivation on a SunPKCS11 SecretKeyFactory service\n+ * @library \/test\/lib ..\n+ * @modules java.base\/com.sun.crypto.provider:open\n+ * @run main\/othervm\/timeout=30 TestPBKD\n+ *\/\n+\n+public final class TestPBKD extends PKCS11Test {\n+    private static final String sep = \"======================================\" +\n+            \"===================================\";\n+\n+    private enum Configuration {\n+        \/\/ Pass password, salt and iterations to a\n+        \/\/ SecretKeyFactory through a PBEKeySpec.\n+        PBEKeySpec,\n+\n+        \/\/ Pass password, salt and iterations and iterations to a\n+        \/\/ SecretKeyFactory through an anonymous class implementing\n+        \/\/ the javax.crypto.interfaces.PBEKey interface.\n+        AnonymousPBEKey,\n+    }\n+\n+    private static Provider sunJCE = Security.getProvider(\"SunJCE\");\n+\n+    private static BigInteger i(byte[] data) {\n+        return new BigInteger(1, data);\n+    }\n+\n+    private record AssertionData(String algo, PBEKeySpec keySpec,\n+            BigInteger expectedKey) {}\n+\n+    private static AssertionData p12PBKDAssertionData(String algo,\n+            char[] password, int keyLen, String hashAlgo, int blockLen,\n+            String staticExpectedKeyString) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n+        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n+                16);\n+        BigInteger expectedKey;\n+        try {\n+            \/\/ Since we need to access an internal\n+            \/\/ SunJCE API, we use reflection.\n+            Class<?> PKCS12PBECipherCore = Class.forName(\n+                    \"com.sun.crypto.provider.PKCS12PBECipherCore\");\n+\n+            Field macKeyField = PKCS12PBECipherCore.getDeclaredField(\"MAC_KEY\");\n+            macKeyField.setAccessible(true);\n+            int MAC_KEY = (int) macKeyField.get(null);\n+\n+            Method deriveMethod = PKCS12PBECipherCore.getDeclaredMethod(\n+                    \"derive\", char[].class, byte[].class, int.class,\n+                    int.class, int.class, String.class, int.class);\n+            deriveMethod.setAccessible(true);\n+            expectedKey = i((byte[]) deriveMethod.invoke(null,\n+                    keySpec.getPassword(), keySpec.getSalt(),\n+                    keySpec.getIterationCount(), keySpec.getKeyLength() \/ 8,\n+                    MAC_KEY, hashAlgo, blockLen));\n+            checkAssertionValues(expectedKey, staticExpectedKey);\n+        } catch (ReflectiveOperationException ignored) {\n+            expectedKey = staticExpectedKey;\n+        }\n+        return new AssertionData(algo, keySpec, expectedKey);\n+    }\n+\n+    private static AssertionData pbkd2AssertionData(String algo,\n+            char[] password, int keyLen, String kdfAlgo,\n+            String staticExpectedKeyString) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n+        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n+                16);\n+        BigInteger expectedKey = null;\n+        if (sunJCE != null) {\n+            try {\n+                expectedKey = i(SecretKeyFactory.getInstance(kdfAlgo, sunJCE)\n+                        .generateSecret(keySpec).getEncoded());\n+                checkAssertionValues(expectedKey, staticExpectedKey);\n+            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                \/\/ Move to staticExpectedKey as it's unlikely\n+                \/\/ that any of the algorithms are available.\n+                sunJCE = null;\n+            }\n+        }\n+        if (expectedKey == null) {\n+            expectedKey = staticExpectedKey;\n+        }\n+        return new AssertionData(algo, keySpec, expectedKey);\n+    }\n+\n+    private static void checkAssertionValues(BigInteger expectedValue,\n+            BigInteger staticExpectedValue) {\n+        if (!expectedValue.equals(staticExpectedValue)) {\n+            printHex(\"SunJCE value\", expectedValue);\n+            printHex(\"Static value\", staticExpectedValue);\n+            throw new Error(\"Static and SunJCE values do not match.\");\n+        }\n+    }\n+\n+    private static final char[] pwd = \"123456\\uA4F7\".toCharArray();\n+    private static final char[] emptyPwd = new char[0];\n+    private static final byte[] salt = \"abcdefgh\".getBytes(\n+            StandardCharsets.UTF_8);\n+    private static final int iterations = 1000;\n+\n+    \/\/ Generated with SunJCE. Keep a reference to some\n+    \/\/ entries for tests executing invalid conditions.\n+    private static final AssertionData hmacPBESHA1Data =\n+            p12PBKDAssertionData(\"HmacPBESHA1\", pwd, 160, \"SHA-1\", 64,\n+                    \"13156c6bee8e13ef568231e0174651afa5a358b0\");\n+    private static final AssertionData hmacPBESHA224Data =\n+            p12PBKDAssertionData(\"HmacPBESHA224\", pwd, 224, \"SHA-224\", 64,\n+                    \"d93acf4b3bea8a89d098e290928840c0b693a30cad0117f70ace50c2\");\n+    private static final AssertionData pbeWithHmacSHA512AndAES256Data =\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n+                    \"7e3077595f90b60ab96d4f29203927b0\");\n+    private static final AssertionData pbkdf2WithHmacSHA256Data =\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 384,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+                    \"44984e3e9b619488a42b93dd6453f630ae3e2ad7ed809fa9e98a7921\" +\n+                    \"87d62e84\");\n+    private static final AssertionData[] assertionData = new AssertionData[]{\n+            hmacPBESHA1Data,\n+            hmacPBESHA224Data,\n+            p12PBKDAssertionData(\"HmacPBESHA256\", pwd, 256, \"SHA-256\", 64,\n+                    \"1bb3ed1ffb784ed32f59b4d7515971699af99cf67a2e574000964c8e\" +\n+                    \"1eba1c45\"),\n+            p12PBKDAssertionData(\"HmacPBESHA384\", pwd, 384, \"SHA-384\", 128,\n+                    \"d4ce121d3cec88a8c8b0c6225f7f996b72d76017c2d91bc51fd47985\" +\n+                    \"86d1012d1ad03a39fdcd0fdc438d164ab50259fc\"),\n+            p12PBKDAssertionData(\"HmacPBESHA512\", pwd, 512, \"SHA-512\", 128,\n+                    \"5f80b350986e5156669193eaa42a107e7d6636d82fb550f67af5b2c2\" +\n+                    \"f546d977b70e52bbbcb6bb8976f9d3f0eaf9bfef5306c50ee5ccda3e\" +\n+                    \"e4c4c7c8421fe4d\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_128\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+                    \"b5552da5e645dad4b5911ce0f2f06b\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n+                    \"7daa2119fee8c64aef7c1f4c1871724e\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+                    \"44984e3e9b619488a42b93dd6453f630\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+                    \"d7d0ad3a18912086f80d974f2acc2efb\"),\n+            pbeWithHmacSHA512AndAES256Data,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 240,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+                    \"b5552da5e645dad4b5911ce0f2\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 336,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n+                    \"7daa2119fee8c64aef7c1f4c1871724e0ea628577e0ab54fa7c6\"),\n+            pbkdf2WithHmacSHA256Data,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 576,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+                    \"d7d0ad3a18912086f80d974f2acc2efba52650d4bf872455820f24c8\" +\n+                    \"46742161da84a1b4c3f197f4347308e8841a8971cf686aef29107396\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", pwd, 768,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n+                    \"7e3077595f90b60ab96d4f29203927b00aa1a11e4d19d4f275a7f453\" +\n+                    \"14be500dacc3c1de9f704827b396463ccaa8957344d41bd64d9d09ff\" +\n+                    \"474e776469d326b1ee6ee5a5d854b86d3d7a25084afd6d6f\"),\n+            p12PBKDAssertionData(\"HmacPBESHA512\", emptyPwd, 512, \"SHA-512\",\n+                    128, \"90b6e088490c6c5e6b6e81209bd769d27df3868cae79591577a\" +\n+                    \"c35b46e4c6ebcc4b90f4943e3cb165f9d1789d938235f4b35ba74df9\" +\n+                    \"e509fbbb7aa329a432445\"),\n+            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", emptyPwd, 256,\n+                    \"PBKDF2WithHmacSHA512\", \"3a5c5fd11e4d381b32e11baa93d7b128\" +\n+                    \"09e016e48e0542c5d3453fc240a0fa76\"),\n+    };\n+\n+    public void main(Provider sunPKCS11) throws Exception {\n+        System.out.println(\"SunPKCS11: \" + sunPKCS11.getName());\n+\n+        \/\/ Test valid cases.\n+        for (Configuration conf : Configuration.values()) {\n+            for (AssertionData data : assertionData) {\n+                testValidWith(sunPKCS11, data, conf);\n+            }\n+        }\n+\n+        \/\/ Test invalid cases.\n+        testInvalidTranslateKey(sunPKCS11);\n+        testInvalidGenerateSecret(sunPKCS11);\n+        testInvalidGetKeySpec(sunPKCS11);\n+\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    private static void testValidWith(Provider sunPKCS11, AssertionData data,\n+            Configuration conf) throws Exception {\n+        System.out.println(sep + System.lineSeparator() + data.algo\n+                + \" (with \" + conf.name() + \")\");\n+\n+        SecretKeyFactory skf = SecretKeyFactory.getInstance(data.algo,\n+                sunPKCS11);\n+        SecretKey derivedKey = switch (conf) {\n+            case PBEKeySpec -> skf.generateSecret(data.keySpec);\n+            case AnonymousPBEKey -> skf.translateKey(getAnonymousPBEKey(\n+                    data.algo, data.keySpec));\n+        };\n+        BigInteger derivedKeyValue = i(derivedKey.getEncoded());\n+        printHex(\"Derived Key\", derivedKeyValue);\n+\n+        if (!derivedKeyValue.equals(data.expectedKey)) {\n+            printHex(\"Expected Derived Key\", data.expectedKey);\n+            throw new Exception(\"Expected Derived Key did not match\");\n+        }\n+\n+        if (skf.translateKey(derivedKey) != derivedKey) {\n+            throw new Exception(\"SecretKeyFactory::translateKey must return \" +\n+                    \"the same key when a P11PBEKey from the same token is \" +\n+                    \"passed\");\n+        }\n+\n+        testGetKeySpec(data, skf, derivedKey);\n+        if (sunJCE != null && data.algo.startsWith(\"PBKDF2\")) {\n+            testTranslateP11PBEKeyToSunJCE(data.algo, (PBEKey) derivedKey);\n+        }\n+    }\n+\n+    private static SecretKey getAnonymousPBEKey(String algorithm,\n+            PBEKeySpec keySpec) {\n+        return new PBEKey() {\n+            public byte[] getSalt() { return keySpec.getSalt(); }\n+            public int getIterationCount() {\n+                return keySpec.getIterationCount();\n+            }\n+            public String getAlgorithm() { return algorithm; }\n+            public String getFormat() { return \"RAW\"; }\n+            public char[] getPassword() { return keySpec.getPassword(); }\n+            public byte[] getEncoded() {\n+                return new byte[keySpec.getKeyLength() \/ 8];\n+            }\n+        };\n+    }\n+\n+    private static void printHex(String title, BigInteger b) {\n+        String repr = (b == null) ? \"buffer is null\" : b.toString(16);\n+        System.out.println(title + \": \" + repr + System.lineSeparator());\n+    }\n+\n+    private static void testGetKeySpec(AssertionData data,\n+            SecretKeyFactory skf, SecretKey derivedKey) throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"SecretKeyFactory::getKeySpec() (for \" + data.algo + \")\");\n+        KeySpec skfKeySpec = skf.getKeySpec(derivedKey, PBEKeySpec.class);\n+        if (skfKeySpec instanceof PBEKeySpec skfPBEKeySpec) {\n+            char[] specPassword = skfPBEKeySpec.getPassword();\n+            byte[] specSalt = skfPBEKeySpec.getSalt();\n+            int specIterations = skfPBEKeySpec.getIterationCount();\n+            int specKeyLength = skfPBEKeySpec.getKeyLength();\n+            System.out.println(\"  spec key length (bits): \" + specKeyLength);\n+            System.out.println(\"           spec password: \"\n+                    + String.valueOf(specPassword));\n+            System.out.println(\"    spec iteration count: \" + specIterations);\n+            printHex(\"               spec salt\", i(specSalt));\n+\n+            if (!Arrays.equals(specPassword, data.keySpec.getPassword())) {\n+                throw new Exception(\"Password differs\");\n+            }\n+            if (!Arrays.equals(specSalt, data.keySpec.getSalt())) {\n+                throw new Exception(\"Salt differs\");\n+            }\n+            if (specIterations != data.keySpec.getIterationCount()) {\n+                throw new Exception(\"Iteration count differs\");\n+            }\n+            if (specKeyLength != data.keySpec.getKeyLength()) {\n+                throw new Exception(\"Key length differs\");\n+            }\n+        } else {\n+            throw new Exception(\"Invalid key spec type: \" + skfKeySpec);\n+        }\n+\n+        \/\/ Test extracting key bytes with a SecretKeySpec.\n+        SecretKeySpec secretKeySpec = (SecretKeySpec)\n+                skf.getKeySpec(derivedKey, SecretKeySpec.class);\n+        if (!Arrays.equals(secretKeySpec.getEncoded(),\n+                derivedKey.getEncoded())) {\n+            throw new Exception(\"Unable to extract key bytes with a \" +\n+                    \"SecretKeySpec\");\n+        }\n+    }\n+\n+    private static void testTranslateP11PBEKeyToSunJCE(String algorithm,\n+            PBEKey p11PbeK) throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Translate P11PBEKey to SunJCE (for \" + algorithm + \")\");\n+        SecretKey jceK = SecretKeyFactory.getInstance(algorithm, sunJCE)\n+                .translateKey(p11PbeK);\n+        BigInteger jceEncoded = i(jceK.getEncoded());\n+        printHex(\"    translated to SunJCE\", jceEncoded);\n+        if (jceK instanceof PBEKey jcePbeK) {\n+            if (!Arrays.equals(jcePbeK.getPassword(), p11PbeK.getPassword())) {\n+                throw new Exception(\"Password differs\");\n+            }\n+            if (!Arrays.equals(jcePbeK.getSalt(), p11PbeK.getSalt())) {\n+                throw new Exception(\"Salt differs\");\n+            }\n+            if (jcePbeK.getIterationCount() != p11PbeK.getIterationCount()) {\n+                throw new Exception(\"Iteration count differs\");\n+            }\n+            if (!jceEncoded.equals(i(p11PbeK.getEncoded()))) {\n+                throw new Exception(\"Encoded key differs\");\n+            }\n+        } else {\n+            throw new Exception(\"Unexpected key type for SunJCE key: \"\n+                    + jceK.getClass().getName());\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface Action {\n+        void run() throws Exception;\n+    }\n+\n+    private static void assertThrows(Class<?> expectedExc, String expectedMsg,\n+            Action action) throws Exception {\n+        String shtExpected = \"Should have thrown '\"\n+                + expectedExc.getSimpleName() + \": \" + expectedMsg + \"'\";\n+        try {\n+            action.run();\n+        } catch (Exception e) {\n+            if (expectedExc.isAssignableFrom(e.getClass()) &&\n+                    e.getMessage().equals(expectedMsg)) {\n+                return;\n+            }\n+            e.printStackTrace();\n+            throw new Exception(shtExpected + \", but threw '\" +\n+                    e.getClass().getSimpleName() + \": \" + e.getMessage() + \"'\");\n+        }\n+        throw new Exception(shtExpected + \", but it didn't throw\");\n+    }\n+\n+    private static void testInvalidTranslateKey(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::translateKey tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n+        SecretKeyFactory skf3 = SecretKeyFactory.getInstance(\n+                pbkdf2WithHmacSHA256Data.algo, sunPKCS11);\n+        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n+                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        Class<?> e = InvalidKeyException.class;\n+\n+        System.out.println(\" * Non-PBEKey key to PBE SecretKeyFactory\");\n+        assertThrows(e, \"PBE service requires a PBE key\",\n+                () -> skf1.translateKey(new SecretKeySpec(\n+                        new byte[10], hmacPBESHA1Data.algo)));\n+\n+        System.out.println(\" * PBEKey key to PBE SecretKeyFactory of a \" +\n+                \"different algorithm\");\n+        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n+                hmacPBESHA224Data.algo + \" service\",\n+                () -> SecretKeyFactory.getInstance(hmacPBESHA224Data.algo,\n+                        sunPKCS11).translateKey(p11PbeKey));\n+\n+        System.out.println(\" * Non-AES PBEKey key to AES SecretKeyFactory\");\n+        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n+                skf2.getAlgorithm() + \" service\",\n+                () -> skf2.translateKey(p11PbeKey));\n+\n+        System.out.println(\" * Inconsistent key length between key and \" +\n+                \"algorithm\");\n+        PBEKeySpec kSpec1 = new PBEKeySpec(pwd, salt, 1, 16);\n+        assertThrows(e, InvalidKeySpecException.class.getName() + \": Key \" +\n+                \"length is invalid for \" + skf1.getAlgorithm() + \" (expecting\" +\n+                \" \" + hmacPBESHA1Data.keySpec.getKeyLength() + \" but was \" +\n+                kSpec1.getKeyLength() + \")\",\n+                () -> skf1.translateKey(getAnonymousPBEKey(\n+                        skf1.getAlgorithm(), kSpec1)));\n+\n+        System.out.println(\" * Invalid key length in bits\");\n+        PBEKeySpec kSpec2 = new PBEKeySpec(pwd, salt, 1);\n+        assertThrows(e, InvalidKeySpecException.class.getName() + \": Key \" +\n+                \"length must be multiple of 8 and greater than zero\",\n+                () -> skf3.translateKey(getAnonymousPBEKey(\n+                        skf3.getAlgorithm(), kSpec2)));\n+\n+        System.out.println();\n+    }\n+\n+    private static void testInvalidGenerateSecret(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::generateSecret tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n+                pbeWithHmacSHA512AndAES256Data.algo, sunPKCS11);\n+        SecretKeyFactory skf3 = SecretKeyFactory.getInstance(\n+                \"PBKDF2WithHmacSHA512\", sunPKCS11);\n+        SecretKeyFactory skf4 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n+        Class<?> e = InvalidKeySpecException.class;\n+\n+        System.out.println(\" * Missing salt and iteration count\");\n+        assertThrows(e, \"Salt not found\",\n+                () -> skf1.generateSecret(new PBEKeySpec(pwd)));\n+\n+        System.out.println(\" * Inconsistent key length between spec and \" +\n+                \"algorithm\");\n+        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n+        assertThrows(e, \"Key length is invalid for \" + skf1.getAlgorithm() +\n+                \" (expecting \" + hmacPBESHA1Data.keySpec.getKeyLength() +\n+                \" but was \" + kSpec.getKeyLength() + \")\",\n+                () -> skf1.generateSecret(kSpec));\n+        assertThrows(e, \"Key length is invalid for \" + skf2.getAlgorithm() +\n+                \" (expecting \" + pbeWithHmacSHA512AndAES256Data.keySpec\n+                .getKeyLength() + \" but was \" + kSpec.getKeyLength() + \")\",\n+                () -> skf2.generateSecret(kSpec));\n+\n+        System.out.println(\" * Invalid key length in bits\");\n+        String msg = \"Key length must be multiple of 8 and greater than zero\";\n+        assertThrows(e, msg,\n+                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1)));\n+        assertThrows(e, msg,\n+                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1, 3)));\n+\n+        System.out.println(\" * PBEKeySpec to non-PBE SecretKeyFactory\");\n+        assertThrows(e, \"Unsupported spec: javax.crypto.spec.PBEKeySpec\",\n+                () -> skf4.generateSecret(kSpec));\n+\n+        System.out.println();\n+    }\n+\n+    private static void testInvalidGetKeySpec(Provider sunPKCS11)\n+            throws Exception {\n+        System.out.println(sep + System.lineSeparator()\n+                + \"Invalid SecretKeyFactory::getKeySpec tests\");\n+\n+        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n+                hmacPBESHA1Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n+                \"AES\", sunPKCS11);\n+        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n+                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        Class<?> e = InvalidKeySpecException.class;\n+\n+        System.out.println(\" * null KeySpec class\");\n+        assertThrows(e, \"key and keySpec must not be null\",\n+                () -> skf1.getKeySpec(p11PbeKey, null));\n+\n+        System.out.println(\" * Invalid key type for PBEKeySpec\");\n+        assertThrows(e, \"Unsupported spec: \" + PBEKeySpec.class.getName(),\n+                () -> skf1.getKeySpec(new SecretKeySpec(new byte[16],\n+                        skf1.getAlgorithm()), PBEKeySpec.class));\n+\n+        System.out.println(\" * Invalid PBE key and PBEKeySpec for \" +\n+                skf2.getAlgorithm() + \" SecretKeyFactory\");\n+        assertThrows(e, \"Unsupported spec: \" + PBEKeySpec.class.getName(),\n+                () -> skf2.getKeySpec(p11PbeKey, PBEKeySpec.class));\n+\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestPBKD());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestPBKD.java","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8271566\n+ * @bug 8271566 8297885\n@@ -42,1 +42,1 @@\n- * @run main\/othervm\/timeout=30 LargeDSAKey\n+ * @run main\/othervm\/timeout=90 LargeDSAKey\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/LargeDSAKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2595 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298127\n+ * @library \/test\/lib\n+ * @summary tests for HSS\/LMS provider\n+ * @modules java.base\/sun.security.util\n+ * @run main TestHSS\n+ *\/\n+\n+import java.io.*;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.Security;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.HexFormat;\n+\n+import sun.security.util.*;\n+\n+import jdk.test.lib.util.SerializationUtils;\n+\n+public class TestHSS {\n+    static final String ALG = \"HSS\/LMS\";\n+    static final String OID = \"1.2.840.113549.1.9.16.3.17\";\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Tests 6-13 were generated with Bouncy Castle using parameter sets\n+        \/\/ mentioned in RFC 8554 section 6.4: two with W=8 and six with W=4.\n+\n+        int i = 1;\n+        for (TestCase t : TestCases) {\n+            if (!kat(t)) {\n+                throw new RuntimeException(\"test case #\" + i + \" failed\");\n+            }\n+            i++;\n+        }\n+\n+        if (!serializeTest()) {\n+            throw new RuntimeException(\"serializeTest failed\");\n+        }\n+\n+        System.out.println(\"All tests passed\");\n+    }\n+\n+    static boolean kat(TestCase t) throws Exception {\n+        if (t.e == null) {\n+            if (verify(t.pk, t.sig, t.msg)) {\n+                return t.expected;\n+            } else {\n+                return !t.expected;\n+            }\n+        } else {\n+            \/\/ exception is expected\n+            try {\n+                verify(t.pk, t.sig, t.msg);\n+                return false;\n+            } catch (InvalidKeySpecException ex) {\n+                return t.e instanceof InvalidKeySpecException;\n+            } catch (SignatureException ex) {\n+                return t.e instanceof SignatureException;\n+            }\n+        }\n+    }\n+\n+    static boolean serializeTest() throws Exception {\n+        final ObjectIdentifier oid;\n+        var pk = decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b8\n+                50650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\n+                \"\"\");\n+\n+        \/\/ build x509 public key\n+        try {\n+            oid = ObjectIdentifier.of(OID);\n+        } catch (IOException e) {\n+            throw new AssertionError(e);\n+        }\n+\n+        var keyBits = new DerOutputStream().putOctetString(pk).toByteArray();\n+        var oidBytes = new DerOutputStream().write(DerValue.tag_Sequence,\n+                new DerOutputStream().putOID(oid));\n+        var x509encoding = new DerOutputStream().write(DerValue.tag_Sequence,\n+                oidBytes\n+                .putUnalignedBitString(new BitArray(keyBits.length * 8, keyBits)))\n+                .toByteArray();\n+\n+        var x509KeySpec = new X509EncodedKeySpec(x509encoding);\n+        var pk1 = KeyFactory.getInstance(ALG).generatePublic(x509KeySpec);\n+\n+        PublicKey pk2 = (PublicKey) SerializationUtils\n+                .deserialize(SerializationUtils.serialize(pk1));\n+        return pk2.equals(pk1);\n+    }\n+\n+    static boolean verify(byte[] pk, byte[] sig, byte[] msg) throws Exception {\n+        return verifyRawKey(pk, sig, msg) && verifyX509Key(pk, sig, msg);\n+    }\n+\n+    static boolean verifyX509Key(byte[] pk, byte[] sig, byte[] msg)\n+            throws Exception {\n+        final ObjectIdentifier oid;\n+\n+        \/\/ build x509 public key\n+        try {\n+            oid = ObjectIdentifier.of(OID);\n+        } catch (IOException e) {\n+            throw new AssertionError(e);\n+        }\n+\n+        var keyBits = new DerOutputStream().putOctetString(pk).toByteArray();\n+        var oidBytes = new DerOutputStream().write(DerValue.tag_Sequence,\n+                new DerOutputStream().putOID(oid));\n+        var x509encoding = new DerOutputStream().write(DerValue.tag_Sequence,\n+                oidBytes\n+                .putUnalignedBitString(new BitArray(keyBits.length * 8, keyBits)))\n+                .toByteArray();\n+\n+        var x509KeySpec = new X509EncodedKeySpec(x509encoding);\n+        var pk1 = KeyFactory.getInstance(ALG).generatePublic(x509KeySpec);\n+\n+        var v = Signature.getInstance(ALG);\n+        v.initVerify(pk1);\n+        v.update(msg);\n+        return v.verify(sig);\n+    }\n+\n+    static boolean verifyRawKey(byte[] pk, byte[] sig, byte[] msg)\n+            throws Exception {\n+        var  provider = Security.getProvider(\"SUN\");\n+        PublicKey pk1;\n+\n+        \/\/ build public key\n+        RawKeySpec rks = new RawKeySpec(pk);\n+        KeyFactory kf = KeyFactory.getInstance(ALG, provider);\n+        pk1 = kf.generatePublic(rks);\n+\n+        var v = Signature.getInstance(ALG);\n+        v.initVerify(pk1);\n+        v.update(msg);\n+        return v.verify(sig);\n+    }\n+\n+    static byte[] decode(String s) {\n+        return HexFormat.of().parseHex(s\n+                        .replaceAll(\"\/\/.*\", \"\")\n+                        .replaceAll(\"\\\\s\", \"\"));\n+    }\n+\n+    record TestCase(\n+            Exception e,\n+            boolean expected,\n+            byte[] pk,\n+            byte[] msg,\n+            byte[] sig) {\n+    }\n+\n+    static TestCase[] TestCases = new TestCase[] {\n+        \/\/ Test Case #1\n+        \/\/ RFC 8554 Test Case 1\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #2\n+        \/\/ RFC 8554 Test Case 2\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000006\n+                00000003\n+                d08fabd4a2091ff0a8cb4ed834e7453432a58885cd9ba0431235466bff9651c6\n+                c92124404d45fa53cf161c28f1ad5a8e\"\"\"),\n+            decode(\"\"\"\n+                54686520656e756d65726174696f6e20696e2074686520436f6e737469747574\n+                696f6e2c206f66206365727461696e207269676874732c207368616c6c206e6f\n+                7420626520636f6e73747275656420746f2064656e79206f7220646973706172\n+                616765206f74686572732072657461696e6564206279207468652070656f706c\n+                652e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000003\n+                00000003\n+                3d46bee8660f8f215d3f96408a7a64cf1c4da02b63a55f62c666ef5707a914ce\n+                0674e8cb7a55f0c48d484f31f3aa4af9719a74f22cf823b94431d01c926e2a76\n+                bb71226d279700ec81c9e95fb11a0d10d065279a5796e265ae17737c44eb8c59\n+                4508e126a9a7870bf4360820bdeb9a01d9693779e416828e75bddd7d8c70d50a\n+                0ac8ba39810909d445f44cb5bb58de737e60cb4345302786ef2c6b14af212ca1\n+                9edeaa3bfcfe8baa6621ce88480df2371dd37add732c9de4ea2ce0dffa53c926\n+                49a18d39a50788f4652987f226a1d48168205df6ae7c58e049a25d4907edc1aa\n+                90da8aa5e5f7671773e941d8055360215c6b60dd35463cf2240a9c06d694e9cb\n+                54e7b1e1bf494d0d1a28c0d31acc75161f4f485dfd3cb9578e836ec2dc722f37\n+                ed30872e07f2b8bd0374eb57d22c614e09150f6c0d8774a39a6e168211035dc5\n+                2988ab46eaca9ec597fb18b4936e66ef2f0df26e8d1e34da28cbb3af75231372\n+                0c7b345434f72d65314328bbb030d0f0f6d5e47b28ea91008fb11b05017705a8\n+                be3b2adb83c60a54f9d1d1b2f476f9e393eb5695203d2ba6ad815e6a111ea293\n+                dcc21033f9453d49c8e5a6387f588b1ea4f706217c151e05f55a6eb7997be09d\n+                56a326a32f9cba1fbe1c07bb49fa04cecf9df1a1b815483c75d7a27cc88ad1b1\n+                238e5ea986b53e087045723ce16187eda22e33b2c70709e53251025abde89396\n+                45fc8c0693e97763928f00b2e3c75af3942d8ddaee81b59a6f1f67efda0ef81d\n+                11873b59137f67800b35e81b01563d187c4a1575a1acb92d087b517a8833383f\n+                05d357ef4678de0c57ff9f1b2da61dfde5d88318bcdde4d9061cc75c2de3cd47\n+                40dd7739ca3ef66f1930026f47d9ebaa713b07176f76f953e1c2e7f8f271a6ca\n+                375dbfb83d719b1635a7d8a13891957944b1c29bb101913e166e11bd5f34186f\n+                a6c0a555c9026b256a6860f4866bd6d0b5bf90627086c6149133f8282ce6c9b3\n+                622442443d5eca959d6c14ca8389d12c4068b503e4e3c39b635bea245d9d05a2\n+                558f249c9661c0427d2e489ca5b5dde220a90333f4862aec793223c781997da9\n+                8266c12c50ea28b2c438e7a379eb106eca0c7fd6006e9bf612f3ea0a454ba3bd\n+                b76e8027992e60de01e9094fddeb3349883914fb17a9621ab929d970d101e45f\n+                8278c14b032bcab02bd15692d21b6c5c204abbf077d465553bd6eda645e6c306\n+                5d33b10d518a61e15ed0f092c32226281a29c8a0f50cde0a8c66236e29c2f310\n+                a375cebda1dc6bb9a1a01dae6c7aba8ebedc6371a7d52aacb955f83bd6e4f84d\n+                2949dcc198fb77c7e5cdf6040b0f84faf82808bf985577f0a2acf2ec7ed7c0b0\n+                ae8a270e951743ff23e0b2dd12e9c3c828fb5598a22461af94d568f29240ba28\n+                20c4591f71c088f96e095dd98beae456579ebbba36f6d9ca2613d1c26eee4d8c\n+                73217ac5962b5f3147b492e8831597fd89b64aa7fde82e1974d2f6779504dc21\n+                435eb3109350756b9fdabe1c6f368081bd40b27ebcb9819a75d7df8bb07bb05d\n+                b1bab705a4b7e37125186339464ad8faaa4f052cc1272919fde3e025bb64aa8e\n+                0eb1fcbfcc25acb5f718ce4f7c2182fb393a1814b0e942490e52d3bca817b2b2\n+                6e90d4c9b0cc38608a6cef5eb153af0858acc867c9922aed43bb67d7b33acc51\n+                9313d28d41a5c6fe6cf3595dd5ee63f0a4c4065a083590b275788bee7ad875a7\n+                f88dd73720708c6c6c0ecf1f43bbaadae6f208557fdc07bd4ed91f88ce4c0de8\n+                42761c70c186bfdafafc444834bd3418be4253a71eaf41d718753ad07754ca3e\n+                ffd5960b0336981795721426803599ed5b2b7516920efcbe32ada4bcf6c73bd2\n+                9e3fa152d9adeca36020fdeeee1b739521d3ea8c0da497003df1513897b0f547\n+                94a873670b8d93bcca2ae47e64424b7423e1f078d9554bb5232cc6de8aae9b83\n+                fa5b9510beb39ccf4b4e1d9c0f19d5e17f58e5b8705d9a6837a7d9bf99cd1338\n+                7af256a8491671f1f2f22af253bcff54b673199bdb7d05d81064ef05f80f0153\n+                d0be7919684b23da8d42ff3effdb7ca0985033f389181f47659138003d712b5e\n+                c0a614d31cc7487f52de8664916af79c98456b2c94a8038083db55391e347586\n+                2250274a1de2584fec975fb09536792cfbfcf6192856cc76eb5b13dc4709e2f7\n+                301ddff26ec1b23de2d188c999166c74e1e14bbc15f457cf4e471ae13dcbdd9c\n+                50f4d646fc6278e8fe7eb6cb5c94100fa870187380b777ed19d7868fd8ca7ceb\n+                7fa7d5cc861c5bdac98e7495eb0a2ceec1924ae979f44c5390ebedddc65d6ec1\n+                1287d978b8df064219bc5679f7d7b264a76ff272b2ac9f2f7cfc9fdcfb6a5142\n+                8240027afd9d52a79b647c90c2709e060ed70f87299dd798d68f4fadd3da6c51\n+                d839f851f98f67840b964ebe73f8cec41572538ec6bc131034ca2894eb736b3b\n+                da93d9f5f6fa6f6c0f03ce43362b8414940355fb54d3dfdd03633ae108f3de3e\n+                bc85a3ff51efeea3bc2cf27e1658f1789ee612c83d0f5fd56f7cd071930e2946\n+                beeecaa04dccea9f97786001475e0294bc2852f62eb5d39bb9fbeef75916efe4\n+                4a662ecae37ede27e9d6eadfdeb8f8b2b2dbccbf96fa6dbaf7321fb0e701f4d4\n+                29c2f4dcd153a2742574126e5eaccc77686acf6e3ee48f423766e0fc466810a9\n+                05ff5453ec99897b56bc55dd49b991142f65043f2d744eeb935ba7f4ef23cf80\n+                cc5a8a335d3619d781e7454826df720eec82e06034c44699b5f0c44a8787752e\n+                057fa3419b5bb0e25d30981e41cb1361322dba8f69931cf42fad3f3bce6ded5b\n+                8bfc3d20a2148861b2afc14562ddd27f12897abf0685288dcc5c4982f8260268\n+                46a24bf77e383c7aacab1ab692b29ed8c018a65f3dc2b87ff619a633c41b4fad\n+                b1c78725c1f8f922f6009787b1964247df0136b1bc614ab575c59a16d089917b\n+                d4a8b6f04d95c581279a139be09fcf6e98a470a0bceca191fce476f9370021cb\n+                c05518a7efd35d89d8577c990a5e19961ba16203c959c91829ba7497cffcbb4b\n+                294546454fa5388a23a22e805a5ca35f956598848bda678615fec28afd5da61a\n+                00000006\n+                b326493313053ced3876db9d237148181b7173bc7d042cefb4dbe94d2e58cd21\n+                a769db4657a103279ba8ef3a629ca84ee836172a9c50e51f45581741cf808315\n+                0b491cb4ecbbabec128e7c81a46e62a67b57640a0a78be1cbf7dd9d419a10cd8\n+                686d16621a80816bfdb5bdc56211d72ca70b81f1117d129529a7570cf79cf52a\n+                7028a48538ecdd3b38d3d5d62d26246595c4fb73a525a5ed2c30524ebb1d8cc8\n+                2e0c19bc4977c6898ff95fd3d310b0bae71696cef93c6a552456bf96e9d075e3\n+                83bb7543c675842bafbfc7cdb88483b3276c29d4f0a341c2d406e40d4653b7e4\n+                d045851acf6a0a0ea9c710b805cced4635ee8c107362f0fc8d80c14d0ac49c51\n+                6703d26d14752f34c1c0d2c4247581c18c2cf4de48e9ce949be7c888e9caebe4\n+                a415e291fd107d21dc1f084b1158208249f28f4f7c7e931ba7b3bd0d824a4570\n+                00000005\n+                00000004\n+                215f83b7ccb9acbcd08db97b0d04dc2ba1cd035833e0e90059603f26e07ad2aa\n+                d152338e7a5e5984bcd5f7bb4eba40b7\n+                00000004\n+                00000004\n+                0eb1ed54a2460d512388cad533138d240534e97b1e82d33bd927d201dfc24ebb\n+                11b3649023696f85150b189e50c00e98850ac343a77b3638319c347d7310269d\n+                3b7714fa406b8c35b021d54d4fdada7b9ce5d4ba5b06719e72aaf58c5aae7aca\n+                057aa0e2e74e7dcfd17a0823429db62965b7d563c57b4cec942cc865e29c1dad\n+                83cac8b4d61aacc457f336e6a10b66323f5887bf3523dfcadee158503bfaa89d\n+                c6bf59daa82afd2b5ebb2a9ca6572a6067cee7c327e9039b3b6ea6a1edc7fdc3\n+                df927aade10c1c9f2d5ff446450d2a3998d0f9f6202b5e07c3f97d2458c69d3c\n+                8190643978d7a7f4d64e97e3f1c4a08a7c5bc03fd55682c017e2907eab07e5bb\n+                2f190143475a6043d5e6d5263471f4eecf6e2575fbc6ff37edfa249d6cda1a09\n+                f797fd5a3cd53a066700f45863f04b6c8a58cfd341241e002d0d2c0217472bf1\n+                8b636ae547c1771368d9f317835c9b0ef430b3df4034f6af00d0da44f4af7800\n+                bc7a5cf8a5abdb12dc718b559b74cab9090e33cc58a955300981c420c4da8ffd\n+                67df540890a062fe40dba8b2c1c548ced22473219c534911d48ccaabfb71bc71\n+                862f4a24ebd376d288fd4e6fb06ed8705787c5fedc813cd2697e5b1aac1ced45\n+                767b14ce88409eaebb601a93559aae893e143d1c395bc326da821d79a9ed41dc\n+                fbe549147f71c092f4f3ac522b5cc57290706650487bae9bb5671ecc9ccc2ce5\n+                1ead87ac01985268521222fb9057df7ed41810b5ef0d4f7cc67368c90f573b1a\n+                c2ce956c365ed38e893ce7b2fae15d3685a3df2fa3d4cc098fa57dd60d2c9754\n+                a8ade980ad0f93f6787075c3f680a2ba1936a8c61d1af52ab7e21f416be09d2a\n+                8d64c3d3d8582968c2839902229f85aee297e717c094c8df4a23bb5db658dd37\n+                7bf0f4ff3ffd8fba5e383a48574802ed545bbe7a6b4753533353d73706067640\n+                135a7ce517279cd683039747d218647c86e097b0daa2872d54b8f3e508598762\n+                9547b830d8118161b65079fe7bc59a99e9c3c7380e3e70b7138fe5d9be255150\n+                2b698d09ae193972f27d40f38dea264a0126e637d74ae4c92a6249fa103436d3\n+                eb0d4029ac712bfc7a5eacbdd7518d6d4fe903a5ae65527cd65bb0d4e9925ca2\n+                4fd7214dc617c150544e423f450c99ce51ac8005d33acd74f1bed3b17b7266a4\n+                a3bb86da7eba80b101e15cb79de9a207852cf91249ef480619ff2af8cabca831\n+                25d1faa94cbb0a03a906f683b3f47a97c871fd513e510a7a25f283b196075778\n+                496152a91c2bf9da76ebe089f4654877f2d586ae7149c406e663eadeb2b5c7e8\n+                2429b9e8cb4834c83464f079995332e4b3c8f5a72bb4b8c6f74b0d45dc6c1f79\n+                952c0b7420df525e37c15377b5f0984319c3993921e5ccd97e097592064530d3\n+                3de3afad5733cbe7703c5296263f77342efbf5a04755b0b3c997c4328463e84c\n+                aa2de3ffdcd297baaaacd7ae646e44b5c0f16044df38fabd296a47b3a838a913\n+                982fb2e370c078edb042c84db34ce36b46ccb76460a690cc86c302457dd1cde1\n+                97ec8075e82b393d542075134e2a17ee70a5e187075d03ae3c853cff60729ba4\n+                00000005\n+                4de1f6965bdabc676c5a4dc7c35f97f82cb0e31c68d04f1dad96314ff09e6b3d\n+                e96aeee300d1f68bf1bca9fc58e4032336cd819aaf578744e50d1357a0e42867\n+                04d341aa0a337b19fe4bc43c2e79964d4f351089f2e0e41c7c43ae0d49e7f404\n+                b0f75be80ea3af098c9752420a8ac0ea2bbb1f4eeba05238aef0d8ce63f0c6e5\n+                e4041d95398a6f7f3e0ee97cc1591849d4ed236338b147abde9f51ef9fd4e1c1\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #3\n+        \/\/ Additional Parameter sets for LMS Hash-Based Signatures (fluhrer)\n+        \/\/ This test should fail because SHA256_M24 is supported.\n+        new TestCase(\n+            new InvalidKeySpecException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                0000000a\n+                00000008\n+                202122232425262728292a2b2c2d2e2f2c571450aed99cfb4f4ac285da148827\n+                96618314508b12d2\"\"\"),\n+            decode(\"\"\"\n+                54657374206d65737361676520666f72205348413235362d3139320a\"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000005\n+                00000008\n+                0b5040a18c1b5cabcbc85b047402ec6294a30dd8da8fc3dae13b9f0875f09361\n+                dc77fcc4481ea463c073716249719193614b835b4694c059f12d3aedd34f3db9\n+                3f3580fb88743b8b3d0648c0537b7a50e433d7ea9d6672fffc5f42770feab4f9\n+                8eb3f3b23fd2061e4d0b38f832860ae76673ad1a1a52a9005dcf1bfb56fe16ff\n+                723627612f9a48f790f3c47a67f870b81e919d99919c8db48168838cece0abfb\n+                683da48b9209868be8ec10c63d8bf80d36498dfc205dc45d0dd870572d6d8f1d\n+                90177cf5137b8bbf7bcb67a46f86f26cfa5a44cbcaa4e18da099a98b0b3f96d5\n+                ac8ac375d8da2a7c248004ba11d7ac775b9218359cddab4cf8ccc6d54cb7e1b3\n+                5a36ddc9265c087063d2fc6742a7177876476a324b03295bfed99f2eaf1f3897\n+                0583c1b2b616aad0f31cd7a4b1bb0a51e477e94a01bbb4d6f8866e2528a159df\n+                3d6ce244d2b6518d1f0212285a3c2d4a927054a1e1620b5b02aab0c8c10ed48a\n+                e518ea73cba81fcfff88bff461dac51e7ab4ca75f47a6259d24820b9995792d1\n+                39f61ae2a8186ae4e3c9bfe0af2cc717f424f41aa67f03faedb0665115f2067a\n+                46843a4cbbd297d5e83bc1aafc18d1d03b3d894e8595a6526073f02ab0f08b99\n+                fd9eb208b59ff6317e5545e6f9ad5f9c183abd043d5acd6eb2dd4da3f02dbc31\n+                67b468720a4b8b92ddfe7960998bb7a0ecf2a26a37598299413f7b2aecd39a30\n+                cec527b4d9710c4473639022451f50d01c0457125da0fa4429c07dad859c846c\n+                bbd93ab5b91b01bc770b089cfede6f651e86dd7c15989c8b5321dea9ca608c71\n+                fd862323072b827cee7a7e28e4e2b999647233c3456944bb7aef9187c96b3f5b\n+                79fb98bc76c3574dd06f0e95685e5b3aef3a54c4155fe3ad817749629c30adbe\n+                897c4f4454c86c49\n+                0000000a\n+                e9ca10eaa811b22ae07fb195e3590a334ea64209942fbae338d19f152182c807\n+                d3c40b189d3fcbea942f44682439b191332d33ae0b761a2a8f984b56b2ac2fd4\n+                ab08223a69ed1f7719c7aa7e9eee96504b0e60c6bb5c942d695f0493eb25f80a\n+                5871cffd131d0e04ffe5065bc7875e82d34b40b69dd9f3c1\"\"\")\n+        ),\n+\n+        \/\/ Test Case #4\n+        \/\/ Additional Parameter sets for LMS Hash-Based Signatures (fluhrer)\n+        \/\/ This test should fail because SHAKE is not supported.\n+        new TestCase(\n+            new InvalidKeySpecException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                00000014\n+                00000010\n+                505152535455565758595a5b5c5d5e5fdb54a4509901051c01e26d9990e55034\n+                7986da87924ff0b1\"\"\"),\n+            decode(\"\"\"\n+                54657374206d65737361676520666f72205348414b453235362d3139320a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000006\n+                00000010\n+                84219da9ce9fffb16edb94527c6d10565587db28062deac4208e62fc4fbe9d85\n+                deb3c6bd2c01640accb387d8a6093d68511234a6a1a50108091c034cb1777e02\n+                b5df466149a66969a498e4200c0a0c1bf5d100cdb97d2dd40efd3cada278acc5\n+                a570071a043956112c6deebd1eb3a7b56f5f6791515a7b5ffddb0ec2d9094bfb\n+                c889ea15c3c7b9bea953efb75ed648f535b9acab66a2e9631e426e4e99b733ca\n+                a6c55963929b77fec54a7e703d8162e736875cb6a455d4a9015c7a6d8fd5fe75\n+                e402b47036dc3770f4a1dd0a559cb478c7fb1726005321be9d1ac2de94d731ee\n+                4ca79cff454c811f46d11980909f047b2005e84b6e15378446b1ca691efe491e\n+                a98acc9d3c0f785caba5e2eb3c306811c240ba22802923827d582639304a1e97\n+                83ba5bc9d69d999a7db8f749770c3c04a152856dc726d8067921465b61b3f847\n+                b13b2635a45379e5adc6ff58a99b00e60ac767f7f30175f9f7a140257e218be3\n+                07954b1250c9b41902c4fa7c90d8a592945c66e86a76defcb84500b55598a199\n+                0faaa10077c74c94895731585c8f900de1a1c675bd8b0c180ebe2b5eb3ef8019\n+                ece3e1ea7223eb7906a2042b6262b4aa25c4b8a05f205c8befeef11ceff12825\n+                08d71bc2a8cfa0a99f73f3e3a74bb4b3c0d8ca2abd0e1c2c17dafe18b4ee2298\n+                e87bcfb1305b3c069e6d385569a4067ed547486dd1a50d6f4a58aab96e2fa883\n+                a9a39e1bd45541eee94efc32faa9a94be66dc8538b2dab05aee5efa6b3b2efb3\n+                fd020fe789477a93afff9a3e636dbba864a5bffa3e28d13d49bb597d94865bde\n+                88c4627f206ab2b465084d6b780666e952f8710efd748bd0f1ae8f1035087f50\n+                28f14affcc5fffe332121ae4f87ac5f1eac9062608c7d87708f1723f38b23237\n+                a4edf4b49a5cd3d7\n+                00000014\n+                dd4bdc8f928fb526f6fb7cdb944a7ebaa7fb05d995b5721a27096a5007d82f79\n+                d063acd434a04e97f61552f7f81a9317b4ec7c87a5ed10c881928fc6ebce6dfc\n+                e9daae9cc9dba6907ca9a9dd5f9f573704d5e6cf22a43b04e64c1ffc7e1c442e\n+                cb495ba265f465c56291a902e62a461f6dfda232457fad14\"\"\")\n+        ),\n+\n+        \/\/ Test Case #5\n+        \/\/ Additional Parameter sets for LMS Hash-Based Signatures (fluhrer)\n+        \/\/ This test should fail because SHAKE is not supported.\n+        new TestCase(\n+            new InvalidKeySpecException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                0000000f\n+                0000000c\n+                808182838485868788898a8b8c8d8e8f9bb7faee411cae806c16a466c3191a8b\n+                65d0ac31932bbf0c2d07c7a4a36379fe\"\"\"),\n+            decode(\"\"\"\n+                54657374206d657361676520666f72205348414b453235362d3235360a\"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000007\n+                0000000c\n+                b82709f0f00e83759190996233d1ee4f4ec50534473c02ffa145e8ca2874e32b\n+                16b228118c62b96c9c77678b33183730debaade8fe607f05c6697bc971519a34\n+                1d69c00129680b67e75b3bd7d8aa5c8b71f02669d177a2a0eea896dcd1660f16\n+                864b302ff321f9c4b8354408d06760504f768ebd4e545a9b0ac058c575078e6c\n+                1403160fb45450d61a9c8c81f6bd69bdfa26a16e12a265baf79e9e233eb71af6\n+                34ecc66dc88e10c6e0142942d4843f70a0242727bc5a2aabf7b0ec12a99090d8\n+                caeef21303f8ac58b9f200371dc9e41ab956e1a3efed9d4bbb38975b46c28d5f\n+                5b3ed19d847bd0a737177263cbc1a2262d40e80815ee149b6cce2714384c9b7f\n+                ceb3bbcbd25228dda8306536376f8793ecadd6020265dab9075f64c773ef97d0\n+                7352919995b74404cc69a6f3b469445c9286a6b2c9f6dc839be76618f053de76\n+                3da3571ef70f805c9cc54b8e501a98b98c70785eeb61737eced78b0e380ded4f\n+                769a9d422786def59700eef3278017babbe5f9063b468ae0dd61d94f9f99d5cc\n+                36fbec4178d2bda3ad31e1644a2bcce208d72d50a7637851aa908b94dc437612\n+                0d5beab0fb805e1945c41834dd6085e6db1a3aa78fcb59f62bde68236a10618c\n+                ff123abe64dae8dabb2e84ca705309c2ab986d4f8326ba0642272cb3904eb96f\n+                6f5e3bb8813997881b6a33cac0714e4b5e7a882ad87e141931f97d612b84e903\n+                e773139ae377f5ba19ac86198d485fca97742568f6ff758120a89bf19059b8a6\n+                bfe2d86b12778164436ab2659ba866767fcc435584125fb7924201ee67b535da\n+                f72c5cb31f5a0b1d926324c26e67d4c3836e301aa09bae8fb3f91f1622b1818c\n+                cf440f52ca9b5b9b99aba8a6754aae2b967c4954fa85298ad9b1e74f27a46127\n+                c36131c8991f0cc2ba57a15d35c91cf8bc48e8e20d625af4e85d8f9402ec44af\n+                bd4792b924b839332a64788a7701a30094b9ec4b9f4b648f168bf457fbb3c959\n+                4fa87920b645e42aa2fecc9e21e000ca7d3ff914e15c40a8bc533129a7fd3952\n+                9376430f355aaf96a0a13d13f2419141b3cc25843e8c90d0e551a355dd90ad77\n+                0ea7255214ce11238605de2f000d200104d0c3a3e35ae64ea10a3eff37ac7e95\n+                49217cdf52f307172e2f6c7a2a4543e14314036525b1ad53eeaddf0e24b1f369\n+                14ed22483f2889f61e62b6fb78f5645bdbb02c9e5bf97db7a0004e87c2a55399\n+                b61958786c97bd52fa199c27f6bb4d68c4907933562755bfec5d4fb52f06c289\n+                d6e852cf6bc773ffd4c07ee2d6cc55f57edcfbc8e8692a49ad47a121fe3c1b16\n+                cab1cc285faf6793ffad7a8c341a49c5d2dce7069e464cb90a00b2903648b23c\n+                81a68e21d748a7e7b1df8a593f3894b2477e8316947ca725d141135202a9442e\n+                1db33bbd390d2c04401c39b253b78ce297b0e14755e46ec08a146d279c67af70\n+                de256890804d83d6ec5ca3286f1fca9c72abf6ef868e7f6eb0fddda1b040ecec\n+                9bbc69e2fd8618e9db3bdb0af13dda06c6617e95afa522d6a2552de15324d991\n+                19f55e9af11ae3d5614b564c642dbfec6c644198ce80d2433ac8ee738f9d825e\n+                0000000f\n+                71d585a35c3a908379f4072d070311db5d65b242b714bc5a756ba5e228abfa0d\n+                1329978a05d5e815cf4d74c1e547ec4aa3ca956ae927df8b29fb9fab3917a7a4\n+                ae61ba57e5342e9db12caf6f6dbc5253de5268d4b0c4ce4ebe6852f012b162fc\n+                1c12b9ffc3bcb1d3ac8589777655e22cd9b99ff1e4346fd0efeaa1da044692e7\n+                ad6bfc337db69849e54411df8920c228a2b7762c11e4b1c49efb74486d3931ea\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #6\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w8\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                00000007\n+                00000004\n+                0dc6e2060bd57f6893d7934b26515ce751360f93dd74a648fa015aa79c862407\n+                5ae5daea402617abb48a1f6b9e2c9f28\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000000\n+                00000004\n+                96755d5f8af0aa32419be743afe779842db52a82387fedd67881aec7172db8c0\n+                70734189eadc76de06e2fc999e8ce42e7ba68c942515b4547abc8c6659a42fd1\n+                371b03ef9ddafdf755b4ea374bfd00b259baef59fd87fd23b1ca5c254ae54fdc\n+                65eec03046b0ca68e8168f82c2e7d28f456ab4f3c69c67ff550cbabdf0f25437\n+                c890347db9d87e0fd243a0341bd6d6cde5190d3c3e7a249bfb757228fe6353f7\n+                69ce313fdaaee88c0416622625f3b6206c2302633e81c23f81de067393a3e3c8\n+                537d3b6b800e7ccea2d90787fb8b7c73cbdf1e778044786ad3b47cab75f9238d\n+                4ef8913fd5ad1e9f762200a649c3e42915f66210c6674a9c0f5a1dc780607b36\n+                c20ea9e299b2dffa4cd144d0715d18cc7130736ebaa67db1c69336ac3c4295a9\n+                94c725bb75a5638a569399f4905f39ccf87999e053fb08ac6e3c04dbbb9c9196\n+                121306e02152603817a574f15dcf010ae68401367024a62ecc4c0dc68bbc76df\n+                c604978101c1ebe4f5fbd8b0bd14aded6740c60b3cb18f8d166c4857940ae8b9\n+                25b707b56637499984f24194cdb2aa66b1bb80a679a8a40bba732ef19b80c301\n+                91bde4b32c6ec0267d81dc86a07ab30afb24b422e99285faae17e8679cf3a6c3\n+                c1682a1d91afb678700fa40fabf03e8b795bd06c4b0b2f8f124ee6790f5aa410\n+                5b8eb7b845efddad84488ebaae01ba7f28e9c670bdf4a142305f3376d13c1a55\n+                cb3e8618e05c11bcf244ae51b825d221e372f45b9c0f512a8ebbeea9a01f213b\n+                75f69f8090f50c11f13ab092c947ded0689803c834c2bbc8b80310be3ad15972\n+                b745678270a0a670806ff1dfb00c65bf661356634bd9466946d79e7e59d4bb63\n+                008f22127172f54c7c15531003a7d31dd949ba15a401b6e8b574f462ee296fba\n+                00e523fe2c54b4b763eb18028d49f5fe60fa88c7c26188710a2ef040c2641c1f\n+                0499a41352ce2c397bee4fa7ffc84a4834419bc571bcfa9ecf17e5e30e14042d\n+                424d0651e85b826e8bf592285e83d01b8b67eff87caaca112fd67a1ed4d5ae7e\n+                2a587d4390c8fd1ef366ff80b83ab02973bcce0be3352656c7e07dfed0df04df\n+                f886adda121035831bf24c31a47157fa19f1e29a7c329a8c0647365886d7914c\n+                969f5477211713dcfe40883c9e00037b200190aa8bd6441e2e9caf895b9ad8d9\n+                52dc7e2ccaaa1d5181b1554c90da50f53bbc993e9a04caed8aff848b72470d1c\n+                7deb858d9baf393f63d8f85cf570161d74a12c93de618d0b1112d5c73164358e\n+                92ce5e4d344b0c9a20e045b47f7ba00567b49cade32612222a5178e5868d88a3\n+                3ec703145ba626a497a716db4ef391cd6c4061dbb904bcbf6ce0e9010893d15b\n+                991b3b0b1d48e2973a19bd94ce2de05577e3db8961dd40c2107ad39aca37e101\n+                66a1788260c7cd125e615b0f19493923a17c0bdba2c982a6ab29fc28689e2b55\n+                c6460afe1e49332835228ea102e9bebf60fe64e44dc1643eaf49c569331e8ca3\n+                d4c7a8206d4b088d786aa514322d9030266fd52d5b92170a112c36b86117f8e7\n+                37520d176ee71b88a13e22b74afb78915c8516bc2967b46b350c6cb5462cd3fe\n+                00000007\n+                7547b8dd925185bf123233ebd5d6efb5b84c25f193ccc96f3cf5746053054d09\n+                274b10a2e41c5b137cc6e3008f6fbe13a32b41ba0ca3d5b95d2ca2af3a7791b4\n+                e4e80d0a837cc7ca2660105679d28c7230bacf244b74e89c9d1a00ec30a96d12\n+                5ff86a045d8d1ce2cad8df211cea8053336b35a4ce75ea9b6a3693c906486a2e\n+                f978e4bc95d39450ae4c44b5204a0f463061cecf2f4b5a3182b40305b57d9bf9\n+                130d38397d257fae6eed3ccf5ed8739738f948aa1e99ada7da70e2f4cb090758\n+                21323fd7b9934344bb47a53196150b88c4e016363132e798a5949a2b52e7194b\n+                d4babc9dc13749f7e69ed462f42de21e03186b6e13aa496b73784d071f8f8292\n+                63b37b71c24b1316bfe5dc48d19cfb4a3dfab112311cbedb59de0fc6d139676c\n+                b5cca0ed495ce2251895447f4983d8147999a9e8a3fbae038e0d3c941b81bdc9\n+                6a80dc3b8569237837940d148150c400d2a93ffe7f2b62aee591498b6c659cb3\n+                1da85478899ad1bfce0803419a4b5bfcfb0ffc27481c351dc594af1146d1ba70\n+                127968e379d34fa22c03a1ca9f2cd8d2f255e9ee2058a6b018cc464d758d633f\n+                f4197291b1ad4257f8f76e1633c19f77fc361767a7a3804d5607931d975d3b19\n+                5182fd0867719ce10daf0f0c0d52b16b8088ca9a26a22aa05224a1765fc82961\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #7\n+        \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w8\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                00000008\n+                00000004\n+                c8568f619f0d5429eab1e63c80e058d1b8a326640a6ab457d776c52eec545dd9\n+                7fedc7e225ab0cce270d961ff9b1615b\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000000\n+                00000004\n+                c89e20317ae8d2211c381fe7354bf382a750e37c307588a30d1bb9a5868e0fbf\n+                414378b30f8c59ccb95a603f03679a417c01bcb191677d629c37a396ffe313c7\n+                f27f1553e993102d1b311b92fd7669c2d1ada6cc808c11477c86fa928196028d\n+                3855d6a39fb56a73ac8eb812fa1974778ab1a7838eda03e4b7ff32d8faad4574\n+                1ede66888334c584ae4086d6a5446772c3f18041126e1972d5acb593261a0a5f\n+                2685e71bb75fae408c4d8dc359bd723d97b5180d96d57a9edbaa7a74f2ef4aa7\n+                316bf4b8232bb32b32bfd3e6c4b7e1356d5822fb90b8c861e8ef9a1f7cd67b32\n+                2b632c2565a6ac6e3635568f1c2cda59cf4ea6a83ec622f81dda9db0b91fff87\n+                080fc8b29ee5514cb25c943a714bd298ea0bba527decdd546c76151b0a9b6c60\n+                ef9de9b8aabc3c979f08fa1a613682eec4c564e5c0d87e932bc618b6009ad575\n+                59489d25a58a4338a03c9ed4c8a89eeea418d5b4a7f813eaf163e2530a40ee84\n+                9b8893f91a2f5aeab8ddd32ad8bbb8e0ffac69d0f1b5333d5211d11f32cb89a9\n+                9f7f346aa5f3c68447e831dfbce57a0a90ac32cb59066f1e5a0c7eb6bb5ef4d2\n+                e941f0a8ffe6e8e944cecdb7124a866e4282ecd848bf53f94f0323828a2250f8\n+                9a59dbc5a0dd02fc90fc433219ce64e982d86c5ddf3bc8bff3ac7f2c6e5dbab1\n+                50a2f4371ebab285f70e25fb0f64667c5805381ff1031321e6f8cb1c85250393\n+                5db51e0032f2da99c0bcc22cafe3abd1d7fddf676713a7fcf2388ed13d60a8a1\n+                ccfb996d9d0accf2be789b949f8cb8ee895f870c4b0c4280a99713abfa29377b\n+                b22a6cfa5f3e0bfd7b6b65c395ac40f8e88980fce0c4ea54b55271a6b3a78a15\n+                957cee33a498d237cb0b6457e7b539591b4c3c01b3ed1e75308cb2d85b1a5d46\n+                40086d1f3c01a244516beb5409175179cc112c16bef7041c92be7e25843703b3\n+                c9fdbb1e9e2d880f9e2c54b8cec53bff94d15406cdac5793dad36af28abf8f16\n+                d95606410d7a8b2af01ddea64572d77609bc9b1f26e0f61ed6115709edaefe5e\n+                c3c44e62d93ffb3dd868f799de31fdd82a5ddbf9126a5271fb368624ecfcba8e\n+                859e9d644063e2d016f3bd6984495bb67a92295a7ba6958d09fb3fa5415cdfbb\n+                c25605e991a5a6d914199f50842357226438c5d757cf1d0bbffdabd32cdb1559\n+                3167d8e672bf1653c2c7466ab7a84e4b587e62be7fe73270cda64513e39966ae\n+                71108c4d187175ae14d9d36dfe6754770febe70c88515b108a20e4fddc240531\n+                3a47377388104fb2597ab1c6ba6aeaf96bf9fa3ef7aa8fc61fdb46fb4c99d401\n+                3ec90362b3b2df6b9be155ffd520f696950ac931d1d32c1fae4d0da0ef76065c\n+                5070edf2043fc9b03ec3c250594f92b8f80862182501a4cb2637d79d347cc2cd\n+                966a3d20415bc34a870d0e9479da62a820f7973e8737a3d1f1cb04507d70981c\n+                5f30c0319443ba0a03cab8c8460306b5a66dd1efe29956995ab4488ee20ceb83\n+                c0891c84eb01761ed74d514d483a51e11a938e89e1f1e6b4a23ebc71150b9381\n+                c01faf71b0ab4f2842f342b80d6bb58bb410091e314127d1c33520e5f38f02f1\n+                00000008\n+                44feef16ea19cce8296b02d3955c58a873f2adb5672f5408d2a1c404c0a955a0\n+                45f483df1000b0cd4dbf5c7918b5259866135714df5fe538b26c10d19b29c5bd\n+                3e6d7f04bf4544385f9fac1e216e371888f866ac840a83518f940f1d0c77487c\n+                eca40d5fec7174006e7255ccd1a85fbd745c0d17797e0425edf97a92b8eb3b79\n+                e524988e3aaaeff9ae4762289737a39acf87e381b5cbe4fc2a0ec29bb3fb5dfd\n+                77c4ae959b46e038e7150c7bb26613125728dbfaf900aa6696c6f2ce0f590c30\n+                14d6b61f70897b732564baa09674b12ff2412eae3378a15ca8ab7d79af7372b3\n+                3dad3878699eda11cc5265d591a2b00a5d948c38fb4e9c4bfa2f34328d590c19\n+                26396c9db7355037bb9e7fa0918e9d2467d358898bad77ed3fdd2cb6f0d14f92\n+                67ba57212ea080200635419bec21ac4163aa41209865b212c5f4b000968e2837\n+                f55c5dc8389f44824427b4e6cda1917e73f7fab883717a0304373e95a7118909\n+                aa1e7854e2546c766823e2f2f4a52f001763692bdb45675ee65101f10007fdef\n+                b5205b6f2d74c42396a7de0a55ff47855e50cea65f46549f845ff855ca6bceee\n+                450eb11b7932b6465736893ca654e1faf280ec2da99dad0b833f5c4e7d805af1\n+                0e95359ba4e23b2640e2768075815adb2298fb5d1dd3552b0e868c2b69a92da3\n+                8b83713af275e933354c5a02438480004d26d0667c3d31236f2e42e594b3108a\n+                2631d63f6b0d6abfa0cc338294019b38bed8da4b49b0ff1a64871ff648687c5c\n+                97b863b78eb60844af1e94d6d3ffbaeead48a974e65fff24776553b3dca6c7b3\n+                072a39cfd09a8bf9c7591c605659c1b103288486475f54be0fb80c18717a944f\n+                51b6d317fba486e1e0ab5afea205335836e717a185827ea4cd47d557be53cc4e\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #8\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                00000007\n+                00000003\n+                7bce4db5bd53cb23819d0fa2181e4d441453ff821284c9d83b8ddace22581469\n+                593d6dd0aa2c99feddc84f8242f6a002\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000000\n+                00000003\n+                92f6ada5a00376437675ae462a5c40d4b1123d97352fdeb3f0b6dd741a3e4db7\n+                60ec956306dc6f2900f5e70e427265deab2d979ebef270cb61fac22a6b6ddc78\n+                ec265af6ef86c9513f3de135f674948c08e5cda0cb953fc6846e2720eb669fd6\n+                2d7e1fd5de25ea3491a4d018782cd929f8df2684ed20c2f71950ac606e86a475\n+                4f60cfca6810ff34233425f932bef13cbb334981f71d54ea71de3510ee52fd31\n+                85cb24191f426bdec8c10caa831e74498ee52dece68f886e9b157b68f2f521b2\n+                17e5907d824bca542126b9d79c70ed4cb1431146025e42ecf8f12b970f109f79\n+                f74e4af4511d966b032976f93ae8118cb4cd3924e92bfe5f508101b0abdc53d2\n+                6f5c1720448e2efa4b97aea98e2069eb4495e2c093601fe70193ed469162e976\n+                4ca3cf64866c59189a488a9e7a510149e0e9b92b0fadcabf22140841946997c4\n+                51410e4954faed09bc3e3e5dfdcfd598e5e70966356718230db6ea8bdf22256d\n+                fb337383d342212b6fbe4be731aef548e86e628fb372971e20d878d3f003b06c\n+                b363799967396381c34252b306a67cfd469710aa9664222dc22fe41008919439\n+                9394d75ffaeeac3b621b0643de2e98f723a761ff6e695f673c3d70918247ef5c\n+                39f222ddedaccc63b6da7ebdfef33a1aba8df3e2444610f6c7b72ba15352f783\n+                b1cac31841e58f6f22a78e2f8521379e226c6890fe41682f2c2a74a44f619f05\n+                84a343deff837d809e41e82cc6ca0b568eb4dfaf5df71de6ad488a3733d07db9\n+                a1d4137cb10244167dada62b3300e5329f886bcf2d35568f39ec759ca82687d9\n+                37fc2b6c7b22d0016f856d9ab353503399bd525298a460b5e5b748942affbe5d\n+                5f562145c6018f53175bfb1c145e512baad481193889f487eb6a007ab3fe7d0f\n+                3e7298c3519fb6d6f6f1c493f5e18bf64e5d421ad60b5c01b599aac05355e674\n+                1966c4d95f3fe002fb936c948121db57a921baef1d9aca2aa918641705a7618f\n+                59df64211e2a0043088af6e970e6e87997a7f9b1fc85513dba92dc8d1f990ada\n+                a8694c4b408341d2e1e01e07ff329486d322ee9b5fa7c3498558c503358f29ed\n+                7abf96c1928b3d21f5262517800587d01517a3ec8fbced7d3f0f7523e6544d7e\n+                2cc5afb15b709fac35301940ca8cf4ef09abe8d1b175cdaa84caba9dad175890\n+                ed9f51d762881e16cec7fed78fe9324bea6b372c09e1ec8078c73192e6869830\n+                5f16d35fdbe5ce305473399014e15c1011329723df62e3f39d28b9e9576e16a2\n+                1199b8eb076017b0500ec5da3e33789a48f6115856a586923f23f167912a307e\n+                19cc96697a4c3198211e95defbc541b797718b0a59bd330a069a3eadd2c285e6\n+                275dfce172e1a109614f0a23ca45fe29dbdf943710176ac138ca10e8a09d87f0\n+                b59ecc4073fa253e0b6707557d075175a167bd0390e089b300d3106c21e83aa0\n+                0ab384f9b301da07eba951294252a421e373def9205711db8326e1558bbd7a79\n+                3665e5663ecc7a552223edabcc6333f07095f274d3e3aa8ec114b8e124aaac0a\n+                4e99113d1950ddf46edf9ea8c8af0d9fd72146885e381a9d899b84d404906db5\n+                6f7f3c209be9da130b0011de9916f7d63c3172637ad83e9a9566d7938559fae3\n+                ac94602daef9f18a8d908e55dc962c48aeaa49c29b4fdb2a3ab38802f650225b\n+                8e6b3d25d3590ed13c3d22e3f1253d385fb02b1feee7770b0f5eb66df2558d5f\n+                3fa6a247e297e96b8f8263648f5f469c8e5313fb929c801e61a16ebe10286010\n+                2c2e9e1a759b7b1f4b2586f3e916970479a0d836c5465c1345314d3dacbe5ee1\n+                074d3a15e4bcf37051d9b1ad76ffbf5bc2826c2311e53caa05d22a7d0315f096\n+                51be069f7903a00b3a1b38a632b00b2e26d3946d151c6a7413cdd7a12593ee70\n+                6307d8dc0d822da33b7e335bc674d287f944fcfbb12af664ef889c9bf9e1175e\n+                f4aa47736532b9a79c489e0130fb2f49456f189cdda60e480ff0cc8435537374\n+                e7619db6a06a6e2eabbbf861483003673f5998dd31c722a6c7d17c7e43d94acf\n+                311e726e12c51805db6837392abcd880b2c5ad035b04bfca7b16ba9b82212c7d\n+                6920b91da7c1e6eaca690756d9b0d403c67ab0f258067f1ae537ad794bb2f2ac\n+                f1132d35e83bc8de5d542f100ea092c33499c5577617dd56399448c6e0719751\n+                f322e16abf3e792ed0014b49354e697f3d4d78b19431d92cbc97aa12bb9f339f\n+                d4be05c666b3215e8450f4f27e5a1a705eaea74c312bfa7d76d4ab39d957fb33\n+                1badfe1cda019460c5011897430e14ad9e8101a5b25fd3de752f47e97452f8d3\n+                2170946b4c905f613953b6a7ea03b96d67b9bee3651bdf1a33f63d2d8bce2867\n+                2e90ef39a066557e991c78201353aeaa47094542581506a5ab258f8cc7757738\n+                9f3d8fc5c19f91b5e7ec60e88bd8c6665b649ac696341229cc1b2cc2224c5da2\n+                7f2c57a53f5824aad8198d9cdefd13753ce10f8cc14f1b764b19d247e6872fd1\n+                99624aaf8a3def3cbb72ae940868870cfb29edc1354532df028dd61414a107ea\n+                83e5a86aad58f52306ada8c12e6817a870696cbec7f5d4ac6a8c5cf63a0494b5\n+                b51617e04794cdd195a1dbaf105175d0219b97fb15efcd172cb3084dff951a69\n+                0b2a0490f8641f245b03a67e4cd75783a8a668483789a3386899d888806633d7\n+                023ce6b77ee7b4c011be72d52eba18cc5f87fc702c9bbcad61e829c78b8faa6c\n+                c6882cfa49bc6ce98f8975bcd88c5c3213c422f20294b4bf960c79911744e18a\n+                1e54b91c78ab7de3f2f5bc69b20a68d7c76f9b0ac029355c523db8348e9bd854\n+                5bc86e1005eb48819993dc2eb96712a71528cfcd69b38c44f668b2ae1e74d985\n+                2303619ef5f54d927d41db399f7273a8d42c85fac74705880b50aee227dab2f4\n+                a2c96d9d6a0cd66ba0c062796c085b0d351b203421f0c1b4ef61330faa31c5ce\n+                f1e91688a35b7c5feb455d467c275049ec330af627d90ac89c7696d9ba06a402\n+                69c347eb6e9114d0f95f0b7a0e3058282988cb2c2cf33ac135d3b108670b8ca0\n+                90e8a770cc1b522fcfd3a777e6efb2e658743a9e65f8dcf218828556626d87f4\n+                00000007\n+                8f421eba67cfd61a355895a87fae815f4531f5ad25dd1832a672321836cbf772\n+                77099b27748d0dcbd08bbd4dd5bc67ff64d630c41bebbd7bf1072910745fcb42\n+                867b9b5e07a6614df38dda0a0f4c89b393b27f42e0a850852a75e9f178e0ee70\n+                f490bdb5266af9db46a2ec1e0fcc6ccb609808cf460048df6a5e8c8fa864ecd8\n+                c87266261ad5e79c874731e2c00a9efc9649895f30ff4a46cc860ebdbeba90fd\n+                c47cdd5e8bb67584f2758b25b032e1462caca6e1f026ecd855856765ebe87f04\n+                4e749f257bb5defbfb826cbfc5de07baffa680e520ff8663b523f151bfb772c2\n+                a6297ab5a9977fb15367eb960050d4c23e42bfc89ac812c1e6cd9ec37668e37c\n+                1a594e0ce90de5cab6341b1e77ea447521645632912a0682fc60de7f7831d0ae\n+                72604756a4416573c0cf6a52e0868b857b76b1faa5bb7e3607a339dd32f33263\n+                4b210e0e31da922ac6870ace1a068f3418588071996ff816b95a1a478488f82f\n+                b54e27fd3f7037360b20e1b3e8674325253ffff578dbf8108927a966cf4163b0\n+                40aa99d98df801f0e241c1607d9e8484c9755f6bbe299a6efe96ec0836e9d53c\n+                213db6d352863854781c78c4cac3083210f979d3f7884aca69fa83429c1542a5\n+                51b8e95ffad4f89b506bd31ba613fe66a375434114dfbdf11741a8d86a239ded\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #9\n+        \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000001\n+                00000008\n+                00000003\n+                fe732f6abc16f3b1c0d1b78d9e72fbe118904abe9b33f2e03d0728ff4cf15b3c\n+                ebea5149fe955d36f911e528d2aaff42\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000000\n+                00000000\n+                00000003\n+                4da59d6dc70132d671114d7e3fafb184a898a603a60119dcb55148775618754f\n+                e4d35a9594db68ab5003f967e968b97101307219d000d16dbc58bcc2285ddb23\n+                dd983189c34e7defa68a7682e26c50668bb20c6d1340fbb127d1d5b805454a66\n+                d2a7f43d2a579568bea4187ae180cd1038d80655454c5dcb9700821d55db70f3\n+                aea2d5f8e1b1b99cfaa86b253e13a72af3389d33bd51329171d666c260b71a66\n+                7f1f7e4256906c0247ac361fd2cb11ab9f3d8d042bab28fd5df69f14a54f88f3\n+                4339c81c02a0a9256292566ed753d2f4312d4103bf25f7b310a86f96301143f2\n+                47c2291674797bd1088920eb5bdc049b8f9809c3c6d96ebfe49084d1021aadef\n+                ec3ece50b4b42e4af022038c6b5363c2dc24522a2e641e352363d9149d68cac3\n+                5bc3d973071e6b7aed2f4f96ca91aa22e162ab985baec0e56df59d3e8b37fe89\n+                59c00aeab5f3713093105cf7db782fa45ea8ee2ec8feb56c529e6b42f18043f9\n+                79d8c4c9d56a4255ec9747d31cc62a7bf70cd8777ffb75ee43dbb2c394e36525\n+                71ce27770f6ea480e89f05ba3cdc633cc3ed269eb2ca0131268fc0579d738334\n+                504b477e8fc2264c421e2e551b1a93713281858ba2cb588a2adcce4d11c2700e\n+                31d7ce6936b267ebe96b4f9bbc4763cccb4f245d371177c258c6d23c30bc5dca\n+                0f6d8fd8194b683f2ac4e0f3ddb7ba1cee1c47e5eec239f5a6b661aaafd2960a\n+                5d1b3305e53d9bbf8f6413368b7656723bcd47e7ab18b41d7e29b511767ba267\n+                e662ee59a004264ec2f88b8ab6fc778315ebc2a08144503455b8b2c1bb410eec\n+                b767ee1eb779f9f2bca35184fa4ff7d8d36a41a9ed3a76fec7fd9a68f8bd35ec\n+                2dd1aa14e7ed9c41db03de868b266f8cfac7fcc887c78e1aa3e085cf0883eddb\n+                74d483dd177f9168ab14134a5e2272bca7e6e31185c34225e05de4545a99a4d2\n+                949a75f970b862aa3b8c9218ac34ad1e3b70a64be25005fd248463606275b9d7\n+                8d96725b39d8b9ba08acb91c3103c7e31f7970f937e176a34f4f4bc601dd8f5f\n+                f83caff6c72b2e7bfeefd49c93cbc270cdd4d442be431b8e9b68e011975708a5\n+                60095a8b784850a3c5bb3bdf2778a8aaca9064b6f1d424f4b41047efc7088639\n+                73df9b861320e66779b25d134bd4528920b64c79c9eed64d5a01e39f8c2e1a62\n+                ad2e6e68bc5de644f5f28b09a9479abe5f96bc6d3e0d77763e3cf61feb31f152\n+                98864c632b450d37a04e6aa4a2fc67406acda826ae98b7c52cc82da5da333ebf\n+                8b1c771dd994f6c650bf24cea6f25963fcf11a1aab7574b888dc89f92659fcb8\n+                1aadd497eb6676243eb9f65e66ef97ab8da3fd9678c8166d1b2aeb724211f4c8\n+                4e72749176f5d63798fbd16b0006dc8d92db7ee411a8ac90eead5a08f89a89bf\n+                295296b8d1d27e97d472cff51787b67a3d6d2a29b66e672647f395e21c9c83d6\n+                dbdda3d3608968288224494a815103549960155b1594d36580ca1db90c54b783\n+                f9e732fc2b14d58726a17bf5869a296985058318adccf6e56672e8dff8beddbc\n+                dbb4bf30d2c59bcb8eedc0e713cd39ad9bb748e5abe75e05179a856c686d1c6c\n+                764f8422372d6f2dbe76f277a21c75c7f778a4056a1ff3bb9f0022d931612411\n+                819c5a8a7b2e360c0ccaaa910e2af0d7ec87e9ba4cb90e85a18ebb8fafb4eec3\n+                40ee8cfa4b9d9a92fbe07aafd07c58e06baeeb5c587279c2b2c344db5e43d5ae\n+                32547dc5f45bc855a9dfd6c8d3ff174d0fb999f4819e3b09ca53cb328689486b\n+                e715f148dcbeea8f46ad00db30bfb087b8ad53ad6e1cb579ed51007289dc5b0f\n+                691188592e1beb23243ea4ab09771552fd03bafc9619dbba025764a5290a938b\n+                3c61ceb22c480a0985cc89a790e189b9e0022f772b30daaa218978208ff94c4d\n+                2f357f74fb93c961de0c97e95efa3a11dfe80caa3fd04051a717bdff5f5cd9ba\n+                36170cbb14defceac5ce20479b564e0d6a3b978a16cc48ede540212af06de08d\n+                300290cdeda5a9eb4c35f6b38cdd04a959370a929bb7c3372cd2a3130e1ae19f\n+                adb54c2389079bd8c7f0249a2b53bf23687cec51b529411fea705fee52504ccb\n+                fa64f7185c6f3601967d30a644a5fb4051517c8560b64009f6de5993c85516d9\n+                2c81e47c076a679ce96435939352d67d11fd5bbc94e6e90881d70311cba88a55\n+                83a7ec14f853f128da2377d14f95b947d00219638e712573223ff1aa2762d1f8\n+                f93d421e70dfd5ff040eb8f2f435d487e2d91d6d9cc0fe2d9066a01eef8a6c92\n+                d3a437a8ef5d8c8c5ea5be932d2f71b4d04ab3dacff9508e7dbbba3a01ea63ed\n+                4b7eb611e35e7d70f0e4ba82ab8a86719bb0e28fc9b3ad28bfa91f227a34b005\n+                418ae4439814122d5e79336d63e1554e1137642a98e67654ee73031166c34726\n+                c4e78848a55ae01b1398338217771198db5973527a82ada98aefa954edf09f55\n+                9f4896aa3b6117592599fd4301dd304d73ce8859509782bf60e8398ff311bcbe\n+                c26cf13b8a6448f2aebd0ca29d06fca7ea09f559aff3a315b1ee70bff8038b06\n+                c381c9630896666c83d14b7bc3b07eb153efddc2b09568c0ea3260c26106d1d9\n+                002ec640f4ed596991b51c20e9d4bb78de99588a33d0a64b20f8ffb2c18b250f\n+                d5f7ed0a4a5e2a9ff94f62b8e84cb4e2ee898b85c11db384a26e9bddbd300128\n+                2d886b7485166c7fc982be8c417f8fcd1a7fd98e529f2fe88a46f36d5091af16\n+                feb75ace51927a339c79cf79fb222b223e845126c73e4e8103fdd04786de373c\n+                9586d13460949c080ec557345dbb88ff1ca59701c889dfbb6492bb9086f05ccb\n+                330a2bff05ebba97a5358702a8d2aee46bf1d7fae1b934405d652a05e532b65d\n+                d7ef2e6599af8683bfe4644ae2fbc77424f31bc422ab791de730e4718d080603\n+                8dbb78b84c5df001047502acc3efe437cd46b8a0a7b4198d5598dbc343db47ad\n+                9c379d5147a5d4bb3c8b962a7368a7405a580f7daf312327141cb5681e198795\n+                3ea2d2d95c7b9ecd6899428a8966203a9ce586357c631f7af27aaef3ea3a47bb\n+                b8a81a7b83bde6f223b270576427c02f0fbb8e9232b2d70f9a0af16ec6544eaf\n+                00000008\n+                ff48f2d9fc8998f7cb6685a1d980003da426db35481323c56195cd5142148269\n+                5b064c6f98dc3289b8244a5a7cfedf3c1c9a96ae48c79d6c9b59e713e91d90bb\n+                a0212398645f8c55bbd03832e57397200b8127d6f38570e15297489040fbe0de\n+                a21d372dfbe5098b1491d8efcfd2389e506039bd49fc976ae940b5e6bf3c394b\n+                189c63af6e799ed580f999ff02a16a5915f9b2ebee58ecde057345f4557e87b7\n+                8828c700ec978f41e9b9ea78cf8dc961b0ac33c54d0f91a1d05b4910e981a050\n+                a2c319c8cf5470b427ab09159fb17e5393176683e6e0b3fcb11104e357d75d66\n+                6b13356454c5bd0e70c18ccaa775ca568ae50d924c2ba2d74babff2fba05ed25\n+                4d9e8dff7d8770738f2e666f8db461fbf0ba307cd638950692c65254b03d739f\n+                72ded6f48b6a9a37de6cb2f3c4498626586ceac37a2644e5fdf9b7794fa4b472\n+                37bc4d45381e5bcf6852d15fd572e0062c8b1fc63a31312737f2347ea40b2117\n+                03f23f5811b7ddbca4a3f19fccaf4860773bcfb872000845166c61243b05b033\n+                4ce5faaac3ab1a7e950403b952e0b0ef4396e5f12abd08bb1354c28afb9bdbc3\n+                edb94b15aad3a85ba3444caa1019262ab6e04f343284bb5a21320440a95edb16\n+                d3317c875cf0187f0ed79b676ca45203c2d4a83233229f0861c58164b2b80b30\n+                0c13ce8899b0ba1e470ead23836fefb921ab6a472beb63b655a1238a5b8f039b\n+                f1c2916a44168e288d4c4aff2ec82c8189a7f7b70837e0a5756db0d38057c9d4\n+                5927418b9fc50048b6ae0f16a9b3e3399d9b08b67c41c84bbc5f8bb9b23f08ca\n+                cd742fa9e1225dc8e6cc32b86d6f57a3ac4b6d733a0655cfcc036c4b4c004a61\n+                1efd58035b06ba03b4a701a68f5945cd90bd4d69d702fb43f0ff10a5879ab709\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #10\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4\n+        \/\/ LMSigParameters.lms_sha256_m32_h10, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000007\n+                00000003\n+                c56e39882736881759e92ef7a37a1953322e3e9742a70e3f401e9bd35c973ace\n+                e06d7f77bd11b4a6082bbf7a5429dd4b\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                c94b744512be0c92aa45ab245dcdb53513877236830106ce43f09a2a6fb083b4\n+                53d15c7290b92cc2864d0780ae105d535de9f9651db43ea47f91a1334bc215e1\n+                eada1413a30a5917c0da8a5ae8256a0d40e98f33d6bca2d93579a44707a4cf0f\n+                6cab795d4e332685898ff004836490805f3b7eeb675c89b46f6d0d76467ffceb\n+                18f41176ce105214f4d57d1058aa1468cd1c2a894b62502b22ecf0b4f73f110b\n+                4b9726934786d58ad59b57ef1fea528421968ef136fd2ca7131c83ca9f03ece5\n+                a8c81765c769d79e8fa4093235c857d3e2864e2614be9535de95a09f60f2c033\n+                fe0125946b47bf09ecbc92123d486411c3c715f313b178818e00a81f02c8b7cf\n+                6c9f6babe65218f5caa8b0c38785fcc9dfe8c35b59077db5084c49f99fa7fccf\n+                5d3dca81c273f72a8f3e8777ffed035edcb9696f9a062a7befa59741abdd8952\n+                1dc585d1f8b37141c6d07974d768ec338ba71f98581fddc7db7f6b11602f2bce\n+                a4168f7959b621d7e298936a981e041092ebc13e944ee2150b91dee55a1f6724\n+                66fc58e24d8d1844237dbf4ae6d5623001afffe971174541fdb7bdf8695d8afd\n+                cc56ce99cd603ad02b700983e6b97b76b9d95715a57baaa5804dee2a02b88894\n+                0260b58e99c05f05bb5b2280e242a40d1f443f3a37ad051dfcf3e1888107c067\n+                a67379ba8716e167b862fcde469ab62a4d84162f68d74a6631ab0a7c41ba7519\n+                096b72110d7a9561eb8bed3d7a87b383a5085c99c54149b56d5d40c747ca28de\n+                ffc08f627609600d2e8f40bd7104bc99a2ec73952b857eda20475530c1fb969a\n+                c79c062c6a687bd2e008b8574260b822de26c9e7cbf32338348db43e4130026e\n+                c2dcd20b79e4b1766762037af058cdd89a9bb2ee4148d09653f0366c7e0b018a\n+                2b72a195a6b1c422e5adc23fbca25968f7bb97e51e01a83b7d1e83b22a118b76\n+                ecc8acac709b3e5de5cfba07d8e81b2dcac4a476359b1541adb24c2e9fd68a38\n+                32f2ae30b1db83470cb50a9f36777fb02b98f63818a078449de16c3108c0b724\n+                ce49b7f5f3beeee04ffdad3cd5cdd2e7955008d6e3123a42a46574a8237f2d54\n+                d54b3f8a6e01185287b167237ef736cef9881ed8478466124d72ac30a3caeb2a\n+                18fd68be71625289e05e076b7c290876dff1a95fab3503533be3ef0c5ad356c9\n+                df59630f3eb5fb6be37c61171243c0cf72ba2e2b83c4d84ef6ff9cac6b9790cf\n+                09eba6e0dc76664cf957c91b09b67f0e5c0f933d503c7a6a6be06f78019eaad0\n+                302e68f499e87d84627a7443bf1e2a8a2673247b1dc6aff3ac940d5f0e3a3ad7\n+                c888cb961d8adc05a85cf2c9af4ac80eb0109b7ae822933ddbfbbbb36e05bf24\n+                c3538c645e22946197d21091192cc2ece6f866fa2c37ce1f4a9be52428d23913\n+                3952f89286f88a7183ad17416360e0143d266f730cfdedd42437eb4baf9c3e7a\n+                1fe7a3e084c2ef4f50e2730ab9fe44c90b1d0167fbd1b6bde2f1457e2a7521be\n+                7bbd3bf2fc64dd111c185062afe4b90830747c68ad4ba890d691bd66d95fde6b\n+                ff7b1b1c4d13c69d4beb23ba90309fa17633ac5c6d3c0571530ee61e48eb4e65\n+                b2482bca9bb230d3fbb6a6e83145a8c918059befc05143a5145ffd4fffb38114\n+                e4026f262038e7d24d5f9dab453899daea13fb4bb07f7c7fa875ff4b8c1600bf\n+                d05be8a945f323243987db289a19bb29250a6a2d8d53c26e4cd5319324676f38\n+                a2adc2fbbedb324a5dd7ef804dfaaba33b4d7fbe17f134e1883400072d5f30ab\n+                86bbfdfdfacabc41b80749abb2271f903c71b383b5779aabb317db34ac01424c\n+                174cacff3dee16cf50e7ecb99d50afead31ab13363f49050463c25aea4d65235\n+                0797d491ebace80bfd2074095f1ab5dceea9866a62c1e7e3c7683c3d7bb50272\n+                741afac834a1e48ffe3e3dac6c168a33f40febfe4ede57637653c7731b4f5d81\n+                ac275de086acfb63133ae49b40cecf3e8a0333764957ecb1fbad30d80e0486d6\n+                5a9727a590494ef7aae57f40bb0d75b05fc8a99d98b28f2294585234894c3f58\n+                a1064bb824afa73938feb5b96b279dfd3f9145ccd4a8339d2be01a62ea25efbe\n+                b4bd970ba21c53d31fe66efba0450e8c5edf46c7116701b52954a11baf31727f\n+                7f845d9050a6a29759850af2d55d47be9646dfd6321af2677806335ecd6812e4\n+                a2ee84aff5aaea12478c36b822335db52a6cc0bac5b59c79f5d947fc526288d6\n+                585abd23a071c6a98bcc6909cc3e45b15ee4244f19fb5e91b9c408870a37741f\n+                bff097374f1da1ac712561ed5f908926f9c05748291de93690cc863d998640f0\n+                963a92ec0b5246745477c83c600e52fd937d4a190d621a114c185a0a84b5ff3e\n+                782113864ccce2b9acf86100bf188d9a00de08bfc9b1fdfffcc1f2ba68420bbd\n+                d6df840fb782a21cda9f051610663e8eb0d1e3e976886fbd98134101fabe1ba9\n+                33b2546f1a468697d453d94716b157dc8dbab7052424b095d3dd7a19ed709da2\n+                60d7ea9df24170f6feea4712c56f82158d1870b1380e7dc4313a4d419ece9ea1\n+                dfd7b3df4ede21f29e050156d5089bc0cff7e15c7983476e890b41f29a2bb373\n+                26dd2da928dca53655602886fd1c4a9c8153cbe50652741ba398857e37ad2231\n+                973c24653ab47e413ca95097a984e56f3fe7fcb3e8a7621d8cd710dcbf8faf0e\n+                2be05dd70a0e746a010fbabf8dc45963673f8e009cf146688852ff02eb1c00b0\n+                5c4adc1ebe2dfcd31a15f37a4ee935bad87bda3e27df9724a7b1564b3f251602\n+                50e722a50869d1cd39784b362bbee70c3a917f18bf92b77a5322e8b5c1a7d101\n+                77fb7a50f3d1b10669d570f7cfd4d5ca1401a4da432d4f68137986c456507611\n+                a050b0ae0b7b8ea295bf78ba9b8b3acceb14aafc82385928ee544ee068171a2a\n+                34a7e2e5b37a19a70c0251910c0966cc6b8a689cd6fc8a00f73959388624f9af\n+                ee57d316054eb23ff1aa63879e13519f416a8449942da592e727073bdccbfc72\n+                52baf02a65ec66bb9504199a147a3616ec20e7c57ab6a4f4c7def3eee13dfe48\n+                06372b85bf3d32cb6b3407a59af02c5549f29a76c73f43566b868e5f1092bfc9\n+                00000007\n+                a22f82a1ca76d4b8fce179e98c2b8f53fc36a1be0c8ecc5ac22a6c65b02101e1\n+                0da5ee071fa5a641198ad237ddc7b03f50612080ff3867ce11df78150d06c9be\n+                35bd7d0befbf473bae9f2f8e077e9358e8bf2b4ca45c7a6af889f56564a22470\n+                43b4b86db63819c4f9d024e3e09b96e731e315d10c3db8312e9bd33d477c318b\n+                3a5f886dc3d8595363de2e2d4053aef8b722f7fe4e092c1c9de6942c6597babb\n+                91ba0b88467321a8762daed53a5e31bd91a76085d559718fa3368aca9c5defbb\n+                6402193da3e293fd7d5df6c0d0b36e4696dbb0e6683dab1e29740b2625faf976\n+                a86910e194b46ca4857c3a1fa37b2a932ee300fd69ff2987fdb6e8ec7fb0a57e\n+                f50448510f72818c87f0a51be0796e20d9fabb66244ec5e99d6fa786b7524992\n+                bed245b61066371a4d0b3b91b64ec0e4e4912b5064f4e73a684de396f73b9531\n+                397506e10da845520a724a419003445e4b3a02ecd83a5fbfa392725054acc609\n+                b9d66d83ca4981ab5a826ac0c675706a0db4ea4f4ad55b3c3a9cad8ebdabcbb0\n+                c1526eeb2f678c0782ff98858241abd90104f0a89767cbfbc8584062ec2f7fd3\n+                ac911a09b2188c85a46b71ed13f71c740cb8f78513476f33b7157b49422e2710\n+                e4ea2efd66b147f1e94f512d5bf7ec40fbf020094c03626fc71053c6984d8b15\n+                00000006\n+                00000003\n+                6002a704915e03814410e7c4a86744b6269cc17650b33496e73414170f642ad0\n+                a5a308f58beacc5b39af6b988b906c8f\n+                00000000\n+                00000003\n+                4958d1fa4dce4ace05d93d530b008131b8c01191cb9c6248842e503676f89c91\n+                12431e2d9276492e1dd36fbdcbdced7dac7a4d86fc64cd8a1f6761d6072eb0fd\n+                a335e5a374b7139a62537af2d20747b199f32b97aa98b7ed722e651b4ea2e8b1\n+                6741525a4adf245446407ef3a0f8da6a374245bc5796fffad397d33ac887ef8a\n+                f1eef9ef53f9bf5ad79d0ca617c69bf8d5687551779762530a71c15a1a833cce\n+                ba629d85f03eb30b065fcf401282632e97cb505e41993ea121aabb93c5f5188a\n+                ae98a85213bfa98bdbe14d2b53fdbc4c00b1826ff9b34ce84293eee25a440622\n+                677e290239095d199a3776d2208ff1dbe2382657e83d1e29f8da4cad0dc2fefe\n+                2d17350229b945718f71d17c646c881229a4fa47e2dcf7485e9096b47c24ee1c\n+                4f051855cd19d787be09ea221bf827f6c2e648435f4d66d2028a011e8536dfc2\n+                66fe9bc6c4d342b95a692567291e6e2ddff81179eeec69fc135983fb550569c0\n+                4d90c040c2a3ecf2b81a55f5368ac0a7a3d9c2bfdb8aa13568c3147f56b0a504\n+                84c4a00b2b1c795e784498d4bd1951eb5733cab4a7b6103a4823f2a94f890c62\n+                dc83c57ac233902bda5440eaea0aa553e0528458b39e8b58ef98e157c95a723f\n+                7c074b5e3c4b2d2c15ded5582d2774c71173be7f7ecbdc659d8d5a132e39f64f\n+                4ae6a81fd550d8dcf7a1e695bc985d059892567fc502399123ee3f1131d113f2\n+                bdcbe027fbf6ef0738f78762982ab379547eee6b4276635d1961b7cfbf1bf6f2\n+                e9c9512fb4699468d882b382bfe6c479878824a52fd5bc0ffbc5cd857d1b96c4\n+                18ef6c59e799b93f14bfe5b769ee28aeee86ff5caae4e7cf19491a00f084b818\n+                dd61b0f97675c85077bee6ce5a44d9a47603491ba1d5e690f311037d7319bcd5\n+                74542337ed91eb7d65a01987d32f17b08d62c9b2cd326fff38e3a6e280c31255\n+                950b7911c262a17193bc9fbe9c43da2a3b69e61a5f09d67f667f64a12e91ab8b\n+                baf00cd7647b9fa8ab76057e5c2dbcb347c26ba18b03c25af8f1bfe18491f962\n+                b537cf3b24078dd8f45a2b3f707657592872d4c3c050bbb69dddc885399e068c\n+                c4d13709c8533f650e48780663b28218bc4e81ac3265b505f4d4ed6c8edf10cc\n+                c9db22b1f92029727cde22f4cade608fcc64372da7367886290828c478ab588b\n+                4473c2e9bfb975368fe6b53b71953eedc62980b60f3da18acbbd292b723d673b\n+                217d17366586344be60802ae9b4bd945c27e196317f9b8aa91299863a6dd336c\n+                9a321b7445934edcfaf6dc7f107a06ec6aacf3c4e7e04d83a938741912a9a34d\n+                6d6cc6598ad635c8299b4c5adb149f935f39a1cae255a8116e544306330ce49e\n+                6a46452ce0420c655ecaf659b8723780c9d2a7946f9b7781ca0ae983dc68c0cc\n+                afbaad6792d3b31b728668d91de0a7927780c78406521bcd483d3614d20a4265\n+                62c6435a924b998e3824351706be646e2d530a2389f6c09a2d8c443611e7c092\n+                330b56ef2672ad807f1ea8e249b0a15a57881048f91b00c4fb374201f8b92259\n+                739e521e10604eb307d3638090c0a4e4eefcda271a5387cebe0fd48d9a146232\n+                37b9380e40ef1108f00a980c4cf9abc88b3edbc7826c48508e02069ab34578f9\n+                db6bc3196dc806e0b1659577ff34d138e53cf784dfd03e3d8289b0d8fa9ab004\n+                dc35ead8fc1433b8c2b1265241f17d9629829c658513051ad7feea28e1d72a34\n+                05a2571a4af94b7ec6ab2ac4cbc810077aeed2237831eb42e303511a3b79475a\n+                9f9284f00b3baaed51ee50f3ec7af02effd2dcaf7abcb9e4bdd639c28293c8f0\n+                63d35b3f3934df46eb853a2b8f9e1e8e39abd9f22a7992325b9965ccc14e7910\n+                829b503007fe5a521c03ffb48f154d908a7f145988de3d35da8710e8b42cf0b3\n+                c9197a9d250dcb5ab5ac724e0eddca2f1e92baa61c2f2862087794fb6aadd837\n+                229c58b673f4a682b6f16178a8bffc71e696a29f9116cb896dfd05780afce77d\n+                cba573170724b067964901112baa343346d2c82e705b842e8be9e5b56577015b\n+                f86f9b27be99ae333bff689d93c7e4ba77be967cf8e6328284c76a2e1a3920a5\n+                515bdc7e5b65e6041aca2268ce13c17195274cb0461611421521e79a2d53af61\n+                1728b35b71db1b6424b6382aaceee899b495fbef4184911ed1877a3b17be2276\n+                571a2347d613ceee0c9de7e0d2f0bb5e18a63ef05f424b1ed1353409f926f84b\n+                4ebafa712f5ce1d36de03c6c90559a60f80e2b4915fa57d08222f6735a6201c9\n+                4931dc8a50f88b537031855c3824f617334f9ca13a9603ac1038d2cde3dab425\n+                e5a3ff1a7fb7a7c25b315187f202eb5311d078cb2e2ffcb1a509cedee7c372b9\n+                c06c6cee6b66b6bae7bcb158e4a74769805a88f5c9cb7c581e12e1d05ece3865\n+                4b5261501fe414ba395f446a846bf736e1eba29fb30fe80ee174677eaab90e1d\n+                eee16dec7a31c23865a38ee8c052a757abb91b104d1b5e0150e535b1c4669e7c\n+                c6b23f57a8dfed44b3f853049596b7f149e5d21be66ae72df95d1e969b054cc8\n+                49f2bc06a1d6bc5565bde1093648ad2581d691cad46237bb920deeb5facabe8e\n+                52e1e02d07903a17332198526a9214b6d4d4bac9f13994f6ae01ee74e673aefa\n+                5aa33ec67c4e0fec44bbd163fc6c317c0db4ce0de479115cd2a9474c7b222a81\n+                23cb5c784e3579ee3805c8a606d2c5d113fcd12bd83d03a9d72c8f72d6c577d9\n+                c891542cd3f3e59abaafdd2b0e9195f57e9c826039647506f0fdda125a1403f3\n+                f007d6db2555125c33de5b3a90ac9cd8485e48bf1db995708b697b5b47741108\n+                1b83dc7bdfdd8aa5a3506cf5a828c0e9803320af6a8b8949edf8fcbe65226beb\n+                aa2930c5502dc34b4ea9588ecf3e69edf41ec734be808b3e39c85a54a7eb5ce4\n+                33994c40209f02eef0e43adb560bdb26a969216b521812c6364bb336d004c56f\n+                91bc928887ae8deae2ea6bde44ddd39135222698c491759ff20dfb6d7686c284\n+                2ffd232c9544e3c39d37e9ce8bac185d58802050284a5fe653aa64e16c9b1777\n+                d011e2ab479a85d33e041423e6a50e5dae059eca94b6c99015e4b65047ae8c6d\n+                00000006\n+                d67b98d51d77fd23841bef1a34fd81e4c561c4f085b02c791553ed46c7644b51\n+                b6b97076d18c3ff64891f63784cd38c9fd1580656d4ed635023f4fca45bd49ad\n+                7958c3201c2233d8e1444a58b1f03221603f1c3b59b72eeac085fdccb79e07b8\n+                37451bf427cb58ac9234253ac0c56906b0540fe5bdf35b47b73f04f56b22c8b2\n+                1ff441f59983c2763a021e6d8f0ee5b73a16ef63d89168563b086698507fa56c\n+                ddd5d64bb968b0763191da92171580f9c404720254cad5c7d6900a4997fb0570\n+                bb9fcd4d249803c3ba2b3e5758cee761ba4c2df21f20ee2d36a547a0cfb216fc\n+                efcf58231cb7d6112ac2583fc1e52f3062c1cb8b14df921eb4b702eb703082db\n+                7ffe104cd0be40b96a04048def98caffea64e25ecfdd3566d3775200c5eb9182\n+                e9a45d41023db850048e05f200a4e7ed2e0b48c532e10c1628503d5b7f394cde\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #11\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000007\n+                00000003\n+                31b6c6a3b78feaefaf459a33e2acfa66a208240984abbe18996896c0eda7b999\n+                9d9786e59e41179854928ed5c5726bfb\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                a3e30c30ffb7b27a99e1e53b030fbbe5f901b7fc38b059190b9ccb9612503d10\n+                d0b0266063d5e234c985b0278428e147ca9686e3540e6d51964e27d0334c0043\n+                3564dc02fe8b1f911667561445bc9e61773d4ea4fb7b5c8e637ce482cfbb69e1\n+                15e118eb5dd28ad2db03ad6618af5a0a919aefafb46d8ae5ca011274032445c9\n+                7a49502e49064fb41fe28aa76c103f0d98edac1d71f51010d7e89d04028394a6\n+                87c98d1ba0b07470add461bdbc5dc553cb7225bc12d6925319253f50e8b8b1ad\n+                1d5ea6304ce5e69150b0b2953e38ba7bf75b5900e1b4e84e81d1ba177c7dad91\n+                956511d74a5b79c22aba2b821ec31021244fc4ceed9b1d992382e7f2e188eb68\n+                841b09301ead899c0857194939576e830cab8fede0f14eace0755d56d144eebf\n+                1eaf5f228f3c3a915de564ffd8c50b7a0e95834eba10737082d38f1c459f2a5b\n+                6479b129f77f57306bc9888a469ea7a7f69be2f4784c472d90b3a84c8a10789e\n+                5984c01ca390681ef94b483be22c2559222a3c8505055fdfcf3c1d5dbc22f342\n+                8d07178cb2736d930313812c30cb9fed3c083e3319208ed600d449df46106898\n+                1f7b3201a9f1760f388aff82eeea616ff89301ed98de1fc9d3a820c7b3e8d5e7\n+                e7a97f3eb819f4f5a08ef7e435d9df748d631539205204f269000d423bf195f8\n+                02091fc8f25e186da3ac3b63f7fcdf832c9a8b849a3efc207dbc39b7d6e67184\n+                4efa7ea995aba735be8d69ea2a7fa954f23d9cd548aae96068e4cca1e53f5fca\n+                2940cf78a43865ff1ef52ac1ed6c347a38b217537ebb6052a094ab8a7d5d67ca\n+                0ea8e46f10be7f07e4f5859f6f940c308aa156268a2378e36b6f642cda1a0e31\n+                dc3eac909426d8e9ad55ee21971c60f58571877e3c9e41bfec8c50c5775fb8da\n+                bc78c18abf1e9c3c9d6a1fdcbc42bb613e5019d95cbd12bbc820df6304240a7a\n+                0aae87df42881ab1e5df3906453ff32acc16a3bd5c01c4bfbe28240a05621899\n+                104994f21e87431596a2c43a336be790cc095ab7fea51a5f957caf3f221dd875\n+                59bad735356ed5364fd9f034ae53c1ae7b7a3672a5d7bc0974650923dca467c3\n+                0f826ae5bfaacfc381469b93825cde82e5f631936bfed860a786d35f29ee326b\n+                18e215c6e01630e811683da0d8d7b9fc24131da9de35a36d5e541896b79bbbe0\n+                eb15ade43e39134013b0de86731d17e7ec7c7cc1cb46d925c211e23f427ddc10\n+                a0d25b18c397a83b3be64eadf9106d5ca75286f599059b2cb0c3cfc892ae5e88\n+                6fb873326634a5231f555a4dabed9fd3370706c6e4af23e5736f5449883d446a\n+                593bbd6f36749f5a71a49175ba562855635511fe9005ab1fdbaa224f55b95a03\n+                cd08a215b8cb400a02896138900273216402241caff7398067b0f6c18edff0b3\n+                3b5e1350ee6157b2d79065ca0beb45feaa67795a821d783d3c566a0a130cd310\n+                ddad078aaa83a319ee6ffba73799bbe3f14a406be25b3f989c316256ae0120ef\n+                bf3593dcbfde8d1f1dce1fbb1cb1c6c8258623112a05b70389b1e801e17fb17e\n+                f10544099ac788eb4cf045ed1fdb9e5e957d7fd930bd927f4c15c253b145f848\n+                dd1ac985fee170307f56d34dae9926d67d1f97fa014fa3ad57c10d76d27dfcc0\n+                0a088a043021d5b053b6d69e912d3cb85b7c2cc029ecec40089333c7c9ec45b4\n+                f9c3ec3720df8fb592f5c71d7dc230f90439ec1ae12643a8f4a30dc96e798cba\n+                269bcd463116dd9657c89c569b519cd061816150e8c39ec3e798574610cd13da\n+                83b52042a890b37d10797ad80f74928a96b697bc810867a4e0e96e98585bf386\n+                d0df41627d76af70436258dd3ed1ae49554d8dc5a2c7e54d477af70e2a407747\n+                227fdd0bc0b5a9019c4df9fe95dcd8ea6251ef1bac071771d364fd428c3db3cf\n+                cb4eb26b7908ed96d30eceffbe634c0184e8cc2b807376d7d5fd9f4d9579f148\n+                8f085df80f032c6c382a48dc80b07bdeca6085aa59f97abc666c1a73d4aeee34\n+                a35e3569ac357a84fa1a9fcd84af37b388dae14e03be6b5e088891060bd69e5f\n+                419fd7d2ae50eb97bfb24c7dbd602de5db1f05c84f1f47fc7c6d40c0fa4c95d0\n+                464a18d0b6338ce123b46188492df786abd9075a535a38de4b42d8d8bd6691d8\n+                fa9dcd8af407d5f20a59cb959802735c2149c18a067367ab9e457e93e569ec1c\n+                42741ac055420fd531dda33faa9f179e272faa5b32c1e6d3029b55e21140f4f0\n+                104a89760e5e038c07a770bc85726fc57159089cc3a2ca2b8a14e9f040b41e30\n+                3e2c57f64dd7579eb094e8deb536a45bfc2840428617117a1b2ae8259764e860\n+                efc03fadfca03511a370256420fbda932a5ab58c98d0df2a9aabeaa7d886ccd1\n+                59281e77e7a1c70094722ec788212885674e90a3134c2471c399bef65cece979\n+                0ef61cf83201cc137a09115b0fa06ebed4de9104974f80fe00b54367ab267483\n+                35e0f8fc02d52e4c556ab748a98aa161d4c9cb712c88155b0177699f5fc4d037\n+                02560279c2be7db70603f03c0c2ccac7437597c79da01ef70d84ae5ab2e0ecc5\n+                b77e9f6a4c412569589d97bfda88efdffb626dafd24408eb79919cf48a619744\n+                fe4c42f3c49ec4c1f94ec8e79366f036aa1366ad559553d102efb9b3a913bb06\n+                feca31ab71949e4aff7fe00be4bfa36e7d6dedfd349c0bd0d8a895b7f8fc55eb\n+                09933f061f0c4a756caea8790d134c58cd1469ce78edd16be26e0208d449556f\n+                b02f343493fafaf615585320902dc4c606d3ae2fd4df7619817b49d47a672121\n+                c18da014aa89309814f49d2259540aa4897cccade9eb94351950a21ef3aab45b\n+                90caa42e3e41f39e1da7b341cacca50a8978f1dab0a54becc79c9501c9ad7c06\n+                db29ca593441ea36ce2d48aa5ab2455efdd70e558ad9f208c2f26ce7c716ef96\n+                44a12f904f4cecae04cb68a433db2d3aefc192009355e6f67f7b565c746c42d7\n+                ed6645ca837351fcc9534c66451e8e1fbc327999423aefe4f5f620c8e15000d3\n+                2c621ba53d572da4d4871d36173e83b1550cfa40a3a8fd7248d351a703389122\n+                a4b070ee87b44ec6543adea6921c567be95a8034a06a00c3fc102b8d2fa4e6b8\n+                00000007\n+                c792abc23c442a9822041aa5889816e9e127ab2323bdf2636cc672b47d055dac\n+                698074f11a96c53449a1ee30e1bc27fc8be61d85f4e5738725457d4cda5f7d62\n+                fc2e949005146d26590fd090a3c50e4141c63b8cfb14087affe86e9ad5207b4e\n+                dedd578be3e0a969d10fcafd1ddb134093d026a9055615e07ec4419786a82aef\n+                0afd2ee68e706169d7688ecfa37c8533d9f7af2bbb02adf614c680db745af017\n+                1676255f9e319f00501c43e4787e8349c9b04bf6bb3e7763fe6e40d6c21e6ec4\n+                d4611c5480aa2f8ef0f6ce3208748b966eb5d1c5945c54f8421ea3c2bf7602ce\n+                c1dbfc1c8408f84cbc3a2b7932764baf9c45e60404f60736cdcb8bd3397398b9\n+                c0e64e4555efd2c94f04a87ae037fd685591599d5c0b1a7197b6886df17c5225\n+                5ad8fec5950668c3dedefbe53ce5ede382633962be26da09260ee48b5d8ba67f\n+                900b54dda5630094a9fa85ae4217faf60801fd315f1f0dd58d30190fee4ef279\n+                51fc2c5633cb46f70e9ee9678e27ac8482a2e48415b14e5d1d3bfa6a86d5b972\n+                93f2d0a32d0c567002b03df6cc7a4c36129ecd04f9cdbc53cee787a344f305a7\n+                b1e61609f7df2745c75a88e07f071d1e93c868409b67afb114cdd539562046fb\n+                7d85f590ebe6969684eeaf7b42547139b50d64400bfe76c687658bf7195c9791\n+                00000007\n+                00000003\n+                052aa96293117df09356c119dd4b9edfe3d7c53d62d9855912682d1c502d64f2\n+                3b298883ffe67153ae1a23d0c6ca41bb\n+                00000000\n+                00000003\n+                9058ddc450f6e1e7b9ddf5fc65edb6c55d60cfaa3b3b1e62fd53d7286903b9c0\n+                63656485ed67b07407c84e1c4a34841d6e88aa0d6a22b262da4265063f3a84c6\n+                fabdc96e1c523d68043290d7d689e7bbd572880f0fb2a1fc2d247c622faad758\n+                ccf2f8751b983a86c29d721002f14050150227e594ab05b2f6ef605140511290\n+                dc213ca6db06bed09f33baaad9a0eb840c7b510bab2a31f7bc039f944b5b40a8\n+                1f047eb423d306a8a190dc1023c6433f39edfe68f2a11357e70356703d15a46d\n+                6df90861e10f84cbffb6efd1b3917e38f6baa2602f4a3d1b4bcf6ff6fc61e22b\n+                edccb0831a655474d5d701fce378142a307819d5a1e8156d655276f1f0b7d9f6\n+                a250c938935f86a2f12410cd5756526d70bfb17e0f90fb440e3e8c760b693ce0\n+                5c5cf7af31049ea0144f6ccfa9a2ca892df28504391c3f1e7fa053fdd29c9767\n+                94ee174f23267131aa62d5346150d9f5ed14867d86b55643ba6ff94b8065a85b\n+                a33499a09fc620e81a57a5d059e37458801464aa461f07ecb15cbd0239272919\n+                aaecec880c2f5bcc5c73af198324d06d9ec48d8a75a0d7aae6fa704bee98eb62\n+                77204af01e13cd80bb8ca5f243c67b02d2eb535041b0b41713c155fc5d5d2ea3\n+                61f27770cf31264a034989896edab335be1ec9b2c5df0106093162af112d1d7a\n+                9913a2edcb1c2fdf732b25c003ebd9df617cc5fc47d8413c2b3b34dd542a217c\n+                32e4aa7a283809f8011dcf59b639e4ca7baeb9b408a100188bd719446c77964d\n+                4865d6b138e9ef1c76d13145218c7de1827ef3599f8c9883ffc2d2412e48ef13\n+                4ef821e1d426748803ddcf325df9b49cd61257f2b2d3fe2bdc960b5140f5ddb6\n+                4696063fcaa699de790947a4ddbc8fdabd46f45d2640a07b434e304d00fa8310\n+                8667fddc1e04a671548ba468ab83dcc897ffc4b776d1694618ab131118cb7830\n+                ec1cf9e432d8f04cf48d8485d58c51b18d5a0bd795588bbcdf65a583f7615e32\n+                4d4a76cd5bfbfec3a0c37c97f9b5b1c5d8795e3149fb11096ab600cd9f77ab37\n+                0fd5970b641fefcf83870fea3d7deb9a4b0d4cc53a9d28330c07802d52635ad4\n+                3cb76a04b6fc09a7129da5a3d617935d144ca865c4a958d4592dd9dff080a696\n+                b2c7301fd3d2974df382562eaab239df41289c7a2b9b55264a879b322d693acb\n+                52c38d9a31559fae7592bc29b1a83e35caef47d793fdab943ff2e3f98a898c80\n+                73ef087f8d4419f1aebd705d2e0ae8fd137f7a46912c6a0ab7cf33f76d523cf4\n+                d27e5c2a22783974134846d923d8d966041d88f113451b439db3af3c90747739\n+                aba2de8ee7e1a7f1f84c6826cd405404c838eb387cba680b5c8f62ce8376c23d\n+                d7bf26386855df8f8d554445987bbee37597171f7849590db96281fba0cd9055\n+                92980b85e0f29f57cc6536e2172695607dee4f53fab7b123a34a97e12182e13c\n+                623f3ac68807718ec5d7806072dcbbf087e6f1e5b834cbbf7d8e85c3021213ae\n+                4100af501e8f77f57fd68c7b339fd649357b396a45eb2826fe06373928cbfe51\n+                f1de9fae833492e42f82d01ea9da9f4074ff22f5b59760d776241c73ebb0f05d\n+                6856dc9e07a2af219e38998afa04ac953dbeb0672b13277bca76ab02566d3f42\n+                2c6763dac87898373b69a1fddd92ef198f52388644be117fd8192b592325039f\n+                aac41b147a73162a5e297f82e09604eab0e06866450f8cebdffa2ff475e83daf\n+                e5eb9296626a895518872a97608ffe04f454a9e0098add3bf581f53490a1e2da\n+                324ee87fd47b7ed7551c0f222f475a57fd041b6e626979434d119525da68fbbc\n+                1e23d8affef88ad8542bd99f981c29435a3a7f3b40ad86426c6bf0a0948a15f7\n+                d8dcf09f4d083cc3c3ac77191afea39e3852f2b679bf2b3028a551e91bb41272\n+                bf59c1bd443dd6c71ead77700dfcdc2a9c686859b12ecfc1f75cddef50ed5eec\n+                fff75007bb26c09b836c32950104dd417ac60622bc57df8e55815204a75d9c79\n+                c13cb605dbc321cfbacdcdebb24ed3fbcde6d7d5b667262a89346598d9f2d9c1\n+                6e6f6886a55caf87221dc27a911cf4c389503d7715b1a791bdc17ba5bffe862d\n+                138b52768c1608f356dd8c88d5b28903a2295891fa139e4cfb16dd22ac8a755b\n+                d496864c95288aa4197ceaa54112e60ae999a8aeca4bef48602298b906c673bd\n+                93bb62da2d0cc7dd0951d304fb878513d2ed70ae39d1f56bb2c665281551ab74\n+                0c1976060bb67bd898868a2c245747a58ea6c1e71eeca9d1e196024b8df0314a\n+                96c278e9387e817caafd11c0cbd517b7cd3b1f1ca9c38a5741b7a46cbe180a9a\n+                deca3d975759eeb165354ca2ac5aa5bbd15841673f5aa25313009e570dc1e70f\n+                58d5d5eea6b10c36f0d5d09fd02021ab10bad7ea9dbd04ed909c7f1b6632eb03\n+                827d67ee609b96079824394bcb3e8f99d7ad77e27c5970fdf56f33097cd38c11\n+                1a095a7cf2ed76014b32a5a73e6a4bbfd86755d2b6e403671fe65ee3fbdf5c30\n+                3b261e3bc613468a46a8c04fb761fcf8b262b142ee4fdcee6a1a8c7baa76f442\n+                2880206b06d406ca77dbf75bf5c0885405e9446e6d0cc8251c11b2a9bf12900d\n+                a45b2515e240afa6d6091cc0618125839efd0e0cf55368b10f9ca04d9e18830a\n+                c0992ca32b1923c1b950215e3eadae1e3fd102f64cb7edf371fdf743ed553048\n+                7e7cc35827d94b7a2462fcdcc7e6eeacbf3626498d66ea1e7d98118431c7b823\n+                5ff390bc68d3063cd42bb63daf5db50edecfb9ce8a83cc5565f1d3ea2d843df8\n+                b899deca8a36e07b79a38be4c064af92b908658743c2808b94f8113490163669\n+                4b50d40b246e3f87930684ebfa0feee96a150e74d3e9150619ffa8c12db5d951\n+                2e55dbd4dc21e09d0262a3b4c9ebe995ca12941e0bc32091891c68614df8ef12\n+                bf34b0441c2204694236631cf4b1992daf2f4511f9f3adc29858dbe1100bfa09\n+                1a8343cf5987fd8175ede1a11e6a5e419d48d1fc834cb83e71e2d2b16a4d724b\n+                0768682f72e83797757e92a04fe738db302cc39622b33ff37a6f3f39503bf229\n+                51af13e28a4f1210f8b88c5279464dcfbfcfb8c2cff3d2ff11321b7f5f1e188c\n+                00000007\n+                ba78a4b874ece30e24b271f4f1a44db792a841a7405e270accf650a793961fd2\n+                09499109aa03394808cab26bf07cb44a856b76a52384c2c8cccf3e343a724d4c\n+                203d131c29a5060c9d518b60ecc1754c52c7abf223683192a40a6831bed6dff0\n+                80a26b30e52b268c8a9184857153af60266b0eb40b0bc255d0e96649c63ec359\n+                6686c1f11ac84488c6ba20f76649b257b6a3bc60d24d6cece4f8396716455dbd\n+                9b9df1ad3ddcd6db59e41d67d52d6648b5da92929d61a17e5b8c9b46246c5101\n+                ef8f4e1b64c8fd471deab9356fb1f5679ae5ac71059a1d54f7a1d72705128c50\n+                b45902f8da6e82e2851bbcd51d8dbb8f824a222596648dffbd61a1d6c95f9885\n+                68500d1d3b084594e0a5c3f3150ed15c4ddf484f45f1a615d63be1d7aebca110\n+                e80efb7a86132d6a57d296343d7c784f50859c9072fdd30c08d71bff9667caab\n+                65b044ecf87e90d7943acb7b5f26a26562ebb6b0a2aa31514c096125ea73c2a5\n+                d17cb68392d92e6c1ac7805a57466a3738256bf8de6cb3c5ee944f45bd4f1d6a\n+                d9977f46826deab2abf93378819376fdc7b61cf344d2265b9f8cd22a1632f738\n+                244569171a23d6d593bd19634758b7ff9c8731720e771023fdb0a6241dda4f61\n+                a4385d3b9c5b6f6bb018324528aff429eca9c1264de9ea434a1a90e07f69015e\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #12\n+        \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4\n+        \/\/ LMSigParameters.lms_sha256_m32_h10, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000008\n+                00000003\n+                4f9fbdfc21ece22a13965cd32027f6d4e5706e751440d214da485f202309a24c\n+                f90dafc3d8f09f797b1b6cfa3636e18c\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                7d5dda179d7f33bd79840ecd9c46c0274f93453448b4b3c8eee74440b900b7e9\n+                9da9eaa94691fda7716fdf2354ad1858df27d29b79c91cf30423c32d5e093b71\n+                b0a141ae160487d8a4451622b5ff1488167cbbf342a876d53671eb0272c6d1b2\n+                ab8d8fe4b51d50ecaa977f379903c9dab520df31beba6f6dd2a310b8514d7a3e\n+                c78e2fd0a33369da3d5e8fde5a3df3669474ada32db4854eeddccb9daa82270c\n+                9f1f9d7d0f45d6b59db36355ccdfff8a08ce7c16cc5c15066b86fa955c7036fd\n+                5706b8560fd06fc1612fbd2aa9866eb40d962bd12585885321fef67dd80c3efc\n+                c0a9f620276038b0850e9598729efcec780d56a67f98d1392426308adfb4d8fb\n+                e4128ad38aad50060186b40fd63eae216d8761ad4b66600f90ad39dbac2c4771\n+                6986754a8c505c0d33906b8a66ca740f68edf3ea55c9e0df72e7f5f1c3b6fdd3\n+                67d8b0205a880a3ac1c9d2a9e48616753a0b9b34d63a8ee4b7f908cbd0a8eebd\n+                a55823c0abeb1911d369ec16414ff39a2d1068ae1331af1eceb6ffdebd3bbc6e\n+                e9ce74dbad7e6fcb362d111a9992b875d4f993a413348d91d7f217c0239b52f6\n+                0140cf51777848ddd04fd1b481033b9ebcd8e4b129db0bb801d99d05ac2490e8\n+                1f858d6f35ff29abd35c40fb650f97a0b32061aa7983822868119dca5c2c78cf\n+                a4f76d26ba91a56bff8c6e500fa35aaf89cce3ca8dc5c9de98a89981cd9283ba\n+                ceaef88dfd5a177d2c71fc7c1131c6ce74be3a2a7a673acaa731482cc4bd4dd5\n+                8f0de26586c2a8863bd96d505821b7e78f88a0560860d022961e6d0ed3cbe9d1\n+                22dd27f77208ad85d12dc33ad819e394841ff0055ce1649b20cd00af1942c76d\n+                14cb6b645d459caa7707f081f47b7a327b3596ab1e3af5b741e503f4888f5261\n+                83d0607e274c4b544e72417aa98326de9bbf51b035bc70e75211b084a947119d\n+                d7929a16d43cba2663a8d2ff8934ac0ee157f01c13fad772bdf15c52bc1cfed0\n+                24aad7e06e3fb72f7ba7bd03860b804ebbf3a78b40cfdc46c147a393d8f88ed3\n+                f921398995697a51b5e3cd8a3b363d03f60f531e3f2d7a8205bdaa4e652f8dfa\n+                42a17bf406580fc7d2240314bc3632850352a9212fbb56e2c4055634ddf76f30\n+                3c9818d2e806b3474587c3dd95d871b7b7b9987108d837efdbafc10735285f3f\n+                3613cffa7ed61e402e08cae00dd43aae21cb70c03cf1fd0313c365075a2927df\n+                a2af481b3026b81aaba7652b8c27a1bf64df4b079ddabc4e142678e86021cfe8\n+                35347ad78e3877a35bfa9da1325935bfd8ee76437c95e95a9199db1949a1d034\n+                2ad2e61b7459e9cc67832093240540d8c1c69af238f5ff9ac49829c5a06db24c\n+                a0cea539f2c58a52e256f404bf0123d03979c32da4b35847f01b253105d71a87\n+                86972babf78052003d2f1183c5bb1f986de6b443ad2b8674a8a88cc6dd1c658d\n+                4efa74da693e5194a7c8eb68a7ea8313e7d42ace9ab5f15e2c536eb4c0da7579\n+                5e50ff72b351c773c603cb749d6410608fe64e191715276fb36a97ee81720d98\n+                06209e53f728bb3be9021a5ac2aa157616b6c9f4f587916732cd682359c8b616\n+                84d3f0ad309c03a3d168f3927601544c622b99a3ddf5291e2500126278122794\n+                5dd8244314b972e0e6c303089055a449aceeaad870a1171b3a93fb329cd777a8\n+                9768b54671a3e87c9861d2c4fbd68971da747e0e12a70211574f5cbd8c98df42\n+                c7439886d089c3515f30ff5c5fb9e1e5a7f0d901ef76a8b5b290e0236caea5b1\n+                bef9f583c7d7b07bf793fabf560ebda31d56a19707fec2a476842dc8171faf3e\n+                b572452a092de32ce195160efe384e7f5c6c5ccfd3201dc34d33fed0fa0fad24\n+                e13053dea01c5ef210e1d5c2d77a94a6acc3fc7d2bb7ead6ef69c5877c1d1587\n+                931fef54754681e96904f5c24050b8d7617843674f4b652bbbcd19860da98aac\n+                c1e00d9c6cdf4a209c8b530b243b7b8f1646b55f9c4b0a35b0133c67eb16b7c9\n+                05834f2e392299ca1c61863c89e333f4530c25c7765379b69fe8ef30a644e746\n+                f09ad8a6090c2548e9294c1ea78695b90639e20de1fb47d3f378689254780b7d\n+                cd4bd7dbc66b62976a5e5df5fe72eda740fd4e38382283f1b335ed72000f8e30\n+                c0de5eb9256808cc5082611a10395710c17861bb7513e52ceb23d005bfb419da\n+                440025643128f9d074351a7ac35e92e9d9eb1520eecc78fd7a8de4919d428642\n+                e1641c269261d4eebc817c82d5b59b3e34bad0a081aa549c02ad7c7c1e8b936f\n+                51eeb581e9a27104a1d210b49c8882234b2de3a655ca4b69b3f72bda9e910875\n+                8cf881ffcab37b11ccd7991b3e12493f4a9e237c3184a838f029be09ac3d511d\n+                12dd84068c476afcf6d18c9516ae5800547b26d0a7d366af96125775f5fda02b\n+                9ac818f4d2209610d48e86c1f57bc71e31519363ea8bcdae791a88b50a84420d\n+                020b627b80424dd377577f0665503dad7d16d2f7532ac51b7adfe5704592dc76\n+                dbc6a32081f3435723b51a7c61ab2b8ffd27179561a8debafff46f1f6ba6a7d9\n+                79a12962352728770024f016cc28caa3de3e7d9695c3c0d2c53d45b7b57e797a\n+                10d1b64e37fa8dd2981d010e95fa9c75619606aac70dacc633d7b415f440d4b7\n+                37fe944f936990afa5f0149776483ead9759af9984c0d37a710735854f526e9c\n+                fcc200c16bc62b6c0a7d3c18189f721eba9b90a29fca15de8d084e44c97cff27\n+                f28af689a7670286687cdd40e60a9f68e7eca10568d5a02561c3f437afc57ad6\n+                9dd6505b04690530c9ed30c5278299a58057b7a24581a0eac0d26166d3f6b49d\n+                796f516103f61ec8f5a6e4307f97b77fed8898190b744c66eb661706fa71606d\n+                5692cb08973738cc0ea9a247590f23dfa8f2c0d406da850c8fcc639b0070c2ca\n+                d9d4c42a42255611b781104068ae3d09e94a7b2b46df774eba4dc6e712509a28\n+                2735e898bef0675f988568bbfdcd09720fa6e2afdc5590ecc9676faf12986f10\n+                9eb838e4e998968dced593c337607f6190b1f32a3cf5aefda5043cbc57e0ac09\n+                eed1660ccaac44af2c55b12ab13a7ef3763eed79cd5ab1b754cf15883c0ce966\n+                0000000856bbc3dc1996d6154a8847e9800276e50ab54db3c75f879f03c48c91\n+                7cfad26d2199acb69cccc8149332d3fcb94f076e55818aa59dc477ecf1bd16c8\n+                f362695da854c55030e90919b40f9aad3d43ead32e97f596c066eafe89d4a8b0\n+                d228e9ee47b531dcf1337b4e45c4ad21ceda14ee10f5f60ad341ba84bda14500\n+                f4c6a8f5317bd98da8713f1d76508046c62decaf44c61d752a9ddbb539eb5844\n+                b4ce4a5ddbc1a050472236a437713603e34fa0eafd713017b932814b6b24a74a\n+                1ff7a6c5d47b4153e2007d87dcaf47573425647f7e6f5f032a934967ada85b7a\n+                8e8934b8aa5395988a6fa50261b8ce6b7900bd6a8bba2d2ac54cf7ce04a0718a\n+                5eccf4551ae37c7b136081189eedbc1793ae7dbf368361f00b1df0cf236bad37\n+                b87b7cec97715aa6daabdb2b30301c376ba7ebb44cd9e2366411aa3b3a1a351b\n+                46c45cafd23213e5c6aabfe59d622904bcaa84d90fa9da47d522bef92a523a84\n+                28e1fec7cac1137532af968d413345dc3ef38b7d6e5f83594f31570ce12c3d8a\n+                2a046604ec433ae94cdf82eddd28fcf603fe605007420fbf34c917e7104fe1ad\n+                1ad45d346c2ac6058bed0f4c44d003e093e4e686a9dd4d80abbb716f7363f204\n+                ede2d0aadbf882db09bc75284fc29b6208b3b8d7110cf847e1cd9a1e04d14cfd\n+                23accde55a2975b5537614fe1809bfa01783c0e3bdc821eae70a5e4ddcf66b4a\n+                c27a3d76e12189a03eab3cd40feb892257213b1318bed0efeac00396546f314a\n+                97b9afc7eb3ef845b4d53bc8593184d734ec19c93fcc0431c5d74afc8f9eebae\n+                f12c7f186a464b0d1b6bdf7ebba592ef9f6d3b3af332a7f100f82619535d7ca1\n+                cd99e4134b50e84ea167948c244f928304f6d008bb7f8a10b218f46c227f5255\n+                980ea31a\n+                00000006\n+                00000003\n+                5490b78c72751e0485c63a1bea5313f0462907f953a8d3ce7e585426c07e608e\n+                33cfd90fa196727a43edb3759b712afb\n+                00000000\n+                00000003\n+                0cb7dce4975f968cae1c1affad81ef53fc2d68bed7d3c9bc83d85204a209e24b\n+                d73256ce79a2e8d2d0ba728a526248518d5201250ea5f831a58c2d03e7aa2fd5\n+                f4eb1081f5e8a7b49ab360caa46395d5c48a527cc84a2db4476194c13e6cbfa8\n+                c11e825f438552014a816e147410daa4ee0ed43c696e78c704f36e924a76008e\n+                e231372d7f50586276da32b3b340d5714d3d1ad1e12e12de00d0a67c61fb6226\n+                5b5a22baf87d2f22d9cbd79b2bc7c9cb0f90a034dd861f50cde7b41ba64df79d\n+                b6c288947156685454739621b526565851d66ad7a47929a97bf82932664db663\n+                550b4cea602c3afd0691cb363df0f8f1858d7296bc99d490df0ca5b5bc5d2a69\n+                ec20f1f85634b7a87b82b4d293d6996fa02678af04e42801871aa56138465452\n+                7f699809d424f62b3d0e4a4e106c3dec086854ba3f61d0edb799612df24ea4a6\n+                a07a7811abd4968500e344948d1293baf4d6a194905d5c526b16e4c4ff28bfb9\n+                b9e03d7a9f184c06441b0631f781f56d5a51f62f3fbc7c3769e32f68d623f406\n+                94fe7179b89289c24493041f4e2c653173cf3a8b2051453d31422bdd50af4a81\n+                2e7bdf63d04765a1ea6a397797a827b7c5ac38d58a7f6196ba5db478dad6c031\n+                143f7684b771a4fb7999152a69106c72642742d892233147e085f5e4793850bf\n+                a83660db5b53df4e67edbc37b4a6a076c419e02ed54b923d708f16d8561c5abb\n+                a10fde6c6043f88137bf80672273924336a81be63d44ec26a4afa761164a0c09\n+                640b1aff3ba0f4dc43d16b382d1135a57936a150323ea3587717a3dd0a8111b0\n+                0b875aed7c7be5250fd2ef9bfb968293ca8121d227efb07b8dff9dc819e6a5f7\n+                459fa5ea01f62b2a8e278e9ef2a7029b08df3a76198de1e840ddc15533195403\n+                197be0c8d1a086651e4dc09e3c59f4b3352662800af531e927b9e52e8a1d0631\n+                1df831a487760cfd6e7a713bdfb2a9326bea28f59067a989d1189889b8a6b9c4\n+                011f0d28113d9f6c2e506bd120bfc78223f6415cd657391dc3f9259e5d9f44b5\n+                4eae3ffbe634eb9880c16f6d67db25f0881fd59e5796c9152efc63c7cfd4e3df\n+                95b98f5aa6a9bce0615a34bf15114dd65e0f44ecc7835754ad6ddddc0f2b69f9\n+                2c41470fb6dbfcfdd1b61292b353665c6fe8601e120ce412bd643049802e3903\n+                f25504f80be1778e24d9166545e2da6552d4c409093a781e33447179fc260164\n+                8598234c932642aa4c307da2670c70fb4dbba29a4aa21fd2ff302364cb13bced\n+                84c0da69d60ce846095ef042f7213be8ff94c23b12e5e5f7bf4818c461355383\n+                c6fbb50e0988f992d82f75db4b98246aa6e6d50713c3b436add3b95670df646f\n+                ebe742cf69c6970b93c7acc86a868c979980e2dc313afcaa67d31ce5dd0c5d97\n+                b20f6fbaeaae2a1b2126e259c2d0b3268eaf96a6a42e3eb0dafb9780ec17c01c\n+                40a85efc413336bcae40324924a311b8645e6554004ac20d4c6334a505ae5c7b\n+                abec7871ee593d9ca8cfd9760417966892d916d9125a81822f96d3d3fb5ed343\n+                a6a8ac47a863dd3bdf502d9d5ffa040398788c446037b82e00392a00ebcc7c7b\n+                d81e85e5986422735ff38cb189dc7c24510a7287714d58aa7b3e645a9cd5bd44\n+                fe4a3573844f5df0ec015c83a15eb3c483b2570de8d105a1fdf6dea1edebd26a\n+                1b4303814b30f16bd064051d077f07e97e825372ed93a10d2022d2a8d93c085d\n+                862ad6006364ab5742fd3e3451ff62c1e8c966d200e18f3f55d79d1ea49d62ee\n+                cd2e2a6202cda533761451e34b691d45b5a6b2227856dfe27cfe777aa9069717\n+                3341aaa79f07975b73cf8c5a26baffaa867f1d41e7d866895f1ac652c19db1df\n+                3124d5d89668032c62c6862aefe101158705e3c735bb1f211eb5faccb167a11f\n+                5f2e043d8c7ae469a28759f25cb477fbd237c44a33a74dd89723aae046ae56a0\n+                b15d415184f0bdd947961a7d3e66480cc3b51d0ca2c1db86c327b0d3270ba864\n+                ed76406b22dc6d107bc172fb9df3513e07ca6365389e41f4a746f56240b921fc\n+                464d1b28d047026abdf970f2767e114da3ff0355a9ab0932f3a9a3097520f9e9\n+                3bf3b03e9b460a7846afe5f316188fe17751857d3bb43ea3a506c974f5d0270a\n+                e519d5ad24b407372f0323730bedcd660f9abb0acc1221ca9e2b0259b1cf4ed8\n+                c64b74776399928598a216ce6ef437056bb752d437347978369b7a578bc41077\n+                d57a6aec7258aabd4c623c03b1c03f5c73931e675667d0c10970f5c620fdaf4f\n+                80d59b70908b30c7a40114d67e92eb93ea34944fd12d6cc7df10bc0d1227999a\n+                200d3a9e92a01a8736ee839d0e72e59a709581e58c6bb03ff7585171f534b97c\n+                4a88937cb7c6a6bb9b1572fd3c2312057ff5986fbb4119a440600496497a91d3\n+                ab0e2b5a744eab30325471539fa9116fae25fc74fd17eb1b75329850ceeefc05\n+                20fc7dbbb35a679cc0c813a19abd5a5730d5b9f0c0bc08d2bbcaffaca6e7b670\n+                1b9f5dcced66b888e93f27c1586e3eb3637e75664f8b88fa2ea8408cf5b90a0d\n+                c9fe016cb773fc85e0b4c5e37a4dd9320fed177e0718862be9a1535274b70668\n+                eeae69369e3746dbea3e3b459f4d20d4fdfc534d5c79517b9c74d4095e4388a9\n+                b3c7ed169f83a079bf4a883cb2bf5d88b9196667f3e2eddc26ea24f192e5ee3e\n+                f68712a78d1ad086eb776a9be9b0301e50e019fb78c70ada132ab3a5bfd6df92\n+                e8a78d837f96ac5e7ff5ae5284d4add69b857bbe06312ac0f579d7f1d537ef5d\n+                b6cb3f775f6a40c85a57ba0f999196368eb0939e68fabfc913d29ff979a1a3e8\n+                74706d3448d12c2eac1f520d5c833138c67233a6109bc3f13d1c9a763c795cbd\n+                cf94a0682257a16401deecb7dc787be82ebec9938df10b1d7ffa147661b11a13\n+                2ed1a432ba87fd76a5be4ac11ebc04e7c151d37b9031e35a9cb7890c2dccaf88\n+                786f3186acbc3fa033ef3fcdf1a670453b07bb1e4bd96e0bd77749ba9c1ae577\n+                b5499b24430d7b3d3786a4dd04c7d69fd052f4a192bd58048b4aea01ad7a14a5\n+                45301c513045cffac021dd9a8640b184b86f915b5967a0996cd6e706e776da68\n+                00000006\n+                180968d5c2d73bddf40eb18e436c809891d2689205550e01993e1b9c0c767575\n+                2dd3d8c2c702aecf34ad3ef16e03b398f1e3d66e490c3d6e086bfbeda5efe599\n+                4cfa5b469a145858df60fed7c71fe8c1fbdf5fbbe5dbe85c9a51016bd9ccbe9b\n+                6bea3b494da9d308c8a85db2fa6848c7db1881615a99b452484c67f96be55785\n+                7b43336be8ff52c5ce5291806e2118337f9a25b26029ec4d1d8023961a5424a5\n+                ecf2b18beac1653790736e6f6a5c7a95ab77caf54ea06c0c11ad6981a2af0b7c\n+                a3e964dc09397caf0e78a63d57aeb5c3acb9c65894b134092a2643d992d53107\n+                5c43c911d5577be8fe88fa023a3e36f32f9333e3c6207ca1b0018c0e0f389827\n+                a7a4cb92d8b054a206adec09b35ea6615069fc7d49132549bab5548b9e1fe61d\n+                2b7a9ba0d6d3e0336f17f3caa18e0ea19d6cf0a9c0e48a83cf325369b6a091ba\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #13\n+        \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4\n+        \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4\n+        new TestCase(\n+            null, \/\/ exception\n+            true, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000008\n+                00000003\n+                cc453a482bbabfad998dbbacf34c0d89151995177fd38cdfa301b645fbad1675\n+                ff8083187b30a36242b11bac4bbb7e0c\"\"\"),\n+            decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                ae258cca017619f7c85179c0dde1f48122fe5b3adcd5ca14475308c6d6a87c8c\n+                6cbbbca7a2dbe83a7fa7a0814e3d692b66bec046ed590831e695e0391c0028c4\n+                9cd5e4e561c983d1640fe534964a4e5725705a4d907f5088b265e329011b8047\n+                330fcf0030724ce62edb5382e59af394eee06b0fe84d95ff8d22b0ba06c31876\n+                b85d29135bd4291f49db0f22c1a304ecdea5137b6b59c49cb053c6ec32b276f2\n+                9dea3ffe6c10f3e99e84b00221bdf587f703e81ffa90e9835839b693fc3e2b06\n+                1cb47c8e3392750c4f53461e419e151004df01da6d8bf8a7998e88089d18c487\n+                d1adabe4050214ae3c5aff0b2e7de19a734d6cc06ff060c5ca4ad5c68178fc7c\n+                bb66b7de65987ce1dc966f1a2f9fbe301f43e6790df0fa452884b3b9ea30fd33\n+                689cf76ae7eb4f6c79f6fae9e89cd9d0349928757dcdee074eacfeb3e1860d0f\n+                1e8f335be9d0ad131da1932730fbe5997a813439920d53c4a36c6ebbc4a2b8d6\n+                96fd511a6b92404421674f1b1b79298243c60bd524cfca71057377b0d0c318fd\n+                341759a91f4b47f5b0df61d1eb1533982707970789297a1af0bb2fedf8fbd582\n+                87708cc4c3304246313b323df92f36fa6fa516c333197253c860b2ea4eb92cef\n+                aa33311f2b9b3af958d67a9e466357f671a1255530fff1c2a7d976c26837bfd5\n+                d7d9d6ea5f87c81abedf1e1b83602250e2226f54eb8f3f1e00bcfcf241e655e1\n+                bf79b0d57b947c196f6c33360d303735d323406411416cd1fb2391d3adbbf0e4\n+                f0ac38767fc2e9ebcec97a5c80712bef5deeaad9c85fc4d024ffe7cba0608c98\n+                90b023852af96a6dfca090187a4f07447d89b1162d0a65e4cc7e2481b057e199\n+                0ed2ee333d2c4f26c6321e2b98017fedc0b42202caf469405678a63108359387\n+                aa240fe210d833914423e02d892fe26290dc2ba89bebdaa2273fe265b5d518dd\n+                5b406c33656466f865c1ffd671b46e2b9044c256798afb1e1d49dfc025aefc06\n+                d6cb1a968c5bb3e200944de6a81bce2ee450559fa3e302effeff2b4e919539ff\n+                3bbeca0575eb8abdc635fd330c1606b1c810029ed55d8a71253ca89587762629\n+                1aa537e4b0c155e7acbac37d1e447586adc56ad262b0ab2421291a28b4e664c1\n+                70750274d82b7850fdf745374c2c2eedf9828300b3b2b9f8d2d774063658ad05\n+                92ed8b8a26e8021ed63f413996d1c12c6a5e80a4fd1f6ede5f431974147d9116\n+                c356e49fb7cda7d35bde52b1c0efdab1dfea8db8b13c608a5545723ee3611456\n+                b21da6a343ca0c432a2353dbf926e2f3227e9659618cc6b46f46da614666f33f\n+                1d979c6d838b678fb027a2ea5ae601592cb28efe10918509418476639bfd1f0f\n+                7dd8bf91f7b28499dc72039218bfe37595e1741942e4a2f640a92dacd809521d\n+                df34aa2b549d2b666089a9df02d963347d565cc5fa1af7f700237db8a57f0cee\n+                4be997ef40f8ae0631877d07b71a4a76d3f6f53a737f14e2fb0f2222e8649144\n+                c3f8ac33595fd9290a2a0345eb1e4c06187ca4b5ac77098e473a07fe0cb58d88\n+                1967f7f645ae144a289744b0801165e9c47d5137f79d3538d6f3a45c962d06a0\n+                13248d125cc52ebd2f3e4ced0d7c1e2429425da6b6aedf96db2c2524522e95a1\n+                dd83db37e92f782b6db3c84ed3f55f32600003d9602c17b6280fc735787f8381\n+                853d02d4b03a97a9404bfe6cd4c58c1a67a70298f29094b454aeb1bc0d59e0d5\n+                e24015f9257d28554905003a687444ce51b19b7e46f4e56e899e3ecdb9415119\n+                924b0a28f383b7e8f817c6430dd9c7b13b6f93179f77c5678fe51098e4c0425e\n+                7d44cd2e82c07bff8b8e99ed08d86982ef7680f8ac3ac2228dd286a1acad546d\n+                43fed64175190ecc62f1662a2f2c29cf2effdc9f9a18e681e96cce1bfb41de22\n+                5b3c02ba65b4c5cc5591d5b17b64a3e8df530ea10627ed29d096f30934d10954\n+                a642548ff04651c9f24ba9c0496bdc1a8af76afc27eb3dc9e28247ab5fa7274f\n+                0cffad5af2cf50ecc35f0b466fd7b8c6973d1ace0cbde0d793cac473ff151aa8\n+                c9bc3d26beb8d819f21ed0ff1fe6af5be4cb4c61e1ed6897496fbbba14f2719d\n+                721742fa7249dd251e501b98936ab43d0fcf4b7a2d551471d3e663595e19e235\n+                674d7d525b6a5ae14ac45913cbfc51e80a7fe351d0cb24a8af1b970d309517df\n+                7a7dd6b12c6edbaab5addb1711abca1c412eb7270e9a8aeefbf7cc5ca22436dc\n+                75b0b5989e1c25f578f8d0aadbde0175e67b14ab05a4c5a5e061a030282f5415\n+                4eebb5a717854b02877ac1fbbb732e52b18dbecaacf16bbb74954f83c0aa470e\n+                35d099b7efb1e17beeeb87ec0b9e706c331f1b20f0a903dec2b7ca1c196b1d63\n+                e804513d3f474cbe6f9bbd2900b79b073011004c49d20f7420a01b7745d490c1\n+                0da63786119d895d58b44eb066d80c88907aaa211dfd82681634be98400099db\n+                8cb82b6d6172478cc2e63d4ea6dd48b47702b24b6fc7b49e09d87b61d15b59d0\n+                39a6d49b3e4896ebe0c83c70ee6926d498ace6148ef3449a7830a7ed4923866a\n+                3f479a708a7dc319c1161d0f29cf425682c389bb173f7681c193ac982c1e4012\n+                6a122b2c6e3fd20906c2921987b2a20d21c722c5fe899fc15089e7b7ddce4262\n+                be8acc27fc4b4b5176740f8f3adcf44240fd1d92c5b1db869bf0bc957175fad6\n+                2d8ad0368b9b47da61e5afffc4ed80ea49890178232dd021d94af7b15bd45059\n+                67bd91eaa2844169e89320c92914e27eda9800cb81b8ff11a52043439035a275\n+                53cf146c9c765b3d5f13bd348475a8bf9b3021168364b7cf0b35b4a2df95adda\n+                7d1d386021d0ddf9193934ae4f0958d2ef8b15a0278e5234aaa976a8ac6acc45\n+                7fff27c4d64da9d374ddccc55285069074ad79bedfb606c95a5d294e97a49571\n+                e4b89696b83a69b4c65568e7ba4b4da0903f819a75ee42f6539b4edd45a53dc4\n+                07c7028834837cb1665050f13b3f69560dec7f042d3d8979fb170257bc024764\n+                627d369086f127e1f5a95f45cf49817c2c699b8d0b20113259ed141e6c01e23e\n+                41a7bb7415f324ba3710534126db40da893b8df672bb16a752e873bc3203dd83\n+                00000008\n+                24bc09be9c410f127964bbf6430a7b42f53ffe22f04cde135d46a847de0844ac\n+                c15c1197f938dcb5adfdcceeb52f95ca113148d07192ab76d83185054df0b38d\n+                8f95cd789b916bf8f7d4b7094802df6ed52cc0573756df7258f12e439cfb1037\n+                01dd72bbdb60753be01822a1ea210eba7fdcea2c9736e79e11ce2e3b50f21a4e\n+                0d84d9c578bfcefb4087146a40c95922b2dd69d29103d9f50fe3368b19015172\n+                36922e837fe8bd50e8063e5f0c2d4a961f1816bf7a5b3eb7ba63761368cae83e\n+                f2fa4e03491acbbfd6d0a6048e3f2589e67aabeb32b3619085ff2d6a810065b0\n+                5a2f5526fe1f188ee80bdb9788f68c1e93cc2ea104e404faceef91fa6a28e27c\n+                e6c2a6a4b03b81c7ca9ce94f06ca7762cb344bc738add901e6496a3fe739343f\n+                aad8396b832ac93f039adad869401a2e590dda2d9c571e136b55053e8bd17af4\n+                2e5518ef8b8dea3d9fefb811e7248961af4f67921c5812bb87c27b22d1384109\n+                85f1f48d40e4c86a1cf7b1d47cb2c776aab2b980a8a1a5e14f6a6c3e823f8b91\n+                9d7de7705ba30357aad9b1d5e7c3404aee1fca2706bb97e94ee56ce826d631c0\n+                d03a93e676a557af5b3105c9cce0364907f1c7520a3a9d70ceef18bc86584df8\n+                c707e48982dcb6221aec3bbe75151d0c50662caf1b401466f089f464b23e4b10\n+                77f4c2ff6efd0ef42202fd51494093459329eccdf895e038c3f7e2325775c399\n+                4ee435f799d7cf0ba8308d018a1c748a5b96786d4b1090547165d30cd9e50c9e\n+                25122424b4d89b5f13949af9eadb7e9bfb95820bfd2053e339dd154593c8912c\n+                ede4bb64b3dad525f55bf6640d99876654d3a9666ab81b38f1e7d41036a2930a\n+                3b4ba370e6fb1cb4436eeffb3a1f4029eab69d47e328e3e50034e3facd1ab396\n+                00000007\n+                00000003\n+                ff29b4fe1b544b372b2922adf63187d1a8186efd415d82a993a79ecd884987fb\n+                984f03f786948f53a3632e75f622a334\n+                00000000\n+                00000003\n+                9818148e2b3f0b1b92424b8df20c31aaaf4d2d49997d481a2be32680e62eac63\n+                4dfc4d390876d14599c23d59822e0d6f525a9afbc8319f75de7370043d33e413\n+                7b9f1fbdaeb3e47bdbe29fb7e3247ee5a1c637bd739be597e5513b81e5b717bb\n+                593037bf97b4c1f216566a944bb19bdac86a5be82fc34eef1799e07d7035692e\n+                687024660a3a83fe17d73c919513c12660edd8af23975ba3816d027b7cff5e5e\n+                675f5375bb1eb6eed9e5cc49b962a97b1cf41d79422f2d8e290ff119d1cd562d\n+                e4f65dff4a7408b2eab21093d096707cbdbb70e8bf6394969e1e51700a500a98\n+                ca1fa371d96eb24b359db9af3d2a5e125e33b87edc22eca8764eefce39dae0b6\n+                db5504c256375a7b6bd8ffcaf48a1fa9b246bc9952f8374d8d65cf22439668b0\n+                3c02ef6fb4a1512dea8d7c38cbd8946114bbd57a0da2ffff326bb83873f4ea40\n+                09270671b0d9a88e10c9552ac580160d248daa7bc3a10cb393a1a2aca8ed55e6\n+                d6983861830557e7001d65d8656c07fa37b459a5bc3ff26c2109be9f395d1307\n+                8e27e75f85f388562f555060fc040650be7c5a4984bfb41fdf0ebc2da22a8719\n+                563aa522fe36af768d95d49da30c899f3409c8a6587403411eaf032a84354039\n+                1b136a795a0b3da15351ece2f62b7cc15d8f9e3bbacf29bd73e96c9761fd23ff\n+                ed75c8131721899b2b314c61537e3d324706de6dbb4adde305943ac6a2000e5f\n+                6e193f83b9381ade4d61a9ecb2591ece400ace7735eb6e0958d7d1c9b0ef4990\n+                2ec4592c935303c71049c44a518d65537cd903c95c37811501028a20b4aa4030\n+                2857c970a589260073ea093eb913a11ac42c67034d27fed38b300eede2ccb18f\n+                7df10d09d9cbeaccba52471fd01d42361343889e5725a7f2d23c723517337e94\n+                2f53fcefef8c4f091fc1a02790db7a987bdac6f67382619a84c003fb76f27e1f\n+                f070bb8b7786ce47d4455de311230a0e1dbccbb8bd37c45f36e84e3f15c1e4e9\n+                daa1b4a082f85a5c2c71371e39661792284357a7cc40451e39444e8c352185d9\n+                e7aa1e7524a1eff33b5839c2247b1430a517db6ef4963b23a1579a3803c0d2ae\n+                3568e0d83d551eb68dcd301e75f4cf38792cc504a94559c1b1a929975aaa38d6\n+                fee0aefd1aa4c99cb1412736b2f5978c21987e651e391c5b1e61cb84d92d3806\n+                cb5fe46edde39efbce75d0db86414e82f6ce07b6c304c7f7fa887d13a02e8f59\n+                57b8f07ae9b80a10b3f050902a230e5b33230473691af8c7c2630d899c8efa1e\n+                da5afd1db629318736132466c1970f9753200e05a30ee13e38b4a60e15fbac33\n+                986a6e7760c5805b4f488580db0008e574e173a34cc62fd52c9cd56980249a2f\n+                0c12238a0df04a06dc9895413b31fd0aa0d9eee50ce7fbc178f8719bd9df399f\n+                ce72a57e8571fcbfa4f174f0c37c053238bb9225d480547b34eaff09d00fd29a\n+                d2daf5b694ba4ca8a25e42f14f2cd7c10477ed29b22936989cb7135c8034f81e\n+                2552fd1d15f54ae69054fa03a36ff48d1ccec9c45dcf642dd4bd0e2aed42d4bc\n+                b3df5f9a10805347ec0524c13d49014ca1d983d7de40031f530a34ca1e8ba45b\n+                5b304303a71942388b61779ec6ecefab91cdf705c41d6c2fe72a6be231acc3b5\n+                496661b0d9f5908d0f39463b785a98348a0f9fcf714255e6d9c9c33549541567\n+                55980f2d96686e98f5a990f821504cf2a1c32d2b654f0071dfd85981d59da1a0\n+                ecac2d30b1e2833ea108982aeb059d8c2b7facbcc4391bdd88f900cfae20cfcf\n+                99fc75fd68a85bee6a75be7cf8f4b8a66d9bcab17094e51e745c9b8980b69cfc\n+                4d9bbacf338fbaddad1fbcee745ce30b8ea8316e597350bf1372353d38274c31\n+                34c9e3ddb3affb1f5d5b30a51c3dbbd7529446f4bba26eadf4aa53e7641f70ea\n+                60710d773b02d930a298f8c6957b71f6841a6391ae9d5d2ebee3600061c57244\n+                7ff9e16c211a5b71ab1e7ee811f70a76aaf8617648083959b327a8f15698ba87\n+                3387b492ae7a7ada5d78ae4fdfce67262cacdcaa0717c4e52d7ecd85491903db\n+                f64073dbc2a0f77ba5489f0af146ce8d4e1544f60cc51d2a9db84eb5d8b3da91\n+                c10ad2437744c8b3077d592e5b42baa7846d4250df4c98112b688813988a6759\n+                2fe7b707276dfbcf7cbe3daaf0be3c8c13917d4f2c70c6b6945e05457ce7018e\n+                c167bebefce80d10502f5a2164492a8602ee7db978c51f79612b5b9d69013105\n+                05bdcbbb66a385ed2702a630303fcc30900b8d9c345229f7d539185cd2cca328\n+                d40dbdf3511715cdf195c7565bfcd7ae7830374d4c77acf746874068f7f0ec3f\n+                bc22fdbd06fbd4a4bc018d6a81bdf9c5f3ec45c441333cee36e2f3d28f4d4ac4\n+                e45299a3ea7151e2f314ce1d8c7f8aff7be4886bf8ab8de2893f17baf2969125\n+                d4b8e4f036b3b60c88e0c08450a8e7ed005831f2030760d4a97c419a859ded43\n+                85e855bed5b966d1a97845fe8a6dc7467a2529ea005fbf0da3fd3efa28142c92\n+                058dcec7ec1e1f199ac8c777857295b34a33e2b678c04475b7dfeda7656dcc5c\n+                b948ff2368e989a4688c16ba02479ccb107f6fb27dc30f0e49b9641aff149d07\n+                c6afd31db92c8a5d0c0f4234aec0c0e1e05c7336378b387d1a70a4176dee6835\n+                74811cce4b20f0730ef92932d1d790b6cf73081da8c51b75ba8950579b92c117\n+                567f3a1fd8a049685a7aacd9cbb997a0aff7e6a34ea7e70fc8cf24b11f96d2f9\n+                ef5327eba013bea5cff327f3a5aece1b8a2fb45f80c2454a9cba86a55a1ef63c\n+                7862d07eb1274fb68b69db5a0cab9b5aba53595f6e0cf643efbf38ed33e7bdb7\n+                3f887e8bc0e50c003bb8523b7aa459bd0517fd3b502ad4fdaa22010cb6ac5bf9\n+                7d6ad67c2317a9d18fa8efc4c02345bba30bdfeb788c001ff4f9a899b0d11043\n+                454b52fc2828fc1891e149b42ef897608d95f568f3eb301023dbf18f40da3148\n+                45821078487199e71a6b48b2105851702fb6319052ca642ed6338c41cc8b3d95\n+                b101a08835e9352f71938d24f8789d32add82e7ede0fd1858330a451015f7e87\n+                9c5eb59c8e534beb771aee8b0fb2bf4937fdc9cf07d891ccda61ae4aad303282\n+                00000007\n+                2e0e7708bb0e589d2d818a8c0e2c53b3e59b9e43c7a194fd18d19ab1554a9f85\n+                90b31f08e2fe1b38486572cc3b36ddaa9d85b795fcd93acd531283688191b5f5\n+                a744b89faae49989127685cdc000e001a0d77df3a5c3061e312377b1050e7371\n+                24a68d2a00a848e141d274dccb8e4740d33ef7970494ed316447f8381ba06791\n+                001e90b7f36ef24e1dbbd68f7074ddd233d9e15cbd4efa4a249cb30fd3095c3d\n+                ed096e87d6c179ff8dbadb1bc6493bb6f944ccee2cbf24573017817e586475f0\n+                ed51bfe889b298a2fb76d16dde0c966a70a284dafa980442f870d640e11079d0\n+                a4f6834a62ba0a4eac4d7334f3c756ea6b0bd8eafad227b5b8eb4e937c32412f\n+                201780dbf5eab317f3a21293e653115bbffac4899830eb28e6e43c1a77b51884\n+                8f68887ccfa366175be2a88d3fc178e671073736bd94eb4e16720a6b3ee119b6\n+                dcba885ecb46126614c7a677c1662c4cadcda742f27fc01a8bd5af474ee4a29b\n+                4e25721bb931b8bf898afb3cb66d3fcab70b80005e737ec5bd88d5ced8941226\n+                720dd43655a9ba1d4bf0a723faa4bb3651ed2ea7e0bd08113e524777e6ec592a\n+                ba5cab16b084d208d20bf25ad9a7ae31bceb00b07ef20cab7d1f6883ac331c75\n+                a2aefb8230ae97dc34577785b123af406040d01fd072c493228d7583cd023c25\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #14\n+        \/\/ LMS signature length is incorrect\n+        new TestCase(\n+            new SignatureException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+                decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000006 \/\/ changed from 5 to 6\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #15\n+        \/\/ HSS signature and public key have different tree heights\n+        new TestCase(\n+            new SignatureException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000003 \/\/ level 2 changed to level 3\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #16\n+        \/\/ bad signature\n+        new TestCase(\n+            null,  \/\/ exception\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000006 \/\/ changed 5 to 6\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #17\n+        \/\/ Invalid key in HSS signature\n+        new TestCase(\n+            new SignatureException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000006 \/\/ changed 5 to 6\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        ),\n+\n+        \/\/ Test Case #18\n+        \/\/ LMS signature is too short\n+        new TestCase(\n+            new SignatureException(),\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                \/\/ very short\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb6\"\"\")\n+        ),\n+\n+        \/\/ Test Case #19\n+        \/\/ bad signature\n+        new TestCase(\n+            null,  \/\/ exception\n+            false, \/\/ expected result\n+            decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                71a5d57d37f5e46bfb7520806b07a1b8 \/\/ 61 changed to 71\n+                50650e3b31fe4a773ea29a07f09cf2ea30e579f0df58ef8e298da0434cb2b878\n+                \"\"\"),\n+            decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\"),\n+            decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\")\n+        )\n+    };\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/hss\/TestHSS.java","additions":2595,"deletions":0,"binary":false,"changes":2595,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug JDK-8298127\n+ * @summary verify JAR files signed with HSS\/LMS\n+ * @library \/test\/lib\n+ * @run main VerifyHSSSignedJar\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+\n+public class VerifyHSSSignedJar {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ This is a signed JAR file using the HSS\/LMS signature algorithm.\n+        String jarFile = \"\"\"\n+                UEsDBBQAAAAIAFKWqlbvY1zrjQAAAJAAAAAUABwATUVUQS1JTkYvTUFOSUZFU1Qu\n+                TUZVVAkAA7wfXGS8H1xkdXgLAAEE9QEAAAQAAAAA803My0xLLS7RDUstKs7Mz7NS\n+                MNQz4OVyLkpNLElN0XWqtFIwMtTNzCtJLcpLzFHQ8C9KTM5JVXDOLyrIL0osAerQ\n+                5OXi5fJLzE0FauXlCvZw1DUyNdN1yUwHmmqlEGgYnp1YkRcS7FdeFmbh5K7tb5ll\n+                6ObvX2rql+4YEOBlXhDm7WUQ6WfkHmoLMggAUEsDBBQAAAAIAFKWqlZLYPST8gAA\n+                ADIBAAASABwATUVUQS1JTkYvU0lHTkVSLlNGVVQJAAO8H1xkvB9cZHV4CwABBPUB\n+                AAAEAAAAAHWPTU+DMACG7yT8hx41pA6aCIPEw4ARNHxtC3Vyq66DZtBiKYL8eolH\n+                E2\/P5X2evCdWc6JGSSGmcmCCe8B6MHUtkJQoeoH+tweQBRlXVHLSgrtcko+WgkDI\n+                Xkii1sW9rp3iHUSPNgxZTQcFU8LZdQUP3FJ5WdJJRM7Yz1m2ea3O0nTHzdzNoYU\/\n+                m9byOzuc8CEQT\/9qVmAc7pSS7H1UdPBAhUWPqRLJs2ENcYX8cCze\/KSseLXdJ7Gu\n+                gam4Ruf0SA6Re1vNupaRjq7f\/kY8gI9fxrjvm3qZm8FuqiJnRll29RLmLyZneOs4\n+                qHYRwjj9Ff0AUEsDBBQAAAAIAFKWqlbb\/AXeEAsAABgMAAATABwATUVUQS1JTkYv\n+                U0lHTkVSLkRTQVVUCQADvB9cZLwfXGR1eAsAAQT1AQAABAAAAADFlWk41P0ax80Y\n+                MgYz9j1rSrb\/2IlibJN9Xwcj+1ZE2creZF8qS5aMnawl+5KdcIhCE4mJqIg8YxCa\n+                03Ou5zo9T9d5f37Xdb+6v\/f39+7zAWIZ2Gih53Fo3D4j6BQYH8tAA8QygMAgEBIO\n+                MNJCsTg0yJ0aAgbRUAGwX0EQPpZmFYilWQZi2vHUYBAYDKVKC9d2CniEM\/95Bvsr\n+                B0VQMwPM\/2mitoJQs9IGeXtedb8OCHIyysoBCkhAVlYBkFO054LLAgoKABKpBABy\n+                SkhF+\/91ZPpbMfUlKogaFRUV6OfQ\/ByIF6DK3t5Qu3Rxlup8XcHalIwmxwRA4y+U\n+                bCzo7Kz4nPjA\/NrVh8Z1HzX9WjuHePv9fu+LpWGm+tuDkFlHqIt7Ang86pOfkC4A\n+                nPiL\/Elek36P5dX4rvcqeztNeV0cJc5lf8o90Ak6eCxsWeN2jB3i\/AKzXh\/wL1bH\n+                ImzjlaV1ihovORjPVjKTX5NLx5A6UvMT7BAb+hvphUnIGCMvaQzdHpqtBFhI8pNX\n+                pv7xinTE+C8CaPKOWflwy7mxPYHuEVDbejz45SUc2Js3J2Azp+aywq1tqwge2qZ8\n+                SN6UP9izQlKfV5BbJ9Q41SrxlUX8CQ4fdKxAIlhFqjspQjA+eVKmAr5K6pkIWEZE\n+                lpCoW7roaMyiX0Ro36JKexrJBuosLLmEmre45adGcYcwz9BFxbRPY8RcDsH5V+6z\n+                ffB5Jx9CYGtmiYiLNLHn5xE5FuhMdjpctzXcu7jcanK5NS5RYLuE1DOmKX+rxI95\n+                jUo5vPygujjKv73nzCX7UW5h9dF3rhlq7x6PEsKb4A5o8YyvrQyFCt1WdoMRo+lM\n+                ukUITut4i40wlhHNKRfleUelTbmuWd0W2Da9ulHfgdFYIL\/nTv0an1LeR+ExHzCR\n+                oFulMmsnezfKkOaleHnZ08g34hkuWzLn8RHFfEendTeZ6mKWLNbHdlk9+cyXcvbo\n+                nQ2TzqJWu89wxx05raZ+M30kns8XKao2kRL2fnfY\/hmkSO6TwLG+LuRSqq5hV+UM\n+                ENapT9C5j2d9w1Ikbzx93LCobObUmdX2kdeycugKbYdUEhIf8lUhJydyApQrU+N4\n+                DWPKkQIHyknWZ\/wF+tU8bG+l4t6CJ25af7rAmkjqmef6pP9Zu0Kq6VRCm+mc+Ek+\n+                XKx0diJfFxt6\/32J5YPHcwodLEHO9\/jbLZ+UMxyIEEOt+xUglE8b8opM9Px0jIW4\n+                LQkVRQ0ZINOSztlgV7siYWuduYb+7u75TbXwNOHIH6zfc5qmYSoznpjgaCSZscO\/\n+                HkGK1tyYvTc3qQdld2\/30Yubfr1U\/IR8o6q9VYcYmFAPVovY0iuf4lL1yI1QmKUH\n+                Rdr4To53GfLviQDWCbuQ8h2pjb0Lpc3o0vIqrTjn7myTmkrut0TU59HWY1H6asc4\n+                mvF5sra30x+OKUli9OPDV+rdPtOVv0hQ8PZB8ekY3Fn8FjrdvYluhKwyVb8\/Z3b8\n+                5NPtFjS\/ZiBhbPAotoyNV+ujjxuDvfk+lp1qDtMX3bHwMMZTijlQy8fQz0Hcc4Gr\n+                XkBbi30st2AlMMHPngBzwRT5LYvZLTY2UJPVGwch\/ABMBZcac3npOuKQOH3NCT4l\n+                nTW3Gupo\/iJj08tpzMFFzuYly\/5WHfwmlHD1zbfKGhk3P\/e3M8BVThKW8fGiinar\n+                NG9WVimmErsQhv2ug0\/lRAERN6pLSO+fSQysFFg8i5PPBTcUz0PvLMuEibSzOnu2\n+                WkFkJc4b6Y9XT6WkoWVSG4oQVLZ22lIXnUmWnLuuUGjf3Gn3OhT17irmq+GQ3qTv\n+                5o63bhQ4cHHqxzBrbvTuBgnccgex6WzX7V3Iq6Q5zDiMmfnQzx289qCiP4l+X\/RP\n+                buV1Rhc7vCe7uYaUaYegYD1wffXkxaiiQ8GTx+xN+WVHRjUafpRzugJnQTnJn90H\n+                UHeLbOm0muv1yKVgI2ObQlHvWqyewdnBnsprzydV9vpQqlxB6cf749eROahOYG0+\n+                YBvNcTwikSySKya9nf+ZWnO25ZqJmJBQPa0Cb1Gwg+wPqQ3Y6ssZVqXGTNySx1x0\n+                fPhzqlTQPehyS2WNElF12QQZS0P6yfmdn0IATv8PKv+T+3\/XBT4mF+D6rzGg1Mi\/\n+                6wPg+7WhQcJ\/0wEg9WsrjxT8+fE\/q4t\/M4zMrzgEKQwRZMqYq9kIEyPoV38V4Qi3\n+                k7b1wDhyyrn63jojfTth5CT9N\/BDYmkQfzH\/T5dA1liMxP0diEadWFaED\/ej3ohY\n+                +cokjZNU\/jclTnQs9yce8lx0lByAMqbvWJIPEk52FvsfpaWKLFAuTIXojNr7nCkq\n+                zrN+LWuKihpilnzDb2ab2VQzaQVaEYVFHH784ueYofYIoVntGN+7Y8pyefDZ7bU3\n+                gdUtHm9he0FaI87NcVl58NpNfr0v995JBIItD4IepPMM7OSny0NjtbgLlqIan5RR\n+                DgVOKflbVm6vXHbwD7zCFzRC8TTeT8HWJhvMb\/dTSmklyO7G1rxX+zQc+8zTJJTU\n+                l9QPxViwQ59Ft60WsqfuCDvs3uw6l+ouacEz4TWYqnFD7ayHjUDPhkuia5NT4r0c\n+                UslKDf3OZrCY3K2F2ifaa7pTnecbvrInYZ1907nwNKWFT\/t80TGZAqGlFTwMki5k\n+                ExmZgGhcSfLi8ugIKicnDOv7iEvruPyYikL7afGtoZ6AMmgElBdK7qsPPKecc3RJ\n+                aBDt4s2Htx1AtEZ\/SNKoOHwJ13oY2w1SY\/hQP\/yyrrpMSJqn0J6WT5iFE1+8\/jpK\n+                +SM9sCzdOMNf9bwmI9Lvsk9yhriDiI9w\/\/Rmo9ZNBl2M491p6iW3tshSWqPx7+1g\n+                3ItjQp39SfNrzD73feilBX8L7Vy3wLfxADEo9EicUuz8x4\/5rbDwhLmjMMKrsFuF\n+                s6YUQQr03KBJb5IG80NOELGa2KLDHpyZUZkpWNYIt+VtNHd91lt1rLgtXR0TAJos\n+                ITYfqUSNlHV7CbqzRRdX2rFPmM\/D2xlatJ7fZ0jnEkp9HcLirPhKcjOA6fRjSWKK\n+                syle\/2T0zviQI2+m0eneB5bfmyMI\/bKENVOUlmbw7gz3d2Y6QrrqBOGL5gz+Cmx\/\n+                5Qz6LUKPvSBcNRu3tMWQrvRHvXvzPaH9ivEIEwfizJ6ay9oWh6ls7eImJQbH6ObL\n+                hdbTNsTcWDZIOPomZ5eDWT+wO3E9KtgQbEu90VRL5d5vT0ysPEvbWT\/69IcRzwvd\n+                Gqf888Kw9LCqjDz5hgV+pq9\/eBqtSjIqOgf7mXVwllHPj69o9n9bUF9A7ttH4Mht\n+                +ILiyffyc4phpFN8npZWQfMBkT3D43qLtYzXJas63CqgrpL0p8K8Wn2ajSvpyHFr\n+                TKrohqSil6mOFWGJRQYEtxVVggEq1MWq6xVca8IIjim4p4l+ta+D425QNomZk8bY\n+                lNp27E2gUWZnzhKJ9VUjywjZb+QULurhNY4Q4ae6jtOwOhNVSNZGtpy68JVsb2WJ\n+                6jQxaYrsnAqYzSFuso1kvrcIvnVuXIJyexp2RM+SOGxmwXmVxVMiOsutdcbbwO4o\n+                RTktXSetM8F1QSNkWIcpXM6+rZZtTqvEnY8DYVkQuoy9SaEwYp9MTg65mkNnF2z9\n+                wfRajVybhi6kEafYCe2tRMl1ju4Jot3M7RevqCoDd8xOr6zFS3MP2FCLN331vKrl\n+                r1YR8v7R8Qp+M1sO3iuMmkU5AgN3kpQNauboa4y7olsApSEmTLCniN5FvApDz5\/c\n+                jytYX3kgkC36Mfh5bL5Hh8P2c\/bOml3lyDddiK7eOGux\/zf3\/w1QSwMECgAAAAAA\n+                eImqVlP8UWcCAAAAAgAAAAEAHAAxVVQJAAOUCFxklAhcZHV4CwABBPUBAAAEAAAA\n+                ADEKUEsBAh4DFAAAAAgAUpaqVu9jXOuNAAAAkAAAABQAGAAAAAAAAQAAAKSBAAAA\n+                AE1FVEEtSU5GL01BTklGRVNULk1GVVQFAAO8H1xkdXgLAAEE9QEAAAQAAAAAUEsB\n+                Ah4DFAAAAAgAUpaqVktg9JPyAAAAMgEAABIAGAAAAAAAAQAAAKSB2wAAAE1FVEEt\n+                SU5GL1NJR05FUi5TRlVUBQADvB9cZHV4CwABBPUBAAAEAAAAAFBLAQIeAxQAAAAI\n+                AFKWqlbb\/AXeEAsAABgMAAATABgAAAAAAAAAAACkgRkCAABNRVRBLUlORi9TSUdO\n+                RVIuRFNBVVQFAAO8H1xkdXgLAAEE9QEAAAQAAAAAUEsBAh4DCgAAAAAAeImqVlP8\n+                UWcCAAAAAgAAAAEAGAAAAAAAAQAAAKSBdg0AADFVVAUAA5QIXGR1eAsAAQT1AQAA\n+                BAAAAABQSwUGAAAAAAQABABSAQAAsw0AAAAA\n+                \"\"\";\n+        Files.write(Path.of(\"x.jar\"), Base64.getMimeDecoder().decode(jarFile));\n+\n+        SecurityTools.jarsigner(\"-verify x.jar -verbose -debug\")\n+                .shouldContain(\"jar verified.\")\n+                .shouldContain(\"Signature algorithm: HSS\/LMS,\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.writeString(Paths.get(\"my.security\"),\n+                \"jdk.jar.disabledAlgorithms=HSS\/LMS\");\n+\n+        SecurityTools.jarsigner(\n+                        \"-J-Djava.security.properties=my.security \" +\n+                        \"-verify x.jar -verbose -debug\")\n+                .shouldNotContain(\"jar verified.\")\n+                .shouldContain(\"WARNING: The jar will be treated as unsigned\")\n+                .shouldContain(\"Signature algorithm: HSS\/LMS (disabled),\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/VerifyHSSSignedJar.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/**\n+  * A no-op Java agent.\n+  *\/\n+public class JavaAgent {\n+    public static void agentmain(String args) {\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/JavaAgent.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+import java.util.List;\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.JarUtils;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8304438\n+ * @summary JVMTI.agent_load should obey EnableDynamicAgentLoading (by default)\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib\n+ * @build JavaAgent\n+ * @run main\/othervm TestJcmdNoAgentLoad\n+ *\/\n+\n+\/*\n+ * @test id=disabled\n+ * @bug 8304438\n+ * @summary JVMTI.agent_load should obey EnableDynamicAgentLoading (disabled)\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib\n+ * @build JavaAgent\n+ * @run main\/othervm -XX:-EnableDynamicAgentLoading TestJcmdNoAgentLoad\n+ *\/\n+\n+\/*\n+ * @test id=enabled\n+ * @bug 8304438\n+ * @summary JVMTI.agent_load should obey EnableDynamicAgentLoading (enabled)\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib\n+ * @build JavaAgent\n+ * @run main\/othervm -XX:+EnableDynamicAgentLoading TestJcmdNoAgentLoad\n+ *\/\n+\n+\n+public class TestJcmdNoAgentLoad {\n+    private static final String PTRN = \"Dynamic agent loading is not enabled\";\n+    private static boolean dynamicLoadingEnabled = true;\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    private static String javaAgent;\n+\n+    static {\n+        \/\/ get VM option EnableDynamicAgentLoading value\n+        HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        VMOption dynamicLoadingEnabledOpt = bean.getVMOption(\"EnableDynamicAgentLoading\");\n+        dynamicLoadingEnabled = dynamicLoadingEnabledOpt.getValue().equals(\"true\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        setup();\n+        testNoAgentLoad(new String[] { \"JVMTI.agent_load\", javaAgent });\n+    }\n+\n+    private static void setup() throws Exception {\n+        \/\/ create JAR file with Java agent\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(new Attributes.Name(\"Agent-Class\"), \"JavaAgent\");\n+        Path jarfile = Path.of(\"javaagent.jar\");\n+        Path classes = Path.of(TEST_CLASSES);\n+        JarUtils.createJarFile(jarfile, man, classes, Path.of(\"JavaAgent.class\"));\n+        javaAgent = jarfile.toString();\n+    }\n+\n+    private static void testNoAgentLoad(String... jcmdArgs) throws Exception {\n+        OutputAnalyzer output = JcmdBase.jcmd(jcmdArgs);\n+\n+        output.shouldHaveExitValue(0);\n+        if (dynamicLoadingEnabled) {\n+            output.shouldNotContain(PTRN);\n+        } else {\n+            output.shouldContain(PTRN);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdNoAgentLoad.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.OperatingSystem;\n@@ -201,1 +203,1 @@\n-        if (Platform.isWindows()) {\n+        if (OperatingSystem.isWindows()) {\n@@ -204,1 +206,1 @@\n-        } else if (Platform.isLinux()) {\n+        } else if (OperatingSystem.isLinux()) {\n@@ -207,1 +209,1 @@\n-        } else if (Platform.isMac()) {\n+        } else if (OperatingSystem.isMacOS()) {\n@@ -211,1 +213,1 @@\n-            throw Platform.throwUnknownPlatformError();\n+            throw new IllegalArgumentException(\"Unknown platform: \" + OperatingSystem.current());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk\/jpackage\/internal\/OverridableResourceTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -96,1 +97,1 @@\n-        if (Platform.isWindows()) {\n+        if (OperatingSystem.isWindows()) {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk\/jpackage\/internal\/ToolValidatorTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test\n+ * @summary test execution priority of main methods\n+ * @run main InstanceMainTest\n+ *\/\n+public class InstanceMainTest extends TestHelper {\n+\n+    private static final String[] SOURCES = new String[] {\n+            \/\/ static dominating with args\n+            \"\"\"\n+            class MainClass {\n+                static void main() {\n+                    throw new AssertionError();\n+                }\n+                static void main(String[] args) {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ static dominating instance\n+            \"\"\"\n+            class MainClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+                static void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ instance dominating with args\n+            \"\"\"\n+            class MainClass {\n+                void main() {\n+                    throw new AssertionError();\n+                }\n+                void main(String[] args) {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ instance no args\n+            \"\"\"\n+            class MainClass {\n+                void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class static dominating with args\n+            \"\"\"\n+            static void main() {\n+                throw new AssertionError();\n+            }\n+            static void main(String[] args) {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class static dominating instance\n+            \"\"\"\n+            void main(String[] args) {\n+                throw new AssertionError();\n+            }\n+            static void main() {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class instance dominating with args\n+            \"\"\"\n+            void main() {\n+                throw new AssertionError();\n+            }\n+            void main(String[] args) {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class instance main no args\n+            \"\"\"\n+            void main() {\n+            }\n+            \"\"\",\n+\n+            \/\/ instance main dominating super static\n+            \"\"\"\n+            class MainClass extends SuperClass {\n+                void main() {\n+                }\n+            }\n+            class SuperClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ super instance main with args dominating\n+            \"\"\"\n+            public class MainClass extends Super {\n+            }\n+\n+            class Super {\n+                public void main(String... args) {\n+                }\n+\n+                public void main() {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ ignore super instance main\n+            \"\"\"\n+            public class MainClass extends Super {\n+                public static void main(String... args) {\n+                }\n+            }\n+\n+            class Super {\n+                public static void main(String... args) {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ enum main\n+            \"\"\"\n+            enum MainClass {\n+                A;\n+\n+                public static void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ record main\n+            \"\"\"\n+            record MainClass() {\n+                 static void main() {\n+                     System.out.println(\"Done!\");\n+                 }\n+            }\n+            \"\"\",\n+            \/\/ interface main\n+            \"\"\"\n+            interface MainClass {\n+                 static void main() {\n+                     System.out.println(\"Done!\");\n+                 }\n+            }\n+            \"\"\"\n+    };\n+\n+    public static void main(String... args) throws Exception {\n+        for (String source : SOURCES) {\n+            Files.writeString(Path.of(\"MainClass.java\"), source);\n+            var version = System.getProperty(\"java.specification.version\");\n+            var tr = doExec(javaCmd, \"--enable-preview\", \"--source\", version, \"MainClass.java\");\n+            if (!tr.isOK()) {\n+                System.err.println(source);\n+                System.err.println(tr);\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8309150\n+ * @summary Need to escape \" inside attribute values\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestAttribute\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestAttribute extends JavadocTester {\n+\n+    public final ToolBox tb;\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestAttribute();\n+        tester.runTests();\n+    }\n+\n+    public TestAttribute() {\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void testQuote(Path base) throws IOException {\n+        var src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * First sentence.\n+                 * @spec http:\/\/example.com title with \"quotes\"\n+                 *\/\n+                public class C { private C() { } }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ Test some section markers and links to these markers\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <a href=\"http:\/\/example.com\"><span id=\"titlewith&quot;quotes&quot;\" \\\n+                    class=\"search-tag-result\">title with \"quotes\"<\/span><\/a>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAttribute\/TestAttribute.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8289332\n+ * @bug 8289332 8286470\n@@ -82,0 +82,4 @@\n+                         * <h2>  Multi-line\n+                         *       heading   with extra\n+                         *                 whitespace<\/h2>\n+                         *\n@@ -124,1 +128,27 @@\n-                    \"\"\");\n+                    \"\"\",\n+                \"\"\"\n+                    <h2 id=\"multi-line-heading-with-extra-whitespace-heading\">  Multi-line\n+                           heading   with extra\n+                                     whitespace<\/h2>\"\"\");\n+        checkOutput(\"tag-search-index.js\", true,\n+                \"\"\"\n+                    {\"l\":\"Duplicate Text\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#duplicate-text-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Duplicate Text\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#duplicate-text-heading1\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Embedded A-Tag with ID\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#fixed-id-2\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Embedded Code Tag\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#embedded-code-tag-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Embedded Link Tag\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#embedded-link-tag-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Extra (#*!. chars\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#extra-chars-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"First Header\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#first-header-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Header with ID\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#fixed-id-1\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Multi-line heading with extra whitespace\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html\\\n+                    #multi-line-heading-with-extra-whitespace-heading\"}\"\"\",\n+                \"\"\"\n+                    {\"l\":\"Other attributes\",\"h\":\"class p.C\",\"d\":\"Section\",\"u\":\"p\/C.html#other-attributes-heading\"}\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAutoHeaderId\/TestAutoHeaderId.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8304878\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestLatePackageDiscovery\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestLatePackageDiscovery extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        new TestLatePackageDiscovery().runTests();\n+    }\n+\n+    @Test\n+    public void testLatePackageDiscovery(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src.resolve(\"test.bar\"),\n+                \"module test.bar { exports bar; }\",\n+                \"package bar;\",\n+                \"package bar; class Base { public void m() { } }\",\n+                \"package bar; public class Bar extends Base { }\");\n+\n+        tb.writeJavaFiles(src.resolve(\"test.foo\"),\n+                \"module test.foo { exports foo; requires test.bar; }\",\n+                \"package foo;\",\n+                \"package foo; public class Foo extends bar.Bar { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"test.foo\",\n+                \"-nodeprecated\");\n+\n+        setAutomaticCheckNoStacktrace(true); \/\/ no exceptions!\n+        checkExit(Exit.OK);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLatePackageDiscovery\/TestLatePackageDiscovery.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8200337 8307377\n+ * @bug 8200337 8307377 8306578\n@@ -143,1 +143,1 @@\n-        checkExit(Exit.OK);\n+        checkExit(Exit.ERROR);\n@@ -145,1 +145,1 @@\n-                    warning: missing reference label\n+                    error: missing reference label\n@@ -150,1 +150,1 @@\n-                    Class1.java:5: warning: missing reference label\n+                    Class1.java:5: error: missing reference label\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeLinkAnchor\/TestSeeLinkAnchor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,2 @@\n-                            .replace(\"&amp;\", \"&\");\n+                            .replace(\"&amp;\", \"&\")\n+                            .replace(\"&quot;\", \"\\\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/HtmlParser.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,0 +513,20 @@\n+    public void assertCommandUserOutputContains(boolean after, String cmd, String... hasThese) {\n+        assertCommandCheckUserOutput(after, cmd, (s)\n+                -> assertTrue(Arrays.stream(hasThese)\n+                        .allMatch(has -> s.contains(has)),\n+                \"User output: \\'\" + s + \"' does not contain: \"\n+                        + Arrays.stream(hasThese)\n+                        .filter(has -> !s.contains(has))\n+                        .collect(Collectors.joining(\", \"))));\n+    }\n+\n+    public void assertCommandCheckUserOutput(boolean after, String cmd, Consumer<String> check) {\n+        if (!after) {\n+            assertCommand(false, cmd, null);\n+        } else {\n+            String got = getUserOutput();\n+            check.accept(got);\n+            assertCommand(true, cmd, null);\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-        test(new String[]{\"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n+        test(new String[]{\"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\", \"--startup\", \"TOOLING\"},\n@@ -76,1 +76,1 @@\n-                        \"System.out.println\", \"import java.util.concurrent\")\n+                        \"System.out.println\", \"import java.util.concurrent\", \"tools()\")\n","filename":"test\/langtools\/jdk\/jshell\/ToolLocalSimpleTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *      8239536 8247456 8246774 8238173 8292625\n+ *      8239536 8247456 8246774 8238173 8292625 8306560\n@@ -752,1 +752,1 @@\n-                          \"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n+                          \"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\", \"--startup\", \"TOOLING\"},\n@@ -754,1 +754,3 @@\n-                        \"\", \"\", null, \"3.14\", \"\")\n+                        \"\", \"\", null, \"3.14\", \"\"),\n+                (a) -> assertCommand(a, \"jar(\\\"--version\\\")\",\n+                        \"\", \"\", null, \"jar \" + System.getProperty(\"java.version\") + \"\\n\", \"\")\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306560\n+ * @summary Tests for snippets and methods defined in TOOLING.jsh\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ * @build KullaTesting TestingInputStream\n+ * @run testng ToolingTest\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class ToolingTest extends ReplToolTesting {\n+    @Test\n+    public void testListToolingSnippets() {\n+        test(\n+                a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+                a -> assertCommandOutputContains(a, \"\/list\",\n+                        \/\/ Tool methods\n+                        \"void jar(String... args)\",\n+                        \/\/ ...\n+                        \"void jpackage(String... args)\",\n+                        \/\/ Utility methods\n+                        \"void javap(Class<?> type) throws Exception\",\n+                        \"void run(String name, String... args)\",\n+                        \"void tools()\")\n+        );\n+    }\n+\n+    @Test\n+    public void testDisassembleJavaLangObjectClass() {\n+        test(\n+                a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+                a -> assertCommandUserOutputContains(a, \"javap(Object.class)\",\n+                        \"Classfile jrt:\/java.base\/java\/lang\/Object.class\",\n+                        \"SourceFile: \\\"Object.java\\\"\")\n+        );\n+    }\n+\n+    @Test\n+    public void testDisassembleNewRecordClass() {\n+        test(\n+                a -> assertCommand(a, \"record Point(int x, int y) {}\",\n+                        \"|  created record Point\"),\n+                a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+                a -> assertCommandUserOutputContains(a, \"javap(Point.class)\",\n+                        \"Classfile \", \/\/ Classfile \/...\/TOOLING-13366652659767559204.class\n+                        \"Point extends java.lang.Record\", \/\/ public final class REPL.$JShell$11$Point extends java.lang.Record\n+                        \"SourceFile: \\\"$JShell$\" \/\/ SourceFile: \"$JShell$11.java\"\n+                )\n+        );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolingTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8004832 8247957\n+ * @bug 8004832 8247957 8292157\n@@ -35,0 +35,1 @@\n+     * <a> <p> <\/a>\n","filename":"test\/langtools\/tools\/doclint\/HtmlTagsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -22,1 +22,7 @@\n-HtmlTagsTest.java:39: error: block element not allowed within @link: p\n+HtmlTagsTest.java:35: warning: block element <p> not allowed within element <a> with default style\n+     * <a> <p> <\/a>\n+           ^\n+HtmlTagsTest.java:35: warning: empty <p> tag\n+     * <a> <p> <\/a>\n+           ^\n+HtmlTagsTest.java:40: warning: block element <p> not allowed within @link with default style\n@@ -25,1 +31,1 @@\n-HtmlTagsTest.java:40: error: block element not allowed within @link: p\n+HtmlTagsTest.java:41: warning: block element <p> not allowed within @link with default style\n@@ -28,1 +34,1 @@\n-HtmlTagsTest.java:45: error: invalid end tag: <\/img>\n+HtmlTagsTest.java:46: error: invalid end tag: <\/img>\n@@ -31,1 +37,1 @@\n-HtmlTagsTest.java:50: error: end tag missing: <\/b>\n+HtmlTagsTest.java:51: error: end tag missing: <\/b>\n@@ -34,1 +40,1 @@\n-HtmlTagsTest.java:55: error: unexpected end tag: <\/b>\n+HtmlTagsTest.java:56: error: unexpected end tag: <\/b>\n@@ -37,1 +43,1 @@\n-HtmlTagsTest.java:55: warning: empty <i> tag\n+HtmlTagsTest.java:56: warning: empty <i> tag\n@@ -40,1 +46,1 @@\n-HtmlTagsTest.java:60: error: text not allowed in <ul> element\n+HtmlTagsTest.java:61: error: text not allowed in <ul> element\n@@ -43,1 +49,1 @@\n-HtmlTagsTest.java:65: error: tag not allowed here: <b>\n+HtmlTagsTest.java:66: error: tag not allowed here: <b>\n@@ -46,1 +52,1 @@\n-HtmlTagsTest.java:70: error: text not allowed in <ul> element\n+HtmlTagsTest.java:71: error: text not allowed in <ul> element\n@@ -49,1 +55,1 @@\n-HtmlTagsTest.java:75: error: text not allowed in <ul> element\n+HtmlTagsTest.java:76: error: text not allowed in <ul> element\n@@ -52,2 +58,2 @@\n-15 errors\n-2 warnings\n+13 errors\n+6 warnings\n","filename":"test\/langtools\/tools\/doclint\/HtmlTagsTest.out","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.enum.label.must.be.enum.constant\n+\n+class EnumLabelMustBeEnumConstant {\n+    enum E { A };\n+\n+    void m(E e) {\n+        switch (e) {\n+            case EA -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    static final E EA;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumLabelMustBeEnumConstant.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.pattern.or.enum.req\n+\n+class PatternOrEnumReq {\n+    enum E { A };\n+\n+    void m(Object o) {\n+        switch (o) {\n+            case EA -> {}\n+            default -> {}\n+        }\n+    }\n+\n+    static final E EA;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternOrEnumReq.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.bad.file.name\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassBad-Filename.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+package unnamed.classes;\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public void ordinaryMethod() {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.use.of.underscore.not.allowed.with.brackets\n+\/\/ key: compiler.misc.feature.unnamed.variables\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class UseOfUnderscoreNotAllowedWithBrackets {\n+    void test() {\n+        int[] _[] = new int[][]{new int[]{1}, new int[]{2}};\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UseOfUnderscoreNotAllowedWithBrackets.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+IdentifierTest.java:158:16: compiler.err.use.of.underscore.not.allowed.with.brackets\n@@ -39,1 +40,1 @@\n-36 errors\n\\ No newline at end of file\n+37 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lambda\/IdentifierTest21.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -556,1 +556,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotPublic\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8133884 8162711 8133896 8172158 8172262 8173636 8175119 8189747 8236842 8254023 8263432\n+ * @bug 8133884 8162711 8133896 8172158 8172262 8173636 8175119 8189747 8236842 8254023 8263432 8305225\n@@ -2136,0 +2136,88 @@\n+    @Test\n+    public void testCreateProvidesWithAP(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path m1 = src.resolve(\"m\");\n+\n+        tb.writeJavaFiles(m1,\n+                          \"\"\"\n+                          module m {\n+                              provides api1.Api with test.Test;\n+                              uses api1.Api;\n+                              uses api2.Api;\n+                          }\n+                          \"\"\");\n+\n+        Path classes = base.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        List<String> expectedErrors = List.of(\n+                \"module-info.java:2:18: compiler.err.doesnt.exist: api1\",\n+                \"module-info.java:2:32: compiler.err.doesnt.exist: test\",\n+                \"module-info.java:3:14: compiler.err.doesnt.exist: api1\",\n+                \"module-info.java:4:14: compiler.err.doesnt.exist: api2\",\n+                \"4 errors\");\n+        List<String> actualErrors = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m1))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        tb.checkEqual(expectedErrors, actualErrors);\n+\n+        new JavacTask(tb)\n+                .options(\"-processor\", CreateProvidesWithAP.class.getName())\n+                .outdir(classes)\n+                .files(findJavaFiles(m1))\n+                .run()\n+                .writeAll();\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class CreateProvidesWithAP extends AbstractProcessor {\n+\n+        int round;\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            processingEnv.getElementUtils().getModuleElement(\"m\").getDirectives();\n+            if (round++ == 0) {\n+                try (Writer w = processingEnv.getFiler().createSourceFile(\"test.Test\").openWriter()) {\n+                    w.append(\"\"\"\n+                             package test;\n+                             public class Test implements api1.Api {\n+                             }\n+                             \"\"\");\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+                try (Writer w = processingEnv.getFiler().createSourceFile(\"api1.Api\").openWriter()) {\n+                    w.append(\"\"\"\n+                             package api1;\n+                             public interface Api {\n+                             }\n+                             \"\"\");\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+                try (Writer w = processingEnv.getFiler().createSourceFile(\"api2.Api\").openWriter()) {\n+                    w.append(\"\"\"\n+                             package api2;\n+                             public interface Api {\n+                             }\n+                             \"\"\");\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationProcessing.java","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-PatternErrorRecovery.java:11:18: compiler.err.const.expr.req\n+PatternErrorRecovery.java:11:18: compiler.err.pattern.expected\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternErrorRecovery-old.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8309054\n+ * @summary Parsing of erroneous patterns succeeds\n+ * @enablePreview\n+ * @compile\/fail\/ref=T8309054.out -XDrawDiagnostics --should-stop=at=FLOW T8309054.java\n+ *\/\n+\n+public class T8309054  {\n+    public void test(Object obj) {\n+        boolean t1 = switch (obj) {\n+            case Long a[] -> true;\n+            default -> false;\n+        };\n+        boolean t2 = switch (obj) {\n+            case Double a[][][][] -> true;\n+            default -> false;\n+        };\n+        if (obj instanceof Float a[][]) {\n+        }\n+        if (obj instanceof Integer a = Integer.valueOf(0)) {\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8309054.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+T8309054.java:12:24: compiler.err.expected2: :, ->\n+T8309054.java:16:26: compiler.err.expected2: :, ->\n+T8309054.java:19:35: compiler.err.expected: ')'\n+T8309054.java:13:13: compiler.err.switch.mixing.case.types\n+T8309054.java:17:13: compiler.err.switch.mixing.case.types\n+T8309054.java:21:17: compiler.err.unexpected.type: kindname.variable, kindname.value\n+6 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8309054.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8304246\n+ * @bug 8304246 8309093\n@@ -109,0 +109,5 @@\n+    void testUnderscoreWithBrackets() {\n+        int _[] = new int[]{1};\n+        for (int _[] : new int[][]{new int[]{1}, new int[]{2}}) { }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+UnnamedErrors.java:110:13: compiler.err.use.of.underscore.not.allowed.with.brackets\n+UnnamedErrors.java:111:18: compiler.err.use.of.underscore.not.allowed.with.brackets\n@@ -35,1 +37,1 @@\n-32 errors\n\\ No newline at end of file\n+34 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/UnnamedErrors.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * A class with no-name.\n+ *\/\n+\n+void main() {\n+    printMessage();\n+}\n+\n+private static String horseName = null;\n+\n+private static void printMessage() {\n+    if (horseName == null) {\n+        System.out.print(\"A horse has no name.\");\n+    } else\n+        System.out.print(\"A horse's name is \" + horseName);\n+}\n+\n+\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/Anonymous.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306112\n+ * @summary Test basic processing of unnamed classes.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor TestUnnamedClass\n+ * @compile -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} Anonymous.java\n+ *\/\n+\n+\n+import java.lang.annotation.*;\n+import java.io.Writer;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import static javax.lang.model.util.ElementFilter.*;\n+import javax.tools.JavaFileObject;\n+\n+\/*\n+ * Ideally, this processor would test both the compile-time\n+ * representation of an unnamed class starting from a source file as\n+ * well as the representation starting from a class file. Currently,\n+ * only the source file based view will be tested.\n+ *\n+ * For future work to test the class file based view, an additional jtreg directive like the following could\n+ * be used:\n+ *\n+ * @compile\/process -processor TestUnnamedClass -proc:only Anonymous Nameless\n+ *\/\n+@SuppressWarnings(\"preview\")\n+public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n+\n+    private static int round  = 0;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (round == 0) { \/\/ Check file from comamnd line\n+            checkRoots(roundEnv);\n+            generateUnnamed();\n+        }\n+\n+        if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n+            checkRoots(roundEnv);\n+        }\n+\n+        round++;\n+        return true;\n+    }\n+\n+    private void checkRoots(RoundEnvironment roundEnv) {\n+        int checks = 0;\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n+            System.out.println(\"Checking \" + type.getQualifiedName());\n+            checks++;\n+            checkUnnamedClassProperties(type);\n+        }\n+        if (checks == 0) {\n+            messager.printError(\"No checking done of any candidate unnamed classes.\");\n+        }\n+    }\n+\n+    private void generateUnnamed() {\n+        try {\n+            String unnamedSource = \"\"\"\n+            void main() {\n+                System.out.println(\"Nameless, but not voiceless.\");\n+            }\n+            \"\"\";\n+\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n+            try(Writer w = outputFile.openWriter()) {\n+                w.append(unnamedSource);\n+            }\n+        } catch (java.io.IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    \/*\n+     * From JEP 445 JLS changes:\n+     *\n+     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n+     * properties:\n+     * It is always a top level class.\n+     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n+     * It is never abstract (8.1.1.1).\n+     * It is always final (8.1.1.2).\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\n+     * Its direct superclass type is always Object (8.1.4).\n+     * It never has any direct superinterface types (8.1.5).\n+     *\n+     * The body of the class contains every ClassMemberDeclaration\n+     * from the unnamed class compilation unit. It is not possible for\n+     * an unnamed class compilation unit to declare an instance\n+     * initializer, static initializer, or constructor.\n+     *\n+     * It has an implicitly declared default constructor (8.8.9).\n+     * All members of this class, including any implicitly declared\n+     * members, are subject to the usual rules for member declarations\n+     * in a class.\n+     *\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n+     *\/\n+    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n+        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n+            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getSimpleName().isEmpty()) {\n+            messager.printError(\"Unnamed class does have an empty simple name.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getQualifiedName().isEmpty()) {\n+            messager.printError(\"Unnamed class does _not_ have an empty qualified name.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n+            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n+        }\n+\n+        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n+            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n+            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n+            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n+        }\n+\n+        if ( !types.isSameType(unnamedClass.getSuperclass(),\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n+            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getInterfaces().isEmpty()) {\n+            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n+        }\n+\n+        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n+        if (ctors.size() != 1 ) {\n+            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n+        }\n+\n+        ExecutableElement ctor = ctors.getFirst();\n+        if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n+            messager.printError(\"Constructor was not marked as mandated\", ctor);\n+        }\n+\n+        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\n+        boolean mainFound = false;\n+        Name mainName = elements.getName(\"main\");\n+        for (var method : methods) {\n+            if (method.getSimpleName().equals(mainName)) {\n+                mainFound = true;\n+                break;\n+            }\n+        }\n+\n+        if (!mainFound) {\n+            messager.printError(\"No main mehtod found\", unnamedClass);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8300543\n+ * @bug 8300543 8309336\n@@ -54,0 +54,18 @@\n+    int testPatternMatchingSwitch4(E1 e) {\n+        return switch(e) {\n+            case E1A -> 1;\n+            case (E1) null -> 1;\n+            case E1 -> 1;\n+            default -> {}\n+        };\n+    }\n+\n+    int testPatternMatchingSwitch5(Object e) {\n+        return switch(e) {\n+            case E1A -> 1;\n+            case (E1) null -> 1;\n+            case E1 -> 1;\n+            default -> {}\n+        };\n+    }\n+\n@@ -58,0 +76,1 @@\n+    static final E1 E1A = null;\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -5,1 +5,7 @@\n-4 errors\n+EnumSwitchQualifiedErrors.java:56:18: compiler.err.enum.label.must.be.enum.constant\n+EnumSwitchQualifiedErrors.java:57:18: compiler.err.enum.label.must.be.enum.constant\n+EnumSwitchQualifiedErrors.java:58:18: compiler.err.enum.label.must.be.enum.constant\n+EnumSwitchQualifiedErrors.java:65:18: compiler.err.pattern.or.enum.req\n+EnumSwitchQualifiedErrors.java:66:18: compiler.err.pattern.or.enum.req\n+EnumSwitchQualifiedErrors.java:67:18: compiler.err.pattern.expected\n+10 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.out","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,8 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=UnnamedClassRecovery.out -XDrawDiagnostics --enable-preview --source ${jdk.version} UnnamedClassRecovery.java\n+ *\/\n+public void main() {\n+    \/\/the following is intentionally missing a semicolon:\n+    System.err.println(\"Hello!\")\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+UnnamedClassRecovery.java:7:33: compiler.err.expected: ';'\n+- compiler.note.preview.filename: UnnamedClassRecovery.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary enums: ensure unnamed class is visible to java.lang.Enum<unnamed_class>\n+ * @enablePreview\n+ * @compile NestedEnum.java\n+ *\/\n+\n+enum Foo {A, B}\n+void main() {\n+    System.out.println(Foo.A);\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/NestedEnum.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        TWENTY_ONE(false,\"65.0\", \"21\", Versions::checksrc20);\n+        TWENTY_ONE(false,\"65.0\", \"21\", Versions::checksrc21);\n@@ -251,1 +251,3 @@\n-        expectedFail(args, List.of(\"New10.java\"));\n+        expectedFail(args, List.of(\"New10.java\", \"New11.java\", \"New14.java\", \"New15.java\",\n+                                   \"New16.java\", \"New17.java\", \"New21.java\"));\n+\n@@ -257,1 +259,2 @@\n-        expectedFail(args, List.of(\"New10.java\"));\n+        expectedFail(args, List.of(\"New10.java\", \"New11.java\", \"New14.java\", \"New15.java\",\n+                                   \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -263,1 +266,2 @@\n-        expectedFail(args, List.of(\"New11.java\"));\n+        expectedFail(args, List.of(\"New11.java\", \"New14.java\", \"New15.java\",\n+                                   \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -269,1 +273,1 @@\n-        expectedFail(args, List.of(\"New14.java\"));\n+        expectedFail(args, List.of(\"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -275,1 +279,1 @@\n-        expectedFail(args, List.of(\"New14.java\"));\n+        expectedFail(args, List.of(\"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -281,1 +285,1 @@\n-        expectedFail(args, List.of(\"New14.java\"));\n+        expectedFail(args, List.of(\"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -288,1 +292,1 @@\n-        expectedFail(args, List.of(\"New15.java\"));\n+        expectedFail(args, List.of(\"New15.java\", \"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -295,1 +299,1 @@\n-        expectedFail(args, List.of(\"New16.java\"));\n+       expectedFail(args, List.of(\"New16.java\", \"New17.java\", \"New21.java\"));\n@@ -302,1 +306,1 @@\n-        expectedFail(args, List.of(\"New17.java\"));\n+       expectedFail(args, List.of(\"New17.java\", \"New21.java\"));\n@@ -309,1 +313,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+       expectedFail(args, List.of(\"New21.java\"));\n@@ -316,1 +320,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+       expectedFail(args, List.of(\"New21.java\"));\n@@ -323,1 +327,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+       expectedFail(args, List.of(\"New21.java\"));\n@@ -330,0 +334,8 @@\n+       expectedFail(args, List.of(\"New21.java\"));\n+    }\n+\n+   protected void checksrc21(List<String> args) {\n+       printargs(\"checksrc21\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\",\n+                                  \"New21.java\"));\n@@ -387,1 +399,0 @@\n-\n@@ -572,0 +583,18 @@\n+\n+        \/*\n+         * Create a file with a new feature in 21, not in 20 : pattern matching for switch\n+         *\/\n+        writeSourceFile(\"New21.java\",\n+            \"\"\"\n+            public class New21 {\n+                public static void main(String... args) {\n+                    Object o = new Object(){};\n+\n+                    System.out.println(switch (o) {\n+                                       case Integer i -> String.format(\"%d\", i);\n+                                       default        -> o.toString();\n+                                       });\n+                }\n+            }\n+            \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -674,2 +674,0 @@\n-        long started = System.currentTimeMillis();\n-\n@@ -677,0 +675,5 @@\n+        return executeAndLog(pb.start(), logName);\n+    }\n+\n+    public static OutputAnalyzer executeAndLog(Process process, String logName) throws Exception {\n+        long started = System.currentTimeMillis();\n@@ -678,1 +681,1 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = new OutputAnalyzer(process);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.FileVisitOption;\n@@ -38,0 +39,1 @@\n+import java.util.EnumSet;\n@@ -166,1 +168,1 @@\n-        Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));\n+        Files.walkFileTree(jdkSrcDir, EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE, new CopyFileVisitor(jdkSrcDir, jdkDstDir));\n@@ -202,3 +204,1 @@\n-        List<String> cmd = new ArrayList<>();\n-\n-        cmd.add(Container.ENGINE_COMMAND);\n+        List<String> cmd = buildContainerCommand();\n@@ -227,0 +227,6 @@\n+    public static List<String> buildContainerCommand() {\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        return cmd;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+    public static final String ResidentSetSize = PREFIX + \"ResidentSetSize\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -882,0 +882,2 @@\n+    public static final String OLD_MAIN_THREAD_NAME = \"old-m-a-i-n\";\n+\n@@ -897,1 +899,1 @@\n-            Thread vthread = startVirtualThread(() -> {\n+            Thread vthread = Thread.ofVirtual().unstarted(() -> {\n@@ -906,0 +908,3 @@\n+            Thread.currentThread().setName(OLD_MAIN_THREAD_NAME);\n+            vthread.setName(\"main\");\n+            vthread.start();\n@@ -942,13 +947,0 @@\n-\n-    static Thread startVirtualThread(Runnable task) {\n-        try {\n-            Object builder = Thread.class.getMethod(\"ofVirtual\").invoke(null);\n-            Class<?> clazz = Class.forName(\"java.lang.Thread$Builder\");\n-            Method start = clazz.getMethod(\"start\", Runnable.class);\n-            return (Thread) start.invoke(builder, task);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -179,1 +179,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n@@ -27,1 +27,1 @@\n-import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.Callable;\n@@ -29,0 +29,1 @@\n+import java.util.function.Supplier;\n@@ -32,1 +33,1 @@\n-import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+import static org.openjdk.bench.java.lang.ScopedValuesData.*;\n@@ -43,1 +44,1 @@\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopedValuesExecutorService\",\n@@ -46,1 +47,0 @@\n-                        \"--add-modules=jdk.incubator.concurrent\",\n@@ -164,1 +164,0 @@\n-\n@@ -168,1 +167,10 @@\n-        return HOLD_42.call(this::getClass);\n+        return HOLD_42.call(aCallable);\n+    }\n+    private static final Callable<Class<?>> aCallable = () -> ScopedValues.class;\n+\n+    \/\/ Same, but make sure that Carrier.get(Supplier) is no slower\n+    \/\/ than Carrier.call(Callable).\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bindViaGet_ScopedValue() {\n+        return HOLD_42.get(aSupplier);\n@@ -170,0 +178,1 @@\n+    private static final Supplier<Class<?>> aSupplier = () -> ScopedValues.class;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":16,"deletions":7,"binary":false,"changes":23,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n@@ -26,1 +26,0 @@\n-import jdk.incubator.concurrent.ScopedValue;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,1 @@\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesExecutorService.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","status":"renamed"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of conversion from and to method type descriptor symbols with\n+ * descriptor strings and class descriptor symbols\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class MethodTypeDescFactories {\n+\n+    private static final ClassDesc DUMMY_CD = ClassDesc.of(\"Dummy_invalid\");\n+\n+    @Param({\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/String;)I\",\n+            \"()V\",\n+            \"([IJLjava\/lang\/String;Z)Ljava\/util\/List;\",\n+            \"()[Ljava\/lang\/String;\"\n+    })\n+    public String descString;\n+    public MethodTypeDesc desc;\n+    public ClassDesc ret;\n+    public ClassDesc[] args;\n+    public List<ClassDesc> argsList;\n+\n+    @Setup\n+    public void setup() {\n+        desc = MethodTypeDesc.ofDescriptor(descString);\n+        ret = desc.returnType();\n+        args = desc.parameterArray();\n+        argsList = desc.parameterList();\n+    }\n+\n+    @Benchmark\n+    public String descriptorString(Blackhole blackhole) {\n+        \/\/ swaps return types with dummy classdesc;\n+        \/\/ this shares parameter arrays and avoids revalidation\n+        \/\/ while it drops the descriptor string cache\n+        var mtd = desc.changeReturnType(DUMMY_CD);\n+        blackhole.consume(mtd);\n+        mtd = mtd.changeReturnType(desc.returnType());\n+        blackhole.consume(mtd);\n+\n+        return mtd.descriptorString();\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofDescriptor() {\n+        return MethodTypeDesc.ofDescriptor(descString);\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofArray() {\n+        return MethodTypeDesc.of(ret, args);\n+    }\n+\n+    @Benchmark\n+    public MethodTypeDesc ofList() {\n+        return MethodTypeDesc.of(ret, argsList);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,1827 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.IOException;\n+import java.util.HexFormat;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.Security;\n+import java.security.Provider;\n+import java.security.KeyFactory;\n+import java.security.Signature;\n+import java.util.concurrent.TimeUnit;\n+\n+import sun.security.util.RawKeySpec;\n+\n+\/**\n+ * Benchmark measuring HSS\/LMS\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+\n+\/\/ Tests 1-2 are from RFC 8554, Appendix F.\n+\n+\/\/ Tests 3-10 were generated with parameter sets mentioned in\n+\/\/ RFC 8554 section 6.4; two with W=8 and six with W=4.\n+\n+public class HSS {\n+    Provider p;\n+    static byte[] pk;\n+    static byte[] msg;\n+    static byte[] sig;\n+    static Signature v;\n+\n+    @Param({\"noop\"})\n+    private String test;\n+\n+    static byte[] decode(String s) {\n+        return HexFormat.of().parseHex(s\n+                        .replaceAll(\"\/\/.*\", \"\")\n+                        .replaceAll(\"\\\\s\", \"\"));\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        p = Security.getProvider(\"SUN\");\n+        if (p == null) {\n+            throw new Exception (\"Can't load \\\"Sun\\\" provider\");\n+        }\n+    }\n+\n+    public Signature getVerifier(byte[] pk) throws Exception {\n+        var kf = KeyFactory.getInstance(\"HSS\/LMS\", Security.getProvider(\"SUN\"));\n+        var pk1 = kf.generatePublic(new RawKeySpec(pk));\n+\n+        var vv = Signature.getInstance(\"HSS\/LMS\");\n+        vv.initVerify(pk1);\n+        return vv;\n+    }\n+\n+    @Benchmark\n+    public void verify() throws Exception {\n+        if (v == null) {\n+            return;\n+        }\n+        v.update(msg);\n+        if (!v.verify(sig)) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ RFC 8554 Test Case 1\n+    public static class test01 extends HSS {\n+\n+        @Param({\"RFC 8554 1\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000005\n+                00000004\n+                61a5d57d37f5e46bfb7520806b07a1b850650e3b31fe4a773ea29a07f09cf2ea\n+                30e579f0df58ef8e298da0434cb2b878\"\"\");\n+            msg = decode(\"\"\"\n+                54686520706f77657273206e6f742064656c65676174656420746f2074686520\n+                556e69746564205374617465732062792074686520436f6e737469747574696f\n+                6e2c206e6f722070726f6869626974656420627920697420746f207468652053\n+                74617465732c2061726520726573657276656420746f20746865205374617465\n+                7320726573706563746976656c792c206f7220746f207468652070656f706c65\n+                2e0a\"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000005\n+                00000004\n+                d32b56671d7eb98833c49b433c272586bc4a1c8a8970528ffa04b966f9426eb9\n+                965a25bfd37f196b9073f3d4a232feb69128ec45146f86292f9dff9610a7bf95\n+                a64c7f60f6261a62043f86c70324b7707f5b4a8a6e19c114c7be866d488778a0\n+                e05fd5c6509a6e61d559cf1a77a970de927d60c70d3de31a7fa0100994e162a2\n+                582e8ff1b10cd99d4e8e413ef469559f7d7ed12c838342f9b9c96b83a4943d16\n+                81d84b15357ff48ca579f19f5e71f18466f2bbef4bf660c2518eb20de2f66e3b\n+                14784269d7d876f5d35d3fbfc7039a462c716bb9f6891a7f41ad133e9e1f6d95\n+                60b960e7777c52f060492f2d7c660e1471e07e72655562035abc9a701b473ecb\n+                c3943c6b9c4f2405a3cb8bf8a691ca51d3f6ad2f428bab6f3a30f55dd9625563\n+                f0a75ee390e385e3ae0b906961ecf41ae073a0590c2eb6204f44831c26dd768c\n+                35b167b28ce8dc988a3748255230cef99ebf14e730632f27414489808afab1d1\n+                e783ed04516de012498682212b07810579b250365941bcc98142da13609e9768\n+                aaf65de7620dabec29eb82a17fde35af15ad238c73f81bdb8dec2fc0e7f93270\n+                1099762b37f43c4a3c20010a3d72e2f606be108d310e639f09ce7286800d9ef8\n+                a1a40281cc5a7ea98d2adc7c7400c2fe5a101552df4e3cccfd0cbf2ddf5dc677\n+                9cbbc68fee0c3efe4ec22b83a2caa3e48e0809a0a750b73ccdcf3c79e6580c15\n+                4f8a58f7f24335eec5c5eb5e0cf01dcf4439424095fceb077f66ded5bec73b27\n+                c5b9f64a2a9af2f07c05e99e5cf80f00252e39db32f6c19674f190c9fbc506d8\n+                26857713afd2ca6bb85cd8c107347552f30575a5417816ab4db3f603f2df56fb\n+                c413e7d0acd8bdd81352b2471fc1bc4f1ef296fea1220403466b1afe78b94f7e\n+                cf7cc62fb92be14f18c2192384ebceaf8801afdf947f698ce9c6ceb696ed70e9\n+                e87b0144417e8d7baf25eb5f70f09f016fc925b4db048ab8d8cb2a661ce3b57a\n+                da67571f5dd546fc22cb1f97e0ebd1a65926b1234fd04f171cf469c76b884cf3\n+                115cce6f792cc84e36da58960c5f1d760f32c12faef477e94c92eb75625b6a37\n+                1efc72d60ca5e908b3a7dd69fef0249150e3eebdfed39cbdc3ce9704882a2072\n+                c75e13527b7a581a556168783dc1e97545e31865ddc46b3c957835da252bb732\n+                8d3ee2062445dfb85ef8c35f8e1f3371af34023cef626e0af1e0bc017351aae2\n+                ab8f5c612ead0b729a1d059d02bfe18efa971b7300e882360a93b025ff97e9e0\n+                eec0f3f3f13039a17f88b0cf808f488431606cb13f9241f40f44e537d302c64a\n+                4f1f4ab949b9feefadcb71ab50ef27d6d6ca8510f150c85fb525bf25703df720\n+                9b6066f09c37280d59128d2f0f637c7d7d7fad4ed1c1ea04e628d221e3d8db77\n+                b7c878c9411cafc5071a34a00f4cf07738912753dfce48f07576f0d4f94f42c6\n+                d76f7ce973e9367095ba7e9a3649b7f461d9f9ac1332a4d1044c96aefee67676\n+                401b64457c54d65fef6500c59cdfb69af7b6dddfcb0f086278dd8ad0686078df\n+                b0f3f79cd893d314168648499898fbc0ced5f95b74e8ff14d735cdea968bee74\n+                00000005\n+                d8b8112f9200a5e50c4a262165bd342cd800b8496810bc716277435ac376728d\n+                129ac6eda839a6f357b5a04387c5ce97382a78f2a4372917eefcbf93f63bb591\n+                12f5dbe400bd49e4501e859f885bf0736e90a509b30a26bfac8c17b5991c157e\n+                b5971115aa39efd8d564a6b90282c3168af2d30ef89d51bf14654510a12b8a14\n+                4cca1848cf7da59cc2b3d9d0692dd2a20ba3863480e25b1b85ee860c62bf5136\n+                00000005\n+                00000004\n+                d2f14ff6346af964569f7d6cb880a1b66c5004917da6eafe4d9ef6c6407b3db0\n+                e5485b122d9ebe15cda93cfec582d7ab\n+                0000000a\n+                00000004\n+                0703c491e7558b35011ece3592eaa5da4d918786771233e8353bc4f62323185c\n+                95cae05b899e35dffd717054706209988ebfdf6e37960bb5c38d7657e8bffeef\n+                9bc042da4b4525650485c66d0ce19b317587c6ba4bffcc428e25d08931e72dfb\n+                6a120c5612344258b85efdb7db1db9e1865a73caf96557eb39ed3e3f426933ac\n+                9eeddb03a1d2374af7bf77185577456237f9de2d60113c23f846df26fa942008\n+                a698994c0827d90e86d43e0df7f4bfcdb09b86a373b98288b7094ad81a0185ac\n+                100e4f2c5fc38c003c1ab6fea479eb2f5ebe48f584d7159b8ada03586e65ad9c\n+                969f6aecbfe44cf356888a7b15a3ff074f771760b26f9c04884ee1faa329fbf4\n+                e61af23aee7fa5d4d9a5dfcf43c4c26ce8aea2ce8a2990d7ba7b57108b47dabf\n+                beadb2b25b3cacc1ac0cef346cbb90fb044beee4fac2603a442bdf7e507243b7\n+                319c9944b1586e899d431c7f91bcccc8690dbf59b28386b2315f3d36ef2eaa3c\n+                f30b2b51f48b71b003dfb08249484201043f65f5a3ef6bbd61ddfee81aca9ce6\n+                0081262a00000480dcbc9a3da6fbef5c1c0a55e48a0e729f9184fcb1407c3152\n+                9db268f6fe50032a363c9801306837fafabdf957fd97eafc80dbd165e435d0e2\n+                dfd836a28b354023924b6fb7e48bc0b3ed95eea64c2d402f4d734c8dc26f3ac5\n+                91825daef01eae3c38e3328d00a77dc657034f287ccb0f0e1c9a7cbdc828f627\n+                205e4737b84b58376551d44c12c3c215c812a0970789c83de51d6ad787271963\n+                327f0a5fbb6b5907dec02c9a90934af5a1c63b72c82653605d1dcce51596b3c2\n+                b45696689f2eb382007497557692caac4d57b5de9f5569bc2ad0137fd47fb47e\n+                664fcb6db4971f5b3e07aceda9ac130e9f38182de994cff192ec0e82fd6d4cb7\n+                f3fe00812589b7a7ce515440456433016b84a59bec6619a1c6c0b37dd1450ed4\n+                f2d8b584410ceda8025f5d2d8dd0d2176fc1cf2cc06fa8c82bed4d944e71339e\n+                ce780fd025bd41ec34ebff9d4270a3224e019fcb444474d482fd2dbe75efb203\n+                89cc10cd600abb54c47ede93e08c114edb04117d714dc1d525e11bed8756192f\n+                929d15462b939ff3f52f2252da2ed64d8fae88818b1efa2c7b08c8794fb1b214\n+                aa233db3162833141ea4383f1a6f120be1db82ce3630b3429114463157a64e91\n+                234d475e2f79cbf05e4db6a9407d72c6bff7d1198b5c4d6aad2831db61274993\n+                715a0182c7dc8089e32c8531deed4f7431c07c02195eba2ef91efb5613c37af7\n+                ae0c066babc69369700e1dd26eddc0d216c781d56e4ce47e3303fa73007ff7b9\n+                49ef23be2aa4dbf25206fe45c20dd888395b2526391a724996a44156beac8082\n+                12858792bf8e74cba49dee5e8812e019da87454bff9e847ed83db07af3137430\n+                82f880a278f682c2bd0ad6887cb59f652e155987d61bbf6a88d36ee93b6072e6\n+                656d9ccbaae3d655852e38deb3a2dcf8058dc9fb6f2ab3d3b3539eb77b248a66\n+                1091d05eb6e2f297774fe6053598457cc61908318de4b826f0fc86d4bb117d33\n+                e865aa805009cc2918d9c2f840c4da43a703ad9f5b5806163d7161696b5a0adc\n+                00000005\n+                d5c0d1bebb06048ed6fe2ef2c6cef305b3ed633941ebc8b3bec9738754cddd60\n+                e1920ada52f43d055b5031cee6192520d6a5115514851ce7fd448d4a39fae2ab\n+                2335b525f484e9b40d6a4a969394843bdcf6d14c48e8015e08ab92662c05c6e9\n+                f90b65a7a6201689999f32bfd368e5e3ec9cb70ac7b8399003f175c40885081a\n+                09ab3034911fe125631051df0408b3946b0bde790911e8978ba07dd56c73e7ee\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ RFC 8554 Test Case 2\n+    public static class test02 extends HSS {\n+\n+        @Param({\"RFC 8554 2\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000006\n+                00000003\n+                d08fabd4a2091ff0a8cb4ed834e7453432a58885cd9ba0431235466bff9651c6\n+                c92124404d45fa53cf161c28f1ad5a8e\"\"\");\n+            msg = decode(\"\"\"\n+                54686520656e756d65726174696f6e20696e2074686520436f6e737469747574\n+                696f6e2c206f66206365727461696e207269676874732c207368616c6c206e6f\n+                7420626520636f6e73747275656420746f2064656e79206f7220646973706172\n+                616765206f74686572732072657461696e6564206279207468652070656f706c\n+                652e0a\"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000003\n+                00000003\n+                3d46bee8660f8f215d3f96408a7a64cf1c4da02b63a55f62c666ef5707a914ce\n+                0674e8cb7a55f0c48d484f31f3aa4af9719a74f22cf823b94431d01c926e2a76\n+                bb71226d279700ec81c9e95fb11a0d10d065279a5796e265ae17737c44eb8c59\n+                4508e126a9a7870bf4360820bdeb9a01d9693779e416828e75bddd7d8c70d50a\n+                0ac8ba39810909d445f44cb5bb58de737e60cb4345302786ef2c6b14af212ca1\n+                9edeaa3bfcfe8baa6621ce88480df2371dd37add732c9de4ea2ce0dffa53c926\n+                49a18d39a50788f4652987f226a1d48168205df6ae7c58e049a25d4907edc1aa\n+                90da8aa5e5f7671773e941d8055360215c6b60dd35463cf2240a9c06d694e9cb\n+                54e7b1e1bf494d0d1a28c0d31acc75161f4f485dfd3cb9578e836ec2dc722f37\n+                ed30872e07f2b8bd0374eb57d22c614e09150f6c0d8774a39a6e168211035dc5\n+                2988ab46eaca9ec597fb18b4936e66ef2f0df26e8d1e34da28cbb3af75231372\n+                0c7b345434f72d65314328bbb030d0f0f6d5e47b28ea91008fb11b05017705a8\n+                be3b2adb83c60a54f9d1d1b2f476f9e393eb5695203d2ba6ad815e6a111ea293\n+                dcc21033f9453d49c8e5a6387f588b1ea4f706217c151e05f55a6eb7997be09d\n+                56a326a32f9cba1fbe1c07bb49fa04cecf9df1a1b815483c75d7a27cc88ad1b1\n+                238e5ea986b53e087045723ce16187eda22e33b2c70709e53251025abde89396\n+                45fc8c0693e97763928f00b2e3c75af3942d8ddaee81b59a6f1f67efda0ef81d\n+                11873b59137f67800b35e81b01563d187c4a1575a1acb92d087b517a8833383f\n+                05d357ef4678de0c57ff9f1b2da61dfde5d88318bcdde4d9061cc75c2de3cd47\n+                40dd7739ca3ef66f1930026f47d9ebaa713b07176f76f953e1c2e7f8f271a6ca\n+                375dbfb83d719b1635a7d8a13891957944b1c29bb101913e166e11bd5f34186f\n+                a6c0a555c9026b256a6860f4866bd6d0b5bf90627086c6149133f8282ce6c9b3\n+                622442443d5eca959d6c14ca8389d12c4068b503e4e3c39b635bea245d9d05a2\n+                558f249c9661c0427d2e489ca5b5dde220a90333f4862aec793223c781997da9\n+                8266c12c50ea28b2c438e7a379eb106eca0c7fd6006e9bf612f3ea0a454ba3bd\n+                b76e8027992e60de01e9094fddeb3349883914fb17a9621ab929d970d101e45f\n+                8278c14b032bcab02bd15692d21b6c5c204abbf077d465553bd6eda645e6c306\n+                5d33b10d518a61e15ed0f092c32226281a29c8a0f50cde0a8c66236e29c2f310\n+                a375cebda1dc6bb9a1a01dae6c7aba8ebedc6371a7d52aacb955f83bd6e4f84d\n+                2949dcc198fb77c7e5cdf6040b0f84faf82808bf985577f0a2acf2ec7ed7c0b0\n+                ae8a270e951743ff23e0b2dd12e9c3c828fb5598a22461af94d568f29240ba28\n+                20c4591f71c088f96e095dd98beae456579ebbba36f6d9ca2613d1c26eee4d8c\n+                73217ac5962b5f3147b492e8831597fd89b64aa7fde82e1974d2f6779504dc21\n+                435eb3109350756b9fdabe1c6f368081bd40b27ebcb9819a75d7df8bb07bb05d\n+                b1bab705a4b7e37125186339464ad8faaa4f052cc1272919fde3e025bb64aa8e\n+                0eb1fcbfcc25acb5f718ce4f7c2182fb393a1814b0e942490e52d3bca817b2b2\n+                6e90d4c9b0cc38608a6cef5eb153af0858acc867c9922aed43bb67d7b33acc51\n+                9313d28d41a5c6fe6cf3595dd5ee63f0a4c4065a083590b275788bee7ad875a7\n+                f88dd73720708c6c6c0ecf1f43bbaadae6f208557fdc07bd4ed91f88ce4c0de8\n+                42761c70c186bfdafafc444834bd3418be4253a71eaf41d718753ad07754ca3e\n+                ffd5960b0336981795721426803599ed5b2b7516920efcbe32ada4bcf6c73bd2\n+                9e3fa152d9adeca36020fdeeee1b739521d3ea8c0da497003df1513897b0f547\n+                94a873670b8d93bcca2ae47e64424b7423e1f078d9554bb5232cc6de8aae9b83\n+                fa5b9510beb39ccf4b4e1d9c0f19d5e17f58e5b8705d9a6837a7d9bf99cd1338\n+                7af256a8491671f1f2f22af253bcff54b673199bdb7d05d81064ef05f80f0153\n+                d0be7919684b23da8d42ff3effdb7ca0985033f389181f47659138003d712b5e\n+                c0a614d31cc7487f52de8664916af79c98456b2c94a8038083db55391e347586\n+                2250274a1de2584fec975fb09536792cfbfcf6192856cc76eb5b13dc4709e2f7\n+                301ddff26ec1b23de2d188c999166c74e1e14bbc15f457cf4e471ae13dcbdd9c\n+                50f4d646fc6278e8fe7eb6cb5c94100fa870187380b777ed19d7868fd8ca7ceb\n+                7fa7d5cc861c5bdac98e7495eb0a2ceec1924ae979f44c5390ebedddc65d6ec1\n+                1287d978b8df064219bc5679f7d7b264a76ff272b2ac9f2f7cfc9fdcfb6a5142\n+                8240027afd9d52a79b647c90c2709e060ed70f87299dd798d68f4fadd3da6c51\n+                d839f851f98f67840b964ebe73f8cec41572538ec6bc131034ca2894eb736b3b\n+                da93d9f5f6fa6f6c0f03ce43362b8414940355fb54d3dfdd03633ae108f3de3e\n+                bc85a3ff51efeea3bc2cf27e1658f1789ee612c83d0f5fd56f7cd071930e2946\n+                beeecaa04dccea9f97786001475e0294bc2852f62eb5d39bb9fbeef75916efe4\n+                4a662ecae37ede27e9d6eadfdeb8f8b2b2dbccbf96fa6dbaf7321fb0e701f4d4\n+                29c2f4dcd153a2742574126e5eaccc77686acf6e3ee48f423766e0fc466810a9\n+                05ff5453ec99897b56bc55dd49b991142f65043f2d744eeb935ba7f4ef23cf80\n+                cc5a8a335d3619d781e7454826df720eec82e06034c44699b5f0c44a8787752e\n+                057fa3419b5bb0e25d30981e41cb1361322dba8f69931cf42fad3f3bce6ded5b\n+                8bfc3d20a2148861b2afc14562ddd27f12897abf0685288dcc5c4982f8260268\n+                46a24bf77e383c7aacab1ab692b29ed8c018a65f3dc2b87ff619a633c41b4fad\n+                b1c78725c1f8f922f6009787b1964247df0136b1bc614ab575c59a16d089917b\n+                d4a8b6f04d95c581279a139be09fcf6e98a470a0bceca191fce476f9370021cb\n+                c05518a7efd35d89d8577c990a5e19961ba16203c959c91829ba7497cffcbb4b\n+                294546454fa5388a23a22e805a5ca35f956598848bda678615fec28afd5da61a\n+                00000006\n+                b326493313053ced3876db9d237148181b7173bc7d042cefb4dbe94d2e58cd21\n+                a769db4657a103279ba8ef3a629ca84ee836172a9c50e51f45581741cf808315\n+                0b491cb4ecbbabec128e7c81a46e62a67b57640a0a78be1cbf7dd9d419a10cd8\n+                686d16621a80816bfdb5bdc56211d72ca70b81f1117d129529a7570cf79cf52a\n+                7028a48538ecdd3b38d3d5d62d26246595c4fb73a525a5ed2c30524ebb1d8cc8\n+                2e0c19bc4977c6898ff95fd3d310b0bae71696cef93c6a552456bf96e9d075e3\n+                83bb7543c675842bafbfc7cdb88483b3276c29d4f0a341c2d406e40d4653b7e4\n+                d045851acf6a0a0ea9c710b805cced4635ee8c107362f0fc8d80c14d0ac49c51\n+                6703d26d14752f34c1c0d2c4247581c18c2cf4de48e9ce949be7c888e9caebe4\n+                a415e291fd107d21dc1f084b1158208249f28f4f7c7e931ba7b3bd0d824a4570\n+                00000005\n+                00000004\n+                215f83b7ccb9acbcd08db97b0d04dc2ba1cd035833e0e90059603f26e07ad2aa\n+                d152338e7a5e5984bcd5f7bb4eba40b7\n+                00000004\n+                00000004\n+                0eb1ed54a2460d512388cad533138d240534e97b1e82d33bd927d201dfc24ebb\n+                11b3649023696f85150b189e50c00e98850ac343a77b3638319c347d7310269d\n+                3b7714fa406b8c35b021d54d4fdada7b9ce5d4ba5b06719e72aaf58c5aae7aca\n+                057aa0e2e74e7dcfd17a0823429db62965b7d563c57b4cec942cc865e29c1dad\n+                83cac8b4d61aacc457f336e6a10b66323f5887bf3523dfcadee158503bfaa89d\n+                c6bf59daa82afd2b5ebb2a9ca6572a6067cee7c327e9039b3b6ea6a1edc7fdc3\n+                df927aade10c1c9f2d5ff446450d2a3998d0f9f6202b5e07c3f97d2458c69d3c\n+                8190643978d7a7f4d64e97e3f1c4a08a7c5bc03fd55682c017e2907eab07e5bb\n+                2f190143475a6043d5e6d5263471f4eecf6e2575fbc6ff37edfa249d6cda1a09\n+                f797fd5a3cd53a066700f45863f04b6c8a58cfd341241e002d0d2c0217472bf1\n+                8b636ae547c1771368d9f317835c9b0ef430b3df4034f6af00d0da44f4af7800\n+                bc7a5cf8a5abdb12dc718b559b74cab9090e33cc58a955300981c420c4da8ffd\n+                67df540890a062fe40dba8b2c1c548ced22473219c534911d48ccaabfb71bc71\n+                862f4a24ebd376d288fd4e6fb06ed8705787c5fedc813cd2697e5b1aac1ced45\n+                767b14ce88409eaebb601a93559aae893e143d1c395bc326da821d79a9ed41dc\n+                fbe549147f71c092f4f3ac522b5cc57290706650487bae9bb5671ecc9ccc2ce5\n+                1ead87ac01985268521222fb9057df7ed41810b5ef0d4f7cc67368c90f573b1a\n+                c2ce956c365ed38e893ce7b2fae15d3685a3df2fa3d4cc098fa57dd60d2c9754\n+                a8ade980ad0f93f6787075c3f680a2ba1936a8c61d1af52ab7e21f416be09d2a\n+                8d64c3d3d8582968c2839902229f85aee297e717c094c8df4a23bb5db658dd37\n+                7bf0f4ff3ffd8fba5e383a48574802ed545bbe7a6b4753533353d73706067640\n+                135a7ce517279cd683039747d218647c86e097b0daa2872d54b8f3e508598762\n+                9547b830d8118161b65079fe7bc59a99e9c3c7380e3e70b7138fe5d9be255150\n+                2b698d09ae193972f27d40f38dea264a0126e637d74ae4c92a6249fa103436d3\n+                eb0d4029ac712bfc7a5eacbdd7518d6d4fe903a5ae65527cd65bb0d4e9925ca2\n+                4fd7214dc617c150544e423f450c99ce51ac8005d33acd74f1bed3b17b7266a4\n+                a3bb86da7eba80b101e15cb79de9a207852cf91249ef480619ff2af8cabca831\n+                25d1faa94cbb0a03a906f683b3f47a97c871fd513e510a7a25f283b196075778\n+                496152a91c2bf9da76ebe089f4654877f2d586ae7149c406e663eadeb2b5c7e8\n+                2429b9e8cb4834c83464f079995332e4b3c8f5a72bb4b8c6f74b0d45dc6c1f79\n+                952c0b7420df525e37c15377b5f0984319c3993921e5ccd97e097592064530d3\n+                3de3afad5733cbe7703c5296263f77342efbf5a04755b0b3c997c4328463e84c\n+                aa2de3ffdcd297baaaacd7ae646e44b5c0f16044df38fabd296a47b3a838a913\n+                982fb2e370c078edb042c84db34ce36b46ccb76460a690cc86c302457dd1cde1\n+                97ec8075e82b393d542075134e2a17ee70a5e187075d03ae3c853cff60729ba4\n+                00000005\n+                4de1f6965bdabc676c5a4dc7c35f97f82cb0e31c68d04f1dad96314ff09e6b3d\n+                e96aeee300d1f68bf1bca9fc58e4032336cd819aaf578744e50d1357a0e42867\n+                04d341aa0a337b19fe4bc43c2e79964d4f351089f2e0e41c7c43ae0d49e7f404\n+                b0f75be80ea3af098c9752420a8ac0ea2bbb1f4eeba05238aef0d8ce63f0c6e5\n+                e4041d95398a6f7f3e0ee97cc1591849d4ed236338b147abde9f51ef9fd4e1c1\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w8);\n+    public static class test03 extends HSS {\n+\n+        @Param({\"       h15_w8\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000001\n+                00000007\n+                00000004\n+                0dc6e2060bd57f6893d7934b26515ce751360f93dd74a648fa015aa79c862407\n+                5ae5daea402617abb48a1f6b9e2c9f28\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000000\n+                00000000\n+                00000004\n+                96755d5f8af0aa32419be743afe779842db52a82387fedd67881aec7172db8c0\n+                70734189eadc76de06e2fc999e8ce42e7ba68c942515b4547abc8c6659a42fd1\n+                371b03ef9ddafdf755b4ea374bfd00b259baef59fd87fd23b1ca5c254ae54fdc\n+                65eec03046b0ca68e8168f82c2e7d28f456ab4f3c69c67ff550cbabdf0f25437\n+                c890347db9d87e0fd243a0341bd6d6cde5190d3c3e7a249bfb757228fe6353f7\n+                69ce313fdaaee88c0416622625f3b6206c2302633e81c23f81de067393a3e3c8\n+                537d3b6b800e7ccea2d90787fb8b7c73cbdf1e778044786ad3b47cab75f9238d\n+                4ef8913fd5ad1e9f762200a649c3e42915f66210c6674a9c0f5a1dc780607b36\n+                c20ea9e299b2dffa4cd144d0715d18cc7130736ebaa67db1c69336ac3c4295a9\n+                94c725bb75a5638a569399f4905f39ccf87999e053fb08ac6e3c04dbbb9c9196\n+                121306e02152603817a574f15dcf010ae68401367024a62ecc4c0dc68bbc76df\n+                c604978101c1ebe4f5fbd8b0bd14aded6740c60b3cb18f8d166c4857940ae8b9\n+                25b707b56637499984f24194cdb2aa66b1bb80a679a8a40bba732ef19b80c301\n+                91bde4b32c6ec0267d81dc86a07ab30afb24b422e99285faae17e8679cf3a6c3\n+                c1682a1d91afb678700fa40fabf03e8b795bd06c4b0b2f8f124ee6790f5aa410\n+                5b8eb7b845efddad84488ebaae01ba7f28e9c670bdf4a142305f3376d13c1a55\n+                cb3e8618e05c11bcf244ae51b825d221e372f45b9c0f512a8ebbeea9a01f213b\n+                75f69f8090f50c11f13ab092c947ded0689803c834c2bbc8b80310be3ad15972\n+                b745678270a0a670806ff1dfb00c65bf661356634bd9466946d79e7e59d4bb63\n+                008f22127172f54c7c15531003a7d31dd949ba15a401b6e8b574f462ee296fba\n+                00e523fe2c54b4b763eb18028d49f5fe60fa88c7c26188710a2ef040c2641c1f\n+                0499a41352ce2c397bee4fa7ffc84a4834419bc571bcfa9ecf17e5e30e14042d\n+                424d0651e85b826e8bf592285e83d01b8b67eff87caaca112fd67a1ed4d5ae7e\n+                2a587d4390c8fd1ef366ff80b83ab02973bcce0be3352656c7e07dfed0df04df\n+                f886adda121035831bf24c31a47157fa19f1e29a7c329a8c0647365886d7914c\n+                969f5477211713dcfe40883c9e00037b200190aa8bd6441e2e9caf895b9ad8d9\n+                52dc7e2ccaaa1d5181b1554c90da50f53bbc993e9a04caed8aff848b72470d1c\n+                7deb858d9baf393f63d8f85cf570161d74a12c93de618d0b1112d5c73164358e\n+                92ce5e4d344b0c9a20e045b47f7ba00567b49cade32612222a5178e5868d88a3\n+                3ec703145ba626a497a716db4ef391cd6c4061dbb904bcbf6ce0e9010893d15b\n+                991b3b0b1d48e2973a19bd94ce2de05577e3db8961dd40c2107ad39aca37e101\n+                66a1788260c7cd125e615b0f19493923a17c0bdba2c982a6ab29fc28689e2b55\n+                c6460afe1e49332835228ea102e9bebf60fe64e44dc1643eaf49c569331e8ca3\n+                d4c7a8206d4b088d786aa514322d9030266fd52d5b92170a112c36b86117f8e7\n+                37520d176ee71b88a13e22b74afb78915c8516bc2967b46b350c6cb5462cd3fe\n+                00000007\n+                7547b8dd925185bf123233ebd5d6efb5b84c25f193ccc96f3cf5746053054d09\n+                274b10a2e41c5b137cc6e3008f6fbe13a32b41ba0ca3d5b95d2ca2af3a7791b4\n+                e4e80d0a837cc7ca2660105679d28c7230bacf244b74e89c9d1a00ec30a96d12\n+                5ff86a045d8d1ce2cad8df211cea8053336b35a4ce75ea9b6a3693c906486a2e\n+                f978e4bc95d39450ae4c44b5204a0f463061cecf2f4b5a3182b40305b57d9bf9\n+                130d38397d257fae6eed3ccf5ed8739738f948aa1e99ada7da70e2f4cb090758\n+                21323fd7b9934344bb47a53196150b88c4e016363132e798a5949a2b52e7194b\n+                d4babc9dc13749f7e69ed462f42de21e03186b6e13aa496b73784d071f8f8292\n+                63b37b71c24b1316bfe5dc48d19cfb4a3dfab112311cbedb59de0fc6d139676c\n+                b5cca0ed495ce2251895447f4983d8147999a9e8a3fbae038e0d3c941b81bdc9\n+                6a80dc3b8569237837940d148150c400d2a93ffe7f2b62aee591498b6c659cb3\n+                1da85478899ad1bfce0803419a4b5bfcfb0ffc27481c351dc594af1146d1ba70\n+                127968e379d34fa22c03a1ca9f2cd8d2f255e9ee2058a6b018cc464d758d633f\n+                f4197291b1ad4257f8f76e1633c19f77fc361767a7a3804d5607931d975d3b19\n+                5182fd0867719ce10daf0f0c0d52b16b8088ca9a26a22aa05224a1765fc82961\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w8);\n+    public static class test04 extends HSS {\n+\n+        @Param({\"       h20_w8\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000001\n+                00000008\n+                00000004\n+                c8568f619f0d5429eab1e63c80e058d1b8a326640a6ab457d776c52eec545dd9\n+                7fedc7e225ab0cce270d961ff9b1615b\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000000\n+                00000000\n+                00000004\n+                c89e20317ae8d2211c381fe7354bf382a750e37c307588a30d1bb9a5868e0fbf\n+                414378b30f8c59ccb95a603f03679a417c01bcb191677d629c37a396ffe313c7\n+                f27f1553e993102d1b311b92fd7669c2d1ada6cc808c11477c86fa928196028d\n+                3855d6a39fb56a73ac8eb812fa1974778ab1a7838eda03e4b7ff32d8faad4574\n+                1ede66888334c584ae4086d6a5446772c3f18041126e1972d5acb593261a0a5f\n+                2685e71bb75fae408c4d8dc359bd723d97b5180d96d57a9edbaa7a74f2ef4aa7\n+                316bf4b8232bb32b32bfd3e6c4b7e1356d5822fb90b8c861e8ef9a1f7cd67b32\n+                2b632c2565a6ac6e3635568f1c2cda59cf4ea6a83ec622f81dda9db0b91fff87\n+                080fc8b29ee5514cb25c943a714bd298ea0bba527decdd546c76151b0a9b6c60\n+                ef9de9b8aabc3c979f08fa1a613682eec4c564e5c0d87e932bc618b6009ad575\n+                59489d25a58a4338a03c9ed4c8a89eeea418d5b4a7f813eaf163e2530a40ee84\n+                9b8893f91a2f5aeab8ddd32ad8bbb8e0ffac69d0f1b5333d5211d11f32cb89a9\n+                9f7f346aa5f3c68447e831dfbce57a0a90ac32cb59066f1e5a0c7eb6bb5ef4d2\n+                e941f0a8ffe6e8e944cecdb7124a866e4282ecd848bf53f94f0323828a2250f8\n+                9a59dbc5a0dd02fc90fc433219ce64e982d86c5ddf3bc8bff3ac7f2c6e5dbab1\n+                50a2f4371ebab285f70e25fb0f64667c5805381ff1031321e6f8cb1c85250393\n+                5db51e0032f2da99c0bcc22cafe3abd1d7fddf676713a7fcf2388ed13d60a8a1\n+                ccfb996d9d0accf2be789b949f8cb8ee895f870c4b0c4280a99713abfa29377b\n+                b22a6cfa5f3e0bfd7b6b65c395ac40f8e88980fce0c4ea54b55271a6b3a78a15\n+                957cee33a498d237cb0b6457e7b539591b4c3c01b3ed1e75308cb2d85b1a5d46\n+                40086d1f3c01a244516beb5409175179cc112c16bef7041c92be7e25843703b3\n+                c9fdbb1e9e2d880f9e2c54b8cec53bff94d15406cdac5793dad36af28abf8f16\n+                d95606410d7a8b2af01ddea64572d77609bc9b1f26e0f61ed6115709edaefe5e\n+                c3c44e62d93ffb3dd868f799de31fdd82a5ddbf9126a5271fb368624ecfcba8e\n+                859e9d644063e2d016f3bd6984495bb67a92295a7ba6958d09fb3fa5415cdfbb\n+                c25605e991a5a6d914199f50842357226438c5d757cf1d0bbffdabd32cdb1559\n+                3167d8e672bf1653c2c7466ab7a84e4b587e62be7fe73270cda64513e39966ae\n+                71108c4d187175ae14d9d36dfe6754770febe70c88515b108a20e4fddc240531\n+                3a47377388104fb2597ab1c6ba6aeaf96bf9fa3ef7aa8fc61fdb46fb4c99d401\n+                3ec90362b3b2df6b9be155ffd520f696950ac931d1d32c1fae4d0da0ef76065c\n+                5070edf2043fc9b03ec3c250594f92b8f80862182501a4cb2637d79d347cc2cd\n+                966a3d20415bc34a870d0e9479da62a820f7973e8737a3d1f1cb04507d70981c\n+                5f30c0319443ba0a03cab8c8460306b5a66dd1efe29956995ab4488ee20ceb83\n+                c0891c84eb01761ed74d514d483a51e11a938e89e1f1e6b4a23ebc71150b9381\n+                c01faf71b0ab4f2842f342b80d6bb58bb410091e314127d1c33520e5f38f02f1\n+                00000008\n+                44feef16ea19cce8296b02d3955c58a873f2adb5672f5408d2a1c404c0a955a0\n+                45f483df1000b0cd4dbf5c7918b5259866135714df5fe538b26c10d19b29c5bd\n+                3e6d7f04bf4544385f9fac1e216e371888f866ac840a83518f940f1d0c77487c\n+                eca40d5fec7174006e7255ccd1a85fbd745c0d17797e0425edf97a92b8eb3b79\n+                e524988e3aaaeff9ae4762289737a39acf87e381b5cbe4fc2a0ec29bb3fb5dfd\n+                77c4ae959b46e038e7150c7bb26613125728dbfaf900aa6696c6f2ce0f590c30\n+                14d6b61f70897b732564baa09674b12ff2412eae3378a15ca8ab7d79af7372b3\n+                3dad3878699eda11cc5265d591a2b00a5d948c38fb4e9c4bfa2f34328d590c19\n+                26396c9db7355037bb9e7fa0918e9d2467d358898bad77ed3fdd2cb6f0d14f92\n+                67ba57212ea080200635419bec21ac4163aa41209865b212c5f4b000968e2837\n+                f55c5dc8389f44824427b4e6cda1917e73f7fab883717a0304373e95a7118909\n+                aa1e7854e2546c766823e2f2f4a52f001763692bdb45675ee65101f10007fdef\n+                b5205b6f2d74c42396a7de0a55ff47855e50cea65f46549f845ff855ca6bceee\n+                450eb11b7932b6465736893ca654e1faf280ec2da99dad0b833f5c4e7d805af1\n+                0e95359ba4e23b2640e2768075815adb2298fb5d1dd3552b0e868c2b69a92da3\n+                8b83713af275e933354c5a02438480004d26d0667c3d31236f2e42e594b3108a\n+                2631d63f6b0d6abfa0cc338294019b38bed8da4b49b0ff1a64871ff648687c5c\n+                97b863b78eb60844af1e94d6d3ffbaeead48a974e65fff24776553b3dca6c7b3\n+                072a39cfd09a8bf9c7591c605659c1b103288486475f54be0fb80c18717a944f\n+                51b6d317fba486e1e0ab5afea205335836e717a185827ea4cd47d557be53cc4e\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4);\n+    public static class test05 extends HSS {\n+\n+        @Param({\"       h15_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000001\n+                00000007\n+                00000003\n+                7bce4db5bd53cb23819d0fa2181e4d441453ff821284c9d83b8ddace22581469\n+                593d6dd0aa2c99feddc84f8242f6a002\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000000\n+                00000000\n+                00000003\n+                92f6ada5a00376437675ae462a5c40d4b1123d97352fdeb3f0b6dd741a3e4db7\n+                60ec956306dc6f2900f5e70e427265deab2d979ebef270cb61fac22a6b6ddc78\n+                ec265af6ef86c9513f3de135f674948c08e5cda0cb953fc6846e2720eb669fd6\n+                2d7e1fd5de25ea3491a4d018782cd929f8df2684ed20c2f71950ac606e86a475\n+                4f60cfca6810ff34233425f932bef13cbb334981f71d54ea71de3510ee52fd31\n+                85cb24191f426bdec8c10caa831e74498ee52dece68f886e9b157b68f2f521b2\n+                17e5907d824bca542126b9d79c70ed4cb1431146025e42ecf8f12b970f109f79\n+                f74e4af4511d966b032976f93ae8118cb4cd3924e92bfe5f508101b0abdc53d2\n+                6f5c1720448e2efa4b97aea98e2069eb4495e2c093601fe70193ed469162e976\n+                4ca3cf64866c59189a488a9e7a510149e0e9b92b0fadcabf22140841946997c4\n+                51410e4954faed09bc3e3e5dfdcfd598e5e70966356718230db6ea8bdf22256d\n+                fb337383d342212b6fbe4be731aef548e86e628fb372971e20d878d3f003b06c\n+                b363799967396381c34252b306a67cfd469710aa9664222dc22fe41008919439\n+                9394d75ffaeeac3b621b0643de2e98f723a761ff6e695f673c3d70918247ef5c\n+                39f222ddedaccc63b6da7ebdfef33a1aba8df3e2444610f6c7b72ba15352f783\n+                b1cac31841e58f6f22a78e2f8521379e226c6890fe41682f2c2a74a44f619f05\n+                84a343deff837d809e41e82cc6ca0b568eb4dfaf5df71de6ad488a3733d07db9\n+                a1d4137cb10244167dada62b3300e5329f886bcf2d35568f39ec759ca82687d9\n+                37fc2b6c7b22d0016f856d9ab353503399bd525298a460b5e5b748942affbe5d\n+                5f562145c6018f53175bfb1c145e512baad481193889f487eb6a007ab3fe7d0f\n+                3e7298c3519fb6d6f6f1c493f5e18bf64e5d421ad60b5c01b599aac05355e674\n+                1966c4d95f3fe002fb936c948121db57a921baef1d9aca2aa918641705a7618f\n+                59df64211e2a0043088af6e970e6e87997a7f9b1fc85513dba92dc8d1f990ada\n+                a8694c4b408341d2e1e01e07ff329486d322ee9b5fa7c3498558c503358f29ed\n+                7abf96c1928b3d21f5262517800587d01517a3ec8fbced7d3f0f7523e6544d7e\n+                2cc5afb15b709fac35301940ca8cf4ef09abe8d1b175cdaa84caba9dad175890\n+                ed9f51d762881e16cec7fed78fe9324bea6b372c09e1ec8078c73192e6869830\n+                5f16d35fdbe5ce305473399014e15c1011329723df62e3f39d28b9e9576e16a2\n+                1199b8eb076017b0500ec5da3e33789a48f6115856a586923f23f167912a307e\n+                19cc96697a4c3198211e95defbc541b797718b0a59bd330a069a3eadd2c285e6\n+                275dfce172e1a109614f0a23ca45fe29dbdf943710176ac138ca10e8a09d87f0\n+                b59ecc4073fa253e0b6707557d075175a167bd0390e089b300d3106c21e83aa0\n+                0ab384f9b301da07eba951294252a421e373def9205711db8326e1558bbd7a79\n+                3665e5663ecc7a552223edabcc6333f07095f274d3e3aa8ec114b8e124aaac0a\n+                4e99113d1950ddf46edf9ea8c8af0d9fd72146885e381a9d899b84d404906db5\n+                6f7f3c209be9da130b0011de9916f7d63c3172637ad83e9a9566d7938559fae3\n+                ac94602daef9f18a8d908e55dc962c48aeaa49c29b4fdb2a3ab38802f650225b\n+                8e6b3d25d3590ed13c3d22e3f1253d385fb02b1feee7770b0f5eb66df2558d5f\n+                3fa6a247e297e96b8f8263648f5f469c8e5313fb929c801e61a16ebe10286010\n+                2c2e9e1a759b7b1f4b2586f3e916970479a0d836c5465c1345314d3dacbe5ee1\n+                074d3a15e4bcf37051d9b1ad76ffbf5bc2826c2311e53caa05d22a7d0315f096\n+                51be069f7903a00b3a1b38a632b00b2e26d3946d151c6a7413cdd7a12593ee70\n+                6307d8dc0d822da33b7e335bc674d287f944fcfbb12af664ef889c9bf9e1175e\n+                f4aa47736532b9a79c489e0130fb2f49456f189cdda60e480ff0cc8435537374\n+                e7619db6a06a6e2eabbbf861483003673f5998dd31c722a6c7d17c7e43d94acf\n+                311e726e12c51805db6837392abcd880b2c5ad035b04bfca7b16ba9b82212c7d\n+                6920b91da7c1e6eaca690756d9b0d403c67ab0f258067f1ae537ad794bb2f2ac\n+                f1132d35e83bc8de5d542f100ea092c33499c5577617dd56399448c6e0719751\n+                f322e16abf3e792ed0014b49354e697f3d4d78b19431d92cbc97aa12bb9f339f\n+                d4be05c666b3215e8450f4f27e5a1a705eaea74c312bfa7d76d4ab39d957fb33\n+                1badfe1cda019460c5011897430e14ad9e8101a5b25fd3de752f47e97452f8d3\n+                2170946b4c905f613953b6a7ea03b96d67b9bee3651bdf1a33f63d2d8bce2867\n+                2e90ef39a066557e991c78201353aeaa47094542581506a5ab258f8cc7757738\n+                9f3d8fc5c19f91b5e7ec60e88bd8c6665b649ac696341229cc1b2cc2224c5da2\n+                7f2c57a53f5824aad8198d9cdefd13753ce10f8cc14f1b764b19d247e6872fd1\n+                99624aaf8a3def3cbb72ae940868870cfb29edc1354532df028dd61414a107ea\n+                83e5a86aad58f52306ada8c12e6817a870696cbec7f5d4ac6a8c5cf63a0494b5\n+                b51617e04794cdd195a1dbaf105175d0219b97fb15efcd172cb3084dff951a69\n+                0b2a0490f8641f245b03a67e4cd75783a8a668483789a3386899d888806633d7\n+                023ce6b77ee7b4c011be72d52eba18cc5f87fc702c9bbcad61e829c78b8faa6c\n+                c6882cfa49bc6ce98f8975bcd88c5c3213c422f20294b4bf960c79911744e18a\n+                1e54b91c78ab7de3f2f5bc69b20a68d7c76f9b0ac029355c523db8348e9bd854\n+                5bc86e1005eb48819993dc2eb96712a71528cfcd69b38c44f668b2ae1e74d985\n+                2303619ef5f54d927d41db399f7273a8d42c85fac74705880b50aee227dab2f4\n+                a2c96d9d6a0cd66ba0c062796c085b0d351b203421f0c1b4ef61330faa31c5ce\n+                f1e91688a35b7c5feb455d467c275049ec330af627d90ac89c7696d9ba06a402\n+                69c347eb6e9114d0f95f0b7a0e3058282988cb2c2cf33ac135d3b108670b8ca0\n+                90e8a770cc1b522fcfd3a777e6efb2e658743a9e65f8dcf218828556626d87f4\n+                00000007\n+                8f421eba67cfd61a355895a87fae815f4531f5ad25dd1832a672321836cbf772\n+                77099b27748d0dcbd08bbd4dd5bc67ff64d630c41bebbd7bf1072910745fcb42\n+                867b9b5e07a6614df38dda0a0f4c89b393b27f42e0a850852a75e9f178e0ee70\n+                f490bdb5266af9db46a2ec1e0fcc6ccb609808cf460048df6a5e8c8fa864ecd8\n+                c87266261ad5e79c874731e2c00a9efc9649895f30ff4a46cc860ebdbeba90fd\n+                c47cdd5e8bb67584f2758b25b032e1462caca6e1f026ecd855856765ebe87f04\n+                4e749f257bb5defbfb826cbfc5de07baffa680e520ff8663b523f151bfb772c2\n+                a6297ab5a9977fb15367eb960050d4c23e42bfc89ac812c1e6cd9ec37668e37c\n+                1a594e0ce90de5cab6341b1e77ea447521645632912a0682fc60de7f7831d0ae\n+                72604756a4416573c0cf6a52e0868b857b76b1faa5bb7e3607a339dd32f33263\n+                4b210e0e31da922ac6870ace1a068f3418588071996ff816b95a1a478488f82f\n+                b54e27fd3f7037360b20e1b3e8674325253ffff578dbf8108927a966cf4163b0\n+                40aa99d98df801f0e241c1607d9e8484c9755f6bbe299a6efe96ec0836e9d53c\n+                213db6d352863854781c78c4cac3083210f979d3f7884aca69fa83429c1542a5\n+                51b8e95ffad4f89b506bd31ba613fe66a375434114dfbdf11741a8d86a239ded\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4);\n+    public static class test06 extends HSS {\n+\n+        @Param({\"       h20_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000001\n+                00000008\n+                00000003\n+                fe732f6abc16f3b1c0d1b78d9e72fbe118904abe9b33f2e03d0728ff4cf15b3c\n+                ebea5149fe955d36f911e528d2aaff42\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000000\n+                00000000\n+                00000003\n+                4da59d6dc70132d671114d7e3fafb184a898a603a60119dcb55148775618754f\n+                e4d35a9594db68ab5003f967e968b97101307219d000d16dbc58bcc2285ddb23\n+                dd983189c34e7defa68a7682e26c50668bb20c6d1340fbb127d1d5b805454a66\n+                d2a7f43d2a579568bea4187ae180cd1038d80655454c5dcb9700821d55db70f3\n+                aea2d5f8e1b1b99cfaa86b253e13a72af3389d33bd51329171d666c260b71a66\n+                7f1f7e4256906c0247ac361fd2cb11ab9f3d8d042bab28fd5df69f14a54f88f3\n+                4339c81c02a0a9256292566ed753d2f4312d4103bf25f7b310a86f96301143f2\n+                47c2291674797bd1088920eb5bdc049b8f9809c3c6d96ebfe49084d1021aadef\n+                ec3ece50b4b42e4af022038c6b5363c2dc24522a2e641e352363d9149d68cac3\n+                5bc3d973071e6b7aed2f4f96ca91aa22e162ab985baec0e56df59d3e8b37fe89\n+                59c00aeab5f3713093105cf7db782fa45ea8ee2ec8feb56c529e6b42f18043f9\n+                79d8c4c9d56a4255ec9747d31cc62a7bf70cd8777ffb75ee43dbb2c394e36525\n+                71ce27770f6ea480e89f05ba3cdc633cc3ed269eb2ca0131268fc0579d738334\n+                504b477e8fc2264c421e2e551b1a93713281858ba2cb588a2adcce4d11c2700e\n+                31d7ce6936b267ebe96b4f9bbc4763cccb4f245d371177c258c6d23c30bc5dca\n+                0f6d8fd8194b683f2ac4e0f3ddb7ba1cee1c47e5eec239f5a6b661aaafd2960a\n+                5d1b3305e53d9bbf8f6413368b7656723bcd47e7ab18b41d7e29b511767ba267\n+                e662ee59a004264ec2f88b8ab6fc778315ebc2a08144503455b8b2c1bb410eec\n+                b767ee1eb779f9f2bca35184fa4ff7d8d36a41a9ed3a76fec7fd9a68f8bd35ec\n+                2dd1aa14e7ed9c41db03de868b266f8cfac7fcc887c78e1aa3e085cf0883eddb\n+                74d483dd177f9168ab14134a5e2272bca7e6e31185c34225e05de4545a99a4d2\n+                949a75f970b862aa3b8c9218ac34ad1e3b70a64be25005fd248463606275b9d7\n+                8d96725b39d8b9ba08acb91c3103c7e31f7970f937e176a34f4f4bc601dd8f5f\n+                f83caff6c72b2e7bfeefd49c93cbc270cdd4d442be431b8e9b68e011975708a5\n+                60095a8b784850a3c5bb3bdf2778a8aaca9064b6f1d424f4b41047efc7088639\n+                73df9b861320e66779b25d134bd4528920b64c79c9eed64d5a01e39f8c2e1a62\n+                ad2e6e68bc5de644f5f28b09a9479abe5f96bc6d3e0d77763e3cf61feb31f152\n+                98864c632b450d37a04e6aa4a2fc67406acda826ae98b7c52cc82da5da333ebf\n+                8b1c771dd994f6c650bf24cea6f25963fcf11a1aab7574b888dc89f92659fcb8\n+                1aadd497eb6676243eb9f65e66ef97ab8da3fd9678c8166d1b2aeb724211f4c8\n+                4e72749176f5d63798fbd16b0006dc8d92db7ee411a8ac90eead5a08f89a89bf\n+                295296b8d1d27e97d472cff51787b67a3d6d2a29b66e672647f395e21c9c83d6\n+                dbdda3d3608968288224494a815103549960155b1594d36580ca1db90c54b783\n+                f9e732fc2b14d58726a17bf5869a296985058318adccf6e56672e8dff8beddbc\n+                dbb4bf30d2c59bcb8eedc0e713cd39ad9bb748e5abe75e05179a856c686d1c6c\n+                764f8422372d6f2dbe76f277a21c75c7f778a4056a1ff3bb9f0022d931612411\n+                819c5a8a7b2e360c0ccaaa910e2af0d7ec87e9ba4cb90e85a18ebb8fafb4eec3\n+                40ee8cfa4b9d9a92fbe07aafd07c58e06baeeb5c587279c2b2c344db5e43d5ae\n+                32547dc5f45bc855a9dfd6c8d3ff174d0fb999f4819e3b09ca53cb328689486b\n+                e715f148dcbeea8f46ad00db30bfb087b8ad53ad6e1cb579ed51007289dc5b0f\n+                691188592e1beb23243ea4ab09771552fd03bafc9619dbba025764a5290a938b\n+                3c61ceb22c480a0985cc89a790e189b9e0022f772b30daaa218978208ff94c4d\n+                2f357f74fb93c961de0c97e95efa3a11dfe80caa3fd04051a717bdff5f5cd9ba\n+                36170cbb14defceac5ce20479b564e0d6a3b978a16cc48ede540212af06de08d\n+                300290cdeda5a9eb4c35f6b38cdd04a959370a929bb7c3372cd2a3130e1ae19f\n+                adb54c2389079bd8c7f0249a2b53bf23687cec51b529411fea705fee52504ccb\n+                fa64f7185c6f3601967d30a644a5fb4051517c8560b64009f6de5993c85516d9\n+                2c81e47c076a679ce96435939352d67d11fd5bbc94e6e90881d70311cba88a55\n+                83a7ec14f853f128da2377d14f95b947d00219638e712573223ff1aa2762d1f8\n+                f93d421e70dfd5ff040eb8f2f435d487e2d91d6d9cc0fe2d9066a01eef8a6c92\n+                d3a437a8ef5d8c8c5ea5be932d2f71b4d04ab3dacff9508e7dbbba3a01ea63ed\n+                4b7eb611e35e7d70f0e4ba82ab8a86719bb0e28fc9b3ad28bfa91f227a34b005\n+                418ae4439814122d5e79336d63e1554e1137642a98e67654ee73031166c34726\n+                c4e78848a55ae01b1398338217771198db5973527a82ada98aefa954edf09f55\n+                9f4896aa3b6117592599fd4301dd304d73ce8859509782bf60e8398ff311bcbe\n+                c26cf13b8a6448f2aebd0ca29d06fca7ea09f559aff3a315b1ee70bff8038b06\n+                c381c9630896666c83d14b7bc3b07eb153efddc2b09568c0ea3260c26106d1d9\n+                002ec640f4ed596991b51c20e9d4bb78de99588a33d0a64b20f8ffb2c18b250f\n+                d5f7ed0a4a5e2a9ff94f62b8e84cb4e2ee898b85c11db384a26e9bddbd300128\n+                2d886b7485166c7fc982be8c417f8fcd1a7fd98e529f2fe88a46f36d5091af16\n+                feb75ace51927a339c79cf79fb222b223e845126c73e4e8103fdd04786de373c\n+                9586d13460949c080ec557345dbb88ff1ca59701c889dfbb6492bb9086f05ccb\n+                330a2bff05ebba97a5358702a8d2aee46bf1d7fae1b934405d652a05e532b65d\n+                d7ef2e6599af8683bfe4644ae2fbc77424f31bc422ab791de730e4718d080603\n+                8dbb78b84c5df001047502acc3efe437cd46b8a0a7b4198d5598dbc343db47ad\n+                9c379d5147a5d4bb3c8b962a7368a7405a580f7daf312327141cb5681e198795\n+                3ea2d2d95c7b9ecd6899428a8966203a9ce586357c631f7af27aaef3ea3a47bb\n+                b8a81a7b83bde6f223b270576427c02f0fbb8e9232b2d70f9a0af16ec6544eaf\n+                00000008\n+                ff48f2d9fc8998f7cb6685a1d980003da426db35481323c56195cd5142148269\n+                5b064c6f98dc3289b8244a5a7cfedf3c1c9a96ae48c79d6c9b59e713e91d90bb\n+                a0212398645f8c55bbd03832e57397200b8127d6f38570e15297489040fbe0de\n+                a21d372dfbe5098b1491d8efcfd2389e506039bd49fc976ae940b5e6bf3c394b\n+                189c63af6e799ed580f999ff02a16a5915f9b2ebee58ecde057345f4557e87b7\n+                8828c700ec978f41e9b9ea78cf8dc961b0ac33c54d0f91a1d05b4910e981a050\n+                a2c319c8cf5470b427ab09159fb17e5393176683e6e0b3fcb11104e357d75d66\n+                6b13356454c5bd0e70c18ccaa775ca568ae50d924c2ba2d74babff2fba05ed25\n+                4d9e8dff7d8770738f2e666f8db461fbf0ba307cd638950692c65254b03d739f\n+                72ded6f48b6a9a37de6cb2f3c4498626586ceac37a2644e5fdf9b7794fa4b472\n+                37bc4d45381e5bcf6852d15fd572e0062c8b1fc63a31312737f2347ea40b2117\n+                03f23f5811b7ddbca4a3f19fccaf4860773bcfb872000845166c61243b05b033\n+                4ce5faaac3ab1a7e950403b952e0b0ef4396e5f12abd08bb1354c28afb9bdbc3\n+                edb94b15aad3a85ba3444caa1019262ab6e04f343284bb5a21320440a95edb16\n+                d3317c875cf0187f0ed79b676ca45203c2d4a83233229f0861c58164b2b80b30\n+                0c13ce8899b0ba1e470ead23836fefb921ab6a472beb63b655a1238a5b8f039b\n+                f1c2916a44168e288d4c4aff2ec82c8189a7f7b70837e0a5756db0d38057c9d4\n+                5927418b9fc50048b6ae0f16a9b3e3399d9b08b67c41c84bbc5f8bb9b23f08ca\n+                cd742fa9e1225dc8e6cc32b86d6f57a3ac4b6d733a0655cfcc036c4b4c004a61\n+                1efd58035b06ba03b4a701a68f5945cd90bd4d69d702fb43f0ff10a5879ab709\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4);\n+    \/\/ LMSigParameters.lms_sha256_m32_h10, LMOtsParameters.sha256_n32_w4);\n+    public static class test07 extends HSS {\n+\n+        @Param({\"h15_w4_h10_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000007\n+                00000003\n+                c56e39882736881759e92ef7a37a1953322e3e9742a70e3f401e9bd35c973ace\n+                e06d7f77bd11b4a6082bbf7a5429dd4b\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                c94b744512be0c92aa45ab245dcdb53513877236830106ce43f09a2a6fb083b4\n+                53d15c7290b92cc2864d0780ae105d535de9f9651db43ea47f91a1334bc215e1\n+                eada1413a30a5917c0da8a5ae8256a0d40e98f33d6bca2d93579a44707a4cf0f\n+                6cab795d4e332685898ff004836490805f3b7eeb675c89b46f6d0d76467ffceb\n+                18f41176ce105214f4d57d1058aa1468cd1c2a894b62502b22ecf0b4f73f110b\n+                4b9726934786d58ad59b57ef1fea528421968ef136fd2ca7131c83ca9f03ece5\n+                a8c81765c769d79e8fa4093235c857d3e2864e2614be9535de95a09f60f2c033\n+                fe0125946b47bf09ecbc92123d486411c3c715f313b178818e00a81f02c8b7cf\n+                6c9f6babe65218f5caa8b0c38785fcc9dfe8c35b59077db5084c49f99fa7fccf\n+                5d3dca81c273f72a8f3e8777ffed035edcb9696f9a062a7befa59741abdd8952\n+                1dc585d1f8b37141c6d07974d768ec338ba71f98581fddc7db7f6b11602f2bce\n+                a4168f7959b621d7e298936a981e041092ebc13e944ee2150b91dee55a1f6724\n+                66fc58e24d8d1844237dbf4ae6d5623001afffe971174541fdb7bdf8695d8afd\n+                cc56ce99cd603ad02b700983e6b97b76b9d95715a57baaa5804dee2a02b88894\n+                0260b58e99c05f05bb5b2280e242a40d1f443f3a37ad051dfcf3e1888107c067\n+                a67379ba8716e167b862fcde469ab62a4d84162f68d74a6631ab0a7c41ba7519\n+                096b72110d7a9561eb8bed3d7a87b383a5085c99c54149b56d5d40c747ca28de\n+                ffc08f627609600d2e8f40bd7104bc99a2ec73952b857eda20475530c1fb969a\n+                c79c062c6a687bd2e008b8574260b822de26c9e7cbf32338348db43e4130026e\n+                c2dcd20b79e4b1766762037af058cdd89a9bb2ee4148d09653f0366c7e0b018a\n+                2b72a195a6b1c422e5adc23fbca25968f7bb97e51e01a83b7d1e83b22a118b76\n+                ecc8acac709b3e5de5cfba07d8e81b2dcac4a476359b1541adb24c2e9fd68a38\n+                32f2ae30b1db83470cb50a9f36777fb02b98f63818a078449de16c3108c0b724\n+                ce49b7f5f3beeee04ffdad3cd5cdd2e7955008d6e3123a42a46574a8237f2d54\n+                d54b3f8a6e01185287b167237ef736cef9881ed8478466124d72ac30a3caeb2a\n+                18fd68be71625289e05e076b7c290876dff1a95fab3503533be3ef0c5ad356c9\n+                df59630f3eb5fb6be37c61171243c0cf72ba2e2b83c4d84ef6ff9cac6b9790cf\n+                09eba6e0dc76664cf957c91b09b67f0e5c0f933d503c7a6a6be06f78019eaad0\n+                302e68f499e87d84627a7443bf1e2a8a2673247b1dc6aff3ac940d5f0e3a3ad7\n+                c888cb961d8adc05a85cf2c9af4ac80eb0109b7ae822933ddbfbbbb36e05bf24\n+                c3538c645e22946197d21091192cc2ece6f866fa2c37ce1f4a9be52428d23913\n+                3952f89286f88a7183ad17416360e0143d266f730cfdedd42437eb4baf9c3e7a\n+                1fe7a3e084c2ef4f50e2730ab9fe44c90b1d0167fbd1b6bde2f1457e2a7521be\n+                7bbd3bf2fc64dd111c185062afe4b90830747c68ad4ba890d691bd66d95fde6b\n+                ff7b1b1c4d13c69d4beb23ba90309fa17633ac5c6d3c0571530ee61e48eb4e65\n+                b2482bca9bb230d3fbb6a6e83145a8c918059befc05143a5145ffd4fffb38114\n+                e4026f262038e7d24d5f9dab453899daea13fb4bb07f7c7fa875ff4b8c1600bf\n+                d05be8a945f323243987db289a19bb29250a6a2d8d53c26e4cd5319324676f38\n+                a2adc2fbbedb324a5dd7ef804dfaaba33b4d7fbe17f134e1883400072d5f30ab\n+                86bbfdfdfacabc41b80749abb2271f903c71b383b5779aabb317db34ac01424c\n+                174cacff3dee16cf50e7ecb99d50afead31ab13363f49050463c25aea4d65235\n+                0797d491ebace80bfd2074095f1ab5dceea9866a62c1e7e3c7683c3d7bb50272\n+                741afac834a1e48ffe3e3dac6c168a33f40febfe4ede57637653c7731b4f5d81\n+                ac275de086acfb63133ae49b40cecf3e8a0333764957ecb1fbad30d80e0486d6\n+                5a9727a590494ef7aae57f40bb0d75b05fc8a99d98b28f2294585234894c3f58\n+                a1064bb824afa73938feb5b96b279dfd3f9145ccd4a8339d2be01a62ea25efbe\n+                b4bd970ba21c53d31fe66efba0450e8c5edf46c7116701b52954a11baf31727f\n+                7f845d9050a6a29759850af2d55d47be9646dfd6321af2677806335ecd6812e4\n+                a2ee84aff5aaea12478c36b822335db52a6cc0bac5b59c79f5d947fc526288d6\n+                585abd23a071c6a98bcc6909cc3e45b15ee4244f19fb5e91b9c408870a37741f\n+                bff097374f1da1ac712561ed5f908926f9c05748291de93690cc863d998640f0\n+                963a92ec0b5246745477c83c600e52fd937d4a190d621a114c185a0a84b5ff3e\n+                782113864ccce2b9acf86100bf188d9a00de08bfc9b1fdfffcc1f2ba68420bbd\n+                d6df840fb782a21cda9f051610663e8eb0d1e3e976886fbd98134101fabe1ba9\n+                33b2546f1a468697d453d94716b157dc8dbab7052424b095d3dd7a19ed709da2\n+                60d7ea9df24170f6feea4712c56f82158d1870b1380e7dc4313a4d419ece9ea1\n+                dfd7b3df4ede21f29e050156d5089bc0cff7e15c7983476e890b41f29a2bb373\n+                26dd2da928dca53655602886fd1c4a9c8153cbe50652741ba398857e37ad2231\n+                973c24653ab47e413ca95097a984e56f3fe7fcb3e8a7621d8cd710dcbf8faf0e\n+                2be05dd70a0e746a010fbabf8dc45963673f8e009cf146688852ff02eb1c00b0\n+                5c4adc1ebe2dfcd31a15f37a4ee935bad87bda3e27df9724a7b1564b3f251602\n+                50e722a50869d1cd39784b362bbee70c3a917f18bf92b77a5322e8b5c1a7d101\n+                77fb7a50f3d1b10669d570f7cfd4d5ca1401a4da432d4f68137986c456507611\n+                a050b0ae0b7b8ea295bf78ba9b8b3acceb14aafc82385928ee544ee068171a2a\n+                34a7e2e5b37a19a70c0251910c0966cc6b8a689cd6fc8a00f73959388624f9af\n+                ee57d316054eb23ff1aa63879e13519f416a8449942da592e727073bdccbfc72\n+                52baf02a65ec66bb9504199a147a3616ec20e7c57ab6a4f4c7def3eee13dfe48\n+                06372b85bf3d32cb6b3407a59af02c5549f29a76c73f43566b868e5f1092bfc9\n+                00000007\n+                a22f82a1ca76d4b8fce179e98c2b8f53fc36a1be0c8ecc5ac22a6c65b02101e1\n+                0da5ee071fa5a641198ad237ddc7b03f50612080ff3867ce11df78150d06c9be\n+                35bd7d0befbf473bae9f2f8e077e9358e8bf2b4ca45c7a6af889f56564a22470\n+                43b4b86db63819c4f9d024e3e09b96e731e315d10c3db8312e9bd33d477c318b\n+                3a5f886dc3d8595363de2e2d4053aef8b722f7fe4e092c1c9de6942c6597babb\n+                91ba0b88467321a8762daed53a5e31bd91a76085d559718fa3368aca9c5defbb\n+                6402193da3e293fd7d5df6c0d0b36e4696dbb0e6683dab1e29740b2625faf976\n+                a86910e194b46ca4857c3a1fa37b2a932ee300fd69ff2987fdb6e8ec7fb0a57e\n+                f50448510f72818c87f0a51be0796e20d9fabb66244ec5e99d6fa786b7524992\n+                bed245b61066371a4d0b3b91b64ec0e4e4912b5064f4e73a684de396f73b9531\n+                397506e10da845520a724a419003445e4b3a02ecd83a5fbfa392725054acc609\n+                b9d66d83ca4981ab5a826ac0c675706a0db4ea4f4ad55b3c3a9cad8ebdabcbb0\n+                c1526eeb2f678c0782ff98858241abd90104f0a89767cbfbc8584062ec2f7fd3\n+                ac911a09b2188c85a46b71ed13f71c740cb8f78513476f33b7157b49422e2710\n+                e4ea2efd66b147f1e94f512d5bf7ec40fbf020094c03626fc71053c6984d8b15\n+                00000006\n+                00000003\n+                6002a704915e03814410e7c4a86744b6269cc17650b33496e73414170f642ad0\n+                a5a308f58beacc5b39af6b988b906c8f\n+                00000000\n+                00000003\n+                4958d1fa4dce4ace05d93d530b008131b8c01191cb9c6248842e503676f89c91\n+                12431e2d9276492e1dd36fbdcbdced7dac7a4d86fc64cd8a1f6761d6072eb0fd\n+                a335e5a374b7139a62537af2d20747b199f32b97aa98b7ed722e651b4ea2e8b1\n+                6741525a4adf245446407ef3a0f8da6a374245bc5796fffad397d33ac887ef8a\n+                f1eef9ef53f9bf5ad79d0ca617c69bf8d5687551779762530a71c15a1a833cce\n+                ba629d85f03eb30b065fcf401282632e97cb505e41993ea121aabb93c5f5188a\n+                ae98a85213bfa98bdbe14d2b53fdbc4c00b1826ff9b34ce84293eee25a440622\n+                677e290239095d199a3776d2208ff1dbe2382657e83d1e29f8da4cad0dc2fefe\n+                2d17350229b945718f71d17c646c881229a4fa47e2dcf7485e9096b47c24ee1c\n+                4f051855cd19d787be09ea221bf827f6c2e648435f4d66d2028a011e8536dfc2\n+                66fe9bc6c4d342b95a692567291e6e2ddff81179eeec69fc135983fb550569c0\n+                4d90c040c2a3ecf2b81a55f5368ac0a7a3d9c2bfdb8aa13568c3147f56b0a504\n+                84c4a00b2b1c795e784498d4bd1951eb5733cab4a7b6103a4823f2a94f890c62\n+                dc83c57ac233902bda5440eaea0aa553e0528458b39e8b58ef98e157c95a723f\n+                7c074b5e3c4b2d2c15ded5582d2774c71173be7f7ecbdc659d8d5a132e39f64f\n+                4ae6a81fd550d8dcf7a1e695bc985d059892567fc502399123ee3f1131d113f2\n+                bdcbe027fbf6ef0738f78762982ab379547eee6b4276635d1961b7cfbf1bf6f2\n+                e9c9512fb4699468d882b382bfe6c479878824a52fd5bc0ffbc5cd857d1b96c4\n+                18ef6c59e799b93f14bfe5b769ee28aeee86ff5caae4e7cf19491a00f084b818\n+                dd61b0f97675c85077bee6ce5a44d9a47603491ba1d5e690f311037d7319bcd5\n+                74542337ed91eb7d65a01987d32f17b08d62c9b2cd326fff38e3a6e280c31255\n+                950b7911c262a17193bc9fbe9c43da2a3b69e61a5f09d67f667f64a12e91ab8b\n+                baf00cd7647b9fa8ab76057e5c2dbcb347c26ba18b03c25af8f1bfe18491f962\n+                b537cf3b24078dd8f45a2b3f707657592872d4c3c050bbb69dddc885399e068c\n+                c4d13709c8533f650e48780663b28218bc4e81ac3265b505f4d4ed6c8edf10cc\n+                c9db22b1f92029727cde22f4cade608fcc64372da7367886290828c478ab588b\n+                4473c2e9bfb975368fe6b53b71953eedc62980b60f3da18acbbd292b723d673b\n+                217d17366586344be60802ae9b4bd945c27e196317f9b8aa91299863a6dd336c\n+                9a321b7445934edcfaf6dc7f107a06ec6aacf3c4e7e04d83a938741912a9a34d\n+                6d6cc6598ad635c8299b4c5adb149f935f39a1cae255a8116e544306330ce49e\n+                6a46452ce0420c655ecaf659b8723780c9d2a7946f9b7781ca0ae983dc68c0cc\n+                afbaad6792d3b31b728668d91de0a7927780c78406521bcd483d3614d20a4265\n+                62c6435a924b998e3824351706be646e2d530a2389f6c09a2d8c443611e7c092\n+                330b56ef2672ad807f1ea8e249b0a15a57881048f91b00c4fb374201f8b92259\n+                739e521e10604eb307d3638090c0a4e4eefcda271a5387cebe0fd48d9a146232\n+                37b9380e40ef1108f00a980c4cf9abc88b3edbc7826c48508e02069ab34578f9\n+                db6bc3196dc806e0b1659577ff34d138e53cf784dfd03e3d8289b0d8fa9ab004\n+                dc35ead8fc1433b8c2b1265241f17d9629829c658513051ad7feea28e1d72a34\n+                05a2571a4af94b7ec6ab2ac4cbc810077aeed2237831eb42e303511a3b79475a\n+                9f9284f00b3baaed51ee50f3ec7af02effd2dcaf7abcb9e4bdd639c28293c8f0\n+                63d35b3f3934df46eb853a2b8f9e1e8e39abd9f22a7992325b9965ccc14e7910\n+                829b503007fe5a521c03ffb48f154d908a7f145988de3d35da8710e8b42cf0b3\n+                c9197a9d250dcb5ab5ac724e0eddca2f1e92baa61c2f2862087794fb6aadd837\n+                229c58b673f4a682b6f16178a8bffc71e696a29f9116cb896dfd05780afce77d\n+                cba573170724b067964901112baa343346d2c82e705b842e8be9e5b56577015b\n+                f86f9b27be99ae333bff689d93c7e4ba77be967cf8e6328284c76a2e1a3920a5\n+                515bdc7e5b65e6041aca2268ce13c17195274cb0461611421521e79a2d53af61\n+                1728b35b71db1b6424b6382aaceee899b495fbef4184911ed1877a3b17be2276\n+                571a2347d613ceee0c9de7e0d2f0bb5e18a63ef05f424b1ed1353409f926f84b\n+                4ebafa712f5ce1d36de03c6c90559a60f80e2b4915fa57d08222f6735a6201c9\n+                4931dc8a50f88b537031855c3824f617334f9ca13a9603ac1038d2cde3dab425\n+                e5a3ff1a7fb7a7c25b315187f202eb5311d078cb2e2ffcb1a509cedee7c372b9\n+                c06c6cee6b66b6bae7bcb158e4a74769805a88f5c9cb7c581e12e1d05ece3865\n+                4b5261501fe414ba395f446a846bf736e1eba29fb30fe80ee174677eaab90e1d\n+                eee16dec7a31c23865a38ee8c052a757abb91b104d1b5e0150e535b1c4669e7c\n+                c6b23f57a8dfed44b3f853049596b7f149e5d21be66ae72df95d1e969b054cc8\n+                49f2bc06a1d6bc5565bde1093648ad2581d691cad46237bb920deeb5facabe8e\n+                52e1e02d07903a17332198526a9214b6d4d4bac9f13994f6ae01ee74e673aefa\n+                5aa33ec67c4e0fec44bbd163fc6c317c0db4ce0de479115cd2a9474c7b222a81\n+                23cb5c784e3579ee3805c8a606d2c5d113fcd12bd83d03a9d72c8f72d6c577d9\n+                c891542cd3f3e59abaafdd2b0e9195f57e9c826039647506f0fdda125a1403f3\n+                f007d6db2555125c33de5b3a90ac9cd8485e48bf1db995708b697b5b47741108\n+                1b83dc7bdfdd8aa5a3506cf5a828c0e9803320af6a8b8949edf8fcbe65226beb\n+                aa2930c5502dc34b4ea9588ecf3e69edf41ec734be808b3e39c85a54a7eb5ce4\n+                33994c40209f02eef0e43adb560bdb26a969216b521812c6364bb336d004c56f\n+                91bc928887ae8deae2ea6bde44ddd39135222698c491759ff20dfb6d7686c284\n+                2ffd232c9544e3c39d37e9ce8bac185d58802050284a5fe653aa64e16c9b1777\n+                d011e2ab479a85d33e041423e6a50e5dae059eca94b6c99015e4b65047ae8c6d\n+                00000006\n+                d67b98d51d77fd23841bef1a34fd81e4c561c4f085b02c791553ed46c7644b51\n+                b6b97076d18c3ff64891f63784cd38c9fd1580656d4ed635023f4fca45bd49ad\n+                7958c3201c2233d8e1444a58b1f03221603f1c3b59b72eeac085fdccb79e07b8\n+                37451bf427cb58ac9234253ac0c56906b0540fe5bdf35b47b73f04f56b22c8b2\n+                1ff441f59983c2763a021e6d8f0ee5b73a16ef63d89168563b086698507fa56c\n+                ddd5d64bb968b0763191da92171580f9c404720254cad5c7d6900a4997fb0570\n+                bb9fcd4d249803c3ba2b3e5758cee761ba4c2df21f20ee2d36a547a0cfb216fc\n+                efcf58231cb7d6112ac2583fc1e52f3062c1cb8b14df921eb4b702eb703082db\n+                7ffe104cd0be40b96a04048def98caffea64e25ecfdd3566d3775200c5eb9182\n+                e9a45d41023db850048e05f200a4e7ed2e0b48c532e10c1628503d5b7f394cde\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4);\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4);\n+    public static class test08 extends HSS {\n+\n+        @Param({\"h15_w4_h15_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000007\n+                00000003\n+                31b6c6a3b78feaefaf459a33e2acfa66a208240984abbe18996896c0eda7b999\n+                9d9786e59e41179854928ed5c5726bfb\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                a3e30c30ffb7b27a99e1e53b030fbbe5f901b7fc38b059190b9ccb9612503d10\n+                d0b0266063d5e234c985b0278428e147ca9686e3540e6d51964e27d0334c0043\n+                3564dc02fe8b1f911667561445bc9e61773d4ea4fb7b5c8e637ce482cfbb69e1\n+                15e118eb5dd28ad2db03ad6618af5a0a919aefafb46d8ae5ca011274032445c9\n+                7a49502e49064fb41fe28aa76c103f0d98edac1d71f51010d7e89d04028394a6\n+                87c98d1ba0b07470add461bdbc5dc553cb7225bc12d6925319253f50e8b8b1ad\n+                1d5ea6304ce5e69150b0b2953e38ba7bf75b5900e1b4e84e81d1ba177c7dad91\n+                956511d74a5b79c22aba2b821ec31021244fc4ceed9b1d992382e7f2e188eb68\n+                841b09301ead899c0857194939576e830cab8fede0f14eace0755d56d144eebf\n+                1eaf5f228f3c3a915de564ffd8c50b7a0e95834eba10737082d38f1c459f2a5b\n+                6479b129f77f57306bc9888a469ea7a7f69be2f4784c472d90b3a84c8a10789e\n+                5984c01ca390681ef94b483be22c2559222a3c8505055fdfcf3c1d5dbc22f342\n+                8d07178cb2736d930313812c30cb9fed3c083e3319208ed600d449df46106898\n+                1f7b3201a9f1760f388aff82eeea616ff89301ed98de1fc9d3a820c7b3e8d5e7\n+                e7a97f3eb819f4f5a08ef7e435d9df748d631539205204f269000d423bf195f8\n+                02091fc8f25e186da3ac3b63f7fcdf832c9a8b849a3efc207dbc39b7d6e67184\n+                4efa7ea995aba735be8d69ea2a7fa954f23d9cd548aae96068e4cca1e53f5fca\n+                2940cf78a43865ff1ef52ac1ed6c347a38b217537ebb6052a094ab8a7d5d67ca\n+                0ea8e46f10be7f07e4f5859f6f940c308aa156268a2378e36b6f642cda1a0e31\n+                dc3eac909426d8e9ad55ee21971c60f58571877e3c9e41bfec8c50c5775fb8da\n+                bc78c18abf1e9c3c9d6a1fdcbc42bb613e5019d95cbd12bbc820df6304240a7a\n+                0aae87df42881ab1e5df3906453ff32acc16a3bd5c01c4bfbe28240a05621899\n+                104994f21e87431596a2c43a336be790cc095ab7fea51a5f957caf3f221dd875\n+                59bad735356ed5364fd9f034ae53c1ae7b7a3672a5d7bc0974650923dca467c3\n+                0f826ae5bfaacfc381469b93825cde82e5f631936bfed860a786d35f29ee326b\n+                18e215c6e01630e811683da0d8d7b9fc24131da9de35a36d5e541896b79bbbe0\n+                eb15ade43e39134013b0de86731d17e7ec7c7cc1cb46d925c211e23f427ddc10\n+                a0d25b18c397a83b3be64eadf9106d5ca75286f599059b2cb0c3cfc892ae5e88\n+                6fb873326634a5231f555a4dabed9fd3370706c6e4af23e5736f5449883d446a\n+                593bbd6f36749f5a71a49175ba562855635511fe9005ab1fdbaa224f55b95a03\n+                cd08a215b8cb400a02896138900273216402241caff7398067b0f6c18edff0b3\n+                3b5e1350ee6157b2d79065ca0beb45feaa67795a821d783d3c566a0a130cd310\n+                ddad078aaa83a319ee6ffba73799bbe3f14a406be25b3f989c316256ae0120ef\n+                bf3593dcbfde8d1f1dce1fbb1cb1c6c8258623112a05b70389b1e801e17fb17e\n+                f10544099ac788eb4cf045ed1fdb9e5e957d7fd930bd927f4c15c253b145f848\n+                dd1ac985fee170307f56d34dae9926d67d1f97fa014fa3ad57c10d76d27dfcc0\n+                0a088a043021d5b053b6d69e912d3cb85b7c2cc029ecec40089333c7c9ec45b4\n+                f9c3ec3720df8fb592f5c71d7dc230f90439ec1ae12643a8f4a30dc96e798cba\n+                269bcd463116dd9657c89c569b519cd061816150e8c39ec3e798574610cd13da\n+                83b52042a890b37d10797ad80f74928a96b697bc810867a4e0e96e98585bf386\n+                d0df41627d76af70436258dd3ed1ae49554d8dc5a2c7e54d477af70e2a407747\n+                227fdd0bc0b5a9019c4df9fe95dcd8ea6251ef1bac071771d364fd428c3db3cf\n+                cb4eb26b7908ed96d30eceffbe634c0184e8cc2b807376d7d5fd9f4d9579f148\n+                8f085df80f032c6c382a48dc80b07bdeca6085aa59f97abc666c1a73d4aeee34\n+                a35e3569ac357a84fa1a9fcd84af37b388dae14e03be6b5e088891060bd69e5f\n+                419fd7d2ae50eb97bfb24c7dbd602de5db1f05c84f1f47fc7c6d40c0fa4c95d0\n+                464a18d0b6338ce123b46188492df786abd9075a535a38de4b42d8d8bd6691d8\n+                fa9dcd8af407d5f20a59cb959802735c2149c18a067367ab9e457e93e569ec1c\n+                42741ac055420fd531dda33faa9f179e272faa5b32c1e6d3029b55e21140f4f0\n+                104a89760e5e038c07a770bc85726fc57159089cc3a2ca2b8a14e9f040b41e30\n+                3e2c57f64dd7579eb094e8deb536a45bfc2840428617117a1b2ae8259764e860\n+                efc03fadfca03511a370256420fbda932a5ab58c98d0df2a9aabeaa7d886ccd1\n+                59281e77e7a1c70094722ec788212885674e90a3134c2471c399bef65cece979\n+                0ef61cf83201cc137a09115b0fa06ebed4de9104974f80fe00b54367ab267483\n+                35e0f8fc02d52e4c556ab748a98aa161d4c9cb712c88155b0177699f5fc4d037\n+                02560279c2be7db70603f03c0c2ccac7437597c79da01ef70d84ae5ab2e0ecc5\n+                b77e9f6a4c412569589d97bfda88efdffb626dafd24408eb79919cf48a619744\n+                fe4c42f3c49ec4c1f94ec8e79366f036aa1366ad559553d102efb9b3a913bb06\n+                feca31ab71949e4aff7fe00be4bfa36e7d6dedfd349c0bd0d8a895b7f8fc55eb\n+                09933f061f0c4a756caea8790d134c58cd1469ce78edd16be26e0208d449556f\n+                b02f343493fafaf615585320902dc4c606d3ae2fd4df7619817b49d47a672121\n+                c18da014aa89309814f49d2259540aa4897cccade9eb94351950a21ef3aab45b\n+                90caa42e3e41f39e1da7b341cacca50a8978f1dab0a54becc79c9501c9ad7c06\n+                db29ca593441ea36ce2d48aa5ab2455efdd70e558ad9f208c2f26ce7c716ef96\n+                44a12f904f4cecae04cb68a433db2d3aefc192009355e6f67f7b565c746c42d7\n+                ed6645ca837351fcc9534c66451e8e1fbc327999423aefe4f5f620c8e15000d3\n+                2c621ba53d572da4d4871d36173e83b1550cfa40a3a8fd7248d351a703389122\n+                a4b070ee87b44ec6543adea6921c567be95a8034a06a00c3fc102b8d2fa4e6b8\n+                00000007\n+                c792abc23c442a9822041aa5889816e9e127ab2323bdf2636cc672b47d055dac\n+                698074f11a96c53449a1ee30e1bc27fc8be61d85f4e5738725457d4cda5f7d62\n+                fc2e949005146d26590fd090a3c50e4141c63b8cfb14087affe86e9ad5207b4e\n+                dedd578be3e0a969d10fcafd1ddb134093d026a9055615e07ec4419786a82aef\n+                0afd2ee68e706169d7688ecfa37c8533d9f7af2bbb02adf614c680db745af017\n+                1676255f9e319f00501c43e4787e8349c9b04bf6bb3e7763fe6e40d6c21e6ec4\n+                d4611c5480aa2f8ef0f6ce3208748b966eb5d1c5945c54f8421ea3c2bf7602ce\n+                c1dbfc1c8408f84cbc3a2b7932764baf9c45e60404f60736cdcb8bd3397398b9\n+                c0e64e4555efd2c94f04a87ae037fd685591599d5c0b1a7197b6886df17c5225\n+                5ad8fec5950668c3dedefbe53ce5ede382633962be26da09260ee48b5d8ba67f\n+                900b54dda5630094a9fa85ae4217faf60801fd315f1f0dd58d30190fee4ef279\n+                51fc2c5633cb46f70e9ee9678e27ac8482a2e48415b14e5d1d3bfa6a86d5b972\n+                93f2d0a32d0c567002b03df6cc7a4c36129ecd04f9cdbc53cee787a344f305a7\n+                b1e61609f7df2745c75a88e07f071d1e93c868409b67afb114cdd539562046fb\n+                7d85f590ebe6969684eeaf7b42547139b50d64400bfe76c687658bf7195c9791\n+                00000007\n+                00000003\n+                052aa96293117df09356c119dd4b9edfe3d7c53d62d9855912682d1c502d64f2\n+                3b298883ffe67153ae1a23d0c6ca41bb\n+                00000000\n+                00000003\n+                9058ddc450f6e1e7b9ddf5fc65edb6c55d60cfaa3b3b1e62fd53d7286903b9c0\n+                63656485ed67b07407c84e1c4a34841d6e88aa0d6a22b262da4265063f3a84c6\n+                fabdc96e1c523d68043290d7d689e7bbd572880f0fb2a1fc2d247c622faad758\n+                ccf2f8751b983a86c29d721002f14050150227e594ab05b2f6ef605140511290\n+                dc213ca6db06bed09f33baaad9a0eb840c7b510bab2a31f7bc039f944b5b40a8\n+                1f047eb423d306a8a190dc1023c6433f39edfe68f2a11357e70356703d15a46d\n+                6df90861e10f84cbffb6efd1b3917e38f6baa2602f4a3d1b4bcf6ff6fc61e22b\n+                edccb0831a655474d5d701fce378142a307819d5a1e8156d655276f1f0b7d9f6\n+                a250c938935f86a2f12410cd5756526d70bfb17e0f90fb440e3e8c760b693ce0\n+                5c5cf7af31049ea0144f6ccfa9a2ca892df28504391c3f1e7fa053fdd29c9767\n+                94ee174f23267131aa62d5346150d9f5ed14867d86b55643ba6ff94b8065a85b\n+                a33499a09fc620e81a57a5d059e37458801464aa461f07ecb15cbd0239272919\n+                aaecec880c2f5bcc5c73af198324d06d9ec48d8a75a0d7aae6fa704bee98eb62\n+                77204af01e13cd80bb8ca5f243c67b02d2eb535041b0b41713c155fc5d5d2ea3\n+                61f27770cf31264a034989896edab335be1ec9b2c5df0106093162af112d1d7a\n+                9913a2edcb1c2fdf732b25c003ebd9df617cc5fc47d8413c2b3b34dd542a217c\n+                32e4aa7a283809f8011dcf59b639e4ca7baeb9b408a100188bd719446c77964d\n+                4865d6b138e9ef1c76d13145218c7de1827ef3599f8c9883ffc2d2412e48ef13\n+                4ef821e1d426748803ddcf325df9b49cd61257f2b2d3fe2bdc960b5140f5ddb6\n+                4696063fcaa699de790947a4ddbc8fdabd46f45d2640a07b434e304d00fa8310\n+                8667fddc1e04a671548ba468ab83dcc897ffc4b776d1694618ab131118cb7830\n+                ec1cf9e432d8f04cf48d8485d58c51b18d5a0bd795588bbcdf65a583f7615e32\n+                4d4a76cd5bfbfec3a0c37c97f9b5b1c5d8795e3149fb11096ab600cd9f77ab37\n+                0fd5970b641fefcf83870fea3d7deb9a4b0d4cc53a9d28330c07802d52635ad4\n+                3cb76a04b6fc09a7129da5a3d617935d144ca865c4a958d4592dd9dff080a696\n+                b2c7301fd3d2974df382562eaab239df41289c7a2b9b55264a879b322d693acb\n+                52c38d9a31559fae7592bc29b1a83e35caef47d793fdab943ff2e3f98a898c80\n+                73ef087f8d4419f1aebd705d2e0ae8fd137f7a46912c6a0ab7cf33f76d523cf4\n+                d27e5c2a22783974134846d923d8d966041d88f113451b439db3af3c90747739\n+                aba2de8ee7e1a7f1f84c6826cd405404c838eb387cba680b5c8f62ce8376c23d\n+                d7bf26386855df8f8d554445987bbee37597171f7849590db96281fba0cd9055\n+                92980b85e0f29f57cc6536e2172695607dee4f53fab7b123a34a97e12182e13c\n+                623f3ac68807718ec5d7806072dcbbf087e6f1e5b834cbbf7d8e85c3021213ae\n+                4100af501e8f77f57fd68c7b339fd649357b396a45eb2826fe06373928cbfe51\n+                f1de9fae833492e42f82d01ea9da9f4074ff22f5b59760d776241c73ebb0f05d\n+                6856dc9e07a2af219e38998afa04ac953dbeb0672b13277bca76ab02566d3f42\n+                2c6763dac87898373b69a1fddd92ef198f52388644be117fd8192b592325039f\n+                aac41b147a73162a5e297f82e09604eab0e06866450f8cebdffa2ff475e83daf\n+                e5eb9296626a895518872a97608ffe04f454a9e0098add3bf581f53490a1e2da\n+                324ee87fd47b7ed7551c0f222f475a57fd041b6e626979434d119525da68fbbc\n+                1e23d8affef88ad8542bd99f981c29435a3a7f3b40ad86426c6bf0a0948a15f7\n+                d8dcf09f4d083cc3c3ac77191afea39e3852f2b679bf2b3028a551e91bb41272\n+                bf59c1bd443dd6c71ead77700dfcdc2a9c686859b12ecfc1f75cddef50ed5eec\n+                fff75007bb26c09b836c32950104dd417ac60622bc57df8e55815204a75d9c79\n+                c13cb605dbc321cfbacdcdebb24ed3fbcde6d7d5b667262a89346598d9f2d9c1\n+                6e6f6886a55caf87221dc27a911cf4c389503d7715b1a791bdc17ba5bffe862d\n+                138b52768c1608f356dd8c88d5b28903a2295891fa139e4cfb16dd22ac8a755b\n+                d496864c95288aa4197ceaa54112e60ae999a8aeca4bef48602298b906c673bd\n+                93bb62da2d0cc7dd0951d304fb878513d2ed70ae39d1f56bb2c665281551ab74\n+                0c1976060bb67bd898868a2c245747a58ea6c1e71eeca9d1e196024b8df0314a\n+                96c278e9387e817caafd11c0cbd517b7cd3b1f1ca9c38a5741b7a46cbe180a9a\n+                deca3d975759eeb165354ca2ac5aa5bbd15841673f5aa25313009e570dc1e70f\n+                58d5d5eea6b10c36f0d5d09fd02021ab10bad7ea9dbd04ed909c7f1b6632eb03\n+                827d67ee609b96079824394bcb3e8f99d7ad77e27c5970fdf56f33097cd38c11\n+                1a095a7cf2ed76014b32a5a73e6a4bbfd86755d2b6e403671fe65ee3fbdf5c30\n+                3b261e3bc613468a46a8c04fb761fcf8b262b142ee4fdcee6a1a8c7baa76f442\n+                2880206b06d406ca77dbf75bf5c0885405e9446e6d0cc8251c11b2a9bf12900d\n+                a45b2515e240afa6d6091cc0618125839efd0e0cf55368b10f9ca04d9e18830a\n+                c0992ca32b1923c1b950215e3eadae1e3fd102f64cb7edf371fdf743ed553048\n+                7e7cc35827d94b7a2462fcdcc7e6eeacbf3626498d66ea1e7d98118431c7b823\n+                5ff390bc68d3063cd42bb63daf5db50edecfb9ce8a83cc5565f1d3ea2d843df8\n+                b899deca8a36e07b79a38be4c064af92b908658743c2808b94f8113490163669\n+                4b50d40b246e3f87930684ebfa0feee96a150e74d3e9150619ffa8c12db5d951\n+                2e55dbd4dc21e09d0262a3b4c9ebe995ca12941e0bc32091891c68614df8ef12\n+                bf34b0441c2204694236631cf4b1992daf2f4511f9f3adc29858dbe1100bfa09\n+                1a8343cf5987fd8175ede1a11e6a5e419d48d1fc834cb83e71e2d2b16a4d724b\n+                0768682f72e83797757e92a04fe738db302cc39622b33ff37a6f3f39503bf229\n+                51af13e28a4f1210f8b88c5279464dcfbfcfb8c2cff3d2ff11321b7f5f1e188c\n+                00000007\n+                ba78a4b874ece30e24b271f4f1a44db792a841a7405e270accf650a793961fd2\n+                09499109aa03394808cab26bf07cb44a856b76a52384c2c8cccf3e343a724d4c\n+                203d131c29a5060c9d518b60ecc1754c52c7abf223683192a40a6831bed6dff0\n+                80a26b30e52b268c8a9184857153af60266b0eb40b0bc255d0e96649c63ec359\n+                6686c1f11ac84488c6ba20f76649b257b6a3bc60d24d6cece4f8396716455dbd\n+                9b9df1ad3ddcd6db59e41d67d52d6648b5da92929d61a17e5b8c9b46246c5101\n+                ef8f4e1b64c8fd471deab9356fb1f5679ae5ac71059a1d54f7a1d72705128c50\n+                b45902f8da6e82e2851bbcd51d8dbb8f824a222596648dffbd61a1d6c95f9885\n+                68500d1d3b084594e0a5c3f3150ed15c4ddf484f45f1a615d63be1d7aebca110\n+                e80efb7a86132d6a57d296343d7c784f50859c9072fdd30c08d71bff9667caab\n+                65b044ecf87e90d7943acb7b5f26a26562ebb6b0a2aa31514c096125ea73c2a5\n+                d17cb68392d92e6c1ac7805a57466a3738256bf8de6cb3c5ee944f45bd4f1d6a\n+                d9977f46826deab2abf93378819376fdc7b61cf344d2265b9f8cd22a1632f738\n+                244569171a23d6d593bd19634758b7ff9c8731720e771023fdb0a6241dda4f61\n+                a4385d3b9c5b6f6bb018324528aff429eca9c1264de9ea434a1a90e07f69015e\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4);\n+    \/\/ LMSigParameters.lms_sha256_m32_h10, LMOtsParameters.sha256_n32_w4);\n+    public static class test09 extends HSS {\n+\n+        @Param({\"h20_w4_h10_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000008\n+                00000003\n+                4f9fbdfc21ece22a13965cd32027f6d4e5706e751440d214da485f202309a24c\n+                f90dafc3d8f09f797b1b6cfa3636e18c\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                7d5dda179d7f33bd79840ecd9c46c0274f93453448b4b3c8eee74440b900b7e9\n+                9da9eaa94691fda7716fdf2354ad1858df27d29b79c91cf30423c32d5e093b71\n+                b0a141ae160487d8a4451622b5ff1488167cbbf342a876d53671eb0272c6d1b2\n+                ab8d8fe4b51d50ecaa977f379903c9dab520df31beba6f6dd2a310b8514d7a3e\n+                c78e2fd0a33369da3d5e8fde5a3df3669474ada32db4854eeddccb9daa82270c\n+                9f1f9d7d0f45d6b59db36355ccdfff8a08ce7c16cc5c15066b86fa955c7036fd\n+                5706b8560fd06fc1612fbd2aa9866eb40d962bd12585885321fef67dd80c3efc\n+                c0a9f620276038b0850e9598729efcec780d56a67f98d1392426308adfb4d8fb\n+                e4128ad38aad50060186b40fd63eae216d8761ad4b66600f90ad39dbac2c4771\n+                6986754a8c505c0d33906b8a66ca740f68edf3ea55c9e0df72e7f5f1c3b6fdd3\n+                67d8b0205a880a3ac1c9d2a9e48616753a0b9b34d63a8ee4b7f908cbd0a8eebd\n+                a55823c0abeb1911d369ec16414ff39a2d1068ae1331af1eceb6ffdebd3bbc6e\n+                e9ce74dbad7e6fcb362d111a9992b875d4f993a413348d91d7f217c0239b52f6\n+                0140cf51777848ddd04fd1b481033b9ebcd8e4b129db0bb801d99d05ac2490e8\n+                1f858d6f35ff29abd35c40fb650f97a0b32061aa7983822868119dca5c2c78cf\n+                a4f76d26ba91a56bff8c6e500fa35aaf89cce3ca8dc5c9de98a89981cd9283ba\n+                ceaef88dfd5a177d2c71fc7c1131c6ce74be3a2a7a673acaa731482cc4bd4dd5\n+                8f0de26586c2a8863bd96d505821b7e78f88a0560860d022961e6d0ed3cbe9d1\n+                22dd27f77208ad85d12dc33ad819e394841ff0055ce1649b20cd00af1942c76d\n+                14cb6b645d459caa7707f081f47b7a327b3596ab1e3af5b741e503f4888f5261\n+                83d0607e274c4b544e72417aa98326de9bbf51b035bc70e75211b084a947119d\n+                d7929a16d43cba2663a8d2ff8934ac0ee157f01c13fad772bdf15c52bc1cfed0\n+                24aad7e06e3fb72f7ba7bd03860b804ebbf3a78b40cfdc46c147a393d8f88ed3\n+                f921398995697a51b5e3cd8a3b363d03f60f531e3f2d7a8205bdaa4e652f8dfa\n+                42a17bf406580fc7d2240314bc3632850352a9212fbb56e2c4055634ddf76f30\n+                3c9818d2e806b3474587c3dd95d871b7b7b9987108d837efdbafc10735285f3f\n+                3613cffa7ed61e402e08cae00dd43aae21cb70c03cf1fd0313c365075a2927df\n+                a2af481b3026b81aaba7652b8c27a1bf64df4b079ddabc4e142678e86021cfe8\n+                35347ad78e3877a35bfa9da1325935bfd8ee76437c95e95a9199db1949a1d034\n+                2ad2e61b7459e9cc67832093240540d8c1c69af238f5ff9ac49829c5a06db24c\n+                a0cea539f2c58a52e256f404bf0123d03979c32da4b35847f01b253105d71a87\n+                86972babf78052003d2f1183c5bb1f986de6b443ad2b8674a8a88cc6dd1c658d\n+                4efa74da693e5194a7c8eb68a7ea8313e7d42ace9ab5f15e2c536eb4c0da7579\n+                5e50ff72b351c773c603cb749d6410608fe64e191715276fb36a97ee81720d98\n+                06209e53f728bb3be9021a5ac2aa157616b6c9f4f587916732cd682359c8b616\n+                84d3f0ad309c03a3d168f3927601544c622b99a3ddf5291e2500126278122794\n+                5dd8244314b972e0e6c303089055a449aceeaad870a1171b3a93fb329cd777a8\n+                9768b54671a3e87c9861d2c4fbd68971da747e0e12a70211574f5cbd8c98df42\n+                c7439886d089c3515f30ff5c5fb9e1e5a7f0d901ef76a8b5b290e0236caea5b1\n+                bef9f583c7d7b07bf793fabf560ebda31d56a19707fec2a476842dc8171faf3e\n+                b572452a092de32ce195160efe384e7f5c6c5ccfd3201dc34d33fed0fa0fad24\n+                e13053dea01c5ef210e1d5c2d77a94a6acc3fc7d2bb7ead6ef69c5877c1d1587\n+                931fef54754681e96904f5c24050b8d7617843674f4b652bbbcd19860da98aac\n+                c1e00d9c6cdf4a209c8b530b243b7b8f1646b55f9c4b0a35b0133c67eb16b7c9\n+                05834f2e392299ca1c61863c89e333f4530c25c7765379b69fe8ef30a644e746\n+                f09ad8a6090c2548e9294c1ea78695b90639e20de1fb47d3f378689254780b7d\n+                cd4bd7dbc66b62976a5e5df5fe72eda740fd4e38382283f1b335ed72000f8e30\n+                c0de5eb9256808cc5082611a10395710c17861bb7513e52ceb23d005bfb419da\n+                440025643128f9d074351a7ac35e92e9d9eb1520eecc78fd7a8de4919d428642\n+                e1641c269261d4eebc817c82d5b59b3e34bad0a081aa549c02ad7c7c1e8b936f\n+                51eeb581e9a27104a1d210b49c8882234b2de3a655ca4b69b3f72bda9e910875\n+                8cf881ffcab37b11ccd7991b3e12493f4a9e237c3184a838f029be09ac3d511d\n+                12dd84068c476afcf6d18c9516ae5800547b26d0a7d366af96125775f5fda02b\n+                9ac818f4d2209610d48e86c1f57bc71e31519363ea8bcdae791a88b50a84420d\n+                020b627b80424dd377577f0665503dad7d16d2f7532ac51b7adfe5704592dc76\n+                dbc6a32081f3435723b51a7c61ab2b8ffd27179561a8debafff46f1f6ba6a7d9\n+                79a12962352728770024f016cc28caa3de3e7d9695c3c0d2c53d45b7b57e797a\n+                10d1b64e37fa8dd2981d010e95fa9c75619606aac70dacc633d7b415f440d4b7\n+                37fe944f936990afa5f0149776483ead9759af9984c0d37a710735854f526e9c\n+                fcc200c16bc62b6c0a7d3c18189f721eba9b90a29fca15de8d084e44c97cff27\n+                f28af689a7670286687cdd40e60a9f68e7eca10568d5a02561c3f437afc57ad6\n+                9dd6505b04690530c9ed30c5278299a58057b7a24581a0eac0d26166d3f6b49d\n+                796f516103f61ec8f5a6e4307f97b77fed8898190b744c66eb661706fa71606d\n+                5692cb08973738cc0ea9a247590f23dfa8f2c0d406da850c8fcc639b0070c2ca\n+                d9d4c42a42255611b781104068ae3d09e94a7b2b46df774eba4dc6e712509a28\n+                2735e898bef0675f988568bbfdcd09720fa6e2afdc5590ecc9676faf12986f10\n+                9eb838e4e998968dced593c337607f6190b1f32a3cf5aefda5043cbc57e0ac09\n+                eed1660ccaac44af2c55b12ab13a7ef3763eed79cd5ab1b754cf15883c0ce966\n+                0000000856bbc3dc1996d6154a8847e9800276e50ab54db3c75f879f03c48c91\n+                7cfad26d2199acb69cccc8149332d3fcb94f076e55818aa59dc477ecf1bd16c8\n+                f362695da854c55030e90919b40f9aad3d43ead32e97f596c066eafe89d4a8b0\n+                d228e9ee47b531dcf1337b4e45c4ad21ceda14ee10f5f60ad341ba84bda14500\n+                f4c6a8f5317bd98da8713f1d76508046c62decaf44c61d752a9ddbb539eb5844\n+                b4ce4a5ddbc1a050472236a437713603e34fa0eafd713017b932814b6b24a74a\n+                1ff7a6c5d47b4153e2007d87dcaf47573425647f7e6f5f032a934967ada85b7a\n+                8e8934b8aa5395988a6fa50261b8ce6b7900bd6a8bba2d2ac54cf7ce04a0718a\n+                5eccf4551ae37c7b136081189eedbc1793ae7dbf368361f00b1df0cf236bad37\n+                b87b7cec97715aa6daabdb2b30301c376ba7ebb44cd9e2366411aa3b3a1a351b\n+                46c45cafd23213e5c6aabfe59d622904bcaa84d90fa9da47d522bef92a523a84\n+                28e1fec7cac1137532af968d413345dc3ef38b7d6e5f83594f31570ce12c3d8a\n+                2a046604ec433ae94cdf82eddd28fcf603fe605007420fbf34c917e7104fe1ad\n+                1ad45d346c2ac6058bed0f4c44d003e093e4e686a9dd4d80abbb716f7363f204\n+                ede2d0aadbf882db09bc75284fc29b6208b3b8d7110cf847e1cd9a1e04d14cfd\n+                23accde55a2975b5537614fe1809bfa01783c0e3bdc821eae70a5e4ddcf66b4a\n+                c27a3d76e12189a03eab3cd40feb892257213b1318bed0efeac00396546f314a\n+                97b9afc7eb3ef845b4d53bc8593184d734ec19c93fcc0431c5d74afc8f9eebae\n+                f12c7f186a464b0d1b6bdf7ebba592ef9f6d3b3af332a7f100f82619535d7ca1\n+                cd99e4134b50e84ea167948c244f928304f6d008bb7f8a10b218f46c227f5255\n+                980ea31a\n+                00000006\n+                00000003\n+                5490b78c72751e0485c63a1bea5313f0462907f953a8d3ce7e585426c07e608e\n+                33cfd90fa196727a43edb3759b712afb\n+                00000000\n+                00000003\n+                0cb7dce4975f968cae1c1affad81ef53fc2d68bed7d3c9bc83d85204a209e24b\n+                d73256ce79a2e8d2d0ba728a526248518d5201250ea5f831a58c2d03e7aa2fd5\n+                f4eb1081f5e8a7b49ab360caa46395d5c48a527cc84a2db4476194c13e6cbfa8\n+                c11e825f438552014a816e147410daa4ee0ed43c696e78c704f36e924a76008e\n+                e231372d7f50586276da32b3b340d5714d3d1ad1e12e12de00d0a67c61fb6226\n+                5b5a22baf87d2f22d9cbd79b2bc7c9cb0f90a034dd861f50cde7b41ba64df79d\n+                b6c288947156685454739621b526565851d66ad7a47929a97bf82932664db663\n+                550b4cea602c3afd0691cb363df0f8f1858d7296bc99d490df0ca5b5bc5d2a69\n+                ec20f1f85634b7a87b82b4d293d6996fa02678af04e42801871aa56138465452\n+                7f699809d424f62b3d0e4a4e106c3dec086854ba3f61d0edb799612df24ea4a6\n+                a07a7811abd4968500e344948d1293baf4d6a194905d5c526b16e4c4ff28bfb9\n+                b9e03d7a9f184c06441b0631f781f56d5a51f62f3fbc7c3769e32f68d623f406\n+                94fe7179b89289c24493041f4e2c653173cf3a8b2051453d31422bdd50af4a81\n+                2e7bdf63d04765a1ea6a397797a827b7c5ac38d58a7f6196ba5db478dad6c031\n+                143f7684b771a4fb7999152a69106c72642742d892233147e085f5e4793850bf\n+                a83660db5b53df4e67edbc37b4a6a076c419e02ed54b923d708f16d8561c5abb\n+                a10fde6c6043f88137bf80672273924336a81be63d44ec26a4afa761164a0c09\n+                640b1aff3ba0f4dc43d16b382d1135a57936a150323ea3587717a3dd0a8111b0\n+                0b875aed7c7be5250fd2ef9bfb968293ca8121d227efb07b8dff9dc819e6a5f7\n+                459fa5ea01f62b2a8e278e9ef2a7029b08df3a76198de1e840ddc15533195403\n+                197be0c8d1a086651e4dc09e3c59f4b3352662800af531e927b9e52e8a1d0631\n+                1df831a487760cfd6e7a713bdfb2a9326bea28f59067a989d1189889b8a6b9c4\n+                011f0d28113d9f6c2e506bd120bfc78223f6415cd657391dc3f9259e5d9f44b5\n+                4eae3ffbe634eb9880c16f6d67db25f0881fd59e5796c9152efc63c7cfd4e3df\n+                95b98f5aa6a9bce0615a34bf15114dd65e0f44ecc7835754ad6ddddc0f2b69f9\n+                2c41470fb6dbfcfdd1b61292b353665c6fe8601e120ce412bd643049802e3903\n+                f25504f80be1778e24d9166545e2da6552d4c409093a781e33447179fc260164\n+                8598234c932642aa4c307da2670c70fb4dbba29a4aa21fd2ff302364cb13bced\n+                84c0da69d60ce846095ef042f7213be8ff94c23b12e5e5f7bf4818c461355383\n+                c6fbb50e0988f992d82f75db4b98246aa6e6d50713c3b436add3b95670df646f\n+                ebe742cf69c6970b93c7acc86a868c979980e2dc313afcaa67d31ce5dd0c5d97\n+                b20f6fbaeaae2a1b2126e259c2d0b3268eaf96a6a42e3eb0dafb9780ec17c01c\n+                40a85efc413336bcae40324924a311b8645e6554004ac20d4c6334a505ae5c7b\n+                abec7871ee593d9ca8cfd9760417966892d916d9125a81822f96d3d3fb5ed343\n+                a6a8ac47a863dd3bdf502d9d5ffa040398788c446037b82e00392a00ebcc7c7b\n+                d81e85e5986422735ff38cb189dc7c24510a7287714d58aa7b3e645a9cd5bd44\n+                fe4a3573844f5df0ec015c83a15eb3c483b2570de8d105a1fdf6dea1edebd26a\n+                1b4303814b30f16bd064051d077f07e97e825372ed93a10d2022d2a8d93c085d\n+                862ad6006364ab5742fd3e3451ff62c1e8c966d200e18f3f55d79d1ea49d62ee\n+                cd2e2a6202cda533761451e34b691d45b5a6b2227856dfe27cfe777aa9069717\n+                3341aaa79f07975b73cf8c5a26baffaa867f1d41e7d866895f1ac652c19db1df\n+                3124d5d89668032c62c6862aefe101158705e3c735bb1f211eb5faccb167a11f\n+                5f2e043d8c7ae469a28759f25cb477fbd237c44a33a74dd89723aae046ae56a0\n+                b15d415184f0bdd947961a7d3e66480cc3b51d0ca2c1db86c327b0d3270ba864\n+                ed76406b22dc6d107bc172fb9df3513e07ca6365389e41f4a746f56240b921fc\n+                464d1b28d047026abdf970f2767e114da3ff0355a9ab0932f3a9a3097520f9e9\n+                3bf3b03e9b460a7846afe5f316188fe17751857d3bb43ea3a506c974f5d0270a\n+                e519d5ad24b407372f0323730bedcd660f9abb0acc1221ca9e2b0259b1cf4ed8\n+                c64b74776399928598a216ce6ef437056bb752d437347978369b7a578bc41077\n+                d57a6aec7258aabd4c623c03b1c03f5c73931e675667d0c10970f5c620fdaf4f\n+                80d59b70908b30c7a40114d67e92eb93ea34944fd12d6cc7df10bc0d1227999a\n+                200d3a9e92a01a8736ee839d0e72e59a709581e58c6bb03ff7585171f534b97c\n+                4a88937cb7c6a6bb9b1572fd3c2312057ff5986fbb4119a440600496497a91d3\n+                ab0e2b5a744eab30325471539fa9116fae25fc74fd17eb1b75329850ceeefc05\n+                20fc7dbbb35a679cc0c813a19abd5a5730d5b9f0c0bc08d2bbcaffaca6e7b670\n+                1b9f5dcced66b888e93f27c1586e3eb3637e75664f8b88fa2ea8408cf5b90a0d\n+                c9fe016cb773fc85e0b4c5e37a4dd9320fed177e0718862be9a1535274b70668\n+                eeae69369e3746dbea3e3b459f4d20d4fdfc534d5c79517b9c74d4095e4388a9\n+                b3c7ed169f83a079bf4a883cb2bf5d88b9196667f3e2eddc26ea24f192e5ee3e\n+                f68712a78d1ad086eb776a9be9b0301e50e019fb78c70ada132ab3a5bfd6df92\n+                e8a78d837f96ac5e7ff5ae5284d4add69b857bbe06312ac0f579d7f1d537ef5d\n+                b6cb3f775f6a40c85a57ba0f999196368eb0939e68fabfc913d29ff979a1a3e8\n+                74706d3448d12c2eac1f520d5c833138c67233a6109bc3f13d1c9a763c795cbd\n+                cf94a0682257a16401deecb7dc787be82ebec9938df10b1d7ffa147661b11a13\n+                2ed1a432ba87fd76a5be4ac11ebc04e7c151d37b9031e35a9cb7890c2dccaf88\n+                786f3186acbc3fa033ef3fcdf1a670453b07bb1e4bd96e0bd77749ba9c1ae577\n+                b5499b24430d7b3d3786a4dd04c7d69fd052f4a192bd58048b4aea01ad7a14a5\n+                45301c513045cffac021dd9a8640b184b86f915b5967a0996cd6e706e776da68\n+                00000006\n+                180968d5c2d73bddf40eb18e436c809891d2689205550e01993e1b9c0c767575\n+                2dd3d8c2c702aecf34ad3ef16e03b398f1e3d66e490c3d6e086bfbeda5efe599\n+                4cfa5b469a145858df60fed7c71fe8c1fbdf5fbbe5dbe85c9a51016bd9ccbe9b\n+                6bea3b494da9d308c8a85db2fa6848c7db1881615a99b452484c67f96be55785\n+                7b43336be8ff52c5ce5291806e2118337f9a25b26029ec4d1d8023961a5424a5\n+                ecf2b18beac1653790736e6f6a5c7a95ab77caf54ea06c0c11ad6981a2af0b7c\n+                a3e964dc09397caf0e78a63d57aeb5c3acb9c65894b134092a2643d992d53107\n+                5c43c911d5577be8fe88fa023a3e36f32f9333e3c6207ca1b0018c0e0f389827\n+                a7a4cb92d8b054a206adec09b35ea6615069fc7d49132549bab5548b9e1fe61d\n+                2b7a9ba0d6d3e0336f17f3caa18e0ea19d6cf0a9c0e48a83cf325369b6a091ba\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+\n+    \/\/ LMSigParameters.lms_sha256_m32_h20, LMOtsParameters.sha256_n32_w4);\n+    \/\/ LMSigParameters.lms_sha256_m32_h15, LMOtsParameters.sha256_n32_w4);\n+    public static class test10 extends HSS {\n+\n+        @Param({\"h20_w4_h15_w4\"})\n+        private String test;\n+\n+        @Setup\n+        public void setup() throws Exception {\n+            pk = decode(\"\"\"\n+                00000002\n+                00000008\n+                00000003\n+                cc453a482bbabfad998dbbacf34c0d89151995177fd38cdfa301b645fbad1675\n+                ff8083187b30a36242b11bac4bbb7e0c\"\"\");\n+            msg = decode(\"\"\"\n+                466f75722073636f726520616e6420736576656e2079656172732061676f206f\n+                757220666174686572732062726f7567687420666f727468206f6e2074686973\n+                20636f6e74696e656e742061206e6577206e6174696f6e2c20636f6e63656976\n+                656420696e206c6962657274792c20616e642064656469636174656420746f20\n+                7468652070726f706f736974696f6e207468617420616c6c206d656e20617265\n+                206372656174656420657175616c2e204e6f772077652061726520656e676167\n+                656420696e206120677265617420636976696c207761722c2074657374696e67\n+                20776865746865722074686174206e6174696f6e2c206f7220616e79206e6174\n+                696f6e20736f20636f6e63656976656420616e6420736f206465646963617465\n+                642c2063616e206c6f6e6720656e647572652e20576520617265206d6574206f\n+                6e206120677265617420626174746c656669656c64206f662074686174207761\n+                722e205765206861766520636f6d6520746f206465646963617465206120706f\n+                7274696f6e206f662074686174206669656c6420617320612066696e616c2072\n+                657374696e6720706c61636520666f722074686f73652077686f206865726520\n+                67617665207468656972206c6976657320746861742074686174206e6174696f\n+                6e206d69676874206c6976652e20497420697320616c746f6765746865722066\n+                697474696e6720616e642070726f70657220746861742077652073686f756c64\n+                20646f20746869732e2042757420696e2061206c61726765722073656e736520\n+                77652063616e6e6f742064656469636174652c2077652063616e6e6f7420636f\n+                6e736563726174652c2077652063616e6e6f742068616c6c6f77207468697320\n+                67726f756e642e20546865206272617665206d656e2c206c6976696e6720616e\n+                6420646561642c2077686f207374727567676c65642068657265206861766520\n+                636f6e73656372617465642069742c206661722061626f7665206f757220706f\n+                6f7220706f77657220746f20616464206f7220646574726163742e2054686520\n+                776f726c642077696c6c206c6974746c65206e6f74652c206e6f72206c6f6e67\n+                2072656d656d6265722c20776861742077652073617920686572652c20627574\n+                2069742063616e206e6576657220666f72676574207768617420746865792064\n+                696420686572652e20497420697320666f7220757320746865206c6976696e67\n+                2c207261746865722c20746f2062652064656469636174656420686572652074\n+                6f2074686520756e66696e697368656420776f726b2077686963682074686579\n+                2077686f20666f75676874206865726520686176652074687573206661722073\n+                6f206e6f626c7920616476616e6365642e204974206973207261746865720a0a\n+                \"\"\");\n+            sig = decode(\"\"\"\n+                00000001\n+                00000000\n+                00000003\n+                ae258cca017619f7c85179c0dde1f48122fe5b3adcd5ca14475308c6d6a87c8c\n+                6cbbbca7a2dbe83a7fa7a0814e3d692b66bec046ed590831e695e0391c0028c4\n+                9cd5e4e561c983d1640fe534964a4e5725705a4d907f5088b265e329011b8047\n+                330fcf0030724ce62edb5382e59af394eee06b0fe84d95ff8d22b0ba06c31876\n+                b85d29135bd4291f49db0f22c1a304ecdea5137b6b59c49cb053c6ec32b276f2\n+                9dea3ffe6c10f3e99e84b00221bdf587f703e81ffa90e9835839b693fc3e2b06\n+                1cb47c8e3392750c4f53461e419e151004df01da6d8bf8a7998e88089d18c487\n+                d1adabe4050214ae3c5aff0b2e7de19a734d6cc06ff060c5ca4ad5c68178fc7c\n+                bb66b7de65987ce1dc966f1a2f9fbe301f43e6790df0fa452884b3b9ea30fd33\n+                689cf76ae7eb4f6c79f6fae9e89cd9d0349928757dcdee074eacfeb3e1860d0f\n+                1e8f335be9d0ad131da1932730fbe5997a813439920d53c4a36c6ebbc4a2b8d6\n+                96fd511a6b92404421674f1b1b79298243c60bd524cfca71057377b0d0c318fd\n+                341759a91f4b47f5b0df61d1eb1533982707970789297a1af0bb2fedf8fbd582\n+                87708cc4c3304246313b323df92f36fa6fa516c333197253c860b2ea4eb92cef\n+                aa33311f2b9b3af958d67a9e466357f671a1255530fff1c2a7d976c26837bfd5\n+                d7d9d6ea5f87c81abedf1e1b83602250e2226f54eb8f3f1e00bcfcf241e655e1\n+                bf79b0d57b947c196f6c33360d303735d323406411416cd1fb2391d3adbbf0e4\n+                f0ac38767fc2e9ebcec97a5c80712bef5deeaad9c85fc4d024ffe7cba0608c98\n+                90b023852af96a6dfca090187a4f07447d89b1162d0a65e4cc7e2481b057e199\n+                0ed2ee333d2c4f26c6321e2b98017fedc0b42202caf469405678a63108359387\n+                aa240fe210d833914423e02d892fe26290dc2ba89bebdaa2273fe265b5d518dd\n+                5b406c33656466f865c1ffd671b46e2b9044c256798afb1e1d49dfc025aefc06\n+                d6cb1a968c5bb3e200944de6a81bce2ee450559fa3e302effeff2b4e919539ff\n+                3bbeca0575eb8abdc635fd330c1606b1c810029ed55d8a71253ca89587762629\n+                1aa537e4b0c155e7acbac37d1e447586adc56ad262b0ab2421291a28b4e664c1\n+                70750274d82b7850fdf745374c2c2eedf9828300b3b2b9f8d2d774063658ad05\n+                92ed8b8a26e8021ed63f413996d1c12c6a5e80a4fd1f6ede5f431974147d9116\n+                c356e49fb7cda7d35bde52b1c0efdab1dfea8db8b13c608a5545723ee3611456\n+                b21da6a343ca0c432a2353dbf926e2f3227e9659618cc6b46f46da614666f33f\n+                1d979c6d838b678fb027a2ea5ae601592cb28efe10918509418476639bfd1f0f\n+                7dd8bf91f7b28499dc72039218bfe37595e1741942e4a2f640a92dacd809521d\n+                df34aa2b549d2b666089a9df02d963347d565cc5fa1af7f700237db8a57f0cee\n+                4be997ef40f8ae0631877d07b71a4a76d3f6f53a737f14e2fb0f2222e8649144\n+                c3f8ac33595fd9290a2a0345eb1e4c06187ca4b5ac77098e473a07fe0cb58d88\n+                1967f7f645ae144a289744b0801165e9c47d5137f79d3538d6f3a45c962d06a0\n+                13248d125cc52ebd2f3e4ced0d7c1e2429425da6b6aedf96db2c2524522e95a1\n+                dd83db37e92f782b6db3c84ed3f55f32600003d9602c17b6280fc735787f8381\n+                853d02d4b03a97a9404bfe6cd4c58c1a67a70298f29094b454aeb1bc0d59e0d5\n+                e24015f9257d28554905003a687444ce51b19b7e46f4e56e899e3ecdb9415119\n+                924b0a28f383b7e8f817c6430dd9c7b13b6f93179f77c5678fe51098e4c0425e\n+                7d44cd2e82c07bff8b8e99ed08d86982ef7680f8ac3ac2228dd286a1acad546d\n+                43fed64175190ecc62f1662a2f2c29cf2effdc9f9a18e681e96cce1bfb41de22\n+                5b3c02ba65b4c5cc5591d5b17b64a3e8df530ea10627ed29d096f30934d10954\n+                a642548ff04651c9f24ba9c0496bdc1a8af76afc27eb3dc9e28247ab5fa7274f\n+                0cffad5af2cf50ecc35f0b466fd7b8c6973d1ace0cbde0d793cac473ff151aa8\n+                c9bc3d26beb8d819f21ed0ff1fe6af5be4cb4c61e1ed6897496fbbba14f2719d\n+                721742fa7249dd251e501b98936ab43d0fcf4b7a2d551471d3e663595e19e235\n+                674d7d525b6a5ae14ac45913cbfc51e80a7fe351d0cb24a8af1b970d309517df\n+                7a7dd6b12c6edbaab5addb1711abca1c412eb7270e9a8aeefbf7cc5ca22436dc\n+                75b0b5989e1c25f578f8d0aadbde0175e67b14ab05a4c5a5e061a030282f5415\n+                4eebb5a717854b02877ac1fbbb732e52b18dbecaacf16bbb74954f83c0aa470e\n+                35d099b7efb1e17beeeb87ec0b9e706c331f1b20f0a903dec2b7ca1c196b1d63\n+                e804513d3f474cbe6f9bbd2900b79b073011004c49d20f7420a01b7745d490c1\n+                0da63786119d895d58b44eb066d80c88907aaa211dfd82681634be98400099db\n+                8cb82b6d6172478cc2e63d4ea6dd48b47702b24b6fc7b49e09d87b61d15b59d0\n+                39a6d49b3e4896ebe0c83c70ee6926d498ace6148ef3449a7830a7ed4923866a\n+                3f479a708a7dc319c1161d0f29cf425682c389bb173f7681c193ac982c1e4012\n+                6a122b2c6e3fd20906c2921987b2a20d21c722c5fe899fc15089e7b7ddce4262\n+                be8acc27fc4b4b5176740f8f3adcf44240fd1d92c5b1db869bf0bc957175fad6\n+                2d8ad0368b9b47da61e5afffc4ed80ea49890178232dd021d94af7b15bd45059\n+                67bd91eaa2844169e89320c92914e27eda9800cb81b8ff11a52043439035a275\n+                53cf146c9c765b3d5f13bd348475a8bf9b3021168364b7cf0b35b4a2df95adda\n+                7d1d386021d0ddf9193934ae4f0958d2ef8b15a0278e5234aaa976a8ac6acc45\n+                7fff27c4d64da9d374ddccc55285069074ad79bedfb606c95a5d294e97a49571\n+                e4b89696b83a69b4c65568e7ba4b4da0903f819a75ee42f6539b4edd45a53dc4\n+                07c7028834837cb1665050f13b3f69560dec7f042d3d8979fb170257bc024764\n+                627d369086f127e1f5a95f45cf49817c2c699b8d0b20113259ed141e6c01e23e\n+                41a7bb7415f324ba3710534126db40da893b8df672bb16a752e873bc3203dd83\n+                00000008\n+                24bc09be9c410f127964bbf6430a7b42f53ffe22f04cde135d46a847de0844ac\n+                c15c1197f938dcb5adfdcceeb52f95ca113148d07192ab76d83185054df0b38d\n+                8f95cd789b916bf8f7d4b7094802df6ed52cc0573756df7258f12e439cfb1037\n+                01dd72bbdb60753be01822a1ea210eba7fdcea2c9736e79e11ce2e3b50f21a4e\n+                0d84d9c578bfcefb4087146a40c95922b2dd69d29103d9f50fe3368b19015172\n+                36922e837fe8bd50e8063e5f0c2d4a961f1816bf7a5b3eb7ba63761368cae83e\n+                f2fa4e03491acbbfd6d0a6048e3f2589e67aabeb32b3619085ff2d6a810065b0\n+                5a2f5526fe1f188ee80bdb9788f68c1e93cc2ea104e404faceef91fa6a28e27c\n+                e6c2a6a4b03b81c7ca9ce94f06ca7762cb344bc738add901e6496a3fe739343f\n+                aad8396b832ac93f039adad869401a2e590dda2d9c571e136b55053e8bd17af4\n+                2e5518ef8b8dea3d9fefb811e7248961af4f67921c5812bb87c27b22d1384109\n+                85f1f48d40e4c86a1cf7b1d47cb2c776aab2b980a8a1a5e14f6a6c3e823f8b91\n+                9d7de7705ba30357aad9b1d5e7c3404aee1fca2706bb97e94ee56ce826d631c0\n+                d03a93e676a557af5b3105c9cce0364907f1c7520a3a9d70ceef18bc86584df8\n+                c707e48982dcb6221aec3bbe75151d0c50662caf1b401466f089f464b23e4b10\n+                77f4c2ff6efd0ef42202fd51494093459329eccdf895e038c3f7e2325775c399\n+                4ee435f799d7cf0ba8308d018a1c748a5b96786d4b1090547165d30cd9e50c9e\n+                25122424b4d89b5f13949af9eadb7e9bfb95820bfd2053e339dd154593c8912c\n+                ede4bb64b3dad525f55bf6640d99876654d3a9666ab81b38f1e7d41036a2930a\n+                3b4ba370e6fb1cb4436eeffb3a1f4029eab69d47e328e3e50034e3facd1ab396\n+                00000007\n+                00000003\n+                ff29b4fe1b544b372b2922adf63187d1a8186efd415d82a993a79ecd884987fb\n+                984f03f786948f53a3632e75f622a334\n+                00000000\n+                00000003\n+                9818148e2b3f0b1b92424b8df20c31aaaf4d2d49997d481a2be32680e62eac63\n+                4dfc4d390876d14599c23d59822e0d6f525a9afbc8319f75de7370043d33e413\n+                7b9f1fbdaeb3e47bdbe29fb7e3247ee5a1c637bd739be597e5513b81e5b717bb\n+                593037bf97b4c1f216566a944bb19bdac86a5be82fc34eef1799e07d7035692e\n+                687024660a3a83fe17d73c919513c12660edd8af23975ba3816d027b7cff5e5e\n+                675f5375bb1eb6eed9e5cc49b962a97b1cf41d79422f2d8e290ff119d1cd562d\n+                e4f65dff4a7408b2eab21093d096707cbdbb70e8bf6394969e1e51700a500a98\n+                ca1fa371d96eb24b359db9af3d2a5e125e33b87edc22eca8764eefce39dae0b6\n+                db5504c256375a7b6bd8ffcaf48a1fa9b246bc9952f8374d8d65cf22439668b0\n+                3c02ef6fb4a1512dea8d7c38cbd8946114bbd57a0da2ffff326bb83873f4ea40\n+                09270671b0d9a88e10c9552ac580160d248daa7bc3a10cb393a1a2aca8ed55e6\n+                d6983861830557e7001d65d8656c07fa37b459a5bc3ff26c2109be9f395d1307\n+                8e27e75f85f388562f555060fc040650be7c5a4984bfb41fdf0ebc2da22a8719\n+                563aa522fe36af768d95d49da30c899f3409c8a6587403411eaf032a84354039\n+                1b136a795a0b3da15351ece2f62b7cc15d8f9e3bbacf29bd73e96c9761fd23ff\n+                ed75c8131721899b2b314c61537e3d324706de6dbb4adde305943ac6a2000e5f\n+                6e193f83b9381ade4d61a9ecb2591ece400ace7735eb6e0958d7d1c9b0ef4990\n+                2ec4592c935303c71049c44a518d65537cd903c95c37811501028a20b4aa4030\n+                2857c970a589260073ea093eb913a11ac42c67034d27fed38b300eede2ccb18f\n+                7df10d09d9cbeaccba52471fd01d42361343889e5725a7f2d23c723517337e94\n+                2f53fcefef8c4f091fc1a02790db7a987bdac6f67382619a84c003fb76f27e1f\n+                f070bb8b7786ce47d4455de311230a0e1dbccbb8bd37c45f36e84e3f15c1e4e9\n+                daa1b4a082f85a5c2c71371e39661792284357a7cc40451e39444e8c352185d9\n+                e7aa1e7524a1eff33b5839c2247b1430a517db6ef4963b23a1579a3803c0d2ae\n+                3568e0d83d551eb68dcd301e75f4cf38792cc504a94559c1b1a929975aaa38d6\n+                fee0aefd1aa4c99cb1412736b2f5978c21987e651e391c5b1e61cb84d92d3806\n+                cb5fe46edde39efbce75d0db86414e82f6ce07b6c304c7f7fa887d13a02e8f59\n+                57b8f07ae9b80a10b3f050902a230e5b33230473691af8c7c2630d899c8efa1e\n+                da5afd1db629318736132466c1970f9753200e05a30ee13e38b4a60e15fbac33\n+                986a6e7760c5805b4f488580db0008e574e173a34cc62fd52c9cd56980249a2f\n+                0c12238a0df04a06dc9895413b31fd0aa0d9eee50ce7fbc178f8719bd9df399f\n+                ce72a57e8571fcbfa4f174f0c37c053238bb9225d480547b34eaff09d00fd29a\n+                d2daf5b694ba4ca8a25e42f14f2cd7c10477ed29b22936989cb7135c8034f81e\n+                2552fd1d15f54ae69054fa03a36ff48d1ccec9c45dcf642dd4bd0e2aed42d4bc\n+                b3df5f9a10805347ec0524c13d49014ca1d983d7de40031f530a34ca1e8ba45b\n+                5b304303a71942388b61779ec6ecefab91cdf705c41d6c2fe72a6be231acc3b5\n+                496661b0d9f5908d0f39463b785a98348a0f9fcf714255e6d9c9c33549541567\n+                55980f2d96686e98f5a990f821504cf2a1c32d2b654f0071dfd85981d59da1a0\n+                ecac2d30b1e2833ea108982aeb059d8c2b7facbcc4391bdd88f900cfae20cfcf\n+                99fc75fd68a85bee6a75be7cf8f4b8a66d9bcab17094e51e745c9b8980b69cfc\n+                4d9bbacf338fbaddad1fbcee745ce30b8ea8316e597350bf1372353d38274c31\n+                34c9e3ddb3affb1f5d5b30a51c3dbbd7529446f4bba26eadf4aa53e7641f70ea\n+                60710d773b02d930a298f8c6957b71f6841a6391ae9d5d2ebee3600061c57244\n+                7ff9e16c211a5b71ab1e7ee811f70a76aaf8617648083959b327a8f15698ba87\n+                3387b492ae7a7ada5d78ae4fdfce67262cacdcaa0717c4e52d7ecd85491903db\n+                f64073dbc2a0f77ba5489f0af146ce8d4e1544f60cc51d2a9db84eb5d8b3da91\n+                c10ad2437744c8b3077d592e5b42baa7846d4250df4c98112b688813988a6759\n+                2fe7b707276dfbcf7cbe3daaf0be3c8c13917d4f2c70c6b6945e05457ce7018e\n+                c167bebefce80d10502f5a2164492a8602ee7db978c51f79612b5b9d69013105\n+                05bdcbbb66a385ed2702a630303fcc30900b8d9c345229f7d539185cd2cca328\n+                d40dbdf3511715cdf195c7565bfcd7ae7830374d4c77acf746874068f7f0ec3f\n+                bc22fdbd06fbd4a4bc018d6a81bdf9c5f3ec45c441333cee36e2f3d28f4d4ac4\n+                e45299a3ea7151e2f314ce1d8c7f8aff7be4886bf8ab8de2893f17baf2969125\n+                d4b8e4f036b3b60c88e0c08450a8e7ed005831f2030760d4a97c419a859ded43\n+                85e855bed5b966d1a97845fe8a6dc7467a2529ea005fbf0da3fd3efa28142c92\n+                058dcec7ec1e1f199ac8c777857295b34a33e2b678c04475b7dfeda7656dcc5c\n+                b948ff2368e989a4688c16ba02479ccb107f6fb27dc30f0e49b9641aff149d07\n+                c6afd31db92c8a5d0c0f4234aec0c0e1e05c7336378b387d1a70a4176dee6835\n+                74811cce4b20f0730ef92932d1d790b6cf73081da8c51b75ba8950579b92c117\n+                567f3a1fd8a049685a7aacd9cbb997a0aff7e6a34ea7e70fc8cf24b11f96d2f9\n+                ef5327eba013bea5cff327f3a5aece1b8a2fb45f80c2454a9cba86a55a1ef63c\n+                7862d07eb1274fb68b69db5a0cab9b5aba53595f6e0cf643efbf38ed33e7bdb7\n+                3f887e8bc0e50c003bb8523b7aa459bd0517fd3b502ad4fdaa22010cb6ac5bf9\n+                7d6ad67c2317a9d18fa8efc4c02345bba30bdfeb788c001ff4f9a899b0d11043\n+                454b52fc2828fc1891e149b42ef897608d95f568f3eb301023dbf18f40da3148\n+                45821078487199e71a6b48b2105851702fb6319052ca642ed6338c41cc8b3d95\n+                b101a08835e9352f71938d24f8789d32add82e7ede0fd1858330a451015f7e87\n+                9c5eb59c8e534beb771aee8b0fb2bf4937fdc9cf07d891ccda61ae4aad303282\n+                00000007\n+                2e0e7708bb0e589d2d818a8c0e2c53b3e59b9e43c7a194fd18d19ab1554a9f85\n+                90b31f08e2fe1b38486572cc3b36ddaa9d85b795fcd93acd531283688191b5f5\n+                a744b89faae49989127685cdc000e001a0d77df3a5c3061e312377b1050e7371\n+                24a68d2a00a848e141d274dccb8e4740d33ef7970494ed316447f8381ba06791\n+                001e90b7f36ef24e1dbbd68f7074ddd233d9e15cbd4efa4a249cb30fd3095c3d\n+                ed096e87d6c179ff8dbadb1bc6493bb6f944ccee2cbf24573017817e586475f0\n+                ed51bfe889b298a2fb76d16dde0c966a70a284dafa980442f870d640e11079d0\n+                a4f6834a62ba0a4eac4d7334f3c756ea6b0bd8eafad227b5b8eb4e937c32412f\n+                201780dbf5eab317f3a21293e653115bbffac4899830eb28e6e43c1a77b51884\n+                8f68887ccfa366175be2a88d3fc178e671073736bd94eb4e16720a6b3ee119b6\n+                dcba885ecb46126614c7a677c1662c4cadcda742f27fc01a8bd5af474ee4a29b\n+                4e25721bb931b8bf898afb3cb66d3fcab70b80005e737ec5bd88d5ced8941226\n+                720dd43655a9ba1d4bf0a723faa4bb3651ed2ea7e0bd08113e524777e6ec592a\n+                ba5cab16b084d208d20bf25ad9a7ae31bceb00b07ef20cab7d1f6883ac331c75\n+                a2aefb8230ae97dc34577785b123af406040d01fd072c493228d7583cd023c25\n+                \"\"\");\n+\n+            v = getVerifier(pk);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/HSS.java","additions":1827,"deletions":0,"binary":false,"changes":1827,"status":"added"},{"patch":"@@ -85,1 +85,1 @@\n-    public void setup() {\n+    public void setup() throws Throwable {\n@@ -88,0 +88,2 @@\n+        byte[] d = data[0];\n+        polyEngineInit.invoke(polyObj, new SecretKeySpec(d, 0, 32, \"Poly1305\"), null);\n@@ -103,0 +105,11 @@\n+    @Benchmark\n+    public void updateBytes() {\n+        try {\n+            byte[] d = data[index];\n+            \/\/ index = (index +1) % SET_SIZE;\n+            polyEngineUpdate.invoke(polyObj, d, 0, d.length);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/Poly1305DigestBench.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class StoreMaskTrueCount {\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_PREFERRED;\n+    private static final int LENGTH = 128;\n+    private static final Random RD = new Random();\n+    private static boolean[] ba;\n+\n+    static {\n+        ba = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testShort() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += S_SPECIES.length()) {\n+            VectorMask<Short> m = VectorMask.fromArray(S_SPECIES, ba, i);\n+            res += m.not().trueCount();\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testInt() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            VectorMask<Integer> m = VectorMask.fromArray(I_SPECIES, ba, i);\n+            res += m.not().trueCount();\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int testLong() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += L_SPECIES.length()) {\n+            VectorMask<Long> m = VectorMask.fromArray(L_SPECIES, ba, i);\n+            res += m.not().trueCount();\n+        }\n+\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/StoreMaskTrueCount.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -55,0 +56,8 @@\n+    interface FirstInterfaceExt extends FirstInterface {\n+        default int getIntFirst() { return 44; }\n+    }\n+\n+    interface FirstInterfaceExtExt extends FirstInterfaceExt {\n+        default int getIntFirst() { return 45; }\n+    }\n+\n@@ -105,0 +114,70 @@\n+    class FirstClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -1;\n+        }\n+    }\n+\n+    class SecondClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -2;\n+        }\n+    }\n+\n+    class ThirdClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthClassDontInline implements FirstInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -5;\n+        }\n+    }\n+\n+    class FirstClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -1;\n+        }\n+    }\n+\n+    class SecondClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -2;\n+        }\n+    }\n+\n+    class ThirdClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthClassDontInlineExtExt implements FirstInterfaceExtExt {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getIntFirst() {\n+            return -5;\n+        }\n+    }\n+\n@@ -107,0 +186,2 @@\n+    public FirstInterface[] noninlined = new FirstInterface[asLength];\n+    public FirstInterfaceExtExt[] noninlinedextext = new FirstInterfaceExtExt[asLength];\n@@ -116,0 +197,12 @@\n+\n+        noninlined[0] = new FirstClassDontInline();\n+        noninlined[1] = new SecondClassDontInline();\n+        noninlined[2] = new ThirdClassDontInline();\n+        noninlined[3] = new FourthClassDontInline();\n+        noninlined[4] = new FifthClassDontInline();\n+\n+        noninlinedextext[0] = new FirstClassDontInlineExtExt();\n+        noninlinedextext[1] = new SecondClassDontInlineExtExt();\n+        noninlinedextext[2] = new ThirdClassDontInlineExtExt();\n+        noninlinedextext[3] = new FourthClassDontInlineExtExt();\n+        noninlinedextext[4] = new FifthClassDontInlineExtExt();\n@@ -129,0 +222,16 @@\n+    \/** Tests single base interface method call *\/\n+    @Benchmark\n+    public int testIfaceCall(Blackhole bh) {\n+        FirstInterface ai = noninlined[l];\n+        l = ++ l % asLength;\n+        return ai.getIntFirst();\n+    }\n+\n+    \/** Tests extended interface method call *\/\n+    @Benchmark\n+    public int testIfaceExtCall(Blackhole bh) {\n+        FirstInterfaceExtExt ai = noninlinedextext[l];\n+        l = ++ l % asLength;\n+        return ai.getIntFirst();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfaceCalls.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+    private double[] doublesA;\n+    private double[] doublesB;\n+    private double[] doublesC;\n@@ -66,0 +69,3 @@\n+        doublesA = new double[COUNT];\n+        doublesB = new double[COUNT];\n+        doublesC = new double[COUNT];\n@@ -74,0 +80,3 @@\n+            doublesA[i] = r.nextDouble();\n+            doublesB[i] = r.nextDouble();\n+            doublesC[i] = r.nextDouble();\n@@ -137,0 +146,10 @@\n+    @Benchmark\n+    public void mulRedD(Blackhole bh) {\n+        double resD = 0.0;\n+        for (int i = 0; i < COUNT; i++) {\n+            resD += (doublesA[i] * doublesB[i]) + (doublesA[i] * doublesC[i]) +\n+                     (doublesB[i] * doublesC[i]);\n+        }\n+        bh.consume(resD);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorReduction.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class Conv2BRules {\n+    @Benchmark\n+    public void testNotEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j != 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals1(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testNotEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o != null);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o == null);\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        int[] ints;\n+        Object[] objs;\n+\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            ints = new int[128];\n+            objs = new Object[128];\n+            for (int i = 0; i < 128; i++) {\n+                ints[i] = random.nextInt(3);\n+                objs[i] = random.nextInt(3) == 0 ? null : new Object();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/Conv2BRules.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}