{"files":[{"patch":"@@ -2439,1 +2439,1 @@\n-  void generate_aes_loadkeys(const Register &key, VectorRegister *working_vregs, int rounds) {\n+  void aes_load_keys(const Register &key, VectorRegister *working_vregs, int rounds) {\n@@ -2451,1 +2451,1 @@\n-  void generate_aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n+  void aes_encrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n@@ -2502,2 +2502,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 15);\n-    generate_aes_encrypt(res, working_vregs, 15);\n+    aes_load_keys(key, working_vregs, 15);\n+    aes_encrypt(res, working_vregs, 15);\n@@ -2511,2 +2511,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 13);\n-    generate_aes_encrypt(res, working_vregs, 13);\n+    aes_load_keys(key, working_vregs, 13);\n+    aes_encrypt(res, working_vregs, 13);\n@@ -2520,2 +2520,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 11);\n-    generate_aes_encrypt(res, working_vregs, 11);\n+    aes_load_keys(key, working_vregs, 11);\n+    aes_encrypt(res, working_vregs, 11);\n@@ -2530,1 +2530,1 @@\n-  void generate_aes_decrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n+  void aes_decrypt(const VectorRegister &res, VectorRegister *working_vregs, int rounds) {\n@@ -2581,2 +2581,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 15);\n-    generate_aes_decrypt(res, working_vregs, 15);\n+    aes_load_keys(key, working_vregs, 15);\n+    aes_decrypt(res, working_vregs, 15);\n@@ -2590,2 +2590,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 13);\n-    generate_aes_decrypt(res, working_vregs, 13);\n+    aes_load_keys(key, working_vregs, 13);\n+    aes_decrypt(res, working_vregs, 13);\n@@ -2599,2 +2599,2 @@\n-    generate_aes_loadkeys(key, working_vregs, 11);\n-    generate_aes_decrypt(res, working_vregs, 11);\n+    aes_load_keys(key, working_vregs, 11);\n+    aes_decrypt(res, working_vregs, 11);\n@@ -2625,1 +2625,1 @@\n-    generate_aes_loadkeys(key, working_vregs, round);\n+    aes_load_keys(key, working_vregs, round);\n@@ -2632,1 +2632,1 @@\n-      generate_aes_encrypt(v16, working_vregs, round);\n+      aes_encrypt(v16, working_vregs, round);\n@@ -2712,1 +2712,1 @@\n-    generate_aes_loadkeys(key, working_vregs, round);\n+    aes_load_keys(key, working_vregs, round);\n@@ -2719,1 +2719,1 @@\n-      generate_aes_decrypt(v17, working_vregs, round);\n+      aes_decrypt(v17, working_vregs, round);\n@@ -2814,1 +2814,1 @@\n-    \/\/   generate_aes_loadkeys();\n+    \/\/   aes_load_keys();\n@@ -2828,1 +2828,1 @@\n-    \/\/     saved_encrypted_ctr = generate_aes_encrypt(counter);\n+    \/\/     saved_encrypted_ctr = aes_encrypt(counter);\n@@ -2872,1 +2872,1 @@\n-    generate_aes_loadkeys(key, working_vregs, round);\n+    aes_load_keys(key, working_vregs, round);\n@@ -2905,1 +2905,1 @@\n-    generate_aes_encrypt(v16, working_vregs, round);\n+    aes_encrypt(v16, working_vregs, round);\n@@ -3000,0 +3000,28 @@\n+  void ghash_loop(Register state, Register subkeyH, Register data, Register blocks,\n+                  VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3) {\n+    VectorRegister partial_hash = vtmp1;\n+    VectorRegister hash_subkey  = vtmp2;\n+    VectorRegister cipher_text  = vtmp3;\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+\n+    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n+    __ vle64_v(hash_subkey, subkeyH);\n+    __ vrev8_v(hash_subkey, hash_subkey);\n+    __ vle64_v(partial_hash, state);\n+    __ vrev8_v(partial_hash, partial_hash);\n+\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    Label L_ghash_loop;\n+    __ bind(L_ghash_loop);\n+      __ vle32_v(cipher_text, data);\n+      __ addi(data, data, BLOCK_SIZE);\n+      __ vghsh_vv(partial_hash, hash_subkey, cipher_text);\n+      __ subi(blocks, blocks, 1);\n+      __ bnez(blocks, L_ghash_loop);\n+\n+    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n+    __ vrev8_v(partial_hash, partial_hash);\n+    __ vse64_v(partial_hash, state);\n+  }\n+\n@@ -3027,3 +3055,3 @@\n-    VectorRegister partial_hash = v1;\n-    VectorRegister hash_subkey  = v2;\n-    VectorRegister cipher_text  = v3;\n+    VectorRegister vtmp1 = v1;\n+    VectorRegister vtmp2 = v2;\n+    VectorRegister vtmp3 = v3;\n@@ -3031,1 +3059,1 @@\n-    const unsigned int BLOCK_SIZE = 16;\n+    ghash_loop(state, subkeyH, data, blocks, vtmp1, vtmp2, vtmp3);\n@@ -3033,18 +3061,0 @@\n-    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n-    __ vle64_v(hash_subkey, subkeyH);\n-    __ vrev8_v(hash_subkey, hash_subkey);\n-    __ vle64_v(partial_hash, state);\n-    __ vrev8_v(partial_hash, partial_hash);\n-\n-    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n-    Label L_ghash_loop;\n-    __ bind(L_ghash_loop);\n-      __ vle32_v(cipher_text, data);\n-      __ addi(data, data, BLOCK_SIZE);\n-      __ vghsh_vv(partial_hash, hash_subkey, cipher_text);\n-      __ subi(blocks, blocks, 1);\n-      __ bnez(blocks, L_ghash_loop);\n-\n-    __ vsetivli(x0, 2, Assembler::e64, Assembler::m1);\n-    __ vrev8_v(partial_hash, partial_hash);\n-    __ vse64_v(partial_hash, state);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":55,"deletions":45,"binary":false,"changes":100,"status":"modified"}]}