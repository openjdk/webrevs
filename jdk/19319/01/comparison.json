{"files":[{"patch":"@@ -635,1 +635,1 @@\n-        assert(VerifyAccess.isTypeVisible(c, Object.class)) : c.getName();\n+        assert(VerifyAccess.ensureTypeVisible(c, Object.class)) : c.getName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-    void checkForTypeAlias(Class<?> refc) {\n+    void ensureTypeVisible(Class<?> refc) {\n@@ -811,1 +811,1 @@\n-            if (VerifyAccess.isTypeVisible(type, refc))  return;\n+            if (VerifyAccess.ensureTypeVisible(type, refc))  return;\n@@ -819,1 +819,1 @@\n-            if (VerifyAccess.isTypeVisible(type, refc))  return;\n+            if (VerifyAccess.ensureTypeVisible(type, refc))  return;\n@@ -961,1 +961,1 @@\n-                m.checkForTypeAlias(m.getDeclaringClass());\n+                m.ensureTypeVisible(m.getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-    public static boolean isTypeVisible(Class<?> type, Class<?> refc) {\n+    public static boolean ensureTypeVisible(Class<?> type, Class<?> refc) {\n@@ -287,6 +287,8 @@\n-        if (typeLoader == null && type.getName().startsWith(\"java.\")) {\n-            \/\/ Note:  The API for actually loading classes, ClassLoader.defineClass,\n-            \/\/ guarantees that classes with names beginning \"java.\" cannot be aliased,\n-            \/\/ because class loaders cannot load them directly.\n-            return true;\n-        }\n+\n+        \/\/ The API for actually loading classes, ClassLoader.defineClass,\n+        \/\/ guarantees that classes with names beginning \"java.\" cannot be aliased,\n+        \/\/ because class loaders cannot load them directly. However, it is beneficial\n+        \/\/ for JIT-compilers to ensure all signature classes are loaded.\n+        \/\/ JVM doesn't install any loader contraints when performing MemberName resolution,\n+        \/\/ so eagerly resolving signature classes is a way to match what JVM achieves\n+        \/\/ with loader constraints during method resolution for invoke bytecodes.\n@@ -341,2 +343,2 @@\n-    public static boolean isTypeVisible(java.lang.invoke.MethodType type, Class<?> refc) {\n-        if (!isTypeVisible(type.returnType(), refc)) {\n+    public static boolean ensureTypeVisible(java.lang.invoke.MethodType type, Class<?> refc) {\n+        if (!ensureTypeVisible(type.returnType(), refc)) {\n@@ -346,1 +348,1 @@\n-            if (!isTypeVisible(type.parameterType(n), refc)) {\n+            if (!ensureTypeVisible(type.parameterType(n), refc)) {\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @run driver compiler.runtime.unloaded.TestUnloadedSignatureClass\n+ *\/\n+\n+package compiler.runtime.unloaded;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestUnloadedSignatureClass {\n+    static class Test {\n+        static int test(Integer i) {\n+            \/\/ Bound to a wrapper around a method with (Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I signature.\n+            \/\/ Neither BiPredicate nor List are guaranteed to be resolved by the context class loader.\n+            return switch (i) {\n+                case null -> -1;\n+                case 0    ->  0;\n+                default   ->  1;\n+            };\n+        }\n+\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 20_000; i++) {\n+                test(i);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-Xbatch\", \"-XX:-TieredCompilation\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*::test\",\n+                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintCompilation\", \"-XX:+PrintInlining\",\n+                Test.class.getName()\n+        );\n+\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldNotContain(\"unloaded signature classes\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/unloaded\/TestUnloadedSignatureClass.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}