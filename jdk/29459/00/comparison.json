{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,2 +468,0 @@\n-\n-    StringTable::load_shared_strings_array();\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapLoader.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1165,6 +1165,0 @@\n-\n-    if (HeapShared::is_writing_mapping_mode()) {\n-      \/\/ Do this at the very end, when no Java code will be executed. Otherwise\n-      \/\/ some new strings may be added to the intern table.\n-      StringTable::allocate_shared_strings_array(CHECK);\n-    }\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, string);\n+  assert(success, \"shared strings array must not point to arrays or strings that are too large to archive\");\n@@ -834,8 +836,0 @@\n-void HeapShared::archive_strings() {\n-  assert(HeapShared::is_writing_mapping_mode(), \"should not reach here\");\n-  oop shared_strings_array = StringTable::init_shared_strings_array();\n-  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, shared_strings_array);\n-  assert(success, \"shared strings array must not point to arrays or strings that are too large to archive\");\n-  StringTable::set_shared_strings_array_index(append_root(shared_strings_array));\n-}\n-\n@@ -893,1 +887,1 @@\n-    archive_strings();\n+    StringTable::init_shared_table();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +481,0 @@\n-  static void archive_strings();\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-bool StringTable::_is_two_dimensional_shared_strings_array = false;\n-OopHandle StringTable::_shared_strings_array;\n-int StringTable::_shared_strings_array_root_index;\n-\n@@ -83,12 +79,1 @@\n-  objArrayOop array = (objArrayOop)(_shared_strings_array.resolve());\n-  oop s;\n-\n-  if (!_is_two_dimensional_shared_strings_array) {\n-    s = array->obj_at((int)index);\n-  } else {\n-    int primary_index = index >> _secondary_array_index_bits;\n-    int secondary_index = index & _secondary_array_index_mask;\n-    objArrayOop secondary = (objArrayOop)array->obj_at(primary_index);\n-    s = secondary->obj_at(secondary_index);\n-  }\n-\n+  oop s = HeapShared::get_root((int)index, false);\n@@ -118,1 +103,0 @@\n-DEBUG_ONLY(static bool _disable_interning_during_cds_dump = false);\n@@ -320,6 +304,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-void StringTable::load_shared_strings_array() {\n-  _shared_strings_array = OopHandle(Universe::vm_global(), HeapShared::get_root(_shared_strings_array_root_index));\n-}\n-#endif\n-\n@@ -512,3 +490,0 @@\n-  assert(!AtomicAccess::load_acquire(&_disable_interning_during_cds_dump),\n-         \"All threads that may intern strings should have been stopped before CDS starts copying the interned string table\");\n-\n@@ -960,30 +935,4 @@\n-\/\/ This is called BEFORE we enter the CDS safepoint. We can still allocate Java object arrays to\n-\/\/ be used by the shared strings table.\n-void StringTable::allocate_shared_strings_array(TRAPS) {\n-  if (!CDSConfig::is_dumping_heap()) {\n-    return;\n-  }\n-\n-  assert(HeapShared::is_writing_mapping_mode(), \"should not reach here\");\n-\n-  CompileBroker::wait_for_no_active_tasks();\n-\n-  precond(CDSConfig::allow_only_single_java_thread());\n-\n-  \/\/ At this point, no more strings will be added:\n-  \/\/ - There's only a single Java thread (this thread). It no longer executes Java bytecodes\n-  \/\/   so JIT compilation will eventually stop.\n-  \/\/ - CompileBroker has no more active tasks, so all JIT requests have been processed.\n-\n-  \/\/ This flag will be cleared after intern table dumping has completed, so we can run the\n-  \/\/ compiler again (for future AOT method compilation, etc).\n-  DEBUG_ONLY(AtomicAccess::release_store(&_disable_interning_during_cds_dump, true));\n-\n-  if (items_count_acquire() > (size_t)max_jint) {\n-    fatal(\"Too many strings to be archived: %zu\", items_count_acquire());\n-  }\n-\n-  int total = (int)items_count_acquire();\n-  size_t single_array_size = objArrayOopDesc::object_size(total);\n-\n-  log_info(aot)(\"allocated string table for %d strings\", total);\n+void StringTable::init_shared_table() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"inside AOT safepoint\");\n+  precond(CDSConfig::is_dumping_heap());\n+  assert(HeapShared::is_writing_mapping_mode(), \"not used for streamed oops\");\n@@ -991,81 +940,2 @@\n-  if (!HeapShared::is_too_large_to_archive(single_array_size)) {\n-    \/\/ The entire table can fit in a single array\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), total, CHECK);\n-    _shared_strings_array = OopHandle(Universe::vm_global(), array);\n-    log_info(aot)(\"string table array (single level) length = %d\", total);\n-  } else {\n-    \/\/ Split the table in two levels of arrays.\n-    int primary_array_length = (total + _secondary_array_max_length - 1) \/ _secondary_array_max_length;\n-    size_t primary_array_size = objArrayOopDesc::object_size(primary_array_length);\n-    size_t secondary_array_size = objArrayOopDesc::object_size(_secondary_array_max_length);\n-\n-    if (HeapShared::is_too_large_to_archive(secondary_array_size)) {\n-      \/\/ This can only happen if you have an extremely large number of classes that\n-      \/\/ refer to more than 16384 * 16384 = 26M interned strings! Not a practical concern\n-      \/\/ but bail out for safety.\n-      log_error(aot)(\"Too many strings to be archived: %zu\", items_count_acquire());\n-      AOTMetaspace::unrecoverable_writing_error();\n-    }\n-\n-    objArrayOop primary = oopFactory::new_objArray(vmClasses::Object_klass(), primary_array_length, CHECK);\n-    objArrayHandle primaryHandle(THREAD, primary);\n-    _shared_strings_array = OopHandle(Universe::vm_global(), primary);\n-\n-    log_info(aot)(\"string table array (primary) length = %d\", primary_array_length);\n-    for (int i = 0; i < primary_array_length; i++) {\n-      int len;\n-      if (total > _secondary_array_max_length) {\n-        len = _secondary_array_max_length;\n-      } else {\n-        len = total;\n-      }\n-      total -= len;\n-\n-      objArrayOop secondary = oopFactory::new_objArray(vmClasses::Object_klass(), len, CHECK);\n-      primaryHandle()->obj_at_put(i, secondary);\n-\n-      log_info(aot)(\"string table array (secondary)[%d] length = %d\", i, len);\n-      assert(!HeapShared::is_too_large_to_archive(secondary), \"sanity\");\n-    }\n-\n-    assert(total == 0, \"must be\");\n-    _is_two_dimensional_shared_strings_array = true;\n-  }\n-}\n-\n-#ifndef PRODUCT\n-void StringTable::verify_secondary_array_index_bits() {\n-  assert(HeapShared::is_writing_mapping_mode(), \"should not reach here\");\n-  int max;\n-  for (max = 1; ; max++) {\n-    size_t next_size = objArrayOopDesc::object_size(1 << (max + 1));\n-    if (HeapShared::is_too_large_to_archive(next_size)) {\n-      break;\n-    }\n-  }\n-  \/\/ Currently max is 17 for +UseCompressedOops, 16 for -UseCompressedOops.\n-  \/\/ When we add support for Shenandoah (which has a smaller mininum region size than G1),\n-  \/\/ max will become 15\/14.\n-  \/\/\n-  \/\/ We use _secondary_array_index_bits==14 as that will be the eventual value, and will\n-  \/\/ make testing easier.\n-  assert(_secondary_array_index_bits <= max,\n-         \"_secondary_array_index_bits (%d) must be smaller than max possible value (%d)\",\n-         _secondary_array_index_bits, max);\n-}\n-#endif \/\/ PRODUCT\n-\n-\/\/ This is called AFTER we enter the CDS safepoint.\n-\/\/\n-\/\/ For each shared string:\n-\/\/ [1] Store it into _shared_strings_array. Encode its position as a 32-bit index.\n-\/\/ [2] Store the index and hashcode into _shared_table.\n-oop StringTable::init_shared_strings_array() {\n-  assert(CDSConfig::is_dumping_heap(), \"must be\");\n-  assert(HeapShared::is_writing_mapping_mode(), \"should not reach here\");\n-  objArrayOop array = (objArrayOop)(_shared_strings_array.resolve());\n-\n-  verify_secondary_array_index_bits();\n-\n-  int index = 0;\n-  auto copy_into_array = [&] (WeakHandle* val) {\n+  int n = 0;\n+  auto copy_into_aot_heap = [&] (WeakHandle* val) {\n@@ -1080,15 +950,0 @@\n-      if (!_is_two_dimensional_shared_strings_array) {\n-        assert(index < array->length(), \"no strings should have been added\");\n-        array->obj_at_put(index, string);\n-      } else {\n-        int primary_index = index >> _secondary_array_index_bits;\n-        int secondary_index = index & _secondary_array_index_mask;\n-\n-        assert(primary_index < array->length(), \"no strings should have been added\");\n-        objArrayOop secondary = (objArrayOop)array->obj_at(primary_index);\n-\n-        assert(secondary != nullptr && secondary->is_objArray(), \"must be\");\n-        assert(secondary_index < secondary->length(), \"no strings should have been added\");\n-        secondary->obj_at_put(secondary_index, string);\n-      }\n-      index ++;\n@@ -1096,0 +951,1 @@\n+    n++;\n@@ -1099,3 +955,2 @@\n-  _local_table->do_safepoint_scan(copy_into_array);\n-  log_info(aot)(\"Archived %d interned strings\", index);\n-  return array;\n+  _local_table->do_safepoint_scan(copy_into_aot_heap);\n+  log_info(aot)(\"Archived %d interned strings\", n);\n@@ -1105,0 +960,4 @@\n+  assert(SafepointSynchronize::is_at_safepoint(), \"inside AOT safepoint\");\n+  precond(CDSConfig::is_dumping_heap());\n+  assert(HeapShared::is_writing_mapping_mode(), \"not used for streamed oops\");\n+\n@@ -1108,1 +967,0 @@\n-  int index = 0;\n@@ -1113,2 +971,2 @@\n-      writer.add(hash, index);\n-      index ++;\n+      int root_id = HeapShared::append_root(string);\n+      writer.add(hash, root_id);\n@@ -1120,7 +978,0 @@\n-\n-  DEBUG_ONLY(AtomicAccess::release_store(&_disable_interning_during_cds_dump, false));\n-}\n-\n-void StringTable::set_shared_strings_array_index(int root_index) {\n-  assert(HeapShared::is_writing_mapping_mode(), \"should not reach here\");\n-  _shared_strings_array_root_index = root_index;\n@@ -1138,3 +989,0 @@\n-\n-  soc->do_bool(&_is_two_dimensional_shared_strings_array);\n-  soc->do_int(&_shared_strings_array_root_index);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":16,"deletions":168,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,4 +112,2 @@\n-  \/\/ Sharing\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static inline oop read_string_from_compact_hashtable(address base_address, u4 index);\n-\n+  \/\/ AOT support\n+  static inline oop read_string_from_compact_hashtable(address base_address, u4 index) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -117,28 +115,0 @@\n-  static bool _is_two_dimensional_shared_strings_array;\n-  static OopHandle _shared_strings_array;\n-  static int _shared_strings_array_root_index;\n-\n-  \/\/ All the shared strings are referenced through _shared_strings_array to keep them alive.\n-  \/\/ Each shared string is stored as a 32-bit index in ::_shared_table. The index\n-  \/\/ is interpreted in two ways:\n-  \/\/\n-  \/\/ [1] _is_two_dimensional_shared_strings_array = false: _shared_strings_array is an Object[].\n-  \/\/     Each shared string is stored as _shared_strings_array[index]\n-  \/\/\n-  \/\/ [2] _is_two_dimensional_shared_strings_array = true: _shared_strings_array is an Object[][]\n-  \/\/     This happens when there are too many elements in the shared table. We store them\n-  \/\/     using two levels of objArrays, such that none of the arrays are too big for\n-  \/\/     AOTMappedHeapWriter::is_too_large_to_archive(). In this case, the index is splited into two\n-  \/\/     parts. Each shared string is stored as _shared_strings_array[primary_index][secondary_index]:\n-  \/\/\n-  \/\/           [bits 31 .. 14][ bits 13 .. 0  ]\n-  \/\/            primary_index  secondary_index\n-  const static int _secondary_array_index_bits = 14;\n-  const static int _secondary_array_max_length = 1 << _secondary_array_index_bits;\n-  const static int _secondary_array_index_mask = _secondary_array_max_length - 1;\n-\n-  \/\/ make sure _secondary_array_index_bits is not too big\n-  static void verify_secondary_array_index_bits() PRODUCT_RETURN;\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n- private:\n@@ -146,1 +116,1 @@\n- public:\n+public:\n@@ -149,3 +119,1 @@\n-  static void allocate_shared_strings_array(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void load_shared_strings_array() NOT_CDS_JAVA_HEAP_RETURN;\n-  static oop init_shared_strings_array() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static void init_shared_table() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -153,1 +121,0 @@\n-  static void set_shared_strings_array_index(int root_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":5,"deletions":38,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,0 @@\n-        dumpOutput.shouldContain(\"string table array (primary)\");\n-        dumpOutput.shouldContain(\"string table array (secondary)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}