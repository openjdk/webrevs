{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +47,1 @@\n+import java.nio.ByteOrder;\n@@ -65,1 +67,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -83,1 +85,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -104,0 +106,3 @@\n+    \/** {@return byte order used by this linker} *\/\n+    protected abstract ByteOrder linkerByteOrder();\n+\n@@ -107,3 +112,3 @@\n-    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n-        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n-        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    private void checkLayouts(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(this::checkLayoutsRecursive);\n+        descriptor.argumentLayouts().forEach(this::checkLayoutsRecursive);\n@@ -112,1 +117,1 @@\n-    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+    private void checkLayoutsRecursive(MemoryLayout layout) {\n@@ -114,0 +119,1 @@\n+        checkByteOrder(layout);\n@@ -116,1 +122,1 @@\n-                checkHasNaturalAlignmentRecursive(member);\n+                checkLayoutsRecursive(member);\n@@ -119,1 +125,1 @@\n-            checkHasNaturalAlignmentRecursive(sl.elementLayout());\n+            checkLayoutsRecursive(sl.elementLayout());\n@@ -128,0 +134,7 @@\n+\n+    private void checkByteOrder(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout vl\n+                && vl.order() != linkerByteOrder()) {\n+            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.nio.ByteOrder;\n@@ -120,0 +121,5 @@\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.nativeOrder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -59,0 +60,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -61,0 +62,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,0 +157,12 @@\n+            {\n+                    FunctionDescriptor.of(C_INT.withOrder(nonNativeOrder())),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(C_INT.withOrder(nonNativeOrder()))),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    \"Layout does not have the right byte order\"\n+            },\n@@ -160,0 +172,6 @@\n+    private static ByteOrder nonNativeOrder() {\n+        return ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? ByteOrder.BIG_ENDIAN\n+                : ByteOrder.LITTLE_ENDIAN;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}