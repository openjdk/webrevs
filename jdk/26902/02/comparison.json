{"files":[{"patch":"@@ -509,48 +509,2 @@\n-    const jushort flags = node->flags();\n-    if (flags & Node::Flag_is_Copy) {\n-      print_prop(\"is_copy\", \"true\");\n-    }\n-    if (flags & Node::Flag_rematerialize) {\n-      print_prop(\"rematerialize\", \"true\");\n-    }\n-    if (flags & Node::Flag_needs_anti_dependence_check) {\n-      print_prop(\"needs_anti_dependence_check\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_macro) {\n-      print_prop(\"is_macro\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_Con) {\n-      print_prop(\"is_con\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_cisc_alternate) {\n-      print_prop(\"is_cisc_alternate\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_dead_loop_safe) {\n-      print_prop(\"is_dead_loop_safe\", \"true\");\n-    }\n-    if (flags & Node::Flag_may_be_short_branch) {\n-      print_prop(\"may_be_short_branch\", \"true\");\n-    }\n-    if (flags & Node::Flag_has_call) {\n-      print_prop(\"has_call\", \"true\");\n-    }\n-    if (flags & Node::Flag_has_swapped_edges) {\n-      print_prop(\"has_swapped_edges\", \"true\");\n-    }\n-\n-    if (C->matcher() != nullptr) {\n-      if (C->matcher()->is_shared(node)) {\n-        print_prop(\"is_shared\", \"true\");\n-      } else {\n-        print_prop(\"is_shared\", \"false\");\n-      }\n-      if (C->matcher()->is_dontcare(node)) {\n-        print_prop(\"is_dontcare\", \"true\");\n-      } else {\n-        print_prop(\"is_dontcare\", \"false\");\n-      }\n-      Node* old = C->matcher()->find_old_node(node);\n-      if (old != nullptr) {\n-        print_prop(\"old_node_idx\", old->_idx);\n-      }\n-    }\n+    PrintProperties print_node(this);\n+    print_node.print_node_properties(node, C);\n@@ -1085,67 +1039,4 @@\n-      print_prop(\"mask\", buffer);\n-      print_prop(\"mask_size\", lrg.mask_size());\n-      if (lrg._degree_valid) {\n-        print_prop(\"degree\", lrg.degree());\n-      }\n-      print_prop(\"num_regs\", lrg.num_regs());\n-      print_prop(\"reg_pressure\", lrg.reg_pressure());\n-      print_prop(\"cost\", lrg._cost);\n-      print_prop(\"area\", lrg._area);\n-      print_prop(\"score\", lrg.score());\n-      if (lrg._risk_bias != 0) {\n-        print_prop(\"risk_bias\", lrg._risk_bias);\n-      }\n-      if (lrg._copy_bias != 0) {\n-        print_prop(\"copy_bias\", lrg._copy_bias);\n-      }\n-      if (lrg.is_singledef()) {\n-        print_prop(\"is_singledef\", TRUE_VALUE);\n-      }\n-      if (lrg.is_multidef()) {\n-        print_prop(\"is_multidef\", TRUE_VALUE);\n-      }\n-      if (lrg._is_oop) {\n-        print_prop(\"is_oop\", TRUE_VALUE);\n-      }\n-      if (lrg._is_float) {\n-        print_prop(\"is_float\", TRUE_VALUE);\n-      }\n-      if (lrg._is_vector) {\n-        print_prop(\"is_vector\", TRUE_VALUE);\n-      }\n-      if (lrg._is_predicate) {\n-        print_prop(\"is_predicate\", TRUE_VALUE);\n-      }\n-      if (lrg._is_scalable) {\n-        print_prop(\"is_scalable\", TRUE_VALUE);\n-      }\n-      if (lrg._was_spilled1) {\n-        print_prop(\"was_spilled1\", TRUE_VALUE);\n-      }\n-      if (lrg._was_spilled2) {\n-        print_prop(\"was_spilled2\", TRUE_VALUE);\n-      }\n-      if (lrg._direct_conflict) {\n-        print_prop(\"direct_conflict\", TRUE_VALUE);\n-      }\n-      if (lrg._fat_proj) {\n-        print_prop(\"fat_proj\", TRUE_VALUE);\n-      }\n-      if (lrg._was_lo) {\n-        print_prop(\"_was_lo\", TRUE_VALUE);\n-      }\n-      if (lrg._has_copy) {\n-        print_prop(\"has_copy\", TRUE_VALUE);\n-      }\n-      if (lrg._at_risk) {\n-        print_prop(\"at_risk\", TRUE_VALUE);\n-      }\n-      if (lrg._must_spill) {\n-        print_prop(\"must_spill\", TRUE_VALUE);\n-      }\n-      if (lrg._is_bound) {\n-        print_prop(\"is_bound\", TRUE_VALUE);\n-      }\n-      if (lrg._msize_valid && lrg._degree_valid && lrg.lo_degree()) {\n-        print_prop(\"trivial\", TRUE_VALUE);\n-      }\n+\n+      PrintProperties print_node(this);\n+      print_node.print_lrg_properties(lrg, buffer);\n+\n@@ -1223,0 +1114,72 @@\n+void PrintProperties::print_node_properties(Node* node, Compile* C) {\n+  const jushort flags = node->flags();\n+  print_property((flags & Node::Flag_is_Copy), \"is_copy\");\n+  print_property((flags & Node::Flag_rematerialize), \"rematerialize\");\n+  print_property((flags & Node::Flag_needs_anti_dependence_check), \"needs_anti_dependence_check\");\n+  print_property((flags & Node::Flag_is_macro), \"is_macro\");\n+  print_property((flags & Node::Flag_is_Con), \"is_con\");\n+  print_property((flags & Node::Flag_is_cisc_alternate), \"is_cisc_alternate\");\n+  print_property((flags & Node::Flag_is_dead_loop_safe), \"is_dead_loop_safe\");\n+  print_property((flags & Node::Flag_may_be_short_branch), \"may_be_short_branch\");\n+  print_property((flags & Node::Flag_has_call), \"has_call\");\n+  print_property((flags & Node::Flag_has_swapped_edges), \"has_swapped_edges\");\n+  if (C->matcher() != nullptr) {\n+    print_property(C->matcher()->is_shared(node),\"is_shared\");\n+    print_property(!(C->matcher()->is_shared(node)), \"is_shared\", IdealGraphPrinter::FALSE_VALUE);\n+    print_property(C->matcher()->is_dontcare(node), \"is_dontcare\");\n+    print_property(!(C->matcher()->is_dontcare(node)),\"is_dontcare\", IdealGraphPrinter::FALSE_VALUE);\n+    Node* old = C->matcher()->find_old_node(node);\n+    if (old != nullptr) {\n+      print_property(true, \"old_node_idx\", C->matcher()->find_old_node(node)->_idx);\n+    }\n+  }\n+}\n+\n+void PrintProperties::print_lrg_properties(const LRG &lrg, const char *buffer) {\n+  print_property(true, \"mask\", buffer);\n+  print_property(true, \"mask_size\", lrg.mask_size());\n+  print_property(lrg._degree_valid, \"degree\", lrg.degree());\n+  print_property(true, \"num_regs\", lrg.num_regs());\n+  print_property(true, \"reg_pressure\", lrg.reg_pressure());\n+  print_property(true, \"cost\", lrg._cost);\n+  print_property(true, \"area\", lrg._area);\n+  print_property(true, \"score\", lrg.score());\n+  print_property((lrg._risk_bias != 0), \"risk_bias\", lrg._risk_bias);\n+  print_property((lrg._copy_bias != 0), \"copy_bias\", lrg._copy_bias);\n+  print_property(lrg.is_singledef(), \"is_singledef\");\n+  print_property(lrg.is_multidef(), \"is_multidef\");\n+  print_property(lrg._is_oop, \"is_oop\");\n+  print_property(lrg._is_float, \"is_float\");\n+  print_property(lrg._is_vector, \"is_vector\");\n+  print_property(lrg._is_predicate, \"is_predicate\");\n+  print_property(lrg._is_scalable, \"is_scalable\");\n+  print_property(lrg._was_spilled1, \"was_spilled1\");\n+  print_property(lrg._was_spilled2, \"was_spilled2\");\n+  print_property(lrg._direct_conflict, \"direct_conflict\");\n+  print_property(lrg._fat_proj, \"fat_proj\");\n+  print_property(lrg._was_lo, \"_was_lo\");\n+  print_property(lrg._has_copy, \"has_copy\");\n+  print_property(lrg._at_risk, \"at_risk\");\n+  print_property(lrg._must_spill, \"must_spill\");\n+  print_property(lrg._is_bound, \"is_bound\");\n+  print_property((lrg._msize_valid && lrg._degree_valid && lrg.lo_degree()), \"trivial\");\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, IdealGraphPrinter::TRUE_VALUE);\n+  }\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name, const char* val) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, val);\n+  }\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name, int val) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, val);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":78,"deletions":115,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+class LRG;\n+class PrintProperties;\n@@ -47,1 +49,1 @@\n- private:\n+  friend class PrintProperties;\n@@ -49,0 +51,1 @@\n+private:\n@@ -168,0 +171,14 @@\n+class PrintProperties\n+{\n+private:\n+  IdealGraphPrinter* _printer;\n+\n+public:\n+  PrintProperties(IdealGraphPrinter* printer) : _printer(printer) {}\n+  void print_node_properties(Node* node, Compile* C);\n+  void print_lrg_properties(const LRG &lrg, const char* buffer);\n+  void print_property(int flag, const char* name);\n+  void print_property(int flag, const char* name, const char* val);\n+  void print_property(int flag, const char* name, int val);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}