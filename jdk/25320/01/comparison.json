{"files":[{"patch":"@@ -843,1 +843,1 @@\n-bool G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n+void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n@@ -858,3 +858,0 @@\n-\n-  \/\/ Full collection was successfully completed.\n-  return true;\n@@ -873,1 +870,1 @@\n-bool G1CollectedHeap::upgrade_to_full_collection() {\n+void G1CollectedHeap::upgrade_to_full_collection() {\n@@ -876,7 +873,3 @@\n-  bool success = do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                                    false \/* do_maximal_compaction *\/,\n-                                    size_t(0) \/* allocation_word_size *\/);\n-  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n-  \/\/ be the case here since we only call this when already completed one gc.\n-  assert(success, \"invariant\");\n-  return success;\n+  do_full_collection(true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n@@ -903,3 +896,1 @@\n-                                                            bool expect_null_mutator_alloc_region,\n-                                                            bool* gc_succeeded) {\n-  *gc_succeeded = true;\n+                                                            bool expect_null_mutator_alloc_region) {\n@@ -933,3 +924,3 @@\n-    *gc_succeeded = do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n-                                       maximal_compaction \/* do_maximal_compaction *\/,\n-                                       word_size \/* allocation_word_size *\/);\n+    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/,\n+                       word_size \/* allocation_word_size *\/);\n@@ -941,2 +932,1 @@\n-HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size,\n-                                                     bool* succeeded) {\n+HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size) {\n@@ -950,2 +940,1 @@\n-                                     false, \/* expect_null_mutator_alloc_region *\/\n-                                     succeeded);\n+                                     false \/* expect_null_mutator_alloc_region *\/);\n@@ -953,1 +942,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -961,2 +950,1 @@\n-                                            true, \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true \/* expect_null_mutator_alloc_region *\/);\n@@ -964,1 +952,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -972,2 +960,1 @@\n-                                            true,  \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true  \/* expect_null_mutator_alloc_region *\/);\n@@ -2288,2 +2275,2 @@\n-  bool ret_succeeded = op.prologue_succeeded() && op.gc_succeeded();\n-  assert(result == nullptr || ret_succeeded,\n+  *succeeded = op.gc_succeeded();\n+  assert(result == nullptr || *succeeded,\n@@ -2291,1 +2278,0 @@\n-  *succeeded = ret_succeeded;\n@@ -2418,1 +2404,1 @@\n-bool G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint() {\n@@ -2423,1 +2409,0 @@\n-  return true;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-  bool do_full_collection(bool clear_all_soft_refs,\n+  void do_full_collection(bool clear_all_soft_refs,\n@@ -492,1 +492,1 @@\n-  bool upgrade_to_full_collection();\n+  void upgrade_to_full_collection();\n@@ -497,2 +497,1 @@\n-  HeapWord* satisfy_failed_allocation(size_t word_size,\n-                                      bool* succeeded);\n+  HeapWord* satisfy_failed_allocation(size_t word_size);\n@@ -513,2 +512,1 @@\n-                                             bool expect_null_mutator_alloc_region,\n-                                             bool* gc_succeeded);\n+                                             bool expect_null_mutator_alloc_region);\n@@ -745,3 +743,1 @@\n-  \/\/ followed by a by-policy upgrade to a full collection.  Returns\n-  \/\/ false if unable to do the collection due to the GC locker being\n-  \/\/ active, true otherwise.\n+  \/\/ followed by a by-policy upgrade to a full collection.\n@@ -750,1 +746,1 @@\n-  bool do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-    _gc_succeeded = g1h->do_collection_pause_at_safepoint();\n-    assert(_gc_succeeded, \"No reason to fail\");\n+    g1h->do_collection_pause_at_safepoint();\n+    _gc_succeeded = true;\n@@ -113,2 +113,1 @@\n-  VM_CollectForAllocation(word_size, gc_count_before, gc_cause),\n-  _gc_succeeded(false) {}\n+  VM_CollectForAllocation(word_size, gc_count_before, gc_cause) {}\n@@ -121,2 +120,1 @@\n-  _gc_succeeded = g1h->do_collection_pause_at_safepoint();\n-  assert(_gc_succeeded, \"no reason to fail\");\n+  g1h->do_collection_pause_at_safepoint();\n@@ -127,1 +125,1 @@\n-    _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+    _result = g1h->satisfy_failed_allocation(_word_size);\n@@ -132,1 +130,1 @@\n-    _gc_succeeded = g1h->upgrade_to_full_collection();\n+    g1h->upgrade_to_full_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+  \/\/ The concurrent start pause may be cancelled for some reasons. Keep track of\n+  \/\/ this.\n@@ -68,1 +70,0 @@\n-  bool _gc_succeeded;\n@@ -76,1 +77,1 @@\n-  bool gc_succeeded() const { return _gc_succeeded; }\n+  bool gc_succeeded() const { return prologue_succeeded(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}