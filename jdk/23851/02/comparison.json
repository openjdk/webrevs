{"files":[{"patch":"@@ -2045,9 +2045,3 @@\n-Node* ReverseINode::Identity(PhaseGVN* phase) {\n-  if (in(1)->Opcode() == Op_ReverseI) {\n-    return in(1)->in(1);\n-  }\n-  return this;\n-}\n-\n-Node* ReverseLNode::Identity(PhaseGVN* phase) {\n-  if (in(1)->Opcode() == Op_ReverseL) {\n+Node* InvolutionNode::Identity(PhaseGVN* phase) {\n+  \/\/ Op ( Op x ) => x\n+  if (in(1)->Opcode() == Opcode()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -442,0 +442,7 @@\n+\/\/------------------------------InvolutionNode----------------------------------\n+\/\/ Represents a self-inverse operation, i.e., op(op(x)) = x for any x\n+class InvolutionNode : public Node {\n+public:\n+  InvolutionNode(Node* in) : Node(nullptr, in) {}\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n@@ -444,1 +451,1 @@\n-class NegNode : public Node {\n+class NegNode : public InvolutionNode {\n@@ -446,1 +453,1 @@\n-  NegNode(Node* in1) : Node(nullptr, in1) {\n+  NegNode(Node* in1) : InvolutionNode(in1) {\n@@ -559,1 +566,1 @@\n-class ReverseBytesINode : public Node {\n+class ReverseBytesINode : public InvolutionNode {\n@@ -561,1 +568,1 @@\n-  ReverseBytesINode(Node* in) : Node(nullptr, in) {}\n+  ReverseBytesINode(Node* in) : InvolutionNode(in) {}\n@@ -569,1 +576,1 @@\n-class ReverseBytesLNode : public Node {\n+class ReverseBytesLNode : public InvolutionNode {\n@@ -571,1 +578,1 @@\n-  ReverseBytesLNode(Node* in) : Node(nullptr, in) {}\n+  ReverseBytesLNode(Node* in) : InvolutionNode(in) {}\n@@ -579,1 +586,1 @@\n-class ReverseBytesUSNode : public Node {\n+class ReverseBytesUSNode : public InvolutionNode {\n@@ -581,1 +588,1 @@\n-  ReverseBytesUSNode(Node* in1) : Node(nullptr, in1) {}\n+  ReverseBytesUSNode(Node* in1) : InvolutionNode(in1) {}\n@@ -589,1 +596,1 @@\n-class ReverseBytesSNode : public Node {\n+class ReverseBytesSNode : public InvolutionNode {\n@@ -591,1 +598,1 @@\n-  ReverseBytesSNode(Node* in) : Node(nullptr, in) {}\n+  ReverseBytesSNode(Node* in) : InvolutionNode(in) {}\n@@ -599,1 +606,1 @@\n-class ReverseINode : public Node {\n+class ReverseINode : public InvolutionNode {\n@@ -601,1 +608,1 @@\n-  ReverseINode(Node* in) : Node(nullptr, in) {}\n+  ReverseINode(Node* in) : InvolutionNode(in) {}\n@@ -605,1 +612,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n@@ -611,1 +617,1 @@\n-class ReverseLNode : public Node {\n+class ReverseLNode : public InvolutionNode {\n@@ -613,1 +619,1 @@\n-  ReverseLNode(Node* in) : Node(nullptr, in) {}\n+  ReverseLNode(Node* in) : InvolutionNode(in) {}\n@@ -617,1 +623,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8350988\n+ * @summary Test that Identity simplifications of Involution nodes are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.InvolutionIdentityTests\n+ *\/\n+public class InvolutionIdentityTests {\n+\n+    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"testI1\", \"testI2\",\n+        \"testL1\", \"testL2\",\n+        \"testS1\",\n+        \"testUS1\",\n+        \"testF1\",\n+        \"testD1\"\n+    })\n+    public void runMethod() {\n+        int ai = GEN_INT.next();\n+\n+        int mini = Integer.MIN_VALUE;\n+        int maxi = Integer.MAX_VALUE;\n+\n+        assertResultI(0);\n+        assertResultI(ai);\n+        assertResultI(mini);\n+        assertResultI(maxi);\n+\n+        long al = GEN_LONG.next();\n+\n+        long minl = Long.MIN_VALUE;\n+        long maxl = Long.MAX_VALUE;\n+\n+        assertResultL(0);\n+        assertResultL(al);\n+        assertResultL(minl);\n+        assertResultL(maxl);\n+\n+        short as = GEN_SHORT.next().shortValue();\n+\n+        short mins = Short.MIN_VALUE;\n+        short maxs = Short.MAX_VALUE;\n+\n+        assertResultS((short) 0);\n+        assertResultS(as);\n+        assertResultS(mins);\n+        assertResultS(maxs);\n+\n+        char ac = (char) GEN_CHAR.next().intValue();\n+\n+        char minc = Character.MIN_VALUE;\n+        char maxc = Character.MAX_VALUE;\n+\n+        assertResultUS((char) 0);\n+        assertResultUS(ac);\n+        assertResultUS(minc);\n+        assertResultUS(maxc);\n+\n+        float af = GEN_FLOAT.next();\n+        float inf = Float.POSITIVE_INFINITY;\n+        float nanf = Float.NaN;\n+\n+        assertResultF(0f);\n+        assertResultF(-0f);\n+        assertResultF(af);\n+        assertResultF(inf);\n+        assertResultF(nanf);\n+\n+        double ad = GEN_DOUBLE.next();\n+        double ind = Double.POSITIVE_INFINITY;\n+        double nand = Double.NaN;\n+\n+        assertResultD(0d);\n+        assertResultD(-0d);\n+        assertResultD(ad);\n+        assertResultD(ind);\n+        assertResultD(nand);\n+\n+    }\n+\n+    @DontCompile\n+    public void assertResultI(int a) {\n+        Asserts.assertEQ(Integer.reverseBytes(Integer.reverseBytes(a)), testI1(a));\n+        Asserts.assertEQ(Integer.reverse(Integer.reverse(a))          , testI2(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultL(long a) {\n+        Asserts.assertEQ(Long.reverseBytes(Long.reverseBytes(a)), testL1(a));\n+        Asserts.assertEQ(Long.reverse(Long.reverse(a))          , testL2(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultS(short a) {\n+        Asserts.assertEQ(Short.reverseBytes(Short.reverseBytes(a)), testS1(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultUS(char a) {\n+        Asserts.assertEQ(Character.reverseBytes(Character.reverseBytes(a)), testUS1(a));\n+    }\n+\n+    @DontCompile\n+    public void assertResultF(float a) {\n+        Asserts.assertEQ(Float.floatToRawIntBits(-(-a)), Float.floatToRawIntBits(testF1(a)));\n+    }\n+\n+    @DontCompile\n+    public void assertResultD(double a) {\n+        Asserts.assertEQ(Double.doubleToRawLongBits(-(-a)), Double.doubleToRawLongBits(testD1(a)));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_I})\n+    public int testI1(int x) {\n+        return Integer.reverseBytes(Integer.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_I})\n+    public int testI2(int x) {\n+        return Integer.reverse(Integer.reverse(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_L})\n+    public long testL1(long x) {\n+        return Long.reverseBytes(Long.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_L})\n+    public long testL2(long x) {\n+        return Long.reverse(Long.reverse(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_S})\n+    public short testS1(short x) {\n+        return Short.reverseBytes(Short.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.REVERSE_BYTES_US})\n+    public char testUS1(char x) {\n+        return Character.reverseBytes(Character.reverseBytes(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.NEG_F})\n+    public float testF1(float x) {\n+        return -(-x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.NEG_D})\n+    public double testD1(double x) {\n+        return -(-x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/InvolutionIdentityTests.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -1353,0 +1353,10 @@\n+    public static final String NEG_F = PREFIX + \"NEG_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_F, \"NegF\");\n+    }\n+\n+    public static final String NEG_D = PREFIX + \"NEG_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_D, \"NegD\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}