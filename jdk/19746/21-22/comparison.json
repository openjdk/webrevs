{"files":[{"patch":"@@ -357,0 +357,1 @@\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3893,0 +3893,1 @@\n+  predicate(!(UseG1GC && n->as_Load()->barrier_data() != 0));\n@@ -4359,0 +4360,1 @@\n+  predicate(!(UseG1GC && n->as_Store()->barrier_data() != 0));\n@@ -5393,0 +5395,1 @@\n+  predicate(!(UseG1GC && n->as_LoadStore()->barrier_data() != 0));\n@@ -5662,0 +5665,1 @@\n+  predicate(!(UseG1GC && n->as_LoadStore()->barrier_data() != 0));\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,2 +122,3 @@\n-    assert((set1._encoding & set2._encoding) == 0,\n-           \"encoding constraint\");\n+\/\/    why so strong constraint?\n+\/\/    assert((set1._encoding & set2._encoding) == 0,\n+\/\/           \"encoding constraint\");\n@@ -145,0 +146,5 @@\n+\n+  static RegisterSet from(RegSet set) {\n+    assert(set.size(), \"RegSet must not be empty\");\n+    return RegisterSet(set.bits());\n+  }\n@@ -160,0 +166,4 @@\n+  FloatRegisterSet() {\n+    _encoding = 0;\n+  }\n+\n@@ -188,0 +198,9 @@\n+  static FloatRegisterSet from(FloatRegSet set) {\n+    assert(set.size(), \"FloatRegSet must not be empty\");\n+    \/\/ the vector load\/store instructions operate on a set of consecutive registers.\n+    \/\/ for the sake of simplicity, write all registers between the first and last in the set\n+    size_t range =  (*set.rbegin())->encoding() - (*set.begin())->encoding() + 1;\n+    \/\/ push_float stores float regisgters by pairs\n+    return  FloatRegisterSet(*set.begin(), (range+1)\/2);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n-#endif\n-\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -109,24 +111,14 @@\n-\/\/ G1 pre-barrier.\n-\/\/ Blows all volatile registers R0-R3, Rtemp, LR).\n-\/\/ If store_addr != noreg, then previous value is loaded from [store_addr];\n-\/\/ in such case store_addr and new_val registers are preserved;\n-\/\/ otherwise pre_val register is preserved.\n-void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,\n-                                          Register store_addr,\n-                                          Register new_val,\n-                                          Register pre_val,\n-                                          Register tmp1,\n-                                          Register tmp2) {\n-  Label done;\n-  Label runtime;\n-\n-  if (store_addr != noreg) {\n-    assert_different_registers(store_addr, new_val, pre_val, tmp1, tmp2, noreg);\n-  } else {\n-    assert (new_val == noreg, \"should be\");\n-    assert_different_registers(pre_val, tmp1, tmp2, noreg);\n-  }\n-\n-  Address in_progress(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(Rthread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register temp1, const Register temp2) {\n+  assert_different_registers(value, temp1, temp2);\n+  \/\/ Can we store original value in the thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ldr(temp1, Address(thread, in_bytes(index_offset)));  \/\/ temp1 := *(index address)\n+  __ cbz(temp1, runtime);                                  \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(temp1, temp1, wordSize);                          \/\/ temp1 := next index\n+  __ str(temp1, Address(thread, in_bytes(index_offset)));  \/\/ *(index address) := next index\n+  __ ldr(temp2, Address(thread, in_bytes(buffer_offset))); \/\/ temp2 := buffer address\n+  \/\/ Record the previous value\n+  __ str(value, Address(temp2, temp1));                    \/\/ *(buffer address + next index) := value\n+ }\n@@ -134,0 +126,4 @@\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n@@ -137,1 +133,1 @@\n-  __ cbz(tmp1, done);\n+}\n@@ -139,0 +135,8 @@\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n@@ -140,2 +144,2 @@\n-  if (store_addr != noreg) {\n-    __ load_heap_oop(pre_val, Address(store_addr, 0));\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0));\n@@ -147,3 +151,7 @@\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ b(done);\n+}\n@@ -151,2 +159,12 @@\n-  __ ldr(tmp1, index);           \/\/ tmp1 := *index_adr\n-  __ ldr(tmp2, buffer);\n+\/\/ G1 pre-barrier.\n+\/\/ Blows all volatile registers R0-R3, LR).\n+\/\/ If obj != noreg, then previous value is loaded from [obj];\n+\/\/ in such case obj and pre_val registers is preserved;\n+\/\/ otherwise pre_val register is preserved.\n+void G1BarrierSetAssembler::g1_write_barrier_pre(MacroAssembler* masm,\n+                                          Register obj,\n+                                          Register pre_val,\n+                                          Register tmp1,\n+                                          Register tmp2) {\n+  Label done;\n+  Label runtime;\n@@ -154,2 +172,1 @@\n-  __ subs(tmp1, tmp1, wordSize); \/\/ tmp1 := tmp1 - wordSize\n-  __ b(runtime, lt);             \/\/ If negative, goto runtime\n+  assert_different_registers(obj, pre_val, tmp1, tmp2, noreg);\n@@ -157,1 +174,3 @@\n-  __ str(tmp1, index);           \/\/ *index_adr := tmp1\n+  generate_pre_barrier_fast_path(masm, Rthread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n+  __ cbz(tmp1, done);\n@@ -159,3 +178,1 @@\n-  \/\/ Record the previous value\n-  __ str(pre_val, Address(tmp2, tmp1));\n-  __ b(done);\n+   generate_pre_barrier_slow_path(masm, obj, pre_val, Rthread, tmp1, tmp2, done, runtime);\n@@ -166,5 +183,5 @@\n-  if (store_addr != noreg) {\n-    \/\/ avoid raw_push to support any ordering of store_addr and new_val\n-    __ push(RegisterSet(store_addr) | RegisterSet(new_val));\n-  } else {\n-    __ push(pre_val);\n+  RegisterSet set = RegisterSet(pre_val) | RegisterSet(R0, R3) | RegisterSet(R12);\n+  \/\/ save the live input values\n+  if (obj != noreg) {\n+    \/\/ avoid raw_push to support any ordering of store_addr and pre_val\n+    set = set | RegisterSet(obj);\n@@ -173,0 +190,2 @@\n+  __ push(set);\n+\n@@ -180,6 +199,1 @@\n-  if (store_addr != noreg) {\n-    __ pop(RegisterSet(store_addr) | RegisterSet(new_val));\n-  } else {\n-    __ pop(pre_val);\n-  }\n-\n+  __ pop(set);\n@@ -189,18 +203,7 @@\n-\/\/ G1 post-barrier.\n-\/\/ Blows all volatile registers R0-R3, Rtemp, LR).\n-void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,\n-                                           Register store_addr,\n-                                           Register new_val,\n-                                           Register tmp1,\n-                                           Register tmp2,\n-                                           Register tmp3) {\n-\n-  Address queue_index(Rthread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(Rthread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-  Label done;\n-  Label runtime;\n-\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n@@ -214,3 +217,3 @@\n-\n-  __ cbz(new_val, done);\n-\n+  if (new_val_may_be_null) {\n+    __ cbz(new_val, done);\n+  }\n@@ -220,1 +223,2 @@\n-  __ mov_address(tmp2, (address)ct->byte_map_base());\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  __ mov_address(tmp2, (address)ct->card_table()->byte_map_base());\n@@ -225,1 +229,1 @@\n-  __ b(done, eq);\n+}\n@@ -227,0 +231,7 @@\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            const Register tmp3,\n+                                            Label& done,\n+                                            Label& runtime) {\n@@ -228,1 +239,0 @@\n-\n@@ -230,0 +240,2 @@\n+  \/\/ card_addr is loaded by generate_post_barrier_fast_path\n+  const Register card_addr = tmp1;\n@@ -237,0 +249,7 @@\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, card_addr, tmp2, tmp3);\n+  __ b(done);\n+}\n@@ -238,5 +257,0 @@\n-  __ ldr(tmp2, queue_index);\n-  __ ldr(tmp3, buffer);\n-\n-  __ subs(tmp2, tmp2, wordSize);\n-  __ b(runtime, lt); \/\/ go to runtime if now negative\n@@ -244,1 +258,10 @@\n-  __ str(tmp2, queue_index);\n+\/\/ G1 post-barrier.\n+\/\/ Blows all volatile registers R0-R3,  LR).\n+void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,\n+                                           Register store_addr,\n+                                           Register new_val,\n+                                           Register tmp1,\n+                                           Register tmp2,\n+                                           Register tmp3) {\n+  Label done;\n+  Label runtime;\n@@ -246,2 +269,7 @@\n-  __ str(card_addr, Address(tmp3, tmp2));\n-  __ b(done);\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n+  \/\/ card_addr and card are loaded by generate_post_barrier_fast_path\n+  const Register card      = tmp2;\n+  const Register card_addr = tmp1;\n+   __ b(done, eq);\n+  generate_post_barrier_slow_path(masm, Rthread, card_addr, tmp2, tmp3, done, runtime);\n@@ -251,0 +279,3 @@\n+  RegisterSet set = RegisterSet(store_addr) | RegisterSet(R0, R3) | RegisterSet(R12);\n+  __ push(set);\n+\n@@ -257,0 +288,2 @@\n+  __ pop(set);\n+\n@@ -260,0 +293,89 @@\n+#if defined(COMPILER2)\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path, Register tmp1) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, Rthread);\n+  __ call_VM_leaf(runtime_path, R0, R1);\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == Rthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n+\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ cbnz(tmp1, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n+\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), tmp1);\n+  __ b(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     Register tmp3,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == Rthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, noreg);\n+\n+  stub->initialize_registers(thread, tmp1, tmp2, tmp3);\n+\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ b(*stub->entry(), ne);\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  Register tmp3 = stub->tmp3();\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, tmp3,  *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp2);\n+  __ b(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n@@ -271,1 +393,1 @@\n-    g1_write_barrier_pre(masm, noreg, noreg, dst, tmp1, tmp2);\n+    g1_write_barrier_pre(masm, noreg, dst, tmp1, tmp2);\n@@ -298,1 +420,1 @@\n-    g1_write_barrier_pre(masm, store_addr, new_val, tmp1, tmp2, tmp3);\n+    g1_write_barrier_pre(masm, store_addr, tmp3 \/*pre_val*\/, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":207,"deletions":85,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -46,1 +48,0 @@\n-                            Register new_val,\n@@ -73,0 +74,23 @@\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                Register tmp3,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_arm.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, Rthread, tmp1, tmp2, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               Register tmp3) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, Rthread, tmp1, tmp2, tmp3, stub);\n+}\n+\n+%}\n+\n+instruct g1StoreP(indirect mem, iRegP src, iRegP tmp1, iRegP tmp2, iRegP tmp3, flagsReg icc)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL icc);\n+  ins_cost(2 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"sd  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ str($src$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/,\n+                       $tmp3$$Register \/* tmp3 *\/);\n+  %}\n+  ins_pipe(istore_mem_reg);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegI res, indirect mem, iRegP newval, iRegP tmp1, iRegP tmp2, iRegP tmp3, iRegP oldval, flagsReg ccr )\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  effect(KILL ccr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(4 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"loop: \\n\\t\"\n+            \"LDREX    $tmp1, $mem\\t! If $oldval==[$mem] Then store $newval into [$mem]\\n\\t\"\n+            \"CMP      $tmp1, $oldval\\n\\t\"\n+            \"STREX.eq $tmp1, $newval, $mem\\n\\t\"\n+            \"MOV.ne   $tmp1, 0 \\n\\t\"\n+            \"EORS.eq  $tmp1,$tmp1, 1 \\n\\t\"\n+            \"B.eq     loop \\n\\t\"\n+            \"MOV      $res, $tmp1\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    Label loop;\n+    __ bind(loop);\n+    __ ldrex($tmp1$$Register,$mem$$Address);\n+    __ cmp($tmp1$$Register, $oldval$$Register);\n+    __ strex($tmp1$$Register, $newval$$Register, $mem$$Address, eq);\n+    __ mov($tmp1$$Register, 0, ne);\n+    __ eors($tmp1$$Register, $tmp1$$Register, 1, eq);\n+    __ b(loop, eq);\n+    __ mov($res$$Register, $tmp1$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp2$$Register \/* tmp2 *\/,\n+                       $tmp3$$Register \/* tmp3 *\/);\n+  %}\n+  ins_pipe(long_memory_op);\n+%}\n+\n+\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegP tmp1, iRegP tmp2, iRegP tmp3, iRegP preval, flagsReg ccr)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(KILL ccr, TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(4 * (MEMORY_REF_COST + BRANCH_COST));\n+  format %{ \"loop: \\n\\t\"\n+            \"LDREX    $preval, $mem\\n\\t\"\n+            \"STREX    $tmp1, $newval, $mem\\n\\t\"\n+            \"CMP      $tmp1, 0 \\n\\t\"\n+            \"B.ne     loop \\n\\t\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    Label loop;\n+    __ bind(loop);\n+    __ ldrex($preval$$Register,$mem$$Address);\n+    __ strex($tmp1$$Register, $newval$$Register, $mem$$Address);\n+    __ cmp($tmp1$$Register, 0);\n+    __ b(loop, ne);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/,\n+                       $tmp3$$Register   \/* tmp3 *\/);\n+  %}\n+  ins_pipe(long_memory_op);\n+%}\n+\n+instruct g1LoadP(iRegP dst, indirect mem, iRegP tmp1, iRegP tmp2, flagsReg icc)\n+%{\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL icc);\n+  ins_cost(MEMORY_REF_COST + BRANCH_COST);\n+  format %{ \"ld  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ ldr($dst$$Register, Address($mem$$Register));\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_mem);\n+%}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1_arm.ad","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -34,0 +34,4 @@\n+#ifdef COMPILER2\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n+\n@@ -209,1 +213,11 @@\n-  Unimplemented(); \/\/ This must be implemented to support late barrier expansion.\n+  if (!OptoReg::is_reg(opto_reg)) {\n+    return OptoReg::Bad;\n+  }\n+\n+  const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+  if (!vm_reg->is_valid()){\n+    \/\/ skip APSR and FPSCR\n+    return OptoReg::Bad;\n+  }\n+\n+  return opto_reg;\n@@ -212,0 +226,40 @@\n+void SaveLiveRegisters::initialize(BarrierStubC2* stub) {\n+  \/\/ Record registers that needs to be saved\/restored\n+  RegMaskIterator rmi(stub->preserve_set());\n+  while (rmi.has_next()) {\n+    const OptoReg::Name opto_reg = rmi.next();\n+    if (OptoReg::is_reg(opto_reg)) {\n+      const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+      if (vm_reg->is_Register()) {\n+        gp_regs += RegSet::of(vm_reg->as_Register());\n+      } else if (vm_reg->is_FloatRegister()) {\n+        fp_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n+      } else {\n+        fatal(\"Unknown register type\");\n+      }\n+    }\n+  }\n+  \/\/ Remove C-ABI SOE registers that will be updated\n+  gp_regs -= RegSet::range(R4, R11) + RegSet::of(R13, R15);\n+\n+  \/\/ Remove C-ABI SOE fp registers\n+  fp_regs -= FloatRegSet::range(S16, S31);\n+}\n+\n+SaveLiveRegisters::SaveLiveRegisters(MacroAssembler* masm, BarrierStubC2* stub)\n+  : masm(masm),\n+    gp_regs(),\n+    fp_regs() {\n+  \/\/ Figure out what registers to save\/restore\n+  initialize(stub);\n+\n+  \/\/ Save registers\n+  if (gp_regs.size() > 0) __ push(RegisterSet::from(gp_regs));\n+  if (fp_regs.size() > 0) __ fpush(FloatRegisterSet::from(fp_regs));\n+}\n+\n+SaveLiveRegisters::~SaveLiveRegisters() {\n+  \/\/ Restore registers\n+  if (fp_regs.size() > 0) __ fpop(FloatRegisterSet::from(fp_regs));\n+  if (gp_regs.size() > 0) __ pop(RegisterSet::from(gp_regs));\n+}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -35,0 +36,1 @@\n+class BarrierStubC2;\n@@ -72,0 +74,22 @@\n+#ifdef COMPILER2\n+\/\/ This class saves and restores the registers that need to be preserved across\n+\/\/ the runtime call represented by a given C2 barrier stub. Use as follows:\n+\/\/ {\n+\/\/   SaveLiveRegisters save(masm, stub);\n+\/\/   ..\n+\/\/   __ bl(...);\n+\/\/   ..\n+\/\/ }\n+class SaveLiveRegisters {\n+private:\n+  MacroAssembler* const masm;\n+  RegSet                gp_regs;\n+  FloatRegSet           fp_regs;\n+\n+public:\n+  void initialize(BarrierStubC2* stub);\n+  SaveLiveRegisters(MacroAssembler* masm, BarrierStubC2* stub);\n+  ~SaveLiveRegisters();\n+};\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -306,0 +306,25 @@\n+typedef AbstractRegSet<Register> RegSet;\n+typedef AbstractRegSet<FloatRegister> FloatRegSet;\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n+}\n+\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_FloatRegister(exact_log2(first)) : fnoreg;\n+}\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::last() {\n+  if (_bitset == 0) { return fnoreg; }\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n+  return as_FloatRegister(last);\n+}\n+\n+\n+\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-  stub->initialize_registers(obj, pre_val, thread, tmp, noreg);\n+  stub->initialize_registers(obj, pre_val, thread, tmp);\n@@ -413,0 +413,1 @@\n+  assert(stub->tmp2() == noreg, \"not needed in this platform\");\n@@ -450,0 +451,1 @@\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-void G1PostBarrierStubC2::initialize_registers(Register thread, Register tmp1, Register tmp2) {\n+void G1PostBarrierStubC2::initialize_registers(Register thread, Register tmp1, Register tmp2, Register tmp3) {\n@@ -464,0 +464,1 @@\n+  _tmp3 = tmp3;\n@@ -478,0 +479,4 @@\n+Register G1PostBarrierStubC2::tmp3() const {\n+  return _tmp3;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  void initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1, Register tmp2);\n+  void initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1 = noreg, Register tmp2 = noreg);\n@@ -72,0 +72,1 @@\n+  Register _tmp3;\n@@ -79,1 +80,1 @@\n-  void initialize_registers(Register thread, Register tmp1, Register tmp2);\n+  void initialize_registers(Register thread, Register tmp1 = noreg, Register tmp2 = noreg, Register tmp3 = noreg);\n@@ -83,0 +84,1 @@\n+  Register tmp3() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}