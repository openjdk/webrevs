{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -42,1 +42,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -99,0 +102,49 @@\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register tmp1, const Register tmp2) {\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ld(tmp1, Address(thread, in_bytes(index_offset)));   \/\/ tmp1 := *(index address)\n+  __ beqz(tmp1, runtime);                                 \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(tmp1, tmp1, wordSize);                           \/\/ tmp1 := next index\n+  __ sd(tmp1, Address(thread, in_bytes(index_offset)));   \/\/ *(index address) := next index\n+  __ ld(tmp2, Address(thread, in_bytes(buffer_offset)));  \/\/ tmp2 := buffer address\n+  __ add(tmp2, tmp2, tmp1);\n+  __ sd(value, Address(tmp2));                            \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ lwu(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ lbu(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ beqz(pre_val, done, true);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ j(done);\n+}\n+\n@@ -119,11 +171,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) { \/\/ 4-byte width\n-    __ lwu(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbu(tmp1, in_progress);\n-  }\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -131,25 +174,1 @@\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ beqz(pre_val, done);\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-\n-  __ ld(tmp1, index);                  \/\/ tmp := *index_adr\n-  __ beqz(tmp1, runtime);              \/\/ tmp == 0?\n-                                       \/\/ If yes, goto runtime\n-\n-  __ sub(tmp1, tmp1, wordSize);        \/\/ tmp := tmp - wordSize\n-  __ sd(tmp1, index);                  \/\/ *index_adr := tmp\n-  __ ld(tmp2, buffer);\n-  __ add(tmp1, tmp1, tmp2);            \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ sd(pre_val, Address(tmp1, 0));\n-  __ j(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, done, runtime);\n@@ -174,0 +193,43 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  \/\/ Does store cross heap regions?\n+  __ xorr(tmp1, store_addr, new_val);                    \/\/ tmp1 := store address ^ new value\n+  __ srli(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);  \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+  __ beqz(tmp1, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ beqz(new_val, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ srli(tmp1, store_addr, CardTable::card_shift());    \/\/ tmp1 := card address relative to card table base\n+  __ load_byte_map_base(tmp2);                           \/\/ tmp2 := card table base address\n+  __ add(tmp1, tmp1, tmp2);                              \/\/ tmp1 := card address\n+  __ lbu(tmp2, Address(tmp1));                           \/\/ tmp2 := card\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(MacroAssembler::StoreLoad);  \/\/ StoreLoad membar\n+  __ lbu(tmp2, Address(tmp1));           \/\/ tmp2 := card\n+  __ beqz(tmp2, done, true);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ sb(zr, Address(tmp1));       \/\/ *(card address) := dirty_card_val\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, tmp1, tmp2, t0);\n+  __ j(done);\n+}\n+\n@@ -182,8 +244,2 @@\n-  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg &&\n-         tmp2 != noreg, \"expecting a register\");\n-\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg,\n+         \"expecting a register\");\n@@ -194,1 +250,5 @@\n-  \/\/ Does store cross heap regions?\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done (tmp2 holds the card value)\n+  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n+  __ beq(tmp2, t0, done);   \/\/ card == young_card_val?\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, done, runtime);\n@@ -196,3 +256,6 @@\n-  __ xorr(tmp1, store_addr, new_val);\n-  __ srli(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n-  __ beqz(tmp1, done);\n+  __ bind(runtime);\n+  \/\/ save the live input values\n+  RegSet saved = RegSet::of(store_addr);\n+  __ push_reg(saved, sp);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp1, thread);\n+  __ pop_reg(saved, sp);\n@@ -200,1 +263,2 @@\n-  \/\/ crosses regions, storing null?\n+  __ bind(done);\n+}\n@@ -202,1 +266,1 @@\n-  __ beqz(new_val, done);\n+#if defined(COMPILER2)\n@@ -204,1 +268,9 @@\n-  \/\/ storing region crossing non-null, is card already dirty?\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mv(c_rarg0, arg);\n+  }\n+  __ mv(c_rarg1, xthread);\n+  __ mv(t0, runtime_path);\n+  __ jalr(t0);\n+}\n@@ -206,1 +278,10 @@\n-  const Register card_addr = tmp1;\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == xthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n@@ -208,1 +289,1 @@\n-  __ srli(card_addr, store_addr, CardTable::card_shift());\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n@@ -210,6 +291,3 @@\n-  \/\/ get the address of the card\n-  __ load_byte_map_base(tmp2);\n-  __ add(card_addr, card_addr, tmp2);\n-  __ lbu(tmp2, Address(card_addr));\n-  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n-  __ beq(tmp2, t0, done);\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ bnez(tmp1, *stub->entry(), true);\n@@ -217,1 +295,2 @@\n-  assert((int)CardTable::dirty_card_val() == 0, \"must be 0\");\n+  __ bind(*stub->continuation());\n+}\n@@ -219,1 +298,9 @@\n-  __ membar(MacroAssembler::StoreLoad);\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n@@ -221,2 +308,2 @@\n-  __ lbu(tmp2, Address(card_addr));\n-  __ beqz(tmp2, done);\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n@@ -224,2 +311,4 @@\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ j(*stub->continuation());\n+}\n@@ -227,1 +316,11 @@\n-  __ sb(zr, Address(card_addr));\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == xthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, t0);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg,\n+         \"expecting a register\");\n@@ -229,4 +328,1 @@\n-  __ ld(t0, queue_index);\n-  __ beqz(t0, runtime);\n-  __ sub(t0, t0, wordSize);\n-  __ sd(t0, queue_index);\n+  stub->initialize_registers(thread, tmp1, tmp2);\n@@ -234,4 +330,5 @@\n-  __ ld(tmp2, buffer);\n-  __ add(t0, tmp2, t0);\n-  __ sd(card_addr, Address(t0, 0));\n-  __ j(done);\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path) (tmp2 holds the card value)\n+  __ mv(t0, (int)G1CardTable::g1_young_card_val());\n+  __ bne(tmp2, t0, *stub->entry(), true);\n@@ -239,6 +336,2 @@\n-  __ bind(runtime);\n-  \/\/ save the live input values\n-  RegSet saved = RegSet::of(store_addr);\n-  __ push_reg(saved, sp);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n-  __ pop_reg(saved, sp);\n+  __ bind(*stub->continuation());\n+}\n@@ -246,1 +339,14 @@\n-  __ bind(done);\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ j(*stub->continuation());\n@@ -249,0 +355,2 @@\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":191,"deletions":83,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2024, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -39,0 +39,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -75,0 +77,21 @@\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               Register tmp2,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,582 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2024, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_riscv.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              Register tmp2,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, xthread, tmp1, tmp2, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, xthread, tmp1, tmp2, stub);\n+}\n+\n+%}\n+\n+instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreP mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"sd  $src, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ sd($src$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"sw  $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    __ sw($src$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ decode_heap_oop($tmp1$$Register, $src$$Register);\n+      } else {\n+        __ decode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+      }\n+    }\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(STORE_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"sw  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ encode_heap_oop($tmp1$$Register, $src$$Register);\n+    } else {\n+      __ encode_heap_oop_not_null($tmp1$$Register, $src$$Register);\n+    }\n+    __ sw($tmp1$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(istore_reg_mem);\n+%}\n+\n+instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP and its Acq variant.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+    __ decode_heap_oop($tmp2$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# narrow oop\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+    __ decode_heap_oop($tmp2$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegP oldval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegP oldval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (ptr)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1 *\/,\n+                      $tmp3$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"cmpxchg $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+    __ decode_heap_oop($tmp2$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"cmpxchg_acq $mem, $oldval, $newval\\t# (narrow oop)\\n\\t\"\n+            \"mv $res, $res == $oldval\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($oldval$$Register, $mem$$Register);\n+    assert_different_registers($newval$$Register, $mem$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+    __ mv($tmp1$$Register, $oldval$$Register);\n+    __ mv($tmp2$$Register, $newval$$Register);\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register, Assembler::uint32,\n+              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+              \/*result as bool*\/ true);\n+    __ decode_heap_oop($tmp2$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp2$$Register \/* new_val *\/,\n+                       $tmp1$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetP mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg_acq  $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register    \/* obj *\/,\n+                      $preval$$Register \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register   \/* tmp1 *\/,\n+                      $tmp2$$Register   \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register    \/* store_addr *\/,\n+                       $newval$$Register \/* new_val *\/,\n+                       $tmp1$$Register   \/* tmp1 *\/,\n+                       $tmp2$$Register   \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+%{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(2 * VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgwu $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgwu($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1GetAndSetNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+%{\n+  predicate(UseG1GC && needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set preval (GetAndSetN mem newval));\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgwu_acq $preval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    assert_different_registers($mem$$Register, $newval$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1 *\/,\n+                      $tmp3$$Register \/* tmp2 *\/,\n+                      RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) \/* preserve *\/);\n+    __ atomic_xchgalwu($preval$$Register, $newval$$Register, $mem$$Register);\n+    __ decode_heap_oop($tmp1$$Register, $newval$$Register);\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val *\/,\n+                       $tmp2$$Register \/* tmp1 *\/,\n+                       $tmp3$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+%{\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n+  ins_cost(LOAD_COST + BRANCH_COST);\n+  format %{ \"ld  $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ ld($dst$$Register, Address($mem$$Register));\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      $tmp2$$Register \/* tmp2 *\/);\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+%{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"lwu  $dst, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    guarantee($mem$$disp == 0, \"impossible encoding\");\n+    __ lwu($dst$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ decode_heap_oop($tmp1$$Register, $dst$$Register);\n+      write_barrier_pre(masm, this,\n+                        noreg \/* obj *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register \/* tmp1 *\/,\n+                        $tmp3$$Register \/* tmp2 *\/);\n+    }\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1_riscv.ad","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -2215,1 +2215,2 @@\n-      is_vector_scalar_bitwise_pattern(n, m)) {\n+      is_vector_scalar_bitwise_pattern(n, m) ||\n+      is_encode_and_store_pattern(n, m)) {\n@@ -4776,0 +4777,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -5211,0 +5213,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5225,0 +5228,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5415,0 +5419,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5536,1 +5541,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -5644,0 +5649,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5777,1 +5783,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -5905,0 +5911,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -6036,1 +6043,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -6108,0 +6115,2 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+\n@@ -6173,1 +6182,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate(needs_acquiring_load_reserved(n) && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"}]}