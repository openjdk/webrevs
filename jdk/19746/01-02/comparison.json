{"files":[{"patch":"@@ -114,1 +114,3 @@\n-static Register generate_marking_active_test(MacroAssembler* masm, const Register thread, const Register tmp1) {\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n@@ -116,0 +118,1 @@\n+  \/\/ Is marking active?\n@@ -117,1 +120,1 @@\n-    __ ldrw(tmp1, in_progress);  \/\/ tmp1 := *(mark queue active address)\n+    __ ldrw(tmp1, in_progress);\n@@ -120,1 +123,1 @@\n-    __ ldrb(tmp1, in_progress);  \/\/ tmp1 := *(mark queue active address)\n+    __ ldrb(tmp1, in_progress);\n@@ -122,1 +125,0 @@\n-  return tmp1;\n@@ -125,1 +127,9 @@\n-static Register generate_pre_val_not_null_test(MacroAssembler* masm, const Register obj, const Register pre_val) {\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n@@ -127,1 +137,1 @@\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);  \/\/ pre_val := previous value\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n@@ -129,1 +139,8 @@\n-  return pre_val;\n+  \/\/ Is the previous value null?\n+  __ cbz(pre_val, done);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ b(done);\n@@ -152,12 +169,4 @@\n-  Register is_marking_active = generate_marking_active_test(masm, thread, tmp1);\n-  __ cbzw(is_marking_active, done);\n-\n-  Register is_pre_val_not_null = generate_pre_val_not_null_test(masm, obj, pre_val);\n-  __ cbz(is_pre_val_not_null, done);\n-\n-  generate_queue_test_and_insertion(masm,\n-                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                                    runtime,\n-                                    thread, pre_val, tmp1, tmp2);\n-  __ b(done);\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n+  __ cbzw(tmp1, done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, done, runtime);\n@@ -194,7 +203,16 @@\n-static Register generate_region_crossing_test(MacroAssembler* masm, const Register store_addr, const Register new_val, const Register tmp1) {\n-  __ eor(tmp1, store_addr, new_val);                  \/\/ tmp1 := store address ^ new value\n-  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);  \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n-  return tmp1;\n-}\n-\n-static void generate_card_young_test(MacroAssembler* masm, const Register store_addr, const Register tmp1, const Register tmp2) {\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+    \/\/ Does store cross heap regions?\n+  __ eor(tmp1, store_addr, new_val);                     \/\/ tmp1 := store address ^ new value\n+  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);   \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+  __ cbz(tmp1, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cbz(new_val, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card already dirty?\n@@ -208,1 +226,6 @@\n-static Register generate_card_clean_test(MacroAssembler* masm, const Register tmp1 \/* card address *\/, const Register tmp2) {\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n@@ -211,4 +234,3 @@\n-  return tmp2;\n-}\n-\n-static void generate_dirty_card(MacroAssembler* masm, const Register tmp1 \/* card address *\/) {\n+  __ cbzw(tmp2, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n@@ -216,1 +238,7 @@\n-  __ strb(zr, Address(tmp1));  \/\/ *(card address) := dirty_card_val\n+  __ strb(zr, Address(tmp1));       \/\/ *(card address) := dirty_card_val\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, tmp1, tmp2, rscratch1);\n+  __ b(done);\n@@ -234,8 +262,2 @@\n-  Register is_region_crossing = generate_region_crossing_test(masm, store_addr, new_val, tmp1);\n-  __ cbz(is_region_crossing, done);\n-\n-  \/\/ crosses regions, storing null?\n-  __ cbz(new_val, done);\n-\n-  generate_card_young_test(masm, store_addr, tmp1, tmp2);\n-  \/\/ From here on, tmp1 holds the card address.\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n@@ -243,12 +265,1 @@\n-\n-  Register is_card_clean = generate_card_clean_test(masm, tmp1, tmp2);\n-  __ cbzw(is_card_clean, done);\n-\n-  generate_dirty_card(masm, tmp1);\n-\n-  generate_queue_test_and_insertion(masm,\n-                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n-                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n-                                    runtime,\n-                                    thread, tmp1, tmp2, rscratch1);\n-  __ b(done);\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, done, runtime);\n@@ -294,2 +305,3 @@\n-  Register is_marking_active = generate_marking_active_test(masm, thread, tmp1);\n-  __ cbnzw(is_marking_active, *stub->entry());\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ cbnzw(tmp1, *stub->entry());\n@@ -311,10 +323,1 @@\n-\n-  Register is_pre_val_not_null = generate_pre_val_not_null_test(masm, obj, pre_val);\n-  __ cbz(is_pre_val_not_null, *stub->continuation());\n-\n-  generate_queue_test_and_insertion(masm,\n-                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                                    runtime,\n-                                    thread, pre_val, tmp1, tmp2);\n-  __ b(*stub->continuation());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n@@ -342,10 +345,3 @@\n-  Register is_region_crossing = generate_region_crossing_test(masm, store_addr, new_val, tmp1);\n-  __ cbz(is_region_crossing, *stub->continuation());\n-\n-  \/\/ crosses regions, storing null?\n-  if ((stub->barrier_data() & G1C2BarrierPostNotNull) == 0) {\n-    __ cbz(new_val, *stub->continuation());\n-  }\n-\n-  generate_card_young_test(masm, store_addr, tmp1, tmp2);\n-  \/\/ From here on, tmp1 holds the card address.\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n@@ -366,12 +362,1 @@\n-\n-  Register is_card_clean = generate_card_clean_test(masm, tmp1, tmp2);\n-  __ cbzw(is_card_clean, *stub->continuation());\n-\n-  generate_dirty_card(masm, tmp1);\n-\n-  generate_queue_test_and_insertion(masm,\n-                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n-                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n-                                    runtime,\n-                                    thread, tmp1, tmp2, rscratch1);\n-  __ b(*stub->continuation());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, *stub->continuation(), runtime);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":71,"deletions":86,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-static Assembler::Condition generate_marking_active_test(MacroAssembler* masm, const Register thread) {\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread) {\n@@ -184,0 +185,1 @@\n+  \/\/ Is marking active?\n@@ -185,1 +187,1 @@\n-    __ cmpl(in_progress, 0);  \/\/ *(mark queue active address) == 0?\n+    __ cmpl(in_progress, 0);\n@@ -188,1 +190,1 @@\n-    __ cmpb(in_progress, 0);  \/\/ *(mark queue active address) == 0?\n+    __ cmpb(in_progress, 0);\n@@ -190,1 +192,0 @@\n-  return Assembler::notEqual;\n@@ -193,1 +194,8 @@\n-static Assembler::Condition generate_pre_val_null_test(MacroAssembler* masm, const Register obj, const Register pre_val) {\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n@@ -195,1 +203,1 @@\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);  \/\/ pre_val := previous value\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n@@ -197,2 +205,9 @@\n-  __ cmpptr(pre_val, NULL_WORD);                                       \/\/ previous value == null?\n-  return Assembler::equal;\n+  \/\/ Is the previous value null?\n+  __ cmpptr(pre_val, NULL_WORD);\n+  __ jcc(Assembler::equal, done);\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                           runtime,\n+                           thread, pre_val, tmp);\n+  __ jmp(done);\n@@ -226,12 +241,4 @@\n-  Assembler::Condition is_marking_active = generate_marking_active_test(masm, thread);\n-  __ jcc(MacroAssembler::negate_condition(is_marking_active), done);\n-\n-  Assembler::Condition is_pre_val_null = generate_pre_val_null_test(masm, obj, pre_val);\n-  __ jcc(is_pre_val_null, done);\n-\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                           runtime,\n-                           thread, pre_val, tmp);\n-  __ jmp(done);\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n+  __ jcc(Assembler::equal, done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n@@ -279,13 +286,7 @@\n-static Assembler::Condition generate_single_region_test(MacroAssembler* masm, const Register store_addr, const Register new_val, const Register tmp) {\n-  __ movptr(tmp, store_addr);                     \/\/ tmp := store address\n-  __ xorptr(tmp, new_val);                        \/\/ tmp := store address ^ new value\n-  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);  \/\/ ((store address ^ new value) >> LogOfHRGrainBytes) == 0?\n-  return Assembler::equal;\n-}\n-\n-static Assembler::Condition generate_new_val_null_test(MacroAssembler* masm, const Register new_val) {\n-  __ cmpptr(new_val, NULL_WORD);  \/\/ new value == null?\n-  return Assembler::equal;\n-}\n-\n-static Assembler::Condition generate_card_young_test(MacroAssembler* masm, const Register store_addr, const Register tmp, const Register tmp2) {\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n@@ -293,0 +294,11 @@\n+    \/\/ Does store cross heap regions?\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ xorptr(tmp, new_val);                                       \/\/ tmp := store address ^ new value\n+  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);               \/\/ ((store address ^ new value) >> LogOfHRGrainBytes) == 0?\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cmpptr(new_val, NULL_WORD);                               \/\/ new value == null?\n+    __ jcc(Assembler::equal, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card already dirty?\n@@ -300,1 +312,0 @@\n-  return Assembler::equal;\n@@ -303,1 +314,6 @@\n-static Assembler::Condition generate_card_dirty_test(MacroAssembler* masm, const Register tmp \/* card address *\/) {\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n@@ -306,5 +322,10 @@\n-  return Assembler::equal;\n-}\n-\n-static void generate_dirty_card(MacroAssembler* masm, const Register tmp \/* card address *\/) {\n-  __ movb(Address(tmp, 0), G1CardTable::dirty_card_val());  \/\/ *(card address) := dirty_card_val\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  __ movb(Address(tmp, 0), G1CardTable::dirty_card_val());       \/\/ *(card address) := dirty_card_val\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                           runtime,\n+                           thread, tmp, tmp2);\n+  __ jmp(done);\n@@ -323,16 +344,2 @@\n-  Label done, runtime;\n-\n-  Assembler::Condition is_single_region = generate_single_region_test(masm, store_addr, new_val, tmp);\n-  __ jcc(is_single_region, done);\n-\n-  Assembler::Condition is_new_val_null = generate_new_val_null_test(masm, new_val);\n-  __ jcc(is_new_val_null, done);\n-\n-  Assembler::Condition is_card_young = generate_card_young_test(masm, store_addr, tmp, tmp2);\n-  \/\/ From here on, tmp holds the card address.\n-  __ jcc(is_card_young, done);\n-\n-  Assembler::Condition is_card_dirty = generate_card_dirty_test(masm, tmp);\n-  __ jcc(is_card_dirty, done);\n-\n-  generate_dirty_card(masm, tmp);\n+  Label done;\n+  Label runtime;\n@@ -340,6 +347,4 @@\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n-                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n-                           runtime,\n-                           thread, tmp, tmp2);\n-  __ jmp(done);\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n+  __ jcc(Assembler::equal, done);\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, done, runtime);\n@@ -396,2 +401,3 @@\n-  Assembler::Condition is_marking_active = generate_marking_active_test(masm, thread);\n-  __ jcc(is_marking_active, *stub->entry());\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n@@ -412,10 +418,1 @@\n-\n-  Assembler::Condition is_pre_val_null = generate_pre_val_null_test(masm, obj, pre_val);\n-  __ jcc(is_pre_val_null, *stub->continuation());\n-\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                           runtime,\n-                           thread, pre_val, tmp);\n-  __ jmp(*stub->continuation());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n@@ -424,1 +421,0 @@\n-\n@@ -440,1 +436,0 @@\n-  assert(stub != nullptr, \"\");\n@@ -443,11 +438,4 @@\n-  Assembler::Condition is_single_region = generate_single_region_test(masm, store_addr, new_val, tmp);\n-  __ jcc(is_single_region, *stub->continuation());\n-\n-  if ((stub->barrier_data() & G1C2BarrierPostNotNull) == 0) {\n-    Assembler::Condition is_new_val_null = generate_new_val_null_test(masm, new_val);\n-    __ jcc(is_new_val_null, *stub->continuation());\n-  }\n-\n-  Assembler::Condition is_card_young = generate_card_young_test(masm, store_addr, tmp, tmp2);\n-  \/\/ From here on, tmp holds the card address.\n-  __ jcc(MacroAssembler::negate_condition(is_card_young), *stub->entry());\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n@@ -467,12 +455,1 @@\n-\n-  Assembler::Condition is_card_dirty = generate_card_dirty_test(masm, tmp);\n-  __ jcc(is_card_dirty, *stub->continuation());\n-\n-  generate_dirty_card(masm, tmp);\n-\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n-                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n-                           runtime,\n-                           thread, tmp, tmp2);\n-  __ jmp(*stub->continuation());\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, *stub->continuation(), runtime);\n@@ -481,1 +458,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":76,"deletions":100,"binary":false,"changes":176,"status":"modified"}]}