{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -45,1 +45,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -49,1 +52,34 @@\n-#define BLOCK_COMMENT(str) if (PrintAssembly) __ block_comment(str)\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ load_and_test_int(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ load_and_test_byte(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register Z_thread, const Register value, const Register temp) {\n+  BLOCK_COMMENT(\"generate_queue_test_and_insertion {\");\n+\n+  assert_different_registers(temp, value);\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+\n+  __ load_and_test_long(temp, Address(Z_thread, in_bytes(index_offset))); \/\/ temp := *(index address)\n+  __ branch_optimized(Assembler::bcondEqual, runtime);                    \/\/ jump to runtime if index == 0 (full buffer)\n+\n+  \/\/ The buffer is not full, store value into it.\n+  __ add2reg(temp, -wordSize);                                            \/\/ temp := next index\n+  __ z_stg(temp, in_bytes(index_offset), Z_thread);                       \/\/ *(index address) := next index\n+\n+  __ z_ag(temp, Address(Z_thread, in_bytes(buffer_offset)));              \/\/ temp := buffer address + next index\n+  __ z_stg(value, 0, temp);                                               \/\/ *(buffer address + next index) := value\n+  BLOCK_COMMENT(\"} generate_queue_test_and_insertion\");\n+}\n@@ -62,7 +98,2 @@\n-    const int active_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-    if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-      __ load_and_test_int(Rtmp1, Address(Z_thread, active_offset));\n-    } else {\n-      guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-      __ load_and_test_byte(Rtmp1, Address(Z_thread, active_offset));\n-    }\n+\n+    generate_pre_barrier_fast_path(masm, Z_thread, Rtmp1);\n@@ -103,0 +134,175 @@\n+#if defined(COMPILER2)\n+\n+#undef __\n+#define __ masm->\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register pre_val, const address runtime_path) {\n+  BLOCK_COMMENT(\"generate_c2_barrier_runtime_call {\");\n+  SaveLiveRegisters save_registers(masm, stub);\n+  __ call_VM_leaf(runtime_path, pre_val, Z_thread);\n+  BLOCK_COMMENT(\"} generate_c2_barrier_runtime_call\");\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    G1PreBarrierStubC2* stub) {\n+\n+  BLOCK_COMMENT(\"g1_write_barrier_pre_c2 {\");\n+\n+  assert(thread == Z_thread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1);\n+  assert(pre_val != noreg && tmp1 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, noreg);\n+\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  __ branch_optimized(Assembler::bcondNotEqual, *stub->entry()); \/\/ Activity indicator is zero, so there is no marking going on currently.\n+\n+  __ bind(*stub->continuation());\n+\n+  BLOCK_COMMENT(\"} g1_write_barrier_pre_c2\");\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+\n+  BLOCK_COMMENT(\"generate_c2_pre_barrier_stub {\");\n+\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+\n+  Label runtime;\n+  Register obj     = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread  = stub->thread();\n+  Register tmp1    = stub->tmp1();\n+\n+  __ bind(*stub->entry());\n+\n+  BLOCK_COMMENT(\"generate_pre_val_not_null_test {\");\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj), noreg, noreg, AS_RAW);\n+  }\n+  __ z_ltgr(pre_val, pre_val);\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_pre_val_not_null_test\");\n+\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    Z_thread, pre_val, tmp1);\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  __ bind(runtime);\n+\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  BLOCK_COMMENT(\"} generate_c2_pre_barrier_stub\");\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  BLOCK_COMMENT(\"g1_write_barrier_post_c2 {\");\n+\n+  assert(thread == Z_thread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2, Z_R1_scratch);\n+\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(thread, tmp1, tmp2);\n+\n+  BLOCK_COMMENT(\"generate_region_crossing_test {\");\n+  if (VM_Version::has_DistinctOpnds()) {\n+    __ z_xgrk(tmp1, store_addr, new_val);\n+  } else {\n+    __ z_lgr(tmp1, store_addr);\n+    __ z_xgr(tmp1, new_val);\n+  }\n+  __ z_srag(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_region_crossing_test\");\n+\n+  \/\/ crosses regions, storing null?\n+  if ((stub->barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+    __ z_ltgr(new_val, new_val);\n+    __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  }\n+\n+  BLOCK_COMMENT(\"generate_card_young_test {\");\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  \/\/ calculate address of card\n+  __ load_const_optimized(tmp2, (address)ct->card_table()->byte_map_base());      \/\/ Card table base.\n+  __ z_srlg(tmp1, store_addr, CardTable::card_shift());         \/\/ Index into card table.\n+  __ z_algr(tmp1, tmp2);                                      \/\/ Explicit calculation needed for cli.\n+\n+  \/\/ Filter young.\n+  __ z_cli(0, tmp1, G1CardTable::g1_young_card_val());\n+\n+  BLOCK_COMMENT(\"} generate_card_young_test\");\n+\n+  \/\/ From here on, tmp1 holds the card address.\n+  __ branch_optimized(Assembler::bcondNotEqual, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+\n+  BLOCK_COMMENT(\"} g1_write_barrier_post_c2\");\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+\n+  BLOCK_COMMENT(\"generate_c2_post_barrier_stub {\");\n+\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+\n+  Register thread     = stub->thread();\n+  Register tmp1       = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2       = stub->tmp2();\n+  Register Rcard_addr = tmp1;\n+\n+  __ bind(*stub->entry());\n+\n+  BLOCK_COMMENT(\"generate_card_clean_test {\");\n+  __ z_sync(); \/\/ Required to support concurrent cleaning.\n+  __ z_cli(0, Rcard_addr, 0); \/\/ Reload after membar.\n+  __ branch_optimized(Assembler::bcondEqual, *stub->continuation());\n+  BLOCK_COMMENT(\"} generate_card_clean_test\");\n+\n+  BLOCK_COMMENT(\"generate_dirty_card {\");\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ z_mvi(0, Rcard_addr, CardTable::dirty_card_val());\n+  BLOCK_COMMENT(\"} generate_dirty_card\");\n+\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    Z_thread, tmp1, tmp2);\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  __ bind(runtime);\n+\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+\n+  __ branch_optimized(Assembler::bcondAlways, *stub->continuation());\n+\n+  BLOCK_COMMENT(\"} generate_c2_post_barrier_stub\");\n+}\n+\n+#endif \/\/COMPILER2\n+\n@@ -139,3 +345,0 @@\n-  const int active_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-  const int buffer_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-  const int index_offset  = in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset());\n@@ -150,8 +353,1 @@\n-  \/\/ Is marking active?\n-  \/\/ Note: value is loaded for test purposes only. No further use here.\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ load_and_test_int(Rtmp1, Address(Z_thread, active_offset));\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ load_and_test_byte(Rtmp1, Address(Z_thread, active_offset));\n-  }\n+  generate_pre_barrier_fast_path(masm, Z_thread, Rtmp1);\n@@ -197,7 +393,0 @@\n-  Register Rbuffer = Rtmp1, Rindex = Rtmp2;\n-  assert_different_registers(Rbuffer, Rindex, Rpre_val);\n-\n-  __ z_lg(Rbuffer, buffer_offset, Z_thread);\n-\n-  __ load_and_test_long(Rindex, Address(Z_thread, index_offset));\n-  __ z_bre(callRuntime); \/\/ If index == 0, goto runtime.\n@@ -205,5 +394,5 @@\n-  __ add2reg(Rindex, -wordSize); \/\/ Decrement index.\n-  __ z_stg(Rindex, index_offset, Z_thread);\n-\n-  \/\/ Record the previous value.\n-  __ z_stg(Rpre_val, 0, Rbuffer, Rindex);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    callRuntime,\n+                                    Z_thread, Rpre_val, Rtmp2);\n@@ -212,3 +401,0 @@\n-  Rbuffer = noreg;  \/\/ end of life\n-  Rindex  = noreg;  \/\/ end of life\n-\n@@ -329,4 +515,1 @@\n-  Register Rqueue_buf   = (Rtmp3 != Z_R0_scratch) ? Rtmp3 : Rtmp1;\n-  const int qidx_off    = in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset());\n-  const int qbuf_off    = in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset());\n-  if ((Rcard_addr == Rqueue_buf) || (Rcard_addr == Rqueue_index)) {\n+  if (Rcard_addr == Rqueue_index) {\n@@ -337,9 +520,5 @@\n-  __ load_and_test_long(Rqueue_index, Address(Z_thread, qidx_off));\n-  __ z_bre(callRuntime); \/\/ Index == 0 then jump to runtime.\n-\n-  __ z_lg(Rqueue_buf, qbuf_off, Z_thread);\n-\n-  __ add2reg(Rqueue_index, -wordSize); \/\/ Decrement index.\n-  __ z_stg(Rqueue_index, qidx_off, Z_thread);\n-\n-  __ z_stg(Rcard_addr_x, 0, Rqueue_index, Rqueue_buf); \/\/ Store card.\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    callRuntime,\n+                                    Z_thread, Rcard_addr_x, Rqueue_index);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":229,"deletions":50,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -37,0 +37,2 @@\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -65,1 +67,21 @@\n-#endif\n+#endif \/\/ COMPILER1\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp1,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp1,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,457 @@\n+\/\/\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright 2024 IBM Corporation. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+source_hpp %{\n+\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+%}\n+\n+source %{\n+\n+#include \"gc\/g1\/g1BarrierSetAssembler_s390.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+\n+static void write_barrier_pre(MacroAssembler* masm,\n+                              const MachNode* node,\n+                              Register obj,\n+                              Register pre_val,\n+                              Register tmp1,\n+                              RegSet preserve = RegSet(),\n+                              RegSet no_preserve = RegSet()) {\n+  if (!G1PreBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PreBarrierStubC2* const stub = G1PreBarrierStubC2::create(node);\n+  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {\n+    stub->preserve(*reg);\n+  }\n+  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {\n+    stub->dont_preserve(*reg);\n+  }\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, Z_thread, tmp1, stub);\n+}\n+\n+static void write_barrier_post(MacroAssembler* masm,\n+                               const MachNode* node,\n+                               Register store_addr,\n+                               Register new_val,\n+                               Register tmp1,\n+                               Register tmp2) {\n+  if (!G1PostBarrierStubC2::needs_barrier(node)) {\n+    return;\n+  }\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  G1BarrierSetAssembler* g1_asm = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  G1PostBarrierStubC2* const stub = G1PostBarrierStubC2::create(node);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, Z_thread, tmp1, tmp2, stub);\n+}\n+\n+%} \/\/ source\n+\n+\/\/ store pointer\n+instruct g1StoreP(indirect dst, memoryRegP src, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set dst (StoreP dst src));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"STG     $src,$dst\\t # ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1StoreP {\");\n+    write_barrier_pre(masm, this,\n+                      $dst$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($dst$$Register, $src$$Register) \/* preserve *\/);\n+\n+    __ z_stg($src$$Register, Address($dst$$Register));\n+\n+    write_barrier_post(masm, this,\n+                       $dst$$Register, \/* store_addr *\/\n+                       $src$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1StoreP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Store Compressed Pointer\n+instruct g1StoreN(indirect mem, iRegN_P2N src, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"STY     $src,$mem\\t # (cOop)\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1StoreN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+\n+    __ z_sty($src$$Register, Address($mem$$Register));\n+\n+    if ((barrier_data() & G1C2BarrierPost) != 0) {\n+      if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+        __ oop_decoder($tmp1$$Register, $src$$Register, true \/* maybe_null *\/);\n+      } else {\n+        __ oop_decoder($tmp1$$Register, $src$$Register, false \/* maybe_null *\/);\n+      }\n+    }\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1StoreN\");\n+  %}\n+\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndSwapN(indirect mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));\n+  effect(USE mem_ptr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndSwapN $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+    __ block_comment(\"g1compareAndSwapN {\");\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+    Register Rres  = reg_to_register_object($res$$reg);\n+\n+    write_barrier_pre(masm, this,\n+                      Raddr           \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of(Raddr, Rcomp, Rnew) \/* preserve *\/,\n+                      RegSet::of(Rres) \/* no_preserve *\/);\n+\n+    __ z_cs(Rcomp, Rnew, 0, Raddr);\n+\n+    assert_different_registers(Rres, Raddr);\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ load_const_optimized(Z_R0_scratch, 0L); \/\/ false (failed)\n+      __ load_const_optimized(Rres, 1L);         \/\/ true  (succeed)\n+      __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);\n+    } else {\n+      Label done;\n+      __ load_const_optimized(Rres, 0L); \/\/ false (failed)\n+      __ z_brne(done);                   \/\/ Assume true to be the common case.\n+      __ load_const_optimized(Rres, 1L); \/\/ true  (succeed)\n+      __ bind(done);\n+    }\n+\n+    __ oop_decoder($tmp3$$Register, Rnew, true \/* maybe_null *\/);\n+\n+    write_barrier_post(masm, this,\n+                       Raddr            \/* store_addr *\/,\n+                       $tmp3$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register  \/* tmp1       *\/,\n+                       $tmp2$$Register  \/* tmp2       *\/);\n+    __ block_comment(\"} g1compareAndSwapN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndExchangeN(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegN res, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeN mem_ptr (Binary oldval newval)));\n+  effect(USE mem_ptr, TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndExchangeN $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+    __ block_comment(\"g1CompareAndExchangeN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem_ptr$$Register \/* obj     *\/,\n+                      $tmp1$$Register    \/* pre_val *\/,\n+                      $tmp2$$Register    \/* tmp1    *\/,\n+                      RegSet::of($mem_ptr$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+\n+    Register Rres = reg_to_register_object($res$$reg);\n+    assert_different_registers(Rres, Raddr);\n+\n+    __ z_lgr(Rres, Rcomp);  \/\/ previous contents\n+    __ z_csy(Rres, Rnew, 0, Raddr); \/\/ Try to store new value.\n+\n+    __ oop_decoder($tmp1$$Register, Rnew, true \/* maybe_null *\/);\n+\n+    write_barrier_post(masm, this,\n+                       Raddr           \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndExchangeN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Load narrow oop\n+instruct g1LoadN(iRegN dst, indirect mem, iRegP tmp1, iRegP tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadN mem));\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"LoadN   $dst,$mem\\t # (cOop)\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1LoadN {\");\n+    __ z_llgf($dst$$Register, Address($mem$$Register));\n+    if ((barrier_data() & G1C2BarrierPre) != 0) {\n+      __ oop_decoder($tmp1$$Register, $dst$$Register, true);\n+      write_barrier_pre(masm, this,\n+                        noreg           \/* obj     *\/,\n+                        $tmp1$$Register \/* pre_val *\/,\n+                        $tmp2$$Register );\n+    }\n+    __ block_comment(\"} g1LoadN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1GetAndSetN(indirect mem, iRegN dst, iRegI tmp, iRegL tmp1, iRegL tmp2, iRegL tmp3, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set dst (GetAndSetN mem dst));\n+  effect(KILL cr, TEMP tmp, TEMP tmp1, TEMP tmp2, TEMP tmp3); \/\/ USE_DEF dst by match rule.\n+  format %{ \"XCHGN   $dst,[$mem]\\t # EXCHANGE (coop, atomic), temp $tmp\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1GetAndSetN {\");\n+    assert_different_registers($mem$$Register, $dst$$Register);\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $dst$$Register) \/* preserve *\/);\n+\n+    Register Rdst = reg_to_register_object($dst$$reg);\n+    Register Rtmp = reg_to_register_object($tmp$$reg);\n+    guarantee(Rdst != Rtmp, \"Fix match rule to use TEMP_DEF\");\n+    Label    retry;\n+\n+    \/\/ Iterate until swap succeeds.\n+    __ z_llgf(Rtmp, Address($mem$$Register)); \/\/ current contents\n+    __ bind(retry);\n+    \/\/ Calculate incremented value.\n+    __ z_csy(Rtmp, Rdst, Address($mem$$Register)); \/\/ Try to store new value.\n+    __ z_brne(retry); \/\/ Yikes, concurrent update, need to retry.\n+\n+    __ oop_decoder($tmp1$$Register, $dst$$Register, true \/* maybe_null *\/);\n+\n+    __ z_lgr(Rdst, Rtmp);  \/\/ Exchanged value from memory is return value.\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp3$$Register \/* tmp2       *\/);\n+\n+    __ block_comment(\"} g1GetAndSetN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndSwapP(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, USE mem_ptr, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndSwapP $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1CompareAndSwapP {\");\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+\n+    Register Rcomp = reg_to_register_object($oldval$$reg);\n+    Register Rnew  = reg_to_register_object($newval$$reg);\n+    Register Raddr = reg_to_register_object($mem_ptr$$reg);\n+    Register Rres  = reg_to_register_object($res$$reg);\n+\n+    write_barrier_pre(masm, this,\n+                      noreg           \/* obj     *\/,\n+                      Rcomp           \/* pre_val *\/,\n+                      $tmp1$$Register \/* tmp1    *\/,\n+                      RegSet::of(Raddr, Rcomp, Rnew) \/* preserve *\/,\n+                      RegSet::of(Rres) \/* no_preserve *\/);\n+\n+    __ z_csg(Rcomp, Rnew, 0, Raddr);\n+\n+    if (VM_Version::has_LoadStoreConditional()) {\n+      __ load_const_optimized(Z_R0_scratch, 0L); \/\/ false (failed)\n+      __ load_const_optimized(Rres, 1L);         \/\/ true  (succeed)\n+      __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);\n+    } else {\n+      Label done;\n+      __ load_const_optimized(Rres, 0L); \/\/ false (failed)\n+      __ z_brne(done);                   \/\/ Assume true to be the common case.\n+      __ load_const_optimized(Rres, 1L); \/\/ true  (succeed)\n+      __ bind(done);\n+    }\n+\n+    write_barrier_post(masm, this,\n+                       Raddr           \/* store_addr *\/,\n+                       Rnew            \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndSwapP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1CompareAndExchangeP(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegP res, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set res (CompareAndExchangeP mem_ptr (Binary oldval newval)));\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, USE mem_ptr, USE_KILL oldval, KILL cr);\n+  format %{ \"$res = CompareAndExchangeP $oldval,$newval,$mem_ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1CompareAndExchangeP {\");\n+    assert_different_registers($oldval$$Register, $mem_ptr$$Register);\n+    assert_different_registers($newval$$Register, $mem_ptr$$Register);\n+\n+    \/\/ Pass $oldval to the pre-barrier (instead of loading from $mem), because\n+    \/\/ $oldval is the only value that can be overwritten.\n+    \/\/ The same holds for g1CompareAndSwapP.\n+    write_barrier_pre(masm, this,\n+                      noreg             \/* obj     *\/,\n+                      $oldval$$Register \/* pre_val *\/,\n+                      $tmp2$$Register   \/* tmp1    *\/,\n+                      RegSet::of($mem_ptr$$Register, $oldval$$Register, $newval$$Register) \/* preserve *\/,\n+                      RegSet::of($res$$Register) \/* no_preserve *\/);\n+\n+    __ z_lgr($res$$Register, $oldval$$Register); \/\/ previous content\n+\n+    __ z_csg($oldval$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n+\n+    write_barrier_post(masm, this,\n+                       $mem_ptr$$Register \/* store_addr *\/,\n+                       $newval$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register    \/* tmp1       *\/,\n+                       $tmp2$$Register    \/* tmp2       *\/);\n+    __ block_comment(\"} g1CompareAndExchangeP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Load Pointer\n+instruct g1LoadP(iRegP dst, memory mem, iRegL tmp1, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_Load()->barrier_data() != 0);\n+  match(Set dst (LoadP mem));\n+  effect(TEMP dst, TEMP tmp1, KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"LG      $dst,$mem\\t # ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1LoadP {\");\n+    __ z_lg($dst$$Register, $mem$$Address);\n+    write_barrier_pre(masm, this,\n+                      noreg \/* obj *\/,\n+                      $dst$$Register \/* pre_val *\/,\n+                      $tmp1$$Register );\n+    __ block_comment(\"} g1LoadP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1GetAndSetP(indirect mem, iRegP dst, iRegL tmp, iRegL tmp1, iRegL tmp2, flagsReg cr) %{\n+  predicate(UseG1GC && n->as_LoadStore()->barrier_data() != 0);\n+  match(Set dst (GetAndSetP mem dst));\n+  effect(KILL cr, TEMP tmp, TEMP tmp1, TEMP tmp2); \/\/ USE_DEF dst by match rule.\n+  format %{ \"XCHGP   $dst,[$mem]\\t # EXCHANGE (oop, atomic), temp $tmp\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1GetAndSetP {\");\n+\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj  *\/,\n+                      $tmp$$Register  \/* pre_val (as a temporary register) *\/,\n+                      $tmp1$$Register \/* tmp1 *\/,\n+                      RegSet::of($mem$$Register, $dst$$Register) \/* preserve *\/);\n+\n+    __ z_lgr($tmp1$$Register, $dst$$Register);\n+    Register Rdst = reg_to_register_object($dst$$reg);\n+    Register Rtmp = reg_to_register_object($tmp$$reg);\n+    guarantee(Rdst != Rtmp, \"Fix match rule to use TEMP_DEF\");\n+    Label    retry;\n+\n+    \/\/ Iterate until swap succeeds.\n+    __ z_lg(Rtmp, Address($mem$$Register));  \/\/ current contents\n+    __ bind(retry);\n+    \/\/ Calculate incremented value.\n+    __ z_csg(Rtmp, Rdst, Address($mem$$Register)); \/\/ Try to store new value.\n+    __ z_brne(retry);                              \/\/ Yikes, concurrent update, need to retry.\n+    __ z_lgr(Rdst, Rtmp);                          \/\/ Exchanged value from memory is return value.\n+\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $tmp1$$Register \/* new_val    *\/,\n+                       $tmp2$$Register \/* tmp1       *\/,\n+                       $tmp$$Register  \/* tmp2       *\/);\n+    __ block_comment(\"} g1GetAndSetP\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegL tmp1, iRegL tmp2, flagsReg cr)\n+%{\n+  predicate(UseG1GC && n->as_Store()->barrier_data() != 0);\n+  match(Set mem (StoreN mem (EncodeP src)));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n+  \/\/ ins_cost(INSN_COST);\n+  format %{ \"encode_heap_oop $tmp1, $src\\n\\t\"\n+            \"st  $tmp1, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ block_comment(\"g1EncodePAndStoreN {\");\n+    write_barrier_pre(masm, this,\n+                      $mem$$Register  \/* obj     *\/,\n+                      $tmp1$$Register \/* pre_val *\/,\n+                      $tmp2$$Register \/* tmp1    *\/,\n+                      RegSet::of($mem$$Register, $src$$Register) \/* preserve *\/);\n+    if ((barrier_data() & G1C2BarrierPostNotNull) == 0) {\n+      __ oop_encoder($tmp1$$Register, $src$$Register, true \/* maybe_null *\/);\n+    } else {\n+      __ oop_encoder($tmp1$$Register, $src$$Register, false \/* maybe_null *\/);\n+    }\n+    __ z_st($tmp1$$Register, Address($mem$$Register));\n+    write_barrier_post(masm, this,\n+                       $mem$$Register  \/* store_addr *\/,\n+                       $src$$Register  \/* new_val    *\/,\n+                       $tmp1$$Register \/* tmp1       *\/,\n+                       $tmp2$$Register \/* tmp2       *\/);\n+    __ block_comment(\"} g1EncodePAndStoreN\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1_s390.ad","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -36,0 +36,3 @@\n+#ifdef COMPILER2\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -153,2 +156,87 @@\n-OptoReg::Name BarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) {\n-  Unimplemented(); \/\/ This must be implemented to support late barrier expansion.\n+OptoReg::Name BarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) const {\n+  if (!OptoReg::is_reg(opto_reg)) {\n+    return OptoReg::Bad;\n+  }\n+\n+  VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+  if ((vm_reg->is_Register() || vm_reg ->is_FloatRegister()) && (opto_reg & 1) != 0) {\n+    return OptoReg::Bad;\n+  }\n+\n+  return opto_reg;\n+}\n+\n+#undef __\n+#define __ _masm->\n+\n+SaveLiveRegisters::SaveLiveRegisters(MacroAssembler *masm, BarrierStubC2 *stub)\n+  : _masm(masm), _reg_mask(stub->preserve_set()) {\n+\n+  const int register_save_size = iterate_over_register_mask(ACTION_COUNT_ONLY) * BytesPerWord;\n+\n+  _frame_size = align_up(register_save_size, frame::alignment_in_bytes) + frame::z_abi_160_size; \/\/ FIXME: this could be restricted to argument only\n+\n+  __ save_return_pc();\n+  __ push_frame(_frame_size, Z_R14); \/\/ FIXME: check if Z_R1_scaratch can do a job here;\n+\n+  __ z_lg(Z_R14, _z_common_abi(return_pc) + _frame_size, Z_SP);\n+\n+  iterate_over_register_mask(ACTION_SAVE, _frame_size);\n+}\n+\n+SaveLiveRegisters::~SaveLiveRegisters() {\n+  iterate_over_register_mask(ACTION_RESTORE, _frame_size);\n+\n+  __ pop_frame();\n+\n+  __ restore_return_pc();\n+}\n+\n+int SaveLiveRegisters::iterate_over_register_mask(IterationAction action, int offset) {\n+  int reg_save_index = 0;\n+  RegMaskIterator live_regs_iterator(_reg_mask);\n+\n+  while(live_regs_iterator.has_next()) {\n+    const OptoReg::Name opto_reg = live_regs_iterator.next();\n+\n+    \/\/ Filter out stack slots (spilled registers, i.e., stack-allocated registers).\n+    if (!OptoReg::is_reg(opto_reg)) {\n+      continue;\n+    }\n+\n+    const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+    if (vm_reg->is_Register()) {\n+      Register std_reg = vm_reg->as_Register();\n+\n+      if (std_reg->encoding() >= Z_R2->encoding() && std_reg->encoding() <= Z_R15->encoding()) {\n+        reg_save_index++;\n+\n+        if (action == ACTION_SAVE) {\n+          __ z_stg(std_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else if (action == ACTION_RESTORE) {\n+          __ z_lg(std_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else {\n+          assert(action == ACTION_COUNT_ONLY, \"Sanity\");\n+        }\n+      }\n+    } else if (vm_reg->is_FloatRegister()) {\n+      FloatRegister fp_reg = vm_reg->as_FloatRegister();\n+      if (fp_reg->encoding() >= Z_F0->encoding() && fp_reg->encoding() <= Z_F15->encoding()\n+          && fp_reg->encoding() != Z_F1->encoding()) {\n+        reg_save_index++;\n+\n+        if (action == ACTION_SAVE) {\n+          __ z_std(fp_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else if (action == ACTION_RESTORE) {\n+          __ z_ld(fp_reg, offset - reg_save_index * BytesPerWord, Z_SP);\n+        } else {\n+          assert(action == ACTION_COUNT_ONLY, \"Sanity\");\n+        }\n+      }\n+    } else if (false \/* vm_reg->is_VectorRegister() *\/){\n+      fatal(\"Vector register support is not there yet!\");\n+    } else {\n+      fatal(\"Register type is not known\");\n+    }\n+  }\n+  return reg_save_index;\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -36,0 +37,1 @@\n+class BarrierStubC2;\n@@ -64,1 +66,1 @@\n-                                OptoReg::Name opto_reg);\n+                                OptoReg::Name opto_reg) const;\n@@ -68,0 +70,34 @@\n+#ifdef COMPILER2\n+\n+\/\/ This class saves and restores the registers that need to be preserved across\n+\/\/ the runtime call represented by a given C2 barrier stub. Use as follows:\n+\/\/ {\n+\/\/   SaveLiveRegisters save(masm, stub);\n+\/\/   ..\n+\/\/   __ call_VM_leaf(...);\n+\/\/   ..\n+\/\/ }\n+\n+class SaveLiveRegisters {\n+  MacroAssembler* _masm;\n+  RegMask _reg_mask;\n+  Register _result_reg;\n+  int _frame_size;\n+\n+ public:\n+  SaveLiveRegisters(MacroAssembler *masm, BarrierStubC2 *stub);\n+\n+  ~SaveLiveRegisters();\n+\n+ private:\n+  enum IterationAction : int {\n+    ACTION_SAVE,\n+    ACTION_RESTORE,\n+    ACTION_COUNT_ONLY\n+  };\n+\n+  int iterate_over_register_mask(IterationAction action, int offset = 0);\n+};\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2130,1 +2130,1 @@\n-  BLOCK_COMMENT(\"pop_frame:\");\n+  BLOCK_COMMENT(\"pop_frame {\");\n@@ -2132,0 +2132,1 @@\n+  BLOCK_COMMENT(\"} pop_frame\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -451,0 +451,8 @@\n+typedef AbstractRegSet<Register> RegSet;\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1647,0 +1647,4 @@\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n@@ -3916,0 +3920,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -3927,0 +3932,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -4289,0 +4295,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -4391,0 +4398,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -4420,0 +4428,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -4483,1 +4492,1 @@\n-  predicate(false && (CompressedOops::base()==nullptr)&&(CompressedOops::shift()==0));\n+  predicate(false && (CompressedOops::base()==nullptr) && (CompressedOops::shift()==0));\n@@ -4738,0 +4747,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5149,0 +5159,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5159,0 +5170,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5446,0 +5458,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5455,0 +5468,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -5929,1 +5943,1 @@\n-  predicate(VM_Version::has_MemWithImmALUOps());\n+  predicate(VM_Version::has_MemWithImmALUOps() && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}