{"files":[{"patch":"@@ -297,0 +297,9 @@\n+bool G1BarrierSetC2::can_initialize_object(const StoreNode* store) const {\n+  assert(store->Opcode() == Op_StoreP || store->Opcode() == Op_StoreN, \"OOP store expected\");\n+  \/\/ It is OK to move the store across the object initialization boundary only\n+  \/\/ if it does not have any barrier, or if it has barriers that can be safely\n+  \/\/ elided (because of the compensation steps taken on the allocation slow path\n+  \/\/ when ReduceInitialCardMarks is enabled).\n+  return (MemNode::barrier_data(store) == 0) || use_ReduceInitialCardMarks();\n+}\n+\n@@ -312,1 +321,1 @@\n-    access.set_barrier_data(get_store_barrier(access, val));\n+    access.set_barrier_data(get_store_barrier(access));\n@@ -468,1 +477,1 @@\n-int G1BarrierSetC2::get_store_barrier(C2Access& access, C2AccessValue& val) const {\n+int G1BarrierSetC2::get_store_barrier(C2Access& access) const {\n@@ -474,0 +483,1 @@\n+  Node * ctl = kit->control();\n@@ -480,17 +490,10 @@\n-  bool can_remove_post_barrier = false;\n-  if (val.node() != nullptr && val.node()->is_Con() && val.node()->bottom_type() == TypePtr::NULL_PTR) {\n-    \/\/ Must be null.\n-    const Type* t = val.node()->bottom_type();\n-    assert(t == Type::TOP || t == TypePtr::NULL_PTR, \"must be NULL\");\n-    \/\/ No post barrier if writing null.\n-    can_remove_post_barrier = true;\n-  } else if (use_ReduceInitialCardMarks() && access.base() == kit->just_allocated_object(kit->control())) {\n-    \/\/ We can skip marks on a freshly-allocated object in Eden. Keep this code\n-    \/\/ in sync with CardTableBarrierSet::on_slowpath_allocation_exit. That\n-    \/\/ routine informs GC to take appropriate compensating steps, upon a\n-    \/\/ slow-path allocation, so as to make this card-mark elision safe.\n-    can_remove_post_barrier = true;\n-  } else if (use_ReduceInitialCardMarks()\n-             && g1_can_remove_post_barrier(kit, &kit->gvn(), kit->control(), adr)) {\n-    can_remove_post_barrier = true;\n-  }\n+  \/\/ We can skip marks on a freshly-allocated object in Eden. Keep this code in\n+  \/\/ sync with CardTableBarrierSet::on_slowpath_allocation_exit. That routine\n+  \/\/ informs GC to take appropriate compensating steps, upon a slow-path\n+  \/\/ allocation, so as to make this card-mark elision safe.\n+  \/\/ The post-barrier can also be removed if null is written. This case is\n+  \/\/ handled by G1BarrierSetC2::expand_barriers, which runs at the end of C2's\n+  \/\/ platform-independent optimizations to exploit stronger type information.\n+  bool can_remove_post_barrier = use_ReduceInitialCardMarks() &&\n+    ((access.base() == kit->just_allocated_object(ctl)) ||\n+     g1_can_remove_post_barrier(kit, &kit->gvn(), ctl, adr));\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  int get_store_barrier(C2Access& access, C2AccessValue& val) const;\n+  int get_store_barrier(C2Access& access) const;\n@@ -113,0 +113,1 @@\n+  virtual bool can_initialize_object(const StoreNode* store) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -345,0 +345,2 @@\n+  \/\/ Whether the given store can be used to initialize a newly allocated object.\n+  virtual bool can_initialize_object(const StoreNode* store) const { return true; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3503,1 +3503,1 @@\n-  if (ReduceFieldZeroing && ReduceInitialCardMarks && \/*can_reshape &&*\/\n+  if (ReduceFieldZeroing && \/*can_reshape &&*\/\n@@ -4641,0 +4641,5 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  if ((st->Opcode() == Op_StoreP || st->Opcode() == Op_StoreN) &&\n+      !bs->can_initialize_object(st)) {\n+    return FAIL;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    static final String POST_ONLY_NOT_NULL = \"post notnull\";\n@@ -173,0 +174,6 @@\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n@@ -185,0 +192,31 @@\n+    @Test\n+    @IR(failOn = {IRNode.STORE_P, IRNode.STORE_N},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    public static Outer testStoreNullOnNewObject() {\n+        Outer o = new Outer();\n+        o.f = null;\n+        return o;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_STORE_P_WITH_BARRIER_FLAG, POST_ONLY_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, POST_ONLY_NOT_NULL, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_P},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_STORE_N, IRNode.G1_ENCODE_P_AND_STORE_N},\n+        phase = CompilePhase.FINAL_CODE)\n+    public static Outer testStoreNotNullOnNewObject(Object o1) {\n+        if (o1.hashCode() == 42) {\n+            return null;\n+        }\n+        Outer o = new Outer();\n+        o.f = o1;\n+        return o;\n+    }\n+\n@@ -190,1 +228,2 @@\n-                 \"testStoreOnNewObject\"})\n+                 \"testStoreOnNewObject\",\n+                 \"testStoreNotNullOnNewObject\"})\n@@ -228,0 +267,9 @@\n+        {\n+            Outer o = testStoreNullOnNewObject();\n+            Asserts.assertNull(o.f);\n+        }\n+        {\n+            Object o1 = new Object();\n+            Outer o = testStoreNotNullOnNewObject(o1);\n+            Asserts.assertEquals(o1, o.f);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"}]}