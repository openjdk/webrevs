{"files":[{"patch":"@@ -626,0 +626,2 @@\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n@@ -642,20 +644,0 @@\n-\/\/ This pattern is generated automatically from g1_aarch64.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct g1LoadPVolatile(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n-%{\n-  predicate(UseG1GC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n-  match(Set dst (LoadP mem));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"ldar  $dst, $mem\\t# ptr\" %}\n-  ins_encode %{\n-    __ ldar($dst$$Register, $mem$$Register);\n-    write_barrier_pre(masm, this,\n-                      noreg \/* obj *\/,\n-                      $dst$$Register \/* pre_val *\/,\n-                      $tmp1$$Register \/* tmp1 *\/,\n-                      $tmp2$$Register \/* tmp2 *\/);\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n@@ -685,23 +667,0 @@\n-\/\/ This pattern is generated automatically from g1_aarch64.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct g1LoadNVolatile(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n-%{\n-  predicate(UseG1GC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n-  match(Set dst (LoadN mem));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"ldarw  $dst, $mem\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ ldarw($dst$$Register, $mem$$Register);\n-    if ((barrier_data() & G1C2BarrierPre) != 0) {\n-      __ decode_heap_oop($tmp1$$Register, $dst$$Register);\n-      write_barrier_pre(masm, this,\n-                        noreg \/* obj *\/,\n-                        $tmp1$$Register \/* pre_val *\/,\n-                        $tmp2$$Register \/* tmp1 *\/,\n-                        $tmp3$$Register \/* tmp2 *\/);\n-    }\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.ad","additions":2,"deletions":43,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -345,3 +345,1 @@\n-dnl\n-define(`LOADP_INSN',\n-`\n+\n@@ -350,1 +348,1 @@\n-instruct g1LoadP$1(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -352,1 +350,3 @@\n-  predicate(UseG1GC && ifelse($1,Volatile,'needs_acquiring_load(n)`,'!needs_acquiring_load(n)`) && n->as_Load()->barrier_data() != 0);\n+  \/\/ This instruction does not need an acquiring counterpart because it is only\n+  \/\/ used for reference loading (Reference::get()). The same holds for g1LoadN.\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n@@ -355,2 +355,2 @@\n-  ins_cost(ifelse($1,Volatile,VOLATILE_REF_COST,4 * INSN_COST));\n-  format %{ \"$2  $dst, $mem\\t# ptr\" %}\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldr  $dst, $mem\\t# ptr\" %}\n@@ -358,1 +358,1 @@\n-    __ $2($dst$$Register, $mem$$Register);\n+    __ ldr($dst$$Register, $mem$$Register);\n@@ -365,7 +365,3 @@\n-  ins_pipe(ifelse($1,Volatile,pipe_serial,iload_reg_mem));\n-%}')dnl\n-LOADP_INSN(,ldr)\n-LOADP_INSN(Volatile,ldar)\n-dnl\n-define(`LOADN_INSN',\n-`\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n@@ -374,1 +370,1 @@\n-instruct g1LoadN$1(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -376,1 +372,1 @@\n-  predicate(UseG1GC && ifelse($1,Volatile,'needs_acquiring_load(n)`,'!needs_acquiring_load(n)`) && n->as_Load()->barrier_data() != 0);\n+  predicate(UseG1GC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n@@ -379,2 +375,2 @@\n-  ins_cost(ifelse($1,Volatile,VOLATILE_REF_COST,4 * INSN_COST));\n-  format %{ \"$2  $dst, $mem\\t# compressed ptr\" %}\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed ptr\" %}\n@@ -382,1 +378,1 @@\n-    __ $2($dst$$Register, $mem$$Register);\n+    __ ldrw($dst$$Register, $mem$$Register);\n@@ -392,4 +388,2 @@\n-  ins_pipe(ifelse($1,Volatile,pipe_serial,iload_reg_mem));\n-%}')dnl\n-LOADN_INSN(,ldrw)\n-LOADN_INSN(Volatile,ldarw)\n+  ins_pipe(iload_reg_mem);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.m4","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"}]}