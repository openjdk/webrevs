{"files":[{"patch":"@@ -196,3 +196,3 @@\n-     * @throws IllegalArgumentException if {@code length} is negative\n-     *         or the {@code context} length is larger than can be\n-     *         accommodated\n+     * @throws IllegalArgumentException if {@code length} is non-positive,\n+     *         or if the {@code label} or {@code context} length can\n+     *         not be accommodated\n@@ -239,1 +239,1 @@\n-     * @param label   the label bytes used in the EKM calculation\n+     * @param label   the label bytes used in the EKM calculation.\n@@ -246,3 +246,3 @@\n-     * @throws IllegalArgumentException if {@code length} is negative\n-     *         or the {@code context} length is larger than can be\n-     *         accommodated\n+     * @throws IllegalArgumentException if {@code length} is non-positive,\n+     *         or if the {@code label} or {@code context} length can\n+     *         not be accommodated\n@@ -251,2 +251,1 @@\n-     *         does not implement the operation, or if the derived key\n-     *         material is not extractable.\n+     *         does not implement the operation\n@@ -254,2 +253,3 @@\n-     * @return a byte buffer of size {@code length} that contains the EKM\n-     *         material\n+     * @return a byte array of size {@code length} that contains the EKM\n+     *         material, or null if the derived key material does not support\n+     *         encoding\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/ExtendedSSLSession.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1608,3 +1608,3 @@\n-    \/**\n-     * Generate Exported Key Material (EKM) calculated according to the\n-     * algorithms defined in RFCs 5705\/8446.\n+    \/*\n+     * deriveKey is used for switching between Keys\/Data.  Will redo\n+     * if we ever introduce additional types.\n@@ -1612,3 +1612,3 @@\n-    @Override\n-    public SecretKey exportKeyingMaterialKey(\n-            String label, byte[] context, int length) throws SSLKeyException {\n+    public Object exportKeyingMaterial(\n+            boolean deriveKey, String label, byte[] context, int length)\n+            throws SSLKeyException {\n@@ -1617,0 +1617,1 @@\n+\n@@ -1618,1 +1619,1 @@\n-        if (length < 0) {\n+        if (length < 1) {\n@@ -1620,1 +1621,1 @@\n-                    \"Output length can not be negative\");\n+                    \"length must be positive\");\n@@ -1626,0 +1627,34 @@\n+\n+            \/\/ Check the label\/context lengths:\n+            \/\/       struct {\n+            \/\/           uint16 length = Length;\n+            \/\/           opaque label<7..255> = \"tls13 \" + Label;\n+            \/\/           opaque context<0..255> = Context;\n+            \/\/       } HkdfLabel;\n+            \/\/ label can have 249 bytes (+6 for \"tls13 \"), and context 255\n+\n+            \/\/ RFC 8446 allows for length of 2^16-1 (65536), but RFC 5869\n+            \/\/ states:\n+            \/\/\n+            \/\/     L    length of output keying material in octets\n+            \/\/          (<= 255*HashLen)\n+            if (length >= (255 * cipherSuite.hashAlg.hashLength )) {\n+                throw new IllegalArgumentException(\n+                        \"length is too large\");\n+            }\n+\n+            byte[] hkdfInfoLabel =\n+                        (\"tls13 \" + label).getBytes(StandardCharsets.UTF_8);\n+            if ((hkdfInfoLabel.length < 7) || hkdfInfoLabel.length > 255) {\n+                throw new IllegalArgumentException(\n+                        \"label length outside range\");\n+            }\n+\n+            \/\/ If no context (null) is provided, RFC 8446 requires an empty\n+            \/\/ context be used, unlike RFC 5705.\n+            context = (context != null ? context : new byte[0]);\n+            if (context.length > 255) {\n+                throw new IllegalArgumentException(\n+                        \"context length outside range\");\n+            }\n+\n@@ -1644,4 +1679,0 @@\n-            \/\/ If no context (null) is provided, RFC 8446 requires an empty\n-            \/\/ context be used, unlike RFC 5705.\n-            context = (context != null ? context : new byte[0]);\n-\n@@ -1669,2 +1700,1 @@\n-                        (\"tls13 \" + label).getBytes(StandardCharsets.UTF_8),\n-                        emptyHash, hashAlg.hashLength);\n+                        hkdfInfoLabel, emptyHash, hashAlg.hashLength);\n@@ -1694,4 +1724,7 @@\n-                    SecretKey key = hkdf.deriveKey(label,\n-                            HKDFParameterSpec.expandOnly(derivedSecret,\n-                                    hkdfInfo, length));\n-                    return key;\n+                    return (deriveKey ?\n+                            hkdf.deriveKey(\"ExportKeyingMaterial\",\n+                                    HKDFParameterSpec.expandOnly(derivedSecret,\n+                                            hkdfInfo, length)) :\n+                            hkdf.deriveData(\n+                                    HKDFParameterSpec.expandOnly(derivedSecret,\n+                                            hkdfInfo, length)));\n@@ -1699,1 +1732,1 @@\n-                    \/\/ Best effort\n+                    \/\/ Best effort to clear the intermediate SecretKey.\n@@ -1733,0 +1766,7 @@\n+            \/\/ Check for a \"disambiguating label string\" (i.e. non-empty).\n+            \/\/ Don't see a max length restriction.\n+            if (label.isEmpty()) {\n+                throw new IllegalArgumentException(\n+                        \"label length outside range\");\n+            }\n+\n@@ -1739,1 +1779,1 @@\n-            if ((context != null) && context.length >= (1 << 16)) {\n+            if ((context != null) && context.length >= 65536) {\n@@ -1786,1 +1826,2 @@\n-                return kg.generateKey();\n+                SecretKey key = kg.generateKey();\n+                return (deriveKey ? key : key.getEncoded());\n@@ -1800,0 +1841,10 @@\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     *\/\n+    @Override\n+    public SecretKey exportKeyingMaterialKey(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        return (SecretKey)exportKeyingMaterial(true, label, context, length);\n+    }\n+\n@@ -1807,7 +1858,1 @@\n-        byte[] bytes =\n-                exportKeyingMaterialKey(label, context, length).getEncoded();\n-        if (bytes == null) {\n-            throw new UnsupportedOperationException(\n-                    \"Exported key material is not extractable\");\n-        }\n-        return bytes;\n+        return (byte[])exportKeyingMaterial(false, label, context, length);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":73,"deletions":28,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javax.crypto.SecretKey;\n@@ -281,0 +282,2 @@\n+        SecretKey clientKey, serverKey;\n+\n@@ -296,17 +299,17 @@\n-        \/\/ Inputs exactly equal.  Use exportKeyMaterialKey()\n-        clientBytes = clientSession.exportKeyingMaterialKey(\"hello\",\n-                bytes, 128).getEncoded();\n-        serverBytes = serverSession.exportKeyingMaterialKey(\"hello\",\n-                bytes, 128).getEncoded();\n-        assertEqualsByteArray(clientBytes, serverBytes,\n-                \"Equal inputs but exporters are not equal\");\n-        log(\"Equal inputs test passed\");\n-\n-        \/\/ Empty label.  I don't see anything that says this is\n-        \/\/ forbidden.  There is some verbiage about: labels being registered\n-        \/\/ with IANA, must not collide with existing PRF labels, SHOULD use\n-        \/\/ \"EXPORTER\"\/\"EXPERIMENTAL\" prefixes, etc.\n-        clientBytes = clientSession.exportKeyingMaterialKey(\"\",\n-                bytes, 128).getEncoded();\n-        serverBytes = serverSession.exportKeyingMaterialKey(\"\",\n-                bytes, 128).getEncoded();\n+        \/\/ Run a bunch of similar derivations using both the Key\/Data methods,\n+        \/\/ exercising the various valid\/invalid combinations.\n+\n+        \/\/ We may need to adjust if it turns out that this is run with\n+        \/\/ non-extractable keys if .equals() doesn't work.\n+\n+        \/\/ Inputs exactly equal.\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\", bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\", bytes, 128);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: Equal inputs but exporters are not equal\");\n+        log(\"Key: Equal inputs test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n@@ -314,2 +317,2 @@\n-                \"Empty label and exporters are equal\");\n-        log(\"Empty label test passed\");\n+                \"Data: Equal inputs but exporters are not equal\");\n+        log(\"Data: Equal inputs test passed\");\n@@ -318,0 +321,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"goodbye\",\n+                bytes, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different labels but exporters same\");\n+        log(\"Key: Different labels test passed\");\n+\n@@ -323,2 +334,2 @@\n-                \"Different labels but exporters same\");\n-        log(\"Different labels test passed\");\n+                \"Data: Different labels but exporters same\");\n+        log(\"Data: Different labels test passed\");\n@@ -327,0 +338,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 127);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different output sizes but exporters same\");\n+        log(\"Key: Different output size test passed\");\n+\n@@ -334,2 +353,2 @@\n-                \"Different output sizes but exporters same\");\n-        log(\"Different output size test passed\");\n+                \"Data: Different output sizes but exporters same\");\n+        log(\"Data: Different output size test passed\");\n@@ -338,0 +357,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytesDiff, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different context but exporters same\");\n+        log(\"Key: Different context test passed\");\n+\n@@ -343,2 +370,2 @@\n-                \"Different context but exporters same\");\n-        log(\"Different context test passed\");\n+                \"Data: Different context but exporters same\");\n+        log(\"Data: Different context test passed\");\n@@ -347,0 +374,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytesDiffSize, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different context sizes but exporters same\");\n+        log(\"Key: Different context sizes test passed\");\n+\n@@ -352,2 +387,2 @@\n-                \"Different context sizes but exporters same\");\n-        log(\"Different context sizes test passed\");\n+                \"Data: Different context sizes but exporters same\");\n+        log(\"Data: Different context sizes test passed\");\n@@ -356,0 +391,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                null, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                null, 128);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: No context and exporters are not the same\");\n+        log(\"Key: No context test passed\");\n+\n@@ -361,2 +404,2 @@\n-                \"No context and exporters are not the same\");\n-        log(\"No context test passed\");\n+                \"Data: No context and exporters are not the same\");\n+        log(\"Data: No context test passed\");\n@@ -365,0 +408,8 @@\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 1);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 1);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: Smaller key size should be the same\");\n+        log(\"Key: Smaller key size test passed\");\n+\n@@ -366,1 +417,1 @@\n-                bytes, 40);\n+                bytes, 1);\n@@ -368,1 +419,1 @@\n-                bytes, 40);\n+                bytes, 1);\n@@ -370,2 +421,2 @@\n-                \"Smaller key size should be the same\");\n-        log(\"Smaller key size test passed\");\n+                \"Data: Smaller key size should be the same\");\n+        log(\"Data: Smaller key size test passed\");\n@@ -374,0 +425,15 @@\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\", bytes, -1);\n+            throw new Exception(\"negative length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"negative length test passed\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\", bytes, 0);\n+            throw new Exception(\"zero length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"zero length test passed\");\n+        }\n+\n@@ -382,8 +448,2 @@\n-            clientSession.exportKeyingMaterialData(\"hello\",\n-                    new byte[1<<16], 128);\n-            if (!clientSession.getProtocol().equals(\"TLSv1.3\")) {\n-                throw new Exception(\"large context accepted in \" +\n-                        \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n-            } else {\n-                log(\"large context test passed in TLSv1.3\");\n-            }\n+            clientSession.exportKeyingMaterialData(\"\", bytes, 128);\n+            throw new Exception(\"empty label accepted\");\n@@ -391,2 +451,1 @@\n-            log(\"large context test passed in \" +\n-                    \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n+            log(\"empty label test passed\");\n@@ -395,5 +454,69 @@\n-        try {\n-            clientSession.exportKeyingMaterialData(\"hello\", bytes, -20);\n-            throw new Exception(\"negative length accepted\");\n-        } catch (IllegalArgumentException e) {\n-            log(\"negative length test passed\");\n+        switch (clientSession.getProtocol()) {\n+\n+        case \"TLSv1.3\":\n+            \/\/ 249 bytes is the max label we can accept (<7..255>, since\n+            \/\/ \"tls13 \" is added in HkdfLabel)\n+            String longString =\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"1234567890123456789012345678901234567890123456789\";\n+\n+            clientSession.exportKeyingMaterialData(longString, bytes, 128);\n+            log(\"large label test passed in TLSv1.3\");\n+\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString + \"0\", bytes, 128);\n+                throw new Exception(\"too large label accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large label test passed in TLSv1.3\");\n+            }\n+\n+            \/\/ 255 bytes is the max context we can accept (<0..255>)\n+            clientSession.exportKeyingMaterialData(\n+                    longString, new byte[255], 128);\n+            log(\"large context test passed in TLSv1.3\");\n+\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString, new byte[256], 128);\n+                throw new Exception(\"too large context accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large context test passed in TLSv1.3\");\n+            }\n+\n+            \/\/ RFC 5869 says 255*HashLen bytes is the max length we can accept.\n+            \/\/ So we'll choose something a bit bigger than the largest\n+            \/\/ hashLen\/ciphertext which is 384 (48 bytes) so this will always\n+            \/\/ fail.\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString, new byte[256], 12240);\n+                throw new Exception(\"too large length accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large length test passed in TLSv1.3\");\n+            }\n+\n+            break;\n+\n+        case \"TLSv1\":\n+        case \"TLSv1.1\":\n+        case \"TLSv1.2\":\n+            \/\/ Don't see a limit of the label.length or output length.\n+\n+            \/\/ Check for large context.length\n+            try {\n+                clientSession.exportKeyingMaterialData(\"hello\",\n+                        new byte[1 << 16], 128);\n+                throw new Exception(\"large context accepted in \" +\n+                        \"TLSv1\/TLSv1.1\/TLSv1.2\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"large context passed in TLSv1\/TLSv1.1\/TLSv1.2\");\n+            }\n+\n+            break;\n+\n+        default:\n+            throw new RuntimeException(\"Unknown protocol: \" + clientSession.getProtocol());\n@@ -401,0 +524,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/ExtendedSSLSession\/ExportKeyingMaterialTests.java","additions":172,"deletions":48,"binary":false,"changes":220,"status":"modified"}]}