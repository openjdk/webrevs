{"files":[{"patch":"@@ -172,3 +172,3 @@\n-     * Note RFC 5705 calculates different EKM values if {@code context}\n-     * is null vs. non-null\/empty.  RFC 8446 does not make such a\n-     * distinction.\n+     * Note RFC 5705 (for (D)TLSv1.2 and earlier) calculates different EKM\n+     * values depending on whether {@code context} is null or non-null\/empty.\n+     * RFC 8446 (TLSv1.3) treats a null context as non-null\/empty.\n@@ -186,0 +186,3 @@\n+     * @implSpec The default implementation throws\n+     *           {@code UnsupportedOperationException}\n+     *\n@@ -188,1 +191,1 @@\n-     *                before the operation begins.\n+     *                before the operation begins\n@@ -205,1 +208,1 @@\n-    public SecretKey exportKeyMaterialKey(\n+    public SecretKey exportKeyingMaterialKey(\n@@ -214,3 +217,3 @@\n-     * Note RFC 5705 calculates different EKM values if {@code context}\n-     * is null vs. non-null\/empty.  RFC 8446 does not make such a\n-     * distinction.\n+     * Note RFC 5705 (for (D)TLSv1.2 and earlier) calculates different EKM\n+     * values depending on whether {@code context} is null or non-null\/empty.\n+     * RFC 8446 (TLSv1.3) treats a null context as non-null\/empty.\n@@ -224,1 +227,1 @@\n-     * {@link #exportKeyMaterialKey(String, byte[], int)} method should be\n+     * {@link #exportKeyingMaterialKey(String, byte[], int)} method should be\n@@ -233,0 +236,3 @@\n+     * @implSpec The default implementation throws\n+     *           {@code UnsupportedOperationException}\n+     *\n@@ -235,1 +241,1 @@\n-     *                before the operation begins.\n+     *                before the operation begins\n@@ -252,1 +258,1 @@\n-    public byte[] exportKeyMaterialData(\n+    public byte[] exportKeyingMaterialData(\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/ExtendedSSLSession.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1610,1 +1610,1 @@\n-    public SecretKey exportKeyMaterialKey(\n+    public SecretKey exportKeyingMaterialKey(\n@@ -1793,1 +1793,1 @@\n-    public byte[] exportKeyMaterialData(\n+    public byte[] exportKeyingMaterialData(\n@@ -1796,1 +1796,1 @@\n-                exportKeyMaterialKey(label, context, length).getEncoded();\n+                exportKeyingMaterialKey(label, context, length).getEncoded();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8341346\n+ * @summary Add support for exporting TLS Keying Material\n+ * @library \/javax\/net\/ssl\/templates \/test\/lib\n+ * @build SSLContextTemplate\n+ * @run main\/othervm ExportKeyingMaterialTests\n+ *\/\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.nio.ByteBuffer;\n+import java.util.Random;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <P>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <P>\n+ * Note, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ * <P>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class ExportKeyingMaterialTests extends SSLContextTemplate {\n+    protected final SSLEngine clientEngine;     \/\/ client Engine\n+    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    \/\/ For data transport, this example uses local ByteBuffers.  This\n+    \/\/ isn't really useful, but the purpose of this example is to show\n+    \/\/ SSLEngine concepts, not how to do network transport.\n+    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected ExportKeyingMaterialTests(String protocol, String ciphersuite)\n+            throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine(),\n+                protocol, ciphersuite);\n+\n+        \/\/ We'll assume the buffer sizes are the same\n+        \/\/ between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/\/\n+    \/\/ Protected methods could be used to customize the test case.\n+    \/\/\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine,\n+            String protocol, String ciphersuite) {\n+        clientEngine.setUseClientMode(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        paramsClient.setProtocols(new String[] { protocol });\n+        paramsClient.setCipherSuites(new String[] { ciphersuite });\n+        clientEngine.setSSLParameters(paramsClient);\n+\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        \/\/\n+        SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        paramsServer.setProtocols(new String[] {\n+                \"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSLv3\"\n+        });\n+        serverEngine.setSSLParameters(paramsServer);\n+\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Turn off the disabled Algorithms so we can also test SSLv3\/TLSv1\/etc.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        \/\/ Exercise all of the triggers which capture data\n+        \/\/ in the various key exchange algorithms.\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos for TLSv1.3\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_AES_128_GCM_SHA256\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_AES_256_GCM_SHA384\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_CHACHA20_POLY1305_SHA256\").runTest();\n+\n+        \/\/ Try the various GCM suites for TLSv1.2\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+\n+        \/\/ Try one TLSv1.2\/CBC suite just for grins, the triggers are the same.\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\").runTest();\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos.  Some of the 1.2\n+        \/\/ suites (e.g. GCM) can't be used in earlier TLS versions.\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        try {\n+            new ExportKeyingMaterialTests(\n+                    \"SSLv3\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+            throw new Exception(\"SSLv3 export test should not have passed\");\n+        } catch (SSLException e) {\n+            System.out.println(\"SSLv3 test failed as expected\");\n+        }\n+\n+        System.out.println(\"All tests PASSED\");\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTest() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            log(\"=================\");\n+\n+            \/\/ client wrap\n+            log(\"---Client Wrap---\");\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server wrap\n+            log(\"---Server Wrap---\");\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            \/\/ client unwrap\n+            log(\"---Client Unwrap---\");\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server unwrap\n+            log(\"---Server Unwrap---\");\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/\/ After we've transferred all application data between the client\n+            \/\/ and server, we close the clientEngine's outbound stream.\n+            \/\/ This generates a close_notify handshake message, which the\n+            \/\/ server engine receives and responds by closing itself.\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                runExporterTests(\n+                        (ExtendedSSLSession) clientEngine.getSession(),\n+                        (ExtendedSSLSession) serverEngine.getSession());\n+\n+                \/\/ A sanity check to ensure we got what was sent.\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                logEngineStatus(clientEngine);\n+\n+                dataDone = true;\n+                log(\"\\tClosing serverEngine's *OUTBOUND*...\");\n+                serverEngine.closeOutbound();\n+                logEngineStatus(serverEngine);\n+            }\n+        }\n+    }\n+\n+    private static void runExporterTests(\n+            ExtendedSSLSession clientSession,\n+            ExtendedSSLSession serverSession) throws Exception {\n+\n+        \/\/ Create output arrays\n+        byte[] clientBytes, serverBytes;\n+\n+        \/\/ Create various input arrays and fill with junk.\n+        Random random = new Random();\n+        byte[] bytes = new byte[20];\n+        random.nextBytes(bytes);\n+\n+        \/\/ Slightly change 1 byte in the middle\n+        byte[] bytesDiff = Arrays.copyOf(bytes, bytes.length);\n+        bytesDiff[bytes.length\/2]++;\n+\n+        byte[] bytesDiffSize = new byte[21];\n+        random.nextBytes(bytesDiffSize);\n+\n+        \/\/ Inputs exactly equal.  Use exportKeyMaterialKey()\n+        clientBytes = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128).getEncoded();\n+        serverBytes = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128).getEncoded();\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Equal inputs but exporters are not equal\");\n+        log(\"Equal inputs test passed\");\n+\n+        \/\/ Empty label.  I don't see anything that says this is\n+        \/\/ forbidden.  There is some verbiage about: labels being registered\n+        \/\/ with IANA, must not collide with existing PRF labels, SHOULD use\n+        \/\/ \"EXPORTER\"\/\"EXPERIMENTAL\" prefixes, etc.\n+        clientBytes = clientSession.exportKeyingMaterialKey(\"\",\n+                bytes, 128).getEncoded();\n+        serverBytes = serverSession.exportKeyingMaterialKey(\"\",\n+                bytes, 128).getEncoded();\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Empty label and exporters are equal\");\n+        log(\"Empty label test passed\");\n+\n+        \/\/ Different labels, now use exportKeyMaterialData() for coverage\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"goodbye\",\n+                bytes, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Different labels but exporters same\");\n+        log(\"Different labels test passed\");\n+\n+        \/\/ Different output sizes\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 127);\n+        assertEquals(clientBytes.length, 128, \"client length != 128\");\n+        assertEquals(serverBytes.length, 127, \"server length != 127\");\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Different output sizes but exporters same\");\n+        log(\"Different output size test passed\");\n+\n+        \/\/ Different context values\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytesDiff, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Different context but exporters same\");\n+        log(\"Different context test passed\");\n+\n+        \/\/ Different context sizes\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytesDiffSize, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Different context sizes but exporters same\");\n+        log(\"Different context sizes test passed\");\n+\n+        \/\/ No context, but otherwise the same\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                null, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                null, 128);\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"No context and exporters are not the same\");\n+        log(\"No context test passed\");\n+\n+        \/\/ Smaller key size\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 40);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 40);\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Smaller key size should be the same\");\n+        log(\"Smaller key size test passed\");\n+\n+        \/\/ Check error conditions\n+        try {\n+            clientSession.exportKeyingMaterialData(null, bytes, 128);\n+            throw new Exception(\"null label accepted\");\n+        } catch (NullPointerException e) {\n+            log(\"null label test passed\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\",\n+                    new byte[1<<16], 128);\n+            if (!clientSession.getProtocol().equals(\"TLSv1.3\")) {\n+                throw new Exception(\"large context accepted in \" +\n+                        \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n+            } else {\n+                log(\"large context test passed in TLSv1.3\");\n+            }\n+        } catch (IllegalArgumentException e) {\n+            log(\"large context test passed in \" +\n+                    \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\", bytes, -20);\n+            throw new Exception(\"negative length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"negative length test passed\");\n+        }\n+    }\n+\n+    static boolean isOpen(SSLEngine engine) {\n+        return (!engine.isOutboundDone() || !engine.isInboundDone());\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    \/\/ Simple check to make sure everything came across as expected.\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/ExtendedSSLSession\/ExportKeyingMaterialTests.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -1,461 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\n-\/*\n- * @test\n- * @bug 8341346\n- * @summary Add support for exporting TLS Keying Material\n- * @library \/javax\/net\/ssl\/templates \/test\/lib\n- * @build SSLContextTemplate\n- * @run main\/othervm TLSKeyExporters\n- *\/\n-\n-import java.security.Security;\n-import java.util.Arrays;\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n-import java.nio.ByteBuffer;\n-import java.util.Random;\n-\n-import static jdk.test.lib.Asserts.*;\n-\n-\/**\n- * A SSLEngine usage example which simplifies the presentation\n- * by removing the I\/O and multi-threading concerns.\n- * <P>\n- * The test creates two SSLEngines, simulating a client and server.\n- * The \"transport\" layer consists two byte buffers:  think of them\n- * as directly connected pipes.\n- * <P>\n- * Note, this is a *very* simple example: real code will be much more\n- * involved.  For example, different threading and I\/O models could be\n- * used, transport mechanisms could close unexpectedly, and so on.\n- * <P>\n- * When this application runs, notice that several messages\n- * (wrap\/unwrap) pass before any application data is consumed or\n- * produced.\n- *\/\n-public class TLSKeyExporters extends SSLContextTemplate {\n-    protected final SSLEngine clientEngine;     \/\/ client Engine\n-    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n-\n-    protected final SSLEngine serverEngine;     \/\/ server Engine\n-    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n-    \/\/ For data transport, this example uses local ByteBuffers.  This\n-    \/\/ isn't really useful, but the purpose of this example is to show\n-    \/\/ SSLEngine concepts, not how to do network transport.\n-    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n-    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n-\n-    protected TLSKeyExporters(String protocol, String ciphersuite)\n-            throws Exception {\n-        serverEngine = configureServerEngine(\n-                createServerSSLContext().createSSLEngine());\n-\n-        clientEngine = configureClientEngine(\n-                createClientSSLContext().createSSLEngine(),\n-                protocol, ciphersuite);\n-\n-        \/\/ We'll assume the buffer sizes are the same\n-        \/\/ between client and server.\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/\/ We'll make the input buffers a bit bigger than the max needed\n-        \/\/ size, so that unwrap()s following a successful data transfer\n-        \/\/ won't generate BUFFER_OVERFLOWS.\n-        \/\/\n-        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n-        \/\/ tutorial purposes only.  In reality, only use direct\n-        \/\/ ByteBuffers when they give a clear performance enhancement.\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = createClientOutputBuffer();\n-        serverOut = createServerOutputBuffer();\n-    }\n-\n-    protected ByteBuffer createServerOutputBuffer() {\n-        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n-    }\n-\n-    \/\/\n-    \/\/ Protected methods could be used to customize the test case.\n-    \/\/\n-\n-    protected ByteBuffer createClientOutputBuffer() {\n-        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-    }\n-\n-    \/*\n-     * Configure the client side engine.\n-     *\/\n-    protected SSLEngine configureClientEngine(SSLEngine clientEngine,\n-            String protocol, String ciphersuite) {\n-        clientEngine.setUseClientMode(true);\n-\n-        \/\/ Get\/set parameters if needed\n-        SSLParameters paramsClient = clientEngine.getSSLParameters();\n-        paramsClient.setProtocols(new String[] { protocol });\n-        paramsClient.setCipherSuites(new String[] { ciphersuite });\n-        clientEngine.setSSLParameters(paramsClient);\n-\n-        return clientEngine;\n-    }\n-\n-    \/*\n-     * Configure the server side engine.\n-     *\/\n-    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n-\n-        \/\/ Get\/set parameters if needed\n-        \/\/\n-        SSLParameters paramsServer = serverEngine.getSSLParameters();\n-        paramsServer.setProtocols(new String[] {\n-                \"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSLv3\"\n-        });\n-        serverEngine.setSSLParameters(paramsServer);\n-\n-        return serverEngine;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Turn off the disabled Algorithms so we can also test SSLv3\/TLSv1\/etc.\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n-\n-        \/\/ Exercise all of the triggers which capture data\n-        \/\/ in the various key exchange algorithms.\n-\n-        \/\/ Use appropriate protocol\/ciphersuite combos for TLSv1.3\n-        new TLSKeyExporters(\n-                \"TLSv1.3\", \"TLS_AES_128_GCM_SHA256\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.3\", \"TLS_AES_256_GCM_SHA384\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.3\", \"TLS_CHACHA20_POLY1305_SHA256\").runTest();\n-\n-        \/\/ Try the various GCM suites for TLSv1.2\n-        new TLSKeyExporters(\n-                \"TLSv1.2\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.2\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.2\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n-\n-        \/\/ Try one TLSv1.2\/CBC suite just for grins, the triggers are the same.\n-        new TLSKeyExporters(\n-                \"TLSv1.2\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\").runTest();\n-\n-        \/\/ Use appropriate protocol\/ciphersuite combos.  Some of the 1.2\n-        \/\/ suites (e.g. GCM) can't be used in earlier TLS versions.\n-        new TLSKeyExporters(\n-                \"TLSv1.1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1.1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n-\n-        new TLSKeyExporters(\n-                \"TLSv1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n-        new TLSKeyExporters(\n-                \"TLSv1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n-\n-        try {\n-            new TLSKeyExporters(\n-                    \"SSLv3\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n-            throw new Exception(\"SSLv3 export test should not have passed\");\n-        } catch (SSLException e) {\n-            System.out.println(\"SSLv3 test failed as expected\");\n-        }\n-\n-        System.out.println(\"All tests PASSED\");\n-    }\n-\n-    \/\/\n-    \/\/ Private methods that used to build the common part of the test.\n-    \/\/\n-\n-    private void runTest() throws Exception {\n-        SSLEngineResult clientResult;\n-        SSLEngineResult serverResult;\n-\n-        boolean dataDone = false;\n-        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n-            log(\"=================\");\n-\n-            \/\/ client wrap\n-            log(\"---Client Wrap---\");\n-            clientResult = clientEngine.wrap(clientOut, cTOs);\n-            logEngineStatus(clientEngine, clientResult);\n-            runDelegatedTasks(clientEngine);\n-\n-            \/\/ server wrap\n-            log(\"---Server Wrap---\");\n-            serverResult = serverEngine.wrap(serverOut, sTOc);\n-            logEngineStatus(serverEngine, serverResult);\n-            runDelegatedTasks(serverEngine);\n-\n-            cTOs.flip();\n-            sTOc.flip();\n-\n-            \/\/ client unwrap\n-            log(\"---Client Unwrap---\");\n-            clientResult = clientEngine.unwrap(sTOc, clientIn);\n-            logEngineStatus(clientEngine, clientResult);\n-            runDelegatedTasks(clientEngine);\n-\n-            \/\/ server unwrap\n-            log(\"---Server Unwrap---\");\n-            serverResult = serverEngine.unwrap(cTOs, serverIn);\n-            logEngineStatus(serverEngine, serverResult);\n-            runDelegatedTasks(serverEngine);\n-\n-            cTOs.compact();\n-            sTOc.compact();\n-\n-            \/\/ After we've transferred all application data between the client\n-            \/\/ and server, we close the clientEngine's outbound stream.\n-            \/\/ This generates a close_notify handshake message, which the\n-            \/\/ server engine receives and responds by closing itself.\n-            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n-                    (serverOut.limit() == clientIn.position())) {\n-\n-                runExporterTests(\n-                        (ExtendedSSLSession) clientEngine.getSession(),\n-                        (ExtendedSSLSession) serverEngine.getSession());\n-\n-                \/\/ A sanity check to ensure we got what was sent.\n-                checkTransfer(serverOut, clientIn);\n-                checkTransfer(clientOut, serverIn);\n-\n-                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n-                clientEngine.closeOutbound();\n-                logEngineStatus(clientEngine);\n-\n-                dataDone = true;\n-                log(\"\\tClosing serverEngine's *OUTBOUND*...\");\n-                serverEngine.closeOutbound();\n-                logEngineStatus(serverEngine);\n-            }\n-        }\n-    }\n-\n-    private static void runExporterTests(\n-            ExtendedSSLSession clientSession,\n-            ExtendedSSLSession serverSession) throws Exception {\n-\n-        \/\/ Create output arrays\n-        byte[] clientBytes, serverBytes;\n-\n-        \/\/ Create various input arrays and fill with junk.\n-        Random random = new Random();\n-        byte[] bytes = new byte[20];\n-        random.nextBytes(bytes);\n-\n-        \/\/ Slightly change 1 byte in the middle\n-        byte[] bytesDiff = Arrays.copyOf(bytes, bytes.length);\n-        bytesDiff[bytes.length\/2]++;\n-\n-        byte[] bytesDiffSize = new byte[21];\n-        random.nextBytes(bytesDiffSize);\n-\n-        \/\/ Inputs exactly equal.  Use exportKeyMaterialKey()\n-        clientBytes = clientSession.exportKeyMaterialKey(\"hello\",\n-                bytes, 128).getEncoded();\n-        serverBytes = serverSession.exportKeyMaterialKey(\"hello\",\n-                bytes, 128).getEncoded();\n-        assertEqualsByteArray(clientBytes, serverBytes,\n-                \"Equal inputs but exporters are not equal\");\n-        log(\"Equal inputs test passed\");\n-\n-        \/\/ Empty label.  I don't see anything that says this is\n-        \/\/ forbidden.  There is some verbiage about: labels being registered\n-        \/\/ with IANA, must not collide with existing PRF labels, SHOULD use\n-        \/\/ \"EXPORTER\"\/\"EXPERIMENTAL\" prefixes, etc.\n-        clientBytes = clientSession.exportKeyMaterialKey(\"\",\n-                bytes, 128).getEncoded();\n-        serverBytes = serverSession.exportKeyMaterialKey(\"\",\n-                bytes, 128).getEncoded();\n-        assertEqualsByteArray(clientBytes, serverBytes,\n-                \"Empty label and exporters are equal\");\n-        log(\"Empty label test passed\");\n-\n-        \/\/ Different labels, now use exportKeyMaterialData() for coverage\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                bytes, 128);\n-        serverBytes = serverSession.exportKeyMaterialData(\"goodbye\",\n-                bytes, 128);\n-        assertNotEqualsByteArray(clientBytes, serverBytes,\n-                \"Different labels but exporters same\");\n-        log(\"Different labels test passed\");\n-\n-        \/\/ Different output sizes\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                bytes, 128);\n-        serverBytes = serverSession.exportKeyMaterialData(\"hello\",\n-                bytes, 127);\n-        assertEquals(clientBytes.length, 128, \"client length != 128\");\n-        assertEquals(serverBytes.length, 127, \"server length != 127\");\n-        assertNotEqualsByteArray(clientBytes, serverBytes,\n-                \"Different output sizes but exporters same\");\n-        log(\"Different output size test passed\");\n-\n-        \/\/ Different context values\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                bytes, 128);\n-        serverBytes = serverSession.exportKeyMaterialData(\"hello\",\n-                bytesDiff, 128);\n-        assertNotEqualsByteArray(clientBytes, serverBytes,\n-                \"Different context but exporters same\");\n-        log(\"Different context test passed\");\n-\n-        \/\/ Different context sizes\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                bytes, 128);\n-        serverBytes = serverSession.exportKeyMaterialData(\"hello\",\n-                bytesDiffSize, 128);\n-        assertNotEqualsByteArray(clientBytes, serverBytes,\n-                \"Different context sizes but exporters same\");\n-        log(\"Different context sizes test passed\");\n-\n-        \/\/ No context, but otherwise the same\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                null, 128);\n-        serverBytes = serverSession.exportKeyMaterialData(\"hello\",\n-                null, 128);\n-        assertEqualsByteArray(clientBytes, serverBytes,\n-                \"No context and exporters are not the same\");\n-        log(\"No context test passed\");\n-\n-        \/\/ Smaller key size\n-        clientBytes = clientSession.exportKeyMaterialData(\"hello\",\n-                bytes, 40);\n-        serverBytes = serverSession.exportKeyMaterialData(\"hello\",\n-                bytes, 40);\n-        assertEqualsByteArray(clientBytes, serverBytes,\n-                \"Smaller key size should be the same\");\n-        log(\"Smaller key size test passed\");\n-\n-        \/\/ Check error conditions\n-        try {\n-            clientSession.exportKeyMaterialData(null, bytes, 128);\n-            throw new Exception(\"null label accepted\");\n-        } catch (NullPointerException e) {\n-            log(\"null label test passed\");\n-        }\n-\n-        try {\n-            clientSession.exportKeyMaterialData(\"hello\", new byte[1<<16], 128);\n-            if (!clientSession.getProtocol().equals(\"TLSv1.3\")) {\n-                throw new Exception(\"large context accepted in \" +\n-                        \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n-            } else {\n-                log(\"large context test passed in TLSv1.3\");\n-            }\n-        } catch (IllegalArgumentException e) {\n-            log(\"large context test passed in \" +\n-                    \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n-        }\n-\n-        try {\n-            clientSession.exportKeyMaterialData(\"hello\", bytes, -20);\n-            throw new Exception(\"negative length accepted\");\n-        } catch (IllegalArgumentException e) {\n-            log(\"negative length test passed\");\n-        }\n-    }\n-\n-    static boolean isOpen(SSLEngine engine) {\n-        return (!engine.isOutboundDone() || !engine.isInboundDone());\n-    }\n-\n-    private static void logEngineStatus(SSLEngine engine) {\n-        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n-        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n-        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n-    }\n-\n-    private static void logEngineStatus(\n-            SSLEngine engine, SSLEngineResult result) {\n-        log(\"\\tResult Status    : \" + result.getStatus());\n-        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n-        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n-        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n-        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n-        log(\"\\tMore Result      : \" + result);\n-    }\n-\n-    private static void log(String message) {\n-        System.err.println(message);\n-    }\n-\n-    \/\/ If the result indicates that we have outstanding tasks to do,\n-    \/\/ go ahead and run them in this thread.\n-    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n-        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"    running delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                        \"handshake shouldn't need additional tasks\");\n-            }\n-            logEngineStatus(engine);\n-        }\n-    }\n-\n-    \/\/ Simple check to make sure everything came across as expected.\n-    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/ExtendedSSLSession\/TLSKeyExporters.java","additions":0,"deletions":461,"binary":false,"changes":461,"status":"deleted"}]}