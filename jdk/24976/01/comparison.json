{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.crypto.SecretKey;\n@@ -166,0 +167,89 @@\n+\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     * <P>\n+     * Note RFC 5705 calculates different EKM values if {@code context}\n+     * is null vs. non-null\/empty.  RFC 8446 does not make such a\n+     * distinction.\n+     * <P>\n+     * The {@code label} {@code String} will be converted to bytes using\n+     * the {@link java.nio.charset.StandardCharsets#UTF_8}\n+     * character encoding.\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc5705\n+     *     RFC 5705: Keying Material Exporters for Transport Layer\n+     *     Security (TLS)\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc8446\n+     *     RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3\n+     *\n+     * @param label   the label bytes used in the EKM calculation.\n+     *                {@code label} will be converted to a {@code byte[]}\n+     *                before the operation begins.\n+     * @param context the context bytes used in the EKM calculation\n+     * @param length  the number of bytes of EKM material needed\n+     *\n+     * @throws SSLKeyException if the key could not be generated\n+     * @throws IllegalArgumentException if {@code length} is negative\n+     *         or the {@code context} length is larger than can be\n+     *         accommodated\n+     * @throws NullPointerException if {@code label} is null\n+     * @throws UnsupportedOperationException if the underlying provider\n+     *         does not implement the operation\n+     *\n+     * @return a {@code SecretKey} that contains {@code length} bytes of the\n+     *         EKM material.\n+     *\n+     * @since 25\n+     *\/\n+    public SecretKey exportKeyMaterialKey(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     * <P>\n+     * Note RFC 5705 calculates different EKM values if {@code context}\n+     * is null vs. non-null\/empty.  RFC 8446 does not make such a\n+     * distinction.\n+     * <P>\n+     * The {@code label} {@code String} will be converted to bytes using\n+     * the {@link java.nio.charset.StandardCharsets#UTF_8}\n+     * character encoding.\n+     * <P>\n+     * Depending on the chosen underlying key derivation mechanism, the\n+     * raw bytes might not be extractable\/exportable.  In such cases, the\n+     * {@link #exportKeyMaterialKey(String, byte[], int)} method should be\n+     * used instead to access the generated key material.\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc5705\n+     *     RFC 5705: Keying Material Exporters for Transport Layer\n+     *     Security (TLS)\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc8446\n+     *     RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3\n+     *\n+     * @param label   the label bytes used in the EKM calculation\n+     *                {@code label} will be converted to a {@code byte[]}\n+     *                before the operation begins.\n+     * @param context the context bytes used in the EKM calculation\n+     * @param length  the number of bytes of EKM material needed\n+     *\n+     * @throws SSLKeyException if the key could not be generated\n+     * @throws IllegalArgumentException if {@code length} is negative\n+     *         or the {@code context} length is larger than can be\n+     *         accommodated\n+     * @throws NullPointerException if {@code label} is null\n+     * @throws UnsupportedOperationException if the underlying provider\n+     *         does not implement the operation, or if the derived key\n+     *         material is not extractable.\n+     *\n+     * @return a byte buffer of size {@code length} that contains the EKM\n+     *         material\n+     * @since 25\n+     *\/\n+    public byte[] exportKeyMaterialData(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/ExtendedSSLSession.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,0 +212,2 @@\n+                chc.handshakeSession.setRandoms(\n+                        chc.clientHelloRandom, chc.serverHelloRandom);\n@@ -308,0 +310,2 @@\n+            shc.handshakeSession.setRandoms(\n+                    shc.clientHelloRandom, shc.serverHelloRandom);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHClientKeyExchange.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,2 @@\n+                chc.handshakeSession.setRandoms(\n+                        chc.clientHelloRandom, chc.serverHelloRandom);\n@@ -344,0 +346,2 @@\n+            shc.handshakeSession.setRandoms(\n+                    shc.clientHelloRandom, shc.serverHelloRandom);\n@@ -424,0 +428,2 @@\n+                chc.handshakeSession.setRandoms(\n+                        chc.clientHelloRandom, chc.serverHelloRandom);\n@@ -528,0 +534,2 @@\n+            shc.handshakeSession.setRandoms(\n+                    shc.clientHelloRandom, shc.serverHelloRandom);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHClientKeyExchange.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -753,0 +753,6 @@\n+            \/\/ Calculate\/save the exporter_master_secret.  It uses\n+            \/\/ the same handshakeHash as the client\/server app traffic.\n+            SecretKey exporterSecret = kd.deriveKey(\n+                    \"TlsExporterMasterSecret\", null);\n+            chc.handshakeSession.setExporterMasterSecret(exporterSecret);\n+\n@@ -1113,0 +1119,6 @@\n+                \/\/ Calculate\/save the exporter_master_secret.  It uses\n+                \/\/ the same handshakeHash as the client\/server app traffic.\n+                SecretKey exporterSecret = kd.deriveKey(\n+                        \"TlsExporterMasterSecret\", null);\n+                shc.handshakeSession.setExporterMasterSecret(exporterSecret);\n+\n@@ -1119,1 +1131,1 @@\n-                \"TlsResumptionMasterSecret\", null);\n+                        \"TlsResumptionMasterSecret\", null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,0 +216,3 @@\n+                chc.handshakeSession.setRandoms(\n+                        chc.clientHelloRandom, chc.serverHelloRandom);\n+\n@@ -304,0 +307,3 @@\n+                shc.handshakeSession.setRandoms(\n+                        shc.clientHelloRandom, shc.serverHelloRandom);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAClientKeyExchange.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-import java.security.Principal;\n-import java.security.PrivateKey;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n@@ -41,0 +41,1 @@\n+import java.util.Objects;\n@@ -44,0 +45,1 @@\n+import javax.crypto.KeyGenerator;\n@@ -46,8 +48,8 @@\n-import javax.net.ssl.ExtendedSSLSession;\n-import javax.net.ssl.SNIHostName;\n-import javax.net.ssl.SNIServerName;\n-import javax.net.ssl.SSLException;\n-import javax.net.ssl.SSLPeerUnverifiedException;\n-import javax.net.ssl.SSLSessionBindingEvent;\n-import javax.net.ssl.SSLSessionBindingListener;\n-import javax.net.ssl.SSLSessionContext;\n+import javax.net.ssl.*;\n+import javax.security.auth.DestroyFailedException;\n+\n+import sun.security.ssl.CipherSuite.HashAlg;\n+import sun.security.internal.spec.TlsPrfParameterSpec;\n+import static sun.security.ssl.CipherSuite.HashAlg.H_NONE;\n+import static sun.security.ssl.ProtocolVersion.*;\n+\n@@ -102,0 +104,3 @@\n+    private SecretKey           exporterMasterSecret;  \/\/ TLSv1.3+ exporter info\n+    private RandomCookie        clientRandom,          \/\/ TLSv1.2- exporter info\n+                                serverRandom;\n@@ -240,0 +245,4 @@\n+        this.exporterMasterSecret = baseSession.exporterMasterSecret;\n+        this.resumptionMasterSecret = baseSession.resumptionMasterSecret;\n+        this.clientRandom = baseSession.clientRandom;\n+        this.serverRandom = baseSession.serverRandom;\n@@ -246,1 +255,0 @@\n-        this.resumptionMasterSecret = baseSession.resumptionMasterSecret;\n@@ -268,2 +276,1 @@\n-     * < 1 byte > masterSecret length\n-     *   < 1 byte > masterSecret algorithm length\n+     * < 1 byte > masterSecret algorithm length (if == 0, no Key)\n@@ -308,0 +315,8 @@\n+     * < 1 byte > exporterMasterSecret algorithm length (if == 0, no Key)\n+     *   < length in bytes > exporterMasterSecret algorithm\n+     *   < 2 bytes > exporterMasterSecretKey length\n+     *   < length in bytes> exporterMasterSecretKey\n+     * < 1 byte > Length of clientRandom\n+     *   < length in bytes > clientRandom\n+     * < 1 byte > Length of serverRandom\n+     *   < length in bytes > serverRandom\n@@ -382,0 +397,1 @@\n+\n@@ -517,0 +533,40 @@\n+        \/\/ Exporter master secret length of secret key algorithm (one byte)\n+        i = buf.get();\n+        if (i > 0) {\n+            b = new byte[i];\n+            \/\/ Get algorithm string\n+            buf.get(b, 0, i);\n+            String algName = new String(b);\n+            \/\/ Encoded length\n+            i = Short.toUnsignedInt(buf.getShort());\n+            \/\/ Encoded SecretKey\n+            b = new byte[i];\n+            buf.get(b);\n+            this.exporterMasterSecret = new SecretKeySpec(b, algName);\n+        } else {\n+            \/\/ TLSv1.2-\n+            this.exporterMasterSecret = null;\n+        }\n+\n+        \/\/ Get clientRandom\n+        i = Byte.toUnsignedInt(buf.get());\n+        if (i > 0) {\n+            b = new byte[i];\n+            buf.get(b, 0, i);\n+            this.clientRandom = new RandomCookie(ByteBuffer.wrap(b));\n+        } else {\n+            \/\/ TLSv1.3+\n+            this.clientRandom = null;\n+        }\n+\n+        \/\/ Get serverRandom\n+        i = Byte.toUnsignedInt(buf.get());\n+        if (i > 0) {\n+            b = new byte[i];\n+            buf.get(b, 0, i);\n+            this.serverRandom = new RandomCookie(ByteBuffer.wrap(b));\n+        } else {\n+            \/\/ TLSv1.3+\n+            this.serverRandom = null;\n+        }\n+\n@@ -697,0 +753,30 @@\n+        \/\/ Exporter Master Secret from TLSv1.3+\n+        if (getExporterMasterSecret() == null ||\n+                getExporterMasterSecret().getAlgorithm() == null) {\n+            hos.putInt8(0);\n+        } else {\n+            String alg = getExporterMasterSecret().getAlgorithm();\n+            hos.putInt8(alg.length());\n+            if (alg.length() != 0) {\n+                hos.write(alg.getBytes());\n+            }\n+            b = getExporterMasterSecret().getEncoded();\n+            hos.putInt16(b.length);\n+            hos.write(b, 0, b.length);\n+        }\n+\n+        \/\/ Randoms from TLSv1.2-\n+        if ( clientRandom == null || clientRandom.randomBytes.length == 0) {\n+            hos.putInt8(0);\n+        } else {\n+            hos.putInt8(clientRandom.randomBytes.length);\n+            hos.writeBytes(clientRandom.randomBytes);\n+        }\n+\n+        if ( serverRandom == null || serverRandom.randomBytes.length == 0) {\n+            hos.putInt8(0);\n+        } else {\n+            hos.putInt8(serverRandom.randomBytes.length);\n+            hos.writeBytes(serverRandom.randomBytes);\n+        }\n+\n@@ -704,0 +790,9 @@\n+    void setExporterMasterSecret(SecretKey secret) {\n+        exporterMasterSecret = secret;\n+    }\n+\n+    void setRandoms(RandomCookie client, RandomCookie server) {\n+        clientRandom = client;\n+        serverRandom = server;\n+    }\n+\n@@ -739,0 +834,21 @@\n+    \/**\n+     * Returns the exporter master secret\n+     *\/\n+    SecretKey getExporterMasterSecret() {\n+        return exporterMasterSecret;\n+    }\n+\n+    \/**\n+     * Returns the client's RandomCookie\n+     *\/\n+    RandomCookie getClientRandom() {\n+        return clientRandom;\n+    }\n+\n+    \/**\n+     * Returns the server's RandomCookie\n+     *\/\n+    RandomCookie getServerRandom() {\n+        return serverRandom;\n+    }\n+\n@@ -1489,0 +1605,196 @@\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     *\/\n+    @Override\n+    public SecretKey exportKeyMaterialKey(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+\n+        \/\/ Global preconditions\n+        Objects.requireNonNull(label, \"label can not be null\");\n+        if (length < 0) {\n+            throw new IllegalArgumentException(\n+                    \"Output length can not be negative\");\n+        }\n+\n+        \/\/ Calculations are primarily based on protocol version.\n+        switch (protocolVersion) {\n+        case TLS13:  \/\/ HKDF-based\n+            \/\/ Unlikely, but check anyway.\n+            if (exporterMasterSecret == null) {\n+                throw new RuntimeException(\n+                        \"Exporter master secret not captured\");\n+            }\n+\n+            \/\/ Do RFC 8446:7.1-7.5 calculations\n+\n+            \/*\n+             * TLS-Exporter(label, context_value, key_length) =\n+             *     HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\n+             *         \"exporter\", Hash(context_value), key_length)\n+             *\n+             * Derive-Secret(Secret, Label, Messages) =\n+             *     HKDF-Expand-Label(Secret, Label,\n+             *         Transcript-Hash(Messages), Hash.length)\n+             *\/\n+\n+            \/\/ If no context (null) is provided, RFC 8446 requires an empty\n+            \/\/ context be used, unlike RFC 5705.\n+            context = (context != null ? context : new byte[0]);\n+\n+            try {\n+                \/\/ Use the ciphersuite's hashAlg for these calcs.\n+                HashAlg hashAlg = cipherSuite.hashAlg;\n+                HKDF hkdf = new HKDF(hashAlg.name);\n+\n+                \/\/ First calculate the inner Derive-Secret(Secret, label, \"\")\n+                MessageDigest md;\n+                byte[] emptyHash;\n+\n+                \/\/ Create the \"\" digest...\n+                try {\n+                    md = MessageDigest.getInstance(hashAlg.toString());\n+                    emptyHash = md.digest();\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    throw new RuntimeException(\n+                            \"Hash algorithm \" + cipherSuite.hashAlg.name +\n+                                    \" is not available\", nsae);\n+                }\n+\n+                \/\/ ...then the hkdfInfo...\n+                byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(\n+                        (\"tls13 \" + label).getBytes(StandardCharsets.UTF_8),\n+                        emptyHash, hashAlg.hashLength);\n+\n+                \/\/ ...then the \"inner\" HKDF-Expand-Label() to get the\n+                \/\/ derivedSecret that is used as the Secret in the \"outer\"\n+                \/\/ HKDF-Expand-Label().\n+                SecretKey derivedSecret = hkdf.expand(exporterMasterSecret,\n+                        hkdfInfo, hashAlg.hashLength, \"DerivedSecret\");\n+\n+                \/\/ Now do the \"outer\" HKDF-Expand-Label.\n+                \/\/     HKDF-Expand-Label(derivedSecret, \"exporter\",\n+                \/\/         Hash(context_value), key_length)\n+\n+                \/\/ If a context was supplied, use it, otherwise, use the\n+                \/\/ previous hashed value of \"\"...\n+                byte[] hash = ((context.length > 0) ?\n+                        md.digest(context): emptyHash);\n+\n+                \/\/ ...now the hkdfInfo...\n+                hkdfInfo = SSLSecretDerivation.createHkdfInfo((\"tls13 \" +\n+                        \"exporter\").getBytes(StandardCharsets.UTF_8), hash,\n+                        length);\n+\n+                \/\/ ...now the final expand.\n+                SecretKey key = hkdf.expand(derivedSecret, hkdfInfo, length,\n+                        \"label\");\n+                try {\n+                    \/\/ Best effort\n+                    derivedSecret.destroy();\n+                } catch (DestroyFailedException e) {\n+                    \/\/ swallow\n+                }\n+                return key;\n+            } catch (Exception e) {\n+                \/\/ For whatever reason, we couldn't generate.  Wrap and return.\n+                throw new SSLKeyException(\"Couldn't generate Exporter\/HKDF\", e);\n+            }\n+\n+        case TLS12:  \/\/ RFC 7505 using PRF-based (RFC 2246\/4346\/5246) calcs.\n+        case TLS11:\n+        case TLS10:\n+\n+            \/\/ RFC 7627:\n+            \/\/\n+            \/\/   If a client or server chooses to continue with a full handshake\n+            \/\/   without the extended master secret extension ... they MUST NOT\n+            \/\/   export any key material based on the new master secret for any\n+            \/\/   subsequent application-level authentication ... it MUST\n+            \/\/   disable [RFC5705] ...\n+\n+            if (!useExtendedMasterSecret) {\n+                throw new SSLKeyException(\n+                        \"Exporters require extended master secrets\");\n+            }\n+\n+            \/\/ Unlikely, but check if randoms were not captured.\n+            if (clientRandom == null || serverRandom == null) {\n+                throw new RuntimeException(\"Random nonces not captured\");\n+            }\n+\n+            \/\/ context length must fit in 2 unsigned bytes.\n+            if ((context != null) && context.length >= (1 << 16)) {\n+                throw new IllegalArgumentException(\n+                        \"Only 16-bit context lengths supported\");\n+            }\n+\n+            \/\/ Perform RFC 5705 calculations using the internal SunJCE PRF.\n+            String prfAlg;\n+            HashAlg hashAlg;\n+            if (protocolVersion == TLS12) {\n+                prfAlg = \"SunTls12Prf\";\n+                hashAlg = cipherSuite.hashAlg;\n+            } else {  \/\/  all other cases\n+                prfAlg = \"SunTlsPrf\";\n+                hashAlg = H_NONE;\n+            }\n+\n+            \/\/ Make a seed with randoms and optional context\n+            \/\/ Note that if context is null, it is omitted from the calc\n+            byte[] clientRandomBytes = clientRandom.randomBytes;\n+            byte[] serverRandomBytes = serverRandom.randomBytes;\n+            byte[] seed = new byte[\n+                    clientRandomBytes.length + serverRandomBytes.length +\n+                            ((context != null) ? (2 + context.length) : 0)];\n+\n+            int pos = 0;\n+            System.arraycopy(\n+                    clientRandomBytes, 0, seed, pos, clientRandomBytes.length);\n+            pos += clientRandomBytes.length;\n+            System.arraycopy(\n+                    serverRandomBytes, 0, seed, pos, serverRandomBytes.length);\n+            pos += serverRandomBytes.length;\n+            if (context != null) {\n+                \/\/ RFC 5705, \"If no context is provided, ...\"\n+                seed[pos++] = (byte) ((context.length >> 8) & 0xFF);\n+                seed[pos++] = (byte) ((context.length) & 0xFF);\n+                System.arraycopy(\n+                        context, 0, seed, pos, context.length);\n+            }\n+\n+            \/\/ Call the PRF function.\n+            try {\n+                @SuppressWarnings(\"deprecation\")\n+                TlsPrfParameterSpec spec = new TlsPrfParameterSpec(\n+                        masterSecret, label, seed, length,\n+                        hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);\n+                KeyGenerator kg = KeyGenerator.getInstance(prfAlg);\n+                kg.init(spec);\n+                return kg.generateKey();\n+            } catch (NoSuchAlgorithmException |\n+                     InvalidAlgorithmParameterException e) {\n+                throw new SSLKeyException(\"Could not generate Exporter\/PRF\", e);\n+            }\n+        default:\n+            \/\/ SSLv3 is vulnerable to a triple handshake attack and can't be\n+            \/\/ mitigated by RFC 7627.  Don't support this or any other\n+            \/\/ unknown protocol.\n+            throw new SSLKeyException(\n+                    \"Exporters not supported in \" + protocolVersion);\n+        }\n+    }\n+\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     *\/\n+    @Override\n+    public byte[] exportKeyMaterialData(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        if (exportKeyMaterialKey(label, context, length).getEncoded() == null) {\n+            throw new UnsupportedOperationException(\n+                    \"Exported key material is not extractable\");\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":325,"deletions":13,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -0,0 +1,466 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8341346\n+ * @summary Add support for exporting TLS Keying Material\n+ * @library \/javax\/net\/ssl\/templates\n+ * @build SSLContextTemplate\n+ * @run main\/othervm TLSKeyExporters\n+ *\/\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.nio.ByteBuffer;\n+import java.util.Random;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <P>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <P>\n+ * Note, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ * <P>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class TLSKeyExporters extends SSLContextTemplate {\n+    protected final SSLEngine clientEngine;     \/\/ client Engine\n+    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    \/\/ For data transport, this example uses local ByteBuffers.  This\n+    \/\/ isn't really useful, but the purpose of this example is to show\n+    \/\/ SSLEngine concepts, not how to do network transport.\n+    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected TLSKeyExporters(String protocol, String ciphersuite)\n+            throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine(),\n+                protocol, ciphersuite);\n+\n+        \/\/ We'll assume the buffer sizes are the same\n+        \/\/ between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/\/\n+    \/\/ Protected methods could be used to customize the test case.\n+    \/\/\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine,\n+            String protocol, String ciphersuite) {\n+        clientEngine.setUseClientMode(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        paramsClient.setProtocols(new String[] { protocol });\n+        paramsClient.setCipherSuites(new String[] { ciphersuite });\n+        clientEngine.setSSLParameters(paramsClient);\n+\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        \/\/\n+        SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        paramsServer.setProtocols(new String[] {\n+                \"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSLv3\"\n+        });\n+        serverEngine.setSSLParameters(paramsServer);\n+\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Turn off the disabled Algorithms so we can also test SSLv3\/TLSv1\/etc.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        \/\/ Exercise all of the triggers which capture data\n+        \/\/ in the various key exchange algorithms.\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos for TLSv1.3\n+        new TLSKeyExporters(\n+                \"TLSv1.3\", \"TLS_AES_128_GCM_SHA256\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.3\", \"TLS_AES_256_GCM_SHA384\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.3\", \"TLS_CHACHA20_POLY1305_SHA256\").runTest();\n+\n+        \/\/ Try the various GCM suites for TLSv1.2\n+        new TLSKeyExporters(\n+                \"TLSv1.2\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.2\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.2\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+\n+        \/\/ Try one TLSv1.2\/CBC suite just for grins, the triggers are the same.\n+        new TLSKeyExporters(\n+                \"TLSv1.2\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\").runTest();\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos.  Some of the 1.2\n+        \/\/ suites (e.g. GCM) can't be used in earlier TLS versions.\n+        new TLSKeyExporters(\n+                \"TLSv1.1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1.1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        new TLSKeyExporters(\n+                \"TLSv1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new TLSKeyExporters(\n+                \"TLSv1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        try {\n+            new TLSKeyExporters(\n+                    \"SSLv3\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+            throw new Exception(\"SSLv3 export test should not have passed\");\n+        } catch (SSLException e) {\n+            System.out.println(\"SSLv3 test failed as expected\");\n+        }\n+\n+        System.out.println(\"All tests PASSED\");\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTest() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            log(\"=================\");\n+\n+            \/\/ client wrap\n+            log(\"---Client Wrap---\");\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server wrap\n+            log(\"---Server Wrap---\");\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            \/\/ client unwrap\n+            log(\"---Client Unwrap---\");\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server unwrap\n+            log(\"---Server Unwrap---\");\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/\/ After we've transferred all application data between the client\n+            \/\/ and server, we close the clientEngine's outbound stream.\n+            \/\/ This generates a close_notify handshake message, which the\n+            \/\/ server engine receives and responds by closing itself.\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                runExporterTests(\n+                        (ExtendedSSLSession) clientEngine.getSession(),\n+                        (ExtendedSSLSession) serverEngine.getSession());\n+\n+                \/\/ A sanity check to ensure we got what was sent.\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                logEngineStatus(clientEngine);\n+\n+                dataDone = true;\n+                log(\"\\tClosing serverEngine's *OUTBOUND*...\");\n+                serverEngine.closeOutbound();\n+                logEngineStatus(serverEngine);\n+            }\n+        }\n+    }\n+\n+    private static void runExporterTests(\n+            ExtendedSSLSession cessls,\n+            ExtendedSSLSession sessls) throws Exception {\n+\n+        \/\/ Create output arrays\n+        byte[] clientBytes, serverBytes;\n+\n+        \/\/ Create various input arrays and fill with junk.\n+        Random random = new Random();\n+        byte[] bytes = new byte[20];\n+        random.nextBytes(bytes);\n+\n+        \/\/ Slightly change 1 byte in the middle\n+        byte[] bytesDiff = Arrays.copyOf(bytes, bytes.length);\n+        bytesDiff[bytes.length\/2]++;\n+\n+        byte[] bytesDiffSize = new byte[21];\n+        random.nextBytes(bytesDiffSize);\n+\n+        \/\/ Inputs exactly equal.  Use exportKeyMaterialKey()\n+        clientBytes = cessls.exportKeyMaterialKey(\"hello\",\n+                bytes, 128).getEncoded();\n+        serverBytes = sessls.exportKeyMaterialKey(\"hello\",\n+                bytes, 128).getEncoded();\n+        if (!Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Equal inputs but exporters are not\");\n+        } else {\n+            log(\"Equal inputs test passed\");\n+        }\n+\n+        \/\/ Empty label.  I don't see anything that says this is\n+        \/\/ forbidden.  There is some verbiage about: labels being registered\n+        \/\/ with IANA, must not collide with existing PRF labels, SHOULD use\n+        \/\/ \"EXPORTER\"\/\"EXPERIMENTAL\" prefixes, etc.\n+        clientBytes = cessls.exportKeyMaterialKey(\"\",\n+                bytes, 128).getEncoded();\n+        serverBytes = sessls.exportKeyMaterialKey(\"\",\n+                bytes, 128).getEncoded();\n+        if (!Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Empty label and exporters are equal\");\n+        } else {\n+            log(\"Empty label test passed\");\n+        }\n+\n+        \/\/ Different labels, now use exportKeyMaterialData() for coverage\n+        clientBytes = cessls.exportKeyMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = sessls.exportKeyMaterialData(\"goodbye\",\n+                bytes, 128);\n+        if (Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Different labels but exporters same\");\n+        } else {\n+            log(\"Different labels test passed\");\n+        }\n+\n+        \/\/ Different output sizes\n+        clientBytes = cessls.exportKeyMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = sessls.exportKeyMaterialData(\"hello\",\n+                bytes, 127);\n+        if ((clientBytes.length != 128) || (serverBytes.length != 127)) {\n+            throw new Exception(\"Output sizes incorrect:  \" +\n+                    clientBytes.length + \"\/\" + serverBytes.length);\n+        }\n+        if (Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Different output sizes but exporters same\");\n+        } else {\n+            log(\"Different output size test passed\");\n+        }\n+\n+        \/\/ Different context values\n+        clientBytes = cessls.exportKeyMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = sessls.exportKeyMaterialData(\"hello\",\n+                bytesDiff, 128);\n+        if (Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Different context but exporters same\");\n+        } else {\n+            log(\"Different context test passed\");\n+        }\n+\n+        \/\/ Different context sizes\n+        clientBytes = cessls.exportKeyMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = sessls.exportKeyMaterialData(\"hello\",\n+                bytesDiffSize, 128);\n+        if (Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"Different context sizes but exporters same.\");\n+        } else {\n+            log(\"Different context sizes test passed\");\n+        }\n+\n+        \/\/ No context, but otherwise the same\n+        clientBytes = cessls.exportKeyMaterialData(\"hello\",\n+                null, 128);\n+        serverBytes = sessls.exportKeyMaterialData(\"hello\",\n+                null, 128);\n+        if (!Arrays.equals(clientBytes, serverBytes)) {\n+            throw new Exception(\"No context and exporters are not the same.\");\n+        } else {\n+            log(\"No context test passed\");\n+        }\n+\n+        \/\/ Check error conditions\n+        try {\n+            cessls.exportKeyMaterialData(null, bytes, 128);\n+            throw new Exception(\"null label accepted\");\n+        } catch (NullPointerException e) {\n+            log(\"null label test passed\");\n+        }\n+\n+        try {\n+            cessls.exportKeyMaterialData(\"hello\", new byte[1<<16], 128);\n+            if (!cessls.getProtocol().equals(\"TLSv1.3\")) {\n+                throw new Exception(\"large context accepted in \" +\n+                        \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n+            } else {\n+                log(\"large context test passed in TLSv1.3\");\n+            }\n+        } catch (IllegalArgumentException e) {\n+            log(\"large context test passed in \" +\n+                    \"SSLv3\/TLSv1\/TLSv1.1\/TLSv1.2\");\n+        }\n+\n+        try {\n+            cessls.exportKeyMaterialData(\"hello\", bytes, -20);\n+            throw new Exception(\"negative length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"negative length test passed\");\n+        }\n+    }\n+\n+    static boolean isOpen(SSLEngine engine) {\n+        return (!engine.isOutboundDone() || !engine.isInboundDone());\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    \/\/ Simple check to make sure everything came across as expected.\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/ExtendedSSLSession\/TLSKeyExporters.java","additions":466,"deletions":0,"binary":false,"changes":466,"status":"added"}]}