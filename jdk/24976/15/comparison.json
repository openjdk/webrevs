{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.crypto.SecretKey;\n@@ -166,0 +167,95 @@\n+\n+    \/**\n+     * Generates Exported Keying Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     * <P>\n+     * RFC 5705 (for (D)TLSv1.2 and earlier) calculates different EKM\n+     * values depending on whether {@code context} is null or non-null\/empty.\n+     * RFC 8446 (TLSv1.3) treats a null context as non-null\/empty.\n+     * <P>\n+     * The {@code label} {@code String} will be converted to bytes using\n+     * the {@link java.nio.charset.StandardCharsets#UTF_8}\n+     * character encoding.\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc5705\n+     *     RFC 5705: Keying Material Exporters for Transport Layer\n+     *     Security (TLS)\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc8446\n+     *     RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3\n+     *\n+     * @implSpec The default implementation throws\n+     *           {@code UnsupportedOperationException}.\n+     *\n+     * @param label   the label bytes used in the EKM calculation.\n+     *                {@code label} will be converted to a {@code byte[]}\n+     *                before the operation begins\n+     * @param context the context bytes used in the EKM calculation, or null\n+     * @param length  the number of bytes of EKM material needed\n+     *\n+     * @throws SSLKeyException if the key cannot be generated\n+     * @throws IllegalArgumentException if {@code length} is non-positive,\n+     *         or if the {@code label} or {@code context} length can\n+     *         not be accommodated\n+     * @throws NullPointerException if {@code label} is null\n+     * @throws UnsupportedOperationException if the underlying provider\n+     *         does not implement the operation\n+     *\n+     * @return a {@code SecretKey} that contains {@code length} bytes of the\n+     *         EKM material\n+     *\n+     * @since 25\n+     *\/\n+    public SecretKey exportKeyingMaterialKey(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Generates Exported Keying Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     * <P>\n+     * RFC 5705 (for (D)TLSv1.2 and earlier) calculates different EKM\n+     * values depending on whether {@code context} is null or non-null\/empty.\n+     * RFC 8446 (TLSv1.3) treats a null context as non-null\/empty.\n+     * <P>\n+     * The {@code label} {@code String} will be converted to bytes using\n+     * the {@link java.nio.charset.StandardCharsets#UTF_8}\n+     * character encoding.\n+     * <P>\n+     * Depending on the chosen underlying key derivation mechanism, the\n+     * raw bytes might not be extractable\/exportable.  In such cases, the\n+     * {@link #exportKeyingMaterialKey(String, byte[], int)} method should be\n+     * used instead to access the generated key material.\n+     *\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc5705\n+     *     RFC 5705: Keying Material Exporters for Transport Layer\n+     *     Security (TLS)\n+     * @spec https:\/\/www.rfc-editor.org\/info\/rfc8446\n+     *     RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3\n+     *\n+     * @implSpec The default implementation throws\n+     *           {@code UnsupportedOperationException}.\n+     *\n+     * @param label   the label bytes used in the EKM calculation.\n+     *                {@code label} will be converted to a {@code byte[]}\n+     *                before the operation begins\n+     * @param context the context bytes used in the EKM calculation, or null\n+     * @param length  the number of bytes of EKM material needed\n+     *\n+     * @throws SSLKeyException if the key cannot be generated\n+     * @throws IllegalArgumentException if {@code length} is non-positive,\n+     *         or if the {@code label} or {@code context} length can\n+     *         not be accommodated\n+     * @throws NullPointerException if {@code label} is null\n+     * @throws UnsupportedOperationException if the underlying provider\n+     *         does not implement the operation\n+     *\n+     * @return a byte array of size {@code length} that contains the EKM\n+     *         material, or null if the derived key material does not support\n+     *         encoding\n+     * @since 25\n+     *\/\n+    public byte[] exportKeyingMaterialData(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/ExtendedSSLSession.java","additions":97,"deletions":1,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -748,0 +748,6 @@\n+            \/\/ Calculate\/save the exporter_master_secret.  It uses\n+            \/\/ the same handshakeHash as the client\/server app traffic.\n+            SecretKey exporterSecret = kd.deriveKey(\n+                    \"TlsExporterMasterSecret\");\n+            chc.handshakeSession.setExporterMasterSecret(exporterSecret);\n+\n@@ -1102,0 +1108,6 @@\n+                \/\/ Calculate\/save the exporter_master_secret.  It uses\n+                \/\/ the same handshakeHash as the client\/server app traffic.\n+                SecretKey exporterSecret = kd.deriveKey(\n+                        \"TlsExporterMasterSecret\");\n+                shc.handshakeSession.setExporterMasterSecret(exporterSecret);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -33,2 +34,1 @@\n-import java.security.Principal;\n-import java.security.PrivateKey;\n+import java.security.*;\n@@ -42,0 +42,1 @@\n+import java.util.Objects;\n@@ -45,0 +46,2 @@\n+import javax.crypto.KDF;\n+import javax.crypto.KeyGenerator;\n@@ -46,0 +49,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -47,8 +51,9 @@\n-import javax.net.ssl.ExtendedSSLSession;\n-import javax.net.ssl.SNIHostName;\n-import javax.net.ssl.SNIServerName;\n-import javax.net.ssl.SSLException;\n-import javax.net.ssl.SSLPeerUnverifiedException;\n-import javax.net.ssl.SSLSessionBindingEvent;\n-import javax.net.ssl.SSLSessionBindingListener;\n-import javax.net.ssl.SSLSessionContext;\n+import javax.net.ssl.*;\n+import javax.security.auth.DestroyFailedException;\n+\n+import sun.security.ssl.CipherSuite.HashAlg;\n+import sun.security.internal.spec.TlsPrfParameterSpec;\n+import static sun.security.ssl.CipherSuite.HashAlg.H_NONE;\n+import static sun.security.ssl.ProtocolVersion.*;\n+import sun.security.util.KeyUtil;\n+\n@@ -103,0 +108,3 @@\n+    private SecretKey           exporterMasterSecret;  \/\/ TLSv1.3+ exporter info\n+    private RandomCookie        clientRandom;          \/\/ TLSv1.2- exporter info\n+    private RandomCookie        serverRandom;\n@@ -247,1 +255,1 @@\n-        this.resumptionMasterSecret = baseSession.resumptionMasterSecret;\n+        this.exporterMasterSecret = baseSession.exporterMasterSecret;\n@@ -269,2 +277,1 @@\n-     * < 1 byte > masterSecret length\n-     *   < 1 byte > masterSecret algorithm length\n+     * < 1 byte > masterSecret algorithm length (if == 0, no Key)\n@@ -309,0 +316,1 @@\n+\n@@ -674,0 +682,9 @@\n+    void setExporterMasterSecret(SecretKey secret) {\n+        exporterMasterSecret = secret;\n+    }\n+\n+    void setRandoms(RandomCookie client, RandomCookie server) {\n+        clientRandom = client;\n+        serverRandom = server;\n+    }\n+\n@@ -709,0 +726,21 @@\n+    \/**\n+     * Returns the exporter master secret\n+     *\/\n+    SecretKey getExporterMasterSecret() {\n+        return exporterMasterSecret;\n+    }\n+\n+    \/**\n+     * Returns the client's RandomCookie\n+     *\/\n+    RandomCookie getClientRandom() {\n+        return clientRandom;\n+    }\n+\n+    \/**\n+     * Returns the server's RandomCookie\n+     *\/\n+    RandomCookie getServerRandom() {\n+        return serverRandom;\n+    }\n+\n@@ -1459,0 +1497,244 @@\n+    \/*\n+     * deriveKey is used for switching between Keys\/Data.  Will redo\n+     * if we ever introduce additional types.\n+     *\/\n+    public Object exportKeyingMaterial(\n+            boolean deriveKey, String label, byte[] context, int length)\n+            throws SSLKeyException {\n+\n+        \/\/ Global preconditions\n+\n+        Objects.requireNonNull(label, \"label can not be null\");\n+        if (length < 1) {\n+            throw new IllegalArgumentException(\n+                    \"length must be positive\");\n+        }\n+\n+        \/\/ Calculations are primarily based on protocol version.\n+        if (protocolVersion.useTLS13PlusSpec()) {\n+            \/\/ TLS 1.3+ using HKDF-based calcs.\n+            \/\/     TLS 1.3 (RFC 8446)\n+\n+            \/\/ Check the label\/context lengths:\n+            \/\/       struct {\n+            \/\/           uint16 length = Length;\n+            \/\/           opaque label<7..255> = \"tls13 \" + Label;\n+            \/\/           opaque context<0..255> = Context;\n+            \/\/       } HkdfLabel;\n+            \/\/ label can have 249 bytes (+6 for \"tls13 \"), and context 255\n+\n+            \/\/ RFC 8446 allows for length of 2^16-1 (65536), but RFC 5869\n+            \/\/ states:\n+            \/\/\n+            \/\/     L    length of output keying material in octets\n+            \/\/          (<= 255*HashLen)\n+            if (length > (255 * cipherSuite.hashAlg.hashLength )) {\n+                throw new IllegalArgumentException(\n+                        \"length is too large\");\n+            }\n+\n+            byte[] hkdfInfoLabel =\n+                        (\"tls13 \" + label).getBytes(StandardCharsets.UTF_8);\n+            if ((hkdfInfoLabel.length < 7) || hkdfInfoLabel.length > 255) {\n+                throw new IllegalArgumentException(\n+                        \"label length outside range\");\n+            }\n+\n+            \/\/ If no context (null) is provided, RFC 8446 requires an empty\n+            \/\/ context be used, unlike RFC 5705.\n+            context = (context != null ? context : new byte[0]);\n+            if (context.length > 255) {\n+                throw new IllegalArgumentException(\n+                        \"context length outside range\");\n+            }\n+\n+            \/\/ Unlikely, but check anyway.\n+            if (exporterMasterSecret == null) {\n+                throw new RuntimeException(\n+                        \"Exporter master secret not captured\");\n+            }\n+\n+            \/\/ Do RFC 8446:7.1-7.5 calculations\n+\n+            \/*\n+             * TLS-Exporter(label, context_value, key_length) =\n+             *     HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\n+             *         \"exporter\", Hash(context_value), key_length)\n+             *\n+             * Derive-Secret(Secret, Label, Messages) =\n+             *     HKDF-Expand-Label(Secret, Label,\n+             *         Transcript-Hash(Messages), Hash.length)\n+             *\/\n+\n+            try {\n+                \/\/ Use the ciphersuite's hashAlg for these calcs.\n+                HashAlg hashAlg = cipherSuite.hashAlg;\n+                KDF hkdf = KDF.getInstance(hashAlg.hkdfAlgorithm);\n+\n+                \/\/ First calculate the inner Derive-Secret(Secret, label, \"\")\n+                MessageDigest md;\n+                byte[] emptyHash;\n+\n+                \/\/ Create the \"\" digest...\n+                try {\n+                    md = MessageDigest.getInstance(hashAlg.toString());\n+                    emptyHash = md.digest();\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    throw new RuntimeException(\n+                            \"Hash algorithm \" + cipherSuite.hashAlg.name +\n+                                    \" is not available\", nsae);\n+                }\n+\n+                \/\/ ...then the hkdfInfo...\n+                byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(\n+                        hkdfInfoLabel, emptyHash, hashAlg.hashLength);\n+\n+                \/\/ ...then the \"inner\" HKDF-Expand-Label() to get the\n+                \/\/ derivedSecret that is used as the Secret in the \"outer\"\n+                \/\/ HKDF-Expand-Label().\n+                SecretKey derivedSecret = hkdf.deriveKey(\"TlsKey\",\n+                        HKDFParameterSpec.expandOnly(exporterMasterSecret,\n+                        hkdfInfo, hashAlg.hashLength));\n+                try {\n+                    \/\/ Now do the \"outer\" HKDF-Expand-Label.\n+                    \/\/     HKDF-Expand-Label(derivedSecret, \"exporter\",\n+                    \/\/         Hash(context_value), key_length)\n+\n+                    \/\/ If a context was supplied, use it, otherwise, use the\n+                    \/\/ previous hashed value of \"\"...\n+                    byte[] hash = ((context.length > 0) ?\n+                            md.digest(context) : emptyHash);\n+\n+                    \/\/ ...now the hkdfInfo...\n+                    hkdfInfo = SSLSecretDerivation.createHkdfInfo(\n+                            (\"tls13 exporter\").getBytes(StandardCharsets.UTF_8),\n+                            hash, length);\n+\n+                    \/\/ ...now the final expand.\n+                    return (deriveKey ?\n+                            hkdf.deriveKey(\"TlsExporterKeyingMaterial\",\n+                                    HKDFParameterSpec.expandOnly(derivedSecret,\n+                                            hkdfInfo, length)) :\n+                            hkdf.deriveData(\n+                                    HKDFParameterSpec.expandOnly(derivedSecret,\n+                                            hkdfInfo, length)));\n+                } finally {\n+                    KeyUtil.destroySecretKeys(derivedSecret);\n+                }\n+            } catch (Exception e) {\n+                \/\/ For whatever reason, we couldn't generate.  Wrap and return.\n+                throw new SSLKeyException(\"Couldn't generate Exporter\/HKDF\", e);\n+            }\n+        } else if (protocolVersion.useTLS10PlusSpec()) {\n+            \/\/ RFC 7505 using PRF-based calcs.\n+            \/\/     TLS 1\/1.1\/1.2 (RFCs 2246\/4346\/5246) or\n+            \/\/     DTLS 1.0\/1.2 (RFCs 4347\/6347)\n+\n+            \/\/ Note:  In RFC 7627:\n+            \/\/\n+            \/\/   If a client or server chooses to continue with a full handshake\n+            \/\/   without the extended master secret extension ... they MUST NOT\n+            \/\/   export any key material based on the new master secret for any\n+            \/\/   subsequent application-level authentication ... it MUST\n+            \/\/   disable [RFC5705] ...\n+\n+            if (!useExtendedMasterSecret) {\n+                throw new SSLKeyException(\n+                        \"Exporters require extended master secrets\");\n+            }\n+\n+            \/\/ Check for a \"disambiguating label string\" (i.e. non-empty).\n+            \/\/ Don't see a max length restriction.\n+            if (label.isEmpty()) {\n+                throw new IllegalArgumentException(\n+                        \"label length outside range\");\n+            }\n+\n+            \/\/ Unlikely, but check if randoms were not captured.\n+            if (clientRandom == null || serverRandom == null) {\n+                throw new RuntimeException(\"Random nonces not captured\");\n+            }\n+\n+            \/\/ context length must fit in 2 unsigned bytes.\n+            if ((context != null) && (context.length > 0xFFFF)) {\n+                throw new IllegalArgumentException(\n+                        \"Only 16-bit context lengths supported\");\n+            }\n+\n+            \/\/ Perform RFC 5705 calculations using the internal SunJCE PRF.\n+            String prfAlg;\n+            HashAlg hashAlg;\n+            if (protocolVersion == TLS12) {\n+                prfAlg = \"SunTls12Prf\";\n+                hashAlg = cipherSuite.hashAlg;\n+            } else {  \/\/  all other cases\n+                prfAlg = \"SunTlsPrf\";\n+                hashAlg = H_NONE;\n+            }\n+\n+            \/\/ Make a seed with randoms and optional context\n+            \/\/ Note that if context is null, it is omitted from the calc\n+            byte[] clientRandomBytes = clientRandom.randomBytes;\n+            byte[] serverRandomBytes = serverRandom.randomBytes;\n+            byte[] seed = new byte[\n+                    clientRandomBytes.length + serverRandomBytes.length +\n+                            ((context != null) ? (2 + context.length) : 0)];\n+\n+            int pos = 0;\n+            System.arraycopy(\n+                    clientRandomBytes, 0, seed, pos, clientRandomBytes.length);\n+            pos += clientRandomBytes.length;\n+            System.arraycopy(\n+                    serverRandomBytes, 0, seed, pos, serverRandomBytes.length);\n+            pos += serverRandomBytes.length;\n+            if (context != null) {\n+                \/\/ RFC 5705, \"If no context is provided, ...\"\n+                seed[pos++] = (byte) ((context.length >> 8) & 0xFF);\n+                seed[pos++] = (byte) ((context.length) & 0xFF);\n+                System.arraycopy(\n+                        context, 0, seed, pos, context.length);\n+            }\n+\n+            \/\/ Call the PRF function.\n+            try {\n+                @SuppressWarnings(\"deprecation\")\n+                TlsPrfParameterSpec spec = new TlsPrfParameterSpec(\n+                        masterSecret, label, seed, length,\n+                        hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);\n+                KeyGenerator kg = KeyGenerator.getInstance(prfAlg);\n+                kg.init(spec);\n+                SecretKey key = kg.generateKey();\n+                return (deriveKey ? key : key.getEncoded());\n+            } catch (NoSuchAlgorithmException |\n+                     InvalidAlgorithmParameterException e) {\n+                throw new SSLKeyException(\"Could not generate Exporter\/PRF\", e);\n+            }\n+        } else {\n+            \/\/ SSLv3 is vulnerable to a triple handshake attack and can't be\n+            \/\/ mitigated by RFC 7627.  Don't support this or any other\n+            \/\/ unknown protocol.\n+            throw new SSLKeyException(\n+                    \"Exporters not supported in \" + protocolVersion);\n+        }\n+    }\n+\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     *\/\n+    @Override\n+    public SecretKey exportKeyingMaterialKey(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        return (SecretKey)exportKeyingMaterial(true, label, context, length);\n+    }\n+\n+    \/**\n+     * Generate Exported Key Material (EKM) calculated according to the\n+     * algorithms defined in RFCs 5705\/8446.\n+     *\/\n+    @Override\n+    public byte[] exportKeyingMaterialData(\n+            String label, byte[] context, int length) throws SSLKeyException {\n+        return (byte[])exportKeyingMaterial(false, label, context, length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":295,"deletions":13,"binary":false,"changes":308,"status":"modified"},{"patch":"@@ -359,0 +359,3 @@\n+            shc.handshakeSession.setRandoms(shc.clientHelloRandom,\n+                    shc.serverHelloRandom);\n+\n@@ -1132,0 +1135,3 @@\n+            chc.handshakeSession.setRandoms(chc.clientHelloRandom,\n+                    chc.serverHelloRandom);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -279,0 +279,2 @@\n+        putKeyInfo(new TLSKeyInfo(\"TlsExporterMasterSecret\"));\n+        putKeyInfo(new TLSKeyInfo(\"TlsExporterKeyingMaterial\"));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,533 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8341346\n+ * @summary Add support for exporting TLS Keying Material\n+ * @library \/javax\/net\/ssl\/templates \/test\/lib\n+ * @build SSLEngineTemplate\n+ * @run main\/othervm ExportKeyingMaterialTests\n+ *\/\n+\n+import java.security.Security;\n+import java.util.Arrays;\n+import javax.crypto.SecretKey;\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.nio.ByteBuffer;\n+import java.util.Random;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <P>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <P>\n+ * Note, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ * <P>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class ExportKeyingMaterialTests extends SSLEngineTemplate {\n+\n+    private String protocol;\n+    private String ciphersuite;\n+\n+    protected ExportKeyingMaterialTests(String protocol, String ciphersuite)\n+            throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        this.ciphersuite = ciphersuite;\n+    }\n+\n+    \/*\n+     * Configure the engines.\n+     *\/\n+    private void configureEngines(SSLEngine clientEngine,\n+            SSLEngine serverEngine) {\n+\n+        clientEngine.setUseClientMode(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        paramsClient.setProtocols(new String[] { protocol });\n+        paramsClient.setCipherSuites(new String[] { ciphersuite });\n+        clientEngine.setSSLParameters(paramsClient);\n+\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+\n+        \/\/ Get\/set parameters if needed\n+        \/\/\n+        SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        paramsServer.setProtocols(new String[] {\n+                \"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSLv3\"\n+        });\n+        serverEngine.setSSLParameters(paramsServer);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Turn off the disabled Algorithms so we can also test SSLv3\/TLSv1\/etc.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        \/\/ Exercise all of the triggers which capture data\n+        \/\/ in the various key exchange algorithms.\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos for TLSv1.3\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_AES_128_GCM_SHA256\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_AES_256_GCM_SHA384\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.3\", \"TLS_CHACHA20_POLY1305_SHA256\").runTest();\n+\n+        \/\/ Try the various GCM suites for TLSv1.2\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\").runTest();\n+\n+        \/\/ Try one TLSv1.2\/CBC suite just for grins, the triggers are the same.\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.2\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\").runTest();\n+\n+        \/\/ Use appropriate protocol\/ciphersuite combos.  Some of the 1.2\n+        \/\/ suites (e.g. GCM) can't be used in earlier TLS versions.\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1.1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+        new ExportKeyingMaterialTests(\n+                \"TLSv1\", \"TLS_RSA_WITH_AES_256_CBC_SHA\").runTest();\n+\n+        try {\n+            new ExportKeyingMaterialTests(\n+                    \"SSLv3\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\").runTest();\n+            throw new Exception(\"SSLv3 export test should not have passed\");\n+        } catch (SSLException e) {\n+            System.out.println(\"SSLv3 test failed as expected\");\n+        }\n+\n+        System.out.println(\"All tests PASSED\");\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTest() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        configureEngines(clientEngine, serverEngine);\n+\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            log(\"=================\");\n+\n+            \/\/ client wrap\n+            log(\"---Client Wrap---\");\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server wrap\n+            log(\"---Server Wrap---\");\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            \/\/ client unwrap\n+            log(\"---Client Unwrap---\");\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n+\n+            \/\/ server unwrap\n+            log(\"---Server Unwrap---\");\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            logEngineStatus(serverEngine, serverResult);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/\/ After we've transferred all application data between the client\n+            \/\/ and server, we close the clientEngine's outbound stream.\n+            \/\/ This generates a close_notify handshake message, which the\n+            \/\/ server engine receives and responds by closing itself.\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                runExporterTests(\n+                        (ExtendedSSLSession) clientEngine.getSession(),\n+                        (ExtendedSSLSession) serverEngine.getSession());\n+\n+                \/\/ A sanity check to ensure we got what was sent.\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                logEngineStatus(clientEngine);\n+\n+                dataDone = true;\n+                log(\"\\tClosing serverEngine's *OUTBOUND*...\");\n+                serverEngine.closeOutbound();\n+                logEngineStatus(serverEngine);\n+            }\n+        }\n+    }\n+\n+    private static void runExporterTests(\n+            ExtendedSSLSession clientSession,\n+            ExtendedSSLSession serverSession) throws Exception {\n+\n+        SecretKey clientKey, serverKey;\n+\n+        \/\/ Create output arrays\n+        byte[] clientBytes, serverBytes;\n+\n+        \/\/ Create various input arrays and fill with junk.\n+        Random random = new Random();\n+        byte[] bytes = new byte[20];\n+        random.nextBytes(bytes);\n+\n+        \/\/ Slightly change 1 byte in the middle\n+        byte[] bytesDiff = Arrays.copyOf(bytes, bytes.length);\n+        bytesDiff[bytes.length\/2]++;\n+\n+        byte[] bytesDiffSize = new byte[21];\n+        random.nextBytes(bytesDiffSize);\n+\n+        \/\/ Run a bunch of similar derivations using both the Key\/Data methods,\n+        \/\/ exercising the various valid\/invalid combinations.\n+\n+        \/\/ We may need to adjust if it turns out that this is run with\n+        \/\/ non-extractable keys if .equals() doesn't work.\n+\n+        \/\/ Inputs exactly equal.\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\", bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\", bytes, 128);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: Equal inputs but exporters are not equal\");\n+        log(\"Key: Equal inputs test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Equal inputs but exporters are not equal\");\n+        log(\"Data: Equal inputs test passed\");\n+\n+        \/\/ Different labels, now use exportKeyingMaterialData() for coverage\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"goodbye\",\n+                bytes, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different labels but exporters same\");\n+        log(\"Key: Different labels test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"goodbye\",\n+                bytes, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Different labels but exporters same\");\n+        log(\"Data: Different labels test passed\");\n+\n+        \/\/ Different output sizes\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 127);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different output sizes but exporters same\");\n+        log(\"Key: Different output size test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 127);\n+        assertEquals(clientBytes.length, 128, \"client length != 128\");\n+        assertEquals(serverBytes.length, 127, \"server length != 127\");\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Different output sizes but exporters same\");\n+        log(\"Data: Different output size test passed\");\n+\n+        \/\/ Different context values\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytesDiff, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different context but exporters same\");\n+        log(\"Key: Different context test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytesDiff, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Different context but exporters same\");\n+        log(\"Data: Different context test passed\");\n+\n+        \/\/ Different context sizes\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytesDiffSize, 128);\n+        assertNotEquals(clientKey, serverKey,\n+                \"Key: Different context sizes but exporters same\");\n+        log(\"Key: Different context sizes test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytesDiffSize, 128);\n+        assertNotEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Different context sizes but exporters same\");\n+        log(\"Data: Different context sizes test passed\");\n+\n+        \/\/ No context, but otherwise the same\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                null, 128);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                null, 128);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: No context and exporters are not the same\");\n+        log(\"Key: No context test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                null, 128);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                null, 128);\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: No context and exporters are not the same\");\n+        log(\"Data: No context test passed\");\n+\n+        \/\/ Smaller key size\n+        clientKey = clientSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 1);\n+        serverKey = serverSession.exportKeyingMaterialKey(\"hello\",\n+                bytes, 1);\n+        assertEquals(clientKey, serverKey,\n+                \"Key: Smaller key size should be the same\");\n+        log(\"Key: Smaller key size test passed\");\n+\n+        clientBytes = clientSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 1);\n+        serverBytes = serverSession.exportKeyingMaterialData(\"hello\",\n+                bytes, 1);\n+        assertEqualsByteArray(clientBytes, serverBytes,\n+                \"Data: Smaller key size should be the same\");\n+        log(\"Data: Smaller key size test passed\");\n+\n+        \/\/ Check error conditions\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\", bytes, -1);\n+            throw new Exception(\"negative length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"negative length test passed\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"hello\", bytes, 0);\n+            throw new Exception(\"zero length accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"zero length test passed\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(null, bytes, 128);\n+            throw new Exception(\"null label accepted\");\n+        } catch (NullPointerException e) {\n+            log(\"null label test passed\");\n+        }\n+\n+        try {\n+            clientSession.exportKeyingMaterialData(\"\", bytes, 128);\n+            throw new Exception(\"empty label accepted\");\n+        } catch (IllegalArgumentException e) {\n+            log(\"empty label test passed\");\n+        }\n+\n+        switch (clientSession.getProtocol()) {\n+\n+        case \"TLSv1.3\":\n+            \/\/ 249 bytes is the max label we can accept (<7..255>, since\n+            \/\/ \"tls13 \" is added in HkdfLabel)\n+            String longString =\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"12345678901234567890123456789012345678901234567890\" +\n+                    \"1234567890123456789012345678901234567890123456789\";\n+\n+            clientSession.exportKeyingMaterialData(longString, bytes, 128);\n+            log(\"large label test passed in TLSv1.3\");\n+\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString + \"0\", bytes, 128);\n+                throw new Exception(\"too large label accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large label test passed in TLSv1.3\");\n+            }\n+\n+            \/\/ 255 bytes is the max context we can accept (<0..255>)\n+            clientSession.exportKeyingMaterialData(\n+                    longString, new byte[255], 128);\n+            log(\"large context test passed in TLSv1.3\");\n+\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString, new byte[256], 128);\n+                throw new Exception(\"too large context accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large context test passed in TLSv1.3\");\n+            }\n+\n+            \/\/ RFC 5869 says 255*HashLen bytes is the max length we can accept.\n+            \/\/ So we'll choose something a bit bigger than the largest\n+            \/\/ hashLen\/ciphertext which is 384 (48 bytes) so this will always\n+            \/\/ fail.\n+            try {\n+                clientSession.exportKeyingMaterialData(\n+                        longString, new byte[256], 12240);\n+                throw new Exception(\"too large length accepted in TLSv1.3\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"too large length test passed in TLSv1.3\");\n+            }\n+\n+            break;\n+\n+        case \"TLSv1\":\n+        case \"TLSv1.1\":\n+        case \"TLSv1.2\":\n+            \/\/ Don't see a limit of the label.length or output length.\n+\n+            \/\/ Check for large context.length\n+            try {\n+                clientSession.exportKeyingMaterialData(\"hello\",\n+                        new byte[1 << 16], 128);\n+                throw new Exception(\"large context accepted in \" +\n+                        \"TLSv1\/TLSv1.1\/TLSv1.2\");\n+            } catch (IllegalArgumentException e) {\n+                log(\"large context passed in TLSv1\/TLSv1.1\/TLSv1.2\");\n+            }\n+\n+            break;\n+\n+        default:\n+            throw new RuntimeException(\"Unknown protocol: \" + clientSession.getProtocol());\n+        }\n+\n+    }\n+\n+    static boolean isOpen(SSLEngine engine) {\n+        return (!engine.isOutboundDone() || !engine.isInboundDone());\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    \/\/ Simple check to make sure everything came across as expected.\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/ExtendedSSLSession\/ExportKeyingMaterialTests.java","additions":533,"deletions":0,"binary":false,"changes":533,"status":"added"}]}