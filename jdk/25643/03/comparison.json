{"files":[{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This class provides a {@link #render} method that can be used to simplify generating\n+ * source code when using the {@link TestFramework} (also known as IR Framework) to run\n+ * a list of tests.\n+ *\n+ * <p>\n+ * The idea is that the user only has to generate the code for the individual tests,\n+ * and can then pass the corresponding list of {@link TemplateToken}s to this\n+ * provided {@link #render} method which generates the surrounding class and the main\n+ * method that invokes the {@link TestFramework}, so that all the generated tests\n+ * are run.\n+ *\/\n+public final class TestFrameworkClass {\n+\n+    \/\/ Ensure there can be no instance, and we do not have to document the constructor.\n+    private TestFrameworkClass() {}\n+\n+    \/**\n+     * This method renders a list of {@code testTemplateTokens} into the body of a class\n+     * and generates a {@code main} method which launches the {@link TestFramework}\n+     * to run the generated tests.\n+     *\n+     * <p>\n+     * The generated {@code main} method is to be invoked with a {@code vmFlags} argument,\n+     * which must be a {@link String[]}, specifying the VM flags for the Test VM, in which\n+     * the tests will be run. Thus, one can generate the test class once, and invoke its\n+     * {@code main} method multiple times, each time with a different set of VM flags.\n+     *\n+     * <p>\n+     * The internal {@link Template} sets the {@link Hooks#CLASS_HOOK} for the scope of\n+     * all test methods.\n+     *\n+     * @param packageName The package name of the test class.\n+     * @param className The name of the test class.\n+     * @param imports A set of imports.\n+     * @param classpath The classpath from {@link CompileFramework#getEscapedClassPathOfCompiledClasses},\n+     *                  so that the Test VM has access to the class files that are compiled from the\n+     *                  generated source code.\n+     * @param testTemplateTokens The list of tests to be generated into the test class.\n+     *                           Every test must be annotated with {@code @Test}, so that\n+     *                           the {@link TestFramework} can later find and run them.\n+     * @return The generated source code of the test class as a {@link String}.\n+     *\/\n+    public static String render(final String packageName,\n+                                final String className,\n+                                final Set<String> imports,\n+                                final String classpath,\n+                                final List<TemplateToken> testTemplateTokens) {\n+        var template = Template.make(() -> body(\n+            let(\"packageName\", packageName),\n+            let(\"className\", className),\n+            let(\"classpath\", classpath),\n+            \"\"\"\n+            package #packageName;\n+            \/\/ --- IMPORTS start ---\n+            import compiler.lib.ir_framework.*;\n+            \"\"\",\n+            imports.stream().map(i -> \"import \" + i + \";\\n\").toList(),\n+            \"\"\"\n+            \/\/ --- IMPORTS end   ---\n+            public class #className {\n+            \/\/ --- CLASS_HOOK insertions start ---\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+            \/\/ --- CLASS_HOOK insertions end   ---\n+                public static void main(String[] vmFlags) {\n+                    TestFramework framework = new TestFramework(#className.class);\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.addFlags(vmFlags);\n+                    framework.start();\n+                }\n+            \/\/ --- LIST OF TESTS start ---\n+            \"\"\",\n+            testTemplateTokens\n+            ),\n+            \"\"\"\n+            \/\/ --- LIST OF TESTS end   ---\n+            }\n+            \"\"\"\n+        ));\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestFrameworkClass.TEMPLATE which allows generating many tests and running them with the IR TestFramework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver template_framework.examples.TestWithTestFrameworkClass\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+\n+import compiler.lib.generators.Generators;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * This is a basic IR verification test, in combination with Generators for random input generation\n+ * and Verify for output verification.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestWithTestFrameworkClass {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnterTest.main(new String[] {});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+\n+        \/\/ We can also pass VM flags for the Test VM.\n+        \/\/ p.xyz.InnterTest.main(new String[] {\"-Xbatch\"});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {\"-Xbatch\"}});\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ A simple template that adds a comment.\n+        var commentTemplate = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Comment inserted from test method to class hook.\n+            \"\"\"\n+        ));\n+\n+        \/\/ We define a Test-Template:\n+        \/\/ - static fields for inputs: INPUT_A and INPUT_B\n+        \/\/   - Data generated with Generators and hashtag replacement #con1.\n+        \/\/ - GOLD value precomputed with dedicated call to test.\n+        \/\/   - This ensures that the GOLD value is computed in the interpreter\n+        \/\/     most likely, since the test method is not yet compiled.\n+        \/\/     This allows us later to compare to the results of the compiled\n+        \/\/     code.\n+        \/\/     The input data is cloned, so that the original INPUT_A is never\n+        \/\/     modified and can serve as identical input in later calls to test.\n+        \/\/ - In the Setup method, we clone the input data, since the input data\n+        \/\/   could be modified inside the test method.\n+        \/\/ - The test method makes use of hashtag replacements (#con2 and #op).\n+        \/\/ - The Check method verifies the results of the test method with the\n+        \/\/   GOLD value.\n+        var testTemplate = Template.make(\"op\", (String op) -> body(\n+            let(\"size\", Generators.G.safeRestrict(Generators.G.ints(), 10_000, 20_000).next()),\n+            let(\"con1\", Generators.G.ints().next()),\n+            let(\"con2\", Generators.G.safeRestrict(Generators.G.ints(), 1, Integer.MAX_VALUE).next()),\n+            \"\"\"\n+            \/\/ --- $test start ---\n+            \/\/ $test with size=#size and op=#op\n+            private static int[] $INPUT_A = new int[#size];\n+            static {\n+                Generators.G.fill(Generators.G.ints(), $INPUT_A);\n+            }\n+            private static int $INPUT_B = #con1;\n+            private static Object $GOLD = $test($INPUT_A.clone(), $INPUT_B);\n+\n+            @Setup\n+            public static Object[] $setup() {\n+                \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+                return new Object[] {$INPUT_A.clone(), $INPUT_B};\n+            }\n+\n+            @Test\n+            @Arguments(setup = \"$setup\")\n+            public static Object $test(int[] a, int b) {\n+                for (int i = 0; i < a.length; i++) {\n+                    int con = #con2;\n+                    a[i] = (a[i] * con) #op b;\n+                }\n+                return a;\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(Object result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \/\/ --- $test end   ---\n+            \"\"\",\n+            \/\/ Good to know: we can insert to the class hook, which is set for the\n+            \/\/ TestFrameworkClass scope:\n+            Hooks.CLASS_HOOK.insert(commentTemplate.asToken())\n+        ));\n+\n+        \/\/ Create a test for each operator.\n+        List<String> ops = List.of(\"+\", \"-\", \"*\", \"&\", \"|\");\n+        List<TemplateToken> testTemplateTokens = ops.stream().map(testTemplate::asToken).toList();\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"p.xyz\", \"InnerTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}