{"files":[{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This class provides a {@link #TEMPLATE} that can be used to simplify generating\n+ * source code when using the {@link TestFramework} (also known as IR Framework) to run a list of tests.\n+ *\n+ * <p>\n+ * The idea is that the user only has to generate the code for the individual tests,\n+ * and can then pass the corresponding list of {@link TemplateToken}s to this\n+ * provided {@link #TEMPLATE} which generates the surrounding class and the main\n+ * method that invokes the {@link TestFramework}, so that all the generated tests\n+ * are run.\n+ *\/\n+public final class TestFrameworkClass {\n+\n+    \/\/ Ensure there can be no instance, and we do not have to document the constructor.\n+    private TestFrameworkClass() {}\n+\n+    \/**\n+     * To use the {@link TestFrameworkClass#TEMPLATE}, the user must specify the\n+     * {@link #packageName} and {@link #className}, as well as a list of {@link #imports}\n+     * and the {@link #classpath} from {@link CompileFramework#getEscapedClassPathOfCompiledClasses},\n+     * so that the Test VM has access to the class files that are compiled from the generated\n+     * source code.\n+     *\n+     * @param packageName The package name of the test class.\n+     * @param className The name of the test class.\n+     * @param imports A list of imports.\n+     * @param classpath The classpath from {@link CompileFramework#getEscapedClassPathOfCompiledClasses},\n+     *                  so that the Test VM has access to the class files that are compiled from the\n+     *                  generated source code.\n+     *\/\n+    public record Info(String packageName, String className, List<String> imports, String classpath) {};\n+\n+    \/**\n+     * This {@link Template} simplifies generating source code when using the {@link TestFramework}\n+     * (also known as IR Framework) to run a list of tests.\n+     *\n+     * <p>\n+     * The {@code info} argument encapsulates the context information for the\n+     * generated class. The {@code testTemplateTokens} is a list of {@link TemplateToken}s,\n+     * which represent the tests that are to be generated inside this test class.\n+     *\n+     * <p>\n+     * The {@code main} method is to be invoked with a {@code vmFlags} argument, where\n+     * the Test VM flags can be specified with which the tests are to be run.\n+     *\/\n+    public static final Template.TwoArgs<Info, List<TemplateToken>> TEMPLATE =\n+        Template.make(\"info\", \"testTemplateTokens\", (Info info, List<TemplateToken> testTemplateTokens) -> body(\n+            let(\"classpath\", info.classpath),\n+            let(\"packageName\", info.packageName),\n+            let(\"className\", info.className),\n+            \"\"\"\n+            package #packageName;\n+            \/\/ --- IMPORTS start ---\n+            import compiler.lib.ir_framework.*;\n+            \"\"\",\n+            info.imports.stream().map(i -> \"import \" + i + \";\\n\").toList(),\n+            \"\"\"\n+            \/\/ --- IMPORTS end   ---\n+            public class #className {\n+            \/\/ --- CLASS_HOOK insertions start ---\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+            \/\/ --- CLASS_HOOK insertions end   ---\n+                public static void main(String[] vmFlags) {\n+                    TestFramework framework = new TestFramework(#className.class);\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.addFlags(vmFlags);\n+                    framework.start();\n+                }\n+            \/\/ --- LIST OF TESTS start ---\n+            \"\"\",\n+            testTemplateTokens\n+            ),\n+            \"\"\"\n+            \/\/ --- LIST OF TESTS end   ---\n+            }\n+            \"\"\"\n+        ));\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestFrameworkClass.TEMPLATE which allows generating many tests and running them with the IR TestFramework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver template_framework.examples.TestWithTestFrameworkClass\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+\n+import compiler.lib.generators.Generators;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * This is a basic IR verification test, in combination with Generators for random input generation\n+ * and Verify for output verification.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestWithTestFrameworkClass {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnterTest.main(new String[] {});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+\n+        \/\/ We can also pass VM flags for the Test VM.\n+        \/\/ p.xyz.InnterTest.main(new String[] {\"-Xbatch\"});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {\"-Xbatch\"}});\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Create the info required for the test class.\n+        \/\/ It is imporant that we pass the classpath to the Test-VM, so that it has access\n+        \/\/ to all compiled classes.\n+        TestFrameworkClass.Info info = new TestFrameworkClass.Info(\n+            \/\/ package and class name.\n+            \"p.xyz\", \"InnerTest\",\n+            \/\/ List of imports. Duplicates are permitted.\n+            List.of(\"compiler.lib.generators.*\",\n+                    \"compiler.lib.ir_framework.*\",\n+                    \"compiler.lib.verify.*\",\n+                    \"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses()\n+        );\n+\n+        \/\/ We define a Test-Template:\n+        \/\/ - static fields for inputs: INPUT_A and INPUT_B\n+        \/\/   - Data generated with Generators and hashtag replacement #con1.\n+        \/\/ - GOLD value precomputed with dedicated call to test.\n+        \/\/   - This ensures that the GOLD value is computed in the interpreter\n+        \/\/     most likely, since the test method is not yet compiled.\n+        \/\/     This allows us later to compare to the results of the compiled\n+        \/\/     code.\n+        \/\/     The input data is cloned, so that the original INPUT_A is never\n+        \/\/     modified and can serve as identical input in later calls to test.\n+        \/\/ - In the Setup method, we clone the input data, since the input data\n+        \/\/   could be modified inside the test method.\n+        \/\/ - The test method makes use of hashtag replacements (#con2 and #op).\n+        \/\/ - The Check method verifies the results of the test method with the\n+        \/\/   GOLD value.\n+        var testTemplate = Template.make(\"op\", (String op) -> body(\n+            let(\"size\", Generators.G.safeRestrict(Generators.G.ints(), 10_000, 20_000).next()),\n+            let(\"con1\", Generators.G.ints().next()),\n+            let(\"con2\", Generators.G.safeRestrict(Generators.G.ints(), 1, Integer.MAX_VALUE).next()),\n+            \"\"\"\n+            \/\/ --- $test start ---\n+            \/\/ $test with size=#size and op=#op\n+            private static int[] $INPUT_A = new int[#size];\n+            static {\n+                Generators.G.fill(Generators.G.ints(), $INPUT_A);\n+            }\n+            private static int $INPUT_B = #con1;\n+            private static Object $GOLD = $test($INPUT_A.clone(), $INPUT_B);\n+\n+            @Setup\n+            public static Object[] $setup() {\n+                \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+                return new Object[] {$INPUT_A.clone(), $INPUT_B};\n+            }\n+\n+            @Test\n+            @Arguments(setup = \"$setup\")\n+            public static Object $test(int[] a, int b) {\n+                for (int i = 0; i < a.length; i++) {\n+                    int con = #con2;\n+                    a[i] = (a[i] * con) #op b;\n+                }\n+                return a;\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(Object result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \/\/ --- $test end   ---\n+            \"\"\"\n+        ));\n+\n+        \/\/ From a list of operators, create a list of templateTokens with applied arguments.\n+        List<String> ops = List.of(\"+\", \"-\", \"*\", \"&\", \"|\");\n+        List<TemplateToken> templateTokens = ops.stream().map(op -> (TemplateToken)testTemplate.asToken(op)).toList();\n+\n+        \/\/ Create the test class, which runs all templateTokens.\n+        return TestFrameworkClass.TEMPLATE.render(info, templateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}