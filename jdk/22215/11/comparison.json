{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,1 @@\n+        jdk.crypto.cryptoki, \/\/ participates in preview features\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.internal.javac.ParticipatesInPreview;\n+\n@@ -34,0 +36,1 @@\n+@ParticipatesInPreview\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import javax.crypto.KDFParameters;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static sun.security.pkcs11.TemplateManager.*;\n+import sun.security.pkcs11.wrapper.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+\n+final class P11HKDF extends KDFSpi {\n+    private final Token token;\n+    private final P11SecretKeyFactory.HKDFKeyInfo svcKi;\n+    private final long hmacMechanism;\n+    private static final SecretKey EMPTY_KEY = new SecretKey() {\n+        @Override\n+        public String getAlgorithm() {\n+            return \"Generic\";\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return new byte[0];\n+        }\n+    };\n+\n+    private static KDFParameters requireNull(KDFParameters kdfParameters,\n+            String message) throws InvalidAlgorithmParameterException {\n+        if (kdfParameters != null) {\n+            throw new InvalidAlgorithmParameterException(message);\n+        }\n+        return null;\n+    }\n+\n+    P11HKDF(Token token, String algorithm, long hmacMechanism,\n+            KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+        super(requireNull(kdfParameters,\n+                algorithm + \" does not support parameters\"));\n+        this.token = token;\n+        this.hmacMechanism = hmacMechanism;\n+        this.svcKi = P11SecretKeyFactory.getHKDFKeyInfo(algorithm);\n+        assert this.svcKi != null : \"Unsupported HKDF algorithm \" + algorithm;\n+    }\n+\n+    @Override\n+    protected KDFParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg,\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException,\n+            NoSuchAlgorithmException {\n+        if (alg == null) {\n+            throw new NullPointerException(\"the algorithm for the \" +\n+                    \"SecretKey return value must not be null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"the algorithm for the \" +\n+                    \"SecretKey return value must not be empty\");\n+        }\n+        return derive(alg, derivationSpec, SecretKey.class);\n+    }\n+\n+    @Override\n+    protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+        return derive(\"Generic\", derivationSpec, byte[].class);\n+    }\n+\n+    private <T> T derive(String alg, AlgorithmParameterSpec derivationSpec,\n+            Class<T> retType) throws InvalidAlgorithmParameterException {\n+        SecretKey baseKey;\n+        SecretKey salt = EMPTY_KEY;\n+        byte[] info = null;\n+        int outLen;\n+        boolean isExtract = false, isExpand = false;\n+        boolean isData = retType == byte[].class;\n+        assert isData || retType == SecretKey.class : \"Invalid return type.\";\n+        assert alg != null : \"The algorithm cannot be null.\";\n+\n+        switch (derivationSpec) {\n+            case HKDFParameterSpec.Extract anExtract -> {\n+                isExtract = true;\n+                baseKey = consolidateKeyMaterial(anExtract.ikms());\n+                salt = consolidateKeyMaterial(anExtract.salts());\n+                outLen = svcKi.prkLen \/ 8;\n+                assert outLen * 8 == svcKi.prkLen : \"Invalid PRK length.\";\n+            }\n+            case HKDFParameterSpec.Expand anExpand -> {\n+                isExpand = true;\n+                baseKey = anExpand.prk();\n+                outLen = anExpand.length();\n+                info = anExpand.info();\n+            }\n+            case HKDFParameterSpec.ExtractThenExpand anExtractExpand -> {\n+                isExtract = true;\n+                isExpand = true;\n+                baseKey = consolidateKeyMaterial(anExtractExpand.ikms());\n+                salt = consolidateKeyMaterial(anExtractExpand.salts());\n+                outLen = anExtractExpand.length();\n+                info = anExtractExpand.info();\n+            }\n+            case null -> throw new NullPointerException(\n+                    \"derivationSpec must be a \" + HKDFParameterSpec.class +\n+                    \" instance, instead of null.\");\n+            default -> throw new InvalidAlgorithmParameterException(\n+                    \"derivationSpec must be a \" + HKDFParameterSpec.class +\n+                    \" instance, instead of \" + derivationSpec.getClass());\n+        }\n+\n+        P11Key p11BaseKey = convertKey(baseKey, (isExtract ? \"IKM\" : \"PRK\") +\n+                \" could not be converted to a token key for HKDF derivation.\");\n+\n+        long saltType = CKF_HKDF_SALT_NULL;\n+        byte[] saltBytes = null;\n+        P11Key p11SaltKey = null;\n+        if (salt instanceof SecretKeySpec) {\n+            saltType = CKF_HKDF_SALT_DATA;\n+            saltBytes = salt.getEncoded();\n+        } else if (salt != EMPTY_KEY) {\n+            \/\/ consolidateKeyMaterial returns a salt from the token.\n+            saltType = CKF_HKDF_SALT_KEY;\n+            p11SaltKey = (P11Key.P11SecretKey) salt;\n+            assert p11SaltKey.token == token : \"salt must be from the same \" +\n+                    \"token as service.\";\n+        }\n+\n+        P11SecretKeyFactory.KeyInfo ki = P11SecretKeyFactory.getKeyInfo(alg);\n+        if (ki == null) {\n+            throw new InvalidAlgorithmParameterException(\"A PKCS #11 key \" +\n+                    \"type (CKK_*) was not found for a key of the algorithm '\" +\n+                    alg + \"'.\");\n+        }\n+        long derivedKeyType = ki.keyType;\n+        long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n+        CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n+                new CK_ATTRIBUTE(CKA_KEY_TYPE, derivedKeyType),\n+                new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n+        };\n+        Session session = null;\n+        long baseKeyID = p11BaseKey.getKeyID();\n+        try {\n+            session = token.getOpSession();\n+            CK_HKDF_PARAMS params = new CK_HKDF_PARAMS(isExtract, isExpand,\n+                    hmacMechanism, saltType, saltBytes, p11SaltKey != null ?\n+                    p11SaltKey.getKeyID() : 0L, info);\n+            attrs = token.getAttributes(O_GENERATE, derivedKeyClass,\n+                    derivedKeyType, attrs);\n+            long derivedObjectID = token.p11.C_DeriveKey(session.id(),\n+                    new CK_MECHANISM(isData ? CKM_HKDF_DATA : CKM_HKDF_DERIVE,\n+                    params), baseKeyID, attrs);\n+            Object ret;\n+            if (isData) {\n+                try {\n+                    CK_ATTRIBUTE[] dataAttr = new CK_ATTRIBUTE[] {\n+                            new CK_ATTRIBUTE(CKA_VALUE)\n+                    };\n+                    token.p11.C_GetAttributeValue(session.id(), derivedObjectID,\n+                            dataAttr);\n+                    ret = dataAttr[0].getByteArray();\n+                } finally {\n+                    token.p11.C_DestroyObject(session.id(), derivedObjectID);\n+                }\n+            } else {\n+                ret = P11Key.secretKey(session, derivedObjectID, alg,\n+                        outLen * 8, null);\n+            }\n+            return retType.cast(ret);\n+        } catch (PKCS11Exception e) {\n+            throw new ProviderException(\"HKDF derivation for algorithm '\" +\n+                    alg + \"' failed.\", e);\n+        } finally {\n+            if (p11SaltKey != null) {\n+                p11SaltKey.releaseKeyID();\n+            }\n+            p11BaseKey.releaseKeyID();\n+            token.releaseSession(session);\n+        }\n+    }\n+\n+    private P11Key.P11SecretKey convertKey(SecretKey key, String errorMessage) {\n+        try {\n+            return (P11Key.P11SecretKey) P11SecretKeyFactory.convertKey(token,\n+                    key, null);\n+        } catch (InvalidKeyException ike) {\n+            throw new ProviderException(errorMessage, ike);\n+        }\n+    }\n+\n+    private abstract sealed class KeyMaterialMerger permits\n+            AnyKeyMaterialMerger, KeyKeyMaterialMerger, DataKeyMaterialMerger {\n+\n+        final KeyMaterialMerger merge(SecretKey nextKeyMaterial) {\n+            if (nextKeyMaterial instanceof SecretKeySpec) {\n+                return merge(nextKeyMaterial.getEncoded());\n+            } else {\n+                return merge(convertKey(nextKeyMaterial,\n+                        \"Failure when merging key material.\"));\n+            }\n+        }\n+\n+        abstract SecretKey getKeyMaterial();\n+\n+        protected abstract KeyMaterialMerger merge(byte[] nextKeyMaterial);\n+\n+        protected abstract KeyMaterialMerger merge(\n+                P11Key.P11SecretKey nextKeyMaterial);\n+\n+        protected final P11Key.P11SecretKey p11Merge(\n+                P11Key.P11SecretKey baseKey, CK_MECHANISM ckMech,\n+                int derivedKeyLen) {\n+            if (!token.provider.config.isEnabled(ckMech.mechanism)) {\n+                throw new ProviderException(\"Mechanism \" +\n+                        Functions.getMechanismName(ckMech.mechanism) +\n+                        \" is either not supported in the token or \" +\n+                        \"disabled through 'disabledMechanisms' in \" +\n+                        token.provider.getName() + \" configuration.\");\n+            }\n+            Session session = null;\n+            long baseKeyID = baseKey.getKeyID();\n+            try {\n+                session = token.getOpSession();\n+                CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_GENERIC_SECRET),\n+                };\n+                long derivedKeyID = token.p11.C_DeriveKey(session.id(), ckMech,\n+                        baseKeyID, attrs);\n+                return (P11Key.P11SecretKey) P11Key.secretKey(session,\n+                        derivedKeyID, \"Generic\", derivedKeyLen * 8, null);\n+            } catch (PKCS11Exception e) {\n+                throw new ProviderException(\"Failure when merging key \" +\n+                        \"material.\", e);\n+            } finally {\n+                baseKey.releaseKeyID();\n+                token.releaseSession(session);\n+            }\n+        }\n+    }\n+\n+    private final class AnyKeyMaterialMerger extends KeyMaterialMerger {\n+\n+        protected KeyMaterialMerger merge(byte[] nextKeyMaterial) {\n+            return P11HKDF.this.new DataKeyMaterialMerger(nextKeyMaterial);\n+        }\n+\n+        protected KeyMaterialMerger merge(P11Key.P11SecretKey nextKeyMaterial) {\n+            return P11HKDF.this.new KeyKeyMaterialMerger(nextKeyMaterial);\n+        }\n+\n+        SecretKey getKeyMaterial() {\n+            return EMPTY_KEY;\n+        }\n+    }\n+\n+    private final class KeyKeyMaterialMerger extends KeyMaterialMerger {\n+        private P11Key.P11SecretKey keyMaterial;\n+\n+        KeyKeyMaterialMerger(P11Key.P11SecretKey keyMaterial) {\n+            this.keyMaterial = keyMaterial;\n+        }\n+\n+        protected KeyMaterialMerger merge(byte[] nextKeyMaterial) {\n+            keyMaterial = p11Merge(keyMaterial,\n+                    new CK_MECHANISM(CKM_CONCATENATE_BASE_AND_DATA,\n+                            new CK_KEY_DERIVATION_STRING_DATA(nextKeyMaterial)),\n+                    keyMaterial.keyLength + nextKeyMaterial.length);\n+            return this;\n+        }\n+\n+        protected KeyMaterialMerger merge(P11Key.P11SecretKey nextKeyMaterial) {\n+            try {\n+                keyMaterial = p11Merge(keyMaterial,\n+                        new CK_MECHANISM(CKM_CONCATENATE_BASE_AND_KEY,\n+                                nextKeyMaterial.getKeyID()),\n+                        keyMaterial.keyLength + nextKeyMaterial.keyLength);\n+            } finally {\n+                nextKeyMaterial.releaseKeyID();\n+            }\n+            return this;\n+        }\n+\n+        SecretKey getKeyMaterial() {\n+            return keyMaterial;\n+        }\n+    }\n+\n+    private final class DataKeyMaterialMerger extends KeyMaterialMerger {\n+        private byte[] keyMaterial;\n+\n+        DataKeyMaterialMerger(byte[] keyMaterial) {\n+            this.keyMaterial = keyMaterial;\n+        }\n+\n+        protected KeyMaterialMerger merge(byte[] nextKeyMaterial) {\n+            keyMaterial = Arrays.copyOf(keyMaterial,\n+                    keyMaterial.length + nextKeyMaterial.length);\n+            System.arraycopy(nextKeyMaterial, 0, keyMaterial,\n+                    keyMaterial.length - nextKeyMaterial.length,\n+                    nextKeyMaterial.length);\n+            return this;\n+        }\n+\n+        protected KeyMaterialMerger merge(P11Key.P11SecretKey nextKeyMaterial) {\n+            return P11HKDF.this.new KeyKeyMaterialMerger(p11Merge(\n+                    nextKeyMaterial, new CK_MECHANISM(\n+                            CKM_CONCATENATE_DATA_AND_BASE,\n+                            new CK_KEY_DERIVATION_STRING_DATA(keyMaterial)),\n+                    keyMaterial.length + nextKeyMaterial.keyLength));\n+        }\n+\n+        SecretKey getKeyMaterial() {\n+            return new SecretKeySpec(keyMaterial, \"Generic\");\n+        }\n+    }\n+\n+    private SecretKey consolidateKeyMaterial(List<SecretKey> keys) {\n+        KeyMaterialMerger keyMerger = P11HKDF.this.new AnyKeyMaterialMerger();\n+        for (SecretKey key : keys) {\n+            keyMerger = keyMerger.merge(key);\n+        }\n+        return keyMerger.getKeyMaterial();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11HKDF.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,1 +449,1 @@\n-    private static class P11SecretKey extends P11Key implements SecretKey {\n+    static class P11SecretKey extends P11Key implements SecretKey {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,1 @@\n-    P11Mac(Token token, String algorithm, long mechanism)\n-            throws PKCS11Exception {\n+    P11Mac(Token token, String algorithm, long mechanism) {\n@@ -99,11 +98,7 @@\n-        Long params = null;\n-        macLength = switch ((int) mechanism) {\n-            case (int) CKM_MD5_HMAC -> 16;\n-            case (int) CKM_SHA_1_HMAC -> 20;\n-            case (int) CKM_SHA224_HMAC, (int) CKM_SHA512_224_HMAC, (int) CKM_SHA3_224_HMAC -> 28;\n-            case (int) CKM_SHA256_HMAC, (int) CKM_SHA512_256_HMAC, (int) CKM_SHA3_256_HMAC -> 32;\n-            case (int) CKM_SHA384_HMAC, (int) CKM_SHA3_384_HMAC -> 48;\n-            case (int) CKM_SHA512_HMAC, (int) CKM_SHA3_512_HMAC -> 64;\n-            case (int) CKM_SSL3_MD5_MAC -> {\n-                params = Long.valueOf(16);\n-                yield 16;\n+        if (svcPbeKi != null) {\n+            macLength = svcPbeKi.keyLen \/ 8;\n+        } else {\n+            P11SecretKeyFactory.HMACKeyInfo svcKi =\n+                    P11SecretKeyFactory.getHMACKeyInfo(algorithm);\n+            if (svcKi == null) {\n+                throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n@@ -111,7 +106,5 @@\n-            case (int) CKM_SSL3_SHA1_MAC -> {\n-                params = Long.valueOf(20);\n-                yield 20;\n-            }\n-            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n-        };\n-        ckMechanism = new CK_MECHANISM(mechanism, params);\n+            macLength = svcKi.keyLen \/ 8;\n+        }\n+        ckMechanism = new CK_MECHANISM(mechanism, mechanism == CKM_SSL3_MD5_MAC\n+                || mechanism == CKM_SSL3_SHA1_MAC ? Long.valueOf(macLength) :\n+                null);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,0 @@\n-    private static final KeyInfo HMAC = new KeyInfo(\"HMAC\", PCKK_HMAC);\n-    private static final KeyInfo SSLMAC = new KeyInfo(\"SSLMAC\", PCKK_SSLMAC);\n@@ -78,7 +76,0 @@\n-            if (ki == null) {\n-                if (algoUpper.startsWith(\"HMAC\")) {\n-                    return HMAC;\n-                } else if (algoUpper.startsWith(\"SSLMAC\")) {\n-                    return SSLMAC;\n-                }\n-            }\n@@ -96,0 +87,14 @@\n+    static HMACKeyInfo getHMACKeyInfo(String algo) {\n+        if (getKeyInfo(algo) instanceof HMACKeyInfo hmacKi) {\n+            return hmacKi;\n+        }\n+        return null;\n+    }\n+\n+    static HKDFKeyInfo getHKDFKeyInfo(String algo) {\n+        if (getKeyInfo(algo) instanceof HKDFKeyInfo hkdfKi) {\n+            return hkdfKi;\n+        }\n+        return null;\n+    }\n+\n@@ -101,1 +106,1 @@\n-    static sealed class KeyInfo permits PBEKeyInfo {\n+    static sealed class KeyInfo permits PBEKeyInfo, HMACKeyInfo, HKDFKeyInfo {\n@@ -132,0 +137,21 @@\n+    static final class HMACKeyInfo extends KeyInfo {\n+        public final long mech;\n+        public final int keyLen;\n+\n+        HMACKeyInfo(String algo, long mech, int keyLen) {\n+            super(algo, CKK_GENERIC_SECRET);\n+            this.mech = mech;\n+            this.keyLen = keyLen;\n+        }\n+    }\n+\n+    static final class HKDFKeyInfo extends KeyInfo {\n+        public static final long UNKNOWN_KEY_TYPE = -1;\n+        public final int prkLen;\n+\n+        HKDFKeyInfo(String algo, HMACKeyInfo hmacKi) {\n+            super(algo, UNKNOWN_KEY_TYPE);\n+            prkLen = hmacKi.keyLen;\n+        }\n+    }\n+\n@@ -172,1 +198,1 @@\n-        P12MacPBEKeyInfo(String algo, long kdfMech, int keyLen) {\n+        P12MacPBEKeyInfo(String algo, long kdfMech, HMACKeyInfo hmacKi) {\n@@ -174,1 +200,1 @@\n-                    CKK_GENERIC_SECRET, keyLen, attr);\n+                    CKK_GENERIC_SECRET, hmacKi.keyLen, attr);\n@@ -198,0 +224,30 @@\n+        HMACKeyInfo hmacSHA1 =\n+                new HMACKeyInfo(\"HmacSHA1\", CKM_SHA_1_HMAC, 160);\n+        HMACKeyInfo hmacSHA224 =\n+                new HMACKeyInfo(\"HmacSHA224\", CKM_SHA224_HMAC, 224);\n+        HMACKeyInfo hmacSHA256 =\n+                new HMACKeyInfo(\"HmacSHA256\", CKM_SHA256_HMAC, 256);\n+        HMACKeyInfo hmacSHA384 =\n+                new HMACKeyInfo(\"HmacSHA384\", CKM_SHA384_HMAC, 384);\n+        HMACKeyInfo hmacSHA512 =\n+                new HMACKeyInfo(\"HmacSHA512\", CKM_SHA512_HMAC, 512);\n+\n+        putKeyInfo(hmacSHA1);\n+        putKeyInfo(hmacSHA224);\n+        putKeyInfo(hmacSHA256);\n+        putKeyInfo(hmacSHA384);\n+        putKeyInfo(hmacSHA512);\n+        putKeyInfo(new HMACKeyInfo(\"HmacMD5\", CKM_MD5_HMAC, 128));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA512\/224\", CKM_SHA512_224_HMAC, 224));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA3-224\", CKM_SHA3_224_HMAC, 224));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA512\/256\", CKM_SHA512_256_HMAC, 256));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA3-256\", CKM_SHA3_256_HMAC, 256));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA3-384\", CKM_SHA3_384_HMAC, 384));\n+        putKeyInfo(new HMACKeyInfo(\"HmacSHA3-512\", CKM_SHA3_512_HMAC, 512));\n+        putKeyInfo(new HMACKeyInfo(\"SslMacMD5\", CKM_SSL3_MD5_MAC, 128));\n+        putKeyInfo(new HMACKeyInfo(\"SslMacSHA1\", CKM_SSL3_SHA1_MAC, 160));\n+\n+        putKeyInfo(new HKDFKeyInfo(\"HKDF-SHA256\", hmacSHA256));\n+        putKeyInfo(new HKDFKeyInfo(\"HKDF-SHA384\", hmacSHA384));\n+        putKeyInfo(new HKDFKeyInfo(\"HKDF-SHA512\", hmacSHA512));\n+\n@@ -231,1 +287,1 @@\n-                CKM_PBA_SHA1_WITH_SHA1_HMAC, 160));\n+                CKM_PBA_SHA1_WITH_SHA1_HMAC, hmacSHA1));\n@@ -233,1 +289,1 @@\n-                CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN, 224));\n+                CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN, hmacSHA224));\n@@ -235,1 +291,1 @@\n-                CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN, 256));\n+                CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN, hmacSHA256));\n@@ -237,1 +293,1 @@\n-                CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN, 384));\n+                CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN, hmacSHA384));\n@@ -239,1 +295,1 @@\n-                CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN, 512));\n+                CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN, hmacSHA512));\n@@ -290,2 +346,1 @@\n-        if (svcAlgo != keyAlgo &&\n-                si.keyType != PCKK_HMAC && si.keyType != PCKK_SSLMAC) {\n+        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo)) {\n@@ -351,2 +406,1 @@\n-                p11Key = createKey(token, encoded, svcAlgo, si.keyType,\n-                        extraAttrs);\n+                p11Key = createKey(token, encoded, svcAlgo, si, extraAttrs);\n@@ -489,1 +543,1 @@\n-            String algorithm, long keyType, CK_ATTRIBUTE[] extraAttrs)\n+            String algorithm, KeyInfo ki, CK_ATTRIBUTE[] extraAttrs)\n@@ -493,0 +547,1 @@\n+        long keyType = ki.keyType;\n@@ -523,7 +578,0 @@\n-                case (int) PCKK_SSLMAC, (int) PCKK_HMAC -> {\n-                    if (n == 0) {\n-                        throw new InvalidKeyException\n-                                (\"MAC keys must not be empty\");\n-                    }\n-                    keyType = CKK_GENERIC_SECRET;\n-                }\n@@ -533,0 +581,3 @@\n+            if (ki instanceof HMACKeyInfo && n == 0) {\n+                throw new InvalidKeyException(\"MAC keys must not be empty\");\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":81,"deletions":30,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.crypto.KDFParameters;\n@@ -529,0 +530,2 @@\n+    private static final String KDF  = \"KDF\";\n+\n@@ -549,0 +552,1 @@\n+        String P11HKDF             = \"sun.security.pkcs11.P11HKDF\";\n@@ -732,0 +736,2 @@\n+        d(SKF, \"Generic\",       P11SecretKeyFactory,\n+                m(CKM_GENERIC_SECRET_KEY_GEN));\n@@ -1076,0 +1082,7 @@\n+\n+        d(KDF, \"HKDF-SHA256\", P11HKDF, m(CKM_SHA256_HMAC),\n+                m(CKM_HKDF_DERIVE, CKM_HKDF_DATA));\n+        d(KDF, \"HKDF-SHA384\", P11HKDF, m(CKM_SHA384_HMAC),\n+                m(CKM_HKDF_DERIVE, CKM_HKDF_DATA));\n+        d(KDF, \"HKDF-SHA512\", P11HKDF, m(CKM_SHA512_HMAC),\n+                m(CKM_HKDF_DERIVE, CKM_HKDF_DATA));\n@@ -1510,0 +1523,9 @@\n+            } else if (type == KDF) {\n+                try {\n+                    return new P11HKDF(token, algorithm, mechanism,\n+                            (KDFParameters) param);\n+                } catch (ClassCastException |\n+                         InvalidAlgorithmParameterException e) {\n+                    throw new NoSuchAlgorithmException(\n+                            \"Cannot instantiate a service of KDF type.\", e);\n+                }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+\/**\n+ * class CK_HKDF_PARAMS provides the parameters to the CKM_HKDF_DERIVE and\n+ * CKM_HKDF_DATA mechanisms.<p>\n+ * <b>PKCS#11 structure:<\/b>\n+ * <pre>\n+ * typedef struct CK_HKDF_PARAMS {\n+ *   CK_BBOOL          bExtract;\n+ *   CK_BBOOL          bExpand;\n+ *   CK_MECHANISM_TYPE prfHashMechanism;\n+ *   CK_ULONG          ulSaltType;\n+ *   CK_BYTE_PTR       pSalt;\n+ *   CK_ULONG          ulSaltLen;\n+ *   CK_OBJECT_HANDLE  hSaltKey;\n+ *   CK_BYTE_PTR       pInfo;\n+ *   CK_ULONG          ulInfoLen;\n+ * } CK_HKDF_PARAMS;\n+ * <\/pre>\n+ *\n+ *\/\n+public class CK_HKDF_PARAMS {\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_BBOOL bExtract;\n+     * <\/pre>\n+     *\/\n+    public final boolean bExtract;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_BBOOL bExpand;\n+     * <\/pre>\n+     *\/\n+    public final boolean bExpand;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_MECHANISM_TYPE prfHashMechanism;\n+     * <\/pre>\n+     *\/\n+    public final long prfHashMechanism;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_ULONG ulSaltType;\n+     * <\/pre>\n+     *\/\n+    public final long ulSaltType;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_BYTE_PTR pSalt;\n+     *   CK_ULONG ulSaltLen;\n+     * <\/pre>\n+     *\/\n+    public final byte[] pSalt;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_OBJECT_HANDLE hSaltKey;\n+     * <\/pre>\n+     *\/\n+    public final long hSaltKey;\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_BYTE_PTR pInfo;\n+     *   CK_ULONG ulInfoLen;\n+     * <\/pre>\n+     *\/\n+    public final byte[] pInfo;\n+\n+    public CK_HKDF_PARAMS(boolean bExtract, boolean bExpand,\n+            long prfHashMechanism, long ulSaltType, byte[] pSalt, long hSaltKey,\n+            byte[] pInfo) {\n+        this.bExtract = bExtract;\n+        this.bExpand = bExpand;\n+        this.prfHashMechanism = prfHashMechanism;\n+        this.ulSaltType = ulSaltType;\n+        this.pSalt = pSalt;\n+        this.hSaltKey = hSaltKey;\n+        this.pInfo = pInfo;\n+    }\n+\n+    \/**\n+     * Returns the string representation of CK_HKDF_PARAMS.\n+     *\n+     * @return the string representation of CK_HKDF_PARAMS\n+     *\/\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"bExtract: \");\n+        sb.append(bExtract);\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"bExpand: \");\n+        sb.append(bExpand);\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"prfHashMechanism: \");\n+        sb.append(Functions.getMechanismName(prfHashMechanism));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulSaltType: \");\n+        sb.append(Functions.saltTypeToString(ulSaltType));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pSalt: \");\n+        sb.append(Functions.toHexString(pSalt));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulSaltLen: \");\n+        sb.append(Functions.getLength(pSalt));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"hSaltKey: \");\n+        sb.append(hSaltKey);\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pInfo: \");\n+        sb.append(Functions.toHexString(pInfo));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulInfoLen: \");\n+        sb.append(Functions.getLength(pInfo));\n+        sb.append(Constants.NEWLINE);\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_HKDF_PARAMS.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+\/**\n+ * class CK_KEY_DERIVATION_STRING_DATA provides the parameters to the\n+ * CKM_DES_ECB_ENCRYPT_DATA, CKM_DES3_ECB_ENCRYPT_DATA,\n+ * CKM_AES_ECB_ENCRYPT_DATA, CKM_CONCATENATE_BASE_AND_DATA,\n+ * CKM_CONCATENATE_DATA_AND_BASE, CKM_XOR_BASE_AND_DATA,\n+ * CKM_CAMELLIA_ECB_ENCRYPT_DATA, CKM_ARIA_ECB_ENCRYPT_DATA and\n+ * CKM_SEED_ECB_ENCRYPT_DATA mechanisms.<p>\n+ * <b>PKCS#11 structure:<\/b>\n+ * <pre>\n+ * typedef struct CK_KEY_DERIVATION_STRING_DATA {\n+ *     CK_BYTE_PTR pData;\n+ *     CK_ULONG ulLen;\n+ * } CK_KEY_DERIVATION_STRING_DATA;\n+ * <\/pre>\n+ *\n+ *\/\n+public class CK_KEY_DERIVATION_STRING_DATA {\n+\n+    \/**\n+     * <b>PKCS#11:<\/b>\n+     * <pre>\n+     *   CK_BYTE_PTR pData;\n+     *   CK_ULONG ulLen;\n+     * <\/pre>\n+     *\/\n+    public final byte[] pData;\n+\n+    public CK_KEY_DERIVATION_STRING_DATA(byte[] pData) {\n+        this.pData = pData;\n+    }\n+\n+    \/**\n+     * Returns the string representation of CK_KEY_DERIVATION_STRING_DATA.\n+     *\n+     * @return the string representation of CK_KEY_DERIVATION_STRING_DATA\n+     *\/\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"pData: \");\n+        sb.append(Functions.toHexString(pData));\n+        sb.append(Constants.NEWLINE);\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"ulLen: \");\n+        sb.append(Functions.getLength(pData));\n+        sb.append(Constants.NEWLINE);\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_KEY_DERIVATION_STRING_DATA.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,8 @@\n+    public CK_MECHANISM(long mechanism, CK_HKDF_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n+    public CK_MECHANISM(long mechanism, CK_KEY_DERIVATION_STRING_DATA params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -443,0 +443,20 @@\n+    private static final Flags hkdfSaltTypes = new Flags(new long[] {\n+            CKF_HKDF_SALT_NULL,\n+            CKF_HKDF_SALT_DATA,\n+            CKF_HKDF_SALT_KEY\n+    }, new String[] {\n+            \"CKF_HKDF_SALT_NULL\",\n+            \"CKF_HKDF_SALT_DATA\",\n+            \"CKF_HKDF_SALT_KEY\"\n+    });\n+\n+    \/**\n+     * converts a long value to a HKDF salt type string\n+     *\n+     * @param ulSaltType the HKDF salt type to be converted\n+     * @return the HKDF salt type string representation\n+     *\/\n+    public static String saltTypeToString(long ulSaltType) {\n+        return hkdfSaltTypes.toString(ulSaltType);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/Functions.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,2 +314,0 @@\n-    public static final long  PCKK_HMAC                = 0x7FFFFF23L;\n-    public static final long  PCKK_SSLMAC              = 0x7FFFFF24L;\n@@ -1159,0 +1157,1 @@\n+    *\/\n@@ -1163,1 +1162,0 @@\n-    *\/\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11Constants.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -734,0 +734,144 @@\n+\/*\n+ * converts a Java CK_HKDF_PARAMS object to a CK_HKDF_PARAMS pointer\n+ *\n+ * @param env - used to call JNI functions to get Java classes and objects\n+ * @param jParam - a Java CK_HKDF_PARAMS object to convert\n+ * @param pLength - length of the allocated memory of the returned pointer\n+ * @return pointer to a new CK_HKDF_PARAMS structure\n+ *\/\n+CK_HKDF_PARAMS_PTR\n+jHkdfParamsToCKHkdfParamsPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength)\n+{\n+    CK_HKDF_PARAMS_PTR ckParamPtr = NULL;\n+    jclass jHkdfParamsClass;\n+    jfieldID fieldID;\n+    jboolean jbExtract, jbExpand;\n+    jlong jPrfHashMechanism, julSaltType, jhSaltKey;\n+    jobject jpSalt, jpInfo;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0L;\n+    }\n+\n+    jHkdfParamsClass = (*env)->FindClass(env, CLASS_HKDF_PARAMS);\n+    if (jHkdfParamsClass == NULL) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"bExtract\", \"Z\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jbExtract = (*env)->GetBooleanField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"bExpand\", \"Z\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jbExpand = (*env)->GetBooleanField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"prfHashMechanism\", \"J\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jPrfHashMechanism = (*env)->GetLongField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"ulSaltType\", \"J\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    julSaltType = (*env)->GetLongField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"pSalt\", \"[B\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jpSalt = (*env)->GetObjectField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"hSaltKey\", \"J\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jhSaltKey = (*env)->GetLongField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jHkdfParamsClass, \"pInfo\", \"[B\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jpInfo = (*env)->GetObjectField(env, jParam, fieldID);\n+\n+    ckParamPtr = calloc(1, sizeof(CK_HKDF_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        p11ThrowOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+\n+    ckParamPtr->bExtract = jBooleanToCKBBool(jbExtract);\n+    ckParamPtr->bExpand = jBooleanToCKBBool(jbExpand);\n+    ckParamPtr->prfHashMechanism = jLongToCKULong(jPrfHashMechanism);\n+    ckParamPtr->ulSaltType = jLongToCKULong(julSaltType);\n+    jByteArrayToCKByteArray(env, jpSalt, &(ckParamPtr->pSalt), &(ckParamPtr->ulSaltLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+    ckParamPtr->hSaltKey = jLongToCKULong(jhSaltKey);\n+    jByteArrayToCKByteArray(env, jpInfo, &(ckParamPtr->pInfo), &(ckParamPtr->ulInfoLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_HKDF_PARAMS);\n+    }\n+    return ckParamPtr;\n+cleanup:\n+    free(ckParamPtr->pInfo);\n+    free(ckParamPtr->pSalt);\n+    free(ckParamPtr);\n+    return NULL;\n+}\n+\n+\/*\n+ * converts a Java CK_KEY_DERIVATION_STRING_DATA object to a CK_KEY_DERIVATION_STRING_DATA pointer\n+ *\n+ * @param env - used to call JNI functions to get Java classes and objects\n+ * @param jParam - a Java CK_KEY_DERIVATION_STRING_DATA object to convert\n+ * @param pLength - length of the allocated memory of the returned pointer\n+ * @return pointer to a new CK_KEY_DERIVATION_STRING_DATA structure\n+ *\/\n+CK_KEY_DERIVATION_STRING_DATA_PTR\n+jKeyDerivationStringDataToCKKeyDerivationStringDataPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_KEY_DERIVATION_STRING_DATA_PTR ckParamPtr = NULL;\n+    jclass jKeyDerivationStringDataClass;\n+    jfieldID fieldID;\n+    jobject jpData;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0L;\n+    }\n+\n+    jKeyDerivationStringDataClass = (*env)->FindClass(env, CLASS_KEY_DERIVATION_STRING_DATA);\n+    if (jKeyDerivationStringDataClass == NULL) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jKeyDerivationStringDataClass, \"pData\", \"[B\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jpData = (*env)->GetObjectField(env, jParam, fieldID);\n+\n+    ckParamPtr = calloc(1, sizeof(CK_KEY_DERIVATION_STRING_DATA));\n+    if (ckParamPtr == NULL) {\n+        p11ThrowOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+\n+    jByteArrayToCKByteArray(env, jpData, &(ckParamPtr->pData), &(ckParamPtr->ulLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_KEY_DERIVATION_STRING_DATA);\n+    }\n+    return ckParamPtr;\n+cleanup:\n+    free(ckParamPtr->pData);\n+    free(ckParamPtr);\n+    return NULL;\n+}\n+\n@@ -1499,0 +1643,9 @@\n+            break;\n+        case CKM_HKDF_DATA:\n+        case CKM_HKDF_DERIVE:\n+            ckpParamPtr = jHkdfParamsToCKHkdfParamsPtr(env, jParam, ckpLength);\n+            break;\n+        case CKM_CONCATENATE_BASE_AND_DATA:\n+        case CKM_CONCATENATE_DATA_AND_BASE:\n+            ckpParamPtr = jKeyDerivationStringDataToCKKeyDerivationStringDataPtr(env, jParam,\n+                    ckpLength);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":154,"deletions":1,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,0 +358,10 @@\n+                 case CKM_HKDF_DERIVE:\n+                     TRACE0(\"[ CK_HKDF_PARAMS ]\\n\");\n+                     free(((CK_HKDF_PARAMS*)tmp)->pSalt);\n+                     free(((CK_HKDF_PARAMS*)tmp)->pInfo);\n+                     break;\n+                 case CKM_CONCATENATE_BASE_AND_DATA:\n+                 case CKM_CONCATENATE_DATA_AND_BASE:\n+                     TRACE0(\"[ CK_KEY_DERIVATION_STRING_DATA ]\\n\");\n+                     free(((CK_KEY_DERIVATION_STRING_DATA*)tmp)->pData);\n+                     break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,1 +300,0 @@\n-#define CLASS_KEY_DERIVATION_STRING_DATA \"sun\/security\/pkcs11\/wrapper\/CK_KEY_DERIVATION_STRING_DATA\"\n@@ -303,0 +302,1 @@\n+#define CLASS_KEY_DERIVATION_STRING_DATA \"sun\/security\/pkcs11\/wrapper\/CK_KEY_DERIVATION_STRING_DATA\"\n@@ -313,0 +313,1 @@\n+#define CLASS_HKDF_PARAMS \"sun\/security\/pkcs11\/wrapper\/CK_HKDF_PARAMS\"\n@@ -397,1 +398,2 @@\n-CK_KEY_DERIVATION_STRING_DATA jKeyDerivationStringDataToCKKeyDerivationStringData(JNIEnv *env, jobject jParam);\n+CK_HKDF_PARAMS_PTR jHkdfParamsToCKHkdfParamsPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n+CK_KEY_DERIVATION_STRING_DATA_PTR jKeyDerivationStringDataToCKKeyDerivationStringDataPtr(JNIEnv *env, jobject jParam, CK_ULONG* pLength);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,634 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.lang.reflect.Method;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8328119\n+ * @summary test HKDF key derivation in SunPKCS11\n+ * @library \/test\/lib ..\n+ * @enablePreview\n+ * @run main\/othervm\/timeout=30 TestHKDF\n+ *\/\n+\n+public final class TestHKDF extends PKCS11Test {\n+\n+    private static final boolean DEBUG = false;\n+    private static final HexFormat hex = HexFormat.of().withLowerCase();\n+    private static final byte[] knownBytes = hex.parseHex(\n+            \"000102030405060708090a0b0c0d0e0f10111213141516\");\n+    private static final OutputStream debugOut = new ByteArrayOutputStream();\n+    private static final PrintWriter debugPrinter = new PrintWriter(debugOut);\n+    private static boolean testFailed = false;\n+    private static Provider p11Provider;\n+    private static SecretKeyFactory p11GenericSkf;\n+\n+    private record TestContext(String hkdfAlg, String derivedKeyAlg,\n+            Supplier<SecretKey> baseKey, byte[] salt, byte[] info,\n+            byte[] expectedPRK, byte[] expectedOKM, byte[] expectedOpOut) {\n+        \/\/ expectedOpOut value:\n+        \/\/  - If derivedKeyAlg is AES, expectedOpOut is the result of encrypting\n+        \/\/    knownBytes with derivedKey, using AES\/CBC\/PKCS5Padding and an IV\n+        \/\/    of 16 zero bytes.\n+        \/\/  - If derivedKeyAlg is Generic, expectedOpOut is the result of\n+        \/\/    calculating the HmacSHA256 of knownBytes with derivedKey.\n+    }\n+\n+    private static class HkdfTestAssertionException extends Exception {\n+        HkdfTestAssertionException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    private enum KdfParamSpecType {\n+        EXTRACT,\n+        EXPAND,\n+        EXTRACT_EXPAND\n+    }\n+\n+    private enum KeyMaterialType {\n+        KEY,\n+        DATA\n+    }\n+\n+    private static final List<List<KeyMaterialType>> keyMaterialCombinations =\n+            List.of(\n+                    List.of(KeyMaterialType.KEY),\n+                    List.of(KeyMaterialType.DATA),\n+                    List.of(KeyMaterialType.KEY, KeyMaterialType.KEY),\n+                    List.of(KeyMaterialType.KEY, KeyMaterialType.DATA),\n+                    List.of(KeyMaterialType.DATA, KeyMaterialType.KEY),\n+                    List.of(KeyMaterialType.DATA, KeyMaterialType.DATA)\n+            );\n+\n+    private static void addKeyMaterial(\n+            List<KeyMaterialType> keyMaterialCombination, byte[] keyMaterial,\n+            Consumer<SecretKey> addKeyCb, Consumer<byte[]> addDataCb)\n+            throws Exception {\n+        if (keyMaterial.length < keyMaterialCombination.size()) {\n+            throw new Exception(\"Key material is not enough to fulfill the \" +\n+                    \"combination requirement.\");\n+        }\n+        int dataStart = 0, dataEnd;\n+        for (int i = 0; i < keyMaterialCombination.size(); i++) {\n+            dataEnd =\n+                    keyMaterial.length - keyMaterialCombination.size() + i + 1;\n+            byte[] chunk = Arrays.copyOfRange(keyMaterial, dataStart, dataEnd);\n+            if (keyMaterialCombination.get(i) == KeyMaterialType.KEY) {\n+                addKeyCb.accept(p11GenericSkf.generateSecret(\n+                        new SecretKeySpec(chunk, \"Generic\")));\n+            } else {\n+                addDataCb.accept(chunk);\n+            }\n+            dataStart = dataEnd;\n+        }\n+    }\n+\n+    private static List<AlgorithmParameterSpec> generateKdfParamSpecs(\n+            TestContext ctx, KdfParamSpecType type) throws Exception {\n+        List<AlgorithmParameterSpec> kdfParamSpecs = new ArrayList<>();\n+        if (type == KdfParamSpecType.EXTRACT ||\n+                type == KdfParamSpecType.EXTRACT_EXPAND) {\n+            for (List<KeyMaterialType> keyMaterialCombination :\n+                    keyMaterialCombinations) {\n+                final HKDFParameterSpec.Builder b =\n+                        HKDFParameterSpec.ofExtract();\n+                SecretKey baseKey = ctx.baseKey.get();\n+                if (baseKey instanceof SecretKeySpec) {\n+                    addKeyMaterial(keyMaterialCombination, baseKey.getEncoded(),\n+                            b::addIKM, b::addIKM);\n+                } else if (baseKey != null) {\n+                    b.addIKM(baseKey);\n+                }\n+                if (ctx.salt != null) {\n+                    addKeyMaterial(keyMaterialCombination, ctx.salt, b::addSalt,\n+                            b::addSalt);\n+                }\n+                if (type == KdfParamSpecType.EXTRACT) {\n+                    kdfParamSpecs.add(b.extractOnly());\n+                } else {\n+                    kdfParamSpecs.add(b.thenExpand(ctx.info,\n+                            ctx.expectedOKM.length));\n+                }\n+                if (ctx.salt == null && !(baseKey instanceof SecretKeySpec)) {\n+                    \/\/ If the salt is null and the IKM is a non-SecretKeySpec\n+                    \/\/ (i.e. is a P11Key.P11SecretKey), the key material\n+                    \/\/ cannot be split and there will be a single\n+                    \/\/ HKDFParameterSpec to test.\n+                    break;\n+                }\n+            }\n+        } else {\n+            assert type == KdfParamSpecType.EXPAND : \"Unexpected type.\";\n+            kdfParamSpecs.add(HKDFParameterSpec.expandOnly(\n+                    new SecretKeySpec(ctx.expectedPRK, \"Generic\"), ctx.info,\n+                    ctx.expectedOKM.length));\n+        }\n+        return kdfParamSpecs;\n+    }\n+\n+    private static void checkOpWithDerivedKey(TestContext ctx,\n+            SecretKey derivedKey, Provider p) throws Exception {\n+        byte[] opOut;\n+        switch (ctx.derivedKeyAlg) {\n+            case \"AES\" -> {\n+                Cipher cipher = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\", p);\n+                cipher.init(Cipher.ENCRYPT_MODE, derivedKey,\n+                        new IvParameterSpec(new byte[16]));\n+                opOut = cipher.doFinal(knownBytes);\n+            }\n+            case \"Generic\" -> {\n+                Mac hmac = Mac.getInstance(\"HmacSHA256\", p);\n+                hmac.init(derivedKey);\n+                opOut = hmac.doFinal(knownBytes);\n+            }\n+            default -> throw new RuntimeException(\n+                    \"Unexpected derived key algorithm.\");\n+        }\n+        printByteArrayAssertion(\"Operation output\", opOut, ctx.expectedOpOut);\n+        if (!Arrays.equals(opOut, ctx.expectedOpOut)) {\n+            throw new HkdfTestAssertionException(\n+                    \"Operation with derived key failure.\");\n+        }\n+    }\n+\n+    private static void checkDerivationData(String derivationType,\n+            byte[] derivedKey, byte[] derivedData, byte[] expectedData)\n+            throws Exception {\n+        printByteArrayAssertion(derivationType + \" key derivation\", derivedKey,\n+                expectedData);\n+        printByteArrayAssertion(derivationType + \" data derivation\",\n+                derivedData, expectedData);\n+        if (!Arrays.equals(derivedKey, expectedData) ||\n+                !Arrays.equals(derivedData, expectedData)) {\n+            throw new HkdfTestAssertionException(\n+                    derivationType + \" derivation failure.\");\n+        }\n+    }\n+\n+    private static void executeDerivationForKdfParamSpec(TestContext ctx,\n+            KdfParamSpecType type, KDF kdf, AlgorithmParameterSpec kdfParamSpec,\n+            Provider p) throws Exception {\n+        printDerivationInfo(ctx, type, kdfParamSpec, p);\n+        printHeader(\"HKDF derivation: output\", '-', 10);\n+        String derivedKeyAlg = type == KdfParamSpecType.EXTRACT ?\n+                \"Generic\" : ctx.derivedKeyAlg;\n+        SecretKey derivedKey = kdf.deriveKey(derivedKeyAlg, kdfParamSpec);\n+        byte[] derivedData = kdf.deriveData(kdfParamSpec);\n+        if (type == KdfParamSpecType.EXPAND ||\n+                type == KdfParamSpecType.EXTRACT_EXPAND) {\n+            checkDerivationData(\"Extract\", derivedKey.getEncoded(),\n+                    derivedData, ctx.expectedOKM);\n+            checkOpWithDerivedKey(ctx, derivedKey, p);\n+        } else {\n+            assert type == KdfParamSpecType.EXTRACT : \"Unexpected type.\";\n+            checkDerivationData(\"Expand\", derivedKey.getEncoded(),\n+                    derivedData, ctx.expectedPRK);\n+        }\n+    }\n+\n+    private static void crossCheckTestExpectedData(TestContext ctx,\n+            KdfParamSpecType type, AlgorithmParameterSpec kdfParamSpec)\n+            throws Exception {\n+        try {\n+            Provider sunJCE = Security.getProvider(\"SunJCE\");\n+            KDF kdf = KDF.getInstance(ctx.hkdfAlg, sunJCE);\n+            executeDerivationForKdfParamSpec(ctx, type, kdf, kdfParamSpec,\n+                    sunJCE);\n+        } catch (HkdfTestAssertionException e) {\n+            \/\/ Fail if derivation was possible and the assertion data in this\n+            \/\/ test is inconsistent with SunJCE. This should never happen.\n+            throw e;\n+        } catch (Exception e) {\n+            \/\/ Cross-checking of the expected data in this test is a\n+            \/\/ best-effort. If derivation was not possible (e.g. SunJCE does\n+            \/\/ not support the HKDF algorithm), do not fail.\n+        }\n+    }\n+\n+    private static void reportTestFailure(Exception e) {\n+        testFailed = true;\n+        printHeader(\"TEST FAILED\", 'x', 10);\n+        e.printStackTrace(debugPrinter);\n+    }\n+\n+    private static void executeDerivation(TestContext ctx,\n+            KdfParamSpecType type) {\n+        try {\n+            KDF kdf = KDF.getInstance(ctx.hkdfAlg, p11Provider);\n+            List<AlgorithmParameterSpec> kdfParamSpecs =\n+                    generateKdfParamSpecs(ctx, type);\n+            crossCheckTestExpectedData(ctx, type, kdfParamSpecs.get(0));\n+            for (AlgorithmParameterSpec kdfParamSpec : kdfParamSpecs) {\n+                executeDerivationForKdfParamSpec(ctx, type, kdf, kdfParamSpec,\n+                        p11Provider);\n+            }\n+        } catch (Exception e) {\n+            reportTestFailure(e);\n+        }\n+    }\n+\n+    private static byte[] hexStringToByteArray(String hexString) {\n+        return hexString != null ? hex.parseHex(hexString) : null;\n+    }\n+\n+    private static void executeTest(String testHeader, String hkdfAlg,\n+            String derivedKeyAlg, SecretKey baseKey, String saltHex,\n+            String infoHex, String expectedPRKHex, String expectedOKMHex,\n+            String expectedOpOutHex) {\n+        executeTest(testHeader, hkdfAlg, derivedKeyAlg, ()-> baseKey, saltHex,\n+                infoHex, expectedPRKHex, expectedOKMHex, expectedOpOutHex);\n+    }\n+\n+    private static void executeTest(String testHeader, String hkdfAlg,\n+            String derivedKeyAlg, String baseKeyHex, String saltHex,\n+            String infoHex, String expectedPRKHex, String expectedOKMHex,\n+            String expectedOpOutHex) {\n+        executeTest(testHeader, hkdfAlg, derivedKeyAlg,\n+                ()-> new SecretKeySpec(hexStringToByteArray(baseKeyHex),\n+                        \"Generic\"), saltHex, infoHex, expectedPRKHex,\n+                expectedOKMHex, expectedOpOutHex);\n+    }\n+\n+    private static void executeTest(String testHeader, String hkdfAlg,\n+            String derivedKeyAlg, Supplier<SecretKey> baseKey, String saltHex,\n+            String infoHex, String expectedPRKHex, String expectedOKMHex,\n+            String expectedOpOutHex) {\n+        printTestHeader(testHeader);\n+        TestContext ctx = new TestContext(hkdfAlg, derivedKeyAlg, baseKey,\n+                hexStringToByteArray(saltHex),\n+                hexStringToByteArray(infoHex),\n+                hexStringToByteArray(expectedPRKHex),\n+                hexStringToByteArray(expectedOKMHex),\n+                hexStringToByteArray(expectedOpOutHex));\n+        executeDerivation(ctx, KdfParamSpecType.EXTRACT_EXPAND);\n+        executeDerivation(ctx, KdfParamSpecType.EXTRACT);\n+        executeDerivation(ctx, KdfParamSpecType.EXPAND);\n+    }\n+\n+    private static void printTestHeader(String testHeader) {\n+        debugPrinter.println();\n+        debugPrinter.println(\"=\".repeat(testHeader.length()));\n+        debugPrinter.println(testHeader);\n+        debugPrinter.println(\"=\".repeat(testHeader.length()));\n+    }\n+\n+    private static void printHeader(String header, char sepChar, int sepCount) {\n+        String sepBlock = String.valueOf(sepChar).repeat(sepCount);\n+        debugPrinter.println(sepBlock + \" \" + header + \" \" + sepBlock);\n+    }\n+\n+    private static void printDerivationKeyMaterial(String header,\n+            List<SecretKey> keyMaterial, KdfParamSpecType type) {\n+        if (keyMaterial != null && !keyMaterial.isEmpty()) {\n+            debugPrinter.println(header + \":\");\n+            for (SecretKey km : keyMaterial) {\n+                debugPrinter.print(\" \".repeat(2));\n+                if (km instanceof SecretKeySpec) {\n+                    debugPrinter.println(hex.formatHex(km.getEncoded()));\n+                } else {\n+                    debugPrinter.println(km);\n+                }\n+            }\n+        } else if (type == KdfParamSpecType.EXTRACT ||\n+                type == KdfParamSpecType.EXTRACT_EXPAND) {\n+            debugPrinter.println(header + \": NULL\");\n+        }\n+    }\n+\n+    private static void printDerivationInfo(TestContext ctx,\n+            KdfParamSpecType type, AlgorithmParameterSpec kdfParamSpec,\n+            Provider p) {\n+        debugPrinter.println();\n+        printHeader(\"HKDF derivation: input\", '-', 10);\n+        debugPrinter.println(\"Algorithm: \" + ctx.hkdfAlg);\n+        debugPrinter.println(\"Provider: \" + p.getName());\n+        debugPrinter.println(\"Derivation type: \" + type);\n+        List<SecretKey> ikms = null;\n+        List<SecretKey> salts = null;\n+        byte[] info = null;\n+        Integer length = null;\n+        switch (kdfParamSpec) {\n+            case HKDFParameterSpec.Extract asExtract -> {\n+                debugPrinter.println(\"Derived key type: PRK (Generic)\");\n+                salts = asExtract.salts();\n+                ikms = asExtract.ikms();\n+            }\n+            case HKDFParameterSpec.ExtractThenExpand asExtractExpand -> {\n+                debugPrinter.println(\"Derived key type: \" + ctx.derivedKeyAlg);\n+                salts = asExtractExpand.salts();\n+                ikms = asExtractExpand.ikms();\n+                info = asExtractExpand.info();\n+                length = asExtractExpand.length();\n+            }\n+            case HKDFParameterSpec.Expand asExpand -> {\n+                debugPrinter.println(\"Derived key type: \" + ctx.derivedKeyAlg);\n+                info = asExpand.info();\n+                length = asExpand.length();\n+            }\n+            case null, default -> throw new RuntimeException(\n+                    \"Unrecognized AlgorithmParameterSpec class.\");\n+        }\n+        printDerivationKeyMaterial(\"Salts\", salts, type);\n+        printDerivationKeyMaterial(\"IKMs\", ikms, type);\n+        if (info != null) {\n+            debugPrinter.println(\"Info: \" + hex.formatHex(info));\n+        } else if (type == KdfParamSpecType.EXPAND ||\n+                type == KdfParamSpecType.EXTRACT_EXPAND) {\n+            debugPrinter.println(\"Info: NULL\");\n+        }\n+        if (length != null) {\n+            debugPrinter.println(\"Length: \" + length);\n+        }\n+    }\n+\n+    private static void printByteArrayAssertion(String desc, byte[] actual,\n+            byte[] expected) {\n+        debugPrinter.println(desc + \" (actual):\");\n+        debugPrinter.println(actual != null ? hex.formatHex(actual) : \"null\");\n+        debugPrinter.println(desc + \" (expected):\");\n+        debugPrinter.println(expected != null ? hex.formatHex(expected) :\n+                \"null\");\n+    }\n+\n+    private static SecretKey doKeyAgreement(String algorithm, PrivateKey privK,\n+            PublicKey pubK) throws Exception {\n+        KeyAgreement ka = KeyAgreement.getInstance(algorithm, p11Provider);\n+        ka.init(privK);\n+        ka.doPhase(pubK, true);\n+        return ka.generateSecret(\"TlsPremasterSecret\");\n+    }\n+\n+    private static SecretKey getTlsPremasterSecretWithDHExchange(String xHex,\n+            String yHex, String pHex, String gHex) throws Exception {\n+        KeyFactory kf = KeyFactory.getInstance(\"DH\", p11Provider);\n+        BigInteger p = new BigInteger(pHex, 16);\n+        BigInteger g = new BigInteger(gHex, 16);\n+        PrivateKey privK = kf.generatePrivate(new DHPrivateKeySpec(\n+                new BigInteger(xHex, 16), p, g));\n+        PublicKey pubK = kf.generatePublic(new DHPublicKeySpec(\n+                new BigInteger(yHex, 16), p, g));\n+        return doKeyAgreement(\"DH\", privK, pubK);\n+    }\n+\n+    private static SecretKey getTlsPremasterSecretWithECDHExchange(String s,\n+            String wx, String wy) throws Exception {\n+        AlgorithmParameters p =\n+                AlgorithmParameters.getInstance(\"EC\", p11Provider);\n+        p.init(new ECGenParameterSpec(\"secp256r1\"));\n+        ECParameterSpec params = p.getParameterSpec(ECParameterSpec.class);\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\", p11Provider);\n+        PrivateKey privK = kf.generatePrivate(new ECPrivateKeySpec(\n+                new BigInteger(s), params));\n+        ECPoint publicPoint = new ECPoint(new BigInteger(wx),\n+                new BigInteger(wy));\n+        PublicKey pubK = kf.generatePublic(new ECPublicKeySpec(\n+                publicPoint, params));\n+        return doKeyAgreement(\"ECDH\", privK, pubK);\n+    }\n+\n+    private static void test_RFC_5869_case_1() {\n+        executeTest(\"RFC 5869 - Test Case 1\",\n+                \"HKDF-SHA256\",\n+                \"Generic\",\n+                \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                \"000102030405060708090a0b0c\",\n+                \"f0f1f2f3f4f5f6f7f8f9\",\n+                \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2\" +\n+                \"b3e5\",\n+                \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4\" +\n+                \"c5bf34007208d5b887185865\",\n+                \"ad9e90d0c59d47539899647a3baf0fd364c54eeb5f4d0b80e1f39579e434\" +\n+                \"e801\");\n+    }\n+\n+    private static void test_RFC_5869_case_2() {\n+        executeTest(\"RFC 5869 - Test Case 2\",\n+                \"HKDF-SHA256\",\n+                \"Generic\",\n+                \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d\" +\n+                \"1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b\" +\n+                \"3c3d3e3f404142434445464748494a4b4c4d4e4f\",\n+                \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d\" +\n+                \"7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b\" +\n+                \"9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccd\" +\n+                \"cecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaeb\" +\n+                \"ecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15f\" +\n+                \"c244\",\n+                \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19af\" +\n+                \"a97c59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9\" +\n+                \"aca3db71cc30c58179ec3e87c14c01d5c1f3434f1d87\",\n+                \"eabe8bc548bf430aedc423e9d7df94125eacff3dbb3b95b50379246c2546\" +\n+                \"01da\");\n+    }\n+\n+    private static void test_RFC_5869_case_3() {\n+        executeTest(\"RFC 5869 - Test Case 3\",\n+                \"HKDF-SHA256\",\n+                \"Generic\",\n+                \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                null,\n+                null,\n+                \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293c\" +\n+                \"cb04\",\n+                \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c73\" +\n+                \"8d2d9d201395faa4b61a96c8\",\n+                \"06828b5679679681be59aa2822869cb1a174319e53a545e3301bd832ae3e\" +\n+                \"513f\");\n+    }\n+\n+    private static void test_AES_HKDFWithHmacSHA256() {\n+        executeTest(\"AES - HKDF-SHA256\",\n+                \"HKDF-SHA256\",\n+                \"AES\",\n+                \"000102030405060708090a0b0c0d0e0f\",\n+                \"101112131415161718191a1b1c1d1e1f\",\n+                \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                \"0ecd9f09ddfc6b7bcad2646fa6bc10f922e5489a4ea755ec87ec1b7df379\" +\n+                \"85ca\",\n+                \"b97b1b4ce098f8e22f2f38b60d9f7a0e5902a1193602a876c010d73009dd\" +\n+                \"0701\",\n+                \"646e0175bcef43b9ebd2a3884699ad40b34d4b011e91679c5f25f0721d36\" +\n+                \"7f6a\");\n+    }\n+\n+    private static void test_AES_HKDFWithHmacSHA384() {\n+        executeTest(\"AES - HKDF-SHA384\",\n+                \"HKDF-SHA384\",\n+                \"AES\",\n+                \"000102030405060708090a0b0c0d0e0f\",\n+                \"101112131415161718191a1b1c1d1e1f\",\n+                \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                \"31ca88a527220f8271d78df4ce6c4d973f135ad37973b96644b4d52d499d\" +\n+                \"0a2b03d53c875b1176b089e1e6161ab6d92b\",\n+                \"ba91a67e4d7640495194916ef1252418a651103fbddb0f2ec8b9d1f44f7a\" +\n+                \"7a0d\",\n+                \"f3cfcb44d7b36dce96f584c74118b434e714a13448321063241fd24ace11\" +\n+                \"f2a0\");\n+    }\n+\n+    private static void test_AES_HKDFWithHmacSHA512() {\n+        executeTest(\"AES - HKDF-SHA512\",\n+                \"HKDF-SHA512\",\n+                \"AES\",\n+                \"000102030405060708090a0b0c0d0e0f\",\n+                \"101112131415161718191a1b1c1d1e1f\",\n+                \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                \"f6e6b1ddb24ea0f0ede0f533d1f350c86bf78966b0e5fd2af34dd00dae39\" +\n+                \"01d6279fe8111d6572e3cd05f2f0eeabb9144dc0da9437cdf37b0c6d7f3b\" +\n+                \"1064ab2b\",\n+                \"302212eb57ae758874e0e52fbdfa4eee29d7c694f181b21d8a8b571a43ce\" +\n+                \"aad5\",\n+                \"94459a6593f9c2cfea2ad32970efb8506f3a927927ba283fb6bfd7111aa8\" +\n+                \"63fc\");\n+    }\n+\n+    private static void test_AES_HKDFWithHmacSHA256_EmptyBaseKey() {\n+        executeTest(\"AES - HKDF-SHA256 (empty base key)\",\n+                \"HKDF-SHA256\",\n+                \"AES\",\n+                (SecretKey) null,\n+                \"101112131415161718191a1b1c1d1e1f\",\n+                \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                \"cc267bd9515c1eba2cf6aaa1fc8380677f4351fcbea6d70873df5a334efc\" +\n+                \"ee0d\",\n+                \"cf353a33460b146c0eae3f0788ee281e5a0be15280fbeba107472aa1cd58\" +\n+                \"d111\",\n+                \"326e9028f51c05c1919215bad6e35668c94c88040c3777e8e6f8b6acdece\" +\n+                \"85fa\");\n+    }\n+\n+    private static void test_AES_HKDFWithHmacSHA256_EmptyBaseKeySaltInfo() {\n+        executeTest(\"AES - HKDF-SHA256 (empty base key, salt, and info)\",\n+                \"HKDF-SHA256\",\n+                \"AES\",\n+                (SecretKey) null,\n+                null,\n+                null,\n+                \"b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292\" +\n+                \"c5ad\",\n+                \"eb70f01dede9afafa449eee1b1286504e1f62388b3f7dd4f956697b0e828\" +\n+                \"fe18\",\n+                \"3fdcf83994f6e0a6f6f482d097e242355e255a8ed17e661a71ca2d592c7a\" +\n+                \"884e\");\n+    }\n+\n+    private static void test_HKDF_after_DH_HkdfSHA256() throws Exception {\n+        SecretKey tlsPremasterSecret = getTlsPremasterSecretWithDHExchange(\n+                \"00bcb8fa0a6b569961782a394599a1a02a05532a836819908a9a9000ed\",\n+                \"58ceab52f470026eaea24eb250e08d7cc23f21dda57ad628d14eab788633\" +\n+                \"cebc78c565f9292e6cfe9910d51c4878f590c46cbf380e19acf55cd468ab\" +\n+                \"672afb29c09b7edfd522d034019eadae75ea99bacf1e166548f092a5d371\" +\n+                \"930a275cbcb4bb02cb1d1b7a8bf3751dc85e61fb674059deef54e8ebbd36\" +\n+                \"3bdac4f85c5e49cb7dc8720a8088f047f319a63c2722a720e187f827578b\" +\n+                \"2545041bb5e640454e791f683622bb5aba4ab9bc51001c59bba5cd6cc0e2\" +\n+                \"aec00b0a5313a27454a93d3bd3f2ae5ab1c13165d1564e3b2d60629302b3\" +\n+                \"6bf44c1991bad279d3bd51b142294007f0c8828c9060d8b9b4cc6d335bcc\" +\n+                \"ce31d4e6aa18fd3ce99cb92aec09de2d\",\n+                \"00ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a\" +\n+                \"67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a\" +\n+                \"6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0b\" +\n+                \"ff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b\" +\n+                \"3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dc\" +\n+                \"a3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c\" +\n+                \"08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5\" +\n+                \"c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa05\" +\n+                \"1015728e5a8aacaa68ffffffffffffffff\",\n+                \"02\"\n+        );\n+        executeTest(\"Test HKDF-SHA256 after DH exchange (TLS)\",\n+                \"HKDF-SHA256\",\n+                \"Generic\",\n+                tlsPremasterSecret,\n+                null,\n+                null,\n+                \"e3cf8e5e0892ad251a5863c7f6ddc4fb988b1a723a30d3fe1ac235799caf\" +\n+                \"86e1\",\n+                \"86e508974080cdad9fa4407e253d35ae48f40e0e266c91dd04c775538c17\" +\n+                \"0eacd71bb4d54ba0c5065091\",\n+                \"2e94c8c852d318887fa94dac544c369bc25879efd39683a9dc5eda55f565\" +\n+                \"88c0\");\n+    }\n+\n+    private static void test_HKDF_after_ECDH_HkdfSHA256() throws Exception {\n+        SecretKey tlsPremasterSecret = getTlsPremasterSecretWithECDHExchange(\n+                \"312092587041182431404764856027482553256569653405119712868911\" +\n+                \"21589605635583946\",\n+                \"851398477998049170325388348439523125186814652510003800309225\" +\n+                \"34333070929362623\",\n+                \"531080873930420952237875954830357399317339863932672261700603\" +\n+                \"26242234504331049\");\n+        executeTest(\"Test HKDF-SHA256 after ECDH exchange (TLS)\",\n+                \"HKDF-SHA256\",\n+                \"Generic\",\n+                tlsPremasterSecret,\n+                null,\n+                null,\n+                \"638d8874237f12e42b366090ee8a0207d28a1ac8fd12b6a753ecb58c31cd\" +\n+                \"6a5e\",\n+                \"348a1afabe9560d3a0a6577e8bd66f0e8dc43b4ad52037f692ea5d28fbb2\" +\n+                \"bc963ef59eba65a83befc465\",\n+                \"bab55b2106b4fee07b7afc905ed7c1e84889e941fbc12f132c706addcfc0\" +\n+                \"6e09\");\n+    }\n+\n+    public void main(Provider p) throws Exception {\n+        p11Provider = p;\n+        p11GenericSkf = SecretKeyFactory.getInstance(\"Generic\", p11Provider);\n+        for (Method m : TestHKDF.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                m.invoke(null);\n+            }\n+        }\n+        if (DEBUG || testFailed) {\n+            debugPrinter.flush();\n+            System.out.println(debugOut);\n+        }\n+        if (testFailed) {\n+            throw new Exception(\"TEST FAILED\");\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestHKDF(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KDF\/TestHKDF.java","additions":634,"deletions":0,"binary":false,"changes":634,"status":"added"}]}