{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -174,0 +175,4 @@\n+  {\n+    G1RegionPinCache& cache = G1ThreadLocalData::pin_count_cache(thread);\n+    cache.flush();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -2474,0 +2475,6 @@\n+void G1CollectedHeap::flush_region_pin_cache() {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    G1ThreadLocalData::pin_count_cache(thread).flush();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -778,0 +778,4 @@\n+  \/\/ Update all region's pin counts from the per-thread caches and resets them.\n+  \/\/ Must be called before any decision based on pin counts.\n+  void flush_region_pin_cache();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ \/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -269,2 +270,3 @@\n-  HeapRegion *r = heap_region_containing(obj);\n-  r->increment_pinned_object_count();\n+\n+  uint obj_region_idx = heap_region_containing(obj)->hrm_index();\n+  G1ThreadLocalData::pin_count_cache(thread).inc_count(obj_region_idx);\n@@ -276,2 +278,3 @@\n-  HeapRegion *r = heap_region_containing(obj);\n-  r->decrement_pinned_object_count();\n+\n+  uint obj_region_idx = heap_region_containing(obj)->hrm_index();\n+  G1ThreadLocalData::pin_count_cache(thread).dec_count(obj_region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,1 @@\n+  _heap->flush_region_pin_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1REGIONPINCACHE_HPP\n+#define SHARE_GC_G1_G1REGIONPINCACHE_HPP\n+\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Holds (caches) the pending pinned object count adjustment for the region\n+\/\/ _region_idx on a per thread basis.\n+\/\/ Keeping such a cache avoids the expensive atomic operations when updating the\n+\/\/ pin count for the very common case that the application pins and unpins the\n+\/\/ same object with any interleaving by a garbage collection or pinning\/unpinning\n+\/\/ to an object in another region.\n+class G1RegionPinCache : public StackObj {\n+  uint _region_idx;\n+  size_t _count;\n+\n+  void flush_and_set(uint new_region_idx, size_t new_count);\n+\n+public:\n+  G1RegionPinCache() : _region_idx(G1_NO_HRM_INDEX), _count(0) { }\n+\n+#ifdef ASSERT\n+  size_t count() const { return _count; }\n+#endif\n+\n+  void inc_count(uint region_idx);\n+  void dec_count(uint region_idx);\n+\n+  void flush();\n+};\n+\n+#endif \/* SHARE_GC_G1_G1REGIONPINCACHE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionPinCache.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP\n+#define SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP\n+\n+#include \"gc\/g1\/g1RegionPinCache.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+\n+inline void G1RegionPinCache::inc_count(uint region_idx) {\n+  if (region_idx == _region_idx) {\n+    ++_count;\n+  } else {\n+    flush_and_set(region_idx, (size_t)1);\n+  }\n+}\n+\n+inline void G1RegionPinCache::dec_count(uint region_idx) {\n+  if (region_idx == _region_idx) {\n+    --_count;\n+  } else {\n+    flush_and_set(region_idx, ~(size_t)0);\n+  }\n+}\n+\n+inline void G1RegionPinCache::flush_and_set(uint new_region_idx, size_t new_count) {\n+  if (_count != 0) {\n+    G1CollectedHeap::heap()->region_at(_region_idx)->add_pinned_object_count(_count);\n+  }\n+  _region_idx = new_region_idx;\n+  _count = new_count;\n+}\n+\n+inline void G1RegionPinCache::flush() {\n+  flush_and_set(G1_NO_HRM_INDEX, 0);\n+}\n+\n+#endif \/* SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionPinCache.inline.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.hpp\"\n@@ -40,0 +41,5 @@\n+  \/\/ Per-thread cache of pinned object count to reduce atomic operation traffic\n+  \/\/ due to region pinning. Holds the last region where the mutator pinned an\n+  \/\/ object and the number of pin operations since the last change of the region.\n+  G1RegionPinCache _pin_cache;\n+\n@@ -42,1 +48,2 @@\n-      _dirty_card_queue(&G1BarrierSet::dirty_card_queue_set()) {}\n+      _dirty_card_queue(&G1BarrierSet::dirty_card_queue_set()),\n+      _pin_cache() {}\n@@ -93,0 +100,4 @@\n+\n+  static G1RegionPinCache& pin_count_cache(Thread* thread) {\n+    return data(thread)->_pin_cache;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ThreadLocalData.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n+#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n@@ -60,0 +62,1 @@\n+      \/\/ Retire TLABs.\n@@ -63,1 +66,1 @@\n-\n+      \/\/ Concatenate logs.\n@@ -66,0 +69,2 @@\n+      \/\/ Flush region pin count cache.\n+      G1ThreadLocalData::pin_count_cache(thread).flush();\n@@ -135,0 +140,2 @@\n+\n+      assert(G1ThreadLocalData::pin_count_cache(thread).count() == 0, \"NonJava thread has pinned Java objects\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -305,2 +305,3 @@\n-  inline void increment_pinned_object_count();\n-  inline void decrement_pinned_object_count();\n+  \/\/ Atomically adjust the pinned object count by the given value. Value must not\n+  \/\/ be zero.\n+  inline void add_pinned_object_count(size_t value);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -556,6 +556,4 @@\n-inline void HeapRegion::increment_pinned_object_count() {\n-  Atomic::add(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n-}\n-\n-inline void HeapRegion::decrement_pinned_object_count() {\n-  Atomic::sub(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n+inline void HeapRegion::add_pinned_object_count(size_t value) {\n+  assert(value != 0, \"wasted effort\");\n+  assert(!is_free(), \"trying to pin free region %u, adding %zu\", hrm_index(), value);\n+  Atomic::add(&_pinned_object_count, value, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}