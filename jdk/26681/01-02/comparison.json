{"files":[{"patch":"@@ -31,0 +31,3 @@\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -37,0 +41,2 @@\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -38,0 +44,2 @@\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/method.hpp\"\n@@ -44,0 +52,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -45,0 +54,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public final class PrecompiledHeaders {\n+\n+    private static final Pattern INCLUDE_PATTERN = Pattern.compile(\"^#\\\\s*include \\\"([^\\\"]+)\\\"$\");\n+    private static final String HOTSPOT_PATH = \"src\/hotspot\";\n+    private static final String PRECOMPILED_HPP = \"src\/hotspot\/share\/precompiled\/precompiled.hpp\";\n+    private static final String INLINE_HPP_SUFFIX = \".inline.hpp\";\n+\n+    private PrecompiledHeaders() {\n+        throw new UnsupportedOperationException(\"Instances not allowed\");\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0 || args.length > 2) {\n+            System.err.println(\"Usage: min_inclusion_count [jdk_root=.]\");\n+            System.exit(1);\n+        }\n+\n+        int minInclusionCount = Integer.parseInt(args[0]);\n+        Path jdkRoot = Path.of(args.length == 2 ? args[1] : \".\").toAbsolutePath();\n+        if (!Files.isDirectory(jdkRoot)) {\n+            throw new IllegalArgumentException(\"jdk_root is not a directory: \" + jdkRoot);\n+        }\n+        Path hotspotPath = jdkRoot.resolve(HOTSPOT_PATH);\n+        if (!Files.isDirectory(hotspotPath)) {\n+            throw new IllegalArgumentException(\"Invalid hotspot directory: \" + hotspotPath);\n+        }\n+\n+        \/\/ Count inclusion times for each header\n+        Map<String, Integer> occurrences = new HashMap<>();\n+        try (Stream<Path> paths = Files.walk(hotspotPath)) {\n+            paths.filter(Files::isRegularFile)\n+                    .filter(path -> {\n+                        String name = path.getFileName().toString();\n+                        return name.endsWith(\".cpp\") || name.endsWith(\".hpp\");\n+                    })\n+                    .flatMap(path -> {\n+                        try {\n+                            return Files.lines(path);\n+                        } catch (IOException exception) {\n+                            throw new UncheckedIOException(exception);\n+                        }\n+                    })\n+                    .map(INCLUDE_PATTERN::matcher)\n+                    .filter(Matcher::matches)\n+                    .map(matcher -> matcher.group(1))\n+                    .forEach(include -> occurrences.compute(include,\n+                            (k, old) -> Objects.requireNonNullElse(old, 0) + 1));\n+        }\n+\n+        List<String> inlineIncludes = occurrences.keySet().stream()\n+                .filter(s -> s.endsWith(INLINE_HPP_SUFFIX))\n+                .toList();\n+\n+        \/\/ Each .inline.hpp pulls in the non-inline version too, so we can increase its counter\n+        for (String inlineInclude : inlineIncludes) {\n+            int inlineCount = occurrences.get(inlineInclude);\n+            String noInlineInclude = inlineInclude.replace(INLINE_HPP_SUFFIX, \".hpp\");\n+            int noInlineCount = Objects.requireNonNullElse(\n+                    occurrences.get(noInlineInclude), 0);\n+            occurrences.put(noInlineInclude, inlineCount + noInlineCount);\n+        }\n+\n+        \/\/ Keep only the headers which are included at least 'minInclusionCount' times\n+        Set<String> headers = occurrences.entrySet().stream()\n+                .filter(entry -> entry.getValue() > minInclusionCount)\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+\n+        \/\/ If both inline and non-inline headers are to be included, prefer the inline header\n+        for (String inlineInclude : inlineIncludes) {\n+            if (headers.contains(inlineInclude)) {\n+                String noInlineInclude = inlineInclude.replace(INLINE_HPP_SUFFIX, \".hpp\");\n+                headers.remove(noInlineInclude);\n+            }\n+        }\n+\n+        Path precompiledHpp = jdkRoot.resolve(PRECOMPILED_HPP);\n+        try (Stream<String> lines = Files.lines(precompiledHpp)) {\n+            String precompiledHppHeader = lines\n+                    .takeWhile(Predicate.not(s -> INCLUDE_PATTERN.matcher(s).matches()))\n+                    .collect(Collectors.joining(System.lineSeparator()));\n+            Files.write(precompiledHpp, precompiledHppHeader.getBytes());\n+        }\n+\n+        String headerLines = headers.stream()\n+                .sorted()\n+                .map(header -> String.format(\"#include \\\"%s\\\"\", header))\n+                .collect(Collectors.joining(System.lineSeparator()));\n+        Files.write(precompiledHpp,\n+                (System.lineSeparator() + headerLines + System.lineSeparator()).getBytes(),\n+                StandardOpenOption.APPEND);\n+    }\n+\n+}\n","filename":"src\/utils\/PrecompiledHeaders\/PrecompiledHeaders.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+# Hotspot precompiled headers\n+\n+This directory contains a simple tool to refresh the current set of precompiled headers\n+in `src\/hotspot`. The headers are selected according to how frequently they are included\n+in Hotspot source code.\n+\n+## Usage\n+\n+The script requires a parameter which determines the minimum inclusion count a header\n+must reach in order to be precompiled. Optionally, the root path to the JDK project can\n+be specified as the second parameter.\n+\n+```bash\n+$ javac src\/utils\/PrecompiledHeaders\/PrecompiledHeaders.java\n+$ java -cp src\/utils\/PrecompiledHeaders PrecompiledHeaders min_inclusion_count [jdk_root=.]\n+```\n+\n+The script will write to `src\/hotspot\/share\/precompiled\/precompiled.hpp` the new set of\n+headers selected to be precompiled.\n+\n+## Related tickets\n+- [JDK-8213339](https:\/\/bugs.openjdk.org\/browse\/JDK-8213339)\n+- [JDK-8365053](https:\/\/bugs.openjdk.org\/browse\/JDK-8365053)\n","filename":"src\/utils\/PrecompiledHeaders\/README.md","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"}]}