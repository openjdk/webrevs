{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.util.HashMap;\n@@ -33,1 +32,0 @@\n-import java.util.Objects;\n@@ -35,0 +33,1 @@\n+import java.util.function.Function;\n@@ -43,0 +42,1 @@\n+    private static final Pattern DEPENDENCY_LINE_PATTERN = Pattern.compile(\"\\\\s*(\\\\S+)\\\\s*\\\\\\\\?\");\n@@ -44,1 +44,1 @@\n-    private static final String HOTSPOT_PATH = \"src\/hotspot\";\n+    private static final String OBJS_PATH = \"hotspot\/variant-server\/libjvm\/objs\";\n@@ -47,0 +47,1 @@\n+    private static final String HOTSPOT_SOURCE_PREFIX = \"\/jdk\/src\/hotspot\/share\/\";\n@@ -53,2 +54,2 @@\n-        if (args.length == 0 || args.length > 2) {\n-            System.err.println(\"Usage: min_inclusion_count [jdk_root=.]\");\n+        if (args.length < 2 || args.length > 3) {\n+            System.err.println(\"Usage: min_inclusion_count build_root [jdk_root=.]\");\n@@ -59,1 +60,5 @@\n-        Path jdkRoot = Path.of(args.length == 2 ? args[1] : \".\").toAbsolutePath();\n+        Path buildRoot = Path.of(args[1]).toAbsolutePath();\n+        if (!Files.isDirectory(buildRoot)) {\n+            throw new IllegalArgumentException(\"build_root is not a directory: \" + buildRoot);\n+        }\n+        Path jdkRoot = Path.of(args.length == 3 ? args[2] : \".\").toAbsolutePath();\n@@ -63,3 +68,4 @@\n-        Path hotspotPath = jdkRoot.resolve(HOTSPOT_PATH);\n-        if (!Files.isDirectory(hotspotPath)) {\n-            throw new IllegalArgumentException(\"Invalid hotspot directory: \" + hotspotPath);\n+\n+        Path objsPath = buildRoot.resolve(OBJS_PATH);\n+        if (!Files.isDirectory(objsPath)) {\n+            throw new IllegalArgumentException(\"Could not find 'objs' directory: \" + objsPath);\n@@ -69,8 +75,4 @@\n-        Map<String, Integer> occurrences = new HashMap<>();\n-        try (Stream<Path> paths = Files.walk(hotspotPath)) {\n-            paths.filter(Files::isRegularFile)\n-                    .filter(path -> {\n-                        String name = path.getFileName().toString();\n-                        return name.endsWith(\".cpp\") || name.endsWith(\".hpp\");\n-                    })\n-                    .flatMap(path -> {\n+        Map<String, Integer> occurrences;\n+        try (Stream<Path> files = Files.list(objsPath)) {\n+            occurrences = files.filter(file -> file.getFileName().toString().endsWith(\".d\"))\n+                    .flatMap(file -> {\n@@ -78,1 +80,1 @@\n-                            return Files.lines(path);\n+                            return Files.lines(file);\n@@ -83,1 +85,3 @@\n-                    .map(INCLUDE_PATTERN::matcher)\n+                    \/\/ The first line contains the object name\n+                    .skip(1)\n+                    .map(DEPENDENCY_LINE_PATTERN::matcher)\n@@ -86,15 +90,3 @@\n-                    .forEach(include -> occurrences.compute(include,\n-                            (k, old) -> Objects.requireNonNullElse(old, 0) + 1));\n-        }\n-\n-        List<String> inlineIncludes = occurrences.keySet().stream()\n-                .filter(s -> s.endsWith(INLINE_HPP_SUFFIX))\n-                .toList();\n-\n-        \/\/ Each .inline.hpp pulls in the non-inline version too, so we can increase its counter\n-        for (String inlineInclude : inlineIncludes) {\n-            int inlineCount = occurrences.get(inlineInclude);\n-            String noInlineInclude = inlineInclude.replace(INLINE_HPP_SUFFIX, \".hpp\");\n-            int noInlineCount = Objects.requireNonNullElse(\n-                    occurrences.get(noInlineInclude), 0);\n-            occurrences.put(noInlineInclude, inlineCount + noInlineCount);\n+                    .filter(dependency -> dependency.startsWith(HOTSPOT_SOURCE_PREFIX))\n+                    .map(dependency -> dependency.replace(HOTSPOT_SOURCE_PREFIX, \"\"))\n+                    .collect(Collectors.toMap(Function.identity(), s -> 1, Integer::sum));\n@@ -105,1 +97,1 @@\n-                .filter(entry -> entry.getValue() > minInclusionCount)\n+                .filter(entry -> entry.getValue() >= minInclusionCount)\n@@ -109,0 +101,3 @@\n+        List<String> inlineIncludes = occurrences.keySet().stream()\n+                .filter(s -> s.endsWith(INLINE_HPP_SUFFIX))\n+                .toList();\n","filename":"src\/utils\/PrecompiledHeaders\/PrecompiledHeaders.java","additions":30,"deletions":35,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -9,3 +9,5 @@\n-The script requires a parameter which determines the minimum inclusion count a header\n-must reach in order to be precompiled. Optionally, the root path to the JDK project can\n-be specified as the second parameter.\n+The script requires two parameters:\n+- The minimum inclusion count a header must reach in order to be precompiled;\n+- The path to a build, which will be used to extract dependency information for each Hotspot\n+    source file.\n+Optionally, the root path to the JDK project can be specified as the second parameter.\n@@ -15,1 +17,1 @@\n-$ java -cp src\/utils\/PrecompiledHeaders PrecompiledHeaders min_inclusion_count [jdk_root=.]\n+$ java -cp src\/utils\/PrecompiledHeaders PrecompiledHeaders min_inclusion_count build_root [jdk_root=.]\n@@ -22,0 +24,1 @@\n+\n","filename":"src\/utils\/PrecompiledHeaders\/README.md","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}