{"files":[{"patch":"@@ -2893,1 +2893,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -2900,6 +2900,2 @@\n-  Node* ONE = ideal.ConI(1);\n-  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n-  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n-\n-  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n-    \/\/ set the VTMS temporary transition bit in current JavaThread\n+  {\n+    \/\/ unconditionally update the temporary VTMS transition bit in current JavaThread\n@@ -2914,1 +2910,1 @@\n-  } ideal.end_if();\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3964,1 +3964,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -3971,3 +3971,0 @@\n-  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -1532,0 +1532,83 @@\n+class VM_SetNotifyJvmtiEventsMode : public VM_Operation {\n+private:\n+  bool _enable;\n+\n+  \/\/ Iterates over all JavaThread's, counts VTMS transitions and restores\n+  \/\/ jt->jvmti_thread_state() and jt->jvmti_vthread() for VTMS transition protocol.\n+  int count_transitions_and_correct_jvmti_thread_states() {\n+    int count = 0;\n+\n+    for (JavaThread* jt : ThreadsListHandle()) {\n+      oop  ct_oop = jt->threadObj();\n+      oop  vt_oop = jt->vthread();\n+      JvmtiThreadState* jt_state = jt->jvmti_thread_state();\n+      JvmtiThreadState* ct_state = java_lang_Thread::jvmti_thread_state(jt->threadObj());\n+      JvmtiThreadState* vt_state = vt_oop != nullptr ? java_lang_Thread::jvmti_thread_state(vt_oop) : nullptr;\n+      bool virt = vt_oop != nullptr && vt_oop != ct_oop;\n+\n+      if (jt->is_in_VTMS_transition()) {\n+        count++;\n+      }\n+      \/\/ Correct jt->jvmti_thread_state() and jt->jvmti_vthread() if necessary.\n+      \/\/ It was not maintained while notifyJvmti was disabled.\n+      if (jt_state != ct_state && jt_state != vt_state) {\n+        JvmtiThreadState* cur_state = virt ? vt_state : ct_state;\n+        jt->set_jvmti_thread_state(cur_state); \/\/ restore jt->jvmti_thread_state()\n+        if (virt) {\n+          jt->set_jvmti_vthread(vt_oop);       \/\/ restore jt->jvmti_vthread()\n+          if (vt_state != nullptr) {\n+            vt_state->set_thread(jt);          \/\/ restore JavaThread link\n+          }\n+        } else {\n+          jt->set_jvmti_vthread(nullptr);      \/\/ reset jt->jvmti_vthread()\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+public:\n+  VMOp_Type type() const { return VMOp_SetNotifyJvmtiEventsMode; }\n+  bool allow_nested_vm_operations() const { return false; }\n+  VM_SetNotifyJvmtiEventsMode(bool enable) : _enable(enable) {}\n+\n+  void doit() {\n+    int count = count_transitions_and_correct_jvmti_thread_states();\n+\n+    JvmtiVTMSTransitionDisabler::set_VTMS_transition_count(count);\n+    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(_enable);\n+  }\n+};\n+\n+\/\/ This function is to support agents loaded into running VM.\n+\/\/ Must be called in thread-in-native mode.\n+bool\n+JvmtiEnvBase::enable_virtual_threads_notify_jvmti() {\n+  if (!Continuations::enabled()) {\n+    return false;\n+  }\n+  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    return false; \/\/ already enabled\n+  }\n+  VM_SetNotifyJvmtiEventsMode op(true);\n+  VMThread::execute(&op);\n+  return true;\n+}\n+\n+\/\/ This function is used in WhiteBox, only needed to test the function above.\n+\/\/ It is unsafe to use this function when virtual threads are executed.\n+\/\/ Must be called in thread-in-native mode.\n+bool\n+JvmtiEnvBase::disable_virtual_threads_notify_jvmti() {\n+  if (!Continuations::enabled()) {\n+    return false;\n+  }\n+  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    return false; \/\/ already disabled\n+  }\n+  JvmtiVTMSTransitionDisabler disabler(true); \/\/ ensure there are no other disablers\n+  VM_SetNotifyJvmtiEventsMode op(false);\n+  VMThread::execute(&op);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -86,0 +86,7 @@\n+  \/\/ This function is to support agents loaded into running VM.\n+  static bool enable_virtual_threads_notify_jvmti();\n+\n+  \/\/ This function is used in WhiteBox, only needed to test the function above.\n+  \/\/ It is unsafe to use this function when virtual threads are executed.\n+  static bool disable_virtual_threads_notify_jvmti();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -382,1 +382,8 @@\n-    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n+      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+        ThreadInVMfromNative __tiv(JavaThread::current());\n+        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+      }\n+    } else {\n+      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  static void set_VTMS_transition_count(bool val)    { _VTMS_transition_count = val; }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -2523,0 +2524,16 @@\n+WB_ENTRY(jboolean, WB_SetVirtualThreadsNotifyJvmtiMode(JNIEnv* env, jobject wb, jboolean enable))\n+  if (!Continuations::enabled()) {\n+    tty->print_cr(\"WB error: must be Continuations::enabled()!\");\n+    return JNI_FALSE;\n+  }\n+  jboolean result = false;\n+#if INCLUDE_JVMTI\n+  if (enable) {\n+    result = JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+  } else {\n+    result = JvmtiEnvBase::disable_virtual_threads_notify_jvmti();\n+  }\n+#endif\n+  return result;\n+WB_END\n+\n@@ -2800,0 +2817,1 @@\n+  {CC\"setVirtualThreadsNotifyJvmtiMode\", CC\"(Z)Z\",    (void*)&WB_SetVirtualThreadsNotifyJvmtiMode},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  template(SetNotifyJvmtiEventsMode)              \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-runtime\/vthread\/RedefineClass.java 8297286 generic-all\n-runtime\/vthread\/TestObjectAllocationSampleEvent.java 8297286 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies JVMTI works for agents loaded into running VM\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -agentlib:ToggleNotifyJvmtiTest ToggleNotifyJvmtiTest\n+ * @run main\/othervm\/native -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -Djdk.attach.allowAttachSelf=true ToggleNotifyJvmtiTest attach\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import java.util.concurrent.ThreadFactory;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/\/ The TestedThread just mimics some thread activity, but it is important\n+\/\/ to have sleep() calls to provide yielding as some frequency of virtual\n+\/\/ thread mount state transitions is needed for this test scenario.\n+class TestedThread extends Thread {\n+    private volatile boolean threadReady = false;\n+    private volatile boolean shouldFinish = false;\n+\n+    \/\/ make thread with specific name\n+    public TestedThread(String name) {\n+        super(name);\n+    }\n+\n+    \/\/ run thread continuously\n+    public void run() {\n+        \/\/ run in a loop\n+        threadReady = true;\n+        int i = 0;\n+        int n = 1000;\n+        while (!shouldFinish) {\n+            if (n <= 0) {\n+                n = 1000;\n+                ToggleNotifyJvmtiTest.sleep(1);\n+            }\n+            if (i > n) {\n+                i = 0;\n+                n = n - 1;\n+            }\n+            i = i + 1;\n+        }\n+    }\n+\n+    \/\/ ensure thread is ready\n+    public void ensureReady() {\n+        while (!threadReady) {\n+            ToggleNotifyJvmtiTest.sleep(1);\n+        }\n+    }\n+\n+    public void letFinish() {\n+        shouldFinish = true;\n+    }\n+}\n+\n+\/*\n+ * The testing scenario consists of a number of serialized test cycles.\n+ * Each cycle has initially zero virtual threads and has the following steps:\n+ *  - disable notifyJvmti events mode\n+ *  - start the platform launcher thread which starts N of virtual thread\n+ *  - enable notifyJvmti events mode after about hapf of virtual thread started\n+ *  - then shut the virtual threads down\n+ * The JVMTI agent is loaded at a start-up or at a dynamic attach.\n+ * It collects events:\n+ *  - VirtualThreadStart, VirtualThreadEnd, ThreadStart and ThreadEnd\n+ *\/\n+public class ToggleNotifyJvmtiTest {\n+    private static final int VTHREADS_CNT = 20;\n+    private static final String AGENT_LIB = \"ToggleNotifyJvmtiTest\";\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static native boolean IsAgentStarted();\n+    private static native int VirtualThreadStartedCount();\n+    private static native int VirtualThreadEndedCount();\n+    private static native int ThreadStartedCount();\n+    private static native int ThreadEndedCount();\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static public void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in TestedThread.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    static TestedThread[] threads = new TestedThread[VTHREADS_CNT];\n+    static Thread vts[] = new Thread[VTHREADS_CNT];\n+\n+    static private synchronized void startThread(int i) {\n+        String name = \"TestedThread\" + i;\n+        TestedThread thread = new TestedThread(name);\n+        vts[i] = Thread.ofVirtual().name(name).start(thread);\n+        thread.ensureReady();\n+        threads[i] = thread;\n+        log(\"# Java: started vthread: \" + name);\n+    }\n+\n+    static private void startThreads() {\n+        log(\"\\n# Java: Starting vthreads\");\n+        for (int i = 0; i < VTHREADS_CNT; i++) {\n+            sleep(1);\n+            startThread(i);\n+        }\n+    }\n+\n+    static private synchronized void finishThreads() {\n+        try {\n+            for (int i = 0; i < VTHREADS_CNT; i++) {\n+                TestedThread thread = threads[i];\n+                if (thread == null) {\n+                    break;\n+                }\n+                thread.letFinish();\n+                vts[i].join();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static private void setVirtualThreadsNotifyJvmtiMode(int iter, boolean enable) {\n+        boolean status = WB.setVirtualThreadsNotifyJvmtiMode(enable);\n+        if (!status) {\n+            throw new RuntimeException(\"Java: failed to set VirtualThreadsNotifyJvmtiMode: \" + enable);\n+        }\n+        log(\"# main: SetNotifyJvmtiEvents: #\" + iter + \" enable: \" + enable);\n+    }\n+\n+    \/\/ Accumulative results after each finished test cycle.\n+    static private void printResults() {\n+        log(\"  VirtualThreadStart events: \" + VirtualThreadStartedCount());\n+        log(\"  VirtualThreadEnd events:   \" + VirtualThreadEndedCount());\n+        log(\"  ThreadStart events:        \" + ThreadStartedCount());\n+        log(\"  ThreadEnd events:          \" + ThreadEndedCount());\n+    }\n+\n+    static private void run_test_cycle(int iter) throws Exception {\n+        log(\"\\n# Java: Started test cycle #\" + iter);\n+\n+        \/\/ Disable notifyJvmti events mode at test cycle start.\n+        \/\/ It is unsafe to do so if any virtual threads are executed.\n+        setVirtualThreadsNotifyJvmtiMode(iter, false);\n+\n+        Thread tt = Thread.ofPlatform().name(\"StartThreadsTest\").start(ToggleNotifyJvmtiTest::startThreads);\n+        sleep(20); \/\/ give some time for launcher thread to start\n+\n+        \/\/ We want this somewhere in the middle of virtual threads execution.\n+        setVirtualThreadsNotifyJvmtiMode(iter, true);\n+        sleep(20); \/\/ give some time for virtual threads to execute\n+\n+        finishThreads();\n+        tt.join();\n+        sleep(20); \/\/ give some time for virtual threads to finish\n+\n+        log(\"\\n# Java: Finished test cycle #\" + iter);\n+        printResults();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        log(\"# main: loading \" + AGENT_LIB + \" lib\");\n+\n+        if (args.length > 0 && args[0].equals(\"attach\")) { \/\/ agent loaded into running VM case\n+            String arg = args.length == 2 ? args[1] : \"\";\n+            VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+            vm.loadAgentLibrary(AGENT_LIB, arg);\n+        }\n+        int waitCount = 0;\n+        while (!IsAgentStarted()) {\n+            log(\"# main: waiting for native agent to start: #\" + waitCount++);\n+            sleep(20);\n+        }\n+\n+        \/\/ The testing scenario consists of a number of sequential testing cycles.\n+        for (int iter = 0; iter < 10; iter++) {\n+            run_test_cycle(iter);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/ToggleNotifyJvmtiTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+static volatile int vthread_started_cnt = 0;\n+static volatile int vthread_ended_cnt = 0;\n+static volatile int thread_started_cnt = 0;\n+static volatile int thread_ended_cnt = 0;\n+\n+static jrawMonitorID agent_lock = NULL;\n+static volatile jboolean agent_started = JNI_FALSE;\n+\n+void JNICALL VirtualThreadStart(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (!jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be virtual thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  vthread_started_cnt++;\n+}\n+\n+void JNICALL VirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (!jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be virtual thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  vthread_ended_cnt++;\n+}\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be platform thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  thread_started_cnt++;\n+}\n+\n+void JNICALL ThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be platform thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  thread_ended_cnt++;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_ToggleNotifyJvmtiTest_IsAgentStarted(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return agent_started;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_VirtualThreadStartedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return vthread_started_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_VirtualThreadEndedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return vthread_ended_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_ThreadStartedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return thread_started_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_ThreadEndedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return thread_ended_cnt;\n+}\n+\n+jint agent_init(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  memset(&caps, 0, sizeof(caps));\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VirtualThreadStart = &VirtualThreadStart;\n+  callbacks.VirtualThreadEnd = &VirtualThreadEnd;\n+  callbacks.ThreadStart = &ThreadStart;\n+  callbacks.ThreadEnd = &ThreadEnd;\n+\n+  {\n+    caps.can_support_virtual_threads = 1;\n+\n+    err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  }\n+  LOG(\"Agent init: can_support_virtual_threads capability: %d\\n\",  caps.can_support_virtual_threads);\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, (jint)sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: error in JVMTI AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  agent_lock = create_raw_monitor(jvmti, \"agent_lock\");\n+  agent_started = JNI_TRUE;\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnAttach started\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/libToggleNotifyJvmtiTest.cpp","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -72,1 +72,2 @@\n-            throw new RuntimeException(\"Failed: wrong ThreadStart event count\");\n+            throw new RuntimeException(\"Failed: wrong ThreadStart count: \" +\n+                                       startedThreads + \" expected: \" + THREAD_CNT);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VirtualThreadStartTest\/VirtualThreadStartTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -741,0 +741,2 @@\n+\n+  public native boolean setVirtualThreadsNotifyJvmtiMode(boolean enabled);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}