{"files":[{"patch":"@@ -2893,1 +2893,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -2900,6 +2900,2 @@\n-  Node* ONE = ideal.ConI(1);\n-  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n-  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n-\n-  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n-    \/\/ set the VTMS temporary transition bit in current JavaThread\n+  {\n+    \/\/ unconditionally update the temporary VTMS transition bit in current JavaThread\n@@ -2914,1 +2910,1 @@\n-  } ideal.end_if();\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3964,1 +3964,1 @@\n-\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+\/\/ Always update the temporary VTMS transition bit.\n@@ -3971,3 +3971,0 @@\n-  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1532,1 +1532,1 @@\n-class VM_InitNotifyJvmtiEventsMode : public VM_Operation {\n+class VM_SetNotifyJvmtiEventsMode : public VM_Operation {\n@@ -1536,1 +1536,3 @@\n-  int count_transitions() {\n+  \/\/ Iterates over all JavaThread's, counts VTMS transitions and restores\n+  \/\/ jt->jvmti_thread_state() and jt->jvmti_vthread() for VTMS transition protocol. \n+  int count_transitions_and_correct_jvmti_thread_states() {\n@@ -1538,4 +1540,24 @@\n-    if (_enable) {\n-      for (JavaThread* jt : ThreadsListHandle()) {\n-        if (jt->is_in_VTMS_transition()) {\n-          count++;\n+\n+    for (JavaThread* jt : ThreadsListHandle()) {\n+      oop  ct_oop = jt->threadObj();\n+      oop  vt_oop = jt->vthread();\n+      JvmtiThreadState* jt_state = jt->jvmti_thread_state();\n+      JvmtiThreadState* ct_state = java_lang_Thread::jvmti_thread_state(jt->threadObj());\n+      JvmtiThreadState* vt_state = vt_oop != nullptr ? java_lang_Thread::jvmti_thread_state(vt_oop) : nullptr;\n+      bool virt = vt_oop != nullptr && vt_oop != ct_oop;\n+\n+      if (jt->is_in_VTMS_transition()) {\n+        count++;\n+      }\n+      \/\/ Correct jt->jvmti_thread_state() and jt->jvmti_vthread() if necessary.\n+      \/\/ It was not maintained while notifyJvmti was disabled. \n+      if (jt_state != ct_state && jt_state != vt_state) {\n+        JvmtiThreadState* cur_state = virt ? vt_state : ct_state;\n+        jt->set_jvmti_thread_state(cur_state); \/\/ restore jt->jvmti_thread_state()\n+        if (virt) {\n+          jt->set_jvmti_vthread(vt_oop);       \/\/ restore jt->jvmti_vthread()\n+          if (vt_state != nullptr) {\n+            vt_state->set_thread(jt);          \/\/ restore JavaThread link\n+          }\n+        } else {\n+          jt->set_jvmti_vthread(nullptr);      \/\/ reset jt->jvmti_vthread()\n@@ -1549,1 +1571,1 @@\n-  VMOp_Type type() const { return VMOp_InitNotifyJvmtiEventsMode; }\n+  VMOp_Type type() const { return VMOp_SetNotifyJvmtiEventsMode; }\n@@ -1551,1 +1573,1 @@\n-  VM_InitNotifyJvmtiEventsMode(bool enable) : _enable(enable) {}\n+  VM_SetNotifyJvmtiEventsMode(bool enable) : _enable(enable) {}\n@@ -1554,1 +1576,1 @@\n-    int trans_count = count_transitions();\n+    int count = count_transitions_and_correct_jvmti_thread_states();\n@@ -1556,0 +1578,1 @@\n+    JvmtiVTMSTransitionDisabler::set_VTMS_transition_count(count);\n@@ -1557,1 +1580,0 @@\n-    JvmtiVTMSTransitionDisabler::set_VTMS_transition_count(trans_count);\n@@ -1561,1 +1583,2 @@\n-\/\/ must be called in thread-in-native mode\n+\/\/ This function is to support agents loaded into running VM.\n+\/\/ Must be called in thread-in-native mode.\n@@ -1570,1 +1593,1 @@\n-  VM_InitNotifyJvmtiEventsMode op(true);\n+  VM_SetNotifyJvmtiEventsMode op(true);\n@@ -1574,2 +1597,4 @@\n-\n-\/\/ must be called in thread-in-native mode\n+  \n+\/\/ This function is used in WhiteBox, only needed to test the function above.\n+\/\/ It is unsafe to use this function when virtual threads are executed.\n+\/\/ Must be called in thread-in-native mode.\n@@ -1581,1 +1606,1 @@\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n@@ -1585,1 +1610,1 @@\n-  VM_InitNotifyJvmtiEventsMode op(false);\n+  VM_SetNotifyJvmtiEventsMode op(false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  \/\/ This function is to support agents loaded into running VM.\n@@ -87,0 +88,3 @@\n+\n+  \/\/ This function is used in WhiteBox, only needed to test the function above.\n+  \/\/ It is unsafe to use this function when virtual threads are executed.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  template(InitNotifyJvmtiEventsMode)             \\\n+  template(SetNotifyJvmtiEventsMode)              \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\/\/import compiler.whitebox.CompilerWhiteBoxTest;\n@@ -43,0 +42,3 @@\n+\/\/ The TestedThread just mimics some thread activity, but it is important\n+\/\/ to have sleep() calls to provide yielding as some frequency of virtual\n+\/\/ thread mount state transitions is needed for this test scenario.\n@@ -52,6 +54,0 @@\n-    \/\/ We will temporarily set a breakpoint on this method when the thread should be suspended.\n-    \/\/ If we hit the breakpoint, then something is wrong.\n-    public void breakpointCheck() {\n-        return;\n-    }\n-\n@@ -65,1 +61,0 @@\n-            breakpointCheck();\n@@ -80,6 +75,2 @@\n-        try {\n-            while (!threadReady) {\n-                sleep(1);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Interruption while preparing tested thread: \\n\\t\" + e);\n+        while (!threadReady) {\n+            ToggleNotifyJvmtiTest.sleep(1);\n@@ -94,0 +85,11 @@\n+\/*\n+ * The testing scenario consists of a number of serialized test cycles.\n+ * Each cycle has initially zero virtual threads and has the following steps:\n+ *  - disable notifyJvmti events mode\n+ *  - start the platform launcher thread which starts N of virtual thread\n+ *  - enable notifyJvmti events mode after about hapf of virtual thread started\n+ *  - then shut the virtual threads down\n+ * The JVMTI agent is loaded at a start-up or at a dynamic attach.\n+ * It collects events:\n+ *  - VirtualThreadStart, VirtualThreadEnd, ThreadStart and ThreadEnd\n+ *\/\n@@ -95,1 +97,1 @@\n-    private static final int VTHREADS_CNT = 60;\n+    private static final int VTHREADS_CNT = 20;\n@@ -101,0 +103,3 @@\n+    private static native int VirtualThreadEndedCount();\n+    private static native int ThreadStartedCount();\n+    private static native int ThreadEndedCount();\n@@ -121,1 +126,1 @@\n-        log(\"## Java: started vthread: \" + name);\n+        log(\"# Java: started vthread: \" + name);\n@@ -125,1 +130,1 @@\n-        log(\"\\n## Java: Starting vthreads\");\n+        log(\"\\n# Java: Starting vthreads\");\n@@ -127,0 +132,1 @@\n+            sleep(1);\n@@ -132,1 +138,0 @@\n-        log(\"\\n## Java: runIt: Finishing vthreads\");\n@@ -148,2 +153,4 @@\n-        sleep(5);\n-        WB.setVirtualThreadsNotifyJvmtiMode(enable);\n+        boolean status = WB.setVirtualThreadsNotifyJvmtiMode(enable);\n+        if (!status) {\n+            throw new RuntimeException(\"Java: failed to set VirtualThreadsNotifyJvmtiMode: \" + enable);\n+        }\n@@ -153,0 +160,30 @@\n+    \/\/ Accumulative results after each finished test cycle.\n+    static private void printResults() {\n+        log(\"  VirtualThreadStart events: \" + VirtualThreadStartedCount());\n+        log(\"  VirtualThreadEnd events:   \" + VirtualThreadEndedCount());\n+        log(\"  ThreadStart events:        \" + ThreadStartedCount());\n+        log(\"  ThreadEnd events:          \" + ThreadEndedCount());\n+    }\n+\n+    static private void run_test_cycle(int iter) throws Exception {\n+        log(\"\\n# Java: Started test cycle #\" + iter);\n+\n+        \/\/ Disable notifyJvmti events mode at test cycle start.\n+        \/\/ It is unsafe to do so if any virtual threads are executed.\n+        setVirtualThreadsNotifyJvmtiMode(iter, false);\n+\n+        Thread tt = Thread.ofPlatform().name(\"StartThreadsTest\").start(ToggleNotifyJvmtiTest::startThreads);\n+        sleep(20); \/\/ give some time for launcher thread to start\n+\n+        \/\/ We want this somewhere in the middle of virtual threads execution.\n+        setVirtualThreadsNotifyJvmtiMode(iter, true);\n+        sleep(20); \/\/ give some time for virtual threads to execute\n+\n+        finishThreads();\n+        tt.join();\n+        sleep(20); \/\/ give some time for virtual threads to finish\n+\n+        log(\"\\n# Java: Finished test cycle #\" + iter);\n+        printResults();\n+    }\n+ \n@@ -160,2 +197,0 @@\n-        } else {\n-            System.loadLibrary(AGENT_LIB);\n@@ -168,2 +203,0 @@\n-        Thread tt = Thread.ofPlatform().name(\"StartThreadsTest\").start(ToggleNotifyJvmtiTest::startThreads);\n-        sleep(20);\n@@ -171,3 +204,6 @@\n-        for (int iter = 0; VirtualThreadStartedCount() < VTHREADS_CNT; iter++) {\n-            setVirtualThreadsNotifyJvmtiMode(iter, false); \/\/ disable\n-            setVirtualThreadsNotifyJvmtiMode(iter, true);  \/\/ enable\n+        \/\/ The testing scenario consists of a number of serialized test cycles.\n+        \/\/ Each cycle has initially zero virtual threads and starts from disabling\n+        \/\/ notifyJvmti events mode. Then it starts the launcher platform thread\n+        \/\/ which starts the VTHREADS_CNT of virtual threads. The native agent\n+        for (int iter = 0; iter < 10; iter++) {\n+            run_test_cycle(iter);\n@@ -175,2 +211,0 @@\n-        finishThreads();\n-        tt.join();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/ToggleNotifyJvmtiTest.java","additions":63,"deletions":29,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -32,1 +32,5 @@\n-static int vthread_started_cnt = 0;\n+static volatile int vthread_started_cnt = 0;\n+static volatile int vthread_ended_cnt = 0;\n+static volatile int thread_started_cnt = 0;\n+static volatile int thread_ended_cnt = 0;\n+\n@@ -34,1 +38,0 @@\n-static bool can_support_vt_enabled = false;\n@@ -39,1 +42,1 @@\n-    fatal(jni, \"Failed: tested thread expected to be virtual\");\n+    fatal(jni, \"Failed: expected to be virtual thread\");\n@@ -46,0 +49,27 @@\n+void JNICALL VirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (!jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be virtual thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  vthread_ended_cnt++;\n+}\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be platform thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  thread_started_cnt++;\n+}\n+\n+void JNICALL ThreadEnd(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: expected to be platform thread\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  thread_ended_cnt++;\n+}\n+\n@@ -60,0 +90,21 @@\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_VirtualThreadEndedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return vthread_ended_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_ThreadStartedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return thread_started_cnt;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_ThreadEndedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return thread_ended_cnt;\n+}\n+\n@@ -71,0 +122,3 @@\n+  callbacks.VirtualThreadEnd = &VirtualThreadEnd;\n+  callbacks.ThreadStart = &ThreadStart;\n+  callbacks.ThreadEnd = &ThreadEnd;\n@@ -73,1 +127,0 @@\n-    can_support_vt_enabled = true;\n@@ -86,0 +139,15 @@\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/libToggleNotifyJvmtiTest.cpp","additions":72,"deletions":4,"binary":false,"changes":76,"status":"modified"}]}