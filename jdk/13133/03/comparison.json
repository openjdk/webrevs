{"files":[{"patch":"@@ -60,1 +60,1 @@\n-#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -1532,0 +1532,58 @@\n+class VM_InitNotifyJvmtiEventsMode : public VM_Operation {\n+private:\n+  bool _enable;\n+\n+  int count_transitions() {\n+    int count = 0;\n+    if (_enable) {\n+      for (JavaThread* jt : ThreadsListHandle()) {\n+        if (jt->is_in_VTMS_transition()) {\n+          count++;\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+public:\n+  VMOp_Type type() const { return VMOp_InitNotifyJvmtiEventsMode; }\n+  bool allow_nested_vm_operations() const { return false; }\n+  VM_InitNotifyJvmtiEventsMode(bool enable) : _enable(enable) {}\n+\n+  void doit() {\n+    int trans_count = count_transitions();\n+\n+    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(_enable);\n+    JvmtiVTMSTransitionDisabler::set_VTMS_transition_count(trans_count);\n+  }\n+};\n+\n+\/\/ must be called in thread-in-native mode\n+bool\n+JvmtiEnvBase::enable_virtual_threads_notify_jvmti() {\n+  if (!Continuations::enabled()) {\n+    return false;\n+  }\n+  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    return false; \/\/ already enabled\n+  }\n+  VM_InitNotifyJvmtiEventsMode op(true);\n+  VMThread::execute(&op);\n+  return true;\n+}\n+\n+\/\/ must be called in thread-in-native mode\n+bool\n+JvmtiEnvBase::disable_virtual_threads_notify_jvmti() {\n+  if (!Continuations::enabled()) {\n+    return false;\n+  }\n+  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    return false; \/\/ already disabled\n+  }\n+  JvmtiVTMSTransitionDisabler disabler(true); \/\/ ensure there are no other disablers\n+  VM_InitNotifyJvmtiEventsMode op(false);\n+  VMThread::execute(&op);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+  static bool enable_virtual_threads_notify_jvmti();\n+  static bool disable_virtual_threads_notify_jvmti();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -382,1 +382,8 @@\n-    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n+      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+        ThreadInVMfromNative __tiv(JavaThread::current());\n+        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+      }\n+    } else {\n+      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  static int  VTMS_transition_count()                { return _VTMS_transition_count; }\n+  static void set_VTMS_transition_count(bool val)    { _VTMS_transition_count = val; }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -2523,0 +2524,16 @@\n+WB_ENTRY(jboolean, WB_SetVirtualThreadsNotifyJvmtiMode(JNIEnv* env, jobject wb, jboolean enable))\n+  if (!Continuations::enabled()) {\n+    tty->print_cr(\"WB error: must be Continuations::enabled()!\");\n+    return JNI_FALSE;\n+  }\n+  jboolean result = false;\n+#if INCLUDE_JVMTI\n+  if (enable) {\n+    result = JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+  } else {\n+    result = JvmtiEnvBase::disable_virtual_threads_notify_jvmti();\n+  }\n+#endif\n+  return result;\n+WB_END\n+\n@@ -2800,0 +2817,1 @@\n+  {CC\"setVirtualThreadsNotifyJvmtiMode\", CC\"(Z)Z\",    (void*)&WB_SetVirtualThreadsNotifyJvmtiMode},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  template(InitNotifyJvmtiEventsMode)             \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-runtime\/vthread\/RedefineClass.java 8297286 generic-all\n-runtime\/vthread\/TestObjectAllocationSampleEvent.java 8297286 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies JVMTI works for agents loaded into running VM\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -agentlib:ToggleNotifyJvmtiTest ToggleNotifyJvmtiTest\n+ * @run main\/othervm\/native -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -Djdk.attach.allowAttachSelf=true ToggleNotifyJvmtiTest attach\n+ *\/\n+\n+\/\/import compiler.whitebox.CompilerWhiteBoxTest;\n+import com.sun.tools.attach.VirtualMachine;\n+import java.util.concurrent.ThreadFactory;\n+import jdk.test.whitebox.WhiteBox;\n+\n+class TestedThread extends Thread {\n+    private volatile boolean threadReady = false;\n+    private volatile boolean shouldFinish = false;\n+\n+    \/\/ make thread with specific name\n+    public TestedThread(String name) {\n+        super(name);\n+    }\n+\n+    \/\/ We will temporarily set a breakpoint on this method when the thread should be suspended.\n+    \/\/ If we hit the breakpoint, then something is wrong.\n+    public void breakpointCheck() {\n+        return;\n+    }\n+\n+    \/\/ run thread continuously\n+    public void run() {\n+        \/\/ run in a loop\n+        threadReady = true;\n+        int i = 0;\n+        int n = 1000;\n+        while (!shouldFinish) {\n+            breakpointCheck();\n+            if (n <= 0) {\n+                n = 1000;\n+                ToggleNotifyJvmtiTest.sleep(1);\n+            }\n+            if (i > n) {\n+                i = 0;\n+                n = n - 1;\n+            }\n+            i = i + 1;\n+        }\n+    }\n+\n+    \/\/ ensure thread is ready\n+    public void ensureReady() {\n+        try {\n+            while (!threadReady) {\n+                sleep(1);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption while preparing tested thread: \\n\\t\" + e);\n+        }\n+    }\n+\n+    public void letFinish() {\n+        shouldFinish = true;\n+    }\n+}\n+\n+public class ToggleNotifyJvmtiTest {\n+    private static final int VTHREADS_CNT = 60;\n+    private static final String AGENT_LIB = \"ToggleNotifyJvmtiTest\";\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static native boolean IsAgentStarted();\n+    private static native int VirtualThreadStartedCount();\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static public void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in TestedThread.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    static TestedThread[] threads = new TestedThread[VTHREADS_CNT];\n+    static Thread vts[] = new Thread[VTHREADS_CNT];\n+\n+    static private synchronized void startThread(int i) {\n+        String name = \"TestedThread\" + i;\n+        TestedThread thread = new TestedThread(name);\n+        vts[i] = Thread.ofVirtual().name(name).start(thread);\n+        thread.ensureReady();\n+        threads[i] = thread;\n+        log(\"## Java: started vthread: \" + name);\n+    }\n+\n+    static private void startThreads() {\n+        log(\"\\n## Java: Starting vthreads\");\n+        for (int i = 0; i < VTHREADS_CNT; i++) {\n+            startThread(i);\n+        }\n+    }\n+\n+    static private synchronized void finishThreads() {\n+        log(\"\\n## Java: runIt: Finishing vthreads\");\n+        try {\n+            for (int i = 0; i < VTHREADS_CNT; i++) {\n+                TestedThread thread = threads[i];\n+                if (thread == null) {\n+                    break;\n+                }\n+                thread.letFinish();\n+                vts[i].join();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static private void setVirtualThreadsNotifyJvmtiMode(int iter, boolean enable) {\n+        sleep(5);\n+        WB.setVirtualThreadsNotifyJvmtiMode(enable);\n+        log(\"# main: SetNotifyJvmtiEvents: #\" + iter + \" enable: \" + enable);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        log(\"# main: loading \" + AGENT_LIB + \" lib\");\n+\n+        if (args.length > 0 && args[0].equals(\"attach\")) { \/\/ agent loaded into running VM case\n+            String arg = args.length == 2 ? args[1] : \"\";\n+            VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+            vm.loadAgentLibrary(AGENT_LIB, arg);\n+        } else {\n+            System.loadLibrary(AGENT_LIB);\n+        }\n+        int waitCount = 0;\n+        while (!IsAgentStarted()) {\n+            log(\"# main: waiting for native agent to start: #\" + waitCount++);\n+            sleep(20);\n+        }\n+        Thread tt = Thread.ofPlatform().name(\"StartThreadsTest\").start(ToggleNotifyJvmtiTest::startThreads);\n+        sleep(20);\n+\n+        for (int iter = 0; VirtualThreadStartedCount() < VTHREADS_CNT; iter++) {\n+            setVirtualThreadsNotifyJvmtiMode(iter, false); \/\/ disable\n+            setVirtualThreadsNotifyJvmtiMode(iter, true);  \/\/ enable\n+        }\n+        finishThreads();\n+        tt.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/ToggleNotifyJvmtiTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+static int vthread_started_cnt = 0;\n+static jrawMonitorID agent_lock = NULL;\n+static bool can_support_vt_enabled = false;\n+static volatile jboolean agent_started = JNI_FALSE;\n+\n+void JNICALL VirtualThreadStart(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  if (!jni->IsVirtualThread(thread)) {\n+    fatal(jni, \"Failed: tested thread expected to be virtual\");\n+  }\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  vthread_started_cnt++;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_ToggleNotifyJvmtiTest_IsAgentStarted(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return agent_started;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ToggleNotifyJvmtiTest_VirtualThreadStartedCount(JNIEnv* jni, jclass clazz) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  return vthread_started_cnt;\n+}\n+\n+jint agent_init(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  memset(&caps, 0, sizeof(caps));\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VirtualThreadStart = &VirtualThreadStart;\n+\n+  {\n+    can_support_vt_enabled = true;\n+    caps.can_support_virtual_threads = 1;\n+\n+    err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      LOG(\"Agent init: error in JVMTI SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  }\n+  LOG(\"Agent init: can_support_virtual_threads capability: %d\\n\",  caps.can_support_virtual_threads);\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, (jint)sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: error in JVMTI AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  agent_lock = create_raw_monitor(jvmti, \"agent_lock\");\n+  agent_started = JNI_TRUE;\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnAttach started\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/libToggleNotifyJvmtiTest.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -72,1 +72,2 @@\n-            throw new RuntimeException(\"Failed: wrong ThreadStart event count\");\n+            throw new RuntimeException(\"Failed: wrong ThreadStart count: \" +\n+                                       startedThreads + \" expected: \" + THREAD_CNT);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VirtualThreadStartTest\/VirtualThreadStartTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -741,0 +741,2 @@\n+\n+  public native boolean setVirtualThreadsNotifyJvmtiMode(boolean enabled);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}