{"files":[{"patch":"@@ -76,0 +76,10 @@\n+void G1BarrierSet::update_card_table_base(Thread* thread) {\n+#ifdef ASSERT\n+  {\n+    ResourceMark rm;\n+    assert(thread->is_Java_thread(), \"may only update card table base of JavaThreads, not %s\", thread->name());\n+  }\n+#endif\n+  G1ThreadLocalData::set_byte_map_base(thread, _card_table->byte_map_base());\n+}\n+\n@@ -164,1 +174,2 @@\n-    G1ThreadLocalData::set_byte_map_base(thread, G1CollectedHeap::heap()->card_table_base());\n+    assert(Threads_lock->is_locked(), \"must be, synchronization with refinement.\");\n+    update_card_table_base(thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class Thread;\n@@ -84,0 +85,3 @@\n+  \/\/ Update the given thread's card table (byte map) base to the current card table's.\n+  void update_card_table_base(Thread* thread);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -803,0 +804,14 @@\n+\n+    if (!sweep_state.are_java_threads_synched()) {\n+      \/\/ Synchronize Java threads with global card table that has already been swapped.\n+      class SwapThreadCardTableClosure : public ThreadClosure {\n+      public:\n+\n+        virtual void do_thread(Thread* t) {\n+          G1BarrierSet* bs = G1BarrierSet::g1_barrier_set();\n+          bs->update_card_table_base(t);\n+        }\n+      } cl;\n+      Threads::java_threads_do(&cl);\n+    }\n+\n@@ -819,0 +834,1 @@\n+  _verifier->verify_card_tables_clean(true \/* both_card_tables *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    virtual void do_thread(Thread* t) {\n+    virtual void do_thread(Thread* thread) {\n@@ -222,1 +222,1 @@\n-      G1ThreadLocalData::set_byte_map_base(t, bs->card_table()->byte_map_base());\n+      bs->update_card_table_base(thread);\n@@ -377,0 +377,4 @@\n+bool G1ConcurrentRefineSweepState::are_java_threads_synched() const {\n+  return _state > State::SwapJavaThreadsCT || !is_in_progress();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+  bool are_java_threads_synched() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -530,0 +531,1 @@\n+  verify_card_tables_in_sync();\n@@ -581,1 +583,1 @@\n-class G1VerifyRefinementTableClean: public G1HeapRegionClosure {\n+class G1VerifyCardTablesClean: public G1HeapRegionClosure {\n@@ -583,0 +585,1 @@\n+  bool _both_card_tables;\n@@ -585,2 +588,2 @@\n-  G1VerifyRefinementTableClean(G1HeapVerifier* verifier)\n-    : _verifier(verifier) { }\n+  G1VerifyCardTablesClean(G1HeapVerifier* verifier, bool both_card_tables = true)\n+    : _verifier(verifier), _both_card_tables(both_card_tables) { }\n@@ -589,3 +592,4 @@\n-    G1CardTable* ct = G1CollectedHeap::heap()->refinement_table();\n-    MemRegion mr(r->bottom(), r->end());\n-    ct->verify_region(mr, G1CardTable::clean_card_val(), true); \/\/ Must be all Clean from bottom -> end.\n+    _verifier->verify_rt_clean_region(r);     \/\/ Must be all Clean from bottom -> end.\n+    if (_both_card_tables) {\n+      _verifier->verify_ct_clean_region(r);\n+    }\n@@ -596,2 +600,2 @@\n-void G1HeapVerifier::verify_refinement_table_clean() {\n-  G1VerifyRefinementTableClean cl(this);\n+void G1HeapVerifier::verify_card_tables_clean(bool both_card_tables) {\n+  G1VerifyCardTablesClean cl(this, both_card_tables);\n@@ -633,0 +637,34 @@\n+\n+void G1HeapVerifier::verify_card_tables_in_sync() {\n+\n+    \/\/ Non-Java thread card tables must be null.\n+    class AssertCardTableBaseNull : public ThreadClosure {\n+    public:\n+\n+      void do_thread(Thread* thread) {\n+        ResourceMark rm;\n+        assert(G1ThreadLocalData::get_byte_map_base(thread) == nullptr, \"thread \" PTR_FORMAT \" (%s) has non-null card table base\",\n+               p2i(thread), thread->name());\n+      }\n+    } check_null_cl;\n+\n+    Threads::non_java_threads_do(&check_null_cl);\n+\n+    \/\/ Java thread card tables must be the same as the global card table.\n+    class AssertSameCardTableClosure : public ThreadClosure {\n+    public:\n+\n+      void do_thread(Thread* thread) {\n+        G1CardTable::CardValue* global_ct_base = G1CollectedHeap::heap()->card_table_base();\n+        G1CardTable::CardValue* cur_ct_base = G1ThreadLocalData::get_byte_map_base(thread);\n+\n+        ResourceMark rm;\n+        assert(cur_ct_base == global_ct_base,\n+               \"thread \" PTR_FORMAT \" (%s) has wrong card table base, should be \" PTR_FORMAT \" is \" PTR_FORMAT,\n+               p2i(thread), thread->name(), p2i(global_ct_base), p2i(cur_ct_base));\n+      }\n+    } check_same_cl;\n+\n+    Threads::java_threads_do(&check_same_cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  void verify_refinement_table_clean();\n+  void verify_card_tables_clean(bool both_card_tables);\n@@ -88,0 +88,3 @@\n+\n+  \/\/ Verify that the global card table and the thread's card tables are in sync.\n+  void verify_card_tables_in_sync() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1291,1 +1291,1 @@\n-    g1h->verifier()->verify_refinement_table_clean();\n+    g1h->verifier()->verify_card_tables_clean(false \/* both_card_tables *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -842,11 +842,0 @@\n-\n-#ifdef ASSERT\n-    class AssertCardTableBaseNull : public ThreadClosure {\n-    public:\n-\n-      void do_thread(Thread* thread) {\n-        assert(G1ThreadLocalData::get_byte_map_base(thread) == nullptr, \"thread \" PTR_FORMAT \" (%s) has non-null card table base\", p2i(thread), thread->name());\n-      }\n-    } assert_cl;\n-    Threads::non_java_threads_do(&assert_cl);\n-#endif\n@@ -865,3 +854,1 @@\n-        \/\/ The global card table references have already been swapped.\n-        G1CardTable::CardValue* new_card_table_base = G1CollectedHeap::heap()->card_table_base();\n-        G1ThreadLocalData::set_byte_map_base(thread, new_card_table_base);\n+        G1BarrierSet::g1_barrier_set()->update_card_table_base(thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,5 @@\n+\/*\n+ * The next test stresses the interaction between (mostly) full garbage collections and refinement.\n+ *\/\n+\/* @test @key stress randomness @library \/vmTestbase \/test\/lib @run main\/othervm -XX:-G1UseAdaptiveIHOP -XX:InitiatingHeapOccupancyPercent=0 -XX:G1HeapRegionSize=1m -XX:G1RSetUpdatingPauseTimePercent=0 -XX:G1UpdateBufferSize=1 -XX:+UnlockDiagnosticVMOptions -XX:+VerifyAfterGC -Xlog:gc=debug,gc+refine=debug:gc.log gc.ArrayJuggle.Juggle2 -tg *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle2.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}