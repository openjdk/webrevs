{"files":[{"patch":"@@ -90,2 +90,8 @@\n-void G1BarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                             Register start, Register count, Register tmp, RegSet saved_regs) {\n+void G1BarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm,\n+                                                             DecoratorSet decorators,\n+                                                             Register start,\n+                                                             Register count,\n+                                                             Register tmp,\n+                                                             RegSet saved_regs) {\n+  assert_different_registers(start, count, tmp);\n+\n@@ -93,1 +99,0 @@\n-  const Register end = count;\n@@ -98,2 +103,6 @@\n-  __ shadd(end, count, start, tmp, LogBytesPerHeapOop); \/\/ end = start + count << LogBytesPerHeapOop\n-  __ subi(end, end, BytesPerHeapOop);                   \/\/ last element address to make inclusive\n+  \/\/ Calculate the number of card marks to set. Since the object might start and\n+  \/\/ end within a card, we need to calculate this via the card table indexes of\n+  \/\/ the actual start and last addresses covered by the object.\n+  \/\/ Temporarily use the count register for the last element address.\n+  __ shadd(count, count, start, tmp, LogBytesPerHeapOop); \/\/ end = start + count << LogBytesPerHeapOop\n+  __ subi(count, count, BytesPerHeapOop);                 \/\/ Use last element address for end.\n@@ -102,2 +111,2 @@\n-  __ srli(end, end, CardTable::card_shift());\n-  __ sub(count, end, start);                            \/\/ Number of bytes to mark - 1\n+  __ srli(count, count, CardTable::card_shift());\n+  __ sub(count, count, start);                            \/\/ Number of bytes to mark - 1.\n@@ -105,0 +114,1 @@\n+  \/\/ Add card table base offset to start.\n@@ -112,1 +122,0 @@\n-    static_assert((uint)G1CardTable::clean_card_val() == 0xff, \"must be\");\n@@ -114,2 +123,3 @@\n-    __ subi(tmp, tmp, G1CardTable::clean_card_val());   \/\/ Convert to clean_card_value() to a comparison\n-                                                        \/\/ against zero to avoid use of an extra temp.\n+    static_assert((uint)G1CardTable::clean_card_val() == 0xff, \"must be\");\n+    __ subi(tmp, tmp, G1CardTable::clean_card_val()); \/\/ Convert to clean_card_value() to a comparison\n+                                                      \/\/ against zero to avoid use of an extra temp.\n@@ -118,1 +128,1 @@\n-  static_assert(G1CardTable::dirty_card_val() == 0, \"must be to use zr\");\n+\n@@ -120,0 +130,1 @@\n+  static_assert(G1CardTable::dirty_card_val() == 0, \"must be to use zr\");\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"}]}