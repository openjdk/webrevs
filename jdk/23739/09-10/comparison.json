{"files":[{"patch":"@@ -78,1 +78,1 @@\n-  if (max_num_threads() > 0) {\n+  if (is_refinement_enabled()) {\n@@ -108,1 +108,1 @@\n-  if (_control_thread != nullptr) {\n+  if (is_refinement_enabled()) {\n@@ -114,1 +114,1 @@\n-  if (_control_thread != nullptr) {\n+  if (is_refinement_enabled()) {\n@@ -120,1 +120,1 @@\n-  if (_control_thread != nullptr) {\n+  if (is_refinement_enabled()) {\n@@ -341,2 +341,5 @@\n-  \/\/ G1CollectedHeap::heap_region_iterate() below will only visit committed regions. Initialize\n-  \/\/ all entries in the state table here to not require special handling when iterating over it.\n+  \/\/ G1CollectedHeap::heap_region_iterate() below will only visit currently committed\n+  \/\/ regions. Initialize all entries in the state table here and later in this method\n+  \/\/ selectively enable regions that we are interested. This way regions committed\n+  \/\/ later will be automatically excluded from iteration.\n+  \/\/ Their refinement table must be completely empty anyway.\n@@ -354,1 +357,1 @@\n-        \/\/ No need for synchronization: we are only interested about regions\n+        \/\/ No need for synchronization: we are only interested in regions\n@@ -398,1 +401,1 @@\n-  bool has_sweep_claims = sweep_state().complete_work(false);\n+  bool has_sweep_claims = sweep_state().complete_work(false \/* concurrent *\/);\n@@ -488,1 +491,1 @@\n-  if (_thread_control.max_num_threads() != 0) {\n+  if (_thread_control.is_refinement_enabled()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  bool is_refinement_enabled() const { return _max_num_threads > 0; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    } else if (res == G1RemSet::HasToCSetRef) {\n+    } else if (res == G1RemSet::HasRefToCSet) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineWorkTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,2 +205,2 @@\n-  bool _has_to_cset_ref;\n-  bool _has_to_old_ref;\n+  bool _has_ref_to_cset;\n+  bool _has_ref_to_old;\n@@ -212,2 +212,2 @@\n-    _has_to_cset_ref(false),\n-    _has_to_old_ref(false) {\n+    _has_ref_to_cset(false),\n+    _has_ref_to_old(false) {\n@@ -216,2 +216,2 @@\n-  bool has_to_cset_ref() const { return _has_to_cset_ref; }\n-  bool has_to_old_ref() const { return _has_to_old_ref; }\n+  bool has_ref_to_cset() const { return _has_ref_to_cset; }\n+  bool has_ref_to_old() const { return _has_ref_to_old; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  if (_has_to_cset_ref) {\n+  if (_has_ref_to_cset) {\n@@ -155,2 +155,2 @@\n-  _has_to_cset_ref = to_region->is_young();\n-  if (_has_to_cset_ref) {\n+  _has_ref_to_cset = to_region->is_young();\n+  if (_has_ref_to_cset) {\n@@ -167,1 +167,1 @@\n-      _has_to_old_ref = true;\n+      _has_ref_to_old = true;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,0 +105,8 @@\n+  \/\/ Tracks the number of cards marked as dirty (only) during garbage collection\n+  \/\/ (evacuation) on the card table.\n+  \/\/ This is needed to properly account for those cards in the heuristics to start\n+  \/\/ refinement at the correct time which needs to know how many cards are currently\n+  \/\/ approximately on the card table.\n+  \/\/ After the first completed refinement sweep of the refinement table between two\n+  \/\/ garbage collections this value is reset to zero as that refinement processed all\n+  \/\/ those cards.\n@@ -106,0 +114,2 @@\n+  \/\/ Tracks the approximate number of cards found as to-collection-set by either the\n+  \/\/ garbage collection or the most recent refinement sweep.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1361,4 +1361,4 @@\n-    if (conc_refine_cl.has_to_cset_ref()) {\n-      return HasToCSetRef;\n-    } else if (conc_refine_cl.has_to_old_ref()) {\n-      return HasToOldRef;\n+    if (conc_refine_cl.has_ref_to_cset()) {\n+      return HasRefToCSet;\n+    } else if (conc_refine_cl.has_ref_to_old()) {\n+      return HasRefToOld;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-      HasToCSetRef,          \/\/ The (dirty) card has a reference to the collection set.\n+      HasRefToCSet,          \/\/ The (dirty) card has a reference to the collection set.\n@@ -125,1 +125,1 @@\n-      HasToOldRef,           \/\/ The dirty cards contains references to other old regions (not the collection set).\n+      HasRefToOld,           \/\/ The dirty card contains references to other old regions (not the collection set).\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}