{"files":[{"patch":"@@ -54,1 +54,1 @@\n-\/\/ The refinement threads mark cards in the the current collection set specially on the\n+\/\/ The refinement threads mark cards in the current collection set specially on the\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+\/\/\n+\/\/ Example:\n+\/\/ a      = 0xAAAAAAAA\n+\/\/ b      = 0xBBBBBBBB\n+\/\/ mask   = 0xFF00FF00\n+\/\/ result = 0xBBAABBAA\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-void G1CardTableClaimTable::initialize(size_t max_reserved_regions) {\n+void G1CardTableClaimTable::initialize(uint max_reserved_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTableClaimTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  size_t _max_reserved_regions;\n+  uint _max_reserved_regions;\n@@ -60,1 +60,1 @@\n-  void initialize(size_t max_reserved_regions);\n+  void initialize(uint max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTableClaimTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  _sweep_state(new G1CardTableClaimTable(G1CollectedHeap::get_chunks_per_region_for_merge())),\n+  _sweep_table(new G1CardTableClaimTable(G1CollectedHeap::get_chunks_per_region_for_merge())),\n@@ -131,1 +131,1 @@\n-  _sweep_state->initialize(max_reserved_regions);\n+  _sweep_table->initialize(max_reserved_regions);\n@@ -135,1 +135,1 @@\n-  delete _sweep_state;\n+  delete _sweep_table;\n@@ -267,2 +267,3 @@\n-void G1ConcurrentRefineWorkState::snapshot_heap() {\n-  assert_state(State::SnapshotHeap);\n+void G1ConcurrentRefineWorkState::snapshot_heap(bool concurrent) {\n+  if (concurrent) {\n+    assert_state(State::SnapshotHeap);\n@@ -270,1 +271,4 @@\n-  set_state_start_time();\n+    set_state_start_time();\n+  } else {\n+    assert(is_in_progress() && _state < State::SnapshotHeap, \"Must be before %s but is %s\", state_name(State::SnapshotHeap), state_name(_state));\n+  }\n@@ -272,1 +276,1 @@\n-  snapshot_heap_into(_sweep_state);\n+  snapshot_heap_into(_sweep_table);\n@@ -274,1 +278,3 @@\n-  advance_state(State::SweepRT);\n+  if (concurrent) {\n+    advance_state(State::SweepRT);\n+  }\n@@ -277,1 +283,1 @@\n-bool G1ConcurrentRefineWorkState::sweep_rt_step() {\n+void G1ConcurrentRefineWorkState::sweep_rt_start() {\n@@ -281,0 +287,4 @@\n+}\n+\n+bool G1ConcurrentRefineWorkState::sweep_rt_step() {\n+  assert_state(State::SweepRT);\n@@ -284,1 +294,1 @@\n-  G1ConcurrentRefineWorkTask task(_sweep_state, &_stats, cr->num_threads_wanted());\n+  G1ConcurrentRefineWorkTask task(_sweep_table, &_stats, cr->num_threads_wanted());\n@@ -335,2 +345,4 @@\n-void G1ConcurrentRefineWorkState::snapshot_heap_into(G1CardTableClaimTable* sweep_state) {\n-  sweep_state->reset_all_claims_to_claimed();\n+void G1ConcurrentRefineWorkState::snapshot_heap_into(G1CardTableClaimTable* sweep_table) {\n+  \/\/ G1CollectedHeap::heap_region_iterate() will only visit committed regions. In the\n+  \/\/ state table \n+  sweep_table->reset_all_claims_to_claimed();\n@@ -339,1 +351,1 @@\n-    G1CardTableClaimTable* _sweep_state;\n+    G1CardTableClaimTable* _sweep_table;\n@@ -342,5 +354,1 @@\n-    size_t _num_clean;\n-    size_t _num_dirty;\n-    size_t _num_to_cset;\n-\n-    SnapshotRegionsClosure(G1CardTableClaimTable* sweep_state) : G1HeapRegionClosure(), _sweep_state(sweep_state), _num_clean(0), _num_dirty(0), _num_to_cset(0) { }\n+    SnapshotRegionsClosure(G1CardTableClaimTable* sweep_table) : G1HeapRegionClosure(), _sweep_table(sweep_table) { }\n@@ -355,1 +363,1 @@\n-        _sweep_state->reset_to_unclaimed(r->hrm_index());\n+        _sweep_table->reset_to_unclaimed(r->hrm_index());\n@@ -359,1 +367,1 @@\n-  } cl(sweep_state);\n+  } cl(sweep_table);\n@@ -394,0 +402,17 @@\n+G1ConcurrentRefineWorkState& G1ConcurrentRefine::refine_state_for_merge() {\n+  bool has_sweep_claims = refine_state().complete(false);\n+  if (has_sweep_claims) {\n+    log_debug(gc, refine)(\"Continue existing work\");\n+  } else {\n+    \/\/ Refinement has been interrupted without having a snapshot. There may\n+    \/\/ be a mix of already swapped and not-swapped card tables assigned to threads,\n+    \/\/ so they might have already dirtied the swapped card tables.\n+    \/\/ Conservatively scan all (non-free, non-committed) region's card tables,\n+    \/\/ creating the snapshot right now.\n+    log_debug(gc, refine)(\"Create work from scratch\");\n+\n+    refine_state().snapshot_heap(false \/* concurrent *\/);\n+  }\n+  return refine_state();\n+}\n+\n@@ -401,1 +426,1 @@\n-    _refine_state.sweep_state()->claim_all_cards(r->hrm_index());\n+    _refine_state.sweep_table()->claim_all_cards(r->hrm_index());\n@@ -520,1 +545,1 @@\n-\/\/ Adjust the target length (in regions) of the young gen, based on the the\n+\/\/ Adjust the target length (in regions) of the young gen, based on the\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  G1CardTableClaimTable* _sweep_state;\n+  G1CardTableClaimTable* _sweep_table;\n@@ -143,1 +143,2 @@\n-  void snapshot_heap();\n+  void snapshot_heap(bool concurrent = true);\n+  void sweep_rt_start();\n@@ -148,1 +149,1 @@\n-  static void snapshot_heap_into(G1CardTableClaimTable* sweep_state);\n+  static void snapshot_heap_into(G1CardTableClaimTable* sweep_table);\n@@ -150,1 +151,1 @@\n-  G1CardTableClaimTable* sweep_state() { return _sweep_state; }\n+  G1CardTableClaimTable* sweep_table() { return _sweep_table; }\n@@ -234,0 +235,2 @@\n+  G1ConcurrentRefineWorkState& refine_state_for_merge();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -180,0 +180,2 @@\n+\n+  state.sweep_rt_start();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  G1CardTableClaimTable _card_state;\n+  G1CardTableClaimTable _card_claim_table;\n@@ -145,3 +145,3 @@\n-    if (_contains[region]) {\n-      return;\n-    }\n+      if (_contains[region]) {\n+        return;\n+      }\n@@ -149,1 +149,1 @@\n-    bool marked_as_dirty = Atomic::cmpxchg(&_contains[region], false, true) == false;\n+      bool marked_as_dirty = Atomic::cmpxchg(&_contains[region], false, true) == false;\n@@ -237,1 +237,1 @@\n-    _card_state(G1CollectedHeap::get_chunks_per_region_for_scan()),\n+    _card_claim_table(G1CollectedHeap::get_chunks_per_region_for_scan()),\n@@ -246,2 +246,2 @@\n-  void initialize(size_t max_reserved_regions) {\n-    _card_state.initialize(max_reserved_regions);\n+  void initialize(uint max_reserved_regions) {\n+    _card_claim_table.initialize(max_reserved_regions);\n@@ -256,1 +256,1 @@\n-    size_t max_reserved_regions = _card_state.max_reserved_regions();\n+    size_t max_reserved_regions = _card_claim_table.max_reserved_regions();\n@@ -271,1 +271,1 @@\n-    _card_state.reset_all_claims_to_unclaimed();\n+    _card_claim_table.reset_all_claims_to_unclaimed();\n@@ -334,1 +334,1 @@\n-    return _card_state.has_unclaimed_cards(region);\n+    return _card_claim_table.has_unclaimed_cards(region);\n@@ -370,1 +370,1 @@\n-    return G1CardTableChunkClaimer(&_card_state, region_idx);\n+    return G1CardTableChunkClaimer(&_card_claim_table, region_idx);\n@@ -830,1 +830,1 @@\n-        size_t* card_cur_card = (size_t*)card_table->byte_for_index(start_idx);\n+        size_t* card_cur_word = (size_t*)card_table->byte_for_index(start_idx);\n@@ -835,1 +835,1 @@\n-        for (; refinement_cur_card < refinement_end_card; ++refinement_cur_card, ++card_cur_card) {\n+        for (; refinement_cur_card < refinement_end_card; ++refinement_cur_card, ++card_cur_word) {\n@@ -842,2 +842,2 @@\n-          size_t new_value = *card_cur_card & value;\n-          *card_cur_card = new_value;\n+          size_t new_value = *card_cur_word & value;\n+          *card_cur_word = new_value;\n@@ -1233,21 +1233,1 @@\n-  G1CardTableClaimTable* claim;\n-  G1CardTableClaimTable constructed(G1CollectedHeap::get_chunks_per_region_for_merge());\n-\n-  G1ConcurrentRefineWorkState& state = g1h->concurrent_refine()->refine_state();\n-  bool has_sweep_claims = state.complete(false);\n-  if (has_sweep_claims) {\n-    log_debug(gc, refine)(\"Continue existing work\");\n-    claim = state.sweep_state();\n-  } else {\n-    \/\/ Refinement has been interrupted without having a snapshot. There may\n-    \/\/ be a mix of already swapped and not-swapped card tables assigned to threads,\n-    \/\/ so they might have already dirtied the swapped card tables.\n-    \/\/ Conservatively scan all (non-free, non-committed) region's card tables,\n-    \/\/ creating the snapshot right now.\n-    log_debug(gc, refine)(\"Create work from scratch\");\n-\n-    constructed.initialize(g1h->max_reserved_regions());\n-    G1ConcurrentRefineWorkState::snapshot_heap_into(&constructed);\n-    claim = &constructed;\n-  }\n-\n+  G1ConcurrentRefineWorkState& state = g1h->concurrent_refine()->refine_state_for_merge();\n@@ -1256,1 +1236,1 @@\n-  MergeRefinementTableTask cl(claim, workers->active_workers());\n+  MergeRefinementTableTask cl(state.sweep_table(), workers->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":18,"deletions":38,"binary":false,"changes":56,"status":"modified"}]}