{"files":[{"patch":"@@ -323,0 +323,4 @@\n+  bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -6153,35 +6157,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -6210,0 +6179,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -313,0 +313,4 @@\n+  bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -4400,35 +4404,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -4457,0 +4426,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1002,0 +1002,4 @@\n+bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2153,0 +2153,4 @@\n+bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+  bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n@@ -4535,35 +4538,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffleB(vReg dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"loadshuffleB $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ For T_BYTE, no need to do anything\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct loadshuffleX(vReg dst, vReg src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE ||\n-            Matcher::vector_element_basic_type(n) == T_LONG ||\n-            Matcher::vector_element_basic_type(n) == T_FLOAT ||\n-            Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"loadshuffleX $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    if (bt == T_SHORT) {\n-      __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    } else if (bt == T_FLOAT || bt == T_INT) {\n-      __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    } else { \/\/ bt == T_DOUBLE || bt == T_LONG\n-      __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1476,0 +1476,4 @@\n+bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2171,0 +2171,13 @@\n+\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n+bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  switch (elem_bt) {\n+    case T_BYTE:  return false;\n+    case T_SHORT: return !VM_Version::supports_avx512bw();\n+    case T_INT:   return !VM_Version::supports_avx();\n+    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n@@ -8700,11 +8713,0 @@\n-\n-instruct loadShuffleB(vec dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"vector_load_shuffle $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8777,1 +8779,1 @@\n-            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            !VM_Version::supports_avx512bw());\n@@ -8788,1 +8790,1 @@\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8803,2 +8805,1 @@\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8851,15 +8852,0 @@\n-instruct loadShuffleS_evex(vec dst, vec src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n-            VM_Version::supports_avx512bw());\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (!VM_Version::supports_avx512vl()) {\n-      vlen_enc = Assembler::AVX_512bit;\n-    }\n-    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8896,1 +8882,1 @@\n-    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8925,12 +8911,0 @@\n-instruct loadShuffleI_avx(vec dst, vec src) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n-            UseAVX > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8966,2 +8940,1 @@\n-    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8993,14 +8966,0 @@\n-instruct loadShuffleL_evex(vec dst, vec src) %{\n-  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":59,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -993,27 +993,0 @@\n-  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n-   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n-                                               \"IIII\"                                                                                          \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n-   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n-   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n-                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n-   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name,                              \\\n-                                                                                                         vector_wrap_shuffle_indexes_sig, F_S) \\\n-   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava\/lang\/Class;\"                                                                          \\\n-                                                  \"Ljava\/lang\/Class;\"                                                                          \\\n-                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                       \\\n-                                                  \"ILjdk\/internal\/vm\/vector\/VectorSupport$WrapShuffleIndexesOperation;)\"                       \\\n-                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                      \\\n-   do_name(vector_wrap_shuffle_indexes_name, \"wrapShuffleIndexes\")                                                                             \\\n-                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -812,3 +812,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-  case vmIntrinsics::_VectorShuffleToVector:\n-  case vmIntrinsics::_VectorWrapShuffleIndexes:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -910,1 +910,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -714,2 +714,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-    return inline_vector_shuffle_iota();\n@@ -718,4 +716,0 @@\n-  case vmIntrinsics::_VectorShuffleToVector:\n-    return inline_vector_shuffle_to_vector();\n-  case vmIntrinsics::_VectorWrapShuffleIndexes:\n-    return inline_vector_wrap_shuffle_indexes();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -355,4 +355,0 @@\n-  bool inline_vector_shuffle_to_vector();\n-  bool inline_vector_wrap_shuffle_indexes();\n-  bool inline_vector_shuffle_iota();\n-  Node* partially_wrap_indexes(Node* index_vec, int num_elem, BasicType type_bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,0 +344,2 @@\n+  static bool vector_needs_load_shuffle(BasicType elem_bt, int vlen);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -463,2 +458,0 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n@@ -509,3 +502,0 @@\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -165,1 +161,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -176,1 +172,1 @@\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n@@ -514,131 +510,1 @@\n-\/\/ Following routine generates IR corresponding to AbstractShuffle::partiallyWrapIndex method,\n-\/\/ which partially wraps index by modulo VEC_LENGTH and generates a negative index value if original\n-\/\/ index is out of valid index range [0, VEC_LENGTH)\n-\/\/\n-\/\/   wrapped_index = (VEC_LENGTH - 1) & index\n-\/\/   if (index u> VEC_LENGTH) {\n-\/\/     wrapped_index -= VEC_LENGTH;\n-\/\/\n-\/\/ Note: Unsigned greater than comparison treat both <0 and >VEC_LENGTH indices as out-of-bound\n-\/\/ indexes.\n-Node* LibraryCallKit::partially_wrap_indexes(Node* index_vec, int num_elem, BasicType elem_bt) {\n-  assert(elem_bt == T_BYTE, \"Shuffles use byte array based backing storage.\");\n-  const TypeVect* vt  = TypeVect::make(elem_bt, num_elem);\n-  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n-\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, type_bt));\n-\n-  BoolTest::mask pred = BoolTest::ugt;\n-  ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(pred));\n-  Node* lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n-  Node*  mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n-\n-  \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n-  index_vec = gvn().transform(VectorNode::make(Op_AndV, index_vec, bcast_mod_mask, vt));\n-  Node* biased_val = gvn().transform(VectorNode::make(Op_SubVB, index_vec, bcast_lane_cnt, vt));\n-  return gvn().transform(new VectorBlendNode(biased_val, index_vec, mask));\n-}\n-\n-\/\/ <Sh extends VectorShuffle<E>,  E>\n-\/\/  Sh ShuffleIota(Class<?> E, Class<?> shuffleClass, Vector.Species<E> s, int length,\n-\/\/                  int start, int step, int wrap, ShuffleIotaOperation<Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_iota() {\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n-  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n-  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n-  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n-\n-  if (shuffle_klass == nullptr || shuffle_klass->const_oop() == nullptr ||\n-      vlen == nullptr || !vlen->is_con() || start_val == nullptr || step_val == nullptr ||\n-      wrap == nullptr || !wrap->is_con()) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-\n-  if (!is_klass_initialized(shuffle_klass)) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int do_wrap = wrap->get_con();\n-  int num_elem = vlen->get_con();\n-  BasicType elem_bt = T_BYTE;\n-\n-  bool effective_indices_in_range = false;\n-  if (start_val->is_con() && step_val->is_con()) {\n-    int effective_min_index = start_val->get_con();\n-    int effective_max_index = start_val->get_con() + step_val->get_con() * (num_elem - 1);\n-    effective_indices_in_range = effective_max_index >= effective_min_index && effective_min_index >= -128 && effective_max_index <= 127;\n-  }\n-\n-  if (!do_wrap && !effective_indices_in_range) {\n-    \/\/ Disable instrinsification for unwrapped shuffle iota if start\/step\n-    \/\/ values are non-constant OR if intermediate result overflows byte value range.\n-    return false;\n-  }\n-\n-  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)           ||\n-      !arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)            ||\n-      !arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n-      !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-\n-  if (!do_wrap &&\n-      (!arch_supports_vector(Op_SubVB, num_elem, elem_bt, VecMaskNotUsed)       ||\n-      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskNotUsed)  ||\n-      !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed))) {\n-    return false;\n-  }\n-\n-  bool step_multiply = !step_val->is_con() || !is_power_of_2(step_val->get_con());\n-  if ((step_multiply && !arch_supports_vector(Op_MulVB, num_elem, elem_bt, VecMaskNotUsed)) ||\n-      (!step_multiply && !arch_supports_vector(Op_LShiftVB, num_elem, elem_bt, VecMaskNotUsed))) {\n-    return false;\n-  }\n-\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n-\n-  Node* res = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n-\n-  Node* start = argument(4);\n-  Node* step  = argument(5);\n-\n-  if (step_multiply) {\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n-    res = gvn().transform(VectorNode::make(Op_MulVB, res, bcast_step, vt));\n-  } else if (step_val->get_con() > 1) {\n-    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n-    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n-    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n-  }\n-\n-  if (!start_val->is_con() || start_val->get_con() != 0) {\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n-    res = gvn().transform(VectorNode::make(Op_AddVB, res, bcast_start, vt));\n-  }\n-\n-  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n-\n-  if (do_wrap)  {\n-    \/\/ Wrap the indices greater than lane count.\n-    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n-  } else {\n-    res = partially_wrap_indexes(res, num_elem, elem_bt);\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Wrap it up in VectorBox to keep object type information.\n-  res = box_vector(res, shuffle_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n+\/\/ public static\n@@ -678,1 +544,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -699,119 +565,0 @@\n-\/\/ public static\n-\/\/ <V,\n-\/\/  Sh extends VectorShuffle<E>,\n-\/\/  E>\n-\/\/ V shuffleToVector(Class<? extends Vector<E>> vclass, Class<E> elementType,\n-\/\/                   Class<? extends Sh> shuffleClass, Sh s, int length,\n-\/\/                   ShuffleToVectorOperation<V, Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_to_vector() {\n-  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n-  Node*              shuffle       = argument(3);\n-  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n-\n-  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-  if (!is_klass_initialized(shuffle_klass) || !is_klass_initialized(vector_klass) ) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int num_elem = vlen->get_con();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType elem_bt = elem_type->basic_type();\n-\n-  if (num_elem < 4) {\n-    return false;\n-  }\n-\n-  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n-  \/\/ Make sure that cast is implemented to particular type\/size combination.\n-  if (!arch_supports_vector(cast_vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-        cast_vopc, num_elem, type2name(elem_bt));\n-    return false;\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n-\n-  \/\/ cast byte to target element type\n-  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n-\n-  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* vec_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n-\n-  \/\/ Box vector\n-  Node* res = box_vector(shuffle_vec, vec_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n-\/\/ public static\n-\/\/ <E,\n-\/\/  SH extends VectorShuffle<E>>\n-\/\/ SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n-\/\/                       ShuffleWrapIndexesOperation<SH> defaultImpl)\n-bool LibraryCallKit::inline_vector_wrap_shuffle_indexes() {\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(0))->isa_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n-  Node*              shuffle       = argument(2);\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n-\n-  if (elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr ||\n-      !vlen->is_con() || shuffle_klass->const_oop() == nullptr) {\n-    \/\/ not enough info for intrinsification\n-    return false;\n-  }\n-\n-  if (!is_klass_initialized(shuffle_klass)) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int num_elem = vlen->get_con();\n-  if ((num_elem < 4) || !is_power_of_2(num_elem)) {\n-    log_if_needed(\"  ** vlen < 4 or not power of two=%d\", num_elem);\n-    return false;\n-  }\n-\n-  \/\/ Shuffles use byte array based backing storage\n-  BasicType shuffle_bt = T_BYTE;\n-  if (!arch_supports_vector(Op_AndV, num_elem, shuffle_bt, VecMaskNotUsed) ||\n-      !arch_supports_vector(Op_Replicate, num_elem, shuffle_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: op=wrapShuffleIndexes vlen=%d etype=%s\",\n-                  num_elem, type2name(shuffle_bt));\n-    return false;\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, shuffle_bt, num_elem, true);\n-\n-  const TypeVect* vt  = TypeVect::make(shuffle_bt, num_elem);\n-  const Type* shuffle_type_bt = Type::get_const_basic_type(shuffle_bt);\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_type_bt));\n-  \/\/ Wrap the indices greater than lane count.\n-  Node* res = gvn().transform(VectorNode::make(Op_AndV, shuffle_vec, bcast_mod_mask, vt));\n-\n-  \/\/ Wrap it up in VectorBox to keep object type information.\n-  res = box_vector(res, shuffle_box_type, shuffle_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(shuffle_bt))));\n-  return true;\n-}\n-\n@@ -1998,0 +1745,1 @@\n+\n@@ -2000,0 +1748,6 @@\n+  if (shuffle_bt == T_FLOAT) {\n+    shuffle_bt = T_INT;\n+  } else if (shuffle_bt == T_DOUBLE) {\n+    shuffle_bt = T_LONG;\n+  }\n+\n@@ -2001,0 +1755,1 @@\n+  bool need_load_shuffle = Matcher::vector_needs_load_shuffle(shuffle_bt, num_elem);\n@@ -2002,3 +1757,5 @@\n-  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n-                    num_elem, type2name(elem_bt));\n+  if (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, shuffle_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n+                    num_elem, type2name(shuffle_bt));\n+    }\n@@ -2016,0 +1773,5 @@\n+  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=2 op=and vlen=%d etype=%s ismask=no\",\n+                      num_elem, type2name(elem_bt));\n+    return false;\n+  }\n@@ -2036,0 +1798,2 @@\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n@@ -2041,0 +1805,5 @@\n+  assert(is_power_of_2(num_elem), \"wrapping invalid\");\n+  Node* wrapping_mask_elem = shuffle_bt == T_LONG ? (Node*)gvn().longcon(num_elem - 1) : gvn().intcon(num_elem - 1);\n+  Node* wrapping_mask = gvn().transform(VectorNode::scalar2vector(wrapping_mask_elem, num_elem, Type::get_const_basic_type(shuffle_bt)));\n+  shuffle = gvn().transform(new AndVNode(shuffle, wrapping_mask, st));\n+\n@@ -2053,0 +1822,4 @@\n+  if (need_load_shuffle) {\n+    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, st));\n+  }\n+\n@@ -2059,1 +1832,0 @@\n-      const TypeVect* vt = v1->bottom_type()->is_vect();\n@@ -2473,3 +2245,1 @@\n-  if (is_vector_shuffle(vbox_klass_from)) {\n-    return false; \/\/ vector shuffles aren't supported\n-  }\n+\n@@ -2515,12 +2285,0 @@\n-\n-  if (is_vector_shuffle(vbox_klass_to) &&\n-      (!arch_supports_vector(Op_SubVB, num_elem_to, elem_bt_to, VecMaskNotUsed)           ||\n-       !arch_supports_vector(Op_VectorBlend, num_elem_to, elem_bt_to, VecMaskNotUsed)     ||\n-       !arch_supports_vector(Op_VectorMaskCmp, num_elem_to, elem_bt_to, VecMaskNotUsed)   ||\n-       !arch_supports_vector(Op_AndV, num_elem_to, elem_bt_to, VecMaskNotUsed)            ||\n-       !arch_supports_vector(Op_Replicate, num_elem_to, elem_bt_to, VecMaskNotUsed))) {\n-    log_if_needed(\"  ** not supported: arity=1 op=shuffle_index_wrap vlen2=%d etype2=%s\",\n-                    num_elem_to, type2name(elem_bt_to));\n-    return false;\n-  }\n-\n@@ -2624,4 +2382,0 @@\n-  if (is_vector_shuffle(vbox_klass_to)) {\n-     op = partially_wrap_indexes(op, num_elem_to, elem_bt_to);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":34,"deletions":280,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -1727,2 +1727,1 @@\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+        bool is_vector_mask = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -1733,5 +1732,0 @@\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n@@ -1739,1 +1733,1 @@\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n+          \/\/ Vector type mismatch is only supported for masks, but sometimes it happens in pathological cases.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1618,3 +1618,1 @@\n-    : VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n-  }\n+    : VectorNode(in, vt) {}\n@@ -1622,1 +1620,0 @@\n-  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1861,2 +1858,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1866,1 +1861,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1868,1 +1863,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1879,1 +1873,0 @@\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,4 +76,0 @@\n-bool VectorSupport::is_vector_shuffle(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorShuffle_klass());\n-}\n-\n@@ -90,3 +86,1 @@\n-  if (is_vector_shuffle(ik)) {\n-    return T_BYTE;\n-  } else if (is_vector_mask(ik)) {\n+  if (is_vector_mask(ik)) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,0 @@\n-  static bool is_vector_shuffle(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,50 +230,0 @@\n-    \/* ============================================================================ *\/\n-    public interface ShuffleIotaOperation<S extends VectorSpecies<?>,\n-                                          SH extends VectorShuffle<?>> {\n-        SH apply(int length, int start, int step, S s);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <E,\n-     S extends VectorSpecies<E>,\n-     SH extends VectorShuffle<E>>\n-    SH shuffleIota(Class<E> eClass, Class<? extends SH> shClass, S s,\n-                   int length,\n-                   int start, int step, int wrap,\n-                   ShuffleIotaOperation<S, SH> defaultImpl) {\n-       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-       return defaultImpl.apply(length, start, step, s);\n-    }\n-\n-    public interface ShuffleToVectorOperation<V extends Vector<?>,\n-                                              SH extends VectorShuffle<?>> {\n-       V apply(SH sh);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <V extends Vector<E>,\n-     SH extends VectorShuffle<E>,\n-     E>\n-    V shuffleToVector(Class<? extends Vector<E>> vClass, Class<E> eClass, Class<? extends SH> shClass, SH sh,\n-                      int length,\n-                      ShuffleToVectorOperation<V, SH> defaultImpl) {\n-      assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-      return defaultImpl.apply(sh);\n-    }\n-\n-    public interface WrapShuffleIndexesOperation<SH extends VectorShuffle<?>> {\n-        SH apply(SH sh);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <E,\n-     SH extends VectorShuffle<E>>\n-    SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n-                          WrapShuffleIndexesOperation<SH> defaultImpl) {\n-       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-       return defaultImpl.apply(sh);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.vector.VectorSupport;\n@@ -33,1 +34,1 @@\n-    \/\/ Internal representation allows for a maximum index of 256\n+    \/\/ Internal representation allows for a maximum index of E.MAX_VALUE - 1\n@@ -36,40 +37,2 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n-\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = reorder[offset + i];\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n-            int si = f.applyAsInt(i);\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n+    AbstractShuffle(Object indices) {\n+        super(indices);\n@@ -87,1 +50,3 @@\n-    @Override\n+    \/*package-private*\/\n+    abstract AbstractVector<?> toBitsVector();\n+\n@@ -89,8 +54,9 @@\n-    public void intoArray(int[] a, int offset) {\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n-        for (int i = 0; i < vlen; i++) {\n-            int sourceIndex = reorder[i];\n-            assert(sourceIndex >= -vlen && sourceIndex < vlen);\n-            a[offset + i] = sourceIndex;\n-        }\n+    final AbstractVector<?> toBitsVectorTemplate() {\n+        AbstractSpecies<?> dsp = vspecies().asIntegral();\n+        Class<?> etype = dsp.elementType();\n+        Class<?> rvtype = dsp.dummyVector().getClass();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                                     getClass(), etype, length(),\n+                                     rvtype, etype, length(),\n+                                     this, dsp,\n+                                     (v, s) -> v.toBitsVector0());\n@@ -99,0 +65,2 @@\n+    abstract AbstractVector<?> toBitsVector0();\n+\n@@ -101,5 +69,4 @@\n-    public int[] toArray() {\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n-        intoArray(a, 0);\n-        return a;\n+    public final int[] toArray() {\n+        int[] res = new int[length()];\n+        intoArray(res, 0);\n+        return res;\n@@ -108,1 +75,1 @@\n-    \/*package-private*\/\n+    @Override\n@@ -110,9 +77,5 @@\n-    final\n-    AbstractVector<E>\n-    toVectorTemplate() {\n-        \/\/ Note that the values produced by laneSource\n-        \/\/ are already clipped.  At this point we convert\n-        \/\/ them from internal ints (or bytes) into the ETYPE.\n-        \/\/ FIXME: Use a conversion intrinsic for this operation.\n-        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8225740\n-        return (AbstractVector<E>) vspecies().fromIntValues(toArray());\n+    public final <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+        if (length() != s.length()) {\n+            throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+        }\n+        return toBitsVector().bitsToShuffle((AbstractSpecies<F>) s);\n@@ -121,0 +84,1 @@\n+    @Override\n@@ -126,13 +90,2 @@\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n-        if (vecmask.anyTrue()) {\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n-        }\n-        return this;\n-    }\n-\n-    @ForceInline\n-    public final VectorShuffle<E> wrapIndexesTemplate() {\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n+        Vector<?> shufvec = this.toBitsVector();\n+        VectorMask<?> vecmask = shufvec.compare(VectorOperators.LT, 0);\n@@ -140,3 +93,2 @@\n-            \/\/ FIXME: vectorize this\n-            byte[] reorder = reorder();\n-            return wrapAndRebuild(reorder);\n+            int[] indices = toArray();\n+            throw checkIndexFailed(indices[vecmask.firstTrue()], length());\n@@ -147,25 +99,0 @@\n-    @ForceInline\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = oldReorder[i];\n-            \/\/ FIXME: This does not work unless it's a power of 2.\n-            if ((length & (length - 1)) == 0) {\n-                si += si & length;  \/\/ power-of-two optimization\n-            } else if (si < 0) {\n-                \/\/ non-POT code requires a conditional add\n-                si += length;\n-            }\n-            assert(si >= 0 && si < length);\n-            reorder[i] = (byte) si;\n-        }\n-        return vspecies().dummyVector().shuffleFromBytes(reorder);\n-    }\n-\n-    @ForceInline\n-    public final VectorMask<E> laneIsValid() {\n-        Vector<E> shufvec = this.toVector();\n-        return shufvec.compare(VectorOperators.GE, vspecies().zero());\n-    }\n-\n@@ -223,17 +150,0 @@\n-\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n-            if (si >= length || si < -length) {\n-                boolean assertsEnabled = false;\n-                assert(assertsEnabled = true);\n-                if (assertsEnabled) {\n-                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(reorder));\n-                    throw new AssertionError(msg);\n-                }\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":34,"deletions":124,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+    final Class<? extends AbstractShuffle<E>> shuffleType;\n+    @Stable\n@@ -64,0 +66,1 @@\n+                    Class<? extends AbstractShuffle<E>> shuffleType,\n@@ -69,0 +72,1 @@\n+        this.shuffleType = shuffleType;\n@@ -165,0 +169,5 @@\n+    @ForceInline\n+    final Class<? extends AbstractShuffle<E>> shuffleType() {\n+        return shuffleType;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-    abstract AbstractShuffle<E> iotaShuffle();\n+    abstract <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp);\n@@ -199,1 +199,19 @@\n-    abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n+    \/*package-private*\/\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffleTemplate(AbstractSpecies<F> dsp) {\n+        Class<?> etype = vspecies().elementType();\n+        Class<?> dvtype = dsp.shuffleType();\n+        Class<?> dtype = dsp.asIntegral().elementType();\n+        int dlength = dsp.dummyVector().length();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), etype, length(),\n+                                     dvtype, dtype, dlength,\n+                                     this, dsp,\n+                                     AbstractVector::bitsToShuffle0);\n+    }\n+\n+    abstract <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp);\n+\n+    abstract <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap);\n+\n+    abstract VectorShuffle<E> iotaShuffle();\n@@ -201,2 +219,14 @@\n-    \/*do not alias this byte array*\/\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n+    abstract VectorShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n+\n+    @ForceInline\n+    final VectorShuffle<E> iotaShuffleTemplate(int start, int step, boolean wrap) {\n+        if ((length() & (length() - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, length())))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n+\n+        AbstractVector<?> iota = vspecies().asIntegral().iota();\n+        iota = (AbstractVector<?>) iota.lanewise(VectorOperators.MUL, step)\n+                .lanewise(VectorOperators.ADD, start);\n+        return iota.toShuffle(vspecies(), wrap);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte128Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte128Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte128Shuffle(indexes, i); }\n+    Byte128Shuffle shuffleFromArray(int[] indices, int i) { return new Byte128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n+    public final Byte128Shuffle toShuffle() {\n+        return (Byte128Shuffle) toShuffle(vspecies(), false);\n@@ -817,2 +815,4 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -821,2 +821,2 @@\n-        public Byte128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -825,2 +825,2 @@\n-        public Byte128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -829,2 +829,2 @@\n-        public Byte128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -834,0 +834,1 @@\n+        @ForceInline\n@@ -849,2 +850,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte128Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -855,6 +855,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte128Vector toBitsVector() {\n+            return (Byte128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte128Vector toBitsVector0() {\n+            return ((Byte128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -865,3 +866,2 @@\n-        public Byte128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte128Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -870,0 +870,1 @@\n+        @Override\n@@ -871,0 +872,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -872,8 +890,60 @@\n-        public Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte128Shuffle s = (Byte128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte128Mask laneIsValid() {\n+            return (Byte128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            return (Byte128Shuffle) toBitsVector().rearrange(((Byte128Shuffle) shuffle)\n+                    .cast(ByteVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte128Shuffle wrapIndexes() {\n+            Byte128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -881,1 +951,1 @@\n-            return new Byte128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte256Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte256Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte256Shuffle(indexes, i); }\n+    Byte256Shuffle shuffleFromArray(int[] indices, int i) { return new Byte256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n+    public final Byte256Shuffle toShuffle() {\n+        return (Byte256Shuffle) toShuffle(vspecies(), false);\n@@ -849,2 +847,4 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -853,2 +853,2 @@\n-        public Byte256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -857,2 +857,2 @@\n-        public Byte256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -861,2 +861,2 @@\n-        public Byte256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -866,0 +866,1 @@\n+        @ForceInline\n@@ -881,2 +882,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte256Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -887,6 +887,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte256Vector toBitsVector() {\n+            return (Byte256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte256Vector toBitsVector0() {\n+            return ((Byte256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -897,3 +898,2 @@\n-        public Byte256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte256Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -902,0 +902,1 @@\n+        @Override\n@@ -903,0 +904,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -904,8 +922,60 @@\n-        public Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte256Shuffle s = (Byte256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte256Mask laneIsValid() {\n+            return (Byte256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            return (Byte256Shuffle) toBitsVector().rearrange(((Byte256Shuffle) shuffle)\n+                    .cast(ByteVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte256Shuffle wrapIndexes() {\n+            Byte256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -913,1 +983,1 @@\n-            return new Byte256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte512Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte512Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte512Shuffle(indexes, i); }\n+    Byte512Shuffle shuffleFromArray(int[] indices, int i) { return new Byte512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n+    public final Byte512Shuffle toShuffle() {\n+        return (Byte512Shuffle) toShuffle(vspecies(), false);\n@@ -913,2 +911,4 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -917,2 +917,2 @@\n-        public Byte512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -921,2 +921,2 @@\n-        public Byte512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -925,2 +925,2 @@\n-        public Byte512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -930,0 +930,1 @@\n+        @ForceInline\n@@ -945,2 +946,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte512Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -951,6 +951,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte512Vector toBitsVector() {\n+            return (Byte512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte512Vector toBitsVector0() {\n+            return ((Byte512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -961,3 +962,2 @@\n-        public Byte512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte512Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -966,0 +966,1 @@\n+        @Override\n@@ -967,0 +968,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -968,8 +986,60 @@\n-        public Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte512Shuffle s = (Byte512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte512Mask laneIsValid() {\n+            return (Byte512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            return (Byte512Shuffle) toBitsVector().rearrange(((Byte512Shuffle) shuffle)\n+                    .cast(ByteVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte512Shuffle wrapIndexes() {\n+            Byte512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -977,1 +1047,1 @@\n-            return new Byte512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte64Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte64Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte64Shuffle(indexes, i); }\n+    Byte64Shuffle shuffleFromArray(int[] indices, int i) { return new Byte64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n+    public final Byte64Shuffle toShuffle() {\n+        return (Byte64Shuffle) toShuffle(vspecies(), false);\n@@ -801,2 +799,4 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -805,2 +805,2 @@\n-        public Byte64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -809,2 +809,2 @@\n-        public Byte64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -813,2 +813,2 @@\n-        public Byte64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -818,0 +818,1 @@\n+        @ForceInline\n@@ -833,2 +834,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte64Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -839,6 +839,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte64Vector toBitsVector() {\n+            return (Byte64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte64Vector toBitsVector0() {\n+            return ((Byte64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -849,3 +850,2 @@\n-        public Byte64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte64Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -854,0 +854,1 @@\n+        @Override\n@@ -855,0 +856,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -856,8 +874,60 @@\n-        public Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte64Shuffle s = (Byte64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte64Mask laneIsValid() {\n+            return (Byte64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            return (Byte64Shuffle) toBitsVector().rearrange(((Byte64Shuffle) shuffle)\n+                    .cast(ByteVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte64Shuffle wrapIndexes() {\n+            Byte64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -865,1 +935,1 @@\n-            return new Byte64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (ByteMaxShuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n+    ByteMaxShuffle shuffleFromArray(int[] indices, int i) { return new ByteMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n+    public final ByteMaxShuffle toShuffle() {\n+        return (ByteMaxShuffle) toShuffle(vspecies(), false);\n@@ -787,2 +785,4 @@\n-        ByteMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -791,2 +791,2 @@\n-        public ByteMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -795,2 +795,2 @@\n-        public ByteMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ByteMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -799,2 +799,2 @@\n-        public ByteMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -804,0 +804,1 @@\n+        @ForceInline\n@@ -819,2 +820,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -825,6 +825,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        ByteMaxVector toBitsVector() {\n+            return (ByteMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ByteMaxVector toBitsVector0() {\n+            return ((ByteMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -835,3 +836,2 @@\n-        public ByteMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxShuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -840,0 +840,1 @@\n+        @Override\n@@ -841,0 +842,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -842,8 +860,60 @@\n-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final ByteMaxMask laneIsValid() {\n+            return (ByteMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            return (ByteMaxShuffle) toBitsVector().rearrange(((ByteMaxShuffle) shuffle)\n+                    .cast(ByteVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ByteMaxShuffle wrapIndexes() {\n+            ByteMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ByteMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ByteMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (ByteMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -851,1 +921,1 @@\n-            return new ByteMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -1074,1 +1074,1 @@\n-   \/**\n+    \/**\n@@ -2403,2 +2403,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2407,1 +2405,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2409,1 +2407,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2432,2 +2430,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2436,1 +2432,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2438,1 +2434,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2459,2 +2455,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2464,1 +2458,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2466,1 +2460,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2472,1 +2466,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2474,1 +2468,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2480,0 +2474,1 @@\n+    @Override\n@@ -2481,2 +2476,1 @@\n-    private final\n-    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n@@ -2491,1 +2485,0 @@\n-    \/*package-private*\/\n@@ -2493,8 +2486,11 @@\n-    final\n-    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n-        ByteSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), byte.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     ByteVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ByteVector idx = this;\n+        ByteVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ByteVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Byte> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -4178,0 +4174,1 @@\n+                Class<? extends AbstractShuffle<Byte>> shuffleType,\n@@ -4180,1 +4177,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4466,0 +4463,1 @@\n+                            Byte64Vector.Byte64Shuffle.class,\n@@ -4473,0 +4471,1 @@\n+                            Byte128Vector.Byte128Shuffle.class,\n@@ -4480,0 +4479,1 @@\n+                            Byte256Vector.Byte256Shuffle.class,\n@@ -4487,0 +4487,1 @@\n+                            Byte512Vector.Byte512Shuffle.class,\n@@ -4494,0 +4495,1 @@\n+                            ByteMaxVector.ByteMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double128Shuffle shuffleFromArray(int[] indexes, int i) { return new Double128Shuffle(indexes, i); }\n+    Double128Shuffle shuffleFromArray(int[] indices, int i) { return new Double128Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n+    public final Double128Shuffle toShuffle() {\n+        return (Double128Shuffle) toShuffle(vspecies(), false);\n@@ -776,1 +774,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -778,2 +776,4 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -782,2 +782,2 @@\n-        public Double128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -786,2 +786,2 @@\n-        public Double128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -790,2 +790,2 @@\n-        public Double128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -795,0 +795,1 @@\n+        @ForceInline\n@@ -802,2 +803,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -810,2 +811,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double128Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double128Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -816,6 +816,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long128Vector toBitsVector() {\n+            return (Long128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long128Vector toBitsVector0() {\n+            return ((Long128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -826,3 +827,2 @@\n-        public Double128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double128Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -831,0 +831,1 @@\n+        @Override\n@@ -832,0 +833,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -833,8 +862,60 @@\n-        public Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double128Shuffle s = (Double128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double128Mask laneIsValid() {\n+            return (Double128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            return (Double128Shuffle) toBitsVector().rearrange(((Double128Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -842,1 +923,1 @@\n-            return new Double128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double256Shuffle shuffleFromArray(int[] indexes, int i) { return new Double256Shuffle(indexes, i); }\n+    Double256Shuffle shuffleFromArray(int[] indices, int i) { return new Double256Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n+    public final Double256Shuffle toShuffle() {\n+        return (Double256Shuffle) toShuffle(vspecies(), false);\n@@ -780,1 +778,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -782,2 +780,4 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -786,2 +786,2 @@\n-        public Double256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -790,2 +790,2 @@\n-        public Double256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -794,2 +794,2 @@\n-        public Double256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -799,0 +799,1 @@\n+        @ForceInline\n@@ -806,2 +807,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -814,2 +815,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double256Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double256Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -820,6 +820,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long256Vector toBitsVector() {\n+            return (Long256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long256Vector toBitsVector0() {\n+            return ((Long256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -830,3 +831,2 @@\n-        public Double256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double256Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -835,0 +835,1 @@\n+        @Override\n@@ -836,0 +837,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -837,8 +866,60 @@\n-        public Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double256Shuffle s = (Double256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double256Mask laneIsValid() {\n+            return (Double256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            return (Double256Shuffle) toBitsVector().rearrange(((Double256Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -846,1 +927,1 @@\n-            return new Double256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double512Shuffle shuffleFromArray(int[] indexes, int i) { return new Double512Shuffle(indexes, i); }\n+    Double512Shuffle shuffleFromArray(int[] indices, int i) { return new Double512Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n+    public final Double512Shuffle toShuffle() {\n+        return (Double512Shuffle) toShuffle(vspecies(), false);\n@@ -788,1 +786,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -790,2 +788,4 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -794,2 +794,2 @@\n-        public Double512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -798,2 +798,2 @@\n-        public Double512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -802,2 +802,2 @@\n-        public Double512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -807,0 +807,1 @@\n+        @ForceInline\n@@ -814,2 +815,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -822,2 +823,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double512Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double512Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -828,6 +828,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long512Vector toBitsVector() {\n+            return (Long512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long512Vector toBitsVector0() {\n+            return ((Long512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -838,3 +839,2 @@\n-        public Double512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double512Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -843,0 +843,1 @@\n+        @Override\n@@ -844,0 +845,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -845,8 +874,60 @@\n-        public Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double512Shuffle s = (Double512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double512Mask laneIsValid() {\n+            return (Double512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            return (Double512Shuffle) toBitsVector().rearrange(((Double512Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -854,1 +935,1 @@\n-            return new Double512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double64Shuffle shuffleFromArray(int[] indexes, int i) { return new Double64Shuffle(indexes, i); }\n+    Double64Shuffle shuffleFromArray(int[] indices, int i) { return new Double64Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n+    public final Double64Shuffle toShuffle() {\n+        return (Double64Shuffle) toShuffle(vspecies(), false);\n@@ -774,1 +772,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -776,2 +774,4 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -780,2 +780,2 @@\n-        public Double64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -784,2 +784,2 @@\n-        public Double64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -788,2 +788,2 @@\n-        public Double64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -793,0 +793,1 @@\n+        @ForceInline\n@@ -800,2 +801,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -808,2 +809,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double64Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double64Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -814,6 +814,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long64Vector toBitsVector() {\n+            return (Long64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long64Vector toBitsVector0() {\n+            return ((Long64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -824,3 +825,2 @@\n-        public Double64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double64Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -829,0 +829,1 @@\n+        @Override\n@@ -830,0 +831,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -831,8 +860,60 @@\n-        public Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double64Shuffle s = (Double64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double64Mask laneIsValid() {\n+            return (Double64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            return (Double64Shuffle) toBitsVector().rearrange(((Double64Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -840,1 +921,1 @@\n-            return new Double64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (DoubleMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n+    DoubleMaxShuffle shuffleFromArray(int[] indices, int i) { return new DoubleMaxShuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n+    public final DoubleMaxShuffle toShuffle() {\n+        return (DoubleMaxShuffle) toShuffle(vspecies(), false);\n@@ -773,1 +771,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -775,2 +773,4 @@\n-        DoubleMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -779,2 +779,2 @@\n-        public DoubleMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -783,2 +783,2 @@\n-        public DoubleMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        DoubleMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -787,2 +787,2 @@\n-        public DoubleMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -792,0 +792,1 @@\n+        @ForceInline\n@@ -799,2 +800,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -807,2 +808,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (DoubleMaxVector) toBitsVector().castShape(vspecies(), 0);\n@@ -813,6 +813,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        LongMaxVector toBitsVector() {\n+            return (LongMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        LongMaxVector toBitsVector0() {\n+            return ((LongMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -823,3 +824,2 @@\n-        public DoubleMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxShuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -828,0 +828,1 @@\n+        @Override\n@@ -829,0 +830,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -830,8 +859,60 @@\n-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final DoubleMaxMask laneIsValid() {\n+            return (DoubleMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n+            return (DoubleMaxShuffle) toBitsVector().rearrange(((DoubleMaxShuffle) shuffle)\n+                    .cast(LongVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final DoubleMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (LongMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (LongMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (DoubleMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -839,1 +920,1 @@\n-            return new DoubleMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":126,"deletions":45,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-   \/**\n+    \/**\n@@ -2245,2 +2245,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2249,1 +2247,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2251,1 +2249,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2274,2 +2272,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2278,1 +2274,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2280,1 +2276,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2301,2 +2297,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2306,1 +2300,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2308,1 +2302,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2314,1 +2308,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2316,1 +2310,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2322,0 +2316,1 @@\n+    @Override\n@@ -2323,8 +2318,2 @@\n-    private final\n-    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n@@ -2333,1 +2322,0 @@\n-    \/*package-private*\/\n@@ -2335,8 +2323,11 @@\n-    final\n-    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n-        DoubleSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), double.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     DoubleVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        LongVector idx = convert(VectorOperators.D2L, 0).reinterpretAsLongs();\n+        LongVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            LongVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Long> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3705,0 +3696,1 @@\n+                Class<? extends AbstractShuffle<Double>> shuffleType,\n@@ -3707,1 +3699,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -3993,0 +3985,1 @@\n+                            Double64Vector.Double64Shuffle.class,\n@@ -4000,0 +3993,1 @@\n+                            Double128Vector.Double128Shuffle.class,\n@@ -4007,0 +4001,1 @@\n+                            Double256Vector.Double256Shuffle.class,\n@@ -4014,0 +4009,1 @@\n+                            Double512Vector.Double512Shuffle.class,\n@@ -4021,0 +4017,1 @@\n+                            DoubleMaxVector.DoubleMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float128Shuffle shuffleFromArray(int[] indexes, int i) { return new Float128Shuffle(indexes, i); }\n+    Float128Shuffle shuffleFromArray(int[] indices, int i) { return new Float128Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n+    public final Float128Shuffle toShuffle() {\n+        return (Float128Shuffle) toShuffle(vspecies(), false);\n@@ -780,1 +778,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -782,2 +780,4 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -786,2 +786,2 @@\n-        public Float128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -790,2 +790,2 @@\n-        public Float128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -794,2 +794,2 @@\n-        public Float128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -799,0 +799,1 @@\n+        @ForceInline\n@@ -806,2 +807,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -814,2 +815,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float128Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float128Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -820,6 +820,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int128Vector toBitsVector() {\n+            return (Int128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int128Vector toBitsVector0() {\n+            return ((Int128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -830,3 +837,9 @@\n-        public Float128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float128Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Float128Mask laneIsValid() {\n+            return (Float128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -837,8 +850,52 @@\n-        public Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float128Shuffle s = (Float128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            return (Float128Shuffle) toBitsVector().rearrange(((Float128Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -846,1 +903,1 @@\n-            return new Float128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":102,"deletions":45,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float256Shuffle shuffleFromArray(int[] indexes, int i) { return new Float256Shuffle(indexes, i); }\n+    Float256Shuffle shuffleFromArray(int[] indices, int i) { return new Float256Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n+    public final Float256Shuffle toShuffle() {\n+        return (Float256Shuffle) toShuffle(vspecies(), false);\n@@ -788,1 +786,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -790,2 +788,4 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -794,2 +794,2 @@\n-        public Float256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -798,2 +798,2 @@\n-        public Float256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -802,2 +802,2 @@\n-        public Float256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -807,0 +807,1 @@\n+        @ForceInline\n@@ -814,2 +815,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -822,2 +823,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float256Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float256Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -828,6 +828,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int256Vector toBitsVector() {\n+            return (Int256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int256Vector toBitsVector0() {\n+            return ((Int256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -838,3 +845,9 @@\n-        public Float256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float256Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Float256Mask laneIsValid() {\n+            return (Float256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -845,8 +858,52 @@\n-        public Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float256Shuffle s = (Float256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            return (Float256Shuffle) toBitsVector().rearrange(((Float256Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -854,1 +911,1 @@\n-            return new Float256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":102,"deletions":45,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float512Shuffle shuffleFromArray(int[] indexes, int i) { return new Float512Shuffle(indexes, i); }\n+    Float512Shuffle shuffleFromArray(int[] indices, int i) { return new Float512Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n+    public final Float512Shuffle toShuffle() {\n+        return (Float512Shuffle) toShuffle(vspecies(), false);\n@@ -804,1 +802,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -806,2 +804,4 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -810,2 +810,2 @@\n-        public Float512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -814,2 +814,2 @@\n-        public Float512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -818,2 +818,2 @@\n-        public Float512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -823,0 +823,1 @@\n+        @ForceInline\n@@ -830,2 +831,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -838,2 +839,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float512Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float512Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -844,6 +844,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int512Vector toBitsVector() {\n+            return (Int512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int512Vector toBitsVector0() {\n+            return ((Int512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -854,3 +861,9 @@\n-        public Float512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float512Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Float512Mask laneIsValid() {\n+            return (Float512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -861,8 +874,52 @@\n-        public Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float512Shuffle s = (Float512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            return (Float512Shuffle) toBitsVector().rearrange(((Float512Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -870,1 +927,1 @@\n-            return new Float512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":102,"deletions":45,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float64Shuffle shuffleFromArray(int[] indexes, int i) { return new Float64Shuffle(indexes, i); }\n+    Float64Shuffle shuffleFromArray(int[] indices, int i) { return new Float64Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n+    public final Float64Shuffle toShuffle() {\n+        return (Float64Shuffle) toShuffle(vspecies(), false);\n@@ -776,1 +774,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -778,2 +776,4 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -782,2 +782,2 @@\n-        public Float64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -786,2 +786,2 @@\n-        public Float64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -790,2 +790,2 @@\n-        public Float64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -795,0 +795,1 @@\n+        @ForceInline\n@@ -802,2 +803,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -810,2 +811,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float64Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float64Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -816,6 +816,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int64Vector toBitsVector() {\n+            return (Int64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int64Vector toBitsVector0() {\n+            return ((Int64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -826,3 +833,9 @@\n-        public Float64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float64Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Float64Mask laneIsValid() {\n+            return (Float64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -833,8 +846,52 @@\n-        public Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float64Shuffle s = (Float64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            return (Float64Shuffle) toBitsVector().rearrange(((Float64Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -842,1 +899,1 @@\n-            return new Float64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":102,"deletions":45,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (FloatMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n+    FloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new FloatMaxShuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n+    public final FloatMaxShuffle toShuffle() {\n+        return (FloatMaxShuffle) toShuffle(vspecies(), false);\n@@ -773,1 +771,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -775,2 +773,4 @@\n-        FloatMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -779,2 +779,2 @@\n-        public FloatMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -783,2 +783,2 @@\n-        public FloatMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        FloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -787,2 +787,2 @@\n-        public FloatMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -792,0 +792,1 @@\n+        @ForceInline\n@@ -799,2 +800,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -807,2 +808,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (FloatMaxVector) toBitsVector().castShape(vspecies(), 0);\n@@ -813,6 +813,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        IntMaxVector toBitsVector() {\n+            return (IntMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        IntMaxVector toBitsVector0() {\n+            return ((IntMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -823,3 +830,9 @@\n-        public FloatMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxShuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final FloatMaxMask laneIsValid() {\n+            return (FloatMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -830,8 +843,52 @@\n-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n+            return (FloatMaxShuffle) toBitsVector().rearrange(((FloatMaxShuffle) shuffle)\n+                    .cast(IntVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final FloatMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (IntMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (IntMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (FloatMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -839,1 +896,1 @@\n-            return new FloatMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":102,"deletions":45,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-   \/**\n+    \/**\n@@ -2257,2 +2257,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2261,1 +2259,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2263,1 +2261,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2286,2 +2284,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2290,1 +2286,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2292,1 +2288,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2313,2 +2309,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2318,1 +2312,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2320,1 +2314,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2326,1 +2320,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2328,1 +2322,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2334,0 +2328,1 @@\n+    @Override\n@@ -2335,8 +2330,2 @@\n-    private final\n-    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n@@ -2345,1 +2334,0 @@\n-    \/*package-private*\/\n@@ -2347,8 +2335,11 @@\n-    final\n-    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n-        FloatSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), float.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     FloatVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        IntVector idx = convert(VectorOperators.F2I, 0).reinterpretAsInts();\n+        IntVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            IntVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Integer> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3655,0 +3646,1 @@\n+                Class<? extends AbstractShuffle<Float>> shuffleType,\n@@ -3657,1 +3649,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -3943,0 +3935,1 @@\n+                            Float64Vector.Float64Shuffle.class,\n@@ -3950,0 +3943,1 @@\n+                            Float128Vector.Float128Shuffle.class,\n@@ -3957,0 +3951,1 @@\n+                            Float256Vector.Float256Shuffle.class,\n@@ -3964,0 +3959,1 @@\n+                            Float512Vector.Float512Shuffle.class,\n@@ -3971,0 +3967,1 @@\n+                            FloatMaxVector.FloatMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int128Shuffle shuffleFromArray(int[] indexes, int i) { return new Int128Shuffle(indexes, i); }\n+    Int128Shuffle shuffleFromArray(int[] indices, int i) { return new Int128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n+    public final Int128Shuffle toShuffle() {\n+        return (Int128Shuffle) toShuffle(vspecies(), false);\n@@ -793,2 +791,4 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -797,2 +797,2 @@\n-        public Int128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -801,2 +801,2 @@\n-        public Int128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -805,2 +805,2 @@\n-        public Int128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -810,0 +810,1 @@\n+        @ForceInline\n@@ -817,2 +818,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -825,2 +826,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int128Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -831,6 +831,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int128Vector toBitsVector() {\n+            return (Int128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int128Vector toBitsVector0() {\n+            return ((Int128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -841,3 +842,2 @@\n-        public Int128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int128Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -846,0 +846,1 @@\n+        @Override\n@@ -847,0 +848,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -848,8 +853,60 @@\n-        public Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int128Shuffle s = (Int128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int128Mask laneIsValid() {\n+            return (Int128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            return (Int128Shuffle) toBitsVector().rearrange(((Int128Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -857,1 +914,1 @@\n-            return new Int128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int256Shuffle shuffleFromArray(int[] indexes, int i) { return new Int256Shuffle(indexes, i); }\n+    Int256Shuffle shuffleFromArray(int[] indices, int i) { return new Int256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n+    public final Int256Shuffle toShuffle() {\n+        return (Int256Shuffle) toShuffle(vspecies(), false);\n@@ -801,2 +799,4 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -805,2 +805,2 @@\n-        public Int256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -809,2 +809,2 @@\n-        public Int256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -813,2 +813,2 @@\n-        public Int256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -818,0 +818,1 @@\n+        @ForceInline\n@@ -825,2 +826,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -833,2 +834,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int256Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -839,6 +839,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int256Vector toBitsVector() {\n+            return (Int256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int256Vector toBitsVector0() {\n+            return ((Int256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -849,3 +850,2 @@\n-        public Int256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int256Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -854,0 +854,1 @@\n+        @Override\n@@ -855,0 +856,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -856,8 +861,60 @@\n-        public Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int256Shuffle s = (Int256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int256Mask laneIsValid() {\n+            return (Int256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            return (Int256Shuffle) toBitsVector().rearrange(((Int256Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -865,1 +922,1 @@\n-            return new Int256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int512Shuffle shuffleFromArray(int[] indexes, int i) { return new Int512Shuffle(indexes, i); }\n+    Int512Shuffle shuffleFromArray(int[] indices, int i) { return new Int512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n+    public final Int512Shuffle toShuffle() {\n+        return (Int512Shuffle) toShuffle(vspecies(), false);\n@@ -817,2 +815,4 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -821,2 +821,2 @@\n-        public Int512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -825,2 +825,2 @@\n-        public Int512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -829,2 +829,2 @@\n-        public Int512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -834,0 +834,1 @@\n+        @ForceInline\n@@ -841,2 +842,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -849,2 +850,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int512Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -855,6 +855,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int512Vector toBitsVector() {\n+            return (Int512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int512Vector toBitsVector0() {\n+            return ((Int512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -865,3 +866,2 @@\n-        public Int512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int512Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -870,0 +870,1 @@\n+        @Override\n@@ -871,0 +872,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -872,8 +877,60 @@\n-        public Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int512Shuffle s = (Int512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int512Mask laneIsValid() {\n+            return (Int512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            return (Int512Shuffle) toBitsVector().rearrange(((Int512Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -881,1 +938,1 @@\n-            return new Int512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int64Shuffle shuffleFromArray(int[] indexes, int i) { return new Int64Shuffle(indexes, i); }\n+    Int64Shuffle shuffleFromArray(int[] indices, int i) { return new Int64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n+    public final Int64Shuffle toShuffle() {\n+        return (Int64Shuffle) toShuffle(vspecies(), false);\n@@ -789,2 +787,4 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -793,2 +793,2 @@\n-        public Int64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -797,2 +797,2 @@\n-        public Int64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -801,2 +801,2 @@\n-        public Int64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -806,0 +806,1 @@\n+        @ForceInline\n@@ -813,2 +814,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -821,2 +822,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int64Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -827,6 +827,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int64Vector toBitsVector() {\n+            return (Int64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int64Vector toBitsVector0() {\n+            return ((Int64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -837,3 +838,2 @@\n-        public Int64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int64Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -842,0 +842,1 @@\n+        @Override\n@@ -843,0 +844,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -844,8 +849,60 @@\n-        public Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int64Shuffle s = (Int64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int64Mask laneIsValid() {\n+            return (Int64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            return (Int64Shuffle) toBitsVector().rearrange(((Int64Shuffle) shuffle)\n+                    .cast(IntVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -853,1 +910,1 @@\n-            return new Int64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (IntMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n+    IntMaxShuffle shuffleFromArray(int[] indices, int i) { return new IntMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n+    public final IntMaxShuffle toShuffle() {\n+        return (IntMaxShuffle) toShuffle(vspecies(), false);\n@@ -798,2 +796,4 @@\n-        IntMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -802,2 +802,2 @@\n-        public IntMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -806,2 +806,2 @@\n-        public IntMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        IntMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -810,2 +810,2 @@\n-        public IntMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -815,0 +815,1 @@\n+        @ForceInline\n@@ -822,2 +823,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -830,2 +831,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -836,6 +836,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        IntMaxVector toBitsVector() {\n+            return (IntMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        IntMaxVector toBitsVector0() {\n+            return ((IntMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -846,3 +847,2 @@\n-        public IntMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxShuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -851,0 +851,1 @@\n+        @Override\n@@ -852,0 +853,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -853,8 +858,60 @@\n-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final IntMaxMask laneIsValid() {\n+            return (IntMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            return (IntMaxShuffle) toBitsVector().rearrange(((IntMaxShuffle) shuffle)\n+                    .cast(IntVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final IntMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (IntMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (IntMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (IntMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -862,1 +919,1 @@\n-            return new IntMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1077,1 +1077,1 @@\n-   \/**\n+    \/**\n@@ -2388,2 +2388,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2392,1 +2390,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2394,1 +2392,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2417,2 +2415,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2421,1 +2417,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2423,1 +2419,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2444,2 +2440,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2449,1 +2443,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2451,1 +2445,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2457,1 +2451,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2459,1 +2453,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2465,0 +2459,1 @@\n+    @Override\n@@ -2466,2 +2461,1 @@\n-    private final\n-    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n@@ -2476,1 +2470,0 @@\n-    \/*package-private*\/\n@@ -2478,8 +2471,11 @@\n-    final\n-    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n-        IntSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), int.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     IntVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        IntVector idx = this;\n+        IntVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            IntVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Integer> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3811,0 +3807,1 @@\n+                Class<? extends AbstractShuffle<Integer>> shuffleType,\n@@ -3813,1 +3810,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4099,0 +4096,1 @@\n+                            Int64Vector.Int64Shuffle.class,\n@@ -4106,0 +4104,1 @@\n+                            Int128Vector.Int128Shuffle.class,\n@@ -4113,0 +4112,1 @@\n+                            Int256Vector.Int256Shuffle.class,\n@@ -4120,0 +4120,1 @@\n+                            Int512Vector.Int512Shuffle.class,\n@@ -4127,0 +4128,1 @@\n+                            IntMaxVector.IntMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long128Shuffle shuffleFromArray(int[] indexes, int i) { return new Long128Shuffle(indexes, i); }\n+    Long128Shuffle shuffleFromArray(int[] indices, int i) { return new Long128Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n+    public final Long128Shuffle toShuffle() {\n+        return (Long128Shuffle) toShuffle(vspecies(), false);\n@@ -779,2 +777,4 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -783,2 +783,2 @@\n-        public Long128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -787,2 +787,2 @@\n-        public Long128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -791,2 +791,2 @@\n-        public Long128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -796,0 +796,1 @@\n+        @ForceInline\n@@ -803,2 +804,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -811,2 +812,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long128Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -817,6 +817,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long128Vector toBitsVector() {\n+            return (Long128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long128Vector toBitsVector0() {\n+            return ((Long128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -827,3 +834,33 @@\n-        public Long128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long128Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long128Mask laneIsValid() {\n+            return (Long128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -834,8 +871,52 @@\n-        public Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long128Shuffle s = (Long128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            return (Long128Shuffle) toBitsVector().rearrange(((Long128Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -843,1 +924,1 @@\n-            return new Long128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":125,"deletions":44,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long256Shuffle shuffleFromArray(int[] indexes, int i) { return new Long256Shuffle(indexes, i); }\n+    Long256Shuffle shuffleFromArray(int[] indices, int i) { return new Long256Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n+    public final Long256Shuffle toShuffle() {\n+        return (Long256Shuffle) toShuffle(vspecies(), false);\n@@ -783,2 +781,4 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -787,2 +787,2 @@\n-        public Long256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -791,2 +791,2 @@\n-        public Long256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -795,2 +795,2 @@\n-        public Long256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -800,0 +800,1 @@\n+        @ForceInline\n@@ -807,2 +808,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -815,2 +816,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long256Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -821,6 +821,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long256Vector toBitsVector() {\n+            return (Long256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long256Vector toBitsVector0() {\n+            return ((Long256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -831,3 +838,33 @@\n-        public Long256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long256Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long256Mask laneIsValid() {\n+            return (Long256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -838,8 +875,52 @@\n-        public Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long256Shuffle s = (Long256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            return (Long256Shuffle) toBitsVector().rearrange(((Long256Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -847,1 +928,1 @@\n-            return new Long256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":125,"deletions":44,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long512Shuffle shuffleFromArray(int[] indexes, int i) { return new Long512Shuffle(indexes, i); }\n+    Long512Shuffle shuffleFromArray(int[] indices, int i) { return new Long512Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n+    public final Long512Shuffle toShuffle() {\n+        return (Long512Shuffle) toShuffle(vspecies(), false);\n@@ -791,2 +789,4 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -795,2 +795,2 @@\n-        public Long512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -799,2 +799,2 @@\n-        public Long512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -803,2 +803,2 @@\n-        public Long512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -808,0 +808,1 @@\n+        @ForceInline\n@@ -815,2 +816,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -823,2 +824,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long512Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -829,6 +829,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long512Vector toBitsVector() {\n+            return (Long512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long512Vector toBitsVector0() {\n+            return ((Long512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -839,3 +846,33 @@\n-        public Long512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long512Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long512Mask laneIsValid() {\n+            return (Long512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -846,8 +883,52 @@\n-        public Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long512Shuffle s = (Long512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            return (Long512Shuffle) toBitsVector().rearrange(((Long512Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -855,1 +936,1 @@\n-            return new Long512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":125,"deletions":44,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long64Shuffle shuffleFromArray(int[] indexes, int i) { return new Long64Shuffle(indexes, i); }\n+    Long64Shuffle shuffleFromArray(int[] indices, int i) { return new Long64Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n+    public final Long64Shuffle toShuffle() {\n+        return (Long64Shuffle) toShuffle(vspecies(), false);\n@@ -777,2 +775,4 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -781,2 +781,2 @@\n-        public Long64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -785,2 +785,2 @@\n-        public Long64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -789,2 +789,2 @@\n-        public Long64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -794,0 +794,1 @@\n+        @ForceInline\n@@ -801,2 +802,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -809,2 +810,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long64Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -815,6 +815,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long64Vector toBitsVector() {\n+            return (Long64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long64Vector toBitsVector0() {\n+            return ((Long64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -825,3 +832,33 @@\n-        public Long64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long64Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long64Mask laneIsValid() {\n+            return (Long64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -832,8 +869,52 @@\n-        public Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long64Shuffle s = (Long64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            return (Long64Shuffle) toBitsVector().rearrange(((Long64Shuffle) shuffle)\n+                    .cast(LongVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -841,1 +922,1 @@\n-            return new Long64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":125,"deletions":44,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (LongMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n+    LongMaxShuffle shuffleFromArray(int[] indices, int i) { return new LongMaxShuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n+    public final LongMaxShuffle toShuffle() {\n+        return (LongMaxShuffle) toShuffle(vspecies(), false);\n@@ -777,2 +775,4 @@\n-        LongMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -781,2 +781,2 @@\n-        public LongMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -785,2 +785,2 @@\n-        public LongMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        LongMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -789,2 +789,2 @@\n-        public LongMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -794,0 +794,1 @@\n+        @ForceInline\n@@ -801,2 +802,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -809,2 +810,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -815,6 +815,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        LongMaxVector toBitsVector() {\n+            return (LongMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        LongMaxVector toBitsVector0() {\n+            return ((LongMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -825,3 +832,33 @@\n-        public LongMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxShuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final LongMaxMask laneIsValid() {\n+            return (LongMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n@@ -832,8 +869,52 @@\n-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n-            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n+            return (LongMaxShuffle) toBitsVector().rearrange(((LongMaxShuffle) shuffle)\n+                    .cast(LongVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final LongMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (LongMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (LongMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (LongMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -841,1 +922,1 @@\n-            return new LongMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":125,"deletions":44,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -990,1 +990,1 @@\n-   \/**\n+    \/**\n@@ -2254,2 +2254,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2258,1 +2256,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2260,1 +2258,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2283,2 +2281,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2287,1 +2283,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2289,1 +2285,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2310,2 +2306,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2315,1 +2309,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2317,1 +2311,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2323,1 +2317,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2325,1 +2319,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2331,0 +2325,1 @@\n+    @Override\n@@ -2332,2 +2327,1 @@\n-    private final\n-    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n@@ -2342,1 +2336,0 @@\n-    \/*package-private*\/\n@@ -2344,8 +2337,11 @@\n-    final\n-    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n-        LongSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), long.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     LongVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        LongVector idx = this;\n+        LongVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            LongVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Long> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3746,0 +3742,1 @@\n+                Class<? extends AbstractShuffle<Long>> shuffleType,\n@@ -3748,1 +3745,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4025,0 +4022,1 @@\n+                            Long64Vector.Long64Shuffle.class,\n@@ -4032,0 +4030,1 @@\n+                            Long128Vector.Long128Shuffle.class,\n@@ -4039,0 +4038,1 @@\n+                            Long256Vector.Long256Shuffle.class,\n@@ -4046,0 +4046,1 @@\n+                            Long512Vector.Long512Shuffle.class,\n@@ -4053,0 +4054,1 @@\n+                            LongMaxVector.LongMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short128Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short128Shuffle shuffleFromArray(int[] indexes, int i) { return new Short128Shuffle(indexes, i); }\n+    Short128Shuffle shuffleFromArray(int[] indices, int i) { return new Short128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n+    public final Short128Shuffle toShuffle() {\n+        return (Short128Shuffle) toShuffle(vspecies(), false);\n@@ -801,2 +799,4 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -805,2 +805,2 @@\n-        public Short128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -809,2 +809,2 @@\n-        public Short128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -813,2 +813,2 @@\n-        public Short128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -818,0 +818,1 @@\n+        @ForceInline\n@@ -825,2 +826,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -833,2 +834,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short128Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -839,6 +839,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short128Vector toBitsVector() {\n+            return (Short128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short128Vector toBitsVector0() {\n+            return ((Short128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -849,3 +850,2 @@\n-        public Short128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short128Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -854,0 +854,1 @@\n+        @Override\n@@ -855,0 +856,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -856,8 +868,60 @@\n-        public Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short128Shuffle s = (Short128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short128Mask laneIsValid() {\n+            return (Short128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            return (Short128Shuffle) toBitsVector().rearrange(((Short128Shuffle) shuffle)\n+                    .cast(ShortVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short128Shuffle wrapIndexes() {\n+            Short128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -865,1 +929,1 @@\n-            return new Short128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":108,"deletions":44,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short256Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short256Shuffle shuffleFromArray(int[] indexes, int i) { return new Short256Shuffle(indexes, i); }\n+    Short256Shuffle shuffleFromArray(int[] indices, int i) { return new Short256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n+    public final Short256Shuffle toShuffle() {\n+        return (Short256Shuffle) toShuffle(vspecies(), false);\n@@ -817,2 +815,4 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -821,2 +821,2 @@\n-        public Short256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -825,2 +825,2 @@\n-        public Short256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -829,2 +829,2 @@\n-        public Short256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -834,0 +834,1 @@\n+        @ForceInline\n@@ -841,2 +842,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -849,2 +850,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short256Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -855,6 +855,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short256Vector toBitsVector() {\n+            return (Short256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short256Vector toBitsVector0() {\n+            return ((Short256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -865,3 +866,2 @@\n-        public Short256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short256Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -870,0 +870,1 @@\n+        @Override\n@@ -871,0 +872,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -872,8 +884,60 @@\n-        public Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short256Shuffle s = (Short256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short256Mask laneIsValid() {\n+            return (Short256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            return (Short256Shuffle) toBitsVector().rearrange(((Short256Shuffle) shuffle)\n+                    .cast(ShortVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short256Shuffle wrapIndexes() {\n+            Short256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -881,1 +945,1 @@\n-            return new Short256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":108,"deletions":44,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short512Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short512Shuffle shuffleFromArray(int[] indexes, int i) { return new Short512Shuffle(indexes, i); }\n+    Short512Shuffle shuffleFromArray(int[] indices, int i) { return new Short512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n+    public final Short512Shuffle toShuffle() {\n+        return (Short512Shuffle) toShuffle(vspecies(), false);\n@@ -849,2 +847,4 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -853,2 +853,2 @@\n-        public Short512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -857,2 +857,2 @@\n-        public Short512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -861,2 +861,2 @@\n-        public Short512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -866,0 +866,1 @@\n+        @ForceInline\n@@ -873,2 +874,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -881,2 +882,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short512Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -887,6 +887,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short512Vector toBitsVector() {\n+            return (Short512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short512Vector toBitsVector0() {\n+            return ((Short512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -897,3 +898,2 @@\n-        public Short512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short512Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -902,0 +902,1 @@\n+        @Override\n@@ -903,0 +904,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -904,8 +916,60 @@\n-        public Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short512Shuffle s = (Short512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short512Mask laneIsValid() {\n+            return (Short512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            return (Short512Shuffle) toBitsVector().rearrange(((Short512Shuffle) shuffle)\n+                    .cast(ShortVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short512Shuffle wrapIndexes() {\n+            Short512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -913,1 +977,1 @@\n-            return new Short512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":108,"deletions":44,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short64Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short64Shuffle shuffleFromArray(int[] indexes, int i) { return new Short64Shuffle(indexes, i); }\n+    Short64Shuffle shuffleFromArray(int[] indices, int i) { return new Short64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n+    public final Short64Shuffle toShuffle() {\n+        return (Short64Shuffle) toShuffle(vspecies(), false);\n@@ -793,2 +791,4 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -797,2 +797,2 @@\n-        public Short64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -801,2 +801,2 @@\n-        public Short64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -805,2 +805,2 @@\n-        public Short64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -810,0 +810,1 @@\n+        @ForceInline\n@@ -817,2 +818,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -825,2 +826,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short64Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -831,6 +831,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short64Vector toBitsVector() {\n+            return (Short64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short64Vector toBitsVector0() {\n+            return ((Short64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -841,3 +842,2 @@\n-        public Short64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short64Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -846,0 +846,1 @@\n+        @Override\n@@ -847,0 +848,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -848,8 +860,60 @@\n-        public Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short64Shuffle s = (Short64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short64Mask laneIsValid() {\n+            return (Short64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            return (Short64Shuffle) toBitsVector().rearrange(((Short64Shuffle) shuffle)\n+                    .cast(ShortVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short64Shuffle wrapIndexes() {\n+            Short64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -857,1 +921,1 @@\n-            return new Short64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":108,"deletions":44,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (ShortMaxShuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n+    ShortMaxShuffle shuffleFromArray(int[] indices, int i) { return new ShortMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n+    public final ShortMaxShuffle toShuffle() {\n+        return (ShortMaxShuffle) toShuffle(vspecies(), false);\n@@ -787,2 +785,4 @@\n-        ShortMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -791,2 +791,2 @@\n-        public ShortMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -795,2 +795,2 @@\n-        public ShortMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ShortMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -799,2 +799,2 @@\n-        public ShortMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -804,0 +804,1 @@\n+        @ForceInline\n@@ -811,2 +812,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -819,2 +820,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -825,6 +825,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        ShortMaxVector toBitsVector() {\n+            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ShortMaxVector toBitsVector0() {\n+            return ((ShortMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -835,3 +836,2 @@\n-        public ShortMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxShuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -840,0 +840,1 @@\n+        @Override\n@@ -841,0 +842,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -842,8 +854,60 @@\n-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final ShortMaxMask laneIsValid() {\n+            return (ShortMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n+            return (ShortMaxShuffle) toBitsVector().rearrange(((ShortMaxShuffle) shuffle)\n+                    .cast(ShortVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ShortMaxShuffle wrapIndexes() {\n+            ShortMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ShortMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ShortMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (ShortMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -851,1 +915,1 @@\n-            return new ShortMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":108,"deletions":44,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -1074,1 +1074,1 @@\n-   \/**\n+    \/**\n@@ -2404,2 +2404,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2408,1 +2406,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2410,1 +2408,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2433,2 +2431,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2437,1 +2433,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2439,1 +2435,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2460,2 +2456,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2465,1 +2459,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2467,1 +2461,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2473,1 +2467,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2475,1 +2469,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2481,0 +2475,1 @@\n+    @Override\n@@ -2482,2 +2477,1 @@\n-    private final\n-    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n@@ -2492,1 +2486,0 @@\n-    \/*package-private*\/\n@@ -2494,8 +2487,11 @@\n-    final\n-    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n-        ShortSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), short.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     ShortVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ShortVector idx = this;\n+        ShortVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ShortVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Short> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -4172,0 +4168,1 @@\n+                Class<? extends AbstractShuffle<Short>> shuffleType,\n@@ -4174,1 +4171,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4460,0 +4457,1 @@\n+                            Short64Vector.Short64Shuffle.class,\n@@ -4467,0 +4465,1 @@\n+                            Short128Vector.Short128Shuffle.class,\n@@ -4474,0 +4473,1 @@\n+                            Short256Vector.Short256Shuffle.class,\n@@ -4481,0 +4481,1 @@\n+                            Short512Vector.Short512Shuffle.class,\n@@ -4488,0 +4489,1 @@\n+                            ShortMaxVector.ShortMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,2 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n+    VectorShuffle(Object indices) {\n+        super(indices);\n@@ -559,1 +559,1 @@\n-    public int laneSource(int i) { return toArray()[i]; }\n+    public abstract int laneSource(int i);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -345,0 +347,1 @@\n+    @ForceInline\n@@ -370,0 +373,1 @@\n+    @ForceInline\n@@ -413,0 +417,1 @@\n+    @ForceInline\n@@ -435,0 +440,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1207,1 +1207,1 @@\n-   \/**\n+    \/**\n@@ -2780,2 +2780,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2784,1 +2782,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2786,1 +2784,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2809,2 +2807,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2813,1 +2809,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2815,1 +2811,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2836,2 +2832,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2841,1 +2835,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2843,1 +2837,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2849,1 +2843,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2851,1 +2845,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2857,0 +2851,1 @@\n+    @Override\n@@ -2858,2 +2853,4 @@\n-    private final\n-    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+#if[FP]\n+        throw new AssertionError();\n+#else[FP]\n@@ -2866,0 +2863,1 @@\n+#end[FP]\n@@ -2868,1 +2866,0 @@\n-    \/*package-private*\/\n@@ -2870,8 +2867,19 @@\n-    final\n-    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n-        $Type$Species vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), $type$.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     $Type$Vector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+#if[float]\n+        IntVector idx = convert(VectorOperators.F2I, 0).reinterpretAsInts();\n+#end[float]\n+#if[double]\n+        LongVector idx = convert(VectorOperators.D2L, 0).reinterpretAsLongs();\n+#end[double]\n+#if[!FP]\n+        $Type$Vector idx = this;\n+#end[!FP]\n+        $Bitstype$Vector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            $Bitstype$Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<$Boxbitstype$> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -5409,0 +5417,1 @@\n+                Class<? extends AbstractShuffle<$Boxtype$>> shuffleType,\n@@ -5411,1 +5420,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -5704,0 +5713,1 @@\n+                            $Type$64Vector.$Type$64Shuffle.class,\n@@ -5711,0 +5721,1 @@\n+                            $Type$128Vector.$Type$128Shuffle.class,\n@@ -5718,0 +5729,1 @@\n+                            $Type$256Vector.$Type$256Shuffle.class,\n@@ -5725,0 +5737,1 @@\n+                            $Type$512Vector.$Type$512Shuffle.class,\n@@ -5732,0 +5745,1 @@\n+                            $Type$MaxVector.$Type$MaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+    @Override\n@@ -148,7 +149,9 @@\n-      if (wrap) {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+#if[byte]\n+        return ($shuffletype$) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n+#end[byte]\n+#if[short]\n+        return ($shuffletype$) iotaShuffleTemplate((short) start, (short) step, wrap);\n+#end[short]\n+#if[!byteOrShort]\n+        return ($shuffletype$) iotaShuffleTemplate(start, step, wrap);\n+#end[!byteOrShort]\n@@ -159,5 +162,1 @@\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    $shuffletype$ shuffleFromArray(int[] indexes, int i) { return new $shuffletype$(indexes, i); }\n+    $shuffletype$ shuffleFromArray(int[] indices, int i) { return new $shuffletype$(indices, i); }\n@@ -364,0 +363,1 @@\n+    @Override\n@@ -365,2 +365,12 @@\n-    public VectorShuffle<$Boxtype$> toShuffle() {\n-        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+#if[FP]\n+        throw new AssertionError();\n+#else[FP]\n+        return bitsToShuffleTemplate(dsp);\n+#end[FP]\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final $shuffletype$ toShuffle() {\n+        return ($shuffletype$) toShuffle(vspecies(), false);\n@@ -1073,1 +1083,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n@@ -1075,2 +1085,4 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$($bitstype$[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -1079,2 +1091,2 @@\n-        public $shuffletype$(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -1083,2 +1095,2 @@\n-        public $shuffletype$(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        $shuffletype$(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -1087,2 +1099,2 @@\n-        public $shuffletype$(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        $bitstype$[] indices() {\n+            return ($bitstype$[])getPayload();\n@@ -1092,0 +1104,1 @@\n+        @ForceInline\n@@ -1099,2 +1112,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < $Boxbitstype$.MAX_VALUE);\n+            assert($Boxbitstype$.MIN_VALUE <= -VLENGTH);\n@@ -1104,0 +1117,7 @@\n+#if[FP]\n+        @Override\n+        @ForceInline\n+        public $vectortype$ toVector() {\n+            return ($vectortype$) toBitsVector().castShape(vspecies(), 0);\n+        }\n+#else[FP]\n@@ -1107,2 +1127,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, $shuffletype$.class, this, VLENGTH,\n-                                                    (s) -> (($vectortype$)(((AbstractShuffle<$Boxtype$>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -1110,0 +1129,1 @@\n+#end[FP]\n@@ -1113,6 +1133,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        $bitsvectortype$ toBitsVector() {\n+            return ($bitsvectortype$) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        $bitsvectortype$ toBitsVector0() {\n+            return (($bitsvectortype$) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -1123,3 +1144,78 @@\n-        public $shuffletype$ wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, $shuffletype$.class, this, VLENGTH,\n-                                                    (s) -> (($shuffletype$)(((AbstractShuffle<$Boxtype$>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+#if[byte]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+#end[byte]\n+#if[short]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+#end[short]\n+#if[intOrFloat]\n+            toBitsVector().intoArray(a, offset);\n+#end[intOrFloat]\n+#if[longOrDouble]\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+#end[longOrDouble]\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final $masktype$ laneIsValid() {\n+            return ($masktype$) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n+            return ($shuffletype$) toBitsVector().rearrange((($shuffletype$) shuffle)\n+                    .cast($Bitstype$Vector.SPECIES_$BITS$))\n+                    .toShuffle(vspecies(), false);\n@@ -1130,8 +1226,44 @@\n-        public $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n-            $shuffletype$ s = ($shuffletype$) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final $shuffletype$ wrapIndexes() {\n+            $bitsvectortype$ v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = ($bitsvectortype$) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = ($bitsvectortype$) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return ($shuffletype$) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static $bitstype$[] prepare(int[] indices, int offset) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static $bitstype$[] prepare(IntUnaryOperator f) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange($bitstype$[] indices) {\n+            int length = indices.length;\n+            for ($bitstype$ si : indices) {\n+                if (si >= ($bitstype$)length || si < ($bitstype$)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -1139,1 +1271,1 @@\n-            return new $shuffletype$(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":177,"deletions":45,"binary":false,"changes":222,"status":"modified"}]}