{"files":[{"patch":"@@ -323,0 +323,4 @@\n+  bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -6153,35 +6157,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -6210,0 +6179,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -313,0 +313,4 @@\n+  bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -4400,35 +4404,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -4457,0 +4426,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1002,0 +1002,4 @@\n+bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2156,0 +2156,4 @@\n+bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+  bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n@@ -4425,35 +4428,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffleB(vReg dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"loadshuffleB $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ For T_BYTE, no need to do anything\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct loadshuffleX(vReg dst, vReg src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE ||\n-            Matcher::vector_element_basic_type(n) == T_LONG ||\n-            Matcher::vector_element_basic_type(n) == T_FLOAT ||\n-            Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"loadshuffleX $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vsetvli_helper(bt, Matcher::vector_length(this));\n-    if (bt == T_SHORT) {\n-      __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    } else if (bt == T_FLOAT || bt == T_INT) {\n-      __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    } else { \/\/ bt == T_DOUBLE || bt == T_LONG\n-      __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1758,0 +1758,4 @@\n+bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2214,0 +2214,13 @@\n+\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n+bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+  switch (elem_bt) {\n+    case T_BYTE:  return false;\n+    case T_SHORT: return !VM_Version::supports_avx512bw();\n+    case T_INT:   return !VM_Version::supports_avx();\n+    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n@@ -8843,11 +8856,0 @@\n-\n-instruct loadShuffleB(vec dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"vector_load_shuffle $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8920,1 +8922,1 @@\n-            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            !VM_Version::supports_avx512bw());\n@@ -8931,1 +8933,1 @@\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8946,2 +8948,1 @@\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8994,15 +8995,0 @@\n-instruct loadShuffleS_evex(vec dst, vec src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n-            VM_Version::supports_avx512bw());\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (!VM_Version::supports_avx512vl()) {\n-      vlen_enc = Assembler::AVX_512bit;\n-    }\n-    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -9039,1 +9025,1 @@\n-    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -9068,12 +9054,0 @@\n-instruct loadShuffleI_avx(vec dst, vec src) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n-            UseAVX > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -9109,2 +9083,1 @@\n-    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -9136,14 +9109,0 @@\n-instruct loadShuffleL_evex(vec dst, vec src) %{\n-  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":59,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1005,27 +1005,0 @@\n-  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n-   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n-                                               \"IIII\"                                                                                          \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n-   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n-   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n-                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n-   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name,                              \\\n-                                                                                                         vector_wrap_shuffle_indexes_sig, F_S) \\\n-   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava\/lang\/Class;\"                                                                          \\\n-                                                  \"Ljava\/lang\/Class;\"                                                                          \\\n-                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                       \\\n-                                                  \"ILjdk\/internal\/vm\/vector\/VectorSupport$WrapShuffleIndexesOperation;)\"                       \\\n-                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                      \\\n-   do_name(vector_wrap_shuffle_indexes_name, \"wrapShuffleIndexes\")                                                                             \\\n-                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -814,3 +814,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-  case vmIntrinsics::_VectorShuffleToVector:\n-  case vmIntrinsics::_VectorWrapShuffleIndexes:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -873,1 +873,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -715,2 +715,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-    return inline_vector_shuffle_iota();\n@@ -719,4 +717,0 @@\n-  case vmIntrinsics::_VectorShuffleToVector:\n-    return inline_vector_shuffle_to_vector();\n-  case vmIntrinsics::_VectorWrapShuffleIndexes:\n-    return inline_vector_wrap_shuffle_indexes();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -356,4 +356,0 @@\n-  bool inline_vector_shuffle_to_vector();\n-  bool inline_vector_wrap_shuffle_indexes();\n-  bool inline_vector_shuffle_iota();\n-  Node* partially_wrap_indexes(Node* index_vec, int num_elem, BasicType type_bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,0 +344,2 @@\n+  static bool vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -463,2 +458,0 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n@@ -509,3 +502,0 @@\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -165,1 +161,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -176,1 +172,1 @@\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n@@ -517,129 +513,1 @@\n-\/\/ Following routine generates IR corresponding to AbstractShuffle::partiallyWrapIndex method,\n-\/\/ which partially wraps index by modulo VEC_LENGTH and generates a negative index value if original\n-\/\/ index is out of valid index range [0, VEC_LENGTH)\n-\/\/\n-\/\/   wrapped_index = (VEC_LENGTH - 1) & index\n-\/\/   if (index u> VEC_LENGTH) {\n-\/\/     wrapped_index -= VEC_LENGTH;\n-\/\/\n-\/\/ Note: Unsigned greater than comparison treat both <0 and >VEC_LENGTH indices as out-of-bound\n-\/\/ indexes.\n-Node* LibraryCallKit::partially_wrap_indexes(Node* index_vec, int num_elem, BasicType elem_bt) {\n-  assert(elem_bt == T_BYTE, \"Shuffles use byte array based backing storage.\");\n-  const TypeVect* vt  = TypeVect::make(elem_bt, num_elem);\n-\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, elem_bt));\n-\n-  BoolTest::mask pred = BoolTest::ugt;\n-  ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(pred));\n-  Node* lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, elem_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n-  Node* mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n-\n-  \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n-  index_vec = gvn().transform(VectorNode::make(Op_AndV, index_vec, bcast_mod_mask, vt));\n-  Node* biased_val = gvn().transform(VectorNode::make(Op_SubVB, index_vec, bcast_lane_cnt, vt));\n-  return gvn().transform(new VectorBlendNode(biased_val, index_vec, mask));\n-}\n-\n-\/\/ <Sh extends VectorShuffle<E>,  E>\n-\/\/  Sh ShuffleIota(Class<?> E, Class<?> shuffleClass, Vector.Species<E> s, int length,\n-\/\/                  int start, int step, int wrap, ShuffleIotaOperation<Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_iota() {\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n-  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n-  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n-  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n-\n-  if (shuffle_klass == nullptr || shuffle_klass->const_oop() == nullptr ||\n-      vlen == nullptr || !vlen->is_con() || start_val == nullptr || step_val == nullptr ||\n-      wrap == nullptr || !wrap->is_con()) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-\n-  if (!is_klass_initialized(shuffle_klass)) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int do_wrap = wrap->get_con();\n-  int num_elem = vlen->get_con();\n-  BasicType elem_bt = T_BYTE;\n-\n-  bool effective_indices_in_range = false;\n-  if (start_val->is_con() && step_val->is_con()) {\n-    int effective_min_index = start_val->get_con();\n-    int effective_max_index = start_val->get_con() + step_val->get_con() * (num_elem - 1);\n-    effective_indices_in_range = effective_max_index >= effective_min_index && effective_min_index >= -128 && effective_max_index <= 127;\n-  }\n-\n-  if (!do_wrap && !effective_indices_in_range) {\n-    \/\/ Disable instrinsification for unwrapped shuffle iota if start\/step\n-    \/\/ values are non-constant OR if intermediate result overflows byte value range.\n-    return false;\n-  }\n-\n-  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)           ||\n-      !arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)            ||\n-      !arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n-      !arch_supports_vector(Op_Replicate, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-\n-  if (!do_wrap &&\n-      (!arch_supports_vector(Op_SubVB, num_elem, elem_bt, VecMaskNotUsed)       ||\n-      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskNotUsed)  ||\n-      !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed))) {\n-    return false;\n-  }\n-\n-  bool step_multiply = !step_val->is_con() || !is_power_of_2(step_val->get_con());\n-  if ((step_multiply && !arch_supports_vector(Op_MulVB, num_elem, elem_bt, VecMaskNotUsed)) ||\n-      (!step_multiply && !arch_supports_vector(Op_LShiftVB, num_elem, elem_bt, VecMaskNotUsed))) {\n-    return false;\n-  }\n-\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-\n-  Node* res = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n-\n-  Node* start = argument(4);\n-  Node* step  = argument(5);\n-\n-  if (step_multiply) {\n-    Node* bcast_step = gvn().transform(VectorNode::scalar2vector(step, num_elem, elem_bt));\n-    res = gvn().transform(VectorNode::make(Op_MulVB, res, bcast_step, vt));\n-  } else if (step_val->get_con() > 1) {\n-    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n-    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n-    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n-  }\n-\n-  if (!start_val->is_con() || start_val->get_con() != 0) {\n-    Node* bcast_start = gvn().transform(VectorNode::scalar2vector(start, num_elem, elem_bt));\n-    res = gvn().transform(VectorNode::make(Op_AddVB, res, bcast_start, vt));\n-  }\n-\n-  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, elem_bt));\n-\n-  if (do_wrap)  {\n-    \/\/ Wrap the indices greater than lane count.\n-    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n-  } else {\n-    res = partially_wrap_indexes(res, num_elem, elem_bt);\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Wrap it up in VectorBox to keep object type information.\n-  res = box_vector(res, shuffle_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n+\/\/ public static\n@@ -676,1 +544,0 @@\n-  const Type* elem_ty = Type::get_const_basic_type(elem_bt);\n@@ -679,1 +546,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -700,118 +567,0 @@\n-\/\/ public static\n-\/\/ <V,\n-\/\/  Sh extends VectorShuffle<E>,\n-\/\/  E>\n-\/\/ V shuffleToVector(Class<? extends Vector<E>> vclass, Class<E> elementType,\n-\/\/                   Class<? extends Sh> shuffleClass, Sh s, int length,\n-\/\/                   ShuffleToVectorOperation<V, Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_to_vector() {\n-  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n-  Node*              shuffle       = argument(3);\n-  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n-\n-  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-  if (!is_klass_initialized(shuffle_klass) || !is_klass_initialized(vector_klass) ) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int num_elem = vlen->get_con();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType elem_bt = elem_type->basic_type();\n-\n-  if (num_elem < 4) {\n-    return false;\n-  }\n-\n-  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n-  \/\/ Make sure that cast is implemented to particular type\/size combination.\n-  if (!arch_supports_vector(cast_vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-        cast_vopc, num_elem, type2name(elem_bt));\n-    return false;\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n-\n-  \/\/ cast byte to target element type\n-  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n-\n-  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* vec_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n-\n-  \/\/ Box vector\n-  Node* res = box_vector(shuffle_vec, vec_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n-\/\/ public static\n-\/\/ <E,\n-\/\/  SH extends VectorShuffle<E>>\n-\/\/ SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n-\/\/                       ShuffleWrapIndexesOperation<SH> defaultImpl)\n-bool LibraryCallKit::inline_vector_wrap_shuffle_indexes() {\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(0))->isa_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n-  Node*              shuffle       = argument(2);\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n-\n-  if (elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr ||\n-      !vlen->is_con() || shuffle_klass->const_oop() == nullptr) {\n-    \/\/ not enough info for intrinsification\n-    return false;\n-  }\n-\n-  if (!is_klass_initialized(shuffle_klass)) {\n-    log_if_needed(\"  ** klass argument not initialized\");\n-    return false;\n-  }\n-\n-  int num_elem = vlen->get_con();\n-  if ((num_elem < 4) || !is_power_of_2(num_elem)) {\n-    log_if_needed(\"  ** vlen < 4 or not power of two=%d\", num_elem);\n-    return false;\n-  }\n-\n-  \/\/ Shuffles use byte array based backing storage\n-  BasicType shuffle_bt = T_BYTE;\n-  if (!arch_supports_vector(Op_AndV, num_elem, shuffle_bt, VecMaskNotUsed) ||\n-      !arch_supports_vector(Op_Replicate, num_elem, shuffle_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: op=wrapShuffleIndexes vlen=%d etype=%s\",\n-                  num_elem, type2name(shuffle_bt));\n-    return false;\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, shuffle_bt, num_elem, true);\n-\n-  const TypeVect* vt  = TypeVect::make(shuffle_bt, num_elem);\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem - 1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_bt));\n-  \/\/ Wrap the indices greater than lane count.\n-  Node* res = gvn().transform(VectorNode::make(Op_AndV, shuffle_vec, bcast_mod_mask, vt));\n-\n-  \/\/ Wrap it up in VectorBox to keep object type information.\n-  res = box_vector(res, shuffle_box_type, shuffle_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(shuffle_bt))));\n-  return true;\n-}\n-\n@@ -1998,0 +1747,1 @@\n+\n@@ -2000,0 +1750,6 @@\n+  if (shuffle_bt == T_FLOAT) {\n+    shuffle_bt = T_INT;\n+  } else if (shuffle_bt == T_DOUBLE) {\n+    shuffle_bt = T_LONG;\n+  }\n+\n@@ -2001,0 +1757,1 @@\n+  bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(shuffle_bt, num_elem);\n@@ -2002,3 +1759,5 @@\n-  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) {\n-    log_if_needed(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n-                    num_elem, type2name(elem_bt));\n+  if (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, shuffle_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n+                    num_elem, type2name(shuffle_bt));\n+    }\n@@ -2016,0 +1775,5 @@\n+  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=2 op=and vlen=%d etype=%s ismask=no\",\n+                      num_elem, type2name(elem_bt));\n+    return false;\n+  }\n@@ -2036,0 +1800,1 @@\n+  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n@@ -2041,0 +1806,5 @@\n+  assert(is_power_of_2(num_elem), \"wrapping invalid\");\n+  Node* wrapping_mask_elem = gvn().makecon(TypeInteger::make(num_elem - 1, num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));\n+  Node* wrapping_mask = gvn().transform(VectorNode::scalar2vector(wrapping_mask_elem, num_elem, shuffle_bt));\n+  shuffle = gvn().transform(new AndVNode(shuffle, wrapping_mask, st));\n+\n@@ -2053,0 +1823,4 @@\n+  if (need_load_shuffle) {\n+    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, st));\n+  }\n+\n@@ -2059,1 +1833,0 @@\n-      const TypeVect* vt = v1->bottom_type()->is_vect();\n@@ -2157,0 +1930,8 @@\n+  BasicType shuffle_bt = elem_bt;\n+  if (shuffle_bt == T_FLOAT) {\n+    shuffle_bt = T_INT;\n+  } else if (shuffle_bt == T_DOUBLE) {\n+    shuffle_bt = T_LONG;\n+  }\n+  bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(shuffle_bt, num_elem);\n+\n@@ -2158,4 +1939,4 @@\n-  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)||\n-      !arch_supports_vector(Op_AndV, num_elem, T_BYTE, VecMaskNotUsed)              ||\n-      !arch_supports_vector(Op_Replicate, num_elem, T_BYTE, VecMaskNotUsed)         ||\n-      !arch_supports_vector(cast_vopc, num_elem, T_BYTE, VecMaskNotUsed)) {\n+  if ((need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) ||\n+      (elem_bt != shuffle_bt && !arch_supports_vector(cast_vopc, num_elem, shuffle_bt, VecMaskNotUsed))     ||\n+      !arch_supports_vector(Op_AndV, num_elem, shuffle_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(Op_Replicate, num_elem, shuffle_bt, VecMaskNotUsed)) {\n@@ -2218,2 +1999,6 @@\n-  const TypeVect* byte_vt = TypeVect::make(T_BYTE, num_elem);\n-  Node* byte_shuffle = gvn().transform(VectorCastNode::make(cast_vopc, v1, T_BYTE, num_elem));\n+  const TypeVect* shuffle_vt = TypeVect::make(shuffle_bt, num_elem);\n+  Node* shuffle = v1;\n+\n+  if (shuffle_bt != elem_bt) {\n+    shuffle = gvn().transform(VectorCastNode::make(cast_vopc, v1, shuffle_bt, num_elem));\n+  }\n@@ -2223,3 +2008,3 @@\n-  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, T_BYTE));\n-  byte_shuffle = gvn().transform(VectorNode::make(Op_AndV, byte_shuffle, bcast_mod, byte_vt));\n+  Node* mod_val = gvn().makecon(TypeInteger::make(num_elem - 1, num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));\n+  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, shuffle_bt));\n+  shuffle = gvn().transform(VectorNode::make(Op_AndV, shuffle, bcast_mod, shuffle_vt));\n@@ -2228,2 +2013,3 @@\n-  const TypeVect* shuffle_vt = TypeVect::make(elem_bt, num_elem);\n-  Node* load_shuffle = gvn().transform(new VectorLoadShuffleNode(byte_shuffle, shuffle_vt));\n+  if (need_load_shuffle) {\n+    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, shuffle_vt));\n+  }\n@@ -2232,1 +2018,1 @@\n-  Node* rearrange = new VectorRearrangeNode(v2, load_shuffle);\n+  Node* rearrange = new VectorRearrangeNode(v2, shuffle);\n@@ -2485,3 +2271,1 @@\n-  if (is_vector_shuffle(vbox_klass_from)) {\n-    return false; \/\/ vector shuffles aren't supported\n-  }\n+\n@@ -2527,12 +2311,0 @@\n-\n-  if (is_vector_shuffle(vbox_klass_to) &&\n-      (!arch_supports_vector(Op_SubVB, num_elem_to, elem_bt_to, VecMaskNotUsed)           ||\n-       !arch_supports_vector(Op_VectorBlend, num_elem_to, elem_bt_to, VecMaskNotUsed)     ||\n-       !arch_supports_vector(Op_VectorMaskCmp, num_elem_to, elem_bt_to, VecMaskNotUsed)   ||\n-       !arch_supports_vector(Op_AndV, num_elem_to, elem_bt_to, VecMaskNotUsed)            ||\n-       !arch_supports_vector(Op_Replicate, num_elem_to, elem_bt_to, VecMaskNotUsed))) {\n-    log_if_needed(\"  ** not supported: arity=1 op=shuffle_index_wrap vlen2=%d etype2=%s\",\n-                    num_elem_to, type2name(elem_bt_to));\n-    return false;\n-  }\n-\n@@ -2636,4 +2408,0 @@\n-  if (is_vector_shuffle(vbox_klass_to)) {\n-     op = partially_wrap_indexes(op, num_elem_to, elem_bt_to);\n-  }\n-\n@@ -2867,2 +2635,7 @@\n-  const TypeVect* index_vect_type = index_vec->bottom_type()->is_vect();\n-  BasicType index_elem_bt = index_vect_type->element_basic_type();\n+  BasicType shuffle_bt = elem_bt;\n+  if (shuffle_bt == T_FLOAT) {\n+    shuffle_bt = T_INT;\n+  } else if (shuffle_bt == T_DOUBLE) {\n+    shuffle_bt = T_LONG;\n+  }\n+  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n@@ -2870,5 +2643,5 @@\n-  \/\/ Downcast index vector to a type agnostic shuffle representation, shuffle\n-  \/\/ indices are held in a byte vector which are later transformed to target\n-  \/\/ specific permutation index format by subsequent VectorLoadShuffle.\n-  int cast_vopc = VectorCastNode::opcode(0, index_elem_bt, true);\n-  Node* index_byte_vec = phase.transform(VectorCastNode::make(cast_vopc, index_vec, T_BYTE, num_elem));\n+  \/\/ Cast index vector to the corresponding bit type\n+  if (elem_bt != shuffle_bt) {\n+    int cast_vopc = VectorCastNode::opcode(0, elem_bt, true);\n+    index_vec = phase.transform(VectorCastNode::make(cast_vopc, index_vec, shuffle_bt, num_elem));\n+  }\n@@ -2877,1 +2650,1 @@\n-  Node* two_vect_lane_cnt_m1 = phase.makecon(TypeInt::make(2 * num_elem - 1));\n+  Node* two_vect_lane_cnt_m1 = phase.makecon(TypeInteger::make(2 * num_elem - 1, 2 * num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));\n@@ -2879,3 +2652,2 @@\n-                                                                                   T_BYTE, false));\n-  index_byte_vec = phase.transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_two_vect_lane_cnt_m1_vec,\n-                                                    index_byte_vec->bottom_type()->is_vect()));\n+                                                                                   shuffle_bt, false));\n+  index_vec = phase.transform(VectorNode::make(Op_AndV, index_vec, bcast_two_vect_lane_cnt_m1_vec, st));\n@@ -2887,5 +2659,4 @@\n-  const TypeVect* vmask_type = TypeVect::makemask(T_BYTE, num_elem);\n-  Node* lane_cnt_m1 = phase.makecon(TypeInt::make(num_elem - 1));\n-  Node* bcast_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem,\n-                                                                          T_BYTE, false));\n-  Node* mask = phase.transform(new VectorMaskCmpNode(pred, index_byte_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n+  const TypeVect* vmask_type = TypeVect::makemask(shuffle_bt, num_elem);\n+  Node* lane_cnt_m1 = phase.makecon(TypeInteger::make(num_elem - 1, num_elem - 1, Type::WidenMin, shuffle_bt == T_LONG ? T_LONG : T_INT));\n+  Node* bcast_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem, shuffle_bt, false));\n+  Node* mask = phase.transform(new VectorMaskCmpNode(pred, index_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n@@ -2894,2 +2665,1 @@\n-  index_byte_vec = phase.transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_lane_cnt_m1_vec,\n-                       index_byte_vec->bottom_type()->is_vect()));\n+  Node* wrapped_index_vec = phase.transform(VectorNode::make(Op_AndV, index_vec, bcast_lane_cnt_m1_vec, st));\n@@ -2899,1 +2669,3 @@\n-  index_vec = phase.transform(new VectorLoadShuffleNode(index_byte_vec, index_vect_type));\n+  if (Matcher::vector_rearrange_requires_load_shuffle(shuffle_bt, num_elem)) {\n+    wrapped_index_vec = phase.transform(new VectorLoadShuffleNode(wrapped_index_vec, st));\n+  }\n@@ -2904,2 +2676,2 @@\n-  Node* p1 = phase.transform(new VectorRearrangeNode(src1, index_vec));\n-  Node* p2 = phase.transform(new VectorRearrangeNode(src2, index_vec));\n+  Node* p1 = phase.transform(new VectorRearrangeNode(src1, wrapped_index_vec));\n+  Node* p2 = phase.transform(new VectorRearrangeNode(src2, wrapped_index_vec));\n@@ -2958,2 +2730,3 @@\n-    if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, T_BYTE, VecMaskNotUsed)            ||\n-        !arch_supports_vector(Op_AndV, num_elem, T_BYTE, VecMaskNotUsed)                     ||\n+    if ((elem_bt != index_elem_bt && !arch_supports_vector(cast_vopc, num_elem, index_elem_bt, VecMaskNotUsed)) ||\n+        !arch_supports_vector(Op_VectorMaskCmp, num_elem, index_elem_bt, VecMaskNotUsed)     ||\n+        !arch_supports_vector(Op_AndV, num_elem, index_elem_bt, VecMaskNotUsed)              ||\n@@ -2963,1 +2736,0 @@\n-        !arch_supports_vector(cast_vopc, num_elem, T_BYTE, VecMaskNotUsed)                   ||\n@@ -2965,1 +2737,1 @@\n-        !arch_supports_vector(Op_Replicate, num_elem, T_BYTE, VecMaskNotUsed)) {\n+        !arch_supports_vector(Op_Replicate, num_elem, index_elem_bt, VecMaskNotUsed)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":87,"deletions":315,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -1734,2 +1734,1 @@\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+        bool is_vector_mask = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -1740,5 +1739,0 @@\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n@@ -1746,1 +1740,1 @@\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n+          \/\/ Vector type mismatch is only supported for masks, but sometimes it happens in pathological cases.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1691,1 +1691,7 @@\n-\n+\/\/ The machine may not directly support the rearrange operation of an element type. In those cases,\n+\/\/ we can transform the rearrange into a different element type. For example, on x86 before AVX512,\n+\/\/ there is no rearrange instruction for short elements, what we will then do is to transform the\n+\/\/ shuffle vector into one that we can do byte rearrange such that it would provide the same\n+\/\/ result. This could have been done in VectorRearrangeNode during code emission but we eagerly\n+\/\/ expand out this because it is often the case that an index vector is reused in many rearrange\n+\/\/ operations. This allows the index preparation to be GVN-ed as well as hoisted out of loops, etc.\n@@ -1695,3 +1701,1 @@\n-    : VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n-  }\n+    : VectorNode(in, vt) {}\n@@ -1699,1 +1703,0 @@\n-  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1938,2 +1941,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1943,1 +1944,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1945,1 +1946,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1956,1 +1956,0 @@\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,4 +76,0 @@\n-bool VectorSupport::is_vector_shuffle(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorShuffle_klass());\n-}\n-\n@@ -90,3 +86,1 @@\n-  if (is_vector_shuffle(ik)) {\n-    return T_BYTE;\n-  } else if (is_vector_mask(ik)) {\n+  if (is_vector_mask(ik)) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-  static bool is_vector_shuffle(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,50 +237,0 @@\n-    \/* ============================================================================ *\/\n-    public interface ShuffleIotaOperation<S extends VectorSpecies<?>,\n-                                          SH extends VectorShuffle<?>> {\n-        SH apply(int length, int start, int step, S s);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <E,\n-     S extends VectorSpecies<E>,\n-     SH extends VectorShuffle<E>>\n-    SH shuffleIota(Class<E> eClass, Class<? extends SH> shClass, S s,\n-                   int length,\n-                   int start, int step, int wrap,\n-                   ShuffleIotaOperation<S, SH> defaultImpl) {\n-       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-       return defaultImpl.apply(length, start, step, s);\n-    }\n-\n-    public interface ShuffleToVectorOperation<V extends Vector<?>,\n-                                              SH extends VectorShuffle<?>> {\n-       V apply(SH sh);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <V extends Vector<E>,\n-     SH extends VectorShuffle<E>,\n-     E>\n-    V shuffleToVector(Class<? extends Vector<E>> vClass, Class<E> eClass, Class<? extends SH> shClass, SH sh,\n-                      int length,\n-                      ShuffleToVectorOperation<V, SH> defaultImpl) {\n-      assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-      return defaultImpl.apply(sh);\n-    }\n-\n-    public interface WrapShuffleIndexesOperation<SH extends VectorShuffle<?>> {\n-        SH apply(SH sh);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <E,\n-     SH extends VectorShuffle<E>>\n-    SH wrapShuffleIndexes(Class<E> eClass, Class<? extends SH> shClass, SH sh, int length,\n-                          WrapShuffleIndexesOperation<SH> defaultImpl) {\n-       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-       return defaultImpl.apply(sh);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.vector.VectorSupport;\n@@ -33,1 +34,1 @@\n-    \/\/ Internal representation allows for a maximum index of 256\n+    \/\/ Internal representation allows for a maximum index of E.MAX_VALUE - 1\n@@ -36,40 +37,2 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n-\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = reorder[offset + i];\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n-            int si = f.applyAsInt(i);\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n+    AbstractShuffle(Object indices) {\n+        super(indices);\n@@ -87,1 +50,3 @@\n-    @Override\n+    \/*package-private*\/\n+    abstract AbstractVector<?> toBitsVector();\n+\n@@ -89,8 +54,9 @@\n-    public void intoArray(int[] a, int offset) {\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n-        for (int i = 0; i < vlen; i++) {\n-            int sourceIndex = reorder[i];\n-            assert(sourceIndex >= -vlen && sourceIndex < vlen);\n-            a[offset + i] = sourceIndex;\n-        }\n+    final AbstractVector<?> toBitsVectorTemplate() {\n+        AbstractSpecies<?> dsp = vspecies().asIntegral();\n+        Class<?> etype = dsp.elementType();\n+        Class<?> rvtype = dsp.dummyVector().getClass();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                                     getClass(), etype, length(),\n+                                     rvtype, etype, length(),\n+                                     this, dsp,\n+                                     (v, s) -> v.toBitsVector0());\n@@ -99,0 +65,2 @@\n+    abstract AbstractVector<?> toBitsVector0();\n+\n@@ -101,5 +69,4 @@\n-    public int[] toArray() {\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n-        intoArray(a, 0);\n-        return a;\n+    public final int[] toArray() {\n+        int[] res = new int[length()];\n+        intoArray(res, 0);\n+        return res;\n@@ -108,1 +75,1 @@\n-    \/*package-private*\/\n+    @Override\n@@ -110,9 +77,5 @@\n-    final\n-    AbstractVector<E>\n-    toVectorTemplate() {\n-        \/\/ Note that the values produced by laneSource\n-        \/\/ are already clipped.  At this point we convert\n-        \/\/ them from internal ints (or bytes) into the ETYPE.\n-        \/\/ FIXME: Use a conversion intrinsic for this operation.\n-        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8225740\n-        return (AbstractVector<E>) vspecies().fromIntValues(toArray());\n+    public final <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+        if (length() != s.length()) {\n+            throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+        }\n+        return toBitsVector().bitsToShuffle((AbstractSpecies<F>) s);\n@@ -121,0 +84,1 @@\n+    @Override\n@@ -126,13 +90,2 @@\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n-        if (vecmask.anyTrue()) {\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n-        }\n-        return this;\n-    }\n-\n-    @ForceInline\n-    public final VectorShuffle<E> wrapIndexesTemplate() {\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n+        Vector<?> shufvec = this.toBitsVector();\n+        VectorMask<?> vecmask = shufvec.compare(VectorOperators.LT, 0);\n@@ -140,3 +93,2 @@\n-            \/\/ FIXME: vectorize this\n-            byte[] reorder = reorder();\n-            return wrapAndRebuild(reorder);\n+            int[] indices = toArray();\n+            throw checkIndexFailed(indices[vecmask.firstTrue()], length());\n@@ -147,25 +99,0 @@\n-    @ForceInline\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = oldReorder[i];\n-            \/\/ FIXME: This does not work unless it's a power of 2.\n-            if ((length & (length - 1)) == 0) {\n-                si += si & length;  \/\/ power-of-two optimization\n-            } else if (si < 0) {\n-                \/\/ non-POT code requires a conditional add\n-                si += length;\n-            }\n-            assert(si >= 0 && si < length);\n-            reorder[i] = (byte) si;\n-        }\n-        return vspecies().dummyVector().shuffleFromBytes(reorder);\n-    }\n-\n-    @ForceInline\n-    public final VectorMask<E> laneIsValid() {\n-        Vector<E> shufvec = this.toVector();\n-        return shufvec.compare(VectorOperators.GE, vspecies().zero());\n-    }\n-\n@@ -223,17 +150,0 @@\n-\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n-            if (si >= length || si < -length) {\n-                boolean assertsEnabled = false;\n-                assert(assertsEnabled = true);\n-                if (assertsEnabled) {\n-                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(reorder));\n-                    throw new AssertionError(msg);\n-                }\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":34,"deletions":124,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+    final Class<? extends AbstractShuffle<E>> shuffleType;\n+    @Stable\n@@ -64,0 +66,1 @@\n+                    Class<? extends AbstractShuffle<E>> shuffleType,\n@@ -69,0 +72,1 @@\n+        this.shuffleType = shuffleType;\n@@ -165,0 +169,5 @@\n+    @ForceInline\n+    final Class<? extends AbstractShuffle<E>> shuffleType() {\n+        return shuffleType;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-    abstract AbstractShuffle<E> iotaShuffle();\n+    abstract <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp);\n@@ -199,1 +199,19 @@\n-    abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n+    \/*package-private*\/\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffleTemplate(AbstractSpecies<F> dsp) {\n+        Class<?> etype = vspecies().elementType();\n+        Class<?> dvtype = dsp.shuffleType();\n+        Class<?> dtype = dsp.asIntegral().elementType();\n+        int dlength = dsp.dummyVector().length();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), etype, length(),\n+                                     dvtype, dtype, dlength,\n+                                     this, dsp,\n+                                     AbstractVector::bitsToShuffle0);\n+    }\n+\n+    abstract <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp);\n+\n+    abstract <F> VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap);\n+\n+    abstract VectorShuffle<E> iotaShuffle();\n@@ -201,2 +219,15 @@\n-    \/*do not alias this byte array*\/\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n+    abstract VectorShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n+\n+    @ForceInline\n+    final VectorShuffle<E> iotaShuffleTemplate(int start, int step, boolean wrap) {\n+        if ((length() & (length() - 1)) != 0) {\n+            \/\/ Uncommon path, the length is not a power of 2\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, length())))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n+\n+        AbstractVector<?> iota = vspecies().asIntegral().iota();\n+        iota = (AbstractVector<?>) iota.lanewise(VectorOperators.MUL, step)\n+                .lanewise(VectorOperators.ADD, start);\n+        return iota.toShuffle(vspecies(), wrap);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte128Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte128Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte128Shuffle(indexes, i); }\n+    Byte128Shuffle shuffleFromArray(int[] indices, int i) { return new Byte128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n+    public final Byte128Shuffle toShuffle() {\n+        return (Byte128Shuffle) toShuffle(vspecies(), false);\n@@ -824,2 +822,4 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -828,2 +828,2 @@\n-        public Byte128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -832,2 +832,2 @@\n-        public Byte128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -836,2 +836,2 @@\n-        public Byte128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -841,0 +841,1 @@\n+        @ForceInline\n@@ -856,2 +857,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte128Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -862,6 +862,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte128Vector toBitsVector() {\n+            return (Byte128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte128Vector toBitsVector0() {\n+            return ((Byte128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -872,3 +873,2 @@\n-        public Byte128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte128Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -877,0 +877,1 @@\n+        @Override\n@@ -878,0 +879,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -879,8 +897,55 @@\n-        public Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte128Shuffle s = (Byte128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte128Mask laneIsValid() {\n+            return (Byte128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte128Shuffle concreteShuffle = (Byte128Shuffle) shuffle;\n+            return (Byte128Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte128Shuffle wrapIndexes() {\n+            Byte128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -888,1 +953,1 @@\n-            return new Byte128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte256Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte256Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte256Shuffle(indexes, i); }\n+    Byte256Shuffle shuffleFromArray(int[] indices, int i) { return new Byte256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n+    public final Byte256Shuffle toShuffle() {\n+        return (Byte256Shuffle) toShuffle(vspecies(), false);\n@@ -856,2 +854,4 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -860,2 +860,2 @@\n-        public Byte256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -864,2 +864,2 @@\n-        public Byte256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -868,2 +868,2 @@\n-        public Byte256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -873,0 +873,1 @@\n+        @ForceInline\n@@ -888,2 +889,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte256Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -894,6 +894,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte256Vector toBitsVector() {\n+            return (Byte256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte256Vector toBitsVector0() {\n+            return ((Byte256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -904,3 +905,2 @@\n-        public Byte256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte256Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -909,0 +909,1 @@\n+        @Override\n@@ -910,0 +911,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -911,8 +929,55 @@\n-        public Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte256Shuffle s = (Byte256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte256Mask laneIsValid() {\n+            return (Byte256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte256Shuffle concreteShuffle = (Byte256Shuffle) shuffle;\n+            return (Byte256Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte256Shuffle wrapIndexes() {\n+            Byte256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -920,1 +985,1 @@\n-            return new Byte256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte512Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte512Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte512Shuffle(indexes, i); }\n+    Byte512Shuffle shuffleFromArray(int[] indices, int i) { return new Byte512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n+    public final Byte512Shuffle toShuffle() {\n+        return (Byte512Shuffle) toShuffle(vspecies(), false);\n@@ -920,2 +918,4 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -924,2 +924,2 @@\n-        public Byte512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -928,2 +928,2 @@\n-        public Byte512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -932,2 +932,2 @@\n-        public Byte512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -937,0 +937,1 @@\n+        @ForceInline\n@@ -952,2 +953,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte512Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -958,6 +958,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte512Vector toBitsVector() {\n+            return (Byte512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte512Vector toBitsVector0() {\n+            return ((Byte512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -968,3 +969,2 @@\n-        public Byte512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte512Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -973,0 +973,1 @@\n+        @Override\n@@ -974,0 +975,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -975,8 +993,55 @@\n-        public Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte512Shuffle s = (Byte512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte512Mask laneIsValid() {\n+            return (Byte512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte512Shuffle concreteShuffle = (Byte512Shuffle) shuffle;\n+            return (Byte512Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte512Shuffle wrapIndexes() {\n+            Byte512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -984,1 +1049,1 @@\n-            return new Byte512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Byte64Shuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Byte64Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte64Shuffle(indexes, i); }\n+    Byte64Shuffle shuffleFromArray(int[] indices, int i) { return new Byte64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n+    public final Byte64Shuffle toShuffle() {\n+        return (Byte64Shuffle) toShuffle(vspecies(), false);\n@@ -808,2 +806,4 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -812,2 +812,2 @@\n-        public Byte64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -816,2 +816,2 @@\n-        public Byte64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -820,2 +820,2 @@\n-        public Byte64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -825,0 +825,1 @@\n+        @ForceInline\n@@ -840,2 +841,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte64Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -846,6 +846,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Byte64Vector toBitsVector() {\n+            return (Byte64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Byte64Vector toBitsVector0() {\n+            return ((Byte64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -856,3 +857,2 @@\n-        public Byte64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Byte64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte64Shuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -861,0 +861,1 @@\n+        @Override\n@@ -862,0 +863,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -863,8 +881,55 @@\n-        public Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            Byte64Shuffle s = (Byte64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Byte64Mask laneIsValid() {\n+            return (Byte64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            Byte64Shuffle concreteShuffle = (Byte64Shuffle) shuffle;\n+            return (Byte64Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Byte64Shuffle wrapIndexes() {\n+            Byte64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Byte64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Byte64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Byte64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -872,1 +937,1 @@\n-            return new Byte64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (ByteMaxShuffle) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n@@ -157,5 +152,1 @@\n-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n+    ByteMaxShuffle shuffleFromArray(int[] indices, int i) { return new ByteMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n+    public final ByteMaxShuffle toShuffle() {\n+        return (ByteMaxShuffle) toShuffle(vspecies(), false);\n@@ -794,2 +792,4 @@\n-        ByteMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -798,2 +798,2 @@\n-        public ByteMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -802,2 +802,2 @@\n-        public ByteMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ByteMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -806,2 +806,2 @@\n-        public ByteMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -811,0 +811,1 @@\n+        @ForceInline\n@@ -826,2 +827,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -832,6 +832,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        ByteMaxVector toBitsVector() {\n+            return (ByteMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ByteMaxVector toBitsVector0() {\n+            return ((ByteMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -842,3 +843,2 @@\n-        public ByteMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxShuffle)(((AbstractShuffle<Byte>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -847,0 +847,1 @@\n+        @Override\n@@ -848,0 +849,17 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+        }\n+\n@@ -849,8 +867,55 @@\n-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final ByteMaxMask laneIsValid() {\n+            return (ByteMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            ByteMaxShuffle concreteShuffle = (ByteMaxShuffle) shuffle;\n+            return (ByteMaxShuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ByteMaxShuffle wrapIndexes() {\n+            ByteMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ByteMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ByteMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (ByteMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -858,1 +923,1 @@\n-            return new ByteMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-   \/**\n+    \/**\n@@ -2428,2 +2428,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2432,1 +2430,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2434,1 +2432,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2457,2 +2455,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2461,1 +2457,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2463,1 +2459,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2484,2 +2480,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2489,1 +2483,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2491,1 +2485,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2497,1 +2491,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2499,1 +2493,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2505,0 +2499,1 @@\n+    @Override\n@@ -2506,2 +2501,2 @@\n-    private final\n-    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        assert(dsp.length() == vspecies().length());\n@@ -2516,1 +2511,0 @@\n-    \/*package-private*\/\n@@ -2518,8 +2512,11 @@\n-    final\n-    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n-        ByteSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), byte.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     ByteVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ByteVector idx = this;\n+        ByteVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ByteVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Byte> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -4219,0 +4216,1 @@\n+                Class<? extends AbstractShuffle<Byte>> shuffleType,\n@@ -4221,1 +4219,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4507,0 +4505,1 @@\n+                            Byte64Vector.Byte64Shuffle.class,\n@@ -4514,0 +4513,1 @@\n+                            Byte128Vector.Byte128Shuffle.class,\n@@ -4521,0 +4521,1 @@\n+                            Byte256Vector.Byte256Shuffle.class,\n@@ -4528,0 +4529,1 @@\n+                            Byte512Vector.Byte512Shuffle.class,\n@@ -4535,0 +4537,1 @@\n+                            ByteMaxVector.ByteMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double128Shuffle shuffleFromArray(int[] indexes, int i) { return new Double128Shuffle(indexes, i); }\n+    Double128Shuffle shuffleFromArray(int[] indices, int i) { return new Double128Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n+    public final Double128Shuffle toShuffle() {\n+        return (Double128Shuffle) toShuffle(vspecies(), false);\n@@ -783,1 +781,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -785,2 +783,4 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -789,2 +789,2 @@\n-        public Double128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -793,2 +793,2 @@\n-        public Double128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -797,2 +797,2 @@\n-        public Double128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -802,0 +802,1 @@\n+        @ForceInline\n@@ -809,2 +810,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -817,2 +818,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double128Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double128Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -823,6 +823,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long128Vector toBitsVector() {\n+            return (Long128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long128Vector toBitsVector0() {\n+            return ((Long128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -833,3 +834,2 @@\n-        public Double128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double128Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -838,0 +838,1 @@\n+        @Override\n@@ -839,0 +840,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -840,8 +869,55 @@\n-        public Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double128Shuffle s = (Double128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double128Mask laneIsValid() {\n+            return (Double128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double128Shuffle concreteShuffle = (Double128Shuffle) shuffle;\n+            return (Double128Shuffle) toBitsVector().rearrange(concreteShuffle.cast(LongVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -849,1 +925,1 @@\n-            return new Double128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":121,"deletions":45,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double256Shuffle shuffleFromArray(int[] indexes, int i) { return new Double256Shuffle(indexes, i); }\n+    Double256Shuffle shuffleFromArray(int[] indices, int i) { return new Double256Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n+    public final Double256Shuffle toShuffle() {\n+        return (Double256Shuffle) toShuffle(vspecies(), false);\n@@ -787,1 +785,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -789,2 +787,4 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -793,2 +793,2 @@\n-        public Double256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -797,2 +797,2 @@\n-        public Double256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -801,2 +801,2 @@\n-        public Double256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -806,0 +806,1 @@\n+        @ForceInline\n@@ -813,2 +814,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -821,2 +822,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double256Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double256Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -827,6 +827,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long256Vector toBitsVector() {\n+            return (Long256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long256Vector toBitsVector0() {\n+            return ((Long256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -837,3 +838,2 @@\n-        public Double256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double256Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -842,0 +842,1 @@\n+        @Override\n@@ -843,0 +844,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -844,8 +873,55 @@\n-        public Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double256Shuffle s = (Double256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double256Mask laneIsValid() {\n+            return (Double256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double256Shuffle concreteShuffle = (Double256Shuffle) shuffle;\n+            return (Double256Shuffle) toBitsVector().rearrange(concreteShuffle.cast(LongVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -853,1 +929,1 @@\n-            return new Double256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":121,"deletions":45,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double512Shuffle shuffleFromArray(int[] indexes, int i) { return new Double512Shuffle(indexes, i); }\n+    Double512Shuffle shuffleFromArray(int[] indices, int i) { return new Double512Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n+    public final Double512Shuffle toShuffle() {\n+        return (Double512Shuffle) toShuffle(vspecies(), false);\n@@ -795,1 +793,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -797,2 +795,4 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -801,2 +801,2 @@\n-        public Double512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -805,2 +805,2 @@\n-        public Double512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -809,2 +809,2 @@\n-        public Double512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -814,0 +814,1 @@\n+        @ForceInline\n@@ -821,2 +822,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -829,2 +830,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double512Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double512Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -835,6 +835,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long512Vector toBitsVector() {\n+            return (Long512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long512Vector toBitsVector0() {\n+            return ((Long512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -845,3 +846,2 @@\n-        public Double512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double512Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -850,0 +850,1 @@\n+        @Override\n@@ -851,0 +852,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -852,8 +881,55 @@\n-        public Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double512Shuffle s = (Double512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double512Mask laneIsValid() {\n+            return (Double512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double512Shuffle concreteShuffle = (Double512Shuffle) shuffle;\n+            return (Double512Shuffle) toBitsVector().rearrange(concreteShuffle.cast(LongVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -861,1 +937,1 @@\n-            return new Double512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":121,"deletions":45,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Double64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Double64Shuffle shuffleFromArray(int[] indexes, int i) { return new Double64Shuffle(indexes, i); }\n+    Double64Shuffle shuffleFromArray(int[] indices, int i) { return new Double64Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n+    public final Double64Shuffle toShuffle() {\n+        return (Double64Shuffle) toShuffle(vspecies(), false);\n@@ -781,1 +779,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -783,2 +781,4 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -787,2 +787,2 @@\n-        public Double64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -791,2 +791,2 @@\n-        public Double64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -795,2 +795,2 @@\n-        public Double64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -800,0 +800,1 @@\n+        @ForceInline\n@@ -807,2 +808,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -815,2 +816,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double64Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (Double64Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -821,6 +821,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long64Vector toBitsVector() {\n+            return (Long64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long64Vector toBitsVector0() {\n+            return ((Long64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -831,3 +832,2 @@\n-        public Double64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Double64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double64Shuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -836,0 +836,1 @@\n+        @Override\n@@ -837,0 +838,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -838,8 +867,55 @@\n-        public Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            Double64Shuffle s = (Double64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Double64Mask laneIsValid() {\n+            return (Double64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n+            Double64Shuffle concreteShuffle = (Double64Shuffle) shuffle;\n+            return (Double64Shuffle) toBitsVector().rearrange(concreteShuffle.cast(LongVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Double64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Double64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -847,1 +923,1 @@\n-            return new Double64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":121,"deletions":45,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (DoubleMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n+    DoubleMaxShuffle shuffleFromArray(int[] indices, int i) { return new DoubleMaxShuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n+    public final DoubleMaxShuffle toShuffle() {\n+        return (DoubleMaxShuffle) toShuffle(vspecies(), false);\n@@ -780,1 +778,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -782,2 +780,4 @@\n-        DoubleMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -786,2 +786,2 @@\n-        public DoubleMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -790,2 +790,2 @@\n-        public DoubleMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        DoubleMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -794,2 +794,2 @@\n-        public DoubleMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -799,0 +799,1 @@\n+        @ForceInline\n@@ -806,2 +807,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -814,2 +815,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+            return (DoubleMaxVector) toBitsVector().castShape(vspecies(), 0);\n@@ -820,6 +820,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        LongMaxVector toBitsVector() {\n+            return (LongMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        LongMaxVector toBitsVector0() {\n+            return ((LongMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -830,3 +831,2 @@\n-        public DoubleMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxShuffle)(((AbstractShuffle<Double>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -835,0 +835,1 @@\n+        @Override\n@@ -836,0 +837,28 @@\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -837,8 +866,55 @@\n-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final DoubleMaxMask laneIsValid() {\n+            return (DoubleMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n+            DoubleMaxShuffle concreteShuffle = (DoubleMaxShuffle) shuffle;\n+            return (DoubleMaxShuffle) toBitsVector().rearrange(concreteShuffle.cast(LongVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final DoubleMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (LongMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (LongMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (DoubleMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -846,1 +922,1 @@\n-            return new DoubleMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":121,"deletions":45,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -969,1 +969,1 @@\n-   \/**\n+    \/**\n@@ -2258,2 +2258,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2262,1 +2260,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2264,1 +2262,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2287,2 +2285,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2291,1 +2287,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2293,1 +2289,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2314,2 +2310,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2319,1 +2313,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2321,1 +2315,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2327,1 +2321,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2329,1 +2323,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2335,0 +2329,1 @@\n+    @Override\n@@ -2336,8 +2331,2 @@\n-    private final\n-    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n@@ -2346,1 +2335,0 @@\n-    \/*package-private*\/\n@@ -2348,8 +2336,11 @@\n-    final\n-    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n-        DoubleSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), double.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     DoubleVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        LongVector idx = convert(VectorOperators.D2L, 0).reinterpretAsLongs();\n+        LongVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            LongVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Long> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3734,0 +3725,1 @@\n+                Class<? extends AbstractShuffle<Double>> shuffleType,\n@@ -3736,1 +3728,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4022,0 +4014,1 @@\n+                            Double64Vector.Double64Shuffle.class,\n@@ -4029,0 +4022,1 @@\n+                            Double128Vector.Double128Shuffle.class,\n@@ -4036,0 +4030,1 @@\n+                            Double256Vector.Double256Shuffle.class,\n@@ -4043,0 +4038,1 @@\n+                            Double512Vector.Double512Shuffle.class,\n@@ -4050,0 +4046,1 @@\n+                            DoubleMaxVector.DoubleMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float128Shuffle shuffleFromArray(int[] indexes, int i) { return new Float128Shuffle(indexes, i); }\n+    Float128Shuffle shuffleFromArray(int[] indices, int i) { return new Float128Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n+    public final Float128Shuffle toShuffle() {\n+        return (Float128Shuffle) toShuffle(vspecies(), false);\n@@ -787,1 +785,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -789,2 +787,4 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -793,2 +793,2 @@\n-        public Float128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -797,2 +797,2 @@\n-        public Float128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -801,2 +801,2 @@\n-        public Float128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -806,0 +806,1 @@\n+        @ForceInline\n@@ -813,2 +814,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -821,2 +822,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float128Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float128Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -827,6 +827,19 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int128Vector toBitsVector() {\n+            return (Int128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int128Vector toBitsVector0() {\n+            return ((Int128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -837,3 +850,11 @@\n-        public Float128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float128Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public final Float128Mask laneIsValid() {\n+            return (Float128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float128Shuffle concreteShuffle = (Float128Shuffle) shuffle;\n+            return (Float128Shuffle) toBitsVector().rearrange(concreteShuffle.cast(IntVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n@@ -844,8 +865,39 @@\n-        public Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float128Shuffle s = (Float128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -853,1 +905,1 @@\n-            return new Float128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":97,"deletions":45,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float256Shuffle shuffleFromArray(int[] indexes, int i) { return new Float256Shuffle(indexes, i); }\n+    Float256Shuffle shuffleFromArray(int[] indices, int i) { return new Float256Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n+    public final Float256Shuffle toShuffle() {\n+        return (Float256Shuffle) toShuffle(vspecies(), false);\n@@ -795,1 +793,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -797,2 +795,4 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -801,2 +801,2 @@\n-        public Float256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -805,2 +805,2 @@\n-        public Float256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -809,2 +809,2 @@\n-        public Float256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -814,0 +814,1 @@\n+        @ForceInline\n@@ -821,2 +822,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -829,2 +830,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float256Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float256Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -835,6 +835,19 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int256Vector toBitsVector() {\n+            return (Int256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int256Vector toBitsVector0() {\n+            return ((Int256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -845,3 +858,11 @@\n-        public Float256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float256Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public final Float256Mask laneIsValid() {\n+            return (Float256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float256Shuffle concreteShuffle = (Float256Shuffle) shuffle;\n+            return (Float256Shuffle) toBitsVector().rearrange(concreteShuffle.cast(IntVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n@@ -852,8 +873,39 @@\n-        public Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float256Shuffle s = (Float256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -861,1 +913,1 @@\n-            return new Float256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":97,"deletions":45,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float512Shuffle shuffleFromArray(int[] indexes, int i) { return new Float512Shuffle(indexes, i); }\n+    Float512Shuffle shuffleFromArray(int[] indices, int i) { return new Float512Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n+    public final Float512Shuffle toShuffle() {\n+        return (Float512Shuffle) toShuffle(vspecies(), false);\n@@ -811,1 +809,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -813,2 +811,4 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -817,2 +817,2 @@\n-        public Float512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -821,2 +821,2 @@\n-        public Float512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -825,2 +825,2 @@\n-        public Float512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -830,0 +830,1 @@\n+        @ForceInline\n@@ -837,2 +838,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -845,2 +846,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float512Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float512Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -851,6 +851,19 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int512Vector toBitsVector() {\n+            return (Int512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int512Vector toBitsVector0() {\n+            return ((Int512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -861,3 +874,11 @@\n-        public Float512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float512Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public final Float512Mask laneIsValid() {\n+            return (Float512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float512Shuffle concreteShuffle = (Float512Shuffle) shuffle;\n+            return (Float512Shuffle) toBitsVector().rearrange(concreteShuffle.cast(IntVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n@@ -868,8 +889,39 @@\n-        public Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float512Shuffle s = (Float512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -877,1 +929,1 @@\n-            return new Float512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":97,"deletions":45,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Float64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Float64Shuffle shuffleFromArray(int[] indexes, int i) { return new Float64Shuffle(indexes, i); }\n+    Float64Shuffle shuffleFromArray(int[] indices, int i) { return new Float64Shuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n+    public final Float64Shuffle toShuffle() {\n+        return (Float64Shuffle) toShuffle(vspecies(), false);\n@@ -783,1 +781,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -785,2 +783,4 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -789,2 +789,2 @@\n-        public Float64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -793,2 +793,2 @@\n-        public Float64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -797,2 +797,2 @@\n-        public Float64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -802,0 +802,1 @@\n+        @ForceInline\n@@ -809,2 +810,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -817,2 +818,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float64Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (Float64Vector) toBitsVector().castShape(vspecies(), 0);\n@@ -823,6 +823,19 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int64Vector toBitsVector() {\n+            return (Int64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int64Vector toBitsVector0() {\n+            return ((Int64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -833,3 +846,11 @@\n-        public Float64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Float64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float64Shuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public final Float64Mask laneIsValid() {\n+            return (Float64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n+            Float64Shuffle concreteShuffle = (Float64Shuffle) shuffle;\n+            return (Float64Shuffle) toBitsVector().rearrange(concreteShuffle.cast(IntVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n@@ -840,8 +861,39 @@\n-        public Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            Float64Shuffle s = (Float64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Float64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Float64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -849,1 +901,1 @@\n-            return new Float64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":97,"deletions":45,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (FloatMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n+    FloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new FloatMaxShuffle(indices, i); }\n@@ -347,0 +338,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n@@ -348,2 +346,2 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n+    public final FloatMaxShuffle toShuffle() {\n+        return (FloatMaxShuffle) toShuffle(vspecies(), false);\n@@ -780,1 +778,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -782,2 +780,4 @@\n-        FloatMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -786,2 +786,2 @@\n-        public FloatMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -790,2 +790,2 @@\n-        public FloatMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        FloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -794,2 +794,2 @@\n-        public FloatMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -799,0 +799,1 @@\n+        @ForceInline\n@@ -806,2 +807,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -814,2 +815,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+            return (FloatMaxVector) toBitsVector().castShape(vspecies(), 0);\n@@ -820,6 +820,19 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        IntMaxVector toBitsVector() {\n+            return (IntMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        IntMaxVector toBitsVector0() {\n+            return ((IntMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -830,3 +843,11 @@\n-        public FloatMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxShuffle)(((AbstractShuffle<Float>)(s)).wrapIndexesTemplate())));\n+        public final FloatMaxMask laneIsValid() {\n+            return (FloatMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n+            FloatMaxShuffle concreteShuffle = (FloatMaxShuffle) shuffle;\n+            return (FloatMaxShuffle) toBitsVector().rearrange(concreteShuffle.cast(IntVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n@@ -837,8 +858,39 @@\n-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final FloatMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (IntMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (IntMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (FloatMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -846,1 +898,1 @@\n-            return new FloatMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":97,"deletions":45,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -969,1 +969,1 @@\n-   \/**\n+    \/**\n@@ -2270,2 +2270,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2274,1 +2272,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2276,1 +2274,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2299,2 +2297,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2303,1 +2299,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2305,1 +2301,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2326,2 +2322,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2331,1 +2325,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2333,1 +2327,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2339,1 +2333,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2341,1 +2335,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2347,0 +2341,1 @@\n+    @Override\n@@ -2348,8 +2343,2 @@\n-    private final\n-    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n@@ -2358,1 +2347,0 @@\n-    \/*package-private*\/\n@@ -2360,8 +2348,11 @@\n-    final\n-    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n-        FloatSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), float.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     FloatVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        IntVector idx = convert(VectorOperators.F2I, 0).reinterpretAsInts();\n+        IntVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            IntVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Integer> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3684,0 +3675,1 @@\n+                Class<? extends AbstractShuffle<Float>> shuffleType,\n@@ -3686,1 +3678,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -3972,0 +3964,1 @@\n+                            Float64Vector.Float64Shuffle.class,\n@@ -3979,0 +3972,1 @@\n+                            Float128Vector.Float128Shuffle.class,\n@@ -3986,0 +3980,1 @@\n+                            Float256Vector.Float256Shuffle.class,\n@@ -3993,0 +3988,1 @@\n+                            Float512Vector.Float512Shuffle.class,\n@@ -4000,0 +3996,1 @@\n+                            FloatMaxVector.FloatMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int128Shuffle shuffleFromArray(int[] indexes, int i) { return new Int128Shuffle(indexes, i); }\n+    Int128Shuffle shuffleFromArray(int[] indices, int i) { return new Int128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n+    public final Int128Shuffle toShuffle() {\n+        return (Int128Shuffle) toShuffle(vspecies(), false);\n@@ -800,2 +798,4 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -804,2 +804,2 @@\n-        public Int128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -808,2 +808,2 @@\n-        public Int128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -812,2 +812,2 @@\n-        public Int128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -817,0 +817,1 @@\n+        @ForceInline\n@@ -824,2 +825,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -832,2 +833,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int128Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -838,6 +838,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int128Vector toBitsVector() {\n+            return (Int128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int128Vector toBitsVector0() {\n+            return ((Int128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -848,3 +849,2 @@\n-        public Int128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int128Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -853,0 +853,1 @@\n+        @Override\n@@ -854,0 +855,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -855,8 +860,55 @@\n-        public Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int128Shuffle s = (Int128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int128Mask laneIsValid() {\n+            return (Int128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int128Shuffle concreteShuffle = (Int128Shuffle) shuffle;\n+            return (Int128Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -864,1 +916,1 @@\n-            return new Int128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":96,"deletions":44,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int256Shuffle shuffleFromArray(int[] indexes, int i) { return new Int256Shuffle(indexes, i); }\n+    Int256Shuffle shuffleFromArray(int[] indices, int i) { return new Int256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n+    public final Int256Shuffle toShuffle() {\n+        return (Int256Shuffle) toShuffle(vspecies(), false);\n@@ -808,2 +806,4 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -812,2 +812,2 @@\n-        public Int256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -816,2 +816,2 @@\n-        public Int256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -820,2 +820,2 @@\n-        public Int256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -825,0 +825,1 @@\n+        @ForceInline\n@@ -832,2 +833,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -840,2 +841,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int256Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -846,6 +846,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int256Vector toBitsVector() {\n+            return (Int256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int256Vector toBitsVector0() {\n+            return ((Int256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -856,3 +857,2 @@\n-        public Int256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int256Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -861,0 +861,1 @@\n+        @Override\n@@ -862,0 +863,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -863,8 +868,55 @@\n-        public Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int256Shuffle s = (Int256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int256Mask laneIsValid() {\n+            return (Int256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int256Shuffle concreteShuffle = (Int256Shuffle) shuffle;\n+            return (Int256Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -872,1 +924,1 @@\n-            return new Int256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":96,"deletions":44,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int512Shuffle shuffleFromArray(int[] indexes, int i) { return new Int512Shuffle(indexes, i); }\n+    Int512Shuffle shuffleFromArray(int[] indices, int i) { return new Int512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n+    public final Int512Shuffle toShuffle() {\n+        return (Int512Shuffle) toShuffle(vspecies(), false);\n@@ -824,2 +822,4 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -828,2 +828,2 @@\n-        public Int512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -832,2 +832,2 @@\n-        public Int512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -836,2 +836,2 @@\n-        public Int512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -841,0 +841,1 @@\n+        @ForceInline\n@@ -848,2 +849,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -856,2 +857,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int512Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -862,6 +862,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int512Vector toBitsVector() {\n+            return (Int512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int512Vector toBitsVector0() {\n+            return ((Int512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -872,3 +873,2 @@\n-        public Int512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int512Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -877,0 +877,1 @@\n+        @Override\n@@ -878,0 +879,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -879,8 +884,55 @@\n-        public Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int512Shuffle s = (Int512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int512Mask laneIsValid() {\n+            return (Int512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int512Shuffle concreteShuffle = (Int512Shuffle) shuffle;\n+            return (Int512Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -888,1 +940,1 @@\n-            return new Int512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":96,"deletions":44,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Int64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Int64Shuffle shuffleFromArray(int[] indexes, int i) { return new Int64Shuffle(indexes, i); }\n+    Int64Shuffle shuffleFromArray(int[] indices, int i) { return new Int64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n+    public final Int64Shuffle toShuffle() {\n+        return (Int64Shuffle) toShuffle(vspecies(), false);\n@@ -796,2 +794,4 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -800,2 +800,2 @@\n-        public Int64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -804,2 +804,2 @@\n-        public Int64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -808,2 +808,2 @@\n-        public Int64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -813,0 +813,1 @@\n+        @ForceInline\n@@ -820,2 +821,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -828,2 +829,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int64Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -834,6 +834,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Int64Vector toBitsVector() {\n+            return (Int64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Int64Vector toBitsVector0() {\n+            return ((Int64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -844,3 +845,2 @@\n-        public Int64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Int64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int64Shuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -849,0 +849,1 @@\n+        @Override\n@@ -850,0 +851,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -851,8 +856,55 @@\n-        public Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            Int64Shuffle s = (Int64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Int64Mask laneIsValid() {\n+            return (Int64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            Int64Shuffle concreteShuffle = (Int64Shuffle) shuffle;\n+            return (Int64Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Int64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Int64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Int64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Int64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -860,1 +912,1 @@\n-            return new Int64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":96,"deletions":44,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (IntMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -157,5 +152,1 @@\n-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n+    IntMaxShuffle shuffleFromArray(int[] indices, int i) { return new IntMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n+    public final IntMaxShuffle toShuffle() {\n+        return (IntMaxShuffle) toShuffle(vspecies(), false);\n@@ -805,2 +803,4 @@\n-        IntMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -809,2 +809,2 @@\n-        public IntMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -813,2 +813,2 @@\n-        public IntMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        IntMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -817,2 +817,2 @@\n-        public IntMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -822,0 +822,1 @@\n+        @ForceInline\n@@ -829,2 +830,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -837,2 +838,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -843,6 +843,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        IntMaxVector toBitsVector() {\n+            return (IntMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        IntMaxVector toBitsVector0() {\n+            return ((IntMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -853,3 +854,2 @@\n-        public IntMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxShuffle)(((AbstractShuffle<Integer>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -858,0 +858,1 @@\n+        @Override\n@@ -859,0 +860,4 @@\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n+        }\n+\n@@ -860,8 +865,55 @@\n-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final IntMaxMask laneIsValid() {\n+            return (IntMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            IntMaxShuffle concreteShuffle = (IntMaxShuffle) shuffle;\n+            return (IntMaxShuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final IntMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (IntMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (IntMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (IntMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -869,1 +921,1 @@\n-            return new IntMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":96,"deletions":44,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1102,1 +1102,1 @@\n-   \/**\n+    \/**\n@@ -2413,2 +2413,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2417,1 +2415,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2419,1 +2417,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2442,2 +2440,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2446,1 +2442,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2448,1 +2444,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2469,2 +2465,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2474,1 +2468,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2476,1 +2470,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2482,1 +2476,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2484,1 +2478,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2490,0 +2484,1 @@\n+    @Override\n@@ -2491,2 +2486,2 @@\n-    private final\n-    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        assert(dsp.length() == vspecies().length());\n@@ -2501,1 +2496,0 @@\n-    \/*package-private*\/\n@@ -2503,8 +2497,11 @@\n-    final\n-    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n-        IntSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), int.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     IntVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        IntVector idx = this;\n+        IntVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            IntVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Integer> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3852,0 +3849,1 @@\n+                Class<? extends AbstractShuffle<Integer>> shuffleType,\n@@ -3854,1 +3852,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4140,0 +4138,1 @@\n+                            Int64Vector.Int64Shuffle.class,\n@@ -4147,0 +4146,1 @@\n+                            Int128Vector.Int128Shuffle.class,\n@@ -4154,0 +4154,1 @@\n+                            Int256Vector.Int256Shuffle.class,\n@@ -4161,0 +4162,1 @@\n+                            Int512Vector.Int512Shuffle.class,\n@@ -4168,0 +4170,1 @@\n+                            IntMaxVector.IntMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long128Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long128Shuffle shuffleFromArray(int[] indexes, int i) { return new Long128Shuffle(indexes, i); }\n+    Long128Shuffle shuffleFromArray(int[] indices, int i) { return new Long128Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n+    public final Long128Shuffle toShuffle() {\n+        return (Long128Shuffle) toShuffle(vspecies(), false);\n@@ -786,2 +784,4 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -790,2 +790,2 @@\n-        public Long128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -794,2 +794,2 @@\n-        public Long128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -798,2 +798,2 @@\n-        public Long128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -803,0 +803,1 @@\n+        @ForceInline\n@@ -810,2 +811,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -818,2 +819,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long128Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -824,6 +824,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long128Vector toBitsVector() {\n+            return (Long128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long128Vector toBitsVector0() {\n+            return ((Long128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -834,3 +841,41 @@\n-        public Long128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long128Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long128Mask laneIsValid() {\n+            return (Long128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long128Shuffle concreteShuffle = (Long128Shuffle) shuffle;\n+            return (Long128Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n@@ -841,8 +886,39 @@\n-        public Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long128Shuffle s = (Long128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -850,1 +926,1 @@\n-            return new Long128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long256Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long256Shuffle shuffleFromArray(int[] indexes, int i) { return new Long256Shuffle(indexes, i); }\n+    Long256Shuffle shuffleFromArray(int[] indices, int i) { return new Long256Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n+    public final Long256Shuffle toShuffle() {\n+        return (Long256Shuffle) toShuffle(vspecies(), false);\n@@ -790,2 +788,4 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -794,2 +794,2 @@\n-        public Long256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -798,2 +798,2 @@\n-        public Long256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -802,2 +802,2 @@\n-        public Long256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -807,0 +807,1 @@\n+        @ForceInline\n@@ -814,2 +815,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -822,2 +823,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long256Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -828,6 +828,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long256Vector toBitsVector() {\n+            return (Long256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long256Vector toBitsVector0() {\n+            return ((Long256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -838,3 +845,41 @@\n-        public Long256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long256Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long256Mask laneIsValid() {\n+            return (Long256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long256Shuffle concreteShuffle = (Long256Shuffle) shuffle;\n+            return (Long256Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n@@ -845,8 +890,39 @@\n-        public Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long256Shuffle s = (Long256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -854,1 +930,1 @@\n-            return new Long256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long512Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long512Shuffle shuffleFromArray(int[] indexes, int i) { return new Long512Shuffle(indexes, i); }\n+    Long512Shuffle shuffleFromArray(int[] indices, int i) { return new Long512Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n+    public final Long512Shuffle toShuffle() {\n+        return (Long512Shuffle) toShuffle(vspecies(), false);\n@@ -798,2 +796,4 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -802,2 +802,2 @@\n-        public Long512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -806,2 +806,2 @@\n-        public Long512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -810,2 +810,2 @@\n-        public Long512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -815,0 +815,1 @@\n+        @ForceInline\n@@ -822,2 +823,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -830,2 +831,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long512Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -836,6 +836,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long512Vector toBitsVector() {\n+            return (Long512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long512Vector toBitsVector0() {\n+            return ((Long512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -846,3 +853,41 @@\n-        public Long512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long512Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long512Mask laneIsValid() {\n+            return (Long512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long512Shuffle concreteShuffle = (Long512Shuffle) shuffle;\n+            return (Long512Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n@@ -853,8 +898,39 @@\n-        public Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long512Shuffle s = (Long512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -862,1 +938,1 @@\n-            return new Long512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Long64Shuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Long64Shuffle shuffleFromArray(int[] indexes, int i) { return new Long64Shuffle(indexes, i); }\n+    Long64Shuffle shuffleFromArray(int[] indices, int i) { return new Long64Shuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n+    public final Long64Shuffle toShuffle() {\n+        return (Long64Shuffle) toShuffle(vspecies(), false);\n@@ -784,2 +782,4 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -788,2 +788,2 @@\n-        public Long64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -792,2 +792,2 @@\n-        public Long64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -796,2 +796,2 @@\n-        public Long64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -801,0 +801,1 @@\n+        @ForceInline\n@@ -808,2 +809,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -816,2 +817,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long64Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -822,6 +822,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Long64Vector toBitsVector() {\n+            return (Long64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Long64Vector toBitsVector0() {\n+            return ((Long64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -832,3 +839,41 @@\n-        public Long64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Long64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long64Shuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Long64Mask laneIsValid() {\n+            return (Long64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n+            Long64Shuffle concreteShuffle = (Long64Shuffle) shuffle;\n+            return (Long64Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n@@ -839,8 +884,39 @@\n-        public Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            Long64Shuffle s = (Long64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final Long64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Long64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Long64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Long64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -848,1 +924,1 @@\n-            return new Long64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Override\n@@ -141,7 +142,1 @@\n-      if (wrap) {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (LongMaxShuffle) iotaShuffleTemplate(start, step, wrap);\n@@ -152,5 +147,1 @@\n-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n+    LongMaxShuffle shuffleFromArray(int[] indices, int i) { return new LongMaxShuffle(indices, i); }\n@@ -355,0 +346,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -356,2 +354,2 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n+    public final LongMaxShuffle toShuffle() {\n+        return (LongMaxShuffle) toShuffle(vspecies(), false);\n@@ -784,2 +782,4 @@\n-        LongMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -788,2 +788,2 @@\n-        public LongMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -792,2 +792,2 @@\n-        public LongMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        LongMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -796,2 +796,2 @@\n-        public LongMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -801,0 +801,1 @@\n+        @ForceInline\n@@ -808,2 +809,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -816,2 +817,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -822,6 +822,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        LongMaxVector toBitsVector() {\n+            return (LongMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        LongMaxVector toBitsVector0() {\n+            return ((LongMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -832,3 +839,41 @@\n-        public LongMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxShuffle)(((AbstractShuffle<Long>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final LongMaxMask laneIsValid() {\n+            return (LongMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n+            LongMaxShuffle concreteShuffle = (LongMaxShuffle) shuffle;\n+            return (LongMaxShuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n@@ -839,8 +884,39 @@\n-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n-            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final LongMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (LongMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (LongMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (LongMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -848,1 +924,1 @@\n-            return new LongMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":120,"deletions":44,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-   \/**\n+    \/**\n@@ -2279,2 +2279,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2283,1 +2281,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2285,1 +2283,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2308,2 +2306,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2312,1 +2308,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2314,1 +2310,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2335,2 +2331,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2340,1 +2334,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2342,1 +2336,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2348,1 +2342,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2350,1 +2344,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2356,0 +2350,1 @@\n+    @Override\n@@ -2357,2 +2352,2 @@\n-    private final\n-    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        assert(dsp.length() == vspecies().length());\n@@ -2367,1 +2362,0 @@\n-    \/*package-private*\/\n@@ -2369,8 +2363,11 @@\n-    final\n-    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n-        LongSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), long.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     LongVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        LongVector idx = this;\n+        LongVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            LongVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Long> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -3787,0 +3784,1 @@\n+                Class<? extends AbstractShuffle<Long>> shuffleType,\n@@ -3789,1 +3787,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4066,0 +4064,1 @@\n+                            Long64Vector.Long64Shuffle.class,\n@@ -4073,0 +4072,1 @@\n+                            Long128Vector.Long128Shuffle.class,\n@@ -4080,0 +4080,1 @@\n+                            Long256Vector.Long256Shuffle.class,\n@@ -4087,0 +4088,1 @@\n+                            Long512Vector.Long512Shuffle.class,\n@@ -4094,0 +4096,1 @@\n+                            LongMaxVector.LongMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short128Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short128Shuffle shuffleFromArray(int[] indexes, int i) { return new Short128Shuffle(indexes, i); }\n+    Short128Shuffle shuffleFromArray(int[] indices, int i) { return new Short128Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n+    public final Short128Shuffle toShuffle() {\n+        return (Short128Shuffle) toShuffle(vspecies(), false);\n@@ -808,2 +806,4 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -812,2 +812,2 @@\n-        public Short128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -816,2 +816,2 @@\n-        public Short128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -820,2 +820,2 @@\n-        public Short128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -825,0 +825,1 @@\n+        @ForceInline\n@@ -832,2 +833,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -840,2 +841,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short128Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -846,6 +846,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short128Vector toBitsVector() {\n+            return (Short128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short128Vector toBitsVector0() {\n+            return ((Short128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -856,3 +857,2 @@\n-        public Short128Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short128Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -861,0 +861,1 @@\n+        @Override\n@@ -862,0 +863,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -863,8 +875,55 @@\n-        public Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short128Shuffle s = (Short128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short128Mask laneIsValid() {\n+            return (Short128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short128Shuffle concreteShuffle = (Short128Shuffle) shuffle;\n+            return (Short128Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short128Shuffle wrapIndexes() {\n+            Short128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -872,1 +931,1 @@\n-            return new Short128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":103,"deletions":44,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short256Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short256Shuffle shuffleFromArray(int[] indexes, int i) { return new Short256Shuffle(indexes, i); }\n+    Short256Shuffle shuffleFromArray(int[] indices, int i) { return new Short256Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n+    public final Short256Shuffle toShuffle() {\n+        return (Short256Shuffle) toShuffle(vspecies(), false);\n@@ -824,2 +822,4 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -828,2 +828,2 @@\n-        public Short256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -832,2 +832,2 @@\n-        public Short256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -836,2 +836,2 @@\n-        public Short256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -841,0 +841,1 @@\n+        @ForceInline\n@@ -848,2 +849,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -856,2 +857,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short256Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -862,6 +862,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short256Vector toBitsVector() {\n+            return (Short256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short256Vector toBitsVector0() {\n+            return ((Short256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -872,3 +873,2 @@\n-        public Short256Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short256Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -877,0 +877,1 @@\n+        @Override\n@@ -878,0 +879,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -879,8 +891,55 @@\n-        public Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short256Shuffle s = (Short256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short256Mask laneIsValid() {\n+            return (Short256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short256Shuffle concreteShuffle = (Short256Shuffle) shuffle;\n+            return (Short256Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short256Shuffle wrapIndexes() {\n+            Short256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -888,1 +947,1 @@\n-            return new Short256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":103,"deletions":44,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short512Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short512Shuffle shuffleFromArray(int[] indexes, int i) { return new Short512Shuffle(indexes, i); }\n+    Short512Shuffle shuffleFromArray(int[] indices, int i) { return new Short512Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n+    public final Short512Shuffle toShuffle() {\n+        return (Short512Shuffle) toShuffle(vspecies(), false);\n@@ -856,2 +854,4 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -860,2 +860,2 @@\n-        public Short512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -864,2 +864,2 @@\n-        public Short512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -868,2 +868,2 @@\n-        public Short512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -873,0 +873,1 @@\n+        @ForceInline\n@@ -880,2 +881,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -888,2 +889,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short512Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -894,6 +894,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short512Vector toBitsVector() {\n+            return (Short512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short512Vector toBitsVector0() {\n+            return ((Short512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -904,3 +905,2 @@\n-        public Short512Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short512Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -909,0 +909,1 @@\n+        @Override\n@@ -910,0 +911,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -911,8 +923,55 @@\n-        public Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short512Shuffle s = (Short512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short512Mask laneIsValid() {\n+            return (Short512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short512Shuffle concreteShuffle = (Short512Shuffle) shuffle;\n+            return (Short512Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short512Shuffle wrapIndexes() {\n+            Short512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -920,1 +979,1 @@\n-            return new Short512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":103,"deletions":44,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (Short64Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    Short64Shuffle shuffleFromArray(int[] indexes, int i) { return new Short64Shuffle(indexes, i); }\n+    Short64Shuffle shuffleFromArray(int[] indices, int i) { return new Short64Shuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n+    public final Short64Shuffle toShuffle() {\n+        return (Short64Shuffle) toShuffle(vspecies(), false);\n@@ -800,2 +798,4 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -804,2 +804,2 @@\n-        public Short64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -808,2 +808,2 @@\n-        public Short64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -812,2 +812,2 @@\n-        public Short64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -817,0 +817,1 @@\n+        @ForceInline\n@@ -824,2 +825,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -832,2 +833,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short64Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -838,6 +838,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        Short64Vector toBitsVector() {\n+            return (Short64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short64Vector toBitsVector0() {\n+            return ((Short64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -848,3 +849,2 @@\n-        public Short64Shuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, Short64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short64Shuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -853,0 +853,1 @@\n+        @Override\n@@ -854,0 +855,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -855,8 +867,55 @@\n-        public Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            Short64Shuffle s = (Short64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final Short64Mask laneIsValid() {\n+            return (Short64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n+            Short64Shuffle concreteShuffle = (Short64Shuffle) shuffle;\n+            return (Short64Shuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Short64Shuffle wrapIndexes() {\n+            Short64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Short64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -864,1 +923,1 @@\n-            return new Short64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":103,"deletions":44,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    @Override\n@@ -146,7 +147,1 @@\n-      if (wrap) {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+        return (ShortMaxShuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n@@ -157,5 +152,1 @@\n-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n+    ShortMaxShuffle shuffleFromArray(int[] indices, int i) { return new ShortMaxShuffle(indices, i); }\n@@ -360,0 +351,7 @@\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        return bitsToShuffleTemplate(dsp);\n+    }\n+\n+    @Override\n@@ -361,2 +359,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n+    public final ShortMaxShuffle toShuffle() {\n+        return (ShortMaxShuffle) toShuffle(vspecies(), false);\n@@ -794,2 +792,4 @@\n-        ShortMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -798,2 +798,2 @@\n-        public ShortMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -802,2 +802,2 @@\n-        public ShortMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ShortMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -806,2 +806,2 @@\n-        public ShortMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -811,0 +811,1 @@\n+        @ForceInline\n@@ -818,2 +819,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -826,2 +827,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -832,6 +832,7 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        ShortMaxVector toBitsVector() {\n+            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ShortMaxVector toBitsVector0() {\n+            return ((ShortMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n@@ -842,3 +843,2 @@\n-        public ShortMaxShuffle wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxShuffle)(((AbstractShuffle<Short>)(s)).wrapIndexesTemplate())));\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -847,0 +847,1 @@\n+        @Override\n@@ -848,0 +849,11 @@\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n@@ -849,8 +861,55 @@\n-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        @ForceInline\n+        public final ShortMaxMask laneIsValid() {\n+            return (ShortMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n+            ShortMaxShuffle concreteShuffle = (ShortMaxShuffle) shuffle;\n+            return (ShortMaxShuffle) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final ShortMaxShuffle wrapIndexes() {\n+            ShortMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ShortMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ShortMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (ShortMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -858,1 +917,1 @@\n-            return new ShortMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":103,"deletions":44,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-   \/**\n+    \/**\n@@ -2429,2 +2429,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2433,1 +2431,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2435,1 +2433,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2458,2 +2456,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2462,1 +2458,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2464,1 +2460,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2485,2 +2481,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2490,1 +2484,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2492,1 +2486,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2498,1 +2492,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2500,1 +2494,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2506,0 +2500,1 @@\n+    @Override\n@@ -2507,2 +2502,2 @@\n-    private final\n-    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        assert(dsp.length() == vspecies().length());\n@@ -2517,1 +2512,0 @@\n-    \/*package-private*\/\n@@ -2519,8 +2513,11 @@\n-    final\n-    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n-        ShortSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), short.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     ShortVector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ShortVector idx = this;\n+        ShortVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ShortVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Short> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -4213,0 +4210,1 @@\n+                Class<? extends AbstractShuffle<Short>> shuffleType,\n@@ -4215,1 +4213,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -4501,0 +4499,1 @@\n+                            Short64Vector.Short64Shuffle.class,\n@@ -4508,0 +4507,1 @@\n+                            Short128Vector.Short128Shuffle.class,\n@@ -4515,0 +4515,1 @@\n+                            Short256Vector.Short256Shuffle.class,\n@@ -4522,0 +4523,1 @@\n+                            Short512Vector.Short512Shuffle.class,\n@@ -4529,0 +4531,1 @@\n+                            ShortMaxVector.ShortMaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,2 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n+    VectorShuffle(Object indices) {\n+        super(indices);\n@@ -559,1 +559,1 @@\n-    public int laneSource(int i) { return toArray()[i]; }\n+    public abstract int laneSource(int i);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -345,0 +347,1 @@\n+    @ForceInline\n@@ -370,0 +373,1 @@\n+    @ForceInline\n@@ -413,0 +417,1 @@\n+    @ForceInline\n@@ -435,0 +440,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-   \/**\n+    \/**\n@@ -2805,2 +2805,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2809,1 +2807,1 @@\n-            this, ws, null,\n+            this, shuffle, null,\n@@ -2811,1 +2809,1 @@\n-                int ei = s_.laneSource(i);\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2834,2 +2832,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2838,1 +2834,1 @@\n-                   this, ws, m,\n+                   this, shuffle, m,\n@@ -2840,1 +2836,1 @@\n-                        int ei = s_.laneSource(i);\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2861,2 +2857,0 @@\n-        @SuppressWarnings(\"unchecked\")\n-        S ws = (S) shuffle.wrapIndexes();\n@@ -2866,1 +2860,1 @@\n-                this, ws, null,\n+                this, shuffle, null,\n@@ -2868,1 +2862,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n@@ -2874,1 +2868,1 @@\n-                v, ws, null,\n+                v, shuffle, null,\n@@ -2876,1 +2870,1 @@\n-                    int ei = s_.laneSource(i);\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n@@ -2882,0 +2876,1 @@\n+    @Override\n@@ -2883,2 +2878,5 @@\n-    private final\n-    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+#if[FP]\n+        throw new AssertionError();\n+#else[FP]\n+        assert(dsp.length() == vspecies().length());\n@@ -2891,0 +2889,1 @@\n+#end[FP]\n@@ -2893,1 +2892,0 @@\n-    \/*package-private*\/\n@@ -2895,8 +2893,19 @@\n-    final\n-    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n-        $Type$Species vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), $type$.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     $Type$Vector::toShuffle0);\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+#if[float]\n+        IntVector idx = convert(VectorOperators.F2I, 0).reinterpretAsInts();\n+#end[float]\n+#if[double]\n+        LongVector idx = convert(VectorOperators.D2L, 0).reinterpretAsLongs();\n+#end[double]\n+#if[!FP]\n+        $Type$Vector idx = this;\n+#end[!FP]\n+        $Bitstype$Vector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            $Bitstype$Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<$Boxbitstype$> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n@@ -5450,0 +5459,1 @@\n+                Class<? extends AbstractShuffle<$Boxtype$>> shuffleType,\n@@ -5452,1 +5462,1 @@\n-                  vectorType, maskType,\n+                  vectorType, maskType, shuffleType,\n@@ -5745,0 +5755,1 @@\n+                            $Type$64Vector.$Type$64Shuffle.class,\n@@ -5752,0 +5763,1 @@\n+                            $Type$128Vector.$Type$128Shuffle.class,\n@@ -5759,0 +5771,1 @@\n+                            $Type$256Vector.$Type$256Shuffle.class,\n@@ -5766,0 +5779,1 @@\n+                            $Type$512Vector.$Type$512Shuffle.class,\n@@ -5773,0 +5787,1 @@\n+                            $Type$MaxVector.$Type$MaxShuffle.class,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+    @Override\n@@ -148,7 +149,9 @@\n-      if (wrap) {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n+#if[byte]\n+        return ($shuffletype$) iotaShuffleTemplate((byte) start, (byte) step, wrap);\n+#end[byte]\n+#if[short]\n+        return ($shuffletype$) iotaShuffleTemplate((short) start, (short) step, wrap);\n+#end[short]\n+#if[!byteOrShort]\n+        return ($shuffletype$) iotaShuffleTemplate(start, step, wrap);\n+#end[!byteOrShort]\n@@ -159,5 +162,1 @@\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    $shuffletype$ shuffleFromArray(int[] indexes, int i) { return new $shuffletype$(indexes, i); }\n+    $shuffletype$ shuffleFromArray(int[] indices, int i) { return new $shuffletype$(indices, i); }\n@@ -364,0 +363,1 @@\n+    @Override\n@@ -365,2 +365,12 @@\n-    public VectorShuffle<$Boxtype$> toShuffle() {\n-        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+#if[FP]\n+        throw new AssertionError();\n+#else[FP]\n+        return bitsToShuffleTemplate(dsp);\n+#end[FP]\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final $shuffletype$ toShuffle() {\n+        return ($shuffletype$) toShuffle(vspecies(), false);\n@@ -1080,1 +1090,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n@@ -1082,2 +1092,4 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$($bitstype$[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -1086,2 +1098,2 @@\n-        public $shuffletype$(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -1090,2 +1102,2 @@\n-        public $shuffletype$(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        $shuffletype$(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -1094,2 +1106,2 @@\n-        public $shuffletype$(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        $bitstype$[] indices() {\n+            return ($bitstype$[])getPayload();\n@@ -1099,0 +1111,1 @@\n+        @ForceInline\n@@ -1106,2 +1119,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < $Boxbitstype$.MAX_VALUE);\n+            assert($Boxbitstype$.MIN_VALUE <= -VLENGTH);\n@@ -1111,0 +1124,7 @@\n+#if[FP]\n+        @Override\n+        @ForceInline\n+        public $vectortype$ toVector() {\n+            return ($vectortype$) toBitsVector().castShape(vspecies(), 0);\n+        }\n+#else[FP]\n@@ -1114,2 +1134,1 @@\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, $shuffletype$.class, this, VLENGTH,\n-                                                    (s) -> (($vectortype$)(((AbstractShuffle<$Boxtype$>)(s)).toVectorTemplate())));\n+            return toBitsVector();\n@@ -1117,0 +1136,1 @@\n+#end[FP]\n@@ -1120,6 +1140,13 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        $bitsvectortype$ toBitsVector() {\n+            return ($bitsvectortype$) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        $bitsvectortype$ toBitsVector0() {\n+            return (($bitsvectortype$) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n@@ -1130,3 +1157,77 @@\n-        public $shuffletype$ wrapIndexes() {\n-            return VectorSupport.wrapShuffleIndexes(ETYPE, $shuffletype$.class, this, VLENGTH,\n-                                                    (s) -> (($shuffletype$)(((AbstractShuffle<$Boxtype$>)(s)).wrapIndexesTemplate())));\n+        public void intoArray(int[] a, int offset) {\n+#if[byte]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+#end[byte]\n+#if[short]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+#end[short]\n+#if[intOrFloat]\n+            toBitsVector().intoArray(a, offset);\n+#end[intOrFloat]\n+#if[longOrDouble]\n+            switch (length()) {\n+                case 1 -> a[offset] = laneSource(0);\n+                case 2 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_64, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 4 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_128, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 8 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_256, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                case 16 -> toBitsVector()\n+                        .convertShape(VectorOperators.L2I, IntVector.SPECIES_512, 0)\n+                        .reinterpretAsInts()\n+                        .intoArray(a, offset);\n+                default -> {\n+                    VectorIntrinsics.checkFromIndexSize(offset, length(), a.length);\n+                    for (int i = 0; i < length(); i++) {\n+                        a[offset + i] = laneSource(i);\n+                    }\n+                }\n+            }\n+#end[longOrDouble]\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final $masktype$ laneIsValid() {\n+            return ($masktype$) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n+            $shuffletype$ concreteShuffle = ($shuffletype$) shuffle;\n+#if[FP]\n+            return ($shuffletype$) toBitsVector().rearrange(concreteShuffle.cast($Bitstype$Vector.SPECIES_$BITS$))\n+                    .toShuffle(vspecies(), false);\n+#else[FP]\n+            return ($shuffletype$) toBitsVector().rearrange(concreteShuffle)\n+                    .toShuffle(vspecies(), false);\n+#end[FP]\n@@ -1137,8 +1238,39 @@\n-        public $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n-            $shuffletype$ s = ($shuffletype$) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+        public final $shuffletype$ wrapIndexes() {\n+            $bitsvectortype$ v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = ($bitsvectortype$) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = ($bitsvectortype$) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return ($shuffletype$) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static $bitstype$[] prepare(int[] indices, int offset) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static $bitstype$[] prepare(IntUnaryOperator f) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange($bitstype$[] indices) {\n+            int length = indices.length;\n+            for ($bitstype$ si : indices) {\n+                if (si >= ($bitstype$)length || si < ($bitstype$)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n@@ -1146,1 +1278,1 @@\n-            return new $shuffletype$(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":177,"deletions":45,"binary":false,"changes":222,"status":"modified"}]}