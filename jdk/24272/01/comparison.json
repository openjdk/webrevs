{"files":[{"patch":"@@ -112,1 +112,4 @@\n-    if (!info.is_excluded()) {\n+    \/\/ Skip \"AOT tooling classes\" in this block. They will be included in the AOT cache only if\n+    \/\/ - One of their subtypes is included\n+    \/\/ - One of their instances is found by HeapShared.\n+    if (!info.is_excluded() && !info.is_aot_tooling_class()) {\n@@ -152,1 +155,0 @@\n-      assert(k->is_hidden(), \"must be\");\n@@ -155,1 +157,2 @@\n-        log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+        log_info(cds)(\"Skipping %s: %s class\", k->name()->as_C_string(),\n+                      k->is_hidden() ? \"Hidden\" : \"AOT tooling\");\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotClassFilter.hpp\"\n+\n+AOTClassFilter::FilterMark* AOTClassFilter::_current_mark = nullptr;\n","filename":"src\/hotspot\/share\/cds\/aotClassFilter.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSFILTER_HPP\n+#define SHARE_CDS_AOTCLASSFILTER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+class InstanceKlass;\n+class JavaThread;\n+\n+\/\/ Used by SystemDictionaryShared\/AOTArtifactFinder to filter out classes that\n+\/\/ shouldn't be included into the AOT cache -- for example, classes that are used only\n+\/\/ in the training\/assembly phases for building contents in the AOT cache.\n+\/\/\n+\/\/ The only use case today is in lambdaFormInvokers.cpp.\n+class AOTClassFilter : AllStatic {\n+public:\n+\n+  \/\/ Filters should be defined using RAII pattern\n+  class FilterMark {\n+  public:\n+    FilterMark() {\n+      assert(_current_mark == nullptr, \"sanity\");\n+      _current_mark = this;\n+    }\n+    ~FilterMark() {\n+      assert(_current_mark == this, \"sanity\");\n+      _current_mark = nullptr;\n+    }\n+\n+    virtual bool is_aot_tooling_class(InstanceKlass* ik) = 0;\n+  };\n+\n+  \/\/ Called when ik is being loaded. Return true iff this class is loaded\n+  \/\/ only because it's used by the AOT tooling code.\n+  static bool is_aot_tooling_class(InstanceKlass* ik) {\n+    return (_current_mark == nullptr) ? false : _current_mark->is_aot_tooling_class(ik);\n+  }\n+\n+private:\n+  \/\/ For the time being, we allow at most one filter.\n+  static FilterMark* _current_mark;\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSFILTER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassFilter.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -576,0 +576,18 @@\n+bool CDSConfig::is_dumping_regenerated_lambdaform_invokers() {\n+  if (is_dumping_final_static_archive()) {\n+    \/\/ No need to regenerate -- the lambda form invokers should have been regenerated\n+    \/\/ in the preimage archive (if allowed)\n+    return false;\n+  } else if (is_dumping_dynamic_archive() && is_using_aot_linked_classes()) {\n+    \/\/ The base archive has aot-linked classes that may have AOT-resolved CP references\n+    \/\/ that point to the lambda form invokers in the base archive. Such pointers will\n+    \/\/ be invalid if lambda form invokers are regenerated in the dynamic archive.\n+    return false;\n+  } else if (CDSConfig::is_dumping_method_handles()) {\n+    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n+    return false;\n+  } else {\n+    return is_dumping_archive();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  static bool is_dumping_regenerated_lambdaform_invokers()   NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,3 +42,5 @@\n-  bool                         _excluded;\n-  bool                         _is_early_klass;\n-  bool                         _has_checked_exclusion;\n+  bool _excluded;\n+  bool _is_aot_tooling_class;\n+  bool _is_early_klass;\n+  bool _has_checked_exclusion;\n+\n@@ -143,0 +145,1 @@\n+    _is_aot_tooling_class = false;\n@@ -202,0 +205,8 @@\n+  bool is_aot_tooling_class() {\n+    return _is_aot_tooling_class;\n+  }\n+\n+  void set_is_aot_tooling_class() {\n+    _is_aot_tooling_class = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"cds\/lambdaFormInvokers.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -498,0 +500,10 @@\n+void DynamicArchive::dump_impl(bool jcmd_request, const char* archive_name, TRAPS) {\n+  MetaspaceShared::link_shared_classes(CHECK);\n+  if (!jcmd_request && CDSConfig::is_dumping_regenerated_lambdaform_invokers()) {\n+    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+  }\n+\n+  VM_PopulateDynamicDumpSharedSpace op(archive_name);\n+  VMThread::execute(&op);\n+}\n+\n@@ -510,5 +522,9 @@\n-  MetaspaceShared::link_shared_classes(false\/*not from jcmd*\/, THREAD);\n-  if (!HAS_PENDING_EXCEPTION) {\n-    VM_PopulateDynamicDumpSharedSpace op(archive_name);\n-    VMThread::execute(&op);\n-    return;\n+  dump_impl(\/*jcmd_request=*\/false, archive_name, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    \/\/ One of the prepatory steps failed\n+    oop ex = current->pending_exception();\n+    log_error(cds)(\"Dynamic dump has failed\");\n+    log_error(cds)(\"%s: %s\", ex->klass()->external_name(),\n+                   java_lang_String::as_utf8_string(java_lang_Throwable::message(ex)));\n+    CLEAR_PENDING_EXCEPTION;\n+    CDSConfig::disable_dumping_dynamic_archive();  \/\/ Just for good measure\n@@ -516,8 +532,0 @@\n-\n-  \/\/ One of the prepatory steps failed\n-  oop ex = current->pending_exception();\n-  log_error(cds)(\"Dynamic dump has failed\");\n-  log_error(cds)(\"%s: %s\", ex->klass()->external_name(),\n-                 java_lang_String::as_utf8_string(java_lang_Throwable::message(ex)));\n-  CLEAR_PENDING_EXCEPTION;\n-  CDSConfig::disable_dumping_dynamic_archive();  \/\/ Just for good measure\n@@ -532,4 +540,1 @@\n-  MetaspaceShared::link_shared_classes(true\/*from jcmd*\/, CHECK);\n-  \/\/ copy shared path table to saved.\n-  VM_PopulateDynamicDumpSharedSpace op(archive_name);\n-  VMThread::execute(&op);\n+  dump_impl(\/*jcmd_request=*\/true, archive_name, CHECK);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+  static void dump_impl(bool jcmd_request, const char* archive_name, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassFilter.hpp\"\n@@ -26,1 +27,2 @@\n-#include \"cds\/lambdaFormInvokers.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/lambdaFormInvokers.inline.hpp\"\n@@ -91,5 +93,14 @@\n-void LambdaFormInvokers::regenerate_holder_classes(TRAPS) {\n-  PrintLambdaFormMessage plm;\n-  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n-    log_info(cds)(\"Nothing to regenerate for holder classes\");\n-    return;\n+class LambdaFormInvokersClassFilterMark : public AOTClassFilter::FilterMark {\n+public:\n+  bool is_aot_tooling_class(InstanceKlass* ik) {\n+    if (ik->name()->index_of_at(0, \"$Species_\", 9) > 0) {\n+      \/\/ Classes like java.lang.invoke.BoundMethodHandle$Species_L should be included in AOT cache\n+      return false;\n+    }\n+    if (LambdaFormInvokers::may_be_regenerated_class(ik->name())) {\n+      \/\/ Regenerated holder classes should be included in AOT cache.\n+      return false;\n+    }\n+    \/\/ Treat all other classes loaded during LambdaFormInvokers::regenerate_holder_classes() as\n+    \/\/ \"AOT tooling classes\".\n+    return true;\n@@ -97,0 +108,1 @@\n+};\n@@ -98,3 +110,2 @@\n-  if (CDSConfig::is_dumping_static_archive() && CDSConfig::is_dumping_method_handles()) {\n-    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n-    log_info(cds)(\"Archived MethodHandles may refer to lambda form holder classes. Cannot regenerate.\");\n+void LambdaFormInvokers::regenerate_holder_classes(TRAPS) {\n+  if (!CDSConfig::is_dumping_regenerated_lambdaform_invokers()) {\n@@ -104,6 +115,3 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && CDSConfig::is_dumping_aot_linked_classes() &&\n-      CDSConfig::is_using_aot_linked_classes()) {\n-    \/\/ The base archive may have some pre-resolved CP entries that point to the lambda form holder\n-    \/\/ classes in the base archive. If we generate new versions of these classes, those CP entries\n-    \/\/ will be pointing to invalid classes.\n-    log_info(cds)(\"Base archive already has aot-linked lambda form holder classes. Cannot regenerate.\");\n+  PrintLambdaFormMessage plm;\n+  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n+    log_info(cds)(\"Nothing to regenerate for holder classes\");\n@@ -115,0 +123,3 @@\n+  \/\/ Filter out AOT tooling classes like java.lang.invoke.GenerateJLIClassesHelper, etc.\n+  LambdaFormInvokersClassFilterMark filter_mark;\n+\n@@ -248,1 +259,1 @@\n-    log_debug(cds)(\"Total LF lines stored into static archive: %d\", count);\n+    log_debug(cds)(\"Total LF lines stored into %s: %d\", CDSConfig::type_of_archive_being_written(), count);\n@@ -260,1 +271,1 @@\n-    log_debug(cds)(\"Total LF lines read from static archive: %d\", _static_archive_invokers->length());\n+    log_debug(cds)(\"Total LF lines read from %s: %d\", CDSConfig::type_of_archive_being_loaded(), _static_archive_invokers->length());\n@@ -267,1 +278,7 @@\n-    LambdaFormInvokers::read_static_archive_invokers();\n+    if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+      \/\/ See CDSConfig::is_dumping_regenerated_lambdaform_invokers() -- a dynamic archive can\n+      \/\/ regenerate lambda form invokers only if the base archive does not contain aot-linked classes.\n+      \/\/ If so, we copy the contents of _static_archive_invokers (from the preimage) into\n+      \/\/_lambdaform_lines, which will be written as _static_archive_invokers into final static archive.\n+      LambdaFormInvokers::read_static_archive_invokers();\n+    }\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassFilter.hpp\"\n@@ -393,0 +394,4 @@\n+  if (AOTClassFilter::is_aot_tooling_class(proxy_klass)) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+#include <sys\/stat.h>\n+\n@@ -699,0 +701,10 @@\n+   CollectClassesForLinking() : _mirrors() {\n+     \/\/ ClassLoaderDataGraph::loaded_classes_do_keepalive() requires ClassLoaderDataGraph_lock.\n+     \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+     \/\/ Therefore, we need to first collect all the classes, keeping them alive by\n+     \/\/ holding onto their java_mirrors in global OopHandles. We then link the classes after\n+     \/\/ releasing the lock.\n+     MutexLocker lock(ClassLoaderDataGraph_lock);\n+     ClassLoaderDataGraph::loaded_classes_do_keepalive(this);\n+   }\n+\n@@ -739,10 +751,1 @@\n-bool MetaspaceShared::link_class_for_cds(InstanceKlass* ik, TRAPS) {\n-  \/\/ Link the class to cause the bytecodes to be rewritten and the\n-  \/\/ cpcache to be created. Class verification is done according\n-  \/\/ to -Xverify setting.\n-  bool res = MetaspaceShared::try_link_class(THREAD, ik);\n-  AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK_(false));\n-  return res;\n-}\n-\n-void MetaspaceShared::link_shared_classes(bool jcmd_request, TRAPS) {\n+void MetaspaceShared::link_shared_classes(TRAPS) {\n@@ -752,5 +755,0 @@\n-  if (!jcmd_request && !CDSConfig::is_dumping_final_static_archive()) {\n-    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n-  }\n-\n-\n@@ -758,0 +756,1 @@\n+    ResourceMark rm(THREAD);\n@@ -759,10 +758,0 @@\n-    {\n-      \/\/ ClassLoaderDataGraph::loaded_classes_do_keepalive() requires ClassLoaderDataGraph_lock.\n-      \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n-      \/\/ Therefore, we need to first collect all the classes, keeping them alive by\n-      \/\/ holding onto their java_mirrors in global OopHandles. We then link the classes after\n-      \/\/ releasing the lock.\n-      MutexLocker lock(ClassLoaderDataGraph_lock);\n-      ClassLoaderDataGraph::loaded_classes_do_keepalive(&collect_classes);\n-    }\n-\n@@ -775,1 +764,1 @@\n-        has_linked |= link_class_for_cds(ik, CHECK);\n+        has_linked |= try_link_class(THREAD, ik);\n@@ -786,0 +775,12 @@\n+  \/\/ Resolve constant pool entries -- we don't load any new classes during this stage\n+  {\n+    ResourceMark rm(THREAD);\n+    CollectClassesForLinking collect_classes;\n+    const GrowableArray<OopHandle>* mirrors = collect_classes.mirrors();\n+    for (int i = 0; i < mirrors->length(); i++) {\n+      OopHandle mirror = mirrors->at(i);\n+      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK);\n+    }\n+  }\n+\n@@ -826,2 +827,8 @@\n-      tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n-      vm_exit(0);\n+      struct stat st;\n+      if (os::stat(AOTCache, &st) != 0) {\n+        tty->print_cr(\"AOTCache creation failed: %s\", AOTCache);\n+        vm_exit(0);\n+      } else {\n+        tty->print_cr(\"AOTCache creation is complete: %s \" INT64_FORMAT \" bytes\", AOTCache, (int64_t)(st.st_size));\n+        vm_exit(0);\n+      }\n@@ -929,0 +936,12 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n+      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+      CDSConfig::stop_dumping_full_module_graph();\n+    }\n+    \/\/ Do this before link_shared_classes(), as the following line may load new classes.\n+    HeapShared::init_for_dumping(CHECK);\n+  }\n+#endif\n+\n@@ -944,1 +963,1 @@\n-  link_shared_classes(false\/*not from jcmd*\/, CHECK);\n+  link_shared_classes(CHECK);\n@@ -947,0 +966,4 @@\n+  if (CDSConfig::is_dumping_regenerated_lambdaform_invokers()) {\n+    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+  }\n+\n@@ -949,5 +972,0 @@\n-    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n-      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n-      CDSConfig::stop_dumping_full_module_graph();\n-    }\n-    HeapShared::init_for_dumping(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":52,"deletions":34,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -134,2 +134,1 @@\n-  static void link_shared_classes(bool jcmd_request, TRAPS) NOT_CDS_RETURN;\n-  static bool link_class_for_cds(InstanceKlass* ik, TRAPS) NOT_CDS_RETURN_(false);\n+  static void link_shared_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassFilter.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"cds\/lambdaFormInvokers.inline.hpp\"\n@@ -487,1 +489,4 @@\n-  _dumptime_table->allocate_info(k);\n+  DumpTimeClassInfo* info = _dumptime_table->allocate_info(k);\n+  if (AOTClassFilter::is_aot_tooling_class(k)) {\n+    info->set_is_aot_tooling_class();\n+  }\n@@ -1059,4 +1064,1 @@\n-    if (name == vmSymbols::java_lang_invoke_Invokers_Holder() ||\n-        name == vmSymbols::java_lang_invoke_DirectMethodHandle_Holder() ||\n-        name == vmSymbols::java_lang_invoke_LambdaForm_Holder() ||\n-        name == vmSymbols::java_lang_invoke_DelegatingMethodHandle_Holder()) {\n+    if (LambdaFormInvokers::may_be_regenerated_class(name)) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  static bool is_builtin(InstanceKlass* k) {\n+  static bool is_builtin(const InstanceKlass* k) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}