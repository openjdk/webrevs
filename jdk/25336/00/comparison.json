{"files":[{"patch":"@@ -207,0 +207,15 @@\n+\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return false;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -196,0 +196,14 @@\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return false;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -207,0 +207,14 @@\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return false;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -202,0 +202,14 @@\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return true;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -199,0 +199,14 @@\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return false;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -239,0 +239,14 @@\n+  static bool supports_vectorize_cmove_bool_unconditionally() {\n+    return false;\n+  }\n+\n+  static bool supports_transform_cmove_to_vectorblend(int cmove_opc) {\n+    switch (cmove_opc) {\n+      case Op_CMoveF:\n+      case Op_CMoveD:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2355,2 +2355,11 @@\n-  \/\/ Default case: input size of use equals output size of def.\n-  return type2aelembytes(use_bt) == type2aelembytes(def_bt);\n+  \/\/ Input size of use equals output size of def\n+  if (type2aelembytes(use_bt) == type2aelembytes(def_bt)) {\n+    return true;\n+  }\n+\n+  if (use->is_CMove() && def->is_Bool() &&\n+      VectorNode::is_vectorize_cmove_bool_unconditionally_supported()) {\n+    return true;\n+  }\n+\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+  case Op_CMoveI:\n+    return (bt == T_INT ? Op_VectorBlend : 0);\n+  case Op_CMoveL:\n+    return (bt == T_LONG ? Op_VectorBlend : 0);\n@@ -432,0 +436,3 @@\n+    if (vopc == Op_VectorBlend) {\n+      return VectorBlendNode::implemented(opc);\n+    }\n@@ -514,0 +521,4 @@\n+bool VectorNode::is_vectorize_cmove_bool_unconditionally_supported() {\n+  return Matcher::supports_vectorize_cmove_bool_unconditionally();\n+}\n+\n@@ -2190,0 +2201,8 @@\n+\n+bool VectorBlendNode::implemented(int opc) {\n+  assert(opc == Op_CMoveF || opc == Op_CMoveD ||\n+         opc == Op_CMoveI || opc == Op_CMoveL ||\n+         opc == Op_CMoveN || opc == Op_CMoveP, \"must\");\n+  return Matcher::supports_transform_cmove_to_vectorblend(opc);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  \/\/ Supports to vectorize CMove which uses Bool unconditionally?\n+  \/\/ Otherwise only same type size of CMove and Bool will be supported for this transformation.\n+  static bool is_vectorize_cmove_bool_unconditionally_supported();\n@@ -1739,0 +1742,2 @@\n+\n+  static bool implemented(int opc);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}