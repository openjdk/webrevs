{"files":[{"patch":"@@ -104,0 +104,1 @@\n+    private static final long INITIAL_SLEEP = 1;\n@@ -106,0 +107,3 @@\n+    private static final Object RESERVE_SLOWPATH_LOCK = new Object();\n+    private static int RESERVE_GC_EPOCH = 0; \/\/ Never negative.\n+\n@@ -121,1 +125,2 @@\n-        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        \/\/ Don't completely discard interruptions.  Instead, record them and\n+        \/\/ reapply when we're done here (whether successfully or OOME).\n@@ -124,6 +129,22 @@\n-\n-            \/\/ Retry allocation until success or there are no more\n-            \/\/ references (including Cleaners that might free direct\n-            \/\/ buffer memory) to process and allocation still fails.\n-            boolean refprocActive;\n-            do {\n+            \/\/ Keep trying to reserve until either succeed or there is no\n+            \/\/ further cleaning available from prior GCs. If the latter then\n+            \/\/ GC to hopefully find more cleaning to do.\n+            for (int cleanedEpoch = -1; true; ) {\n+                synchronized (RESERVE_SLOWPATH_LOCK) {\n+                    \/\/ Test if cleaning for prior GCs (from here) is complete.\n+                    \/\/ If so, GC to produce more cleaning work, and increment\n+                    \/\/ the counter to inform other threads that there may be\n+                    \/\/ more cleaning work to do.  This is done under the lock\n+                    \/\/ to close a race.  We could have multiple threads pass\n+                    \/\/ the test \"simultaneously\", resulting in back-to-back\n+                    \/\/ GCs.  For a STW GC the window is small, but for a\n+                    \/\/ concurrent GC it's quite large.\n+                    if (RESERVE_GC_EPOCH == cleanedEpoch) {\n+                        \/\/ Increment with overflow to 0, so the value can\n+                        \/\/ never equal the initial\/reset cleanedEpoch value.\n+                        RESERVE_GC_EPOCH = Integer.max(0, RESERVE_GC_EPOCH + 1);\n+                        System.gc();\n+                        break;\n+                    }\n+                    cleanedEpoch = RESERVE_GC_EPOCH;\n+                }\n@@ -131,1 +152,3 @@\n-                    refprocActive = jlra.waitForReferenceProcessing();\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    }\n@@ -133,1 +156,0 @@\n-                    \/\/ Defer interrupts and keep trying.\n@@ -135,4 +157,1 @@\n-                    refprocActive = true;\n-                }\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n+                    cleanedEpoch = -1; \/\/ Reset when incomplete.\n@@ -140,4 +159,1 @@\n-            } while (refprocActive);\n-\n-            \/\/ trigger VM's Reference processing\n-            System.gc();\n+            }\n@@ -154,9 +170,1 @@\n-            long sleepTime = 1;\n-            int sleeps = 0;\n-            while (true) {\n-                if (tryReserveMemory(size, cap)) {\n-                    return;\n-                }\n-                if (sleeps >= MAX_SLEEPS) {\n-                    break;\n-                }\n+            for (int sleeps = 0; true; ) {\n@@ -164,4 +172,10 @@\n-                    if (!jlra.waitForReferenceProcessing()) {\n-                        Thread.sleep(sleepTime);\n-                        sleepTime <<= 1;\n-                        sleeps++;\n+                    if (tryReserveOrClean(size, cap)) {\n+                        return;\n+                    } else if (sleeps < MAX_SLEEPS) {\n+                        Thread.sleep(INITIAL_SLEEP << sleeps);\n+                        ++sleeps; \/\/ Only increment if sleep completed.\n+                    } else {\n+                        throw new OutOfMemoryError\n+                            (\"Cannot reserve \"\n+                             + size + \" bytes of direct buffer memory (allocated: \"\n+                             + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n@@ -174,6 +188,0 @@\n-            \/\/ no luck\n-            throw new OutOfMemoryError\n-                (\"Cannot reserve \"\n-                 + size + \" bytes of direct buffer memory (allocated: \"\n-                 + RESERVED_MEMORY.get() + \", limit: \" + MAX_MEMORY +\")\");\n-\n@@ -181,0 +189,1 @@\n+            \/\/ Reapply any deferred interruption.\n@@ -182,1 +191,0 @@\n-                \/\/ don't swallow interrupts\n@@ -188,0 +196,21 @@\n+    \/\/ Try to reserve memory, or failing that, try to make progress on\n+    \/\/ cleaning.  Returns true if successfully reserved memory, false if\n+    \/\/ failed and ran out of cleaning work.\n+    private static boolean tryReserveOrClean(long size, long cap)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+        boolean progressing = true;\n+        while (true) {\n+            if (tryReserveMemory(size, cap)) {\n+                return true;\n+            } else if (BufferCleaner.tryCleaning()) {\n+                progressing = true;\n+            } else if (!progressing) {\n+                return false;\n+            } else {\n+                progressing = jlra.waitForReferenceProcessing();\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":66,"deletions":37,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.nio;\n+\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.Objects;\n+import sun.nio.Cleaner;\n+\n+\/**\n+ * BufferCleaner supports PhantomReference-based management of native memory\n+ * referred to by Direct-XXX-Buffers. Unreferenced DBBs may be garbage\n+ * collected, deactivating the associated PRefs and making them available for\n+ * cleanup here.\n+ *\n+ * There is a configured limit to the amount of memory that may be allocated\n+ * by DBBs. When that limit is reached, the allocator may invoke the garbage\n+ * collector directly to attempt to trigger cleaning here, hopefully\n+ * permitting the allocation to complete. Only if that doesn't free sufficient\n+ * memory does the allocation fail.  See java.nio.Bits::reserveMemory() for\n+ * details.\n+ *\n+ * One of the requirements for that approach is having a way to determine that\n+ * deactivated cleaners have been cleaned. java.lang.ref.Cleaner doesn't\n+ * provide such a mechanism, and adding such a mechanism to that class to\n+ * satisfy this unique requirement was deemed undesirable. Instead, this class\n+ * uses the underlying primitives (PhantomReferences, ReferenceQueues) to\n+ * provide the functionality needed for DBB management.\n+ *\/\n+class BufferCleaner {\n+    private static final class PhantomCleaner\n+        extends PhantomReference<Object>\n+        implements Cleaner\n+    {\n+        private final Runnable action;\n+        \/\/ Position in the CleanerList.\n+        CleanerList.Node node;\n+        int index;\n+\n+        public PhantomCleaner(Object obj, Runnable action) {\n+            super(obj, queue);\n+            this.action = action;\n+        }\n+\n+        public void clean() {\n+            if (cleanerList.remove(this)) {\n+                \/\/ If being cleaned explicitly by application, rather than via\n+                \/\/ reference processing by BufferCleaner, clear the referent so\n+                \/\/ reference processing is disabled for this object.\n+                clear();\n+                try {\n+                    action.run();\n+                } catch (Throwable x) {\n+                    \/\/ Long-standing behavior: when cleaning fails, VM exits.\n+                    if (System.err != null) {\n+                        new Error(\"nio Cleaner terminated abnormally\", x).printStackTrace();\n+                    }\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Cribbed from jdk.internal.ref.CleanerImpl.\n+    static final class CleanerList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node where PhantomCleanabls are\n+         * added to or removed from. This is the only node with variable size,\n+         * all other nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanerList() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleaner in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleaner phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            final int lastIndex = head.size;\n+            phc.node = head;\n+            phc.index = lastIndex;\n+            head.arr[lastIndex] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleaner from the list.\n+         *\n+         * @return true if Cleaner was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleaner phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            final int lastIndex = head.size - 1;\n+            assert lastIndex >= 0;\n+            if (head != phc.node || (phc.index != lastIndex)) {\n+                PhantomCleaner mover = head.arr[lastIndex];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[lastIndex] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleaners, and the amount of elements in it.\n+            final PhantomCleaner[] arr = new PhantomCleaner[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n+\n+    private static final class CleaningThread extends Thread {\n+        public CleaningThread() {}\n+\n+        @Override\n+        public void run() {\n+            while (true) {\n+                try {\n+                    Cleaner c = (Cleaner) queue.remove();\n+                    c.clean();\n+                } catch (InterruptedException e) {\n+                    \/\/ Ignore InterruptedException in cleaner thread.\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Try to do some cleaning. Takes a cleaner from the queue and executes it.\n+     *\n+     * @return true if a cleaner was found and executed, false if there\n+     * weren't any cleaners in the queue.\n+     *\/\n+    public static boolean tryCleaning() {\n+        Cleaner c = (Cleaner) queue.poll();\n+        if (c == null) {\n+            return false;\n+        } else {\n+            c.clean();\n+            return true;\n+        }\n+    }\n+\n+    private static final CleanerList cleanerList = new CleanerList();\n+    private static final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();\n+    private static CleaningThread cleaningThread = null;\n+\n+    private static void startCleaningThreadIfNeeded() {\n+        synchronized (cleanerList) {\n+            if (cleaningThread != null) {\n+                return;\n+            }\n+            cleaningThread = new CleaningThread();\n+        }\n+        cleaningThread.setDaemon(true);\n+        cleaningThread.start();\n+    }\n+\n+    private BufferCleaner() {}\n+\n+    \/**\n+     * Construct a new Cleaner for obj, with the associated action.\n+     *\n+     * @param obj object to track.\n+     * @param action cleanup action for obj.\n+     * @return associated cleaner.\n+     *\n+     *\/\n+    public static Cleaner register(Object obj, Runnable action) {\n+        Objects.requireNonNull(obj, \"obj\");\n+        Objects.requireNonNull(action, \"action\");\n+        startCleaningThreadIfNeeded();\n+        PhantomCleaner cleaner = new PhantomCleaner(obj, action);\n+        cleanerList.insert(cleaner);\n+        Reference.reachabilityFence(obj);\n+        return cleaner;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.BufferCleaner;\n@@ -40,1 +41,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n@@ -125,1 +126,1 @@\n-            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+            cleaner = BufferCleaner.register(this, new Deallocator(base, size, cap));\n@@ -200,1 +201,1 @@\n-        cleaner = Cleaner.create(this, unmapper);\n+        cleaner = (unmapper == null) ? null : BufferCleaner.register(this, unmapper);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -31,0 +30,1 @@\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio;\n+\n+\/**\n+ * {@code Cleaner} represents an object and a cleaning action.\n+ *\/\n+public interface Cleaner {\n+    \/**\n+     * Unregisters the cleaner and invokes the cleaning action.\n+     * The cleaner's cleaning action is invoked at most once,\n+     * regardless of the number of calls to {@code clean}.\n+     *\/\n+    void clean();\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/Cleaner.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.ref.Cleaner;\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DirectBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import jdk.internal.ref.Cleaner;\n@@ -66,0 +65,1 @@\n+import sun.nio.Cleaner;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean direct = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return direct ? ByteBuffer.allocateDirect(1) : ByteBuffer.allocate(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferChurn.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx1g\", \"-Xms1g\", \"-XX:+AlwaysPreTouch\"})\n+public class DirectByteBufferGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Make sure all buffers are reachable and available for GC. Buffers\n+    \/\/ directly reference their Cleanables, so we do not want to provide\n+    \/\/ excess GC parallelism opportunities here, this is why reference\n+    \/\/ buffers from a linked list.\n+    \/\/\n+    \/\/ This exposes the potential GC parallelism problem in Cleaner lists.\n+    LinkedList<ByteBuffer> buffers;\n+\n+    @Setup\n+    public void setup() {\n+        buffers = new LinkedList<>();\n+        for (int c = 0; c < count; c++) {\n+            buffers.add(ByteBuffer.allocateDirect(1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferGC.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}