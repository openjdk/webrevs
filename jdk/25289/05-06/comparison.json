{"files":[{"patch":"@@ -108,0 +108,3 @@\n+\n+    \/\/ Token for detecting whether some other thread has done a GC since the\n+    \/\/ last time the checking thread went around the retry-with-GC loop.\n@@ -131,1 +134,2 @@\n-            \/\/ GC to hopefully find more cleaning to do.\n+            \/\/ GC to hopefully find more cleaning to do. Once a thread GCs it\n+            \/\/ drops to the later retry with backoff loop.\n@@ -135,2 +139,2 @@\n-                    \/\/ If so, GC to produce more cleaning work, and increment\n-                    \/\/ the counter to inform other threads that there may be\n+                    \/\/ If so, GC to produce more cleaning work, and change\n+                    \/\/ the token to inform other threads that there may be\n@@ -141,1 +145,4 @@\n-                    \/\/ concurrent GC it's quite large.\n+                    \/\/ concurrent GC it's quite large. If a thread were to\n+                    \/\/ somehow be stuck trying to take the lock while enough\n+                    \/\/ other threads succeeded for the epoch to wrap, it just\n+                    \/\/ does an excess GC.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+        @Override\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferCleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}