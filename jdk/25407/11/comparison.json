{"files":[{"patch":"@@ -468,3 +468,1 @@\n-  _async_exceptions_blocked(false),\n-  _suspended(false),\n-  _async_suspend_handshake(false) {\n+  _async_exceptions_blocked(false) {\n@@ -702,120 +700,0 @@\n-void HandshakeState::do_self_suspend() {\n-  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n-  assert(_lock.owned_by_self(), \"Lock must be held\");\n-  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n-\n-  while (is_suspended()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n-    _lock.wait_without_safepoint_check();\n-  }\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n-}\n-\n-\/\/ This is the closure that prevents a suspended JavaThread from\n-\/\/ escaping the suspend request.\n-class ThreadSelfSuspensionHandshake : public AsyncHandshakeClosure {\n- public:\n-  ThreadSelfSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n-  void do_thread(Thread* thr) {\n-    JavaThread* current = JavaThread::cast(thr);\n-    assert(current == Thread::current(), \"Must be self executed.\");\n-    JavaThreadState jts = current->thread_state();\n-\n-    current->set_thread_state(_thread_blocked);\n-    current->handshake_state()->do_self_suspend();\n-    current->set_thread_state(jts);\n-    current->handshake_state()->set_async_suspend_handshake(false);\n-  }\n-  virtual bool is_suspend() { return true; }\n-};\n-\n-bool HandshakeState::suspend_with_handshake(bool register_vthread_SR) {\n-  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n-  if (_handshakee->is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n-    return false;\n-  }\n-  if (has_async_suspend_handshake()) {\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n-      return false;\n-    } else {\n-      \/\/ Target is going to wake up and leave suspension.\n-      \/\/ Let's just stop the thread from doing that.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n-      set_suspended(true, register_vthread_SR);\n-      return true;\n-    }\n-  }\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n-  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n-  \/\/ from this point.\n-  set_suspended(true, register_vthread_SR);\n-  set_async_suspend_handshake(true);\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n-  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n-  Handshake::execute(ts, _handshakee);\n-  return true;\n-}\n-\n-\/\/ This is the closure that synchronously honors the suspend request.\n-class SuspendThreadHandshake : public HandshakeClosure {\n-  bool _register_vthread_SR;\n-  bool _did_suspend;\n-public:\n-  SuspendThreadHandshake(bool register_vthread_SR) : HandshakeClosure(\"SuspendThread\"),\n-    _register_vthread_SR(register_vthread_SR), _did_suspend(false) {}\n-  void do_thread(Thread* thr) {\n-    JavaThread* target = JavaThread::cast(thr);\n-    _did_suspend = target->handshake_state()->suspend_with_handshake(_register_vthread_SR);\n-  }\n-  bool did_suspend() { return _did_suspend; }\n-};\n-\n-bool HandshakeState::suspend(bool register_vthread_SR) {\n-  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n-  JavaThread* self = JavaThread::current();\n-  if (_handshakee == self) {\n-    \/\/ If target is the current thread we can bypass the handshake machinery\n-    \/\/ and just suspend directly\n-    ThreadBlockInVM tbivm(self);\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-    set_suspended(true, register_vthread_SR);\n-    do_self_suspend();\n-    return true;\n-  } else {\n-    SuspendThreadHandshake st(register_vthread_SR);\n-    Handshake::execute(&st, _handshakee);\n-    return st.did_suspend();\n-  }\n-}\n-\n-bool HandshakeState::resume(bool register_vthread_SR) {\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-  if (!is_suspended()) {\n-    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n-    return false;\n-  }\n-  \/\/ Resume the thread.\n-  set_suspended(false, register_vthread_SR);\n-  _lock.notify();\n-  return true;\n-}\n-\n-void HandshakeState::set_suspended(bool is_suspend, bool register_vthread_SR) {\n-#if INCLUDE_JVMTI\n-  if (register_vthread_SR) {\n-    assert(_handshakee->is_vthread_mounted(), \"sanity check\");\n-    if (is_suspend) {\n-      JvmtiVTSuspender::register_vthread_suspend(_handshakee->vthread());\n-    } else {\n-      JvmtiVTSuspender::register_vthread_resume(_handshakee->vthread());\n-    }\n-  }\n-#endif\n-  Atomic::store(&_suspended, is_suspend);\n-}\n-\n@@ -823,1 +701,1 @@\n-  if (is_suspended()) {\n+  if (_handshakee->is_suspended()) {\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":124,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-class SuspendThreadHandshake;\n-class ThreadSelfSuspensionHandshake;\n@@ -91,2 +89,0 @@\n-  friend ThreadSelfSuspensionHandshake;\n-  friend SuspendThreadHandshake;\n@@ -101,1 +97,1 @@\n-  \/\/ JavaThread suspend\/resume operations.\n+  \/\/ JavaThread suspend\/resume operations performed by SuspendResumeManager.\n@@ -163,25 +159,0 @@\n-\n-  \/\/ Suspend\/resume support\n- private:\n-  \/\/ This flag is true when the thread owning this\n-  \/\/ HandshakeState (the _handshakee) is suspended.\n-  volatile bool _suspended;\n-  \/\/ This flag is true while there is async handshake (trap)\n-  \/\/ on queue. Since we do only need one, we can reuse it if\n-  \/\/ thread gets suspended again (after a resume)\n-  \/\/ and we have not yet processed it.\n-  bool _async_suspend_handshake;\n-\n-  \/\/ Called from the suspend handshake.\n-  bool suspend_with_handshake(bool register_vthread_SR);\n-  \/\/ Called from the async handshake (the trap)\n-  \/\/ to stop a thread from continuing execution when suspended.\n-  void do_self_suspend();\n-\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n-  void set_suspended(bool to, bool register_vthread_SR);\n-  bool has_async_suspend_handshake()        { return _async_suspend_handshake; }\n-  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n-\n-  bool suspend(bool register_vthread_SR);\n-  bool resume(bool register_vthread_SR);\n@@ -189,1 +160,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -501,0 +501,1 @@\n+  _suspend_resume_manager(this, &_handshake._lock),\n@@ -1203,1 +1204,1 @@\n-  return this->handshake_state()->suspend(register_vthread_SR);\n+  return this->suspend_resume_manager()->suspend(register_vthread_SR);\n@@ -1209,1 +1210,1 @@\n-  return this->handshake_state()->resume(register_vthread_SR);\n+  return this->suspend_resume_manager()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/suspendResumeManager.hpp\"\n@@ -697,0 +698,3 @@\n+private:\n+  SuspendResumeManager _suspend_resume_manager;\n+public:\n@@ -699,1 +703,2 @@\n-  bool is_suspended()     { return _handshake.is_suspended(); }\n+  bool is_suspended()     { return _suspend_resume_manager.is_suspended(); }\n+  SuspendResumeManager* suspend_resume_manager() { return &_suspend_resume_manager; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"prims\/jvmtiThreadState.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/suspendResumeManager.hpp\"\n+\n+\/\/ This is the closure that prevents a suspended JavaThread from\n+\/\/ escaping the suspend request.\n+class ThreadSelfSuspensionHandshake : public AsyncHandshakeClosure {\n+public:\n+  ThreadSelfSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* current = JavaThread::cast(thr);\n+    assert(current == Thread::current(), \"Must be self executed.\");\n+    JavaThreadState jts = current->thread_state();\n+\n+    current->set_thread_state(_thread_blocked);\n+    current->suspend_resume_manager()->do_owner_suspend();\n+    current->set_thread_state(jts);\n+    current->suspend_resume_manager()->set_async_suspend_handshake(false);\n+  }\n+  virtual bool is_suspend() { return true; }\n+};\n+\n+\/\/ This is the closure that synchronously honors the suspend request.\n+class SuspendThreadHandshake : public HandshakeClosure {\n+  bool _register_vthread_SR;\n+  bool _did_suspend;\n+public:\n+  SuspendThreadHandshake(bool register_vthread_SR) : HandshakeClosure(\"SuspendThread\"),\n+    _register_vthread_SR(register_vthread_SR), _did_suspend(false) {\n+  }\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = JavaThread::cast(thr);\n+    _did_suspend = target->suspend_resume_manager()->suspend_with_handshake(_register_vthread_SR);\n+  }\n+  bool did_suspend() { return _did_suspend; }\n+};\n+\n+void SuspendResumeManager::set_suspended(bool is_suspend, bool register_vthread_SR) {\n+#if INCLUDE_JVMTI\n+  if (register_vthread_SR) {\n+    assert(_target->is_vthread_mounted(), \"sanity check\");\n+    if (is_suspend) {\n+      JvmtiVTSuspender::register_vthread_suspend(_target->vthread());\n+    }\n+    else {\n+      JvmtiVTSuspender::register_vthread_resume(_target->vthread());\n+    }\n+  }\n+#endif\n+  Atomic::store(&_suspended, is_suspend);\n+}\n+\n+bool SuspendResumeManager::suspend(bool register_vthread_SR) {\n+  JVMTI_ONLY(assert(!_target->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n+  JavaThread* self = JavaThread::current();\n+  if (_target == self) {\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true, register_vthread_SR);\n+    do_owner_suspend();\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st(register_vthread_SR);\n+    Handshake::execute(&st, _target);\n+    return st.did_suspend();\n+  }\n+}\n+\n+bool SuspendResumeManager::resume(bool register_vthread_SR) {\n+  MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended()) {\n+    assert(!_target->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspended(false, register_vthread_SR);\n+  _state_lock->notify();\n+  return true;\n+}\n+\n+void SuspendResumeManager::do_owner_suspend() {\n+  assert(Thread::current() == _target, \"should call from _target\");\n+  assert(_state_lock->owned_by_self(), \"Lock must be held\");\n+  assert(!_target->has_last_Java_frame() || _target->frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(_target->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+\n+  while (is_suspended()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_target));\n+    _state_lock->wait_without_safepoint_check();\n+  }\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_target));\n+}\n+\n+bool SuspendResumeManager::suspend_with_handshake(bool register_vthread_SR) {\n+  assert(_target->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n+  if (_target->is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_target));\n+    return false;\n+  }\n+  if (has_async_suspend_handshake()) {\n+    if (is_suspended()) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_target));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_target));\n+      set_suspended(true, register_vthread_SR);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspended(true, register_vthread_SR);\n+  set_async_suspend_handshake(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_target));\n+  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n+  Handshake::execute(ts, _target);\n+  return true;\n+}\n+\n+SuspendResumeManager::SuspendResumeManager(JavaThread* thread, Monitor* state_lock) : _target(thread), _state_lock(state_lock), _suspended(false), _async_suspend_handshake(false) {}\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SUSPENDRESUMEMANAGER_HPP\n+#define SHARE_RUNTIME_SUSPENDRESUMEMANAGER_HPP\n+\n+class SuspendThreadHandshake;\n+class ThreadSelfSuspensionHandshake;\n+\n+class SuspendResumeManager {\n+  friend SuspendThreadHandshake;\n+  friend ThreadSelfSuspensionHandshake;\n+  friend JavaThread;\n+\n+  JavaThread* _target;\n+  Monitor* _state_lock;\n+\n+  SuspendResumeManager(JavaThread* thread, Monitor* state_lock);\n+\n+  \/\/ This flag is true when the thread owning this\n+  \/\/ SuspendResumeManager (the _target) is suspended.\n+  volatile bool _suspended;\n+  \/\/ This flag is true while there is async handshake (trap)\n+  \/\/ on queue. Since we do only need one, we can reuse it if\n+  \/\/ thread gets suspended again (after a resume)\n+  \/\/ and we have not yet processed it.\n+  bool _async_suspend_handshake;\n+\n+  bool suspend(bool register_vthread_SR);\n+  bool resume(bool register_vthread_SR);\n+\n+  \/\/ Called from the async handshake (the trap)\n+  \/\/ to stop a thread from continuing execution when suspended.\n+  void do_owner_suspend();\n+\n+  \/\/ Called from the suspend handshake.\n+  bool suspend_with_handshake(bool register_vthread_SR);\n+\n+  void set_suspended(bool to, bool register_vthread_SR);\n+\n+  bool is_suspended() {\n+    return Atomic::load(&_suspended);\n+  }\n+\n+  bool has_async_suspend_handshake() { return _async_suspend_handshake; }\n+  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_SUSPENDRESUMEMANAGER_HPP\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}