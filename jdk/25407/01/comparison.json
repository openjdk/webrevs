{"files":[{"patch":"@@ -702,13 +702,0 @@\n-void HandshakeState::do_self_suspend() {\n-  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n-  assert(_lock.owned_by_self(), \"Lock must be held\");\n-  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n-\n-  while (is_suspended()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n-    _lock.wait_without_safepoint_check();\n-  }\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n-}\n-\n@@ -726,1 +713,1 @@\n-    current->handshake_state()->do_self_suspend();\n+    HandshakeSuspender::do_self_suspend(current->handshake_state());\n@@ -728,1 +715,1 @@\n-    current->handshake_state()->set_async_suspend_handshake(false);\n+    HandshakeSuspender::set_async_suspend_handshake(current->handshake_state(), false);\n@@ -733,31 +720,0 @@\n-bool HandshakeState::suspend_with_handshake(bool register_vthread_SR) {\n-  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n-  if (_handshakee->is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n-    return false;\n-  }\n-  if (has_async_suspend_handshake()) {\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n-      return false;\n-    } else {\n-      \/\/ Target is going to wake up and leave suspension.\n-      \/\/ Let's just stop the thread from doing that.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n-      set_suspended(true, register_vthread_SR);\n-      return true;\n-    }\n-  }\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n-  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n-  \/\/ from this point.\n-  set_suspended(true, register_vthread_SR);\n-  set_async_suspend_handshake(true);\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n-  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n-  Handshake::execute(ts, _handshakee);\n-  return true;\n-}\n-\n@@ -773,1 +729,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake(_register_vthread_SR);\n+    _did_suspend = HandshakeSuspender::suspend_with_handshake(target->handshake_state(), _register_vthread_SR);\n@@ -778,30 +734,0 @@\n-bool HandshakeState::suspend(bool register_vthread_SR) {\n-  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n-  JavaThread* self = JavaThread::current();\n-  if (_handshakee == self) {\n-    \/\/ If target is the current thread we can bypass the handshake machinery\n-    \/\/ and just suspend directly\n-    ThreadBlockInVM tbivm(self);\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-    set_suspended(true, register_vthread_SR);\n-    do_self_suspend();\n-    return true;\n-  } else {\n-    SuspendThreadHandshake st(register_vthread_SR);\n-    Handshake::execute(&st, _handshakee);\n-    return st.did_suspend();\n-  }\n-}\n-\n-bool HandshakeState::resume(bool register_vthread_SR) {\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-  if (!is_suspended()) {\n-    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n-    return false;\n-  }\n-  \/\/ Resume the thread.\n-  set_suspended(false, register_vthread_SR);\n-  _lock.notify();\n-  return true;\n-}\n-\n@@ -847,0 +773,74 @@\n+\n+bool HandshakeSuspender::suspend(HandshakeState *state, bool register_vthread_SR) {\n+  JVMTI_ONLY(assert(!get_handshakee(state)->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n+  JavaThread* self = JavaThread::current();\n+  if (get_handshakee(state) == self) {\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(get_lock_ptr(state), Mutex::_no_safepoint_check_flag);\n+    set_suspended(state, true, register_vthread_SR);\n+    do_self_suspend(state);\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st(register_vthread_SR);\n+    Handshake::execute(&st, get_handshakee(state));\n+    return st.did_suspend();\n+  }\n+}\n+\n+bool HandshakeSuspender::resume(HandshakeState* state, bool register_vthread_SR) {\n+  MutexLocker ml(get_lock_ptr(state), Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended(state)) {\n+    assert(!get_handshakee(state)->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspended(state, false, register_vthread_SR);\n+  get_lock_ptr(state)->notify();\n+  return true;\n+}\n+\n+void HandshakeSuspender::do_self_suspend(HandshakeState* state) {\n+  assert(Thread::current() == get_handshakee(state), \"should call from _handshakee\");\n+  assert(get_lock_ptr(state)->owned_by_self(), \"Lock must be held\");\n+  assert(!get_handshakee(state)->has_last_Java_frame() || get_handshakee(state)->frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(get_handshakee(state)->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+\n+  while (is_suspended(state)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(get_handshakee(state)));\n+    get_lock_ptr(state)->wait_without_safepoint_check();\n+  }\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(get_handshakee(state)));\n+}\n+\n+bool HandshakeSuspender::suspend_with_handshake(HandshakeState* state, bool register_vthread_SR) {\n+  assert(get_handshakee(state)->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n+  if (get_handshakee(state)->is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(get_handshakee(state)));\n+    return false;\n+  }\n+  if (has_async_suspend_handshake(state)) {\n+    if (is_suspended(state)) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(get_handshakee(state)));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(get_handshakee(state)));\n+      set_suspended(state, true, register_vthread_SR);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(state), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspended(state, true, register_vthread_SR);\n+  set_async_suspend_handshake(state, true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(get_handshakee(state)));\n+  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n+  Handshake::execute(ts, get_handshakee(state));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+class HandshakeSuspender;\n@@ -95,0 +96,1 @@\n+  friend HandshakeSuspender;\n@@ -175,6 +177,0 @@\n-  \/\/ Called from the suspend handshake.\n-  bool suspend_with_handshake(bool register_vthread_SR);\n-  \/\/ Called from the async handshake (the trap)\n-  \/\/ to stop a thread from continuing execution when suspended.\n-  void do_self_suspend();\n-\n@@ -183,0 +179,1 @@\n+\n@@ -185,0 +182,42 @@\n+};\n+\n+class HandshakeSuspender {\n+  friend SuspendThreadHandshake;\n+  friend ThreadSelfSuspensionHandshake;\n+  friend JavaThread;\n+\n+private:\n+\n+  static bool suspend(HandshakeState* state, bool register_vthread_SR);\n+  static bool resume(HandshakeState* state, bool register_vthread_SR);\n+\n+  \/\/ Called from the async handshake (the trap)\n+  \/\/ to stop a thread from continuing execution when suspended.\n+  static void do_self_suspend(HandshakeState* state);\n+\n+  \/\/ Called from the suspend handshake.\n+  static bool suspend_with_handshake(HandshakeState* state, bool register_vthread_SR);\n+\n+  static JavaThread* get_handshakee(HandshakeState* state) {\n+    return state->_handshakee;\n+  }\n+\n+  static void set_suspended(HandshakeState* state, bool to, bool register_vthread_SR) {\n+    state->set_suspended(to, register_vthread_SR);\n+  }\n+\n+  static bool is_suspended(HandshakeState* state) {\n+    return state->is_suspended();\n+  }\n+\n+  static Monitor* get_lock_ptr(HandshakeState* state) {\n+    return &state->_lock;\n+  }\n+\n+  static bool has_async_suspend_handshake(HandshakeState* state) {\n+    return state->has_async_suspend_handshake();\n+  }\n+\n+  static void set_async_suspend_handshake(HandshakeState* state, bool to) {\n+    state->set_async_suspend_handshake(to);\n+  }\n@@ -186,2 +225,0 @@\n-  bool suspend(bool register_vthread_SR);\n-  bool resume(bool register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-  return this->handshake_state()->suspend(register_vthread_SR);\n+  return HandshakeSuspender::suspend(this->handshake_state(), register_vthread_SR);\n@@ -1210,1 +1210,1 @@\n-  return this->handshake_state()->resume(register_vthread_SR);\n+  return HandshakeSuspender::resume(this->handshake_state(), register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}