{"files":[{"patch":"@@ -700,48 +700,2 @@\n-\/\/ This is the closure that prevents a suspended JavaThread from\n-\/\/ escaping the suspend request.\n-class ThreadSelfSuspensionHandshake : public AsyncHandshakeClosure {\n- public:\n-  ThreadSelfSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n-  void do_thread(Thread* thr) {\n-    JavaThread* current = JavaThread::cast(thr);\n-    assert(current == Thread::current(), \"Must be self executed.\");\n-    JavaThreadState jts = current->thread_state();\n-\n-    current->set_thread_state(_thread_blocked);\n-    current->handshake_suspender()->do_self_suspend();\n-    current->set_thread_state(jts);\n-    current->handshake_suspender()->set_async_suspend_handshake(false);\n-  }\n-  virtual bool is_suspend() { return true; }\n-};\n-\n-\/\/ This is the closure that synchronously honors the suspend request.\n-class SuspendThreadHandshake : public HandshakeClosure {\n-  bool _register_vthread_SR;\n-  bool _did_suspend;\n-public:\n-  SuspendThreadHandshake(bool register_vthread_SR) : HandshakeClosure(\"SuspendThread\"),\n-    _register_vthread_SR(register_vthread_SR), _did_suspend(false) {}\n-  void do_thread(Thread* thr) {\n-    JavaThread* target = JavaThread::cast(thr);\n-    _did_suspend = target->handshake_suspender()->suspend_with_handshake(_register_vthread_SR);\n-  }\n-  bool did_suspend() { return _did_suspend; }\n-};\n-\n-void HandshakeSuspender::set_suspended(bool is_suspend, bool register_vthread_SR) {\n-#if INCLUDE_JVMTI\n-  if (register_vthread_SR) {\n-    assert(_handshakee->is_vthread_mounted(), \"sanity check\");\n-    if (is_suspend) {\n-      JvmtiVTSuspender::register_vthread_suspend(_handshakee->vthread());\n-    } else {\n-      JvmtiVTSuspender::register_vthread_resume(_handshakee->vthread());\n-    }\n-  }\n-#endif\n-  Atomic::store(&_suspended, is_suspend);\n-}\n-\n-void HandshakeState::handle_unsafe_access_error(HandshakeSuspender* suspender) {\n-  if (suspender->is_suspended()) {\n+void HandshakeState::handle_unsafe_access_error() {\n+  if (_handshakee->is_suspended()) {\n@@ -771,76 +725,0 @@\n-\n-bool HandshakeSuspender::suspend(bool register_vthread_SR) {\n-  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n-  JavaThread* self = JavaThread::current();\n-  if (_handshakee == self) {\n-    \/\/ If target is the current thread we can bypass the handshake machinery\n-    \/\/ and just suspend directly\n-    ThreadBlockInVM tbivm(self);\n-    MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n-    set_suspended(true, register_vthread_SR);\n-    do_self_suspend();\n-    return true;\n-  } else {\n-    SuspendThreadHandshake st(register_vthread_SR);\n-    Handshake::execute(&st, _handshakee);\n-    return st.did_suspend();\n-  }\n-}\n-\n-bool HandshakeSuspender::resume(bool register_vthread_SR) {\n-  MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n-  if (!is_suspended()) {\n-    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n-    return false;\n-  }\n-  \/\/ Resume the thread.\n-  set_suspended(false, register_vthread_SR);\n-  _state_lock->notify();\n-  return true;\n-}\n-\n-void HandshakeSuspender::do_self_suspend() {\n-  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n-  assert(_state_lock->owned_by_self(), \"Lock must be held\");\n-  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n-\n-  while (is_suspended()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n-    _state_lock->wait_without_safepoint_check();\n-  }\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n-}\n-\n-bool HandshakeSuspender::suspend_with_handshake(bool register_vthread_SR) {\n-  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n-  if (_handshakee->is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n-    return false;\n-  }\n-  if (has_async_suspend_handshake()) {\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n-      return false;\n-    } else {\n-      \/\/ Target is going to wake up and leave suspension.\n-      \/\/ Let's just stop the thread from doing that.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n-      set_suspended(true, register_vthread_SR);\n-      return true;\n-    }\n-  }\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n-  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n-  \/\/ from this point.\n-  set_suspended(true, register_vthread_SR);\n-  set_async_suspend_handshake(true);\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n-  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n-  Handshake::execute(ts, _handshakee);\n-  return true;\n-}\n-\n-HandshakeSuspender::HandshakeSuspender(JavaThread* thread, Monitor* state_lock) : _handshakee(thread), _state_lock(state_lock), _suspended(false), _async_suspend_handshake(false) {}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":124,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-class HandshakeSuspender;\n@@ -96,1 +95,0 @@\n-  friend HandshakeSuspender;\n@@ -164,1 +162,1 @@\n-  void handle_unsafe_access_error(HandshakeSuspender* suspender);\n+  void handle_unsafe_access_error();\n@@ -166,44 +164,0 @@\n-\n-class HandshakeSuspender {\n-  friend SuspendThreadHandshake;\n-  friend ThreadSelfSuspensionHandshake;\n-  friend JavaThread;\n-  friend HandshakeState;\n-\n-  JavaThread* _handshakee;\n-  Monitor* _state_lock;\n-\n-public:\n-  HandshakeSuspender(JavaThread* thread, Monitor* state_lock);\n-\n-private:\n-  \/\/ This flag is true when the thread owning this\n-  \/\/ HandshakeSuspender (the _handshakee) is suspended.\n-  volatile bool _suspended;\n-  \/\/ This flag is true while there is async handshake (trap)\n-  \/\/ on queue. Since we do only need one, we can reuse it if\n-  \/\/ thread gets suspended again (after a resume)\n-  \/\/ and we have not yet processed it.\n-  bool _async_suspend_handshake;\n-\n-  bool suspend(bool register_vthread_SR);\n-  bool resume(bool register_vthread_SR);\n-\n-  \/\/ Called from the async handshake (the trap)\n-  \/\/ to stop a thread from continuing execution when suspended.\n-  void do_self_suspend();\n-\n-  \/\/ Called from the suspend handshake.\n-  bool suspend_with_handshake(bool register_vthread_SR);\n-\n-  void set_suspended(bool to, bool register_vthread_SR);\n-\n-  bool is_suspended() {\n-    return Atomic::load(&_suspended);\n-  }\n-\n-  bool has_async_suspend_handshake() { return _async_suspend_handshake; }\n-  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n-\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":47,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  _handshake_suspender(this, &_handshake._lock),\n+  _suspend_resume_manager(this, &_handshake._lock),\n@@ -1204,1 +1204,1 @@\n-  return this->handshake_suspender()->suspend(register_vthread_SR);\n+  return this->suspend_resume_manager()->suspend(register_vthread_SR);\n@@ -1210,1 +1210,1 @@\n-  return this->handshake_suspender()->resume(register_vthread_SR);\n+  return this->suspend_resume_manager()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/suspendResumeManager.hpp\"\n@@ -84,0 +85,1 @@\n+\n@@ -686,1 +688,1 @@\n-  HandshakeSuspender _handshake_suspender;\n+\n@@ -689,1 +691,1 @@\n-  HandshakeSuspender* handshake_suspender() { return &_handshake_suspender; }\n+\n@@ -699,0 +701,3 @@\n+private:\n+  SuspendResumeManager _suspend_resume_manager;\n+public:\n@@ -701,1 +706,2 @@\n-  bool is_suspended()     { return _handshake_suspender.is_suspended(); }\n+  bool is_suspended()     { return _suspend_resume_manager.is_suspended(); }\n+  SuspendResumeManager* suspend_resume_manager() { return &_suspend_resume_manager; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    self->handshake_state()->handle_unsafe_access_error(self->handshake_suspender());\n+    self->handshake_state()->handle_unsafe_access_error();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"prims\/jvmtiThreadState.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/suspendResumeManager.hpp\"\n+\n+\/\/ This is the closure that prevents a suspended JavaThread from\n+\/\/ escaping the suspend request.\n+class ThreadSelfSuspensionHandshake : public AsyncHandshakeClosure {\n+public:\n+  ThreadSelfSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSelfSuspensionHandshake\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* current = JavaThread::cast(thr);\n+    assert(current == Thread::current(), \"Must be self executed.\");\n+    JavaThreadState jts = current->thread_state();\n+\n+    current->set_thread_state(_thread_blocked);\n+    current->suspend_resume_manager()->do_owner_suspend();\n+    current->set_thread_state(jts);\n+    current->suspend_resume_manager()->set_async_suspend_handshake(false);\n+  }\n+  virtual bool is_suspend() { return true; }\n+};\n+\n+\/\/ This is the closure that synchronously honors the suspend request.\n+class SuspendThreadHandshake : public HandshakeClosure {\n+  bool _register_vthread_SR;\n+  bool _did_suspend;\n+public:\n+  SuspendThreadHandshake(bool register_vthread_SR) : HandshakeClosure(\"SuspendThread\"),\n+    _register_vthread_SR(register_vthread_SR), _did_suspend(false) {\n+  }\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = JavaThread::cast(thr);\n+    _did_suspend = target->suspend_resume_manager()->suspend_with_handshake(_register_vthread_SR);\n+  }\n+  bool did_suspend() { return _did_suspend; }\n+};\n+\n+void SuspendResumeManager::set_suspended(bool is_suspend, bool register_vthread_SR) {\n+#if INCLUDE_JVMTI\n+  if (register_vthread_SR) {\n+    assert(_handshakee->is_vthread_mounted(), \"sanity check\");\n+    if (is_suspend) {\n+      JvmtiVTSuspender::register_vthread_suspend(_handshakee->vthread());\n+    }\n+    else {\n+      JvmtiVTSuspender::register_vthread_resume(_handshakee->vthread());\n+    }\n+  }\n+#endif\n+  Atomic::store(&_suspended, is_suspend);\n+}\n+\n+bool SuspendResumeManager::suspend(bool register_vthread_SR) {\n+  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n+    JavaThread* self = JavaThread::current();\n+  if (_handshakee == self) {\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true, register_vthread_SR);\n+    do_owner_suspend();\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st(register_vthread_SR);\n+    Handshake::execute(&st, _handshakee);\n+    return st.did_suspend();\n+  }\n+}\n+\n+bool SuspendResumeManager::resume(bool register_vthread_SR) {\n+  MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspended(false, register_vthread_SR);\n+  _state_lock->notify();\n+  return true;\n+}\n+\n+void SuspendResumeManager::do_owner_suspend() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_state_lock->owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+\n+  while (is_suspended()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _state_lock->wait_without_safepoint_check();\n+  }\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n+}\n+\n+bool SuspendResumeManager::suspend_with_handshake(bool register_vthread_SR) {\n+  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n+  if (_handshakee->is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n+    return false;\n+  }\n+  if (has_async_suspend_handshake()) {\n+    if (is_suspended()) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n+      set_suspended(true, register_vthread_SR);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspended(true, register_vthread_SR);\n+  set_async_suspend_handshake(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n+  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n+  Handshake::execute(ts, _handshakee);\n+  return true;\n+}\n+\n+SuspendResumeManager::SuspendResumeManager(JavaThread* thread, Monitor* state_lock) : _handshakee(thread), _state_lock(state_lock), _suspended(false), _async_suspend_handshake(false) {}\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SUSPENSRESUMEMANAGER_HPP\n+#define SHARE_RUNTIME_SUSPENSRESUMEMANAGER_HPP\n+\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+\n+class SuspendResumeManager {\n+  friend SuspendThreadHandshake;\n+  friend ThreadSelfSuspensionHandshake;\n+  friend JavaThread;\n+\n+  JavaThread* _handshakee;\n+  Monitor* _state_lock;\n+\n+public:\n+  SuspendResumeManager(JavaThread* thread, Monitor* state_lock);\n+\n+private:\n+  \/\/ This flag is true when the thread owning this\n+  \/\/ SuspendResumeManager (the _handshakee) is suspended.\n+  volatile bool _suspended;\n+  \/\/ This flag is true while there is async handshake (trap)\n+  \/\/ on queue. Since we do only need one, we can reuse it if\n+  \/\/ thread gets suspended again (after a resume)\n+  \/\/ and we have not yet processed it.\n+  bool _async_suspend_handshake;\n+\n+  bool suspend(bool register_vthread_SR);\n+  bool resume(bool register_vthread_SR);\n+\n+  \/\/ Called from the async handshake (the trap)\n+  \/\/ to stop a thread from continuing execution when suspended.\n+  void do_owner_suspend();\n+\n+  \/\/ Called from the suspend handshake.\n+  bool suspend_with_handshake(bool register_vthread_SR);\n+\n+  void set_suspended(bool to, bool register_vthread_SR);\n+\n+  bool is_suspended() {\n+    return Atomic::load(&_suspended);\n+  }\n+\n+  bool has_async_suspend_handshake() { return _async_suspend_handshake; }\n+  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_SUSPENSRESUMEMANAGER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}