{"files":[{"patch":"@@ -468,3 +468,1 @@\n-  _async_exceptions_blocked(false),\n-  _suspended(false),\n-  _async_suspend_handshake(false) {\n+  _async_exceptions_blocked(false) {\n@@ -702,13 +700,0 @@\n-void HandshakeState::do_self_suspend() {\n-  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n-  assert(_lock.owned_by_self(), \"Lock must be held\");\n-  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n-\n-  while (is_suspended()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n-    _lock.wait_without_safepoint_check();\n-  }\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n-}\n-\n@@ -726,1 +711,1 @@\n-    current->handshake_state()->do_self_suspend();\n+    current->handshake_suspender()->do_self_suspend();\n@@ -728,1 +713,1 @@\n-    current->handshake_state()->set_async_suspend_handshake(false);\n+    current->handshake_suspender()->set_async_suspend_handshake(false);\n@@ -733,31 +718,0 @@\n-bool HandshakeState::suspend_with_handshake(bool register_vthread_SR) {\n-  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n-  if (_handshakee->is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n-    return false;\n-  }\n-  if (has_async_suspend_handshake()) {\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n-      return false;\n-    } else {\n-      \/\/ Target is going to wake up and leave suspension.\n-      \/\/ Let's just stop the thread from doing that.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n-      set_suspended(true, register_vthread_SR);\n-      return true;\n-    }\n-  }\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n-  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n-  \/\/ from this point.\n-  set_suspended(true, register_vthread_SR);\n-  set_async_suspend_handshake(true);\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n-  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n-  Handshake::execute(ts, _handshakee);\n-  return true;\n-}\n-\n@@ -773,1 +727,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake(_register_vthread_SR);\n+    _did_suspend = target->handshake_suspender()->suspend_with_handshake(_register_vthread_SR);\n@@ -778,31 +732,1 @@\n-bool HandshakeState::suspend(bool register_vthread_SR) {\n-  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n-  JavaThread* self = JavaThread::current();\n-  if (_handshakee == self) {\n-    \/\/ If target is the current thread we can bypass the handshake machinery\n-    \/\/ and just suspend directly\n-    ThreadBlockInVM tbivm(self);\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-    set_suspended(true, register_vthread_SR);\n-    do_self_suspend();\n-    return true;\n-  } else {\n-    SuspendThreadHandshake st(register_vthread_SR);\n-    Handshake::execute(&st, _handshakee);\n-    return st.did_suspend();\n-  }\n-}\n-\n-bool HandshakeState::resume(bool register_vthread_SR) {\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-  if (!is_suspended()) {\n-    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n-    return false;\n-  }\n-  \/\/ Resume the thread.\n-  set_suspended(false, register_vthread_SR);\n-  _lock.notify();\n-  return true;\n-}\n-\n-void HandshakeState::set_suspended(bool is_suspend, bool register_vthread_SR) {\n+void HandshakeSuspender::set_suspended(bool is_suspend, bool register_vthread_SR) {\n@@ -822,2 +746,2 @@\n-void HandshakeState::handle_unsafe_access_error() {\n-  if (is_suspended()) {\n+void HandshakeState::handle_unsafe_access_error(HandshakeSuspender* suspender) {\n+  if (suspender->is_suspended()) {\n@@ -847,0 +771,76 @@\n+\n+bool HandshakeSuspender::suspend(bool register_vthread_SR) {\n+  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n+  JavaThread* self = JavaThread::current();\n+  if (_handshakee == self) {\n+    \/\/ If target is the current thread we can bypass the handshake machinery\n+    \/\/ and just suspend directly\n+    ThreadBlockInVM tbivm(self);\n+    MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true, register_vthread_SR);\n+    do_self_suspend();\n+    return true;\n+  } else {\n+    SuspendThreadHandshake st(register_vthread_SR);\n+    Handshake::execute(&st, _handshakee);\n+    return st.did_suspend();\n+  }\n+}\n+\n+bool HandshakeSuspender::resume(bool register_vthread_SR) {\n+  MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  \/\/ Resume the thread.\n+  set_suspended(false, register_vthread_SR);\n+  _state_lock->notify();\n+  return true;\n+}\n+\n+void HandshakeSuspender::do_self_suspend() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_state_lock->owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+\n+  while (is_suspended()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _state_lock->wait_without_safepoint_check();\n+  }\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n+}\n+\n+bool HandshakeSuspender::suspend_with_handshake(bool register_vthread_SR) {\n+  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n+  if (_handshakee->is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n+    return false;\n+  }\n+  if (has_async_suspend_handshake()) {\n+    if (is_suspended()) {\n+      \/\/ Target is already suspended.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+      return false;\n+    } else {\n+      \/\/ Target is going to wake up and leave suspension.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n+      set_suspended(true, register_vthread_SR);\n+      return true;\n+    }\n+  }\n+  \/\/ no suspend request\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+  \/\/ Thread is safe, so it must execute the request, thus we can count it as suspended\n+  \/\/ from this point.\n+  set_suspended(true, register_vthread_SR);\n+  set_async_suspend_handshake(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n+  ThreadSelfSuspensionHandshake* ts = new ThreadSelfSuspensionHandshake();\n+  Handshake::execute(ts, _handshakee);\n+  return true;\n+}\n+\n+HandshakeSuspender::HandshakeSuspender(JavaThread* thread, Monitor* state_lock) : _handshakee(thread), _state_lock(state_lock), _suspended(false), _async_suspend_handshake(false) {}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+class HandshakeSuspender;\n@@ -95,0 +96,1 @@\n+  friend HandshakeSuspender;\n@@ -162,1 +164,2 @@\n-  void handle_unsafe_access_error();\n+  void handle_unsafe_access_error(HandshakeSuspender* suspender);\n+};\n@@ -164,2 +167,13 @@\n-  \/\/ Suspend\/resume support\n- private:\n+class HandshakeSuspender {\n+  friend SuspendThreadHandshake;\n+  friend ThreadSelfSuspensionHandshake;\n+  friend JavaThread;\n+  friend HandshakeState;\n+\n+  JavaThread* _handshakee;\n+  Monitor* _state_lock;\n+\n+public:\n+  HandshakeSuspender(JavaThread* thread, Monitor* state_lock);\n+\n+private:\n@@ -167,1 +181,1 @@\n-  \/\/ HandshakeState (the _handshakee) is suspended.\n+  \/\/ HandshakeSuspender (the _handshakee) is suspended.\n@@ -175,2 +189,3 @@\n-  \/\/ Called from the suspend handshake.\n-  bool suspend_with_handshake(bool register_vthread_SR);\n+  bool suspend(bool register_vthread_SR);\n+  bool resume(bool register_vthread_SR);\n+\n@@ -181,1 +196,3 @@\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n+  \/\/ Called from the suspend handshake.\n+  bool suspend_with_handshake(bool register_vthread_SR);\n+\n@@ -183,1 +200,6 @@\n-  bool has_async_suspend_handshake()        { return _async_suspend_handshake; }\n+\n+  bool is_suspended() {\n+    return Atomic::load(&_suspended);\n+  }\n+\n+  bool has_async_suspend_handshake() { return _async_suspend_handshake; }\n@@ -186,2 +208,0 @@\n-  bool suspend(bool register_vthread_SR);\n-  bool resume(bool register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-  _jvmci{nullptr},\n+  _jvmci{ nullptr },\n@@ -501,0 +501,1 @@\n+  _handshake_suspender(this, &_handshake._lock),\n@@ -1203,1 +1204,1 @@\n-  return this->handshake_state()->suspend(register_vthread_SR);\n+  return this->handshake_suspender()->suspend(register_vthread_SR);\n@@ -1209,1 +1210,1 @@\n-  return this->handshake_state()->resume(register_vthread_SR);\n+  return this->handshake_suspender()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+  HandshakeSuspender _handshake_suspender;\n@@ -688,0 +689,1 @@\n+  HandshakeSuspender* handshake_suspender() { return &_handshake_suspender; }\n@@ -699,1 +701,1 @@\n-  bool is_suspended()     { return _handshake.is_suspended(); }\n+  bool is_suspended()     { return _handshake_suspender.is_suspended(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    self->handshake_state()->handle_unsafe_access_error();\n+    self->handshake_state()->handle_unsafe_access_error(self->handshake_suspender());\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}