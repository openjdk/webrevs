{"files":[{"patch":"@@ -468,3 +468,1 @@\n-  _async_exceptions_blocked(false),\n-  _suspended(false),\n-  _async_suspend_handshake(false) {\n+  _async_exceptions_blocked(false) {\n@@ -713,1 +711,1 @@\n-    HandshakeSuspender::do_self_suspend(current->handshake_state());\n+    current->handshake_suspender()->do_self_suspend();\n@@ -715,1 +713,1 @@\n-    HandshakeSuspender::set_async_suspend_handshake(current->handshake_state(), false);\n+    current->handshake_suspender()->set_async_suspend_handshake(false);\n@@ -729,1 +727,1 @@\n-    _did_suspend = HandshakeSuspender::suspend_with_handshake(target->handshake_state(), _register_vthread_SR);\n+    _did_suspend = target->handshake_suspender()->suspend_with_handshake(_register_vthread_SR);\n@@ -734,1 +732,1 @@\n-void HandshakeState::set_suspended(bool is_suspend, bool register_vthread_SR) {\n+void HandshakeSuspender::set_suspended(bool is_suspend, bool register_vthread_SR) {\n@@ -748,2 +746,2 @@\n-void HandshakeState::handle_unsafe_access_error() {\n-  if (is_suspended()) {\n+void HandshakeState::handle_unsafe_access_error(HandshakeSuspender* suspender) {\n+  if (suspender->is_suspended()) {\n@@ -774,2 +772,2 @@\n-bool HandshakeSuspender::suspend(HandshakeState *state, bool register_vthread_SR) {\n-  JVMTI_ONLY(assert(!get_handshakee(state)->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n+bool HandshakeSuspender::suspend(bool register_vthread_SR) {\n+  JVMTI_ONLY(assert(!_handshakee->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n@@ -777,1 +775,1 @@\n-  if (get_handshakee(state) == self) {\n+  if (_handshakee == self) {\n@@ -781,3 +779,3 @@\n-    MutexLocker ml(get_lock_ptr(state), Mutex::_no_safepoint_check_flag);\n-    set_suspended(state, true, register_vthread_SR);\n-    do_self_suspend(state);\n+    MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+    set_suspended(true, register_vthread_SR);\n+    do_self_suspend();\n@@ -787,1 +785,1 @@\n-    Handshake::execute(&st, get_handshakee(state));\n+    Handshake::execute(&st, _handshakee);\n@@ -792,4 +790,4 @@\n-bool HandshakeSuspender::resume(HandshakeState* state, bool register_vthread_SR) {\n-  MutexLocker ml(get_lock_ptr(state), Mutex::_no_safepoint_check_flag);\n-  if (!is_suspended(state)) {\n-    assert(!get_handshakee(state)->is_suspended(), \"cannot be suspended without a suspend request\");\n+bool HandshakeSuspender::resume(bool register_vthread_SR) {\n+  MutexLocker ml(_state_lock, Mutex::_no_safepoint_check_flag);\n+  if (!is_suspended()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n@@ -799,2 +797,2 @@\n-  set_suspended(state, false, register_vthread_SR);\n-  get_lock_ptr(state)->notify();\n+  set_suspended(false, register_vthread_SR);\n+  _state_lock->notify();\n@@ -804,5 +802,5 @@\n-void HandshakeSuspender::do_self_suspend(HandshakeState* state) {\n-  assert(Thread::current() == get_handshakee(state), \"should call from _handshakee\");\n-  assert(get_lock_ptr(state)->owned_by_self(), \"Lock must be held\");\n-  assert(!get_handshakee(state)->has_last_Java_frame() || get_handshakee(state)->frame_anchor()->walkable(), \"should have walkable stack\");\n-  assert(get_handshakee(state)->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n+void HandshakeSuspender::do_self_suspend() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_state_lock->owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(_handshakee->thread_state() == _thread_blocked, \"Caller should have transitioned to _thread_blocked\");\n@@ -810,3 +808,3 @@\n-  while (is_suspended(state)) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(get_handshakee(state)));\n-    get_lock_ptr(state)->wait_without_safepoint_check();\n+  while (is_suspended()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _state_lock->wait_without_safepoint_check();\n@@ -814,1 +812,1 @@\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(get_handshakee(state)));\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n@@ -817,4 +815,4 @@\n-bool HandshakeSuspender::suspend_with_handshake(HandshakeState* state, bool register_vthread_SR) {\n-  assert(get_handshakee(state)->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n-  if (get_handshakee(state)->is_exiting()) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(get_handshakee(state)));\n+bool HandshakeSuspender::suspend_with_handshake(bool register_vthread_SR) {\n+  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a null threadObj\");\n+  if (_handshakee->is_exiting()) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(_handshakee));\n@@ -823,2 +821,2 @@\n-  if (has_async_suspend_handshake(state)) {\n-    if (is_suspended(state)) {\n+  if (has_async_suspend_handshake()) {\n+    if (is_suspended()) {\n@@ -826,1 +824,1 @@\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(get_handshakee(state)));\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n@@ -831,2 +829,2 @@\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(get_handshakee(state)));\n-      set_suspended(state, true, register_vthread_SR);\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(_handshakee));\n+      set_suspended(true, register_vthread_SR);\n@@ -837,1 +835,1 @@\n-  assert(!is_suspended(state), \"cannot be suspended without a suspend request\");\n+  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n@@ -840,3 +838,3 @@\n-  set_suspended(state, true, register_vthread_SR);\n-  set_async_suspend_handshake(state, true);\n-  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(get_handshakee(state)));\n+  set_suspended(true, register_vthread_SR);\n+  set_async_suspend_handshake(true);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(_handshakee));\n@@ -844,1 +842,1 @@\n-  Handshake::execute(ts, get_handshakee(state));\n+  Handshake::execute(ts, _handshakee);\n@@ -847,0 +845,2 @@\n+\n+HandshakeSuspender::HandshakeSuspender(JavaThread* thread, Monitor* state_lock) : _handshakee(thread), _state_lock(state_lock), _suspended(false), _async_suspend_handshake(false) {}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,18 +164,1 @@\n-  void handle_unsafe_access_error();\n-\n-  \/\/ Suspend\/resume support\n- private:\n-  \/\/ This flag is true when the thread owning this\n-  \/\/ HandshakeState (the _handshakee) is suspended.\n-  volatile bool _suspended;\n-  \/\/ This flag is true while there is async handshake (trap)\n-  \/\/ on queue. Since we do only need one, we can reuse it if\n-  \/\/ thread gets suspended again (after a resume)\n-  \/\/ and we have not yet processed it.\n-  bool _async_suspend_handshake;\n-\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n-  void set_suspended(bool to, bool register_vthread_SR);\n-\n-  bool has_async_suspend_handshake()        { return _async_suspend_handshake; }\n-  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n+  void handle_unsafe_access_error(HandshakeSuspender* suspender);\n@@ -188,0 +171,7 @@\n+  friend HandshakeState;\n+\n+  JavaThread* _handshakee;\n+  Monitor* _state_lock;\n+\n+public:\n+  HandshakeSuspender(JavaThread* thread, Monitor* state_lock);\n@@ -190,0 +180,8 @@\n+  \/\/ This flag is true when the thread owning this\n+  \/\/ HandshakeSuspender (the _handshakee) is suspended.\n+  volatile bool _suspended;\n+  \/\/ This flag is true while there is async handshake (trap)\n+  \/\/ on queue. Since we do only need one, we can reuse it if\n+  \/\/ thread gets suspended again (after a resume)\n+  \/\/ and we have not yet processed it.\n+  bool _async_suspend_handshake;\n@@ -191,2 +189,2 @@\n-  static bool suspend(HandshakeState* state, bool register_vthread_SR);\n-  static bool resume(HandshakeState* state, bool register_vthread_SR);\n+  bool suspend(bool register_vthread_SR);\n+  bool resume(bool register_vthread_SR);\n@@ -196,1 +194,1 @@\n-  static void do_self_suspend(HandshakeState* state);\n+  void do_self_suspend();\n@@ -199,5 +197,1 @@\n-  static bool suspend_with_handshake(HandshakeState* state, bool register_vthread_SR);\n-\n-  static JavaThread* get_handshakee(HandshakeState* state) {\n-    return state->_handshakee;\n-  }\n+  bool suspend_with_handshake(bool register_vthread_SR);\n@@ -205,11 +199,1 @@\n-  static void set_suspended(HandshakeState* state, bool to, bool register_vthread_SR) {\n-    state->set_suspended(to, register_vthread_SR);\n-  }\n-\n-  static bool is_suspended(HandshakeState* state) {\n-    return state->is_suspended();\n-  }\n-\n-  static Monitor* get_lock_ptr(HandshakeState* state) {\n-    return &state->_lock;\n-  }\n+  void set_suspended(bool to, bool register_vthread_SR);\n@@ -217,2 +201,2 @@\n-  static bool has_async_suspend_handshake(HandshakeState* state) {\n-    return state->has_async_suspend_handshake();\n+  bool is_suspended() {\n+    return Atomic::load(&_suspended);\n@@ -221,3 +205,2 @@\n-  static void set_async_suspend_handshake(HandshakeState* state, bool to) {\n-    state->set_async_suspend_handshake(to);\n-  }\n+  bool has_async_suspend_handshake() { return _async_suspend_handshake; }\n+  void set_async_suspend_handshake(bool to) { _async_suspend_handshake = to; }\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":26,"deletions":43,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-  _jvmci{nullptr},\n+  _jvmci{ nullptr },\n@@ -501,0 +501,1 @@\n+  _handshake_suspender(this, &_handshake._lock),\n@@ -1203,1 +1204,1 @@\n-  return HandshakeSuspender::suspend(this->handshake_state(), register_vthread_SR);\n+  return this->handshake_suspender()->suspend(register_vthread_SR);\n@@ -1209,1 +1210,1 @@\n-  return HandshakeSuspender::resume(this->handshake_state(), register_vthread_SR);\n+  return this->handshake_suspender()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+  HandshakeSuspender _handshake_suspender;\n@@ -688,0 +689,1 @@\n+  HandshakeSuspender* handshake_suspender() { return &_handshake_suspender; }\n@@ -699,1 +701,1 @@\n-  bool is_suspended()     { return _handshake.is_suspended(); }\n+  bool is_suspended()     { return _handshake_suspender.is_suspended(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    self->handshake_state()->handle_unsafe_access_error();\n+    self->handshake_state()->handle_unsafe_access_error(self->handshake_suspender());\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}