{"files":[{"patch":"@@ -4544,0 +4544,1 @@\n+            !BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5702,0 +5702,7 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+      Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+      ldr(reg, curr_ct_holder_addr);\n+    return ;\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -62,0 +58,10 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+      Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+      __ ldr(tmp, curr_ct_holder_addr);\n+  } else {\n+#endif\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+  CardTable* ct = ctbs->card_table();\n+\n@@ -64,0 +70,3 @@\n+#if INCLUDE_SHENANDOAHGC\n+  }\n+#endif\n@@ -101,1 +110,5 @@\n-\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+     ldr(card_table_base, Address(Rthread, JavaThread::card_table_offset()));\n+  } else {\n+#endif\n@@ -104,16 +117,0 @@\n-\n-  \/\/ Load card table base address.\n-\n-  \/* Performance note.\n-\n-     There is an alternative way of loading card table base address\n-     from thread descriptor, which may look more efficient:\n-\n-     ldr(card_table_base, Address(Rthread, JavaThread::card_table_base_offset()));\n-\n-     However, performance measurements of micro benchmarks and specJVM98\n-     showed that loading of card table base from thread descriptor is\n-     7-18% slower compared to loading of literal embedded into the code.\n-     Possible cause is a cache miss (card table base address resides in a\n-     rarely accessed area of thread descriptor).\n-  *\/\n@@ -121,0 +118,3 @@\n+#if INCLUDE_SHENANDOAHGC\n+  }\n+#endif\n@@ -149,0 +149,6 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    __ mov(tmp, 0);\n+    __ strb(tmp, card_table_addr);\n+  } else {\n+#endif\n@@ -160,0 +166,3 @@\n+#if INCLUDE_SHENANDOAHGC\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.cpp","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -591,3 +591,0 @@\n-\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n@@ -602,1 +599,2 @@\n-  __ load_const_optimized(tmp, (address)ct->byte_map_base(), R0);\n+  __ ld(tmp, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread);\n+  __ add(tmp, \/* card_table_base *\/ tmp, R0);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4538,0 +4538,7 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+      Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+      ld(reg, curr_ct_holder_addr);\n+    return ;\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2919,0 +2919,1 @@\n+            !BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  SHENANDOAHGC_ONLY(assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");)\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -618,4 +618,0 @@\n-\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -624,1 +620,4 @@\n-  Address card_addr;\n+  \/\/ We'll use this register as the TLS base address and also later on\n+  \/\/ to hold the byte_map_base.\n+  Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+  Register tmp = LP64_ONLY(rscratch1) NOT_LP64(rdx);\n@@ -626,16 +625,8 @@\n-  \/\/ The calculation for byte_map_base is as follows:\n-  \/\/ byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);\n-  \/\/ So this essentially converts an address to a displacement and it will\n-  \/\/ never need to be relocated. On 64-bit however the value may be too\n-  \/\/ large for a 32-bit displacement.\n-  intptr_t byte_map_base = (intptr_t)ct->byte_map_base();\n-  if (__ is_simm32(byte_map_base)) {\n-    card_addr = Address(noreg, obj, Address::times_1, byte_map_base);\n-  } else {\n-    \/\/ By doing it as an ExternalAddress 'byte_map_base' could be converted to a rip-relative\n-    \/\/ displacement and done in a single instruction given favorable mapping and a\n-    \/\/ smarter version of as_Address. However, 'ExternalAddress' generates a relocation\n-    \/\/ entry and that entry is not properly handled by the relocation code.\n-    AddressLiteral cardtable((address)byte_map_base, relocInfo::none);\n-    Address index(noreg, obj, Address::times_1);\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+#ifndef _LP64\n+  \/\/ The next two ifs are just to get temporary registers to use for TLS and card table base.\n+  if (thread == obj) {\n+    thread = rdx;\n+    tmp = rsi;\n+  }\n+  if (tmp == obj) {\n+    tmp = rsi;\n@@ -644,0 +635,9 @@\n+  __ push(thread);\n+  __ push(tmp);\n+  __ get_thread(thread);\n+#endif\n+\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+  Address card_addr(tmp, obj, Address::times_1);\n+\n@@ -654,0 +654,5 @@\n+\n+#ifndef _LP64\n+  __ pop(tmp1);\n+  __ pop(thread);\n+#endif\n@@ -909,4 +914,0 @@\n-  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = bs->card_table();\n-  intptr_t disp = (intptr_t) ct->byte_map_base();\n-\n@@ -922,0 +923,4 @@\n+  const Register thread = r15_thread;\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+\n@@ -928,1 +933,0 @@\n-  __ mov64(tmp, disp);\n@@ -936,0 +940,6 @@\n+  const Register thread = tmp;\n+  __ get_thread(thread);\n+\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::byte_map_base_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+\n@@ -941,0 +951,2 @@\n+  __ addptr(addr, tmp);\n+\n@@ -942,1 +954,1 @@\n-  Address cardtable(addr, count, Address::times_1, disp);\n+  Address cardtable(addr, count, Address::times_1, 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -44,0 +44,6 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    _card_table_base = nullptr;\n+    return ;\n+  }\n+#endif\n@@ -45,1 +51,0 @@\n-\n@@ -51,1 +56,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/javaThread_linux_arm.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -49,0 +50,1 @@\n+  SHENANDOAHGC_ONLY(assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");)\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+  SHENANDOAHGC_ONLY(assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");)\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,2 +121,3 @@\n-    CardValue* result = &_byte_map_base[uintptr_t(p) >> _card_shift];\n-    assert(result >= _byte_map && result < _byte_map + _byte_map_size,\n+    CardValue* local_byte_map_base = byte_map_base();\n+    CardValue* result = &local_byte_map_base[uintptr_t(p) >> _card_shift];\n+    assert(result >= byte_map() && result < (byte_map() + _byte_map_size),\n@@ -144,1 +145,1 @@\n-    assert(p >= _byte_map && p < _byte_map + _byte_map_size,\n+    assert(p >= byte_map() && p < byte_map() + _byte_map_size,\n@@ -147,1 +148,1 @@\n-           p2i(p), p2i(_byte_map), p2i(_byte_map + _byte_map_size));\n+           p2i(p), p2i(byte_map()), p2i(byte_map() + _byte_map_size));\n@@ -150,1 +151,1 @@\n-    size_t delta = p - _byte_map_base;\n+    size_t delta = p - byte_map_base();\n@@ -154,1 +155,1 @@\n-           \" card marking array's _whole_heap = [\" PTR_FORMAT \",\" PTR_FORMAT \")\",\n+           \"card marking array's _whole_heap = [\" PTR_FORMAT \",\" PTR_FORMAT \").\",\n@@ -165,1 +166,1 @@\n-    return byte_for(p) - _byte_map;\n+    return byte_for(p) - byte_map();\n@@ -169,1 +170,1 @@\n-    return _byte_map + card_index;\n+    return byte_map() + card_index;\n@@ -202,1 +203,3 @@\n-  CardValue* byte_map_base() const { return _byte_map_base; }\n+  virtual CardValue* byte_map_base() const { return _byte_map_base; }\n+\n+  virtual CardValue* byte_map() const { return _byte_map; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -313,4 +313,6 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-  LIR_Const* card_table_base = new LIR_Const(ct->byte_map_base());\n+  LIR_Opr thrd = gen->getThreadPointer();\n+  const int curr_ct_holder_offset = in_bytes(ShenandoahThreadLocalData::card_table_offset());\n+  LIR_Address* curr_ct_holder_addr = new LIR_Address(thrd, curr_ct_holder_offset, T_ADDRESS);\n+  LIR_Opr curr_ct_holder_ptr_reg = gen->new_register(T_ADDRESS);\n+  __ move(curr_ct_holder_addr, curr_ct_holder_ptr_reg);\n+\n@@ -340,7 +342,1 @@\n-  LIR_Address* card_addr;\n-  if (gen->can_inline_as_constant(card_table_base)) {\n-    card_addr = new LIR_Address(tmp, card_table_base->as_jint(), T_BYTE);\n-  } else {\n-    card_addr = new LIR_Address(tmp, gen->load_constant(card_table_base), T_BYTE);\n-  }\n-\n+  LIR_Address* card_addr = new LIR_Address(curr_ct_holder_ptr_reg, tmp, T_BYTE);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -437,11 +437,0 @@\n-Node* ShenandoahBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n-  CardTable::CardValue* card_table_base = ctbs->card_table()->byte_map_base();\n-  if (card_table_base != nullptr) {\n-    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n-  } else {\n-    return kit->null();\n-  }\n-}\n-\n@@ -491,0 +480,2 @@\n+  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n+\n@@ -494,0 +485,4 @@\n+  Node* curr_ct_holder_offset = __ ConX(in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  Node* curr_ct_holder_addr  = __ AddP(__ top(), tls, curr_ct_holder_offset);\n+  Node* curr_ct_base_addr = __ load( __ ctrl(), curr_ct_holder_addr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n+\n@@ -498,1 +493,1 @@\n-  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset );\n+  Node* card_adr = __ AddP(__ top(), curr_ct_base_addr, card_offset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-  Node* byte_map_base_node(GraphKit* kit) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+\n+  if (ShenandoahCardBarrier) {\n+    \/\/ Every thread always have a pointer to the _current_ _write_ version of the card table.\n+    \/\/ The JIT'ed code will use this address (+card entry offset) to marke card's as dirty.\n+    ShenandoahThreadLocalData::set_card_table(thread, _card_table->write_byte_map_base());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n@@ -57,2 +58,0 @@\n-  assert(byte_for(low_bound) == &_byte_map[0], \"Checking start of map\");\n-  assert(byte_for(high_bound-1) <= &_byte_map[last_valid_index()], \"Checking end of map\");\n@@ -68,2 +67,0 @@\n-  assert(read_byte_for(low_bound) == &_read_byte_map[0], \"Checking start of map\");\n-  assert(read_byte_for(high_bound-1) <= &_read_byte_map[last_valid_index()], \"Checking end of map\");\n@@ -108,0 +105,4 @@\n+\n+CardValue* ShenandoahCardTable::byte_map_base() const {\n+  return ShenandoahThreadLocalData::card_table(Thread::current());\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,12 @@\n+  CardValue* byte_map_base() const override;\n+\n+  CardValue* swap_read_and_write_tables() {\n+    swap(_read_byte_map, _write_byte_map);\n+    swap(_read_byte_map_base, _write_byte_map_base);\n+\n+    _byte_map = _write_byte_map;\n+    _byte_map_base = _write_byte_map_base;\n+\n+    return _byte_map_base;\n+  }\n+\n@@ -75,0 +87,4 @@\n+  CardValue* read_byte_map_base() {\n+    return _read_byte_map_base;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -378,0 +378,4 @@\n+\n+  if (heap->mode()->is_generational()) {\n+    heap->old_generation()->card_scan()->mark_read_table_as_clean();\n+  }\n@@ -632,1 +636,0 @@\n-\n@@ -635,1 +638,0 @@\n-      \/\/ The current implementation of swap_remembered_set() copies the write-card-table to the read-card-table.\n@@ -637,1 +639,1 @@\n-      _generation->swap_remembered_set();\n+      _generation->swap_card_tables();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  \/\/ and workers for net VM operation\n+  \/\/ and workers for next VM operation\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        _generation->swap_remembered_set();\n+        _generation->swap_card_tables();\n@@ -169,1 +169,1 @@\n-          \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n+          \/\/ and this degenerated cycle. These pointers need to be included in the 'read' table\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,14 +110,0 @@\n-class ShenandoahCopyWriteCardTableToRead: public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahScanRemembered* _scanner;\n-public:\n-  ShenandoahCopyWriteCardTableToRead(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* region) override {\n-    assert(region->is_old(), \"Don't waste time doing this for non-old regions\");\n-    _scanner->reset_remset(region->bottom(), ShenandoahHeapRegion::region_size_words());\n-  }\n-\n-  bool is_thread_safe() override { return true; }\n-};\n-\n@@ -239,5 +225,5 @@\n-\/\/ The ideal is to swap the remembered set so the safepoint effort is no more than a few pointer manipulations.\n-\/\/ However, limitations in the implementation of the mutator write-barrier make it difficult to simply change the\n-\/\/ location of the card table.  So the interim implementation of swap_remembered_set will copy the write-table\n-\/\/ onto the read-table and will then clear the write-table.\n-void ShenandoahGeneration::swap_remembered_set() {\n+\/\/ Swap the read and write card table pointers prior to the next remset scan.\n+\/\/ This avoids the need to synchronize reads of the table by the GC workers doing\n+\/\/ remset scanning, on the one hand, with the dirtying of the table by mutators\n+\/\/ and by the GC workers doing remset scans, on the other.\n+void ShenandoahGeneration::swap_card_tables() {\n@@ -250,2 +236,1 @@\n-  ShenandoahCopyWriteCardTableToRead task(old_generation->card_scan());\n-  old_generation->parallel_heap_region_iterate(&task);\n+  old_generation->card_scan()->swap_card_tables();\n@@ -269,1 +254,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  void swap_remembered_set();\n+  void swap_card_tables();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,5 @@\n+\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+  scanner->mark_read_table_as_clean();\n+  scanner->swap_card_tables();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -246,1 +246,10 @@\n-  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n+  ShenandoahBarrierSet* bs = new ShenandoahBarrierSet(this, _heap_region);\n+  BarrierSet::set_barrier_set(bs);\n+\n+  \/\/ Every thread always have a pointer to the _current_ _write_ version of the card table.\n+  \/\/ The JIT'ed code will use this address (+card entry offset) to mark card's as dirty.\n+  \/\/\n+  \/\/ Now that ThreadLocalData's are created we can set byte_map_base on it.\n+  if (ShenandoahCardBarrier) {\n+    ShenandoahThreadLocalData::set_card_table(Thread::current(), bs->card_table()->write_byte_map_base());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -74,12 +75,0 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n-void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  while (num_cards-- > 0) {\n-    *bp++ = CardTable::clean_card_val();\n-  }\n-}\n-\n@@ -116,6 +105,0 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord* p) {\n-  size_t index = card_index_for_addr(p);\n-  CardValue* bp = &(_card_table->write_byte_map())[index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n@@ -134,0 +117,12 @@\n+void ShenandoahDirectCardMarkRememberedSet::mark_read_table_as_clean() {\n+  CardValue* read_table = _card_table->read_byte_map();\n+  CardValue* bp = &(read_table)[0];\n+  CardValue* end_bp = &(read_table)[_card_table->last_valid_index()];\n+\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+\n+  log_info(gc, barrier)(\"Cleaned read_table from \" PTR_FORMAT \" to \" PTR_FORMAT, p2i(&(read_table)[0]), p2i(end_bp));\n+}\n+\n@@ -333,2 +328,2 @@\n-void ShenandoahScanRemembered::mark_card_as_clean(HeapWord* p) {\n-  _rs->mark_card_as_clean(p);\n+void ShenandoahScanRemembered::mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n+  _rs->mark_range_as_clean(p, num_heap_words);\n@@ -337,2 +332,2 @@\n-void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n-  _rs->mark_range_as_clean(p, num_heap_words);\n+void ShenandoahScanRemembered::mark_read_table_as_clean() {\n+  _rs->mark_read_table_as_clean();\n@@ -626,0 +621,2 @@\n+\n+  log_info(gc, remset)(\"Finished merging write_table into read_table.\");\n@@ -628,3 +625,3 @@\n-\/\/ Destructively copy the write table to the read table, and clean the write table.\n-void ShenandoahDirectCardMarkRememberedSet::reset_remset(HeapWord* start, size_t word_count) {\n-  size_t start_index = card_index_for_addr(start);\n+void ShenandoahDirectCardMarkRememberedSet::swap_card_tables() {\n+  CardTable::CardValue* new_ptr = _card_table->swap_read_and_write_tables();\n+\n@@ -632,2 +629,7 @@\n-  \/\/ avoid querying card_index_for_addr() for an address past end of heap\n-  size_t end_index = card_index_for_addr(start + word_count - 1) + 1;\n+  CardValue* start_bp = &(_card_table->write_byte_map())[0];\n+  CardValue* end_bp = &(new_ptr)[_card_table->last_valid_index()];\n+\n+  while (start_bp < end_bp) {\n+    assert(*start_bp == CardTable::clean_card_val(), \"Should be clean: \" PTR_FORMAT, p2i(start_bp));\n+    start_bp++;\n+  }\n@@ -635,2 +637,0 @@\n-  assert(start_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n-  assert(end_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n@@ -638,3 +638,9 @@\n-  \/\/ We'll access in groups of intptr_t worth of card entries\n-  intptr_t* const read_table  = (intptr_t*) &(_card_table->read_byte_map())[start_index];\n-  intptr_t* const write_table = (intptr_t*) &(_card_table->write_byte_map())[start_index];\n+  struct SwapTLSCardTable : public ThreadClosure {\n+    CardTable::CardValue* new_ptr;\n+    SwapTLSCardTable(CardTable::CardValue* np) {\n+      this->new_ptr = np;\n+    }\n+    virtual void do_thread(Thread* t) {\n+      ShenandoahThreadLocalData::set_card_table(t, new_ptr);\n+    }\n+  } swap_it(new_ptr);\n@@ -642,3 +648,2 @@\n-  \/\/ Avoid division, use shift instead\n-  assert(word_count % ((size_t)1 << (LogCardSizeInWords + LogCardValsPerIntPtr)) == 0, \"Expected a multiple of CardSizeInWords*CardValsPerIntPtr\");\n-  size_t const num = word_count >> (LogCardSizeInWords + LogCardValsPerIntPtr);\n+  \/\/ Iterate on threads and adjust thread local data\n+  Threads::threads_do(&swap_it);\n@@ -646,4 +651,1 @@\n-  for (size_t i = 0; i < num; i++) {\n-    read_table[i]  = write_table[i];\n-    write_table[i] = CardTable::clean_card_row_val();\n-  }\n+  log_info(gc, barrier)(\"Current write_card_table: \" PTR_FORMAT, p2i(swap_it.new_ptr));\n@@ -942,1 +944,0 @@\n-        \/\/ First, clear the remembered set for all spanned humongous regions\n@@ -944,2 +945,0 @@\n-        size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n-        scanner->reset_remset(r->bottom(), region_span);\n@@ -958,2 +957,0 @@\n-        \/\/ First, clear the remembered set\n-        scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  inline void mark_card_as_clean(HeapWord* p);\n@@ -242,0 +241,3 @@\n+  \/\/ See comment in ShenandoahScanRemembered\n+  inline void mark_read_table_as_clean();\n+\n@@ -246,2 +248,2 @@\n-  \/\/ Destructively copy the write table to the read table, and clean the write table.\n-  void reset_remset(HeapWord* start, size_t word_count);\n+  \/\/ See comment in ShenandoahScanRemembered\n+  void swap_card_tables();\n@@ -758,1 +760,0 @@\n-  void mark_card_as_clean(HeapWord* p);\n@@ -761,1 +762,10 @@\n-  void reset_remset(HeapWord* start, size_t word_count) { _rs->reset_remset(start, word_count); }\n+  \/\/ This method is used to concurrently clean the \"read\" card table -\n+  \/\/ currently, as part of the reset phase. Later on the pointers to the \"read\"\n+  \/\/ and \"write\" card tables are swapped everywhere to enable the GC to\n+  \/\/ concurrently operate on the \"read\" table while mutators effect changes on\n+  \/\/ the \"write\" table.\n+  void mark_read_table_as_clean();\n+\n+  \/\/ Swaps read and write card tables pointers in effect setting a clean card\n+  \/\/ table for the next GC cycle.\n+  void swap_card_tables() { _rs->swap_card_tables(); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  _card_table(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+  \/\/ Current active CardTable's byte_map_base for this thread.\n+  CardTable::CardValue*   _card_table;\n+\n@@ -125,0 +128,11 @@\n+  static void set_card_table(Thread* thread, CardTable::CardValue* ct) {\n+    assert(ct != nullptr, \"trying to set thread local card_table pointer to nullptr.\");\n+    data(thread)->_card_table = ct;\n+  }\n+\n+  static CardTable::CardValue* card_table(Thread* thread) {\n+    CardTable::CardValue* ct = data(thread)->_card_table;\n+    assert(ct != nullptr, \"returning a null thread local card_table pointer.\");\n+    return ct;\n+  }\n+\n@@ -283,0 +297,4 @@\n+\n+  static ByteSize card_table_offset() {\n+    return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _card_table);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1271,1 +1271,1 @@\n-                                         _message, \"clean card should be dirty\", __FILE__, __LINE__);\n+                                         _message, \"clean card, it should be dirty.\", __FILE__, __LINE__);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}