{"files":[{"patch":"@@ -4544,0 +4544,1 @@\n+            !BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -380,1 +380,2 @@\n-  __ load_byte_map_base(rscratch1);\n+  Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ldr(rscratch1, curr_ct_holder_addr);\n@@ -627,1 +628,2 @@\n-  __ load_byte_map_base(scratch);\n+  Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ldr(scratch, curr_ct_holder_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -590,3 +590,0 @@\n-\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n@@ -601,1 +598,1 @@\n-  __ load_const_optimized(tmp, (address)ct->byte_map_base(), R0);\n+  __ ld(tmp, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread); \/* tmp = *[R16_thread + card_table_offset] *\/\n@@ -800,1 +797,2 @@\n-  __ add_const_optimized(addr, addr, (address)ct->byte_map_base(), R0);\n+  __ ld(R0, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread);\n+  __ add(addr, addr, R0);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -399,1 +399,2 @@\n-  __ load_byte_map_base(t1);\n+  Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ld(t1, curr_ct_holder_addr);\n@@ -571,1 +572,2 @@\n-  __ load_byte_map_base(tmp);\n+  Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ld(tmp, curr_ct_holder_addr);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2919,0 +2919,1 @@\n+            !BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  SHENANDOAHGC_ONLY(assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");)\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -617,4 +617,0 @@\n-\n-  ShenandoahBarrierSet* ctbs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -623,1 +619,4 @@\n-  Address card_addr;\n+  \/\/ We'll use this register as the TLS base address and also later on\n+  \/\/ to hold the byte_map_base.\n+  Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+  Register tmp = LP64_ONLY(rscratch1) NOT_LP64(rdx);\n@@ -625,16 +624,8 @@\n-  \/\/ The calculation for byte_map_base is as follows:\n-  \/\/ byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);\n-  \/\/ So this essentially converts an address to a displacement and it will\n-  \/\/ never need to be relocated. On 64-bit however the value may be too\n-  \/\/ large for a 32-bit displacement.\n-  intptr_t byte_map_base = (intptr_t)ct->byte_map_base();\n-  if (__ is_simm32(byte_map_base)) {\n-    card_addr = Address(noreg, obj, Address::times_1, byte_map_base);\n-  } else {\n-    \/\/ By doing it as an ExternalAddress 'byte_map_base' could be converted to a rip-relative\n-    \/\/ displacement and done in a single instruction given favorable mapping and a\n-    \/\/ smarter version of as_Address. However, 'ExternalAddress' generates a relocation\n-    \/\/ entry and that entry is not properly handled by the relocation code.\n-    AddressLiteral cardtable((address)byte_map_base, relocInfo::none);\n-    Address index(noreg, obj, Address::times_1);\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n+#ifndef _LP64\n+  \/\/ The next two ifs are just to get temporary registers to use for TLS and card table base.\n+  if (thread == obj) {\n+    thread = rdx;\n+    tmp = rsi;\n+  }\n+  if (tmp == obj) {\n+    tmp = rsi;\n@@ -643,0 +634,9 @@\n+  __ push(thread);\n+  __ push(tmp);\n+  __ get_thread(thread);\n+#endif\n+\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+  Address card_addr(tmp, obj, Address::times_1);\n+\n@@ -653,0 +653,5 @@\n+\n+#ifndef _LP64\n+  __ pop(tmp);\n+  __ pop(thread);\n+#endif\n@@ -908,4 +913,0 @@\n-  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n-  CardTable* ct = bs->card_table();\n-  intptr_t disp = (intptr_t) ct->byte_map_base();\n-\n@@ -921,0 +922,4 @@\n+  const Register thread = r15_thread;\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+\n@@ -927,1 +932,0 @@\n-  __ mov64(tmp, disp);\n@@ -935,0 +939,6 @@\n+  const Register thread = tmp;\n+  __ get_thread(thread);\n+\n+  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::byte_map_base_offset()));\n+  __ movptr(tmp, curr_ct_holder_addr);\n+\n@@ -940,0 +950,2 @@\n+  __ addptr(addr, tmp);\n+\n@@ -941,1 +953,1 @@\n-  Address cardtable(addr, count, Address::times_1, disp);\n+  Address cardtable(addr, count, Address::times_1, 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+#if INCLUDE_SHENANDOAHGC\n+  if (UseShenandoahGC) {\n+    _card_table_base = nullptr;\n+    return;\n+  }\n+#endif\n@@ -44,1 +50,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/javaThread_linux_arm.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -48,0 +49,1 @@\n+  assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  SHENANDOAHGC_ONLY(assert(!UseShenandoahGC, \"Shenandoah byte_map_base is not constant.\");)\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,4 +312,6 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-  LIR_Const* card_table_base = new LIR_Const(ct->byte_map_base());\n+  LIR_Opr thrd = gen->getThreadPointer();\n+  const int curr_ct_holder_offset = in_bytes(ShenandoahThreadLocalData::card_table_offset());\n+  LIR_Address* curr_ct_holder_addr = new LIR_Address(thrd, curr_ct_holder_offset, T_ADDRESS);\n+  LIR_Opr curr_ct_holder_ptr_reg = gen->new_register(T_ADDRESS);\n+  __ move(curr_ct_holder_addr, curr_ct_holder_ptr_reg);\n+\n@@ -339,7 +341,1 @@\n-  LIR_Address* card_addr;\n-  if (gen->can_inline_as_constant(card_table_base)) {\n-    card_addr = new LIR_Address(tmp, card_table_base->as_jint(), T_BYTE);\n-  } else {\n-    card_addr = new LIR_Address(tmp, gen->load_constant(card_table_base), T_BYTE);\n-  }\n-\n+  LIR_Address* card_addr = new LIR_Address(curr_ct_holder_ptr_reg, tmp, T_BYTE);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -436,11 +436,0 @@\n-Node* ShenandoahBarrierSetC2::byte_map_base_node(GraphKit* kit) const {\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  ShenandoahBarrierSet* ctbs = barrier_set_cast<ShenandoahBarrierSet>(bs);\n-  CardTable::CardValue* card_table_base = ctbs->card_table()->byte_map_base();\n-  if (card_table_base != nullptr) {\n-    return kit->makecon(TypeRawPtr::make((address)card_table_base));\n-  } else {\n-    return kit->null();\n-  }\n-}\n-\n@@ -490,0 +479,2 @@\n+  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n+\n@@ -493,0 +484,4 @@\n+  Node* curr_ct_holder_offset = __ ConX(in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  Node* curr_ct_holder_addr  = __ AddP(__ top(), tls, curr_ct_holder_offset);\n+  Node* curr_ct_base_addr = __ load( __ ctrl(), curr_ct_holder_addr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n+\n@@ -497,1 +492,1 @@\n-  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset );\n+  Node* card_adr = __ AddP(__ top(), curr_ct_base_addr, card_offset);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-  Node* byte_map_base_node(GraphKit* kit) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+  if (ShenandoahCardBarrier) {\n+    \/\/ Every thread always have a pointer to the _current_ _write_ version of the card table.\n+    \/\/ The JIT'ed code will use this address (+card entry offset) to mark the card as dirty.\n+    ShenandoahThreadLocalData::set_card_table(thread, _card_table->write_byte_map_base());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n@@ -56,2 +57,0 @@\n-  assert(byte_for(low_bound) == &_byte_map[0], \"Checking start of map\");\n-  assert(byte_for(high_bound-1) <= &_byte_map[last_valid_index()], \"Checking end of map\");\n@@ -67,2 +66,0 @@\n-  assert(read_byte_for(low_bound) == &_read_byte_map[0], \"Checking start of map\");\n-  assert(read_byte_for(high_bound-1) <= &_read_byte_map[last_valid_index()], \"Checking end of map\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,10 @@\n+  CardValue* swap_read_and_write_tables() {\n+    swap(_read_byte_map, _write_byte_map);\n+    swap(_read_byte_map_base, _write_byte_map_base);\n+\n+    _byte_map = _write_byte_map;\n+    _byte_map_base = _write_byte_map_base;\n+\n+    return _byte_map_base;\n+  }\n+\n@@ -77,0 +87,4 @@\n+  CardValue* read_byte_map_base() {\n+    return _read_byte_map_base;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -377,0 +377,4 @@\n+\n+  if (heap->mode()->is_generational()) {\n+    heap->old_generation()->card_scan()->mark_read_table_as_clean();\n+  }\n@@ -631,1 +635,0 @@\n-\n@@ -634,1 +637,0 @@\n-      \/\/ The current implementation of swap_remembered_set() copies the write-card-table to the read-card-table.\n@@ -636,1 +638,1 @@\n-      _generation->swap_remembered_set();\n+      _generation->swap_card_tables();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  \/\/ and workers for net VM operation\n+  \/\/ and workers for next VM operation\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        _generation->swap_remembered_set();\n+        _generation->swap_card_tables();\n@@ -173,1 +173,1 @@\n-          \/\/ and this degenerated cycle. These pointers need to be included the 'read' table\n+          \/\/ and this degenerated cycle. These pointers need to be included in the 'read' table\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,14 +109,0 @@\n-class ShenandoahCopyWriteCardTableToRead: public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahScanRemembered* _scanner;\n-public:\n-  ShenandoahCopyWriteCardTableToRead(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* region) override {\n-    assert(region->is_old(), \"Don't waste time doing this for non-old regions\");\n-    _scanner->reset_remset(region->bottom(), ShenandoahHeapRegion::region_size_words());\n-  }\n-\n-  bool is_thread_safe() override { return true; }\n-};\n-\n@@ -238,5 +224,5 @@\n-\/\/ The ideal is to swap the remembered set so the safepoint effort is no more than a few pointer manipulations.\n-\/\/ However, limitations in the implementation of the mutator write-barrier make it difficult to simply change the\n-\/\/ location of the card table.  So the interim implementation of swap_remembered_set will copy the write-table\n-\/\/ onto the read-table and will then clear the write-table.\n-void ShenandoahGeneration::swap_remembered_set() {\n+\/\/ Swap the read and write card table pointers prior to the next remset scan.\n+\/\/ This avoids the need to synchronize reads of the table by the GC workers\n+\/\/ doing remset scanning, on the one hand, with the dirtying of the table by\n+\/\/ mutators on the other.\n+void ShenandoahGeneration::swap_card_tables() {\n@@ -249,2 +235,1 @@\n-  ShenandoahCopyWriteCardTableToRead task(old_generation->card_scan());\n-  old_generation->parallel_heap_region_iterate(&task);\n+  old_generation->card_scan()->swap_card_tables();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  void swap_remembered_set();\n+  void swap_card_tables();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,5 @@\n+\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n+  scanner->mark_read_table_as_clean();\n+  scanner->swap_card_tables();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -249,1 +249,10 @@\n-  BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this, _heap_region));\n+  ShenandoahBarrierSet* bs = new ShenandoahBarrierSet(this, _heap_region);\n+  BarrierSet::set_barrier_set(bs);\n+\n+  \/\/ Every thread always have a pointer to the _current_ _write_ version of the card table.\n+  \/\/ The JIT'ed code will use this address (+card entry offset) to mark card's as dirty.\n+  \/\/\n+  \/\/ Now that ThreadLocalData's are created we can set byte_map_base on it.\n+  if (ShenandoahCardBarrier) {\n+    ShenandoahThreadLocalData::set_card_table(Thread::current(), bs->card_table()->write_byte_map_base());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -71,12 +72,0 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n-void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  while (num_cards-- > 0) {\n-    *bp++ = CardTable::clean_card_val();\n-  }\n-}\n-\n@@ -113,6 +102,0 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord* p) {\n-  size_t index = card_index_for_addr(p);\n-  CardValue* bp = &(_card_table->write_byte_map())[index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n@@ -131,0 +114,12 @@\n+void ShenandoahDirectCardMarkRememberedSet::mark_read_table_as_clean() {\n+  CardValue* read_table = _card_table->read_byte_map();\n+  CardValue* bp = &(read_table)[0];\n+  CardValue* end_bp = &(read_table)[_card_table->last_valid_index()];\n+\n+  while (bp <= end_bp) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+\n+  log_info(gc, barrier)(\"Cleaned read_table from \" PTR_FORMAT \" to \" PTR_FORMAT, p2i(&(read_table)[0]), p2i(end_bp));\n+}\n+\n@@ -330,2 +325,2 @@\n-void ShenandoahScanRemembered::mark_card_as_clean(HeapWord* p) {\n-  _rs->mark_card_as_clean(p);\n+void ShenandoahScanRemembered::mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n+  _rs->mark_range_as_clean(p, num_heap_words);\n@@ -334,2 +329,2 @@\n-void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n-  _rs->mark_range_as_clean(p, num_heap_words);\n+void ShenandoahScanRemembered::mark_read_table_as_clean() {\n+  _rs->mark_read_table_as_clean();\n@@ -623,0 +618,2 @@\n+\n+  log_info(gc, remset)(\"Finished merging write_table into read_table.\");\n@@ -625,3 +622,3 @@\n-\/\/ Destructively copy the write table to the read table, and clean the write table.\n-void ShenandoahDirectCardMarkRememberedSet::reset_remset(HeapWord* start, size_t word_count) {\n-  size_t start_index = card_index_for_addr(start);\n+void ShenandoahDirectCardMarkRememberedSet::swap_card_tables() {\n+  CardTable::CardValue* new_ptr = _card_table->swap_read_and_write_tables();\n+\n@@ -629,2 +626,7 @@\n-  \/\/ avoid querying card_index_for_addr() for an address past end of heap\n-  size_t end_index = card_index_for_addr(start + word_count - 1) + 1;\n+  CardValue* start_bp = &(_card_table->write_byte_map())[0];\n+  CardValue* end_bp = &(new_ptr)[_card_table->last_valid_index()];\n+\n+  while (start_bp <= end_bp) {\n+    assert(*start_bp == CardTable::clean_card_val(), \"Should be clean: \" PTR_FORMAT, p2i(start_bp));\n+    start_bp++;\n+  }\n@@ -632,2 +634,0 @@\n-  assert(start_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n-  assert(end_index % ((size_t)1 << LogCardValsPerIntPtr) == 0, \"Expected a multiple of CardValsPerIntPtr\");\n@@ -635,3 +635,9 @@\n-  \/\/ We'll access in groups of intptr_t worth of card entries\n-  intptr_t* const read_table  = (intptr_t*) &(_card_table->read_byte_map())[start_index];\n-  intptr_t* const write_table = (intptr_t*) &(_card_table->write_byte_map())[start_index];\n+  struct SwapTLSCardTable : public ThreadClosure {\n+    CardTable::CardValue* new_ptr;\n+    SwapTLSCardTable(CardTable::CardValue* np) {\n+      this->new_ptr = np;\n+    }\n+    virtual void do_thread(Thread* t) {\n+      ShenandoahThreadLocalData::set_card_table(t, new_ptr);\n+    }\n+  } swap_it(new_ptr);\n@@ -639,3 +645,2 @@\n-  \/\/ Avoid division, use shift instead\n-  assert(word_count % ((size_t)1 << (LogCardSizeInWords + LogCardValsPerIntPtr)) == 0, \"Expected a multiple of CardSizeInWords*CardValsPerIntPtr\");\n-  size_t const num = word_count >> (LogCardSizeInWords + LogCardValsPerIntPtr);\n+  \/\/ Iterate on threads and adjust thread local data\n+  Threads::threads_do(&swap_it);\n@@ -643,4 +648,1 @@\n-  for (size_t i = 0; i < num; i++) {\n-    read_table[i]  = write_table[i];\n-    write_table[i] = CardTable::clean_card_row_val();\n-  }\n+  log_info(gc, barrier)(\"Current write_card_table: \" PTR_FORMAT, p2i(swap_it.new_ptr));\n@@ -950,1 +952,0 @@\n-        \/\/ First, clear the remembered set for all spanned humongous regions\n@@ -952,2 +953,0 @@\n-        size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n-        scanner->reset_remset(r->bottom(), region_span);\n@@ -966,2 +965,0 @@\n-        \/\/ First, clear the remembered set\n-        scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -242,1 +242,0 @@\n-  inline void mark_card_as_clean(HeapWord* p);\n@@ -245,0 +244,3 @@\n+  \/\/ See comment in ShenandoahScanRemembered\n+  inline void mark_read_table_as_clean();\n+\n@@ -249,2 +251,2 @@\n-  \/\/ Destructively copy the write table to the read table, and clean the write table.\n-  void reset_remset(HeapWord* start, size_t word_count);\n+  \/\/ See comment in ShenandoahScanRemembered\n+  void swap_card_tables();\n@@ -405,1 +407,1 @@\n-    _object_starts = NEW_C_HEAP_ARRAY(crossing_info, rs->total_cards(), mtGC);\n+    _object_starts = NEW_C_HEAP_ARRAY(crossing_info, rs->total_cards()+1, mtGC);\n@@ -761,1 +763,0 @@\n-  void mark_card_as_clean(HeapWord* p);\n@@ -764,1 +765,10 @@\n-  void reset_remset(HeapWord* start, size_t word_count) { _rs->reset_remset(start, word_count); }\n+  \/\/ This method is used to concurrently clean the \"read\" card table -\n+  \/\/ currently, as part of the reset phase. Later on the pointers to the \"read\"\n+  \/\/ and \"write\" card tables are swapped everywhere to enable the GC to\n+  \/\/ concurrently operate on the \"read\" table while mutators effect changes on\n+  \/\/ the \"write\" table.\n+  void mark_read_table_as_clean();\n+\n+  \/\/ Swaps read and write card tables pointers in effect setting a clean card\n+  \/\/ table for the next GC cycle.\n+  void swap_card_tables() { _rs->swap_card_tables(); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  _card_table(nullptr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+  \/\/ Current active CardTable's byte_map_base for this thread.\n+  CardTable::CardValue*   _card_table;\n+\n@@ -125,0 +128,11 @@\n+  static void set_card_table(Thread* thread, CardTable::CardValue* ct) {\n+    assert(ct != nullptr, \"trying to set thread local card_table pointer to nullptr.\");\n+    data(thread)->_card_table = ct;\n+  }\n+\n+  static CardTable::CardValue* card_table(Thread* thread) {\n+    CardTable::CardValue* ct = data(thread)->_card_table;\n+    assert(ct != nullptr, \"returning a null thread local card_table pointer.\");\n+    return ct;\n+  }\n+\n@@ -283,0 +297,4 @@\n+\n+  static ByteSize card_table_offset() {\n+    return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _card_table);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1270,1 +1270,1 @@\n-                                         _message, \"clean card should be dirty\", __FILE__, __LINE__);\n+                                         _message, \"clean card, it should be dirty.\", __FILE__, __LINE__);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}