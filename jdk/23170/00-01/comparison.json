{"files":[{"patch":"@@ -381,1 +381,2 @@\n-  __ load_byte_map_base(rscratch1);\n+  Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ldr(rscratch1, curr_ct_holder_addr);\n@@ -628,1 +629,2 @@\n-  __ load_byte_map_base(scratch);\n+  Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ldr(scratch, curr_ct_holder_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5702,7 +5702,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-      Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n-      ldr(reg, curr_ct_holder_addr);\n-    return ;\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n+  CardTable* ct = ctbs->card_table();\n+\n@@ -58,10 +62,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-      Address curr_ct_holder_addr(rthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n-      __ ldr(tmp, curr_ct_holder_addr);\n-  } else {\n-#endif\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -70,3 +64,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  }\n-#endif\n@@ -110,5 +101,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-     ldr(card_table_base, Address(Rthread, JavaThread::card_table_offset()));\n-  } else {\n-#endif\n@@ -117,0 +103,16 @@\n+\n+  \/\/ Load card table base address.\n+\n+  \/* Performance note.\n+\n+     There is an alternative way of loading card table base address\n+     from thread descriptor, which may look more efficient:\n+\n+     ldr(card_table_base, Address(Rthread, JavaThread::card_table_base_offset()));\n+\n+     However, performance measurements of micro benchmarks and specJVM98\n+     showed that loading of card table base from thread descriptor is\n+     7-18% slower compared to loading of literal embedded into the code.\n+     Possible cause is a cache miss (card table base address resides in a\n+     rarely accessed area of thread descriptor).\n+  *\/\n@@ -118,3 +120,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  }\n-#endif\n@@ -149,6 +148,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-    __ mov(tmp, 0);\n-    __ strb(tmp, card_table_addr);\n-  } else {\n-#endif\n@@ -166,3 +159,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.cpp","additions":20,"deletions":30,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -599,2 +599,1 @@\n-  __ ld(tmp, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread);\n-  __ add(tmp, \/* card_table_base *\/ tmp, R0);\n+  __ ld(tmp, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread); \/* tmp = *[R16_thread + card_table_offset] *\/\n@@ -799,1 +798,2 @@\n-  __ add_const_optimized(addr, addr, (address)ct->byte_map_base(), R0);\n+  __ ld(R0, in_bytes(ShenandoahThreadLocalData::card_table_offset()), R16_thread);\n+  __ add(addr, addr, R0);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -400,1 +400,2 @@\n-  __ load_byte_map_base(t1);\n+  Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ld(t1, curr_ct_holder_addr);\n@@ -572,1 +573,2 @@\n-  __ load_byte_map_base(tmp);\n+  Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n+  __ ld(tmp, curr_ct_holder_addr);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4538,7 +4538,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-  if (UseShenandoahGC) {\n-      Address curr_ct_holder_addr(xthread, in_bytes(ShenandoahThreadLocalData::card_table_offset()));\n-      ld(reg, curr_ct_holder_addr);\n-    return ;\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    \/\/ The JIT'ed code will use this address (+card entry offset) to marke card's as dirty.\n+    \/\/ The JIT'ed code will use this address (+card entry offset) to mark the card as dirty.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,3 +226,3 @@\n-\/\/ This avoids the need to synchronize reads of the table by the GC workers doing\n-\/\/ remset scanning, on the one hand, with the dirtying of the table by mutators\n-\/\/ and by the GC workers doing remset scans, on the other.\n+\/\/ This avoids the need to synchronize reads of the table by the GC workers\n+\/\/ doing remset scanning, on the one hand, with the dirtying of the table by\n+\/\/ mutators on the other.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  while (bp < end_bp) {\n+  while (bp <= end_bp) {\n@@ -632,1 +632,1 @@\n-  while (start_bp < end_bp) {\n+  while (start_bp <= end_bp) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}