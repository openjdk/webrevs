{"files":[{"patch":"@@ -241,1 +241,0 @@\n-    const __m256i oxff = _mm256_set1_epi32(0xFFFFFFFF);\n@@ -249,2 +248,0 @@\n-    const __m256i &left = _mm256_loadu_si256(\n-        (const __m256i *)avx2_compressstore_lut32_left[shortMask].data());\n@@ -254,2 +251,2 @@\n-    vtype::mask_storeu(leftStore, left, temp);\n-    vtype::mask_storeu(rightStore, _mm256_xor_si256(oxff, left), temp);\n+    vtype::storeu(leftStore, temp);\n+    vtype::storeu(rightStore, temp);\n@@ -265,1 +262,0 @@\n-    const __m256i oxff = _mm256_set1_epi32(0xFFFFFFFF);\n@@ -273,2 +269,0 @@\n-    const __m256i &left = _mm256_loadu_si256(\n-        (const __m256i *)avx2_compressstore_lut64_left[shortMask].data());\n@@ -279,2 +273,2 @@\n-    vtype::mask_storeu(leftStore, left, temp);\n-    vtype::mask_storeu(rightStore, _mm256_xor_si256(oxff, left), temp);\n+    vtype::storeu(leftStore, temp);\n+    vtype::storeu(rightStore, temp);\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-emu-funcs.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,342 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n-\n-#ifndef AVX512_64BIT_COMMON\n-#define AVX512_64BIT_COMMON\n-\n-#include \"xss-common-includes.h\"\n-\n-\/*\n- * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n- * sorting network (see\n- * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n- *\/\n-\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n-#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n-#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n-#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n-#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n-\n-template <typename vtype, typename reg_t>\n-X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm);\n-\n-struct avx512_64bit_swizzle_ops;\n-\n-template <>\n-struct zmm_vector<int64_t> {\n-    using type_t = int64_t;\n-    using reg_t = __m512i;\n-    using regi_t = __m512i;\n-    using halfreg_t = __m512i;\n-    using opmask_t = __mmask8;\n-    static const uint8_t numlanes = 8;\n-#ifdef XSS_MINIMAL_NETWORK_SORT\n-    static constexpr int network_sort_threshold = numlanes;\n-#else\n-    static constexpr int network_sort_threshold = 256;\n-#endif\n-    static constexpr int partition_unroll_factor = 8;\n-\n-    using swizzle_ops = avx512_64bit_swizzle_ops;\n-\n-    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n-    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n-    static reg_t zmm_max() {\n-        return _mm512_set1_epi64(type_max());\n-    }  \/\/ TODO: this should broadcast bits as is?\n-\n-    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n-                       int v8) {\n-        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n-                     type_t v6, type_t v7, type_t v8) {\n-        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n-        return _kxor_mask8(x, y);\n-    }\n-    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n-    static opmask_t le(reg_t x, reg_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n-    }\n-    static opmask_t ge(reg_t x, reg_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n-    }\n-    static opmask_t gt(reg_t x, reg_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n-    }\n-    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n-        return ((0x1ull << num_to_read) - 0x1ull);\n-    }\n-    static opmask_t eq(reg_t x, reg_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n-    }\n-    template <int scale>\n-    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n-                                void const *base) {\n-        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n-    }\n-    template <int scale>\n-    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n-                                void const *base) {\n-        return _mm512_mask_i32gather_epi64(src, mask, index, base, scale);\n-    }\n-    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n-        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n-                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n-    }\n-    static reg_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n-    static reg_t max(reg_t x, reg_t y) { return _mm512_max_epi64(x, y); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n-        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n-    }\n-    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n-        return _mm512_maskz_loadu_epi64(mask, mem);\n-    }\n-    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n-        return _mm512_mask_loadu_epi64(x, mask, mem);\n-    }\n-    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n-        return _mm512_mask_mov_epi64(x, mask, y);\n-    }\n-    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n-        return _mm512_mask_storeu_epi64(mem, mask, x);\n-    }\n-    static reg_t min(reg_t x, reg_t y) { return _mm512_min_epi64(x, y); }\n-    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n-        return _mm512_permutexvar_epi64(idx, zmm);\n-    }\n-    static type_t reducemax(reg_t v) { return _mm512_reduce_max_epi64(v); }\n-    static type_t reducemin(reg_t v) { return _mm512_reduce_min_epi64(v); }\n-    static reg_t set1(type_t v) { return _mm512_set1_epi64(v); }\n-    template <uint8_t mask>\n-    static reg_t shuffle(reg_t zmm) {\n-        __m512d temp = _mm512_castsi512_pd(zmm);\n-        return _mm512_castpd_si512(\n-            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n-    }\n-    static void storeu(void *mem, reg_t x) { _mm512_storeu_si512(mem, x); }\n-    static reg_t reverse(reg_t zmm) {\n-        const regi_t rev_index = seti(NETWORK_64BIT_2);\n-        return permutexvar(rev_index, zmm);\n-    }\n-    static reg_t sort_vec(reg_t x) {\n-        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n-    }\n-    static reg_t cast_from(__m512i v) { return v; }\n-    static __m512i cast_to(reg_t v) { return v; }\n-    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n-                                    opmask_t k, reg_t reg) {\n-        return avx512_double_compressstore<zmm_vector<type_t>>(\n-            left_addr, right_addr, k, reg);\n-    }\n-};\n-template <>\n-struct zmm_vector<double> {\n-    using type_t = double;\n-    using reg_t = __m512d;\n-    using regi_t = __m512i;\n-    using halfreg_t = __m512d;\n-    using opmask_t = __mmask8;\n-    static const uint8_t numlanes = 8;\n-#ifdef XSS_MINIMAL_NETWORK_SORT\n-    static constexpr int network_sort_threshold = numlanes;\n-#else\n-    static constexpr int network_sort_threshold = 256;\n-#endif\n-    static constexpr int partition_unroll_factor = 8;\n-\n-    using swizzle_ops = avx512_64bit_swizzle_ops;\n-\n-    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n-    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n-    static reg_t zmm_max() { return _mm512_set1_pd(type_max()); }\n-    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n-                       int v8) {\n-        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n-                     type_t v6, type_t v7, type_t v8) {\n-        return _mm512_set_pd(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n-        return _mm512_maskz_loadu_pd(mask, mem);\n-    }\n-    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n-    static opmask_t ge(reg_t x, reg_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n-    }\n-    static opmask_t gt(reg_t x, reg_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n-    }\n-    static opmask_t eq(reg_t x, reg_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n-    }\n-    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n-        return ((0x1ull << num_to_read) - 0x1ull);\n-    }\n-    static int32_t convert_mask_to_int(opmask_t mask) { return mask; }\n-    template <int type>\n-    static opmask_t fpclass(reg_t x) {\n-        return _mm512_fpclass_pd_mask(x, type);\n-    }\n-    template <int scale>\n-    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n-                                void const *base) {\n-        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n-    }\n-    template <int scale>\n-    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n-                                void const *base) {\n-        return _mm512_mask_i32gather_pd(src, mask, index, base, scale);\n-    }\n-    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n-        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n-                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n-    }\n-    static reg_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n-    static reg_t max(reg_t x, reg_t y) { return _mm512_max_pd(x, y); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n-        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n-    }\n-    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n-        return _mm512_mask_loadu_pd(x, mask, mem);\n-    }\n-    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n-        return _mm512_mask_mov_pd(x, mask, y);\n-    }\n-    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n-        return _mm512_mask_storeu_pd(mem, mask, x);\n-    }\n-    static reg_t min(reg_t x, reg_t y) { return _mm512_min_pd(x, y); }\n-    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n-        return _mm512_permutexvar_pd(idx, zmm);\n-    }\n-    static type_t reducemax(reg_t v) { return _mm512_reduce_max_pd(v); }\n-    static type_t reducemin(reg_t v) { return _mm512_reduce_min_pd(v); }\n-    static reg_t set1(type_t v) { return _mm512_set1_pd(v); }\n-    template <uint8_t mask>\n-    static reg_t shuffle(reg_t zmm) {\n-        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n-    }\n-    static void storeu(void *mem, reg_t x) { _mm512_storeu_pd(mem, x); }\n-    static reg_t reverse(reg_t zmm) {\n-        const regi_t rev_index = seti(NETWORK_64BIT_2);\n-        return permutexvar(rev_index, zmm);\n-    }\n-    static reg_t sort_vec(reg_t x) {\n-        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n-    }\n-    static reg_t cast_from(__m512i v) { return _mm512_castsi512_pd(v); }\n-    static __m512i cast_to(reg_t v) { return _mm512_castpd_si512(v); }\n-    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n-                                    opmask_t k, reg_t reg) {\n-        return avx512_double_compressstore<zmm_vector<type_t>>(\n-            left_addr, right_addr, k, reg);\n-    }\n-};\n-\n-\/*\n- * Assumes zmm is random and performs a full sorting network defined in\n- * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n- *\/\n-template <typename vtype, typename reg_t = typename vtype::reg_t>\n-X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm) {\n-    const typename vtype::regi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    return zmm;\n-}\n-\n-struct avx512_64bit_swizzle_ops {\n-    template <typename vtype, int scale>\n-    X86_SIMD_SORT_INLINE typename vtype::reg_t swap_n(\n-        typename vtype::reg_t reg) {\n-        __m512i v = vtype::cast_to(reg);\n-\n-        if constexpr (scale == 2) {\n-            v = _mm512_shuffle_epi32(v, (_MM_PERM_ENUM)0b01001110);\n-        } else if constexpr (scale == 4) {\n-            v = _mm512_shuffle_i64x2(v, v, 0b10110001);\n-        } else if constexpr (scale == 8) {\n-            v = _mm512_shuffle_i64x2(v, v, 0b01001110);\n-        } else {\n-            static_assert(scale == -1, \"should not be reached\");\n-        }\n-\n-        return vtype::cast_from(v);\n-    }\n-\n-    template <typename vtype, int scale>\n-    X86_SIMD_SORT_INLINE typename vtype::reg_t reverse_n(\n-        typename vtype::reg_t reg) {\n-        __m512i v = vtype::cast_to(reg);\n-\n-        if constexpr (scale == 2) {\n-            return swap_n<vtype, 2>(reg);\n-        } else if constexpr (scale == 4) {\n-            constexpr uint64_t mask = 0b00011011;\n-            v = _mm512_permutex_epi64(v, mask);\n-        } else if constexpr (scale == 8) {\n-            return vtype::reverse(reg);\n-        } else {\n-            static_assert(scale == -1, \"should not be reached\");\n-        }\n-\n-        return vtype::cast_from(v);\n-    }\n-\n-    template <typename vtype, int scale>\n-    X86_SIMD_SORT_INLINE typename vtype::reg_t merge_n(\n-        typename vtype::reg_t reg, typename vtype::reg_t other) {\n-        __m512i v1 = vtype::cast_to(reg);\n-        __m512i v2 = vtype::cast_to(other);\n-\n-        if constexpr (scale == 2) {\n-            v1 = _mm512_mask_blend_epi64(0b01010101, v1, v2);\n-        } else if constexpr (scale == 4) {\n-            v1 = _mm512_mask_blend_epi64(0b00110011, v1, v2);\n-        } else if constexpr (scale == 8) {\n-            v1 = _mm512_mask_blend_epi64(0b00001111, v1, v2);\n-        } else {\n-            static_assert(scale == -1, \"should not be reached\");\n-        }\n-\n-        return vtype::cast_from(v1);\n-    }\n-};\n-\n-#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-common.h","additions":0,"deletions":342,"binary":false,"changes":342,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"xss-common-includes.h\"\n@@ -31,1 +32,0 @@\n-#include \"avx512-64bit-common.h\"\n@@ -33,1 +33,311 @@\n-#endif \/\/ AVX512_QSORT_64BIT\n+\/*\n+ * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n+#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n+\n+template <typename vtype, typename reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm);\n+\n+struct avx512_64bit_swizzle_ops;\n+\n+template <>\n+struct zmm_vector<int64_t> {\n+    using type_t = int64_t;\n+    using reg_t = __m512i;\n+    using regi_t = __m512i;\n+    using halfreg_t = __m512i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_64bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n+    static reg_t zmm_max() {\n+        return _mm512_set1_epi64(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n+                     type_t v6, type_t v7, type_t v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n+    }\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n+    static opmask_t eq(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm512_mask_i32gather_epi64(src, mask, index, base, scale);\n+    }\n+    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n+        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n+                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n+    }\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_epi64(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n+    }\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_epi64(mask, mem);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi64(x, mask, mem);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm512_mask_mov_epi64(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_storeu_epi64(mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_epi64(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n+        return _mm512_permutexvar_epi64(idx, zmm);\n+    }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_epi64(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_epi64(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_epi64(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t zmm) {\n+        __m512d temp = _mm512_castsi512_pd(zmm);\n+        return _mm512_castpd_si512(\n+            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n+    }\n+    static void storeu(void *mem, reg_t x) { _mm512_storeu_si512(mem, x); }\n+    static reg_t reverse(reg_t zmm) {\n+        const regi_t rev_index = seti(NETWORK_64BIT_2);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return v; }\n+    static __m512i cast_to(reg_t v) { return v; }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n+};\n+template <>\n+struct zmm_vector<double> {\n+    using type_t = double;\n+    using reg_t = __m512d;\n+    using regi_t = __m512i;\n+    using halfreg_t = __m512d;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_64bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n+    static reg_t zmm_max() { return _mm512_set1_pd(type_max()); }\n+    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n+                     type_t v6, type_t v7, type_t v8) {\n+        return _mm512_set_pd(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_pd(mask, mem);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n+    }\n+    static opmask_t eq(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n+    }\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n+    static int32_t convert_mask_to_int(opmask_t mask) { return mask; }\n+    template <int type>\n+    static opmask_t fpclass(reg_t x) {\n+        return _mm512_fpclass_pd_mask(x, type);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm512_mask_i32gather_pd(src, mask, index, base, scale);\n+    }\n+    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n+        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n+                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n+    }\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_pd(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_pd(x, mask, mem);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm512_mask_mov_pd(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_storeu_pd(mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_pd(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n+        return _mm512_permutexvar_pd(idx, zmm);\n+    }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_pd(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_pd(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_pd(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t zmm) {\n+        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, reg_t x) { _mm512_storeu_pd(mem, x); }\n+    static reg_t reverse(reg_t zmm) {\n+        const regi_t rev_index = seti(NETWORK_64BIT_2);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return _mm512_castsi512_pd(v); }\n+    static __m512i cast_to(reg_t v) { return _mm512_castpd_si512(v); }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n+};\n+\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm) {\n+    const typename vtype::regi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    return zmm;\n+}\n+\n+struct avx512_64bit_swizzle_ops {\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t swap_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n+\n+        if constexpr (scale == 2) {\n+            v = _mm512_shuffle_epi32(v, (_MM_PERM_ENUM)0b01001110);\n+        } else if constexpr (scale == 4) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b10110001);\n+        } else if constexpr (scale == 8) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b01001110);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v);\n+    }\n+\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t reverse_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n+\n+        if constexpr (scale == 2) {\n+            return swap_n<vtype, 2>(reg);\n+        } else if constexpr (scale == 4) {\n+            constexpr uint64_t mask = 0b00011011;\n+            v = _mm512_permutex_epi64(v, mask);\n+        } else if constexpr (scale == 8) {\n+            return vtype::reverse(reg);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v);\n+    }\n+\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t merge_n(\n+        typename vtype::reg_t reg, typename vtype::reg_t other) {\n+        __m512i v1 = vtype::cast_to(reg);\n+        __m512i v2 = vtype::cast_to(other);\n+\n+        if constexpr (scale == 2) {\n+            v1 = _mm512_mask_blend_epi64(0b01010101, v1, v2);\n+        } else if constexpr (scale == 4) {\n+            v1 = _mm512_mask_blend_epi64(0b00110011, v1, v2);\n+        } else if constexpr (scale == 8) {\n+            v1 = _mm512_mask_blend_epi64(0b00001111, v1, v2);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v1);\n+    }\n+};\n+\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-qsort.hpp","additions":312,"deletions":2,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-#endif  \/\/ XSS_COMMON_INCLUDES\n+#endif \/\/ XSS_COMMON_INCLUDES\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-common-includes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}