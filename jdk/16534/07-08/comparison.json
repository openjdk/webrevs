{"files":[{"patch":"@@ -51,15 +51,0 @@\n-constexpr auto avx2_mask_helper_lut64 = [] {\n-    std::array<std::array<int64_t, 4>, 16> lut{};\n-    for (int64_t i = 0; i <= 0xF; i++) {\n-        std::array<int64_t, 4> entry{};\n-        for (int j = 0; j < 4; j++) {\n-            if (((i >> j) & 1) == 1)\n-                entry[j] = 0xFFFFFFFFFFFFFFFF;\n-            else\n-                entry[j] = 0;\n-        }\n-        lut[i] = entry;\n-    }\n-    return lut;\n-}();\n-\n@@ -95,30 +80,0 @@\n-constexpr auto avx2_compressstore_lut64_gen = [] {\n-    std::array<std::array<int32_t, 8>, 16> permLut{};\n-    std::array<std::array<int64_t, 4>, 16> leftLut{};\n-    for (int64_t i = 0; i <= 0xF; i++) {\n-        std::array<int32_t, 8> indices{};\n-        std::array<int64_t, 4> leftEntry = {0, 0, 0, 0};\n-        int right = 7;\n-        int left = 0;\n-        for (int j = 0; j < 4; j++) {\n-            bool ge = (i >> j) & 1;\n-            if (ge) {\n-                indices[right] = 2 * j + 1;\n-                indices[right - 1] = 2 * j;\n-                right -= 2;\n-            } else {\n-                indices[left + 1] = 2 * j + 1;\n-                indices[left] = 2 * j;\n-                leftEntry[left \/ 2] = 0xFFFFFFFFFFFFFFFF;\n-                left += 2;\n-            }\n-        }\n-        permLut[i] = indices;\n-        leftLut[i] = leftEntry;\n-    }\n-    return std::make_pair(permLut, leftLut);\n-}();\n-constexpr auto avx2_compressstore_lut64_perm =\n-    avx2_compressstore_lut64_gen.first;\n-constexpr auto avx2_compressstore_lut64_left =\n-    avx2_compressstore_lut64_gen.second;\n@@ -137,11 +92,0 @@\n-X86_SIMD_SORT_INLINE\n-__m256i convert_int_to_avx2_mask_64bit(int32_t m) {\n-    return _mm256_loadu_si256(\n-        (const __m256i *)avx2_mask_helper_lut64[m].data());\n-}\n-\n-X86_SIMD_SORT_INLINE\n-int32_t convert_avx2_mask_to_int_64bit(__m256i m) {\n-    return _mm256_movemask_pd(_mm256_castsi256_pd(m));\n-}\n-\n@@ -177,20 +121,0 @@\n-template <typename T>\n-T avx2_emu_reduce_max64(typename avx2_vector<T>::reg_t x) {\n-    using vtype = avx2_vector<T>;\n-    typename vtype::reg_t inter1 =\n-        vtype::max(x, vtype::template permutexvar<SHUFFLE_MASK(2, 3, 0, 1)>(x));\n-    T arr[vtype::numlanes];\n-    vtype::storeu(arr, inter1);\n-    return std::max(arr[0], arr[3]);\n-}\n-\n-template <typename T>\n-T avx2_emu_reduce_min64(typename avx2_vector<T>::reg_t x) {\n-    using vtype = avx2_vector<T>;\n-    typename vtype::reg_t inter1 =\n-        vtype::min(x, vtype::template permutexvar<SHUFFLE_MASK(2, 3, 0, 1)>(x));\n-    T arr[vtype::numlanes];\n-    vtype::storeu(arr, inter1);\n-    return std::min(arr[0], arr[3]);\n-}\n-\n@@ -216,19 +140,0 @@\n-template <typename T>\n-void avx2_emu_mask_compressstoreu64(void *base_addr,\n-                                    typename avx2_vector<T>::opmask_t k,\n-                                    typename avx2_vector<T>::reg_t reg) {\n-    using vtype = avx2_vector<T>;\n-\n-    T *leftStore = (T *)base_addr;\n-\n-    int32_t shortMask = convert_avx2_mask_to_int_64bit(k);\n-    const __m256i &perm = _mm256_loadu_si256(\n-        (const __m256i *)avx2_compressstore_lut64_perm[shortMask].data());\n-    const __m256i &left = _mm256_loadu_si256(\n-        (const __m256i *)avx2_compressstore_lut64_left[shortMask].data());\n-\n-    typename vtype::reg_t temp = vtype::cast_from(\n-        _mm256_permutevar8x32_epi32(vtype::cast_to(reg), perm));\n-\n-    vtype::mask_storeu(leftStore, left, temp);\n-}\n@@ -257,21 +162,0 @@\n-template <typename T>\n-int32_t avx2_double_compressstore64(void *left_addr, void *right_addr,\n-                                    typename avx2_vector<T>::opmask_t k,\n-                                    typename avx2_vector<T>::reg_t reg) {\n-    using vtype = avx2_vector<T>;\n-\n-    T *leftStore = (T *)left_addr;\n-    T *rightStore = (T *)right_addr;\n-\n-    int32_t shortMask = convert_avx2_mask_to_int_64bit(k);\n-    const __m256i &perm = _mm256_loadu_si256(\n-        (const __m256i *)avx2_compressstore_lut64_perm[shortMask].data());\n-\n-    typename vtype::reg_t temp = vtype::cast_from(\n-        _mm256_permutevar8x32_epi32(vtype::cast_to(reg), perm));\n-\n-    vtype::storeu(leftStore, temp);\n-    vtype::storeu(rightStore, temp);\n-\n-    return _mm_popcnt_u32(shortMask);\n-}\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-emu-funcs.hpp","additions":0,"deletions":116,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n@@ -57,0 +59,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-linux-qsort.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n@@ -70,0 +72,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-linux-qsort.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+#undef assert\n+#define assert(cond, msg) { if (!(cond)) { fprintf(stderr, \"assert fails %s %d: %s\\n\", __FILE__, __LINE__, msg); abort(); }}\n+\n+\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/simdsort-support.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}