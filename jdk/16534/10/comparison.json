{"files":[{"patch":"@@ -248,1 +248,1 @@\n-      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB) -std=c++17, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,0 +196,5 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -189,0 +189,5 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -198,0 +198,5 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -195,0 +195,5 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -187,0 +187,5 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -251,0 +251,13 @@\n+  \/\/ Is SIMD sort supported for this CPU?\n+  static bool supports_simd_sort(BasicType bt) {\n+    if (VM_Version::supports_avx512dq()) {\n+      return true;\n+    }\n+    else if (VM_Version::supports_avx2() && !is_double_word_type(bt)) {\n+      return true;\n+    }\n+    else {\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4196,2 +4196,3 @@\n-  \/\/ Load x86_64_sort library on supported hardware to enable avx512 sort and partition intrinsics\n-  if (VM_Version::is_intel() && VM_Version::supports_avx512dq()) {\n+  \/\/ Load x86_64_sort library on supported hardware to enable SIMD sort and partition intrinsics\n+\n+  if (VM_Version::is_intel() && (VM_Version::supports_avx512dq() || VM_Version::supports_avx2())) {\n@@ -4204,1 +4205,1 @@\n-    \/\/ Get addresses for avx512 sort and partition routines\n+    \/\/ Get addresses for SIMD sort and partition routines\n@@ -4208,1 +4209,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort\");\n+      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512dq() ? \"avx512_sort\" : \"avx2_sort\");\n@@ -4211,1 +4212,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition\");\n+      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512dq() ? \"avx512_partition\" : \"avx2_partition\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -861,1 +861,1 @@\n-    (_model == 0x97 || _model == 0xAC || _model == 0xAF)) {\n+    (_model == 0x97 || _model == 0xAA || _model == 0xAC || _model == 0xAF)) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,0 +217,18 @@\n+bool C2Compiler::is_intrinsic_supported(vmIntrinsics::ID id, BasicType bt) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+\n+  if (id < vmIntrinsics::FIRST_ID || id > vmIntrinsics::LAST_COMPILER_INLINE) {\n+    return false;\n+  }\n+\n+  switch (id) {\n+  case vmIntrinsics::_arraySort:\n+  case vmIntrinsics::_arrayPartition:\n+    if (!Matcher::supports_simd_sort(bt)) return false;\n+    break;\n+  default:\n+    return false;\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+  \/\/ Return true if the intrinsic `id` is supported by C2 for a given basictype `bt`\n+  static bool is_intrinsic_supported(vmIntrinsics::ID id, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,2 +296,2 @@\n-  case vmIntrinsics::_arraySort:                return inline_array_sort();\n-  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+  case vmIntrinsics::_arraySort:                return inline_array_sort(intrinsic_id());\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition(intrinsic_id());\n@@ -5370,1 +5370,1 @@\n-bool LibraryCallKit::inline_array_partition() {\n+bool LibraryCallKit::inline_array_partition(vmIntrinsics::ID id) {\n@@ -5390,0 +5390,4 @@\n+    \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+    if (!C2Compiler::is_intrinsic_supported(id, bt)) {\n+      return false;\n+    }\n@@ -5432,1 +5436,1 @@\n-bool LibraryCallKit::inline_array_sort() {\n+bool LibraryCallKit::inline_array_sort(vmIntrinsics::ID id) {\n@@ -5443,0 +5447,4 @@\n+  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+  if (!C2Compiler::is_intrinsic_supported(id, bt)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -280,2 +280,2 @@\n-  bool inline_array_sort();\n-  bool inline_array_partition();\n+  bool inline_array_sort(vmIntrinsics::ID id);\n+  bool inline_array_partition(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX2_QSORT_32BIT\n+#define AVX2_QSORT_32BIT\n+\n+#include \"avx2-emu-funcs.hpp\"\n+#include \"xss-common-qsort.h\"\n+\n+\/*\n+ * Constants used in sorting 8 elements in a ymm registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+\n+\/\/ ymm                  7, 6, 5, 4, 3, 2, 1, 0\n+#define NETWORK_32BIT_AVX2_1 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_32BIT_AVX2_2 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_32BIT_AVX2_3 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_32BIT_AVX2_4 3, 2, 1, 0, 7, 6, 5, 4\n+\n+\/*\n+ * Assumes ymm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_ymm_32bit(reg_t ymm) {\n+    const typename vtype::opmask_t oxAA = _mm256_set_epi32(\n+        0xFFFFFFFF, 0, 0xFFFFFFFF, 0, 0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n+    const typename vtype::opmask_t oxCC = _mm256_set_epi32(\n+        0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0, 0);\n+    const typename vtype::opmask_t oxF0 = _mm256_set_epi32(\n+        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0, 0);\n+\n+    const typename vtype::ymmi_t rev_index = vtype::seti(NETWORK_32BIT_AVX2_2);\n+    ymm = cmp_merge<vtype>(\n+        ymm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(ymm), oxAA);\n+    ymm = cmp_merge<vtype>(\n+        ymm, vtype::permutexvar(vtype::seti(NETWORK_32BIT_AVX2_1), ymm), oxCC);\n+    ymm = cmp_merge<vtype>(\n+        ymm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(ymm), oxAA);\n+    ymm = cmp_merge<vtype>(ymm, vtype::permutexvar(rev_index, ymm), oxF0);\n+    ymm = cmp_merge<vtype>(\n+        ymm, vtype::permutexvar(vtype::seti(NETWORK_32BIT_AVX2_3), ymm), oxCC);\n+    ymm = cmp_merge<vtype>(\n+        ymm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(ymm), oxAA);\n+    return ymm;\n+}\n+\n+struct avx2_32bit_swizzle_ops;\n+\n+template <>\n+struct avx2_vector<int32_t> {\n+    using type_t = int32_t;\n+    using reg_t = __m256i;\n+    using ymmi_t = __m256i;\n+    using opmask_t = __m256i;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 4;\n+\n+    using swizzle_ops = avx2_32bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT32; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT32; }\n+    static reg_t zmm_max() {\n+        return _mm256_set1_epi32(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        auto mask = ((0x1ull << num_to_read) - 0x1ull);\n+        return convert_int_to_avx2_mask(mask);\n+    }\n+    static ymmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm256_set_epi32(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _mm256_xor_si256(x, y);\n+    }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        opmask_t equal = eq(x, y);\n+        opmask_t greater = _mm256_cmpgt_epi32(x, y);\n+        return _mm256_castps_si256(_mm256_or_ps(_mm256_castsi256_ps(equal),\n+                                                _mm256_castsi256_ps(greater)));\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) { return _mm256_cmpgt_epi32(x, y); }\n+    static opmask_t eq(reg_t x, reg_t y) { return _mm256_cmpeq_epi32(x, y); }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm256_mask_i32gather_epi32(src, base, index, mask, scale);\n+    }\n+    template <int scale>\n+    static reg_t i64gather(__m256i index, void const *base) {\n+        return _mm256_i32gather_epi32((int const *)base, index, scale);\n+    }\n+    static reg_t loadu(void const *mem) {\n+        return _mm256_loadu_si256((reg_t const *)mem);\n+    }\n+    static reg_t max(reg_t x, reg_t y) { return _mm256_max_epi32(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return avx2_emu_mask_compressstoreu32<type_t>(mem, mask, x);\n+    }\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm256_maskload_epi32((const int *)mem, mask);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        reg_t dst = _mm256_maskload_epi32((type_t *)mem, mask);\n+        return mask_mov(x, mask, dst);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm256_castps_si256(_mm256_blendv_ps(_mm256_castsi256_ps(x),\n+                                                    _mm256_castsi256_ps(y),\n+                                                    _mm256_castsi256_ps(mask)));\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm256_maskstore_epi32((type_t *)mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm256_min_epi32(x, y); }\n+    static reg_t permutexvar(__m256i idx, reg_t ymm) {\n+        return _mm256_permutevar8x32_epi32(ymm, idx);\n+        \/\/ return avx2_emu_permutexvar_epi32(idx, ymm);\n+    }\n+    static reg_t permutevar(reg_t ymm, __m256i idx) {\n+        return _mm256_permutevar8x32_epi32(ymm, idx);\n+    }\n+    static reg_t reverse(reg_t ymm) {\n+        const __m256i rev_index = _mm256_set_epi32(NETWORK_32BIT_AVX2_2);\n+        return permutexvar(rev_index, ymm);\n+    }\n+    static type_t reducemax(reg_t v) {\n+        return avx2_emu_reduce_max32<type_t>(v);\n+    }\n+    static type_t reducemin(reg_t v) {\n+        return avx2_emu_reduce_min32<type_t>(v);\n+    }\n+    static reg_t set1(type_t v) { return _mm256_set1_epi32(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t ymm) {\n+        return _mm256_shuffle_epi32(ymm, mask);\n+    }\n+    static void storeu(void *mem, reg_t x) {\n+        _mm256_storeu_si256((__m256i *)mem, x);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_ymm_32bit<avx2_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m256i v) { return v; }\n+    static __m256i cast_to(reg_t v) { return v; }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx2_double_compressstore32<type_t>(left_addr, right_addr, k,\n+                                                   reg);\n+    }\n+};\n+\n+template <>\n+struct avx2_vector<float> {\n+    using type_t = float;\n+    using reg_t = __m256;\n+    using ymmi_t = __m256i;\n+    using opmask_t = __m256i;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 4;\n+\n+    using swizzle_ops = avx2_32bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITYF; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITYF; }\n+    static reg_t zmm_max() { return _mm256_set1_ps(type_max()); }\n+\n+    static ymmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm256_set_epi32(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm256_maskload_ps((const float *)mem, mask);\n+    }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        return _mm256_castps_si256(_mm256_cmp_ps(x, y, _CMP_GE_OQ));\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) {\n+        return _mm256_castps_si256(_mm256_cmp_ps(x, y, _CMP_GT_OQ));\n+    }\n+    static opmask_t eq(reg_t x, reg_t y) {\n+        return _mm256_castps_si256(_mm256_cmp_ps(x, y, _CMP_EQ_OQ));\n+    }\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        auto mask = ((0x1ull << num_to_read) - 0x1ull);\n+        return convert_int_to_avx2_mask(mask);\n+    }\n+    static int32_t convert_mask_to_int(opmask_t mask) {\n+        return convert_avx2_mask_to_int(mask);\n+    }\n+    template <int type>\n+    static opmask_t fpclass(reg_t x) {\n+        if constexpr (type == (0x01 | 0x80)) {\n+            return _mm256_castps_si256(_mm256_cmp_ps(x, x, _CMP_UNORD_Q));\n+        } else {\n+            static_assert(type == (0x01 | 0x80), \"should not reach here\");\n+        }\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm256_mask_i32gather_ps(src, base, index,\n+                                        _mm256_castsi256_ps(mask), scale);\n+        ;\n+    }\n+    template <int scale>\n+    static reg_t i64gather(__m256i index, void const *base) {\n+        return _mm256_i32gather_ps((float *)base, index, scale);\n+    }\n+    static reg_t loadu(void const *mem) {\n+        return _mm256_loadu_ps((float const *)mem);\n+    }\n+    static reg_t max(reg_t x, reg_t y) { return _mm256_max_ps(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return avx2_emu_mask_compressstoreu32<type_t>(mem, mask, x);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        reg_t dst = _mm256_maskload_ps((type_t *)mem, mask);\n+        return mask_mov(x, mask, dst);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm256_blendv_ps(x, y, _mm256_castsi256_ps(mask));\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm256_maskstore_ps((type_t *)mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm256_min_ps(x, y); }\n+    static reg_t permutexvar(__m256i idx, reg_t ymm) {\n+        return _mm256_permutevar8x32_ps(ymm, idx);\n+    }\n+    static reg_t permutevar(reg_t ymm, __m256i idx) {\n+        return _mm256_permutevar8x32_ps(ymm, idx);\n+    }\n+    static reg_t reverse(reg_t ymm) {\n+        const __m256i rev_index = _mm256_set_epi32(NETWORK_32BIT_AVX2_2);\n+        return permutexvar(rev_index, ymm);\n+    }\n+    static type_t reducemax(reg_t v) {\n+        return avx2_emu_reduce_max32<type_t>(v);\n+    }\n+    static type_t reducemin(reg_t v) {\n+        return avx2_emu_reduce_min32<type_t>(v);\n+    }\n+    static reg_t set1(type_t v) { return _mm256_set1_ps(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t ymm) {\n+        return _mm256_castsi256_ps(\n+            _mm256_shuffle_epi32(_mm256_castps_si256(ymm), mask));\n+    }\n+    static void storeu(void *mem, reg_t x) {\n+        _mm256_storeu_ps((float *)mem, x);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_ymm_32bit<avx2_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m256i v) { return _mm256_castsi256_ps(v); }\n+    static __m256i cast_to(reg_t v) { return _mm256_castps_si256(v); }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx2_double_compressstore32<type_t>(left_addr, right_addr, k,\n+                                                   reg);\n+    }\n+};\n+\n+struct avx2_32bit_swizzle_ops {\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t swap_n(\n+        typename vtype::reg_t reg) {\n+        __m256i v = vtype::cast_to(reg);\n+\n+        if constexpr (scale == 2) {\n+            __m256 vf = _mm256_castsi256_ps(v);\n+            vf = _mm256_permute_ps(vf, 0b10110001);\n+            v = _mm256_castps_si256(vf);\n+        } else if constexpr (scale == 4) {\n+            __m256 vf = _mm256_castsi256_ps(v);\n+            vf = _mm256_permute_ps(vf, 0b01001110);\n+            v = _mm256_castps_si256(vf);\n+        } else if constexpr (scale == 8) {\n+            v = _mm256_permute2x128_si256(v, v, 0b00000001);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v);\n+    }\n+\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t reverse_n(\n+        typename vtype::reg_t reg) {\n+        __m256i v = vtype::cast_to(reg);\n+\n+        if constexpr (scale == 2) {\n+            return swap_n<vtype, 2>(reg);\n+        } else if constexpr (scale == 4) {\n+            constexpr uint64_t mask = 0b00011011;\n+            __m256 vf = _mm256_castsi256_ps(v);\n+            vf = _mm256_permute_ps(vf, mask);\n+            v = _mm256_castps_si256(vf);\n+        } else if constexpr (scale == 8) {\n+            return vtype::reverse(reg);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v);\n+    }\n+\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t merge_n(\n+        typename vtype::reg_t reg, typename vtype::reg_t other) {\n+        __m256i v1 = vtype::cast_to(reg);\n+        __m256i v2 = vtype::cast_to(other);\n+\n+        if constexpr (scale == 2) {\n+            v1 = _mm256_blend_epi32(v1, v2, 0b01010101);\n+        } else if constexpr (scale == 4) {\n+            v1 = _mm256_blend_epi32(v1, v2, 0b00110011);\n+        } else if constexpr (scale == 8) {\n+            v1 = _mm256_blend_epi32(v1, v2, 0b00001111);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n+\n+        return vtype::cast_from(v1);\n+    }\n+};\n+\n+#endif  \/\/ AVX2_QSORT_32BIT\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-32bit-qsort.hpp","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef AVX2_EMU_FUNCS\n+#define AVX2_EMU_FUNCS\n+\n+#include <array>\n+#include <utility>\n+\n+#include \"xss-common-qsort.h\"\n+\n+constexpr auto avx2_mask_helper_lut32 = [] {\n+    std::array<std::array<int32_t, 8>, 256> lut{};\n+    for (int64_t i = 0; i <= 0xFF; i++) {\n+        std::array<int32_t, 8> entry{};\n+        for (int j = 0; j < 8; j++) {\n+            if (((i >> j) & 1) == 1)\n+                entry[j] = 0xFFFFFFFF;\n+            else\n+                entry[j] = 0;\n+        }\n+        lut[i] = entry;\n+    }\n+    return lut;\n+}();\n+\n+constexpr auto avx2_compressstore_lut32_gen = [] {\n+    std::array<std::array<std::array<int32_t, 8>, 256>, 2> lutPair{};\n+    auto &permLut = lutPair[0];\n+    auto &leftLut = lutPair[1];\n+    for (int64_t i = 0; i <= 0xFF; i++) {\n+        std::array<int32_t, 8> indices{};\n+        std::array<int32_t, 8> leftEntry = {0, 0, 0, 0, 0, 0, 0, 0};\n+        int right = 7;\n+        int left = 0;\n+        for (int j = 0; j < 8; j++) {\n+            bool ge = (i >> j) & 1;\n+            if (ge) {\n+                indices[right] = j;\n+                right--;\n+            } else {\n+                indices[left] = j;\n+                leftEntry[left] = 0xFFFFFFFF;\n+                left++;\n+            }\n+        }\n+        permLut[i] = indices;\n+        leftLut[i] = leftEntry;\n+    }\n+    return lutPair;\n+}();\n+\n+constexpr auto avx2_compressstore_lut32_perm = avx2_compressstore_lut32_gen[0];\n+constexpr auto avx2_compressstore_lut32_left = avx2_compressstore_lut32_gen[1];\n+\n+\n+X86_SIMD_SORT_INLINE\n+__m256i convert_int_to_avx2_mask(int32_t m) {\n+    return _mm256_loadu_si256(\n+        (const __m256i *)avx2_mask_helper_lut32[m].data());\n+}\n+\n+X86_SIMD_SORT_INLINE\n+int32_t convert_avx2_mask_to_int(__m256i m) {\n+    return _mm256_movemask_ps(_mm256_castsi256_ps(m));\n+}\n+\n+\/\/ Emulators for intrinsics missing from AVX2 compared to AVX512\n+template <typename T>\n+T avx2_emu_reduce_max32(typename avx2_vector<T>::reg_t x) {\n+    using vtype = avx2_vector<T>;\n+    using reg_t = typename vtype::reg_t;\n+\n+    reg_t inter1 =\n+        vtype::max(x, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(x));\n+    reg_t inter2 = vtype::max(\n+        inter1, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(inter1));\n+    T arr[vtype::numlanes];\n+    vtype::storeu(arr, inter2);\n+    return std::max(arr[0], arr[7]);\n+}\n+\n+template <typename T>\n+T avx2_emu_reduce_min32(typename avx2_vector<T>::reg_t x) {\n+    using vtype = avx2_vector<T>;\n+    using reg_t = typename vtype::reg_t;\n+\n+    reg_t inter1 =\n+        vtype::min(x, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(x));\n+    reg_t inter2 = vtype::min(\n+        inter1, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(inter1));\n+    T arr[vtype::numlanes];\n+    vtype::storeu(arr, inter2);\n+    return std::min(arr[0], arr[7]);\n+}\n+\n+template <typename T>\n+void avx2_emu_mask_compressstoreu32(void *base_addr,\n+                                    typename avx2_vector<T>::opmask_t k,\n+                                    typename avx2_vector<T>::reg_t reg) {\n+    using vtype = avx2_vector<T>;\n+\n+    T *leftStore = (T *)base_addr;\n+\n+    int32_t shortMask = convert_avx2_mask_to_int(k);\n+    const __m256i &perm = _mm256_loadu_si256(\n+        (const __m256i *)avx2_compressstore_lut32_perm[shortMask].data());\n+    const __m256i &left = _mm256_loadu_si256(\n+        (const __m256i *)avx2_compressstore_lut32_left[shortMask].data());\n+\n+    typename vtype::reg_t temp = vtype::permutevar(reg, perm);\n+\n+    vtype::mask_storeu(leftStore, left, temp);\n+}\n+\n+\n+template <typename T>\n+int avx2_double_compressstore32(void *left_addr, void *right_addr,\n+                                typename avx2_vector<T>::opmask_t k,\n+                                typename avx2_vector<T>::reg_t reg) {\n+    using vtype = avx2_vector<T>;\n+\n+    T *leftStore = (T *)left_addr;\n+    T *rightStore = (T *)right_addr;\n+\n+    int32_t shortMask = convert_avx2_mask_to_int(k);\n+    const __m256i &perm = _mm256_loadu_si256(\n+        (const __m256i *)avx2_compressstore_lut32_perm[shortMask].data());\n+\n+    typename vtype::reg_t temp = vtype::permutevar(reg, perm);\n+\n+    vtype::storeu(leftStore, temp);\n+    vtype::storeu(rightStore, temp);\n+\n+    return _mm_popcnt_u32(shortMask);\n+}\n+\n+\n+template <typename T>\n+typename avx2_vector<T>::reg_t avx2_emu_max(typename avx2_vector<T>::reg_t x,\n+                                            typename avx2_vector<T>::reg_t y) {\n+    using vtype = avx2_vector<T>;\n+    typename vtype::opmask_t nlt = vtype::gt(x, y);\n+    return _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(y),\n+                                                _mm256_castsi256_pd(x),\n+                                                _mm256_castsi256_pd(nlt)));\n+}\n+\n+template <typename T>\n+typename avx2_vector<T>::reg_t avx2_emu_min(typename avx2_vector<T>::reg_t x,\n+                                            typename avx2_vector<T>::reg_t y) {\n+    using vtype = avx2_vector<T>;\n+    typename vtype::opmask_t nlt = vtype::gt(x, y);\n+    return _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(x),\n+                                                _mm256_castsi256_pd(y),\n+                                                _mm256_castsi256_pd(nlt)));\n+}\n+\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-emu-funcs.hpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"simdsort-support.hpp\"\n+#ifdef __SIMDSORT_SUPPORTED_LINUX\n+\n+#pragma GCC target(\"avx2\")\n+#include \"avx2-32bit-qsort.hpp\"\n+#include \"classfile_constants.h\"\n+\n+\n+#define DLL_PUBLIC __attribute__((visibility(\"default\")))\n+#define INSERTION_SORT_THRESHOLD_32BIT 16\n+\n+extern \"C\" {\n+\n+    DLL_PUBLIC void avx2_sort(void *array, int elem_type, int32_t from_index, int32_t to_index) {\n+        switch(elem_type) {\n+            case JVM_T_INT:\n+                avx2_fast_sort((int32_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                break;\n+            case JVM_T_FLOAT:\n+                avx2_fast_sort((float*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                break;\n+            default:\n+                assert(false, \"Unexpected type\");\n+        }\n+    }\n+\n+    DLL_PUBLIC void avx2_partition(void *array, int elem_type, int32_t from_index, int32_t to_index, int32_t *pivot_indices, int32_t index_pivot1, int32_t index_pivot2) {\n+        switch(elem_type) {\n+            case JVM_T_INT:\n+                avx2_fast_partition((int32_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                break;\n+            case JVM_T_FLOAT:\n+                avx2_fast_partition((float*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                break;\n+            default:\n+                assert(false, \"Unexpected type\");\n+        }\n+    }\n+\n+}\n+\n+#endif\n\\ No newline at end of file\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx2-linux-qsort.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"avx512-common-qsort.h\"\n+#include \"xss-common-qsort.h\"\n@@ -46,0 +46,5 @@\n+template <typename vtype, typename reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_32bit(reg_t zmm);\n+\n+struct avx512_32bit_swizzle_ops;\n+\n@@ -49,2 +54,2 @@\n-    using zmm_t = __m512i;\n-    using ymm_t = __m256i;\n+    using reg_t = __m512i;\n+    using halfreg_t = __m256i;\n@@ -53,0 +58,8 @@\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 512;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_32bit_swizzle_ops;\n@@ -56,1 +69,1 @@\n-    static zmm_t zmm_max() { return _mm512_set1_epi32(type_max()); }\n+    static reg_t zmm_max() { return _mm512_set1_epi32(type_max()); }\n@@ -59,1 +72,2 @@\n-    static opmask_t ge(zmm_t x, zmm_t y) {\n+\n+    static opmask_t ge(reg_t x, reg_t y) {\n@@ -62,1 +76,2 @@\n-    static opmask_t gt(zmm_t x, zmm_t y) {\n+\n+    static opmask_t gt(reg_t x, reg_t y) {\n@@ -65,0 +80,4 @@\n+\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n@@ -66,1 +85,1 @@\n-    static ymm_t i64gather(__m512i index, void const *base) {\n+    static halfreg_t i64gather(__m512i index, void const *base) {\n@@ -69,2 +88,2 @@\n-    static zmm_t merge(ymm_t y1, ymm_t y2) {\n-        zmm_t z1 = _mm512_castsi256_si512(y1);\n+    static reg_t merge(halfreg_t y1, halfreg_t y2) {\n+        reg_t z1 = _mm512_castsi256_si512(y1);\n@@ -73,2 +92,2 @@\n-    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n@@ -77,1 +96,1 @@\n-    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n@@ -80,1 +99,1 @@\n-    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n@@ -83,1 +102,1 @@\n-    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n@@ -86,3 +105,3 @@\n-    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi32(x, y); }\n-    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi32(x, y); }\n-    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_epi32(x, y); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_epi32(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n@@ -91,3 +110,3 @@\n-    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi32(v); }\n-    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi32(v); }\n-    static zmm_t set1(type_t v) { return _mm512_set1_epi32(v); }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_epi32(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_epi32(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_epi32(v); }\n@@ -95,1 +114,1 @@\n-    static zmm_t shuffle(zmm_t zmm) {\n+    static reg_t shuffle(reg_t zmm) {\n@@ -98,1 +117,1 @@\n-    static void storeu(void *mem, zmm_t x) {\n+    static void storeu(void *mem, reg_t x) {\n@@ -102,2 +121,20 @@\n-    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_epi32(x, y); }\n-    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_epi32(x, y); }\n+    static halfreg_t max(halfreg_t x, halfreg_t y) {\n+        return _mm256_max_epi32(x, y);\n+    }\n+    static halfreg_t min(halfreg_t x, halfreg_t y) {\n+        return _mm256_min_epi32(x, y);\n+    }\n+    static reg_t reverse(reg_t zmm) {\n+        const auto rev_index = _mm512_set_epi32(NETWORK_32BIT_5);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_32bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return v; }\n+    static __m512i cast_to(reg_t v) { return v; }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n@@ -108,2 +145,2 @@\n-    using zmm_t = __m512;\n-    using ymm_t = __m256;\n+    using reg_t = __m512;\n+    using halfreg_t = __m256;\n@@ -112,0 +149,8 @@\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 512;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_32bit_swizzle_ops;\n@@ -115,1 +160,1 @@\n-    static zmm_t zmm_max() { return _mm512_set1_ps(type_max()); }\n+    static reg_t zmm_max() { return _mm512_set1_ps(type_max()); }\n@@ -118,1 +163,1 @@\n-    static opmask_t ge(zmm_t x, zmm_t y) {\n+    static opmask_t ge(reg_t x, reg_t y) {\n@@ -121,1 +166,1 @@\n-    static opmask_t gt(zmm_t x, zmm_t y) {\n+    static opmask_t gt(reg_t x, reg_t y) {\n@@ -124,0 +169,8 @@\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n+    static int32_t convert_mask_to_int(opmask_t mask) { return mask; }\n+    template <int type>\n+    static opmask_t fpclass(reg_t x) {\n+        return _mm512_fpclass_ps_mask(x, type);\n+    }\n@@ -125,1 +178,1 @@\n-    static ymm_t i64gather(__m512i index, void const *base) {\n+    static halfreg_t i64gather(__m512i index, void const *base) {\n@@ -128,2 +181,2 @@\n-    static zmm_t merge(ymm_t y1, ymm_t y2) {\n-        zmm_t z1 = _mm512_castsi512_ps(\n+    static reg_t merge(halfreg_t y1, halfreg_t y2) {\n+        reg_t z1 = _mm512_castsi512_ps(\n@@ -133,3 +186,3 @@\n-    static zmm_t loadu(void const *mem) { return _mm512_loadu_ps(mem); }\n-    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_ps(x, y); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_ps(mem); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_ps(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n@@ -138,1 +191,4 @@\n-    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_ps(mask, mem);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n@@ -141,1 +197,1 @@\n-    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n@@ -144,1 +200,1 @@\n-    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n@@ -147,2 +203,2 @@\n-    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_ps(x, y); }\n-    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_ps(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n@@ -151,3 +207,3 @@\n-    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_ps(v); }\n-    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_ps(v); }\n-    static zmm_t set1(type_t v) { return _mm512_set1_ps(v); }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_ps(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_ps(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_ps(v); }\n@@ -155,1 +211,1 @@\n-    static zmm_t shuffle(zmm_t zmm) {\n+    static reg_t shuffle(reg_t zmm) {\n@@ -158,1 +214,1 @@\n-    static void storeu(void *mem, zmm_t x) { return _mm512_storeu_ps(mem, x); }\n+    static void storeu(void *mem, reg_t x) { return _mm512_storeu_ps(mem, x); }\n@@ -160,2 +216,20 @@\n-    static ymm_t max(ymm_t x, ymm_t y) { return _mm256_max_ps(x, y); }\n-    static ymm_t min(ymm_t x, ymm_t y) { return _mm256_min_ps(x, y); }\n+    static halfreg_t max(halfreg_t x, halfreg_t y) {\n+        return _mm256_max_ps(x, y);\n+    }\n+    static halfreg_t min(halfreg_t x, halfreg_t y) {\n+        return _mm256_min_ps(x, y);\n+    }\n+    static reg_t reverse(reg_t zmm) {\n+        const auto rev_index = _mm512_set_epi32(NETWORK_32BIT_5);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_32bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return _mm512_castsi512_ps(v); }\n+    static __m512i cast_to(reg_t v) { return _mm512_castps_si512(v); }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n@@ -168,2 +242,2 @@\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE zmm_t sort_zmm_32bit(zmm_t zmm) {\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_32bit(reg_t zmm) {\n@@ -196,19 +270,5 @@\n-\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_32bit(zmm_t zmm) {\n-    \/\/ 1) half_cleaner[16]: compare 1-9, 2-10, 3-11 etc ..\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_7), zmm),\n-        0xFF00);\n-    \/\/ 2) half_cleaner[8]: compare 1-5, 2-6, 3-7 etc ..\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_6), zmm),\n-        0xF0F0);\n-    \/\/ 3) half_cleaner[4]\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 0, 3, 2)>(zmm), 0xCCCC);\n-    \/\/ 3) half_cleaner[1]\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(2, 3, 0, 1)>(zmm), 0xAAAA);\n-    return zmm;\n-}\n+struct avx512_32bit_swizzle_ops {\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t swap_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n@@ -216,78 +276,11 @@\n-\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_32bit(zmm_t *zmm1,\n-                                                      zmm_t *zmm2) {\n-    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n-    *zmm2 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), *zmm2);\n-    zmm_t zmm3 = vtype::min(*zmm1, *zmm2);\n-    zmm_t zmm4 = vtype::max(*zmm1, *zmm2);\n-    \/\/ 2) Recursive half cleaner for each\n-    *zmm1 = bitonic_merge_zmm_32bit<vtype>(zmm3);\n-    *zmm2 = bitonic_merge_zmm_32bit<vtype>(zmm4);\n-}\n-\n-\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n-\/\/ half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_32bit(zmm_t *zmm) {\n-    zmm_t zmm2r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[2]);\n-    zmm_t zmm3r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[3]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n-    zmm_t zmm_t3 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[1], zmm2r));\n-    zmm_t zmm_t4 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[0], zmm3r));\n-    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n-    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n-    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n-    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n-    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm0);\n-    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm1);\n-    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm2);\n-    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm3);\n-}\n-\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_32bit(zmm_t *zmm) {\n-    zmm_t zmm4r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[4]);\n-    zmm_t zmm5r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[5]);\n-    zmm_t zmm6r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[6]);\n-    zmm_t zmm7r = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5), zmm[7]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n-    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n-    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n-    zmm_t zmm_t5 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[3], zmm4r));\n-    zmm_t zmm_t6 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[2], zmm5r));\n-    zmm_t zmm_t7 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[1], zmm6r));\n-    zmm_t zmm_t8 = vtype::permutexvar(_mm512_set_epi32(NETWORK_32BIT_5),\n-                                      vtype::max(zmm[0], zmm7r));\n-    COEX<vtype>(zmm_t1, zmm_t3);\n-    COEX<vtype>(zmm_t2, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t7);\n-    COEX<vtype>(zmm_t6, zmm_t8);\n-    COEX<vtype>(zmm_t1, zmm_t2);\n-    COEX<vtype>(zmm_t3, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t6);\n-    COEX<vtype>(zmm_t7, zmm_t8);\n-    zmm[0] = bitonic_merge_zmm_32bit<vtype>(zmm_t1);\n-    zmm[1] = bitonic_merge_zmm_32bit<vtype>(zmm_t2);\n-    zmm[2] = bitonic_merge_zmm_32bit<vtype>(zmm_t3);\n-    zmm[3] = bitonic_merge_zmm_32bit<vtype>(zmm_t4);\n-    zmm[4] = bitonic_merge_zmm_32bit<vtype>(zmm_t5);\n-    zmm[5] = bitonic_merge_zmm_32bit<vtype>(zmm_t6);\n-    zmm[6] = bitonic_merge_zmm_32bit<vtype>(zmm_t7);\n-    zmm[7] = bitonic_merge_zmm_32bit<vtype>(zmm_t8);\n-}\n-\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_16_32bit(type_t *arr, int32_t N) {\n-    typename vtype::opmask_t load_mask = (0x0001 << N) - 0x0001;\n-    typename vtype::zmm_t zmm =\n-        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n-    vtype::mask_storeu(arr, load_mask, sort_zmm_32bit<vtype>(zmm));\n-}\n+        if constexpr (scale == 2) {\n+            v = _mm512_shuffle_epi32(v, (_MM_PERM_ENUM)0b10110001);\n+        } else if constexpr (scale == 4) {\n+            v = _mm512_shuffle_epi32(v, (_MM_PERM_ENUM)0b01001110);\n+        } else if constexpr (scale == 8) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b10110001);\n+        } else if constexpr (scale == 16) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b01001110);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n@@ -295,46 +288,2 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_32_32bit(type_t *arr, int32_t N) {\n-    if (N <= 16) {\n-        sort_16_32bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    zmm_t zmm1 = vtype::loadu(arr);\n-    typename vtype::opmask_t load_mask = (0x0001 << (N - 16)) - 0x0001;\n-    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 16);\n-    zmm1 = sort_zmm_32bit<vtype>(zmm1);\n-    zmm2 = sort_zmm_32bit<vtype>(zmm2);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm1, &zmm2);\n-    vtype::storeu(arr, zmm1);\n-    vtype::mask_storeu(arr + 16, load_mask, zmm2);\n-}\n-\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_64_32bit(type_t *arr, int32_t N) {\n-    if (N <= 32) {\n-        sort_32_32bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[4];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 16);\n-    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n-    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n-    load_mask1 &= combined_mask & 0xFFFF;\n-    load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n-    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n-    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 48);\n-    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n-    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 16, zmm[1]);\n-    vtype::mask_storeu(arr + 32, load_mask1, zmm[2]);\n-    vtype::mask_storeu(arr + 48, load_mask2, zmm[3]);\n-}\n+        return vtype::cast_from(v);\n+    }\n@@ -342,50 +291,4 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_128_32bit(type_t *arr, int32_t N) {\n-    if (N <= 64) {\n-        sort_64_32bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[8];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 16);\n-    zmm[2] = vtype::loadu(arr + 32);\n-    zmm[3] = vtype::loadu(arr + 48);\n-    zmm[0] = sort_zmm_32bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_32bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_32bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_32bit<vtype>(zmm[3]);\n-    opmask_t load_mask1 = 0xFFFF, load_mask2 = 0xFFFF;\n-    opmask_t load_mask3 = 0xFFFF, load_mask4 = 0xFFFF;\n-    if (N != 128) {\n-        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n-        load_mask1 &= combined_mask & 0xFFFF;\n-        load_mask2 &= (combined_mask >> 16) & 0xFFFF;\n-        load_mask3 &= (combined_mask >> 32) & 0xFFFF;\n-        load_mask4 &= (combined_mask >> 48) & 0xFFFF;\n-    }\n-    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n-    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 80);\n-    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 96);\n-    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 112);\n-    zmm[4] = sort_zmm_32bit<vtype>(zmm[4]);\n-    zmm[5] = sort_zmm_32bit<vtype>(zmm[5]);\n-    zmm[6] = sort_zmm_32bit<vtype>(zmm[6]);\n-    zmm[7] = sort_zmm_32bit<vtype>(zmm[7]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[0], &zmm[1]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[2], &zmm[3]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[4], &zmm[5]);\n-    bitonic_merge_two_zmm_32bit<vtype>(&zmm[6], &zmm[7]);\n-    bitonic_merge_four_zmm_32bit<vtype>(zmm);\n-    bitonic_merge_four_zmm_32bit<vtype>(zmm + 4);\n-    bitonic_merge_eight_zmm_32bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 16, zmm[1]);\n-    vtype::storeu(arr + 32, zmm[2]);\n-    vtype::storeu(arr + 48, zmm[3]);\n-    vtype::mask_storeu(arr + 64, load_mask1, zmm[4]);\n-    vtype::mask_storeu(arr + 80, load_mask2, zmm[5]);\n-    vtype::mask_storeu(arr + 96, load_mask3, zmm[6]);\n-    vtype::mask_storeu(arr + 112, load_mask4, zmm[7]);\n-}\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t reverse_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n@@ -393,0 +296,15 @@\n+        if constexpr (scale == 2) {\n+            return swap_n<vtype, 2>(reg);\n+        } else if constexpr (scale == 4) {\n+            __m512i mask = _mm512_set_epi32(12, 13, 14, 15, 8, 9, 10, 11, 4, 5,\n+                                            6, 7, 0, 1, 2, 3);\n+            v = _mm512_permutexvar_epi32(mask, v);\n+        } else if constexpr (scale == 8) {\n+            __m512i mask = _mm512_set_epi32(8, 9, 10, 11, 12, 13, 14, 15, 0, 1,\n+                                            2, 3, 4, 5, 6, 7);\n+            v = _mm512_permutexvar_epi32(mask, v);\n+        } else if constexpr (scale == 16) {\n+            return vtype::reverse(reg);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n@@ -394,16 +312,1 @@\n-template <typename vtype, typename type_t>\n-static void qsort_32bit_(type_t *arr, int64_t left, int64_t right,\n-                         int64_t max_iters) {\n-    \/*\n-     * Resort to std::sort if quicksort isnt making any progress\n-     *\/\n-    if (max_iters <= 0) {\n-        std::sort(arr + left, arr + right + 1);\n-        return;\n-    }\n-    \/*\n-     * Base case: use bitonic networks to sort arrays <= 128\n-     *\/\n-    if (right + 1 - left <= 128) {\n-        sort_128_32bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n-        return;\n+        return vtype::cast_from(v);\n@@ -412,10 +315,5 @@\n-    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n-    type_t smallest = vtype::type_max();\n-    type_t biggest = vtype::type_min();\n-    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n-        arr, left, right + 1, pivot, &smallest, &biggest, false);\n-    if (pivot != smallest)\n-        qsort_32bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n-    if (pivot != biggest)\n-        qsort_32bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n-}\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t merge_n(\n+        typename vtype::reg_t reg, typename vtype::reg_t other) {\n+        __m512i v1 = vtype::cast_to(reg);\n+        __m512i v2 = vtype::cast_to(other);\n@@ -423,8 +321,11 @@\n-template <>\n-void inline avx512_qsort<int32_t>(int32_t *arr, int64_t fromIndex, int64_t toIndex) {\n-    int64_t arrsize = toIndex - fromIndex;\n-    if (arrsize > 1) {\n-        qsort_32bit_<zmm_vector<int32_t>, int32_t>(arr, fromIndex, toIndex - 1,\n-                                                   2 * (int64_t)log2(arrsize));\n-    }\n-}\n+        if constexpr (scale == 2) {\n+            v1 = _mm512_mask_blend_epi32(0b0101010101010101, v1, v2);\n+        } else if constexpr (scale == 4) {\n+            v1 = _mm512_mask_blend_epi32(0b0011001100110011, v1, v2);\n+        } else if constexpr (scale == 8) {\n+            v1 = _mm512_mask_blend_epi32(0b0000111100001111, v1, v2);\n+        } else if constexpr (scale == 16) {\n+            v1 = _mm512_mask_blend_epi32(0b0000000011111111, v1, v2);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n@@ -432,6 +333,1 @@\n-template <>\n-void inline avx512_qsort<float>(float *arr, int64_t fromIndex, int64_t toIndex) {\n-    int64_t arrsize = toIndex - fromIndex;\n-    if (arrsize > 1) {\n-        qsort_32bit_<zmm_vector<float>, float>(arr, fromIndex, toIndex - 1,\n-                                               2 * (int64_t)log2(arrsize));\n+        return vtype::cast_from(v1);\n@@ -439,1 +335,1 @@\n-}\n+};\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-32bit-qsort.hpp","additions":179,"deletions":283,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n-\n-#ifndef AVX512_64BIT_COMMON\n-#define AVX512_64BIT_COMMON\n-#include \"avx512-common-qsort.h\"\n-\n-\/*\n- * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n- * sorting network (see\n- * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n- *\/\n-\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n-#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n-#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n-#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n-#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n-\n-template <>\n-struct zmm_vector<int64_t> {\n-    using type_t = int64_t;\n-    using zmm_t = __m512i;\n-    using zmmi_t = __m512i;\n-    using ymm_t = __m512i;\n-    using opmask_t = __mmask8;\n-    static const uint8_t numlanes = 8;\n-\n-    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n-    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n-    static zmm_t zmm_max() {\n-        return _mm512_set1_epi64(type_max());\n-    }  \/\/ TODO: this should broadcast bits as is?\n-\n-    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n-                       int v8) {\n-        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n-        return _kxor_mask8(x, y);\n-    }\n-    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n-    static opmask_t le(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n-    }\n-    static opmask_t ge(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n-    }\n-    static opmask_t gt(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n-    }\n-    static opmask_t eq(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n-    }\n-    template <int scale>\n-    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n-                                void const *base) {\n-        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n-    }\n-    template <int scale>\n-    static zmm_t i64gather(__m512i index, void const *base) {\n-        return _mm512_i64gather_epi64(index, base, scale);\n-    }\n-    static zmm_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n-    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_epi64(x, y); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n-        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n-    }\n-    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n-        return _mm512_maskz_loadu_epi64(mask, mem);\n-    }\n-    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n-        return _mm512_mask_loadu_epi64(x, mask, mem);\n-    }\n-    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n-        return _mm512_mask_mov_epi64(x, mask, y);\n-    }\n-    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n-        return _mm512_mask_storeu_epi64(mem, mask, x);\n-    }\n-    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_epi64(x, y); }\n-    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n-        return _mm512_permutexvar_epi64(idx, zmm);\n-    }\n-    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_epi64(v); }\n-    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_epi64(v); }\n-    static zmm_t set1(type_t v) { return _mm512_set1_epi64(v); }\n-    template <uint8_t mask>\n-    static zmm_t shuffle(zmm_t zmm) {\n-        __m512d temp = _mm512_castsi512_pd(zmm);\n-        return _mm512_castpd_si512(\n-            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n-    }\n-    static void storeu(void *mem, zmm_t x) { _mm512_storeu_si512(mem, x); }\n-};\n-template <>\n-struct zmm_vector<double> {\n-    using type_t = double;\n-    using zmm_t = __m512d;\n-    using zmmi_t = __m512i;\n-    using ymm_t = __m512d;\n-    using opmask_t = __mmask8;\n-    static const uint8_t numlanes = 8;\n-\n-    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n-    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n-    static zmm_t zmm_max() { return _mm512_set1_pd(type_max()); }\n-\n-    static zmmi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n-                       int v8) {\n-        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n-    }\n-\n-    static zmm_t maskz_loadu(opmask_t mask, void const *mem) {\n-        return _mm512_maskz_loadu_pd(mask, mem);\n-    }\n-    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n-    static opmask_t ge(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n-    }\n-    static opmask_t gt(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n-    }\n-    static opmask_t eq(zmm_t x, zmm_t y) {\n-        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n-    }\n-    template <int type>\n-    static opmask_t fpclass(zmm_t x) {\n-        return _mm512_fpclass_pd_mask(x, type);\n-    }\n-    template <int scale>\n-    static zmm_t mask_i64gather(zmm_t src, opmask_t mask, __m512i index,\n-                                void const *base) {\n-        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n-    }\n-    template <int scale>\n-    static zmm_t i64gather(__m512i index, void const *base) {\n-        return _mm512_i64gather_pd(index, base, scale);\n-    }\n-    static zmm_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n-    static zmm_t max(zmm_t x, zmm_t y) { return _mm512_max_pd(x, y); }\n-    static void mask_compressstoreu(void *mem, opmask_t mask, zmm_t x) {\n-        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n-    }\n-    static zmm_t mask_loadu(zmm_t x, opmask_t mask, void const *mem) {\n-        return _mm512_mask_loadu_pd(x, mask, mem);\n-    }\n-    static zmm_t mask_mov(zmm_t x, opmask_t mask, zmm_t y) {\n-        return _mm512_mask_mov_pd(x, mask, y);\n-    }\n-    static void mask_storeu(void *mem, opmask_t mask, zmm_t x) {\n-        return _mm512_mask_storeu_pd(mem, mask, x);\n-    }\n-    static zmm_t min(zmm_t x, zmm_t y) { return _mm512_min_pd(x, y); }\n-    static zmm_t permutexvar(__m512i idx, zmm_t zmm) {\n-        return _mm512_permutexvar_pd(idx, zmm);\n-    }\n-    static type_t reducemax(zmm_t v) { return _mm512_reduce_max_pd(v); }\n-    static type_t reducemin(zmm_t v) { return _mm512_reduce_min_pd(v); }\n-    static zmm_t set1(type_t v) { return _mm512_set1_pd(v); }\n-    template <uint8_t mask>\n-    static zmm_t shuffle(zmm_t zmm) {\n-        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n-    }\n-    static void storeu(void *mem, zmm_t x) { _mm512_storeu_pd(mem, x); }\n-};\n-\n-\/*\n- * Assumes zmm is random and performs a full sorting network defined in\n- * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n- *\/\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE zmm_t sort_zmm_64bit(zmm_t zmm) {\n-    const typename vtype::zmmi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n-    zmm = cmp_merge<vtype>(\n-        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n-    return zmm;\n-}\n-\n-\n-#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-common.h","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"avx512-64bit-common.h\"\n+#include \"xss-common-includes.h\"\n+#include \"xss-common-qsort.h\"\n@@ -32,4 +33,242 @@\n-\/\/ Assumes zmm is bitonic and performs a recursive half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE zmm_t bitonic_merge_zmm_64bit(zmm_t zmm) {\n-    \/\/ 1) half_cleaner[8]: compare 0-4, 1-5, 2-6, 3-7\n+\/*\n+ * Constants used in sorting 8 elements in a ZMM registers. Based on Bitonic\n+ * sorting network (see\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg)\n+ *\/\n+\/\/ ZMM                  7, 6, 5, 4, 3, 2, 1, 0\n+#define NETWORK_64BIT_1 4, 5, 6, 7, 0, 1, 2, 3\n+#define NETWORK_64BIT_2 0, 1, 2, 3, 4, 5, 6, 7\n+#define NETWORK_64BIT_3 5, 4, 7, 6, 1, 0, 3, 2\n+#define NETWORK_64BIT_4 3, 2, 1, 0, 7, 6, 5, 4\n+\n+template <typename vtype, typename reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm);\n+\n+struct avx512_64bit_swizzle_ops;\n+\n+template <>\n+struct zmm_vector<int64_t> {\n+    using type_t = int64_t;\n+    using reg_t = __m512i;\n+    using regi_t = __m512i;\n+    using halfreg_t = __m512i;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_64bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_MAX_INT64; }\n+    static type_t type_min() { return X86_SIMD_SORT_MIN_INT64; }\n+    static reg_t zmm_max() {\n+        return _mm512_set1_epi64(type_max());\n+    }  \/\/ TODO: this should broadcast bits as is?\n+\n+    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n+                     type_t v6, type_t v7, type_t v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static opmask_t kxor_opmask(opmask_t x, opmask_t y) {\n+        return _kxor_mask8(x, y);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t le(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_LE);\n+    }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_NLT);\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_GT);\n+    }\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n+    static opmask_t eq(reg_t x, reg_t y) {\n+        return _mm512_cmp_epi64_mask(x, y, _MM_CMPINT_EQ);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_epi64(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm512_mask_i32gather_epi64(src, mask, index, base, scale);\n+    }\n+    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n+        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n+                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n+    }\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_si512(mem); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_epi64(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_compressstoreu_epi64(mem, mask, x);\n+    }\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_epi64(mask, mem);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_epi64(x, mask, mem);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm512_mask_mov_epi64(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_storeu_epi64(mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_epi64(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n+        return _mm512_permutexvar_epi64(idx, zmm);\n+    }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_epi64(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_epi64(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_epi64(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t zmm) {\n+        __m512d temp = _mm512_castsi512_pd(zmm);\n+        return _mm512_castpd_si512(\n+            _mm512_shuffle_pd(temp, temp, (_MM_PERM_ENUM)mask));\n+    }\n+    static void storeu(void *mem, reg_t x) { _mm512_storeu_si512(mem, x); }\n+    static reg_t reverse(reg_t zmm) {\n+        const regi_t rev_index = seti(NETWORK_64BIT_2);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return v; }\n+    static __m512i cast_to(reg_t v) { return v; }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n+};\n+template <>\n+struct zmm_vector<double> {\n+    using type_t = double;\n+    using reg_t = __m512d;\n+    using regi_t = __m512i;\n+    using halfreg_t = __m512d;\n+    using opmask_t = __mmask8;\n+    static const uint8_t numlanes = 8;\n+#ifdef XSS_MINIMAL_NETWORK_SORT\n+    static constexpr int network_sort_threshold = numlanes;\n+#else\n+    static constexpr int network_sort_threshold = 256;\n+#endif\n+    static constexpr int partition_unroll_factor = 8;\n+\n+    using swizzle_ops = avx512_64bit_swizzle_ops;\n+\n+    static type_t type_max() { return X86_SIMD_SORT_INFINITY; }\n+    static type_t type_min() { return -X86_SIMD_SORT_INFINITY; }\n+    static reg_t zmm_max() { return _mm512_set1_pd(type_max()); }\n+    static regi_t seti(int v1, int v2, int v3, int v4, int v5, int v6, int v7,\n+                       int v8) {\n+        return _mm512_set_epi64(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t set(type_t v1, type_t v2, type_t v3, type_t v4, type_t v5,\n+                     type_t v6, type_t v7, type_t v8) {\n+        return _mm512_set_pd(v1, v2, v3, v4, v5, v6, v7, v8);\n+    }\n+    static reg_t maskz_loadu(opmask_t mask, void const *mem) {\n+        return _mm512_maskz_loadu_pd(mask, mem);\n+    }\n+    static opmask_t knot_opmask(opmask_t x) { return _knot_mask8(x); }\n+    static opmask_t ge(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GE_OQ);\n+    }\n+    static opmask_t gt(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_GT_OQ);\n+    }\n+    static opmask_t eq(reg_t x, reg_t y) {\n+        return _mm512_cmp_pd_mask(x, y, _CMP_EQ_OQ);\n+    }\n+    static opmask_t get_partial_loadmask(uint64_t num_to_read) {\n+        return ((0x1ull << num_to_read) - 0x1ull);\n+    }\n+    static int32_t convert_mask_to_int(opmask_t mask) { return mask; }\n+    template <int type>\n+    static opmask_t fpclass(reg_t x) {\n+        return _mm512_fpclass_pd_mask(x, type);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m512i index,\n+                                void const *base) {\n+        return _mm512_mask_i64gather_pd(src, mask, index, base, scale);\n+    }\n+    template <int scale>\n+    static reg_t mask_i64gather(reg_t src, opmask_t mask, __m256i index,\n+                                void const *base) {\n+        return _mm512_mask_i32gather_pd(src, mask, index, base, scale);\n+    }\n+    static reg_t i64gather(type_t *arr, arrsize_t *ind) {\n+        return set(arr[ind[7]], arr[ind[6]], arr[ind[5]], arr[ind[4]],\n+                   arr[ind[3]], arr[ind[2]], arr[ind[1]], arr[ind[0]]);\n+    }\n+    static reg_t loadu(void const *mem) { return _mm512_loadu_pd(mem); }\n+    static reg_t max(reg_t x, reg_t y) { return _mm512_max_pd(x, y); }\n+    static void mask_compressstoreu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_compressstoreu_pd(mem, mask, x);\n+    }\n+    static reg_t mask_loadu(reg_t x, opmask_t mask, void const *mem) {\n+        return _mm512_mask_loadu_pd(x, mask, mem);\n+    }\n+    static reg_t mask_mov(reg_t x, opmask_t mask, reg_t y) {\n+        return _mm512_mask_mov_pd(x, mask, y);\n+    }\n+    static void mask_storeu(void *mem, opmask_t mask, reg_t x) {\n+        return _mm512_mask_storeu_pd(mem, mask, x);\n+    }\n+    static reg_t min(reg_t x, reg_t y) { return _mm512_min_pd(x, y); }\n+    static reg_t permutexvar(__m512i idx, reg_t zmm) {\n+        return _mm512_permutexvar_pd(idx, zmm);\n+    }\n+    static type_t reducemax(reg_t v) { return _mm512_reduce_max_pd(v); }\n+    static type_t reducemin(reg_t v) { return _mm512_reduce_min_pd(v); }\n+    static reg_t set1(type_t v) { return _mm512_set1_pd(v); }\n+    template <uint8_t mask>\n+    static reg_t shuffle(reg_t zmm) {\n+        return _mm512_shuffle_pd(zmm, zmm, (_MM_PERM_ENUM)mask);\n+    }\n+    static void storeu(void *mem, reg_t x) { _mm512_storeu_pd(mem, x); }\n+    static reg_t reverse(reg_t zmm) {\n+        const regi_t rev_index = seti(NETWORK_64BIT_2);\n+        return permutexvar(rev_index, zmm);\n+    }\n+    static reg_t sort_vec(reg_t x) {\n+        return sort_zmm_64bit<zmm_vector<type_t>>(x);\n+    }\n+    static reg_t cast_from(__m512i v) { return _mm512_castsi512_pd(v); }\n+    static __m512i cast_to(reg_t v) { return _mm512_castpd_si512(v); }\n+    static int double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                    opmask_t k, reg_t reg) {\n+        return avx512_double_compressstore<zmm_vector<type_t>>(\n+            left_addr, right_addr, k, reg);\n+    }\n+};\n+\n+\/*\n+ * Assumes zmm is random and performs a full sorting network defined in\n+ * https:\/\/en.wikipedia.org\/wiki\/Bitonic_sorter#\/media\/File:BitonicSort.svg\n+ *\/\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE reg_t sort_zmm_64bit(reg_t zmm) {\n+    const typename vtype::regi_t rev_index = vtype::seti(NETWORK_64BIT_2);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_1), zmm), 0xCC);\n@@ -37,2 +276,2 @@\n-        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_4), zmm), 0xF0);\n-    \/\/ 2) half_cleaner[4]\n+        zmm, vtype::template shuffle<SHUFFLE_MASK(1, 1, 1, 1)>(zmm), 0xAA);\n+    zmm = cmp_merge<vtype>(zmm, vtype::permutexvar(rev_index, zmm), 0xF0);\n@@ -40,2 +279,1 @@\n-        zmm, vtype::permutexvar(_mm512_set_epi64(NETWORK_64BIT_3), zmm), 0xCC);\n-    \/\/ 3) half_cleaner[1]\n+        zmm, vtype::permutexvar(vtype::seti(NETWORK_64BIT_3), zmm), 0xCC);\n@@ -46,139 +284,0 @@\n-\/\/ Assumes zmm1 and zmm2 are sorted and performs a recursive half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_two_zmm_64bit(zmm_t &zmm1,\n-                                                      zmm_t &zmm2) {\n-    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n-    \/\/ 1) First step of a merging network: coex of zmm1 and zmm2 reversed\n-    zmm2 = vtype::permutexvar(rev_index, zmm2);\n-    zmm_t zmm3 = vtype::min(zmm1, zmm2);\n-    zmm_t zmm4 = vtype::max(zmm1, zmm2);\n-    \/\/ 2) Recursive half cleaner for each\n-    zmm1 = bitonic_merge_zmm_64bit<vtype>(zmm3);\n-    zmm2 = bitonic_merge_zmm_64bit<vtype>(zmm4);\n-}\n-\/\/ Assumes [zmm0, zmm1] and [zmm2, zmm3] are sorted and performs a recursive\n-\/\/ half cleaner\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_four_zmm_64bit(zmm_t *zmm) {\n-    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n-    \/\/ 1) First step of a merging network\n-    zmm_t zmm2r = vtype::permutexvar(rev_index, zmm[2]);\n-    zmm_t zmm3r = vtype::permutexvar(rev_index, zmm[3]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm3r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm2r);\n-    \/\/ 2) Recursive half clearer: 16\n-    zmm_t zmm_t3 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm2r));\n-    zmm_t zmm_t4 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm3r));\n-    zmm_t zmm0 = vtype::min(zmm_t1, zmm_t2);\n-    zmm_t zmm1 = vtype::max(zmm_t1, zmm_t2);\n-    zmm_t zmm2 = vtype::min(zmm_t3, zmm_t4);\n-    zmm_t zmm3 = vtype::max(zmm_t3, zmm_t4);\n-    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm0);\n-    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm1);\n-    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm2);\n-    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm3);\n-}\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_eight_zmm_64bit(zmm_t *zmm) {\n-    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n-    zmm_t zmm4r = vtype::permutexvar(rev_index, zmm[4]);\n-    zmm_t zmm5r = vtype::permutexvar(rev_index, zmm[5]);\n-    zmm_t zmm6r = vtype::permutexvar(rev_index, zmm[6]);\n-    zmm_t zmm7r = vtype::permutexvar(rev_index, zmm[7]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm7r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm6r);\n-    zmm_t zmm_t3 = vtype::min(zmm[2], zmm5r);\n-    zmm_t zmm_t4 = vtype::min(zmm[3], zmm4r);\n-    zmm_t zmm_t5 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm4r));\n-    zmm_t zmm_t6 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm5r));\n-    zmm_t zmm_t7 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm6r));\n-    zmm_t zmm_t8 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm7r));\n-    COEX<vtype>(zmm_t1, zmm_t3);\n-    COEX<vtype>(zmm_t2, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t7);\n-    COEX<vtype>(zmm_t6, zmm_t8);\n-    COEX<vtype>(zmm_t1, zmm_t2);\n-    COEX<vtype>(zmm_t3, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t6);\n-    COEX<vtype>(zmm_t7, zmm_t8);\n-    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n-    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n-    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n-    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n-    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n-    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n-    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n-    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n-}\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_sixteen_zmm_64bit(zmm_t *zmm) {\n-    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n-    zmm_t zmm8r = vtype::permutexvar(rev_index, zmm[8]);\n-    zmm_t zmm9r = vtype::permutexvar(rev_index, zmm[9]);\n-    zmm_t zmm10r = vtype::permutexvar(rev_index, zmm[10]);\n-    zmm_t zmm11r = vtype::permutexvar(rev_index, zmm[11]);\n-    zmm_t zmm12r = vtype::permutexvar(rev_index, zmm[12]);\n-    zmm_t zmm13r = vtype::permutexvar(rev_index, zmm[13]);\n-    zmm_t zmm14r = vtype::permutexvar(rev_index, zmm[14]);\n-    zmm_t zmm15r = vtype::permutexvar(rev_index, zmm[15]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm15r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm14r);\n-    zmm_t zmm_t3 = vtype::min(zmm[2], zmm13r);\n-    zmm_t zmm_t4 = vtype::min(zmm[3], zmm12r);\n-    zmm_t zmm_t5 = vtype::min(zmm[4], zmm11r);\n-    zmm_t zmm_t6 = vtype::min(zmm[5], zmm10r);\n-    zmm_t zmm_t7 = vtype::min(zmm[6], zmm9r);\n-    zmm_t zmm_t8 = vtype::min(zmm[7], zmm8r);\n-    zmm_t zmm_t9 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm8r));\n-    zmm_t zmm_t10 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm9r));\n-    zmm_t zmm_t11 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm10r));\n-    zmm_t zmm_t12 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm11r));\n-    zmm_t zmm_t13 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm12r));\n-    zmm_t zmm_t14 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm13r));\n-    zmm_t zmm_t15 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm14r));\n-    zmm_t zmm_t16 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm15r));\n-    \/\/ Recusive half clear 16 zmm regs\n-    COEX<vtype>(zmm_t1, zmm_t5);\n-    COEX<vtype>(zmm_t2, zmm_t6);\n-    COEX<vtype>(zmm_t3, zmm_t7);\n-    COEX<vtype>(zmm_t4, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t13);\n-    COEX<vtype>(zmm_t10, zmm_t14);\n-    COEX<vtype>(zmm_t11, zmm_t15);\n-    COEX<vtype>(zmm_t12, zmm_t16);\n-    \/\/\n-    COEX<vtype>(zmm_t1, zmm_t3);\n-    COEX<vtype>(zmm_t2, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t7);\n-    COEX<vtype>(zmm_t6, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t11);\n-    COEX<vtype>(zmm_t10, zmm_t12);\n-    COEX<vtype>(zmm_t13, zmm_t15);\n-    COEX<vtype>(zmm_t14, zmm_t16);\n-    \/\/\n-    COEX<vtype>(zmm_t1, zmm_t2);\n-    COEX<vtype>(zmm_t3, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t6);\n-    COEX<vtype>(zmm_t7, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t10);\n-    COEX<vtype>(zmm_t11, zmm_t12);\n-    COEX<vtype>(zmm_t13, zmm_t14);\n-    COEX<vtype>(zmm_t15, zmm_t16);\n-    \/\/\n-    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n-    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n-    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n-    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n-    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n-    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n-    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n-    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n-    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n-    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n-    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n-    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n-    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n-    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n-    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n-    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n-}\n@@ -186,153 +285,5 @@\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t>\n-X86_SIMD_SORT_INLINE void bitonic_merge_32_zmm_64bit(zmm_t *zmm) {\n-    const __m512i rev_index = _mm512_set_epi64(NETWORK_64BIT_2);\n-    zmm_t zmm16r = vtype::permutexvar(rev_index, zmm[16]);\n-    zmm_t zmm17r = vtype::permutexvar(rev_index, zmm[17]);\n-    zmm_t zmm18r = vtype::permutexvar(rev_index, zmm[18]);\n-    zmm_t zmm19r = vtype::permutexvar(rev_index, zmm[19]);\n-    zmm_t zmm20r = vtype::permutexvar(rev_index, zmm[20]);\n-    zmm_t zmm21r = vtype::permutexvar(rev_index, zmm[21]);\n-    zmm_t zmm22r = vtype::permutexvar(rev_index, zmm[22]);\n-    zmm_t zmm23r = vtype::permutexvar(rev_index, zmm[23]);\n-    zmm_t zmm24r = vtype::permutexvar(rev_index, zmm[24]);\n-    zmm_t zmm25r = vtype::permutexvar(rev_index, zmm[25]);\n-    zmm_t zmm26r = vtype::permutexvar(rev_index, zmm[26]);\n-    zmm_t zmm27r = vtype::permutexvar(rev_index, zmm[27]);\n-    zmm_t zmm28r = vtype::permutexvar(rev_index, zmm[28]);\n-    zmm_t zmm29r = vtype::permutexvar(rev_index, zmm[29]);\n-    zmm_t zmm30r = vtype::permutexvar(rev_index, zmm[30]);\n-    zmm_t zmm31r = vtype::permutexvar(rev_index, zmm[31]);\n-    zmm_t zmm_t1 = vtype::min(zmm[0], zmm31r);\n-    zmm_t zmm_t2 = vtype::min(zmm[1], zmm30r);\n-    zmm_t zmm_t3 = vtype::min(zmm[2], zmm29r);\n-    zmm_t zmm_t4 = vtype::min(zmm[3], zmm28r);\n-    zmm_t zmm_t5 = vtype::min(zmm[4], zmm27r);\n-    zmm_t zmm_t6 = vtype::min(zmm[5], zmm26r);\n-    zmm_t zmm_t7 = vtype::min(zmm[6], zmm25r);\n-    zmm_t zmm_t8 = vtype::min(zmm[7], zmm24r);\n-    zmm_t zmm_t9 = vtype::min(zmm[8], zmm23r);\n-    zmm_t zmm_t10 = vtype::min(zmm[9], zmm22r);\n-    zmm_t zmm_t11 = vtype::min(zmm[10], zmm21r);\n-    zmm_t zmm_t12 = vtype::min(zmm[11], zmm20r);\n-    zmm_t zmm_t13 = vtype::min(zmm[12], zmm19r);\n-    zmm_t zmm_t14 = vtype::min(zmm[13], zmm18r);\n-    zmm_t zmm_t15 = vtype::min(zmm[14], zmm17r);\n-    zmm_t zmm_t16 = vtype::min(zmm[15], zmm16r);\n-    zmm_t zmm_t17 = vtype::permutexvar(rev_index, vtype::max(zmm[15], zmm16r));\n-    zmm_t zmm_t18 = vtype::permutexvar(rev_index, vtype::max(zmm[14], zmm17r));\n-    zmm_t zmm_t19 = vtype::permutexvar(rev_index, vtype::max(zmm[13], zmm18r));\n-    zmm_t zmm_t20 = vtype::permutexvar(rev_index, vtype::max(zmm[12], zmm19r));\n-    zmm_t zmm_t21 = vtype::permutexvar(rev_index, vtype::max(zmm[11], zmm20r));\n-    zmm_t zmm_t22 = vtype::permutexvar(rev_index, vtype::max(zmm[10], zmm21r));\n-    zmm_t zmm_t23 = vtype::permutexvar(rev_index, vtype::max(zmm[9], zmm22r));\n-    zmm_t zmm_t24 = vtype::permutexvar(rev_index, vtype::max(zmm[8], zmm23r));\n-    zmm_t zmm_t25 = vtype::permutexvar(rev_index, vtype::max(zmm[7], zmm24r));\n-    zmm_t zmm_t26 = vtype::permutexvar(rev_index, vtype::max(zmm[6], zmm25r));\n-    zmm_t zmm_t27 = vtype::permutexvar(rev_index, vtype::max(zmm[5], zmm26r));\n-    zmm_t zmm_t28 = vtype::permutexvar(rev_index, vtype::max(zmm[4], zmm27r));\n-    zmm_t zmm_t29 = vtype::permutexvar(rev_index, vtype::max(zmm[3], zmm28r));\n-    zmm_t zmm_t30 = vtype::permutexvar(rev_index, vtype::max(zmm[2], zmm29r));\n-    zmm_t zmm_t31 = vtype::permutexvar(rev_index, vtype::max(zmm[1], zmm30r));\n-    zmm_t zmm_t32 = vtype::permutexvar(rev_index, vtype::max(zmm[0], zmm31r));\n-    \/\/ Recusive half clear 16 zmm regs\n-    COEX<vtype>(zmm_t1, zmm_t9);\n-    COEX<vtype>(zmm_t2, zmm_t10);\n-    COEX<vtype>(zmm_t3, zmm_t11);\n-    COEX<vtype>(zmm_t4, zmm_t12);\n-    COEX<vtype>(zmm_t5, zmm_t13);\n-    COEX<vtype>(zmm_t6, zmm_t14);\n-    COEX<vtype>(zmm_t7, zmm_t15);\n-    COEX<vtype>(zmm_t8, zmm_t16);\n-    COEX<vtype>(zmm_t17, zmm_t25);\n-    COEX<vtype>(zmm_t18, zmm_t26);\n-    COEX<vtype>(zmm_t19, zmm_t27);\n-    COEX<vtype>(zmm_t20, zmm_t28);\n-    COEX<vtype>(zmm_t21, zmm_t29);\n-    COEX<vtype>(zmm_t22, zmm_t30);\n-    COEX<vtype>(zmm_t23, zmm_t31);\n-    COEX<vtype>(zmm_t24, zmm_t32);\n-    \/\/\n-    COEX<vtype>(zmm_t1, zmm_t5);\n-    COEX<vtype>(zmm_t2, zmm_t6);\n-    COEX<vtype>(zmm_t3, zmm_t7);\n-    COEX<vtype>(zmm_t4, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t13);\n-    COEX<vtype>(zmm_t10, zmm_t14);\n-    COEX<vtype>(zmm_t11, zmm_t15);\n-    COEX<vtype>(zmm_t12, zmm_t16);\n-    COEX<vtype>(zmm_t17, zmm_t21);\n-    COEX<vtype>(zmm_t18, zmm_t22);\n-    COEX<vtype>(zmm_t19, zmm_t23);\n-    COEX<vtype>(zmm_t20, zmm_t24);\n-    COEX<vtype>(zmm_t25, zmm_t29);\n-    COEX<vtype>(zmm_t26, zmm_t30);\n-    COEX<vtype>(zmm_t27, zmm_t31);\n-    COEX<vtype>(zmm_t28, zmm_t32);\n-    \/\/\n-    COEX<vtype>(zmm_t1, zmm_t3);\n-    COEX<vtype>(zmm_t2, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t7);\n-    COEX<vtype>(zmm_t6, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t11);\n-    COEX<vtype>(zmm_t10, zmm_t12);\n-    COEX<vtype>(zmm_t13, zmm_t15);\n-    COEX<vtype>(zmm_t14, zmm_t16);\n-    COEX<vtype>(zmm_t17, zmm_t19);\n-    COEX<vtype>(zmm_t18, zmm_t20);\n-    COEX<vtype>(zmm_t21, zmm_t23);\n-    COEX<vtype>(zmm_t22, zmm_t24);\n-    COEX<vtype>(zmm_t25, zmm_t27);\n-    COEX<vtype>(zmm_t26, zmm_t28);\n-    COEX<vtype>(zmm_t29, zmm_t31);\n-    COEX<vtype>(zmm_t30, zmm_t32);\n-    \/\/\n-    COEX<vtype>(zmm_t1, zmm_t2);\n-    COEX<vtype>(zmm_t3, zmm_t4);\n-    COEX<vtype>(zmm_t5, zmm_t6);\n-    COEX<vtype>(zmm_t7, zmm_t8);\n-    COEX<vtype>(zmm_t9, zmm_t10);\n-    COEX<vtype>(zmm_t11, zmm_t12);\n-    COEX<vtype>(zmm_t13, zmm_t14);\n-    COEX<vtype>(zmm_t15, zmm_t16);\n-    COEX<vtype>(zmm_t17, zmm_t18);\n-    COEX<vtype>(zmm_t19, zmm_t20);\n-    COEX<vtype>(zmm_t21, zmm_t22);\n-    COEX<vtype>(zmm_t23, zmm_t24);\n-    COEX<vtype>(zmm_t25, zmm_t26);\n-    COEX<vtype>(zmm_t27, zmm_t28);\n-    COEX<vtype>(zmm_t29, zmm_t30);\n-    COEX<vtype>(zmm_t31, zmm_t32);\n-    \/\/\n-    zmm[0] = bitonic_merge_zmm_64bit<vtype>(zmm_t1);\n-    zmm[1] = bitonic_merge_zmm_64bit<vtype>(zmm_t2);\n-    zmm[2] = bitonic_merge_zmm_64bit<vtype>(zmm_t3);\n-    zmm[3] = bitonic_merge_zmm_64bit<vtype>(zmm_t4);\n-    zmm[4] = bitonic_merge_zmm_64bit<vtype>(zmm_t5);\n-    zmm[5] = bitonic_merge_zmm_64bit<vtype>(zmm_t6);\n-    zmm[6] = bitonic_merge_zmm_64bit<vtype>(zmm_t7);\n-    zmm[7] = bitonic_merge_zmm_64bit<vtype>(zmm_t8);\n-    zmm[8] = bitonic_merge_zmm_64bit<vtype>(zmm_t9);\n-    zmm[9] = bitonic_merge_zmm_64bit<vtype>(zmm_t10);\n-    zmm[10] = bitonic_merge_zmm_64bit<vtype>(zmm_t11);\n-    zmm[11] = bitonic_merge_zmm_64bit<vtype>(zmm_t12);\n-    zmm[12] = bitonic_merge_zmm_64bit<vtype>(zmm_t13);\n-    zmm[13] = bitonic_merge_zmm_64bit<vtype>(zmm_t14);\n-    zmm[14] = bitonic_merge_zmm_64bit<vtype>(zmm_t15);\n-    zmm[15] = bitonic_merge_zmm_64bit<vtype>(zmm_t16);\n-    zmm[16] = bitonic_merge_zmm_64bit<vtype>(zmm_t17);\n-    zmm[17] = bitonic_merge_zmm_64bit<vtype>(zmm_t18);\n-    zmm[18] = bitonic_merge_zmm_64bit<vtype>(zmm_t19);\n-    zmm[19] = bitonic_merge_zmm_64bit<vtype>(zmm_t20);\n-    zmm[20] = bitonic_merge_zmm_64bit<vtype>(zmm_t21);\n-    zmm[21] = bitonic_merge_zmm_64bit<vtype>(zmm_t22);\n-    zmm[22] = bitonic_merge_zmm_64bit<vtype>(zmm_t23);\n-    zmm[23] = bitonic_merge_zmm_64bit<vtype>(zmm_t24);\n-    zmm[24] = bitonic_merge_zmm_64bit<vtype>(zmm_t25);\n-    zmm[25] = bitonic_merge_zmm_64bit<vtype>(zmm_t26);\n-    zmm[26] = bitonic_merge_zmm_64bit<vtype>(zmm_t27);\n-    zmm[27] = bitonic_merge_zmm_64bit<vtype>(zmm_t28);\n-    zmm[28] = bitonic_merge_zmm_64bit<vtype>(zmm_t29);\n-    zmm[29] = bitonic_merge_zmm_64bit<vtype>(zmm_t30);\n-    zmm[30] = bitonic_merge_zmm_64bit<vtype>(zmm_t31);\n-    zmm[31] = bitonic_merge_zmm_64bit<vtype>(zmm_t32);\n-}\n+struct avx512_64bit_swizzle_ops {\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t swap_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n@@ -340,54 +291,9 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_8_64bit(type_t *arr, int32_t N) {\n-    typename vtype::opmask_t load_mask = (0x01 << N) - 0x01;\n-    typename vtype::zmm_t zmm =\n-        vtype::mask_loadu(vtype::zmm_max(), load_mask, arr);\n-    vtype::mask_storeu(arr, load_mask, sort_zmm_64bit<vtype>(zmm));\n-}\n-\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_16_64bit(type_t *arr, int32_t N) {\n-    if (N <= 8) {\n-        sort_8_64bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    zmm_t zmm1 = vtype::loadu(arr);\n-    typename vtype::opmask_t load_mask = (0x01 << (N - 8)) - 0x01;\n-    zmm_t zmm2 = vtype::mask_loadu(vtype::zmm_max(), load_mask, arr + 8);\n-    zmm1 = sort_zmm_64bit<vtype>(zmm1);\n-    zmm2 = sort_zmm_64bit<vtype>(zmm2);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm1, zmm2);\n-    vtype::storeu(arr, zmm1);\n-    vtype::mask_storeu(arr + 8, load_mask, zmm2);\n-}\n-\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_32_64bit(type_t *arr, int32_t N) {\n-    if (N <= 16) {\n-        sort_16_64bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[4];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 8);\n-    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n-    uint64_t combined_mask = (0x1ull << (N - 16)) - 0x1ull;\n-    load_mask1 = (combined_mask)&0xFF;\n-    load_mask2 = (combined_mask >> 8) & 0xFF;\n-    zmm[2] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 16);\n-    zmm[3] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 24);\n-    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 8, zmm[1]);\n-    vtype::mask_storeu(arr + 16, load_mask1, zmm[2]);\n-    vtype::mask_storeu(arr + 24, load_mask2, zmm[3]);\n-}\n+        if constexpr (scale == 2) {\n+            v = _mm512_shuffle_epi32(v, (_MM_PERM_ENUM)0b01001110);\n+        } else if constexpr (scale == 4) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b10110001);\n+        } else if constexpr (scale == 8) {\n+            v = _mm512_shuffle_i64x2(v, v, 0b01001110);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n@@ -395,49 +301,2 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_64_64bit(type_t *arr, int32_t N) {\n-    if (N <= 32) {\n-        sort_32_64bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[8];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 8);\n-    zmm[2] = vtype::loadu(arr + 16);\n-    zmm[3] = vtype::loadu(arr + 24);\n-    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n-    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n-    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n-    \/\/ N-32 >= 1\n-    uint64_t combined_mask = (0x1ull << (N - 32)) - 0x1ull;\n-    load_mask1 = (combined_mask)&0xFF;\n-    load_mask2 = (combined_mask >> 8) & 0xFF;\n-    load_mask3 = (combined_mask >> 16) & 0xFF;\n-    load_mask4 = (combined_mask >> 24) & 0xFF;\n-    zmm[4] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 32);\n-    zmm[5] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 40);\n-    zmm[6] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 48);\n-    zmm[7] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 56);\n-    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n-    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n-    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n-    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 8, zmm[1]);\n-    vtype::storeu(arr + 16, zmm[2]);\n-    vtype::storeu(arr + 24, zmm[3]);\n-    vtype::mask_storeu(arr + 32, load_mask1, zmm[4]);\n-    vtype::mask_storeu(arr + 40, load_mask2, zmm[5]);\n-    vtype::mask_storeu(arr + 48, load_mask3, zmm[6]);\n-    vtype::mask_storeu(arr + 56, load_mask4, zmm[7]);\n-}\n+        return vtype::cast_from(v);\n+    }\n@@ -445,88 +304,4 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_128_64bit(type_t *arr, int32_t N) {\n-    if (N <= 64) {\n-        sort_64_64bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[16];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 8);\n-    zmm[2] = vtype::loadu(arr + 16);\n-    zmm[3] = vtype::loadu(arr + 24);\n-    zmm[4] = vtype::loadu(arr + 32);\n-    zmm[5] = vtype::loadu(arr + 40);\n-    zmm[6] = vtype::loadu(arr + 48);\n-    zmm[7] = vtype::loadu(arr + 56);\n-    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n-    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n-    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n-    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n-    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n-    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n-    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n-    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n-    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n-    if (N != 128) {\n-        uint64_t combined_mask = (0x1ull << (N - 64)) - 0x1ull;\n-        load_mask1 = (combined_mask)&0xFF;\n-        load_mask2 = (combined_mask >> 8) & 0xFF;\n-        load_mask3 = (combined_mask >> 16) & 0xFF;\n-        load_mask4 = (combined_mask >> 24) & 0xFF;\n-        load_mask5 = (combined_mask >> 32) & 0xFF;\n-        load_mask6 = (combined_mask >> 40) & 0xFF;\n-        load_mask7 = (combined_mask >> 48) & 0xFF;\n-        load_mask8 = (combined_mask >> 56) & 0xFF;\n-    }\n-    zmm[8] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 64);\n-    zmm[9] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 72);\n-    zmm[10] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 80);\n-    zmm[11] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 88);\n-    zmm[12] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 96);\n-    zmm[13] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 104);\n-    zmm[14] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 112);\n-    zmm[15] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 120);\n-    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n-    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n-    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n-    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n-    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n-    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n-    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n-    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n-    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 8, zmm[1]);\n-    vtype::storeu(arr + 16, zmm[2]);\n-    vtype::storeu(arr + 24, zmm[3]);\n-    vtype::storeu(arr + 32, zmm[4]);\n-    vtype::storeu(arr + 40, zmm[5]);\n-    vtype::storeu(arr + 48, zmm[6]);\n-    vtype::storeu(arr + 56, zmm[7]);\n-    vtype::mask_storeu(arr + 64, load_mask1, zmm[8]);\n-    vtype::mask_storeu(arr + 72, load_mask2, zmm[9]);\n-    vtype::mask_storeu(arr + 80, load_mask3, zmm[10]);\n-    vtype::mask_storeu(arr + 88, load_mask4, zmm[11]);\n-    vtype::mask_storeu(arr + 96, load_mask5, zmm[12]);\n-    vtype::mask_storeu(arr + 104, load_mask6, zmm[13]);\n-    vtype::mask_storeu(arr + 112, load_mask7, zmm[14]);\n-    vtype::mask_storeu(arr + 120, load_mask8, zmm[15]);\n-}\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t reverse_n(\n+        typename vtype::reg_t reg) {\n+        __m512i v = vtype::cast_to(reg);\n@@ -534,69 +309,7 @@\n-template <typename vtype, typename type_t>\n-X86_SIMD_SORT_INLINE void sort_256_64bit(type_t *arr, int32_t N) {\n-    if (N <= 128) {\n-        sort_128_64bit<vtype>(arr, N);\n-        return;\n-    }\n-    using zmm_t = typename vtype::zmm_t;\n-    using opmask_t = typename vtype::opmask_t;\n-    zmm_t zmm[32];\n-    zmm[0] = vtype::loadu(arr);\n-    zmm[1] = vtype::loadu(arr + 8);\n-    zmm[2] = vtype::loadu(arr + 16);\n-    zmm[3] = vtype::loadu(arr + 24);\n-    zmm[4] = vtype::loadu(arr + 32);\n-    zmm[5] = vtype::loadu(arr + 40);\n-    zmm[6] = vtype::loadu(arr + 48);\n-    zmm[7] = vtype::loadu(arr + 56);\n-    zmm[8] = vtype::loadu(arr + 64);\n-    zmm[9] = vtype::loadu(arr + 72);\n-    zmm[10] = vtype::loadu(arr + 80);\n-    zmm[11] = vtype::loadu(arr + 88);\n-    zmm[12] = vtype::loadu(arr + 96);\n-    zmm[13] = vtype::loadu(arr + 104);\n-    zmm[14] = vtype::loadu(arr + 112);\n-    zmm[15] = vtype::loadu(arr + 120);\n-    zmm[0] = sort_zmm_64bit<vtype>(zmm[0]);\n-    zmm[1] = sort_zmm_64bit<vtype>(zmm[1]);\n-    zmm[2] = sort_zmm_64bit<vtype>(zmm[2]);\n-    zmm[3] = sort_zmm_64bit<vtype>(zmm[3]);\n-    zmm[4] = sort_zmm_64bit<vtype>(zmm[4]);\n-    zmm[5] = sort_zmm_64bit<vtype>(zmm[5]);\n-    zmm[6] = sort_zmm_64bit<vtype>(zmm[6]);\n-    zmm[7] = sort_zmm_64bit<vtype>(zmm[7]);\n-    zmm[8] = sort_zmm_64bit<vtype>(zmm[8]);\n-    zmm[9] = sort_zmm_64bit<vtype>(zmm[9]);\n-    zmm[10] = sort_zmm_64bit<vtype>(zmm[10]);\n-    zmm[11] = sort_zmm_64bit<vtype>(zmm[11]);\n-    zmm[12] = sort_zmm_64bit<vtype>(zmm[12]);\n-    zmm[13] = sort_zmm_64bit<vtype>(zmm[13]);\n-    zmm[14] = sort_zmm_64bit<vtype>(zmm[14]);\n-    zmm[15] = sort_zmm_64bit<vtype>(zmm[15]);\n-    opmask_t load_mask1 = 0xFF, load_mask2 = 0xFF;\n-    opmask_t load_mask3 = 0xFF, load_mask4 = 0xFF;\n-    opmask_t load_mask5 = 0xFF, load_mask6 = 0xFF;\n-    opmask_t load_mask7 = 0xFF, load_mask8 = 0xFF;\n-    opmask_t load_mask9 = 0xFF, load_mask10 = 0xFF;\n-    opmask_t load_mask11 = 0xFF, load_mask12 = 0xFF;\n-    opmask_t load_mask13 = 0xFF, load_mask14 = 0xFF;\n-    opmask_t load_mask15 = 0xFF, load_mask16 = 0xFF;\n-    if (N != 256) {\n-        uint64_t combined_mask;\n-        if (N < 192) {\n-            combined_mask = (0x1ull << (N - 128)) - 0x1ull;\n-            load_mask1 = (combined_mask)&0xFF;\n-            load_mask2 = (combined_mask >> 8) & 0xFF;\n-            load_mask3 = (combined_mask >> 16) & 0xFF;\n-            load_mask4 = (combined_mask >> 24) & 0xFF;\n-            load_mask5 = (combined_mask >> 32) & 0xFF;\n-            load_mask6 = (combined_mask >> 40) & 0xFF;\n-            load_mask7 = (combined_mask >> 48) & 0xFF;\n-            load_mask8 = (combined_mask >> 56) & 0xFF;\n-            load_mask9 = 0x00;\n-            load_mask10 = 0x0;\n-            load_mask11 = 0x00;\n-            load_mask12 = 0x00;\n-            load_mask13 = 0x00;\n-            load_mask14 = 0x00;\n-            load_mask15 = 0x00;\n-            load_mask16 = 0x00;\n+        if constexpr (scale == 2) {\n+            return swap_n<vtype, 2>(reg);\n+        } else if constexpr (scale == 4) {\n+            constexpr uint64_t mask = 0b00011011;\n+            v = _mm512_permutex_epi64(v, mask);\n+        } else if constexpr (scale == 8) {\n+            return vtype::reverse(reg);\n@@ -604,9 +317,1 @@\n-            combined_mask = (0x1ull << (N - 192)) - 0x1ull;\n-            load_mask9 = (combined_mask)&0xFF;\n-            load_mask10 = (combined_mask >> 8) & 0xFF;\n-            load_mask11 = (combined_mask >> 16) & 0xFF;\n-            load_mask12 = (combined_mask >> 24) & 0xFF;\n-            load_mask13 = (combined_mask >> 32) & 0xFF;\n-            load_mask14 = (combined_mask >> 40) & 0xFF;\n-            load_mask15 = (combined_mask >> 48) & 0xFF;\n-            load_mask16 = (combined_mask >> 56) & 0xFF;\n+            static_assert(scale == -1, \"should not be reached\");\n@@ -614,110 +319,0 @@\n-    }\n-    zmm[16] = vtype::mask_loadu(vtype::zmm_max(), load_mask1, arr + 128);\n-    zmm[17] = vtype::mask_loadu(vtype::zmm_max(), load_mask2, arr + 136);\n-    zmm[18] = vtype::mask_loadu(vtype::zmm_max(), load_mask3, arr + 144);\n-    zmm[19] = vtype::mask_loadu(vtype::zmm_max(), load_mask4, arr + 152);\n-    zmm[20] = vtype::mask_loadu(vtype::zmm_max(), load_mask5, arr + 160);\n-    zmm[21] = vtype::mask_loadu(vtype::zmm_max(), load_mask6, arr + 168);\n-    zmm[22] = vtype::mask_loadu(vtype::zmm_max(), load_mask7, arr + 176);\n-    zmm[23] = vtype::mask_loadu(vtype::zmm_max(), load_mask8, arr + 184);\n-    if (N < 192) {\n-        zmm[24] = vtype::zmm_max();\n-        zmm[25] = vtype::zmm_max();\n-        zmm[26] = vtype::zmm_max();\n-        zmm[27] = vtype::zmm_max();\n-        zmm[28] = vtype::zmm_max();\n-        zmm[29] = vtype::zmm_max();\n-        zmm[30] = vtype::zmm_max();\n-        zmm[31] = vtype::zmm_max();\n-    } else {\n-        zmm[24] = vtype::mask_loadu(vtype::zmm_max(), load_mask9, arr + 192);\n-        zmm[25] = vtype::mask_loadu(vtype::zmm_max(), load_mask10, arr + 200);\n-        zmm[26] = vtype::mask_loadu(vtype::zmm_max(), load_mask11, arr + 208);\n-        zmm[27] = vtype::mask_loadu(vtype::zmm_max(), load_mask12, arr + 216);\n-        zmm[28] = vtype::mask_loadu(vtype::zmm_max(), load_mask13, arr + 224);\n-        zmm[29] = vtype::mask_loadu(vtype::zmm_max(), load_mask14, arr + 232);\n-        zmm[30] = vtype::mask_loadu(vtype::zmm_max(), load_mask15, arr + 240);\n-        zmm[31] = vtype::mask_loadu(vtype::zmm_max(), load_mask16, arr + 248);\n-    }\n-    zmm[16] = sort_zmm_64bit<vtype>(zmm[16]);\n-    zmm[17] = sort_zmm_64bit<vtype>(zmm[17]);\n-    zmm[18] = sort_zmm_64bit<vtype>(zmm[18]);\n-    zmm[19] = sort_zmm_64bit<vtype>(zmm[19]);\n-    zmm[20] = sort_zmm_64bit<vtype>(zmm[20]);\n-    zmm[21] = sort_zmm_64bit<vtype>(zmm[21]);\n-    zmm[22] = sort_zmm_64bit<vtype>(zmm[22]);\n-    zmm[23] = sort_zmm_64bit<vtype>(zmm[23]);\n-    zmm[24] = sort_zmm_64bit<vtype>(zmm[24]);\n-    zmm[25] = sort_zmm_64bit<vtype>(zmm[25]);\n-    zmm[26] = sort_zmm_64bit<vtype>(zmm[26]);\n-    zmm[27] = sort_zmm_64bit<vtype>(zmm[27]);\n-    zmm[28] = sort_zmm_64bit<vtype>(zmm[28]);\n-    zmm[29] = sort_zmm_64bit<vtype>(zmm[29]);\n-    zmm[30] = sort_zmm_64bit<vtype>(zmm[30]);\n-    zmm[31] = sort_zmm_64bit<vtype>(zmm[31]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[0], zmm[1]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[2], zmm[3]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[4], zmm[5]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[6], zmm[7]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[8], zmm[9]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[10], zmm[11]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[12], zmm[13]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[14], zmm[15]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[16], zmm[17]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[18], zmm[19]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[20], zmm[21]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[22], zmm[23]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[24], zmm[25]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[26], zmm[27]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[28], zmm[29]);\n-    bitonic_merge_two_zmm_64bit<vtype>(zmm[30], zmm[31]);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 4);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 8);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 12);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 16);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 20);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 24);\n-    bitonic_merge_four_zmm_64bit<vtype>(zmm + 28);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 8);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 16);\n-    bitonic_merge_eight_zmm_64bit<vtype>(zmm + 24);\n-    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm);\n-    bitonic_merge_sixteen_zmm_64bit<vtype>(zmm + 16);\n-    bitonic_merge_32_zmm_64bit<vtype>(zmm);\n-    vtype::storeu(arr, zmm[0]);\n-    vtype::storeu(arr + 8, zmm[1]);\n-    vtype::storeu(arr + 16, zmm[2]);\n-    vtype::storeu(arr + 24, zmm[3]);\n-    vtype::storeu(arr + 32, zmm[4]);\n-    vtype::storeu(arr + 40, zmm[5]);\n-    vtype::storeu(arr + 48, zmm[6]);\n-    vtype::storeu(arr + 56, zmm[7]);\n-    vtype::storeu(arr + 64, zmm[8]);\n-    vtype::storeu(arr + 72, zmm[9]);\n-    vtype::storeu(arr + 80, zmm[10]);\n-    vtype::storeu(arr + 88, zmm[11]);\n-    vtype::storeu(arr + 96, zmm[12]);\n-    vtype::storeu(arr + 104, zmm[13]);\n-    vtype::storeu(arr + 112, zmm[14]);\n-    vtype::storeu(arr + 120, zmm[15]);\n-    vtype::mask_storeu(arr + 128, load_mask1, zmm[16]);\n-    vtype::mask_storeu(arr + 136, load_mask2, zmm[17]);\n-    vtype::mask_storeu(arr + 144, load_mask3, zmm[18]);\n-    vtype::mask_storeu(arr + 152, load_mask4, zmm[19]);\n-    vtype::mask_storeu(arr + 160, load_mask5, zmm[20]);\n-    vtype::mask_storeu(arr + 168, load_mask6, zmm[21]);\n-    vtype::mask_storeu(arr + 176, load_mask7, zmm[22]);\n-    vtype::mask_storeu(arr + 184, load_mask8, zmm[23]);\n-    if (N > 192) {\n-        vtype::mask_storeu(arr + 192, load_mask9, zmm[24]);\n-        vtype::mask_storeu(arr + 200, load_mask10, zmm[25]);\n-        vtype::mask_storeu(arr + 208, load_mask11, zmm[26]);\n-        vtype::mask_storeu(arr + 216, load_mask12, zmm[27]);\n-        vtype::mask_storeu(arr + 224, load_mask13, zmm[28]);\n-        vtype::mask_storeu(arr + 232, load_mask14, zmm[29]);\n-        vtype::mask_storeu(arr + 240, load_mask15, zmm[30]);\n-        vtype::mask_storeu(arr + 248, load_mask16, zmm[31]);\n-    }\n-}\n@@ -725,16 +320,1 @@\n-template <typename vtype, typename type_t>\n-static void qsort_64bit_(type_t *arr, int64_t left, int64_t right,\n-                         int64_t max_iters) {\n-    \/*\n-     * Resort to std::sort if quicksort isnt making any progress\n-     *\/\n-    if (max_iters <= 0) {\n-        std::sort(arr + left, arr + right + 1);\n-        return;\n-    }\n-    \/*\n-     * Base case: use bitonic networks to sort arrays <= 128\n-     *\/\n-    if (right + 1 - left <= 256) {\n-        sort_256_64bit<vtype>(arr + left, (int32_t)(right + 1 - left));\n-        return;\n+        return vtype::cast_from(v);\n@@ -743,10 +323,5 @@\n-    type_t pivot = get_pivot_scalar<type_t>(arr, left, right);\n-    type_t smallest = vtype::type_max();\n-    type_t biggest = vtype::type_min();\n-    int64_t pivot_index = partition_avx512_unrolled<vtype, 8>(\n-        arr, left, right + 1, pivot, &smallest, &biggest, false);\n-    if (pivot != smallest)\n-        qsort_64bit_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n-    if (pivot != biggest)\n-        qsort_64bit_<vtype>(arr, pivot_index, right, max_iters - 1);\n-}\n+    template <typename vtype, int scale>\n+    X86_SIMD_SORT_INLINE typename vtype::reg_t merge_n(\n+        typename vtype::reg_t reg, typename vtype::reg_t other) {\n+        __m512i v1 = vtype::cast_to(reg);\n+        __m512i v2 = vtype::cast_to(other);\n@@ -754,8 +329,9 @@\n-template <>\n-void inline avx512_qsort<int64_t>(int64_t *arr, int64_t fromIndex, int64_t toIndex) {\n-    int64_t arrsize = toIndex - fromIndex;\n-    if (arrsize > 1) {\n-        qsort_64bit_<zmm_vector<int64_t>, int64_t>(arr, fromIndex, toIndex - 1,\n-                                                   2 * (int64_t)log2(arrsize));\n-    }\n-}\n+        if constexpr (scale == 2) {\n+            v1 = _mm512_mask_blend_epi64(0b01010101, v1, v2);\n+        } else if constexpr (scale == 4) {\n+            v1 = _mm512_mask_blend_epi64(0b00110011, v1, v2);\n+        } else if constexpr (scale == 8) {\n+            v1 = _mm512_mask_blend_epi64(0b00001111, v1, v2);\n+        } else {\n+            static_assert(scale == -1, \"should not be reached\");\n+        }\n@@ -763,6 +339,1 @@\n-template <>\n-void inline avx512_qsort<double>(double *arr, int64_t fromIndex, int64_t toIndex) {\n-    int64_t arrsize = toIndex - fromIndex;\n-    if (arrsize > 1) {\n-        qsort_64bit_<zmm_vector<double>, double>(arr, fromIndex, toIndex - 1,\n-                                                 2 * (int64_t)log2(arrsize));\n+        return vtype::cast_from(v1);\n@@ -770,1 +341,1 @@\n-}\n+};\n@@ -772,1 +343,1 @@\n-#endif  \/\/ AVX512_QSORT_64BIT\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-64bit-qsort.hpp","additions":293,"deletions":722,"binary":false,"changes":1015,"status":"modified"},{"patch":"@@ -1,483 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n- * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n-#ifndef AVX512_QSORT_COMMON\n-#define AVX512_QSORT_COMMON\n-\n-\/*\n- * Quicksort using AVX-512. The ideas and code are based on these two research\n- * papers [1] and [2]. On a high level, the idea is to vectorize quicksort\n- * partitioning using AVX-512 compressstore instructions. If the array size is\n- * < 128, then use Bitonic sorting network implemented on 512-bit registers.\n- * The precise network definitions depend on the dtype and are defined in\n- * separate files: avx512-16bit-qsort.hpp, avx512-32bit-qsort.hpp and\n- * avx512-64bit-qsort.hpp. Article [4] is a good resource for bitonic sorting\n- * network. The core implementations of the vectorized qsort functions\n- * avx512_qsort<T>(T*, int64_t) are modified versions of avx2 quicksort\n- * presented in the paper [2] and source code associated with that paper [3].\n- *\n- * [1] Fast and Robust Vectorized In-Place Sorting of Primitive Types\n- *     https:\/\/drops.dagstuhl.de\/opus\/volltexte\/2021\/13775\/\n- *\n- * [2] A Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel\n- * Skylake https:\/\/arxiv.org\/pdf\/1704.08579.pdf\n- *\n- * [3] https:\/\/github.com\/simd-sorting\/fast-and-robust: SPDX-License-Identifier:\n- * MIT\n- *\n- * [4]\n- * http:\/\/mitp-content-server.mit.edu:18180\/books\/content\/sectbyfn?collid=books_pres_0&fn=Chapter%2027.pdf&id=8030\n- *\n- *\/\n-\n-#include <algorithm>\n-#include <cmath>\n-#include <cstdint>\n-#include <cstring>\n-#include <limits>\n-\n-\/*\n-Workaround for the bug in GCC12 (that was fixed in GCC 12.3.1).\n-More details are available at: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=105593\n-*\/\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n-#pragma GCC diagnostic ignored \"-Wuninitialized\"\n-#include <immintrin.h>\n-#pragma GCC diagnostic pop\n-\n-#define X86_SIMD_SORT_INFINITY std::numeric_limits<double>::infinity()\n-#define X86_SIMD_SORT_INFINITYF std::numeric_limits<float>::infinity()\n-#define X86_SIMD_SORT_INFINITYH 0x7c00\n-#define X86_SIMD_SORT_NEGINFINITYH 0xfc00\n-#define X86_SIMD_SORT_MAX_UINT16 std::numeric_limits<uint16_t>::max()\n-#define X86_SIMD_SORT_MAX_INT16 std::numeric_limits<int16_t>::max()\n-#define X86_SIMD_SORT_MIN_INT16 std::numeric_limits<int16_t>::min()\n-#define X86_SIMD_SORT_MAX_UINT32 std::numeric_limits<uint32_t>::max()\n-#define X86_SIMD_SORT_MAX_INT32 std::numeric_limits<int32_t>::max()\n-#define X86_SIMD_SORT_MIN_INT32 std::numeric_limits<int32_t>::min()\n-#define X86_SIMD_SORT_MAX_UINT64 std::numeric_limits<uint64_t>::max()\n-#define X86_SIMD_SORT_MAX_INT64 std::numeric_limits<int64_t>::max()\n-#define X86_SIMD_SORT_MIN_INT64 std::numeric_limits<int64_t>::min()\n-#define ZMM_MAX_DOUBLE _mm512_set1_pd(X86_SIMD_SORT_INFINITY)\n-#define ZMM_MAX_UINT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_UINT64)\n-#define ZMM_MAX_INT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_INT64)\n-#define ZMM_MAX_FLOAT _mm512_set1_ps(X86_SIMD_SORT_INFINITYF)\n-#define ZMM_MAX_UINT _mm512_set1_epi32(X86_SIMD_SORT_MAX_UINT32)\n-#define ZMM_MAX_INT _mm512_set1_epi32(X86_SIMD_SORT_MAX_INT32)\n-#define ZMM_MAX_HALF _mm512_set1_epi16(X86_SIMD_SORT_INFINITYH)\n-#define YMM_MAX_HALF _mm256_set1_epi16(X86_SIMD_SORT_INFINITYH)\n-#define ZMM_MAX_UINT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_UINT16)\n-#define ZMM_MAX_INT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_INT16)\n-#define SHUFFLE_MASK(a, b, c, d) (a << 6) | (b << 4) | (c << 2) | d\n-\n-#ifdef _MSC_VER\n-#define X86_SIMD_SORT_INLINE static inline\n-#define X86_SIMD_SORT_FINLINE static __forceinline\n-#elif defined(__CYGWIN__)\n-\/*\n- * Force inline in cygwin to work around a compiler bug. See\n- * https:\/\/github.com\/numpy\/numpy\/pull\/22315#issuecomment-1267757584\n- *\/\n-#define X86_SIMD_SORT_INLINE static __attribute__((always_inline))\n-#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n-#elif defined(__GNUC__)\n-#define X86_SIMD_SORT_INLINE static inline\n-#define X86_SIMD_SORT_FINLINE static __attribute__((always_inline))\n-#else\n-#define X86_SIMD_SORT_INLINE static\n-#define X86_SIMD_SORT_FINLINE static\n-#endif\n-\n-#define LIKELY(x) __builtin_expect((x), 1)\n-#define UNLIKELY(x) __builtin_expect((x), 0)\n-\n-template <typename type>\n-struct zmm_vector;\n-\n-template <typename type>\n-struct ymm_vector;\n-\n-\/\/ Regular quicksort routines:\n-template <typename T>\n-void avx512_qsort(T *arr, int64_t arrsize);\n-\n-template <typename T>\n-void inline avx512_qsort(T *arr, int64_t from_index, int64_t to_index);\n-\n-template <typename T>\n-bool is_a_nan(T elem) {\n-    return std::isnan(elem);\n-}\n-\n-template <typename T>\n-X86_SIMD_SORT_INLINE T get_pivot_scalar(T *arr, const int64_t left, const int64_t right) {\n-    \/\/ median of 8 equally spaced elements\n-    int64_t NUM_ELEMENTS = 8;\n-    int64_t MID = NUM_ELEMENTS \/ 2;\n-    int64_t size = (right - left) \/ NUM_ELEMENTS;\n-    T temp[NUM_ELEMENTS];\n-    for (int64_t i = 0; i < NUM_ELEMENTS; i++) temp[i] = arr[left + (i * size)];\n-    std::sort(temp, temp + NUM_ELEMENTS);\n-    return temp[MID];\n-}\n-\n-template <typename vtype, typename T = typename vtype::type_t>\n-bool comparison_func_ge(const T &a, const T &b) {\n-    return a < b;\n-}\n-\n-template <typename vtype, typename T = typename vtype::type_t>\n-bool comparison_func_gt(const T &a, const T &b) {\n-    return a <= b;\n-}\n-\n-\/*\n- * COEX == Compare and Exchange two registers by swapping min and max values\n- *\/\n-template <typename vtype, typename mm_t>\n-static void COEX(mm_t &a, mm_t &b) {\n-    mm_t temp = a;\n-    a = vtype::min(a, b);\n-    b = vtype::max(temp, b);\n-}\n-template <typename vtype, typename zmm_t = typename vtype::zmm_t,\n-          typename opmask_t = typename vtype::opmask_t>\n-static inline zmm_t cmp_merge(zmm_t in1, zmm_t in2, opmask_t mask) {\n-    zmm_t min = vtype::min(in2, in1);\n-    zmm_t max = vtype::max(in2, in1);\n-    return vtype::mask_mov(min, mask, max);  \/\/ 0 -> min, 1 -> max\n-}\n-\/*\n- * Parition one ZMM register based on the pivot and returns the\n- * number of elements that are greater than or equal to the pivot.\n- *\/\n-template <typename vtype, typename type_t, typename zmm_t>\n-static inline int32_t partition_vec(type_t *arr, int64_t left, int64_t right,\n-                                    const zmm_t curr_vec, const zmm_t pivot_vec,\n-                                    zmm_t *smallest_vec, zmm_t *biggest_vec, bool use_gt) {\n-    \/* which elements are larger than or equal to the pivot *\/\n-    typename vtype::opmask_t mask;\n-    if (use_gt) mask = vtype::gt(curr_vec, pivot_vec);\n-    else mask = vtype::ge(curr_vec, pivot_vec);\n-    \/\/mask = vtype::ge(curr_vec, pivot_vec);\n-    int32_t amount_ge_pivot = _mm_popcnt_u32((int32_t)mask);\n-    vtype::mask_compressstoreu(arr + left, vtype::knot_opmask(mask),\n-                               curr_vec);\n-    vtype::mask_compressstoreu(arr + right - amount_ge_pivot, mask,\n-                               curr_vec);\n-    *smallest_vec = vtype::min(curr_vec, *smallest_vec);\n-    *biggest_vec = vtype::max(curr_vec, *biggest_vec);\n-    return amount_ge_pivot;\n-}\n-\/*\n- * Parition an array based on the pivot and returns the index of the\n- * first element that is greater than or equal to the pivot.\n- *\/\n-template <typename vtype, typename type_t>\n-static inline int64_t partition_avx512(type_t *arr, int64_t left, int64_t right,\n-                                       type_t pivot, type_t *smallest,\n-                                       type_t *biggest, bool use_gt) {\n-    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n-    \/* make array length divisible by vtype::numlanes , shortening the array *\/\n-    for (int32_t i = (right - left) % vtype::numlanes; i > 0; --i) {\n-        *smallest = std::min(*smallest, arr[left], comparison_func);\n-        *biggest = std::max(*biggest, arr[left], comparison_func);\n-        if (!comparison_func(arr[left], pivot)) {\n-            std::swap(arr[left], arr[--right]);\n-        } else {\n-            ++left;\n-        }\n-    }\n-\n-    if (left == right)\n-        return left; \/* less than vtype::numlanes elements in the array *\/\n-\n-    using zmm_t = typename vtype::zmm_t;\n-    zmm_t pivot_vec = vtype::set1(pivot);\n-    zmm_t min_vec = vtype::set1(*smallest);\n-    zmm_t max_vec = vtype::set1(*biggest);\n-\n-    if (right - left == vtype::numlanes) {\n-        zmm_t vec = vtype::loadu(arr + left);\n-        int32_t amount_ge_pivot =\n-            partition_vec<vtype>(arr, left, left + vtype::numlanes, vec,\n-                                 pivot_vec, &min_vec, &max_vec, use_gt);\n-        *smallest = vtype::reducemin(min_vec);\n-        *biggest = vtype::reducemax(max_vec);\n-        return left + (vtype::numlanes - amount_ge_pivot);\n-    }\n-\n-    \/\/ first and last vtype::numlanes values are partitioned at the end\n-    zmm_t vec_left = vtype::loadu(arr + left);\n-    zmm_t vec_right = vtype::loadu(arr + (right - vtype::numlanes));\n-    \/\/ store points of the vectors\n-    int64_t r_store = right - vtype::numlanes;\n-    int64_t l_store = left;\n-    \/\/ indices for loading the elements\n-    left += vtype::numlanes;\n-    right -= vtype::numlanes;\n-    while (right - left != 0) {\n-        zmm_t curr_vec;\n-        \/*\n-         * if fewer elements are stored on the right side of the array,\n-         * then next elements are loaded from the right side,\n-         * otherwise from the left side\n-         *\/\n-        if ((r_store + vtype::numlanes) - right < left - l_store) {\n-            right -= vtype::numlanes;\n-            curr_vec = vtype::loadu(arr + right);\n-        } else {\n-            curr_vec = vtype::loadu(arr + left);\n-            left += vtype::numlanes;\n-        }\n-        \/\/ partition the current vector and save it on both sides of the array\n-        int32_t amount_ge_pivot =\n-            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n-                                 curr_vec, pivot_vec, &min_vec, &max_vec, use_gt);\n-        ;\n-        r_store -= amount_ge_pivot;\n-        l_store += (vtype::numlanes - amount_ge_pivot);\n-    }\n-\n-    \/* partition and save vec_left and vec_right *\/\n-    int32_t amount_ge_pivot =\n-        partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes, vec_left,\n-                             pivot_vec, &min_vec, &max_vec, use_gt);\n-    l_store += (vtype::numlanes - amount_ge_pivot);\n-    amount_ge_pivot =\n-        partition_vec<vtype>(arr, l_store, l_store + vtype::numlanes, vec_right,\n-                             pivot_vec, &min_vec, &max_vec, use_gt);\n-    l_store += (vtype::numlanes - amount_ge_pivot);\n-    *smallest = vtype::reducemin(min_vec);\n-    *biggest = vtype::reducemax(max_vec);\n-    return l_store;\n-}\n-\n-template <typename vtype, int num_unroll,\n-          typename type_t = typename vtype::type_t>\n-static inline int64_t partition_avx512_unrolled(type_t *arr, int64_t left,\n-                                                int64_t right, type_t pivot,\n-                                                type_t *smallest,\n-                                                type_t *biggest, bool use_gt) {\n-    if (right - left <= 2 * num_unroll * vtype::numlanes) {\n-        return partition_avx512<vtype>(arr, left, right, pivot, smallest,\n-                                       biggest, use_gt);\n-    }\n-\n-    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n-    \/* make array length divisible by 8*vtype::numlanes , shortening the array\n-     *\/\n-    for (int32_t i = ((right - left) % (num_unroll * vtype::numlanes)); i > 0;\n-         --i) {\n-        *smallest = std::min(*smallest, arr[left], comparison_func);\n-        *biggest = std::max(*biggest, arr[left], comparison_func);\n-        if (!comparison_func(arr[left], pivot)) {\n-            std::swap(arr[left], arr[--right]);\n-        } else {\n-            ++left;\n-        }\n-    }\n-\n-    if (left == right)\n-        return left; \/* less than vtype::numlanes elements in the array *\/\n-\n-    using zmm_t = typename vtype::zmm_t;\n-    zmm_t pivot_vec = vtype::set1(pivot);\n-    zmm_t min_vec = vtype::set1(*smallest);\n-    zmm_t max_vec = vtype::set1(*biggest);\n-\n-    \/\/ We will now have atleast 16 registers worth of data to process:\n-    \/\/ left and right vtype::numlanes values are partitioned at the end\n-    zmm_t vec_left[num_unroll], vec_right[num_unroll];\n-#pragma GCC unroll 8\n-    for (int ii = 0; ii < num_unroll; ++ii) {\n-        vec_left[ii] = vtype::loadu(arr + left + vtype::numlanes * ii);\n-        vec_right[ii] =\n-            vtype::loadu(arr + (right - vtype::numlanes * (num_unroll - ii)));\n-    }\n-    \/\/ store points of the vectors\n-    int64_t r_store = right - vtype::numlanes;\n-    int64_t l_store = left;\n-    \/\/ indices for loading the elements\n-    left += num_unroll * vtype::numlanes;\n-    right -= num_unroll * vtype::numlanes;\n-    while (right - left != 0) {\n-        zmm_t curr_vec[num_unroll];\n-        \/*\n-         * if fewer elements are stored on the right side of the array,\n-         * then next elements are loaded from the right side,\n-         * otherwise from the left side\n-         *\/\n-        if ((r_store + vtype::numlanes) - right < left - l_store) {\n-            right -= num_unroll * vtype::numlanes;\n-#pragma GCC unroll 8\n-            for (int ii = 0; ii < num_unroll; ++ii) {\n-                curr_vec[ii] = vtype::loadu(arr + right + ii * vtype::numlanes);\n-            }\n-        } else {\n-#pragma GCC unroll 8\n-            for (int ii = 0; ii < num_unroll; ++ii) {\n-                curr_vec[ii] = vtype::loadu(arr + left + ii * vtype::numlanes);\n-            }\n-            left += num_unroll * vtype::numlanes;\n-        }\n-\/\/ partition the current vector and save it on both sides of the array\n-#pragma GCC unroll 8\n-        for (int ii = 0; ii < num_unroll; ++ii) {\n-            int32_t amount_ge_pivot = partition_vec<vtype>(\n-                arr, l_store, r_store + vtype::numlanes, curr_vec[ii],\n-                pivot_vec, &min_vec, &max_vec, use_gt);\n-            l_store += (vtype::numlanes - amount_ge_pivot);\n-            r_store -= amount_ge_pivot;\n-        }\n-    }\n-\n-\/* partition and save vec_left[8] and vec_right[8] *\/\n-#pragma GCC unroll 8\n-    for (int ii = 0; ii < num_unroll; ++ii) {\n-        int32_t amount_ge_pivot =\n-            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n-                                 vec_left[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n-        l_store += (vtype::numlanes - amount_ge_pivot);\n-        r_store -= amount_ge_pivot;\n-    }\n-#pragma GCC unroll 8\n-    for (int ii = 0; ii < num_unroll; ++ii) {\n-        int32_t amount_ge_pivot =\n-            partition_vec<vtype>(arr, l_store, r_store + vtype::numlanes,\n-                                 vec_right[ii], pivot_vec, &min_vec, &max_vec, use_gt);\n-        l_store += (vtype::numlanes - amount_ge_pivot);\n-        r_store -= amount_ge_pivot;\n-    }\n-    *smallest = vtype::reducemin(min_vec);\n-    *biggest = vtype::reducemax(max_vec);\n-    return l_store;\n-}\n-\n-\/\/ to_index (exclusive)\n-template <typename vtype, typename type_t>\n-static int64_t vectorized_partition(type_t *arr, int64_t from_index, int64_t to_index, type_t pivot, bool use_gt) {\n-    type_t smallest = vtype::type_max();\n-    type_t biggest = vtype::type_min();\n-    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n-            arr, from_index, to_index, pivot, &smallest, &biggest, use_gt);\n-    return pivot_index;\n-}\n-\n-\/\/ partitioning functions\n-template <typename T>\n-void avx512_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2){\n-    const T pivot1 = arr[index_pivot1];\n-    const T pivot2 = arr[index_pivot2];\n-\n-    const int64_t low = from_index;\n-    const int64_t high = to_index;\n-    const int64_t start = low + 1;\n-    const int64_t end = high - 1;\n-\n-\n-    std::swap(arr[index_pivot1], arr[low]);\n-    std::swap(arr[index_pivot2], arr[end]);\n-\n-\n-    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, start, end, pivot2, true); \/\/ use_gt = true\n-    std::swap(arr[end], arr[pivot_index2]);\n-    int64_t upper = pivot_index2;\n-\n-    \/\/ if all other elements are greater than pivot2 (and pivot1), no need to do further partitioning\n-    if (upper == start) {\n-        pivot_indices[0] = low;\n-        pivot_indices[1] = upper;\n-        return;\n-    }\n-\n-    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, start, upper, pivot1, false); \/\/ use_ge (use_gt = false)\n-    int64_t lower = pivot_index1 - 1;\n-    std::swap(arr[low], arr[lower]);\n-\n-    pivot_indices[0] = lower;\n-    pivot_indices[1] = upper;\n-}\n-\n-template <typename T>\n-void avx512_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot){\n-    const T pivot = arr[index_pivot];\n-\n-    const int64_t low = from_index;\n-    const int64_t high = to_index;\n-    const int64_t end = high - 1;\n-\n-\n-    const int64_t pivot_index1 = vectorized_partition<zmm_vector<T>, T>(arr, low, high, pivot, false); \/\/ use_gt = false (use_ge)\n-    int64_t lower = pivot_index1;\n-\n-    const int64_t pivot_index2 = vectorized_partition<zmm_vector<T>, T>(arr, pivot_index1, high, pivot, true); \/\/ use_gt = true\n-    int64_t upper = pivot_index2;\n-\n-    pivot_indices[0] = lower;\n-    pivot_indices[1] = upper;\n-}\n-\n-template <typename T>\n-void inline avx512_fast_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2) {\n-    if (index_pivot1 != index_pivot2) {\n-        avx512_dual_pivot_partition<T>(arr, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n-    }\n-    else {\n-        avx512_single_pivot_partition<T>(arr, from_index, to_index, pivot_indices, index_pivot1);\n-    }\n-}\n-\n-template <typename T>\n-void inline insertion_sort(T *arr, int32_t from_index, int32_t to_index) {\n-    for (int i, k = from_index; ++k < to_index; ) {\n-        T ai = arr[i = k];\n-\n-        if (ai < arr[i - 1]) {\n-            while (--i >= from_index && ai < arr[i]) {\n-                arr[i + 1] = arr[i];\n-            }\n-            arr[i + 1] = ai;\n-        }\n-    }\n-}\n-\n-template <typename T>\n-void inline avx512_fast_sort(T *arr, int64_t from_index, int64_t to_index, const int32_t INS_SORT_THRESHOLD) {\n-    int32_t size = to_index - from_index;\n-\n-    if (size <= INS_SORT_THRESHOLD) {\n-        insertion_sort<T>(arr, from_index, to_index);\n-    }\n-    else {\n-        avx512_qsort<T>(arr, from_index, to_index);\n-    }\n-}\n-\n-\n-\n-#endif  \/\/ AVX512_QSORT_COMMON\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-common-qsort.h","additions":0,"deletions":483,"binary":false,"changes":483,"status":"deleted"},{"patch":"@@ -24,0 +24,2 @@\n+#include \"simdsort-support.hpp\"\n+#ifdef __SIMDSORT_SUPPORTED_LINUX\n@@ -30,0 +32,1 @@\n+\n@@ -39,1 +42,1 @@\n-                avx512_fast_sort<int32_t>((int32_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                avx512_fast_sort((int32_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n@@ -42,1 +45,1 @@\n-                avx512_fast_sort<int64_t>((int64_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+                avx512_fast_sort((int64_t*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n@@ -45,1 +48,1 @@\n-                avx512_fast_sort<float>((float*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n+                avx512_fast_sort((float*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_32BIT);\n@@ -48,1 +51,1 @@\n-                avx512_fast_sort<double>((double*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n+                avx512_fast_sort((double*)array, from_index, to_index, INSERTION_SORT_THRESHOLD_64BIT);\n@@ -50,0 +53,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n@@ -56,1 +61,1 @@\n-                avx512_fast_partition<int32_t>((int32_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                avx512_fast_partition((int32_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -59,1 +64,1 @@\n-                avx512_fast_partition<int64_t>((int64_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                avx512_fast_partition((int64_t*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -62,1 +67,1 @@\n-                avx512_fast_partition<float>((float*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                avx512_fast_partition((float*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -65,1 +70,1 @@\n-                avx512_fast_partition<double>((double*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+                avx512_fast_partition((double*)array, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n@@ -67,0 +72,2 @@\n+            default:\n+                assert(false, \"Unexpected type\");\n@@ -71,0 +78,2 @@\n+\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/avx512-linux-qsort.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SIMDSORT_SUPPORT_HPP\n+#define SIMDSORT_SUPPORT_HPP\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#undef assert\n+#define assert(cond, msg) { if (!(cond)) { fprintf(stderr, \"assert fails %s %d: %s\\n\", __FILE__, __LINE__, msg); abort(); }}\n+\n+\n+\/\/ GCC >= 7.5 is needed to build AVX2 portions of libsimdsort using C++17 features\n+#if defined(_LP64) && (defined(__GNUC__) && ((__GNUC__ > 7) || ((__GNUC__ == 7) && (__GNUC_MINOR__ >= 5))))\n+#define __SIMDSORT_SUPPORTED_LINUX\n+#endif\n+\n+#endif \/\/SIMDSORT_SUPPORT_HPP\n\\ No newline at end of file\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/simdsort-support.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef XSS_COMMON_INCLUDES\n+#define XSS_COMMON_INCLUDES\n+#include <algorithm>\n+#include <cmath>\n+#include <cstdint>\n+#include <cstring>\n+\/*\n+Workaround for the bug in GCC12 (that was fixed in GCC 12.3.1).\n+More details are available at:\n+https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=105593\n+*\/\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+#include <immintrin.h>\n+#pragma GCC diagnostic pop\n+#include <limits>\n+#include <vector>\n+\n+#define X86_SIMD_SORT_INFINITY std::numeric_limits<double>::infinity()\n+#define X86_SIMD_SORT_INFINITYF std::numeric_limits<float>::infinity()\n+#define X86_SIMD_SORT_INFINITYH 0x7c00\n+#define X86_SIMD_SORT_NEGINFINITYH 0xfc00\n+#define X86_SIMD_SORT_MAX_UINT16 std::numeric_limits<uint16_t>::max()\n+#define X86_SIMD_SORT_MAX_INT16 std::numeric_limits<int16_t>::max()\n+#define X86_SIMD_SORT_MIN_INT16 std::numeric_limits<int16_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT32 std::numeric_limits<uint32_t>::max()\n+#define X86_SIMD_SORT_MAX_INT32 std::numeric_limits<int32_t>::max()\n+#define X86_SIMD_SORT_MIN_INT32 std::numeric_limits<int32_t>::min()\n+#define X86_SIMD_SORT_MAX_UINT64 std::numeric_limits<uint64_t>::max()\n+#define X86_SIMD_SORT_MAX_INT64 std::numeric_limits<int64_t>::max()\n+#define X86_SIMD_SORT_MIN_INT64 std::numeric_limits<int64_t>::min()\n+#define ZMM_MAX_DOUBLE _mm512_set1_pd(X86_SIMD_SORT_INFINITY)\n+#define ZMM_MAX_UINT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_UINT64)\n+#define ZMM_MAX_INT64 _mm512_set1_epi64(X86_SIMD_SORT_MAX_INT64)\n+#define ZMM_MAX_FLOAT _mm512_set1_ps(X86_SIMD_SORT_INFINITYF)\n+#define ZMM_MAX_UINT _mm512_set1_epi32(X86_SIMD_SORT_MAX_UINT32)\n+#define ZMM_MAX_INT _mm512_set1_epi32(X86_SIMD_SORT_MAX_INT32)\n+#define ZMM_MAX_HALF _mm512_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define YMM_MAX_HALF _mm256_set1_epi16(X86_SIMD_SORT_INFINITYH)\n+#define ZMM_MAX_UINT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_UINT16)\n+#define ZMM_MAX_INT16 _mm512_set1_epi16(X86_SIMD_SORT_MAX_INT16)\n+#define SHUFFLE_MASK(a, b, c, d) (a << 6) | (b << 4) | (c << 2) | d\n+\n+#define PRAGMA(x) _Pragma(#x)\n+#define UNUSED(x) (void)(x)\n+\n+\/* Compiler specific macros specific *\/\n+#if defined(__GNUC__)\n+#define X86_SIMD_SORT_INLINE static inline\n+#define X86_SIMD_SORT_FINLINE static inline __attribute__((always_inline))\n+#else\n+#define X86_SIMD_SORT_INLINE static\n+#define X86_SIMD_SORT_FINLINE static\n+#endif\n+\n+#if __GNUC__ >= 8\n+#define X86_SIMD_SORT_UNROLL_LOOP(num) PRAGMA(GCC unroll num)\n+#else\n+#define X86_SIMD_SORT_UNROLL_LOOP(num)\n+#endif\n+\n+typedef size_t arrsize_t;\n+\n+template <typename type>\n+struct zmm_vector;\n+\n+template <typename type>\n+struct ymm_vector;\n+\n+template <typename type>\n+struct avx2_vector;\n+\n+#endif \/\/ XSS_COMMON_INCLUDES\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-common-includes.h","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,528 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef XSS_COMMON_QSORT\n+#define XSS_COMMON_QSORT\n+\n+\/*\n+ * Quicksort using AVX-512. The ideas and code are based on these two research\n+ * papers [1] and [2]. On a high level, the idea is to vectorize quicksort\n+ * partitioning using AVX-512 compressstore instructions. If the array size is\n+ * < 128, then use Bitonic sorting network implemented on 512-bit registers.\n+ * The precise network definitions depend on the dtype and are defined in\n+ * separate files: avx512-16bit-qsort.hpp, avx512-32bit-qsort.hpp and\n+ * avx512-64bit-qsort.hpp. Article [4] is a good resource for bitonic sorting\n+ * network. The core implementations of the vectorized qsort functions\n+ * avx512_qsort<T>(T*, arrsize_t) are modified versions of avx2 quicksort\n+ * presented in the paper [2] and source code associated with that paper [3].\n+ *\n+ * [1] Fast and Robust Vectorized In-Place Sorting of Primitive Types\n+ *     https:\/\/drops.dagstuhl.de\/opus\/volltexte\/2021\/13775\/\n+ *\n+ * [2] A Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel\n+ * Skylake https:\/\/arxiv.org\/pdf\/1704.08579.pdf\n+ *\n+ * [3] https:\/\/github.com\/simd-sorting\/fast-and-robust: SPDX-License-Identifier:\n+ * MIT\n+ *\n+ * [4] http:\/\/mitp-content-server.mit.edu:18180\/books\/content\/sectbyfn?collid=books_pres_0&fn=Chapter%2027.pdf&id=8030\n+ *\n+ *\/\n+\n+#include \"xss-common-includes.h\"\n+#include \"xss-pivot-selection.hpp\"\n+#include \"xss-network-qsort.hpp\"\n+\n+\n+template <typename T>\n+bool is_a_nan(T elem) {\n+    return std::isnan(elem);\n+}\n+\n+template <typename T>\n+X86_SIMD_SORT_INLINE T get_pivot_scalar(T *arr, const int64_t left, const int64_t right) {\n+    \/\/ median of 8 equally spaced elements\n+    int64_t NUM_ELEMENTS = 8;\n+    int64_t MID = NUM_ELEMENTS \/ 2;\n+    int64_t size = (right - left) \/ NUM_ELEMENTS;\n+    T temp[NUM_ELEMENTS];\n+    for (int64_t i = 0; i < NUM_ELEMENTS; i++) temp[i] = arr[left + (i * size)];\n+    std::sort(temp, temp + NUM_ELEMENTS);\n+    return temp[MID];\n+}\n+\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func_ge(const T &a, const T &b) {\n+    return a < b;\n+}\n+\n+template <typename vtype, typename T = typename vtype::type_t>\n+bool comparison_func_gt(const T &a, const T &b) {\n+    return a <= b;\n+}\n+\n+\/*\n+ * COEX == Compare and Exchange two registers by swapping min and max values\n+ *\/\n+template <typename vtype, typename mm_t>\n+X86_SIMD_SORT_INLINE void COEX(mm_t &a, mm_t &b) {\n+    mm_t temp = a;\n+    a = vtype::min(a, b);\n+    b = vtype::max(temp, b);\n+}\n+\n+template <typename vtype, typename reg_t = typename vtype::reg_t,\n+          typename opmask_t = typename vtype::opmask_t>\n+X86_SIMD_SORT_INLINE reg_t cmp_merge(reg_t in1, reg_t in2, opmask_t mask) {\n+    reg_t min = vtype::min(in2, in1);\n+    reg_t max = vtype::max(in2, in1);\n+    return vtype::mask_mov(min, mask, max);  \/\/ 0 -> min, 1 -> max\n+}\n+\n+template <typename vtype, typename type_t, typename reg_t>\n+int avx512_double_compressstore(type_t *left_addr, type_t *right_addr,\n+                                typename vtype::opmask_t k, reg_t reg) {\n+    int amount_ge_pivot = _mm_popcnt_u32((int)k);\n+\n+    vtype::mask_compressstoreu(left_addr, vtype::knot_opmask(k), reg);\n+    vtype::mask_compressstoreu(right_addr + vtype::numlanes - amount_ge_pivot,\n+                               k, reg);\n+\n+    return amount_ge_pivot;\n+}\n+\n+\/\/ Generic function dispatches to AVX2 or AVX512 code\n+template <typename vtype, typename type_t,\n+          typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE arrsize_t partition_vec(type_t *l_store, type_t *r_store,\n+                                             const reg_t curr_vec,\n+                                             const reg_t pivot_vec,\n+                                             reg_t &smallest_vec,\n+                                             reg_t &biggest_vec, bool use_gt) {\n+    \/\/typename vtype::opmask_t ge_mask = vtype::ge(curr_vec, pivot_vec);\n+    typename vtype::opmask_t mask;\n+    if (use_gt) mask = vtype::gt(curr_vec, pivot_vec);\n+    else mask = vtype::ge(curr_vec, pivot_vec);\n+\n+    int amount_ge_pivot =\n+        vtype::double_compressstore(l_store, r_store, mask, curr_vec);\n+\n+    smallest_vec = vtype::min(curr_vec, smallest_vec);\n+    biggest_vec = vtype::max(curr_vec, biggest_vec);\n+\n+    return amount_ge_pivot;\n+}\n+\n+\/*\n+ * Parition an array based on the pivot and returns the index of the\n+ * first element that is greater than or equal to the pivot.\n+ *\/\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE arrsize_t partition_avx512(type_t *arr, arrsize_t left,\n+                                                arrsize_t right, type_t pivot,\n+                                                type_t *smallest,\n+                                                type_t *biggest,\n+                                                bool use_gt) {\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n+    \/* make array length divisible by vtype::numlanes , shortening the array *\/\n+    for (int32_t i = (right - left) % vtype::numlanes; i > 0; --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    if (left == right)\n+        return left; \/* less than vtype::numlanes elements in the array *\/\n+\n+    using reg_t = typename vtype::reg_t;\n+    reg_t pivot_vec = vtype::set1(pivot);\n+    reg_t min_vec = vtype::set1(*smallest);\n+    reg_t max_vec = vtype::set1(*biggest);\n+\n+    if (right - left == vtype::numlanes) {\n+        reg_t vec = vtype::loadu(arr + left);\n+        arrsize_t unpartitioned = right - left - vtype::numlanes;\n+        arrsize_t l_store = left;\n+\n+        arrsize_t amount_ge_pivot =\n+            partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                                 vec, pivot_vec, min_vec, max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        *smallest = vtype::reducemin(min_vec);\n+        *biggest = vtype::reducemax(max_vec);\n+        return l_store;\n+    }\n+\n+    \/\/ first and last vtype::numlanes values are partitioned at the end\n+    reg_t vec_left = vtype::loadu(arr + left);\n+    reg_t vec_right = vtype::loadu(arr + (right - vtype::numlanes));\n+    \/\/ store points of the vectors\n+    arrsize_t unpartitioned = right - left - vtype::numlanes;\n+    arrsize_t l_store = left;\n+    \/\/ indices for loading the elements\n+    left += vtype::numlanes;\n+    right -= vtype::numlanes;\n+    while (right - left != 0) {\n+        reg_t curr_vec;\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((l_store + unpartitioned + vtype::numlanes) - right <\n+            left - l_store) {\n+            right -= vtype::numlanes;\n+            curr_vec = vtype::loadu(arr + right);\n+        } else {\n+            curr_vec = vtype::loadu(arr + left);\n+            left += vtype::numlanes;\n+        }\n+        \/\/ partition the current vector and save it on both sides of the array\n+        arrsize_t amount_ge_pivot =\n+            partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                                 curr_vec, pivot_vec, min_vec, max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        unpartitioned -= vtype::numlanes;\n+    }\n+\n+    \/* partition and save vec_left and vec_right *\/\n+    arrsize_t amount_ge_pivot =\n+        partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                             vec_left, pivot_vec, min_vec, max_vec, use_gt);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    unpartitioned -= vtype::numlanes;\n+\n+    amount_ge_pivot =\n+        partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                             vec_right, pivot_vec, min_vec, max_vec, use_gt);\n+    l_store += (vtype::numlanes - amount_ge_pivot);\n+    unpartitioned -= vtype::numlanes;\n+\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+template <typename vtype, int num_unroll,\n+          typename type_t = typename vtype::type_t>\n+X86_SIMD_SORT_INLINE arrsize_t\n+partition_avx512_unrolled(type_t *arr, arrsize_t left, arrsize_t right,\n+                          type_t pivot, type_t *smallest, type_t *biggest, bool use_gt) {\n+    if constexpr (num_unroll == 0) {\n+        return partition_avx512<vtype>(arr, left, right, pivot, smallest,\n+                                       biggest, use_gt);\n+    }\n+\n+    \/* Use regular partition_avx512 for smaller arrays *\/\n+    if (right - left < 3 * num_unroll * vtype::numlanes) {\n+        return partition_avx512<vtype>(arr, left, right, pivot, smallest,\n+                                       biggest, use_gt);\n+    }\n+\n+    auto comparison_func = use_gt ? comparison_func_gt<vtype> : comparison_func_ge<vtype>;\n+    \/* make array length divisible by vtype::numlanes, shortening the array *\/\n+    for (int32_t i = ((right - left) % (vtype::numlanes)); i > 0; --i) {\n+        *smallest = std::min(*smallest, arr[left], comparison_func);\n+        *biggest = std::max(*biggest, arr[left], comparison_func);\n+        if (!comparison_func(arr[left], pivot)) {\n+            std::swap(arr[left], arr[--right]);\n+        } else {\n+            ++left;\n+        }\n+    }\n+\n+    arrsize_t unpartitioned = right - left - vtype::numlanes;\n+    arrsize_t l_store = left;\n+\n+    using reg_t = typename vtype::reg_t;\n+    reg_t pivot_vec = vtype::set1(pivot);\n+    reg_t min_vec = vtype::set1(*smallest);\n+    reg_t max_vec = vtype::set1(*biggest);\n+\n+    \/* Calculate and load more registers to make the rest of the array a\n+     * multiple of num_unroll. These registers will be partitioned at the very\n+     * end. *\/\n+    int vecsToPartition = ((right - left) \/ vtype::numlanes) % num_unroll;\n+    reg_t vec_align[num_unroll];\n+    for (int i = 0; i < vecsToPartition; i++) {\n+        vec_align[i] = vtype::loadu(arr + left + i * vtype::numlanes);\n+    }\n+    left += vecsToPartition * vtype::numlanes;\n+\n+    \/* We will now have atleast 3*num_unroll registers worth of data to\n+     * process. Load left and right vtype::numlanes*num_unroll values into\n+     * registers to make space for in-place parition. The vec_left and\n+     * vec_right registers are partitioned at the end *\/\n+    reg_t vec_left[num_unroll], vec_right[num_unroll];\n+    X86_SIMD_SORT_UNROLL_LOOP(8)\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        vec_left[ii] = vtype::loadu(arr + left + vtype::numlanes * ii);\n+        vec_right[ii] =\n+            vtype::loadu(arr + (right - vtype::numlanes * (num_unroll - ii)));\n+    }\n+    \/* indices for loading the elements *\/\n+    left += num_unroll * vtype::numlanes;\n+    right -= num_unroll * vtype::numlanes;\n+    while (right - left != 0) {\n+        reg_t curr_vec[num_unroll];\n+        \/*\n+         * if fewer elements are stored on the right side of the array,\n+         * then next elements are loaded from the right side,\n+         * otherwise from the left side\n+         *\/\n+        if ((l_store + unpartitioned + vtype::numlanes) - right <\n+            left - l_store) {\n+            right -= num_unroll * vtype::numlanes;\n+            X86_SIMD_SORT_UNROLL_LOOP(8)\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + right + ii * vtype::numlanes);\n+                \/*\n+                 * error: '_mm_prefetch' needs target feature mmx on clang-cl\n+                 *\/\n+#if !(defined(_MSC_VER) && defined(__clang__))\n+                _mm_prefetch((char *)(arr + right + ii * vtype::numlanes -\n+                                      num_unroll * vtype::numlanes),\n+                             _MM_HINT_T0);\n+#endif\n+            }\n+        } else {\n+            X86_SIMD_SORT_UNROLL_LOOP(8)\n+            for (int ii = 0; ii < num_unroll; ++ii) {\n+                curr_vec[ii] = vtype::loadu(arr + left + ii * vtype::numlanes);\n+                \/*\n+                 * error: '_mm_prefetch' needs target feature mmx on clang-cl\n+                 *\/\n+#if !(defined(_MSC_VER) && defined(__clang__))\n+                _mm_prefetch((char *)(arr + left + ii * vtype::numlanes +\n+                                      num_unroll * vtype::numlanes),\n+                             _MM_HINT_T0);\n+#endif\n+            }\n+            left += num_unroll * vtype::numlanes;\n+        }\n+        \/* partition the current vector and save it on both sides of the array\n+         * *\/\n+        X86_SIMD_SORT_UNROLL_LOOP(8)\n+        for (int ii = 0; ii < num_unroll; ++ii) {\n+            arrsize_t amount_ge_pivot = partition_vec<vtype>(\n+                arr + l_store, arr + l_store + unpartitioned, curr_vec[ii],\n+                pivot_vec, min_vec, max_vec, use_gt);\n+            l_store += (vtype::numlanes - amount_ge_pivot);\n+            unpartitioned -= vtype::numlanes;\n+        }\n+    }\n+\n+    \/* partition and save vec_left[num_unroll] and vec_right[num_unroll] *\/\n+    X86_SIMD_SORT_UNROLL_LOOP(8)\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        arrsize_t amount_ge_pivot =\n+            partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                                 vec_left[ii], pivot_vec, min_vec, max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        unpartitioned -= vtype::numlanes;\n+    }\n+    X86_SIMD_SORT_UNROLL_LOOP(8)\n+    for (int ii = 0; ii < num_unroll; ++ii) {\n+        arrsize_t amount_ge_pivot =\n+            partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                                 vec_right[ii], pivot_vec, min_vec, max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        unpartitioned -= vtype::numlanes;\n+    }\n+\n+    \/* partition and save vec_align[vecsToPartition] *\/\n+    X86_SIMD_SORT_UNROLL_LOOP(8)\n+    for (int ii = 0; ii < vecsToPartition; ++ii) {\n+        arrsize_t amount_ge_pivot =\n+            partition_vec<vtype>(arr + l_store, arr + l_store + unpartitioned,\n+                                 vec_align[ii], pivot_vec, min_vec, max_vec, use_gt);\n+        l_store += (vtype::numlanes - amount_ge_pivot);\n+        unpartitioned -= vtype::numlanes;\n+    }\n+\n+    *smallest = vtype::reducemin(min_vec);\n+    *biggest = vtype::reducemax(max_vec);\n+    return l_store;\n+}\n+\n+template <typename vtype, int maxN>\n+void sort_n(typename vtype::type_t *arr, int N);\n+\n+template <typename vtype, typename type_t>\n+static void qsort_(type_t *arr, arrsize_t left, arrsize_t right,\n+                   arrsize_t max_iters) {\n+    \/*\n+     * Resort to std::sort if quicksort isnt making any progress\n+     *\/\n+    if (max_iters <= 0) {\n+        std::sort(arr + left, arr + right + 1, comparison_func_ge<vtype>);\n+        return;\n+    }\n+    \/*\n+     * Base case: use bitonic networks to sort arrays <=\n+     * vtype::network_sort_threshold\n+     *\/\n+    if (right + 1 - left <= vtype::network_sort_threshold) {\n+        sort_n<vtype, vtype::network_sort_threshold>(\n+            arr + left, (int32_t)(right + 1 - left));\n+        return;\n+    }\n+\n+    type_t pivot = get_pivot_blocks<vtype, type_t>(arr, left, right);\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+\n+    arrsize_t pivot_index =\n+        partition_avx512_unrolled<vtype, vtype::partition_unroll_factor>(\n+            arr, left, right + 1, pivot, &smallest, &biggest, false);\n+\n+    if (pivot != smallest)\n+        qsort_<vtype>(arr, left, pivot_index - 1, max_iters - 1);\n+    if (pivot != biggest) qsort_<vtype>(arr, pivot_index, right, max_iters - 1);\n+}\n+\n+\/\/ Hooks for OpenJDK sort\n+\/\/ to_index (exclusive)\n+template <typename vtype, typename type_t>\n+static int64_t vectorized_partition(type_t *arr, int64_t from_index, int64_t to_index, type_t pivot, bool use_gt) {\n+    type_t smallest = vtype::type_max();\n+    type_t biggest = vtype::type_min();\n+    int64_t pivot_index = partition_avx512_unrolled<vtype, 2>(\n+            arr, from_index, to_index, pivot, &smallest, &biggest, use_gt);\n+    return pivot_index;\n+}\n+\n+\/\/ partitioning functions\n+template <typename vtype, typename T>\n+X86_SIMD_SORT_INLINE void simd_dual_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2){\n+    const T pivot1 = arr[index_pivot1];\n+    const T pivot2 = arr[index_pivot2];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    const int64_t start = low + 1;\n+    const int64_t end = high - 1;\n+\n+\n+    std::swap(arr[index_pivot1], arr[low]);\n+    std::swap(arr[index_pivot2], arr[end]);\n+\n+\n+    const int64_t pivot_index2 = vectorized_partition<vtype, T>(arr, start, end, pivot2, true); \/\/ use_gt = true\n+    std::swap(arr[end], arr[pivot_index2]);\n+    int64_t upper = pivot_index2;\n+\n+    \/\/ if all other elements are greater than pivot2 (and pivot1), no need to do further partitioning\n+    if (upper == start) {\n+        pivot_indices[0] = low;\n+        pivot_indices[1] = upper;\n+        return;\n+    }\n+\n+    const int64_t pivot_index1 = vectorized_partition<vtype, T>(arr, start, upper, pivot1, false); \/\/ use_ge (use_gt = false)\n+    int64_t lower = pivot_index1 - 1;\n+    std::swap(arr[low], arr[lower]);\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename vtype, typename T>\n+X86_SIMD_SORT_INLINE void simd_single_pivot_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot) {\n+    const T pivot = arr[index_pivot];\n+\n+    const int64_t low = from_index;\n+    const int64_t high = to_index;\n+    const int64_t end = high - 1;\n+\n+\n+    const int64_t pivot_index1 = vectorized_partition<vtype, T>(arr, low, high, pivot, false); \/\/ use_gt = false (use_ge)\n+    int64_t lower = pivot_index1;\n+\n+    const int64_t pivot_index2 = vectorized_partition<vtype, T>(arr, pivot_index1, high, pivot, true); \/\/ use_gt = true\n+    int64_t upper = pivot_index2;\n+\n+    pivot_indices[0] = lower;\n+    pivot_indices[1] = upper;\n+}\n+\n+template <typename vtype, typename T>\n+X86_SIMD_SORT_INLINE void simd_fast_partition(T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2) {\n+    if (index_pivot1 != index_pivot2) {\n+        simd_dual_pivot_partition<vtype, T>(arr, from_index, to_index, pivot_indices, index_pivot1, index_pivot2);\n+    }\n+    else {\n+        simd_single_pivot_partition<vtype, T>(arr, from_index, to_index, pivot_indices, index_pivot1);\n+    }\n+}\n+\n+template <typename T>\n+X86_SIMD_SORT_INLINE void insertion_sort(T *arr, int32_t from_index, int32_t to_index) {\n+    for (int i, k = from_index; ++k < to_index; ) {\n+        T ai = arr[i = k];\n+        if (ai < arr[i - 1]) {\n+            while (--i >= from_index && ai < arr[i]) {\n+                arr[i + 1] = arr[i];\n+            }\n+            arr[i + 1] = ai;\n+        }\n+    }\n+}\n+\n+template <typename vtype, typename T>\n+X86_SIMD_SORT_INLINE void simd_fast_sort(T *arr, arrsize_t from_index, arrsize_t to_index, const arrsize_t INS_SORT_THRESHOLD)\n+{\n+    arrsize_t arrsize = to_index - from_index;\n+    if (arrsize <= INS_SORT_THRESHOLD) {\n+        insertion_sort<T>(arr, from_index, to_index);\n+    } else {\n+        qsort_<vtype, T>(arr, from_index, to_index - 1, 2 * (arrsize_t)log2(arrsize));\n+    }\n+}\n+\n+#define DEFINE_METHODS(ISA, VTYPE) \\\n+    template <typename T> \\\n+    X86_SIMD_SORT_INLINE void ISA##_fast_sort( \\\n+            T *arr, arrsize_t from_index, arrsize_t to_index, const arrsize_t INS_SORT_THRESHOLD) \\\n+    { \\\n+        simd_fast_sort<VTYPE, T>(arr, from_index, to_index, INS_SORT_THRESHOLD); \\\n+    } \\\n+    template <typename T> \\\n+    X86_SIMD_SORT_INLINE void ISA##_fast_partition( \\\n+            T *arr, int64_t from_index, int64_t to_index, int32_t *pivot_indices, int64_t index_pivot1, int64_t index_pivot2) \\\n+    { \\\n+        simd_fast_partition<VTYPE, T>(arr, from_index, to_index, pivot_indices, index_pivot1, index_pivot2); \\\n+    }\n+\n+DEFINE_METHODS(avx2, avx2_vector<T>)\n+DEFINE_METHODS(avx512, zmm_vector<T>)\n+\n+#endif  \/\/ XSS_COMMON_QSORT\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-common-qsort.h","additions":528,"deletions":0,"binary":false,"changes":528,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+#ifndef XSS_NETWORK_QSORT\n+#define XSS_NETWORK_QSORT\n+\n+#include \"xss-common-qsort.h\"\n+#include \"xss-optimal-networks.hpp\"\n+\n+template <typename vtype, int numVecs, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void bitonic_sort_n_vec(reg_t *regs) {\n+    if constexpr (numVecs == 1) {\n+        UNUSED(regs);\n+        return;\n+    } else if constexpr (numVecs == 2) {\n+        COEX<vtype>(regs[0], regs[1]);\n+    } else if constexpr (numVecs == 4) {\n+        optimal_sort_4<vtype>(regs);\n+    } else if constexpr (numVecs == 8) {\n+        optimal_sort_8<vtype>(regs);\n+    } else if constexpr (numVecs == 16) {\n+        optimal_sort_16<vtype>(regs);\n+    } else if constexpr (numVecs == 32) {\n+        optimal_sort_32<vtype>(regs);\n+    } else {\n+        static_assert(numVecs == -1, \"should not reach here\");\n+    }\n+}\n+\n+\/*\n+ * Swizzle ops explained:\n+ * swap_n<scale>: swap neighbouring blocks of size <scale\/2> within block of\n+ * size <scale> reg i        = [7,6,5,4,3,2,1,0] swap_n<2>:   =\n+ * [[6,7],[4,5],[2,3],[0,1]] swap_n<4>:   = [[5,4,7,6],[1,0,3,2]] swap_n<8>:   =\n+ * [[3,2,1,0,7,6,5,4]] reverse_n<scale>: reverse elements within block of size\n+ * <scale> reg i        = [7,6,5,4,3,2,1,0] rev_n<2>:    =\n+ * [[6,7],[4,5],[2,3],[0,1]] rev_n<4>:    = [[4,5,6,7],[0,1,2,3]] rev_n<8>:    =\n+ * [[0,1,2,3,4,5,6,7]] merge_n<scale>: merge blocks of <scale\/2> elements from\n+ * two regs reg b,a      = [a,a,a,a,a,a,a,a], [b,b,b,b,b,b,b,b] merge_n<2>   =\n+ * [a,b,a,b,a,b,a,b] merge_n<4>   = [a,a,b,b,a,a,b,b] merge_n<8>   =\n+ * [a,a,a,a,b,b,b,b]\n+ *\/\n+\n+template <typename vtype, int numVecs, int scale, bool first = true>\n+X86_SIMD_SORT_FINLINE void internal_merge_n_vec(typename vtype::reg_t *reg) {\n+    using reg_t = typename vtype::reg_t;\n+    using swizzle = typename vtype::swizzle_ops;\n+    if constexpr (scale <= 1) {\n+        UNUSED(reg);\n+        return;\n+    } else {\n+        if constexpr (first) {\n+            \/\/ Use reverse then merge\n+            X86_SIMD_SORT_UNROLL_LOOP(64)\n+            for (int i = 0; i < numVecs; i++) {\n+                reg_t &v = reg[i];\n+                reg_t rev = swizzle::template reverse_n<vtype, scale>(v);\n+                COEX<vtype>(rev, v);\n+                v = swizzle::template merge_n<vtype, scale>(v, rev);\n+            }\n+        } else {\n+            \/\/ Use swap then merge\n+            X86_SIMD_SORT_UNROLL_LOOP(64)\n+            for (int i = 0; i < numVecs; i++) {\n+                reg_t &v = reg[i];\n+                reg_t swap = swizzle::template swap_n<vtype, scale>(v);\n+                COEX<vtype>(swap, v);\n+                v = swizzle::template merge_n<vtype, scale>(v, swap);\n+            }\n+        }\n+        internal_merge_n_vec<vtype, numVecs, scale \/ 2, false>(reg);\n+    }\n+}\n+\n+template <typename vtype, int numVecs, int scale,\n+          typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void merge_substep_n_vec(reg_t *regs) {\n+    using swizzle = typename vtype::swizzle_ops;\n+    if constexpr (numVecs <= 1) {\n+        UNUSED(regs);\n+        return;\n+    }\n+\n+    \/\/ Reverse upper half of vectors\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = numVecs \/ 2; i < numVecs; i++) {\n+        regs[i] = swizzle::template reverse_n<vtype, scale>(regs[i]);\n+    }\n+    \/\/ Do compare exchanges\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = 0; i < numVecs \/ 2; i++) {\n+        COEX<vtype>(regs[i], regs[numVecs - 1 - i]);\n+    }\n+\n+    merge_substep_n_vec<vtype, numVecs \/ 2, scale>(regs);\n+    merge_substep_n_vec<vtype, numVecs \/ 2, scale>(regs + numVecs \/ 2);\n+}\n+\n+template <typename vtype, int numVecs, int scale,\n+          typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void merge_step_n_vec(reg_t *regs) {\n+    \/\/ Do cross vector merges\n+    merge_substep_n_vec<vtype, numVecs, scale>(regs);\n+\n+    \/\/ Do internal vector merges\n+    internal_merge_n_vec<vtype, numVecs, scale>(regs);\n+}\n+\n+template <typename vtype, int numVecs, int numPer = 2,\n+          typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void merge_n_vec(reg_t *regs) {\n+    if constexpr (numPer > vtype::numlanes) {\n+        UNUSED(regs);\n+        return;\n+    } else {\n+        merge_step_n_vec<vtype, numVecs, numPer>(regs);\n+        merge_n_vec<vtype, numVecs, numPer * 2>(regs);\n+    }\n+}\n+\n+template <typename vtype, int numVecs, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_INLINE void sort_n_vec(typename vtype::type_t *arr, int N) {\n+    static_assert(numVecs > 0, \"numVecs should be > 0\");\n+    if constexpr (numVecs > 1) {\n+        if (N * 2 <= numVecs * vtype::numlanes) {\n+            sort_n_vec<vtype, numVecs \/ 2>(arr, N);\n+            return;\n+        }\n+    }\n+\n+    reg_t vecs[numVecs];\n+\n+    \/\/ Generate masks for loading and storing\n+    typename vtype::opmask_t ioMasks[numVecs - numVecs \/ 2];\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = numVecs \/ 2, j = 0; i < numVecs; i++, j++) {\n+        uint64_t num_to_read =\n+            std::min((uint64_t)std::max(0, N - i * vtype::numlanes),\n+                     (uint64_t)vtype::numlanes);\n+        ioMasks[j] = vtype::get_partial_loadmask(num_to_read);\n+    }\n+\n+    \/\/ Unmasked part of the load\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = 0; i < numVecs \/ 2; i++) {\n+        vecs[i] = vtype::loadu(arr + i * vtype::numlanes);\n+    }\n+    \/\/ Masked part of the load\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = numVecs \/ 2, j = 0; i < numVecs; i++, j++) {\n+        vecs[i] = vtype::mask_loadu(vtype::zmm_max(), ioMasks[j],\n+                                    arr + i * vtype::numlanes);\n+    }\n+\n+    \/* Run the initial sorting network to sort the columns of the [numVecs x\n+     * num_lanes] matrix\n+     *\/\n+    bitonic_sort_n_vec<vtype, numVecs>(vecs);\n+\n+    \/\/ Merge the vectors using bitonic merging networks\n+    merge_n_vec<vtype, numVecs>(vecs);\n+\n+    \/\/ Unmasked part of the store\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = 0; i < numVecs \/ 2; i++) {\n+        vtype::storeu(arr + i * vtype::numlanes, vecs[i]);\n+    }\n+    \/\/ Masked part of the store\n+    X86_SIMD_SORT_UNROLL_LOOP(64)\n+    for (int i = numVecs \/ 2, j = 0; i < numVecs; i++, j++) {\n+        vtype::mask_storeu(arr + i * vtype::numlanes, ioMasks[j], vecs[i]);\n+    }\n+}\n+\n+template <typename vtype, int maxN>\n+X86_SIMD_SORT_INLINE void sort_n(typename vtype::type_t *arr, int N) {\n+    constexpr int numVecs = maxN \/ vtype::numlanes;\n+    constexpr bool isMultiple = (maxN == (vtype::numlanes * numVecs));\n+    constexpr bool powerOfTwo = (numVecs != 0 && !(numVecs & (numVecs - 1)));\n+    static_assert(powerOfTwo == true && isMultiple == true,\n+                  \"maxN must be vtype::numlanes times a power of 2\");\n+\n+    sort_n_vec<vtype, numVecs>(arr, N);\n+}\n+#endif\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-network-qsort.hpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort) All of these sources\n+\/\/ files are generated from the optimal networks described in\n+\/\/ https:\/\/bertdobbelaere.github.io\/sorting_networks.html\n+\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void optimal_sort_4(reg_t *vecs) {\n+    COEX<vtype>(vecs[0], vecs[2]);\n+    COEX<vtype>(vecs[1], vecs[3]);\n+\n+    COEX<vtype>(vecs[0], vecs[1]);\n+    COEX<vtype>(vecs[2], vecs[3]);\n+\n+    COEX<vtype>(vecs[1], vecs[2]);\n+}\n+\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void optimal_sort_8(reg_t *vecs) {\n+    COEX<vtype>(vecs[0], vecs[2]);\n+    COEX<vtype>(vecs[1], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[6]);\n+    COEX<vtype>(vecs[5], vecs[7]);\n+\n+    COEX<vtype>(vecs[0], vecs[4]);\n+    COEX<vtype>(vecs[1], vecs[5]);\n+    COEX<vtype>(vecs[2], vecs[6]);\n+    COEX<vtype>(vecs[3], vecs[7]);\n+\n+    COEX<vtype>(vecs[0], vecs[1]);\n+    COEX<vtype>(vecs[2], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[5]);\n+    COEX<vtype>(vecs[6], vecs[7]);\n+\n+    COEX<vtype>(vecs[2], vecs[4]);\n+    COEX<vtype>(vecs[3], vecs[5]);\n+\n+    COEX<vtype>(vecs[1], vecs[4]);\n+    COEX<vtype>(vecs[3], vecs[6]);\n+\n+    COEX<vtype>(vecs[1], vecs[2]);\n+    COEX<vtype>(vecs[3], vecs[4]);\n+    COEX<vtype>(vecs[5], vecs[6]);\n+}\n+\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void optimal_sort_16(reg_t *vecs) {\n+    COEX<vtype>(vecs[0], vecs[13]);\n+    COEX<vtype>(vecs[1], vecs[12]);\n+    COEX<vtype>(vecs[2], vecs[15]);\n+    COEX<vtype>(vecs[3], vecs[14]);\n+    COEX<vtype>(vecs[4], vecs[8]);\n+    COEX<vtype>(vecs[5], vecs[6]);\n+    COEX<vtype>(vecs[7], vecs[11]);\n+    COEX<vtype>(vecs[9], vecs[10]);\n+\n+    COEX<vtype>(vecs[0], vecs[5]);\n+    COEX<vtype>(vecs[1], vecs[7]);\n+    COEX<vtype>(vecs[2], vecs[9]);\n+    COEX<vtype>(vecs[3], vecs[4]);\n+    COEX<vtype>(vecs[6], vecs[13]);\n+    COEX<vtype>(vecs[8], vecs[14]);\n+    COEX<vtype>(vecs[10], vecs[15]);\n+    COEX<vtype>(vecs[11], vecs[12]);\n+\n+    COEX<vtype>(vecs[0], vecs[1]);\n+    COEX<vtype>(vecs[2], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[5]);\n+    COEX<vtype>(vecs[6], vecs[8]);\n+    COEX<vtype>(vecs[7], vecs[9]);\n+    COEX<vtype>(vecs[10], vecs[11]);\n+    COEX<vtype>(vecs[12], vecs[13]);\n+    COEX<vtype>(vecs[14], vecs[15]);\n+\n+    COEX<vtype>(vecs[0], vecs[2]);\n+    COEX<vtype>(vecs[1], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[10]);\n+    COEX<vtype>(vecs[5], vecs[11]);\n+    COEX<vtype>(vecs[6], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[9]);\n+    COEX<vtype>(vecs[12], vecs[14]);\n+    COEX<vtype>(vecs[13], vecs[15]);\n+\n+    COEX<vtype>(vecs[1], vecs[2]);\n+    COEX<vtype>(vecs[3], vecs[12]);\n+    COEX<vtype>(vecs[4], vecs[6]);\n+    COEX<vtype>(vecs[5], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[10]);\n+    COEX<vtype>(vecs[9], vecs[11]);\n+    COEX<vtype>(vecs[13], vecs[14]);\n+\n+    COEX<vtype>(vecs[1], vecs[4]);\n+    COEX<vtype>(vecs[2], vecs[6]);\n+    COEX<vtype>(vecs[5], vecs[8]);\n+    COEX<vtype>(vecs[7], vecs[10]);\n+    COEX<vtype>(vecs[9], vecs[13]);\n+    COEX<vtype>(vecs[11], vecs[14]);\n+\n+    COEX<vtype>(vecs[2], vecs[4]);\n+    COEX<vtype>(vecs[3], vecs[6]);\n+    COEX<vtype>(vecs[9], vecs[12]);\n+    COEX<vtype>(vecs[11], vecs[13]);\n+\n+    COEX<vtype>(vecs[3], vecs[5]);\n+    COEX<vtype>(vecs[6], vecs[8]);\n+    COEX<vtype>(vecs[7], vecs[9]);\n+    COEX<vtype>(vecs[10], vecs[12]);\n+\n+    COEX<vtype>(vecs[3], vecs[4]);\n+    COEX<vtype>(vecs[5], vecs[6]);\n+    COEX<vtype>(vecs[7], vecs[8]);\n+    COEX<vtype>(vecs[9], vecs[10]);\n+    COEX<vtype>(vecs[11], vecs[12]);\n+\n+    COEX<vtype>(vecs[6], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[9]);\n+}\n+\n+template <typename vtype, typename reg_t = typename vtype::reg_t>\n+X86_SIMD_SORT_FINLINE void optimal_sort_32(reg_t *vecs) {\n+    COEX<vtype>(vecs[0], vecs[1]);\n+    COEX<vtype>(vecs[2], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[5]);\n+    COEX<vtype>(vecs[6], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[9]);\n+    COEX<vtype>(vecs[10], vecs[11]);\n+    COEX<vtype>(vecs[12], vecs[13]);\n+    COEX<vtype>(vecs[14], vecs[15]);\n+    COEX<vtype>(vecs[16], vecs[17]);\n+    COEX<vtype>(vecs[18], vecs[19]);\n+    COEX<vtype>(vecs[20], vecs[21]);\n+    COEX<vtype>(vecs[22], vecs[23]);\n+    COEX<vtype>(vecs[24], vecs[25]);\n+    COEX<vtype>(vecs[26], vecs[27]);\n+    COEX<vtype>(vecs[28], vecs[29]);\n+    COEX<vtype>(vecs[30], vecs[31]);\n+\n+    COEX<vtype>(vecs[0], vecs[2]);\n+    COEX<vtype>(vecs[1], vecs[3]);\n+    COEX<vtype>(vecs[4], vecs[6]);\n+    COEX<vtype>(vecs[5], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[10]);\n+    COEX<vtype>(vecs[9], vecs[11]);\n+    COEX<vtype>(vecs[12], vecs[14]);\n+    COEX<vtype>(vecs[13], vecs[15]);\n+    COEX<vtype>(vecs[16], vecs[18]);\n+    COEX<vtype>(vecs[17], vecs[19]);\n+    COEX<vtype>(vecs[20], vecs[22]);\n+    COEX<vtype>(vecs[21], vecs[23]);\n+    COEX<vtype>(vecs[24], vecs[26]);\n+    COEX<vtype>(vecs[25], vecs[27]);\n+    COEX<vtype>(vecs[28], vecs[30]);\n+    COEX<vtype>(vecs[29], vecs[31]);\n+\n+    COEX<vtype>(vecs[0], vecs[4]);\n+    COEX<vtype>(vecs[1], vecs[5]);\n+    COEX<vtype>(vecs[2], vecs[6]);\n+    COEX<vtype>(vecs[3], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[12]);\n+    COEX<vtype>(vecs[9], vecs[13]);\n+    COEX<vtype>(vecs[10], vecs[14]);\n+    COEX<vtype>(vecs[11], vecs[15]);\n+    COEX<vtype>(vecs[16], vecs[20]);\n+    COEX<vtype>(vecs[17], vecs[21]);\n+    COEX<vtype>(vecs[18], vecs[22]);\n+    COEX<vtype>(vecs[19], vecs[23]);\n+    COEX<vtype>(vecs[24], vecs[28]);\n+    COEX<vtype>(vecs[25], vecs[29]);\n+    COEX<vtype>(vecs[26], vecs[30]);\n+    COEX<vtype>(vecs[27], vecs[31]);\n+\n+    COEX<vtype>(vecs[0], vecs[8]);\n+    COEX<vtype>(vecs[1], vecs[9]);\n+    COEX<vtype>(vecs[2], vecs[10]);\n+    COEX<vtype>(vecs[3], vecs[11]);\n+    COEX<vtype>(vecs[4], vecs[12]);\n+    COEX<vtype>(vecs[5], vecs[13]);\n+    COEX<vtype>(vecs[6], vecs[14]);\n+    COEX<vtype>(vecs[7], vecs[15]);\n+    COEX<vtype>(vecs[16], vecs[24]);\n+    COEX<vtype>(vecs[17], vecs[25]);\n+    COEX<vtype>(vecs[18], vecs[26]);\n+    COEX<vtype>(vecs[19], vecs[27]);\n+    COEX<vtype>(vecs[20], vecs[28]);\n+    COEX<vtype>(vecs[21], vecs[29]);\n+    COEX<vtype>(vecs[22], vecs[30]);\n+    COEX<vtype>(vecs[23], vecs[31]);\n+\n+    COEX<vtype>(vecs[0], vecs[16]);\n+    COEX<vtype>(vecs[1], vecs[8]);\n+    COEX<vtype>(vecs[2], vecs[4]);\n+    COEX<vtype>(vecs[3], vecs[12]);\n+    COEX<vtype>(vecs[5], vecs[10]);\n+    COEX<vtype>(vecs[6], vecs[9]);\n+    COEX<vtype>(vecs[7], vecs[14]);\n+    COEX<vtype>(vecs[11], vecs[13]);\n+    COEX<vtype>(vecs[15], vecs[31]);\n+    COEX<vtype>(vecs[17], vecs[24]);\n+    COEX<vtype>(vecs[18], vecs[20]);\n+    COEX<vtype>(vecs[19], vecs[28]);\n+    COEX<vtype>(vecs[21], vecs[26]);\n+    COEX<vtype>(vecs[22], vecs[25]);\n+    COEX<vtype>(vecs[23], vecs[30]);\n+    COEX<vtype>(vecs[27], vecs[29]);\n+\n+    COEX<vtype>(vecs[1], vecs[2]);\n+    COEX<vtype>(vecs[3], vecs[5]);\n+    COEX<vtype>(vecs[4], vecs[8]);\n+    COEX<vtype>(vecs[6], vecs[22]);\n+    COEX<vtype>(vecs[7], vecs[11]);\n+    COEX<vtype>(vecs[9], vecs[25]);\n+    COEX<vtype>(vecs[10], vecs[12]);\n+    COEX<vtype>(vecs[13], vecs[14]);\n+    COEX<vtype>(vecs[17], vecs[18]);\n+    COEX<vtype>(vecs[19], vecs[21]);\n+    COEX<vtype>(vecs[20], vecs[24]);\n+    COEX<vtype>(vecs[23], vecs[27]);\n+    COEX<vtype>(vecs[26], vecs[28]);\n+    COEX<vtype>(vecs[29], vecs[30]);\n+\n+    COEX<vtype>(vecs[1], vecs[17]);\n+    COEX<vtype>(vecs[2], vecs[18]);\n+    COEX<vtype>(vecs[3], vecs[19]);\n+    COEX<vtype>(vecs[4], vecs[20]);\n+    COEX<vtype>(vecs[5], vecs[10]);\n+    COEX<vtype>(vecs[7], vecs[23]);\n+    COEX<vtype>(vecs[8], vecs[24]);\n+    COEX<vtype>(vecs[11], vecs[27]);\n+    COEX<vtype>(vecs[12], vecs[28]);\n+    COEX<vtype>(vecs[13], vecs[29]);\n+    COEX<vtype>(vecs[14], vecs[30]);\n+    COEX<vtype>(vecs[21], vecs[26]);\n+\n+    COEX<vtype>(vecs[3], vecs[17]);\n+    COEX<vtype>(vecs[4], vecs[16]);\n+    COEX<vtype>(vecs[5], vecs[21]);\n+    COEX<vtype>(vecs[6], vecs[18]);\n+    COEX<vtype>(vecs[7], vecs[9]);\n+    COEX<vtype>(vecs[8], vecs[20]);\n+    COEX<vtype>(vecs[10], vecs[26]);\n+    COEX<vtype>(vecs[11], vecs[23]);\n+    COEX<vtype>(vecs[13], vecs[25]);\n+    COEX<vtype>(vecs[14], vecs[28]);\n+    COEX<vtype>(vecs[15], vecs[27]);\n+    COEX<vtype>(vecs[22], vecs[24]);\n+\n+    COEX<vtype>(vecs[1], vecs[4]);\n+    COEX<vtype>(vecs[3], vecs[8]);\n+    COEX<vtype>(vecs[5], vecs[16]);\n+    COEX<vtype>(vecs[7], vecs[17]);\n+    COEX<vtype>(vecs[9], vecs[21]);\n+    COEX<vtype>(vecs[10], vecs[22]);\n+    COEX<vtype>(vecs[11], vecs[19]);\n+    COEX<vtype>(vecs[12], vecs[20]);\n+    COEX<vtype>(vecs[14], vecs[24]);\n+    COEX<vtype>(vecs[15], vecs[26]);\n+    COEX<vtype>(vecs[23], vecs[28]);\n+    COEX<vtype>(vecs[27], vecs[30]);\n+\n+    COEX<vtype>(vecs[2], vecs[5]);\n+    COEX<vtype>(vecs[7], vecs[8]);\n+    COEX<vtype>(vecs[9], vecs[18]);\n+    COEX<vtype>(vecs[11], vecs[17]);\n+    COEX<vtype>(vecs[12], vecs[16]);\n+    COEX<vtype>(vecs[13], vecs[22]);\n+    COEX<vtype>(vecs[14], vecs[20]);\n+    COEX<vtype>(vecs[15], vecs[19]);\n+    COEX<vtype>(vecs[23], vecs[24]);\n+    COEX<vtype>(vecs[26], vecs[29]);\n+\n+    COEX<vtype>(vecs[2], vecs[4]);\n+    COEX<vtype>(vecs[6], vecs[12]);\n+    COEX<vtype>(vecs[9], vecs[16]);\n+    COEX<vtype>(vecs[10], vecs[11]);\n+    COEX<vtype>(vecs[13], vecs[17]);\n+    COEX<vtype>(vecs[14], vecs[18]);\n+    COEX<vtype>(vecs[15], vecs[22]);\n+    COEX<vtype>(vecs[19], vecs[25]);\n+    COEX<vtype>(vecs[20], vecs[21]);\n+    COEX<vtype>(vecs[27], vecs[29]);\n+\n+    COEX<vtype>(vecs[5], vecs[6]);\n+    COEX<vtype>(vecs[8], vecs[12]);\n+    COEX<vtype>(vecs[9], vecs[10]);\n+    COEX<vtype>(vecs[11], vecs[13]);\n+    COEX<vtype>(vecs[14], vecs[16]);\n+    COEX<vtype>(vecs[15], vecs[17]);\n+    COEX<vtype>(vecs[18], vecs[20]);\n+    COEX<vtype>(vecs[19], vecs[23]);\n+    COEX<vtype>(vecs[21], vecs[22]);\n+    COEX<vtype>(vecs[25], vecs[26]);\n+\n+    COEX<vtype>(vecs[3], vecs[5]);\n+    COEX<vtype>(vecs[6], vecs[7]);\n+    COEX<vtype>(vecs[8], vecs[9]);\n+    COEX<vtype>(vecs[10], vecs[12]);\n+    COEX<vtype>(vecs[11], vecs[14]);\n+    COEX<vtype>(vecs[13], vecs[16]);\n+    COEX<vtype>(vecs[15], vecs[18]);\n+    COEX<vtype>(vecs[17], vecs[20]);\n+    COEX<vtype>(vecs[19], vecs[21]);\n+    COEX<vtype>(vecs[22], vecs[23]);\n+    COEX<vtype>(vecs[24], vecs[25]);\n+    COEX<vtype>(vecs[26], vecs[28]);\n+\n+    COEX<vtype>(vecs[3], vecs[4]);\n+    COEX<vtype>(vecs[5], vecs[6]);\n+    COEX<vtype>(vecs[7], vecs[8]);\n+    COEX<vtype>(vecs[9], vecs[10]);\n+    COEX<vtype>(vecs[11], vecs[12]);\n+    COEX<vtype>(vecs[13], vecs[14]);\n+    COEX<vtype>(vecs[15], vecs[16]);\n+    COEX<vtype>(vecs[17], vecs[18]);\n+    COEX<vtype>(vecs[19], vecs[20]);\n+    COEX<vtype>(vecs[21], vecs[22]);\n+    COEX<vtype>(vecs[23], vecs[24]);\n+    COEX<vtype>(vecs[25], vecs[26]);\n+    COEX<vtype>(vecs[27], vecs[28]);\n+}\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-optimal-networks.hpp","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2021 Serge Sans Paille. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This implementation is based on x86-simd-sort(https:\/\/github.com\/intel\/x86-simd-sort)\n+\n+template <typename vtype, typename mm_t>\n+X86_SIMD_SORT_INLINE void COEX(mm_t &a, mm_t &b);\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE type_t get_pivot(type_t *arr, const arrsize_t left,\n+                                      const arrsize_t right) {\n+    using reg_t = typename vtype::reg_t;\n+    type_t samples[vtype::numlanes];\n+    arrsize_t delta = (right - left) \/ vtype::numlanes;\n+    for (int i = 0; i < vtype::numlanes; i++) {\n+        samples[i] = arr[left + i * delta];\n+    }\n+    reg_t rand_vec = vtype::loadu(samples);\n+    reg_t sort = vtype::sort_vec(rand_vec);\n+\n+    return ((type_t *)&sort)[vtype::numlanes \/ 2];\n+}\n+\n+template <typename vtype, typename type_t>\n+X86_SIMD_SORT_INLINE type_t get_pivot_blocks(type_t *arr, const arrsize_t left,\n+                                             const arrsize_t right) {\n+    if (right - left <= 1024) {\n+        return get_pivot<vtype>(arr, left, right);\n+    }\n+\n+    using reg_t = typename vtype::reg_t;\n+    constexpr int numVecs = 5;\n+\n+    arrsize_t width = (right - vtype::numlanes) - left;\n+    arrsize_t delta = width \/ numVecs;\n+\n+    reg_t vecs[numVecs];\n+    \/\/ Load data\n+    for (int i = 0; i < numVecs; i++) {\n+        vecs[i] = vtype::loadu(arr + left + delta * i);\n+    }\n+\n+    \/\/ Implement sorting network (from\n+    \/\/ https:\/\/bertdobbelaere.github.io\/sorting_networks.html)\n+    COEX<vtype>(vecs[0], vecs[3]);\n+    COEX<vtype>(vecs[1], vecs[4]);\n+\n+    COEX<vtype>(vecs[0], vecs[2]);\n+    COEX<vtype>(vecs[1], vecs[3]);\n+\n+    COEX<vtype>(vecs[0], vecs[1]);\n+    COEX<vtype>(vecs[2], vecs[4]);\n+\n+    COEX<vtype>(vecs[1], vecs[2]);\n+    COEX<vtype>(vecs[3], vecs[4]);\n+\n+    COEX<vtype>(vecs[2], vecs[3]);\n+\n+    \/\/ Calculate median of the middle vector\n+    reg_t &vec = vecs[numVecs \/ 2];\n+    vec = vtype::sort_vec(vec);\n+\n+    type_t data[vtype::numlanes];\n+    vtype::storeu(data, vec);\n+    return data[vtype::numlanes \/ 2];\n+}\n","filename":"src\/java.base\/linux\/native\/libsimdsort\/xss-pivot-selection.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}