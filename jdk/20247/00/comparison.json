{"files":[{"patch":"@@ -54,1 +54,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -72,1 +69,0 @@\n-        extends Annotation\n@@ -183,19 +179,1 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation on the type use target}\n@@ -203,19 +181,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -227,2 +187,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +190,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":6,"deletions":48,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,1 +284,0 @@\n-        \/\/ handles annotations and type annotations\n@@ -291,2 +288,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +296,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":63,"deletions":7,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -404,3 +404,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -753,10 +751,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -764,58 +753,2 @@\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n-\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -103,1 +103,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -118,1 +118,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}