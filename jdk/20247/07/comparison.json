{"files":[{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -29,0 +31,1 @@\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n@@ -31,0 +34,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n@@ -40,1 +44,57 @@\n- * Models an annotation on a declaration.\n+ * Models an {@code annotation} structure ({@jvms 4.7.16}) or part of a {@code\n+ * type_annotation} structure ({@jvms 4.7.20}).\n+ * <p>\n+ * Each {@code annotation} structure denotes an annotation that applies to a\n+ * construct in Java source code ({@jls 9.7.4}).\n+ * Similarly, each {@code type_annotation} structure denotes an annotation\n+ * that applies to a type in Java source code.\n+ * In either case, the structure indicates the interface of the annotation\n+ * and a set of element-value pairs.\n+ * <p>\n+ * In an annotation in Java source code, elements in the annotation interface\n+ * with default values may not be represented unless an explicit value is provided.\n+ * ({@jls 9.6.2}) The default value is derived from the {@link AnnotationDefaultAttribute\n+ * AnnotationDefault} attribute on the method representing the annotation\n+ * interface element, in the class file representing the annotation interface.\n+ * <p id=\"repeatable\">\n+ * Multiple annotations of the same interface <i>A<\/i> in Java source code\n+ * ({@jls 9.7.5}) are represented by the {@linkplain AnnotationValue.OfAnnotation\n+ * annotation-valued} array elements of the {@linkplain AnnotationValue.OfArray\n+ * array-valued} element named {@code value} of a container annotation, whose\n+ * interface is the containing annotation interface of <i>A<\/i>. ({@jls 9.6.3})\n+ * <p>\n+ * The location in the class file of an {@code annotation} structure or a\n+ * {@code type_annotation} structure,\n+ * respectively, indicates the source code construct or type, respectively, to\n+ * which the annotation applies.\n+ * Accordingly, an {@code Annotation} may represent:\n+ * <ul>\n+ * <li>A <i>declaration annotation<\/i> on a class, field, method, or record\n+ * component declaration, when an {@code annotation} structure appears in the\n+ * {@link RuntimeVisibleAnnotationsAttribute} or\n+ * {@link RuntimeInvisibleAnnotationsAttribute} of a class, field, method, or\n+ * record component.\n+ * <li>A <i>declaration annotation<\/i> on a method parameter declaration, when\n+ * an {@code annotation} structure appears in the\n+ * {@link RuntimeVisibleParameterAnnotationsAttribute} or\n+ * {@link RuntimeInvisibleParameterAnnotationsAttribute} of a method.\n+ * <li>The {@linkplain AnnotationValue.OfAnnotation element value} of an\n+ * annotation, where the type of the element value is itself an annotation\n+ * interface. In this case, the {@code annotation} structure appears as the\n+ * {@code annotation_value} item of an {@code element_value} structure\n+ * ({@jvms 4.7.16.1}).<br>\n+ * If this annotation is of a {@linkplain ##repeatable repeatable} annotation\n+ * interface <i>A<\/i>, is an array element of an array-valued element named\n+ * {@code value} in a container annotation, and the interface of the container\n+ * annotation is the containing annotation interface <i>AC<\/i> of <i>A<\/i>,\n+ * this annotation represents a base annotation of type <i>A<\/i>, which applies\n+ * to the same source code construct or type as the container annotation of\n+ * type <i>AC<\/i>.\n+ * <li>A <i>type annotation<\/i>, when a {@code type_annotation} structure\n+ * appears in the {@link RuntimeVisibleTypeAnnotationsAttribute}\n+ * or {@link RuntimeInvisibleTypeAnnotationsAttribute} of a class, field,\n+ * method, {@link CodeAttribute}, or record component.\n+ * <\/ul>\n+ * <p>\n+ * Two {@code Annotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -44,0 +104,1 @@\n+ * @see TypeAnnotation\n@@ -49,1 +110,0 @@\n- * @sealedGraph\n@@ -54,1 +114,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n@@ -57,1 +117,2 @@\n-     * {@return the class of the annotation}\n+     * {@return the constant pool entry holding the {@linkplain Class#descriptorString\n+     * descriptor string} of the annotation interface}\n@@ -62,1 +123,1 @@\n-     * {@return the class of the annotation, as a symbolic descriptor}\n+     * {@return the annotation interface, as a symbolic descriptor}\n@@ -69,1 +130,1 @@\n-     * {@return the elements of the annotation}\n+     * {@return the element-value pairs of the annotation}\n@@ -75,2 +136,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -85,2 +147,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -95,2 +158,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -105,2 +168,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":77,"deletions":14,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -35,1 +35,7 @@\n- * Models a key-value pair of an annotation.\n+ * Models an element-value pair in the {@code element_value_pairs}\n+ * table in the {@code annotation} structure defined in\n+ * {@jvms 4.7.16} or the {@code type_annotation} structure defined\n+ * in {@jvms 4.7.20}.\n+ * <p>\n+ * Two {@code AnnotationElement} objects should be compared using the\n+ * {@link Object#equals(Object) equals} method.\n@@ -48,0 +54,8 @@\n+     *\n+     * @apiNote\n+     * In Java source code, by convention, the name of the sole element in a\n+     * single-element annotation interface is {@code value}. ({@jls 9.6.1})\n+     * A single-element annotation ({@jls 9.7.3}) declares the element value\n+     * for the {@code value} element. The single element of a containing\n+     * annotation interface that holds {@linkplain Annotation##repeatable\n+     * multiple} base annotations is also named {@code value}. ({@jls 9.6.3})\n@@ -57,1 +71,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an annotation element-value pair}\n@@ -67,1 +81,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an annotation element-value pair}\n@@ -77,1 +91,1 @@\n-     * {@return an annotation key-value pair for a class-valued annotation}\n+     * {@return an annotation element-value pair for a class-valued annotation}\n@@ -87,1 +101,1 @@\n-     * {@return an annotation key-value pair for a string-valued annotation}\n+     * {@return an annotation element-value pair for a string-valued annotation}\n@@ -97,1 +111,1 @@\n-     * {@return an annotation key-value pair for a long-valued annotation}\n+     * {@return an annotation element-value pair for a long-valued annotation}\n@@ -107,1 +121,1 @@\n-     * {@return an annotation key-value pair for an int-valued annotation}\n+     * {@return an annotation element-value pair for an int-valued annotation}\n@@ -117,1 +131,1 @@\n-     * {@return an annotation key-value pair for a char-valued annotation}\n+     * {@return an annotation element-value pair for a char-valued annotation}\n@@ -127,1 +141,1 @@\n-     * {@return an annotation key-value pair for a short-valued annotation}\n+     * {@return an annotation element-value pair for a short-valued annotation}\n@@ -137,1 +151,1 @@\n-     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * {@return an annotation element-value pair for a byte-valued annotation}\n@@ -147,1 +161,1 @@\n-     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * {@return an annotation element-value pair for a boolean-valued annotation}\n@@ -157,1 +171,1 @@\n-     * {@return an annotation key-value pair for a double-valued annotation}\n+     * {@return an annotation element-value pair for a double-valued annotation}\n@@ -167,1 +181,1 @@\n-     * {@return an annotation key-value pair for a float-valued annotation}\n+     * {@return an annotation element-value pair for a float-valued annotation}\n@@ -177,1 +191,1 @@\n-     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * {@return an annotation element-value pair for an annotation-valued annotation}\n@@ -187,1 +201,1 @@\n-     * {@return an annotation key-value pair for an array-valued annotation}\n+     * {@return an annotation element-value pair for an array-valued annotation}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,5 @@\n- * Models the value of a key-value pair of an annotation.\n+ * Models the {@code element_value} structure, or the value of an element-value\n+ * pair of an annotation, as defined in {@jvms 4.7.16.1}.\n+ * <p>\n+ * Two {@code AnnotationValue} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -63,1 +60,29 @@\n- * Models an annotation on a type use, as defined in {@jvms 4.7.19} and {@jvms 4.7.20}.\n+ * Models a {@code type_annotation} structure ({@jvms 4.7.20}).\n+ * <p>\n+ * Each {@code type_annotation} structure denotes an annotation that applies\n+ * to a type in Java source code ({@jls 9.7.4}). The structure indicates the\n+ * interface of the annotation and a set of element-value pairs; this\n+ * information is exposed by the {@link #annotation() annotation()} method.\n+ * <p>\n+ * Multiple annotations of the same interface <i>A<\/i> in Java source code\n+ * ({@jls 9.7.5}) are represented by the {@linkplain AnnotationValue.OfAnnotation\n+ * annotation-valued} array elements of the {@linkplain AnnotationValue.OfArray\n+ * array-valued} element named {@code value} of a container annotation of the\n+ * containing annotation interface of <i>A<\/i>. ({@jls 9.6.3})\n+ * <p>\n+ * The {@code type_annotation} structure is a superset of the {@code annotation}\n+ * structure ({@jvms 4.7.16}),\n+ * so a {@code TypeAnnotation} exposes more information about its location than\n+ * an {@code Annotation}.\n+ * In particular, the {@code type_annotation} structure indicates:\n+ * <ul>\n+ * <li>which of the <i>n<\/i> types in a declaration or expression is the specific\n+ * type to which the annotation applies. This information is exposed by\n+ * {@link #targetInfo() targetInfo()}.\n+ * <li>whether the annotation applies to a type or to part of a type (such as a\n+ * type argument in a parameterized type). This information is exposed by {@link\n+ * #targetPath() targetPath()}.\n+ * <\/ul>\n+ * <p>\n+ * Two {@code TypeAnnotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -65,0 +90,1 @@\n+ * @see Annotation\n@@ -72,1 +98,0 @@\n-        extends Annotation\n@@ -173,1 +198,1 @@\n-     * is annotated}\n+     * is annotated} This models the {@code target_type} and {@code target_info} items.\n@@ -183,19 +208,4 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation applied to the part indicated by {@link #targetPath()}}\n+     * This models the interface of the annotation and the set of element-value pairs,\n+     * the subset of the {@code type_annotation} structure that is identical to the\n+     * {@code annotation} structure.\n@@ -203,19 +213,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -224,1 +216,1 @@\n-     * {@return a type annotation}\n+     * {@return a {@code type_annotation} structure}\n@@ -227,2 +219,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +222,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":41,"deletions":51,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,1 +284,0 @@\n-        \/\/ handles annotations and type annotations\n@@ -291,2 +288,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +296,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":63,"deletions":7,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -404,3 +404,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -761,52 +759,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n-\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -814,16 +761,2 @@\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -103,1 +103,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -118,1 +118,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}