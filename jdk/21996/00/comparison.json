{"files":[{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import static java.util.stream.Collectors.toMap;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import static jdk.internal.util.OperatingSystem.LINUX;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import static jdk.jpackage.test.Functional.ThrowingSupplier.toSupplier;\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage test library's annotation processor\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.AnnotationsTest\n+ *\/\n+public class AnnotationsTest {\n+\n+    public static void main(String... args) {\n+        runTests(BasicTest.class, ParameterizedInstanceTest.class);\n+        for (var os : OperatingSystem.values()) {\n+            try {\n+                TestBuilderConfig.setOperatingSystem(os);\n+                TKit.log(\"Current operating system: \" + os);\n+                runTests(IfOSTest.class);\n+            } finally {\n+                TestBuilderConfig.setDefaults();\n+            }\n+        }\n+    }\n+\n+    public static class BasicTest extends TestExecutionRecorder {\n+        @Test\n+        public void testNoArg() {\n+            recordTestCase();\n+        }\n+\n+        @Test\n+        @Parameter(\"TRUE\")\n+        public int testNoArg(boolean v) {\n+            recordTestCase(v);\n+            return 0;\n+        }\n+\n+        @Test\n+        @Parameter({})\n+        @Parameter(\"a\")\n+        @Parameter({\"b\", \"c\"})\n+        public void testVarArg(Path ... paths) {\n+            recordTestCase((Object[]) paths);\n+        }\n+\n+        @Test\n+        @Parameter({\"12\", \"foo\"})\n+        @Parameter({\"-89\", \"bar\", \"more\"})\n+        @Parameter({\"-89\", \"bar\", \"more\", \"moore\"})\n+        public void testVarArg2(int a, String b, String ... other) {\n+            recordTestCase(a, b, other);\n+        }\n+\n+        @Test\n+        @ParameterSupplier(\"dateSupplier\")\n+        @ParameterSupplier(\"jdk.jpackage.test.AnnotationsTest.dateSupplier\")\n+        public void testDates(LocalDate v) {\n+            recordTestCase(v);\n+        }\n+\n+        public static Set<String> getExpectedTestDescs() {\n+            return Set.of(\n+                    \"().testNoArg()\",\n+                    \"().testNoArg(true)\",\n+                    \"().testVarArg()\",\n+                    \"().testVarArg(a)\",\n+                    \"().testVarArg(b, c)\",\n+                    \"().testVarArg2(-89, bar, [more, moore](length=2))\",\n+                    \"().testVarArg2(-89, bar, [more](length=1))\",\n+                    \"().testVarArg2(12, foo, [](length=0))\",\n+                    \"().testDates(2018-05-05)\",\n+                    \"().testDates(2018-07-11)\",\n+                    \"().testDates(2034-05-05)\",\n+                    \"().testDates(2056-07-11)\"\n+            );\n+        }\n+\n+        public static Collection<Object[]> dateSupplier() {\n+            return List.of(new Object[][] {\n+                { LocalDate.parse(\"2018-05-05\") },\n+                { LocalDate.parse(\"2018-07-11\") },\n+            });\n+        }\n+    }\n+\n+    public static class ParameterizedInstanceTest extends TestExecutionRecorder {\n+        public ParameterizedInstanceTest(String... args) {\n+            super((Object[]) args);\n+        }\n+\n+        public ParameterizedInstanceTest(int o) {\n+            super(o);\n+        }\n+\n+        public ParameterizedInstanceTest(int a, Boolean[] b, String c, String ... other) {\n+            super(a, b, c, other);\n+        }\n+\n+        @Test\n+        public void testNoArgs() {\n+            recordTestCase();\n+        }\n+\n+        @Test\n+        @ParameterSupplier(\"jdk.jpackage.test.AnnotationsTest.dateSupplier\")\n+        public void testDates(LocalDate v) {\n+            recordTestCase(v);\n+        }\n+\n+        @Test\n+        @Parameter(\"a\")\n+        public static void staticTest(String arg) {\n+            staticRecorder.recordTestCase(arg);\n+        }\n+\n+        @Parameters\n+        public static Collection<Object[]> input() {\n+            return List.of(new Object[][] {\n+                {},\n+                {55, new Boolean[]{false, true, false}, \"foo\", \"bar\"},\n+                {78},\n+            });\n+        }\n+\n+        @Parameters\n+        public static Collection<Object[]> input2() {\n+            return List.of(new Object[][] {\n+                {51, new boolean[]{true, true, true}, \"foo\"},\n+                {33},\n+                {55, null, null },\n+                {55, null, null, \"1\" },\n+            });\n+        }\n+\n+        public static Set<String> getExpectedTestDescs() {\n+            return Set.of(\n+                    \"().testNoArgs()\",\n+                    \"(33).testNoArgs()\",\n+                    \"(78).testNoArgs()\",\n+                    \"(55, [false, true, false](length=3), foo, [bar](length=1)).testNoArgs()\",\n+                    \"(51, [true, true, true](length=3), foo, [](length=0)).testNoArgs()\",\n+                    \"().testDates(2034-05-05)\",\n+                    \"().testDates(2056-07-11)\",\n+                    \"(33).testDates(2034-05-05)\",\n+                    \"(33).testDates(2056-07-11)\",\n+                    \"(51, [true, true, true](length=3), foo, [](length=0)).testDates(2034-05-05)\",\n+                    \"(51, [true, true, true](length=3), foo, [](length=0)).testDates(2056-07-11)\",\n+                    \"(55, [false, true, false](length=3), foo, [bar](length=1)).testDates(2034-05-05)\",\n+                    \"(55, [false, true, false](length=3), foo, [bar](length=1)).testDates(2056-07-11)\",\n+                    \"(78).testDates(2034-05-05)\",\n+                    \"(78).testDates(2056-07-11)\",\n+                    \"(55, null, null, [1](length=1)).testDates(2034-05-05)\",\n+                    \"(55, null, null, [1](length=1)).testDates(2056-07-11)\",\n+                    \"(55, null, null, [1](length=1)).testNoArgs()\",\n+                    \"(55, null, null, [](length=0)).testDates(2034-05-05)\",\n+                    \"(55, null, null, [](length=0)).testDates(2056-07-11)\",\n+                    \"(55, null, null, [](length=0)).testNoArgs()\",\n+                    \"().staticTest(a)\"\n+            );\n+        }\n+\n+        private final static TestExecutionRecorder staticRecorder = new TestExecutionRecorder(ParameterizedInstanceTest.class);\n+    }\n+\n+    public static class IfOSTest extends TestExecutionRecorder {\n+        public IfOSTest(int a, String b) {\n+            super(a, b);\n+        }\n+\n+        @Test(ifOS = OperatingSystem.LINUX)\n+        public void testNoArgs() {\n+            recordTestCase();\n+        }\n+\n+        @Test(ifNotOS = OperatingSystem.LINUX)\n+        public void testNoArgs2() {\n+            recordTestCase();\n+        }\n+\n+        @Test\n+        @Parameter(value = \"foo\", ifOS = OperatingSystem.LINUX)\n+        @Parameter(value = {\"foo\", \"bar\"}, ifOS = { OperatingSystem.LINUX, OperatingSystem.MACOS })\n+        @Parameter(value = {}, ifNotOS = { OperatingSystem.WINDOWS })\n+        public void testVarArgs(String ... args) {\n+            recordTestCase((Object[]) args);\n+        }\n+\n+        @Test\n+        @ParameterSupplier(value = \"jdk.jpackage.test.AnnotationsTest.dateSupplier\", ifOS = OperatingSystem.WINDOWS)\n+        public void testDates(LocalDate v) {\n+            recordTestCase(v);\n+        }\n+\n+        @Parameters(ifOS = OperatingSystem.LINUX)\n+        public static Collection<Object[]> input() {\n+            return Set.of(new Object[][] {\n+                {7, null},\n+            });\n+        }\n+\n+        @Parameters(ifNotOS = {OperatingSystem.LINUX, OperatingSystem.MACOS})\n+        public static Collection<Object[]> input2() {\n+            return Set.of(new Object[][] {\n+                {10, \"hello\"},\n+            });\n+        }\n+\n+        @Parameters(ifNotOS = OperatingSystem.LINUX)\n+        public static Collection<Object[]> input3() {\n+            return Set.of(new Object[][] {\n+                {15, \"bye\"},\n+            });\n+        }\n+\n+        public static Set<String> getExpectedTestDescs() {\n+            switch (TestBuilderConfig.getDefault().getOperatingSystem()) {\n+                case LINUX -> {\n+                    return Set.of(\n+                            \"(7, null).testNoArgs()\",\n+                            \"(7, null).testVarArgs()\",\n+                            \"(7, null).testVarArgs(foo)\",\n+                            \"(7, null).testVarArgs(foo, bar)\"\n+                    );\n+                }\n+\n+                case MACOS -> {\n+                    return Set.of(\n+                            \"(15, bye).testNoArgs2()\",\n+                            \"(15, bye).testVarArgs()\",\n+                            \"(15, bye).testVarArgs(foo, bar)\"\n+                    );\n+                }\n+\n+                case WINDOWS -> {\n+                    return Set.of(\n+                            \"(15, bye).testDates(2034-05-05)\",\n+                            \"(15, bye).testDates(2056-07-11)\",\n+                            \"(15, bye).testNoArgs2()\",\n+                            \"(10, hello).testDates(2034-05-05)\",\n+                            \"(10, hello).testDates(2056-07-11)\",\n+                            \"(10, hello).testNoArgs2()\"\n+                    );\n+                }\n+\n+                case AIX -> {\n+                    return Set.of(\n+                    );\n+                }\n+            }\n+\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static Collection<Object[]> dateSupplier() {\n+        return List.of(new Object[][] {\n+            { LocalDate.parse(\"2034-05-05\") },\n+            { LocalDate.parse(\"2056-07-11\") },\n+        });\n+    }\n+\n+    private static void runTests(Class<? extends TestExecutionRecorder>... tests) {\n+        ACTUAL_TEST_DESCS.get().clear();\n+\n+        var expectedTestDescs = Stream.of(tests)\n+                .map(AnnotationsTest::getExpectedTestDescs)\n+                .flatMap(x -> x)\n+                \/\/ Collect in the map to check for collisions for free\n+                .collect(toMap(x -> x, x -> \"\"))\n+                .keySet();\n+\n+        var args = Stream.of(tests).map(test -> {\n+            return String.format(\"--jpt-run=%s\", test.getName());\n+        }).toArray(String[]::new);\n+\n+        try {\n+            Main.main(args);\n+            assertRecordedTestDescs(expectedTestDescs);\n+        } catch (Throwable t) {\n+            t.printStackTrace(System.err);\n+            System.exit(1);\n+        }\n+    }\n+\n+    private static Stream<String> getExpectedTestDescs(Class<?> type) {\n+        return toSupplier(() -> {\n+            var method = type.getMethod(\"getExpectedTestDescs\");\n+            var testDescPefix = type.getName();\n+            return ((Set<String>)method.invoke(null)).stream().map(desc -> {\n+                return testDescPefix + desc;\n+            });\n+        }).get();\n+    }\n+\n+    private static void assertRecordedTestDescs(Set<String> expectedTestDescs) {\n+        var comm = Comm.compare(expectedTestDescs, ACTUAL_TEST_DESCS.get());\n+        if (!comm.unique1().isEmpty()) {\n+            System.err.println(\"Missing test case signatures:\");\n+            comm.unique1().stream().sorted().sequential().forEachOrdered(System.err::println);\n+            System.err.println(\"<>\");\n+        }\n+\n+        if (!comm.unique2().isEmpty()) {\n+            System.err.println(\"Unexpected test case signatures:\");\n+            comm.unique2().stream().sorted().sequential().forEachOrdered(System.err::println);\n+            System.err.println(\"<>\");\n+        }\n+\n+        if (!comm.unique2().isEmpty() || !comm.unique1().isEmpty()) {\n+            \/\/ Don't use TKit asserts as this call is outside the test execution\n+            throw new AssertionError(\"Test case signatures mismatched\");\n+        }\n+    }\n+\n+    private static class TestExecutionRecorder {\n+        protected TestExecutionRecorder(Object ... args) {\n+            this.testClass = getClass();\n+            this.testDescBuilder = TestInstance.TestDesc.createBuilder().ctorArgs(args);\n+        }\n+\n+        TestExecutionRecorder(Class<?> testClass) {\n+            this.testClass = testClass;\n+            this.testDescBuilder = TestInstance.TestDesc.createBuilder().ctorArgs();\n+        }\n+\n+        protected void recordTestCase(Object ... args) {\n+            testDescBuilder.methodArgs(args).method(getCurrentTestCase());\n+            var testCaseDescs = ACTUAL_TEST_DESCS.get();\n+            var testCaseDesc = testDescBuilder.get().testFullName();\n+            TKit.assertTrue(!testCaseDescs.contains(testCaseDesc), String.format(\n+                    \"Check this test case is executed for the first time\",\n+                    testCaseDesc));\n+            TKit.assertTrue(!executed, \"Check this test case instance is not reused\");\n+            executed = true;\n+            testCaseDescs.add(testCaseDesc);\n+        }\n+\n+        private Method getCurrentTestCase() {\n+            return StackWalker.getInstance(RETAIN_CLASS_REFERENCE).walk(frames -> {\n+                 return frames.map(frame -> {\n+                    var methodType = frame.getMethodType();\n+                    var methodName = frame.getMethodName();\n+                    var methodReturn = methodType.returnType();\n+                    var methodParameters = methodType.parameterArray();\n+                    return Stream.of(testClass.getDeclaredMethods()).filter(method -> {\n+                        return method.getName().equals(methodName)\n+                                && method.getReturnType().equals(methodReturn)\n+                                && Arrays.equals(method.getParameterTypes(), methodParameters)\n+                                && method.isAnnotationPresent(Test.class);\n+                    }).findFirst();\n+                }).dropWhile(Optional::isEmpty).map(Optional::get).findFirst();\n+            }).get();\n+        }\n+\n+        private boolean executed;\n+        private final TestInstance.TestDesc.Builder testDescBuilder;\n+        private final Class<?> testClass;\n+    }\n+\n+    private static final ThreadLocal<Set<String>> ACTUAL_TEST_DESCS = new ThreadLocal<>() {\n+        @Override\n+        protected Set<String> initialValue() {\n+            return new HashSet<>();\n+        }\n+    };\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/AnnotationsTest.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -46,0 +47,8 @@\n+\n+        OperatingSystem[] ifOS() default {\n+            OperatingSystem.LINUX,\n+            OperatingSystem.WINDOWS,\n+            OperatingSystem.MACOS\n+        };\n+\n+        OperatingSystem[] ifNotOS() default {};\n@@ -54,0 +63,8 @@\n+\n+        OperatingSystem[] ifOS() default {\n+            OperatingSystem.LINUX,\n+            OperatingSystem.WINDOWS,\n+            OperatingSystem.MACOS\n+        };\n+\n+        OperatingSystem[] ifNotOS() default {};\n@@ -63,0 +80,23 @@\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @Repeatable(ParameterSupplierGroup.class)\n+    public @interface ParameterSupplier {\n+\n+        String value();\n+\n+        OperatingSystem[] ifOS() default {\n+            OperatingSystem.LINUX,\n+            OperatingSystem.WINDOWS,\n+            OperatingSystem.MACOS\n+        };\n+\n+        OperatingSystem[] ifNotOS() default {};\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    public @interface ParameterSupplierGroup {\n+\n+        ParameterSupplier[] value();\n+    }\n+\n@@ -66,0 +106,8 @@\n+\n+        OperatingSystem[] ifOS() default {\n+            OperatingSystem.LINUX,\n+            OperatingSystem.WINDOWS,\n+            OperatingSystem.MACOS\n+        };\n+\n+        OperatingSystem[] ifNotOS() default {};\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Annotations.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+public final class CannedFormattedString {\n+\n+    CannedFormattedString(BiFunction<String, Object[], String> formatter,\n+            String key, Object[] args) {\n+        this.formatter = formatter;\n+        this.key = key;\n+        this.args = args;\n+    }\n+\n+    public String getValue() {\n+        return formatter.apply(key, args);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (args.length == 0) {\n+            return String.format(\"%s\", key);\n+        } else {\n+            return String.format(\"%s+%s\", key, List.of(args));\n+        }\n+    }\n+\n+    private final BiFunction<String, Object[], String> formatter;\n+    private final String key;\n+    private final Object[] args;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CannedFormattedString.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+record Comm<T>(Set<T> common, Set<T> unique1, Set<T> unique2) {\n+\n+    static <T> Comm<T> compare(Set<T> a, Set<T> b) {\n+        Set<T> common = new HashSet<>(a);\n+        common.retainAll(b);\n+        Set<T> unique1 = new HashSet<>(a);\n+        unique1.removeAll(common);\n+        Set<T> unique2 = new HashSet<>(b);\n+        unique2.removeAll(common);\n+        return new Comm(common, unique1, unique2);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Comm.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -81,0 +81,1 @@\n+        outputValidator = cmd.outputValidator;\n@@ -742,0 +743,18 @@\n+    public JPackageCommand validateOutput(TKit.TextStreamVerifier validator) {\n+        return JPackageCommand.this.validateOutput(validator::apply);\n+    }\n+\n+    public JPackageCommand validateOutput(Consumer<Stream<String>> validator) {\n+        if (validator != null) {\n+            saveConsoleOutput(true);\n+            outputValidator = validator;\n+        } else {\n+            outputValidator = null;\n+        }\n+        return this;\n+    }\n+\n+    public JPackageCommand validateOutput(CannedFormattedString str) {\n+        return JPackageCommand.this.validateOutput(TKit.assertTextStream(str.getValue()));\n+    }\n+\n@@ -820,0 +839,4 @@\n+        if (outputValidator != null) {\n+            outputValidator.accept(result.getOutput().stream());\n+        }\n+\n@@ -1190,0 +1213,1 @@\n+    private Consumer<Stream<String>> outputValidator;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.text.MessageFormat;\n+\n+public enum JPackageStringBundle {\n+\n+    MAIN(\"jdk.jpackage.internal.I18N\"),\n+    ;\n+\n+    JPackageStringBundle(String i18nClassName) {\n+        try {\n+            i18nClass = Class.forName(i18nClassName);\n+\n+            i18nClass_getString = i18nClass.getDeclaredMethod(\"getString\", String.class);\n+            i18nClass_getString.setAccessible(true);\n+        } catch (ClassNotFoundException|NoSuchMethodException ex) {\n+            throw Functional.rethrowUnchecked(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Gets a string for the given key from jpackage resources.\n+     *\/\n+    private String getString(String key) {\n+        try {\n+            return (String)i18nClass_getString.invoke(i18nClass, key);\n+        } catch (IllegalAccessException|InvocationTargetException ex) {\n+            throw Functional.rethrowUnchecked(ex);\n+        }\n+    }\n+\n+    private String getFormattedString(String key, Object[] args) {\n+        return MessageFormat.format(getString(key), args);\n+    }\n+\n+    public CannedFormattedString cannedFormattedString(String key, String ... args) {\n+        return new CannedFormattedString(this::getFormattedString, key, args);\n+    }\n+\n+    private final Class<?> i18nClass;\n+    private final Method i18nClass_getString;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageStringBundle.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.jpackage.internal.ApplicationLayout;\n@@ -402,0 +403,9 @@\n+\n+        var launcherName = Stream.of(List.of(cmd.name()), cmd.addLauncherNames()).flatMap(List::stream).filter(name -> {\n+            return getDesktopFile(cmd, name).equals(desktopFile);\n+        }).findAny();\n+        if (!cmd.hasArgument(\"--app-image\")) {\n+            TKit.assertTrue(launcherName.isPresent(),\n+                    \"Check the desktop file corresponds to one of app launchers\");\n+        }\n+\n@@ -431,1 +441,1 @@\n-        \/\/ Verify value of `Exec` property in .desktop files are escaped if required\n+        \/\/ Verify the value of `Exec` key in is escaped if required\n@@ -440,4 +450,19 @@\n-        Stream.of(launcherPath, data.get(\"Icon\"))\n-                .map(Path::of)\n-                .map(cmd::pathToUnpackedPackageFile)\n-                .forEach(TKit::assertFileExists);\n+        if (launcherName.isPresent()) {\n+            TKit.assertEquals(launcherPath, cmd.pathToPackageFile(\n+                    cmd.appLauncherPath(launcherName.get())).toString(),\n+                    String.format(\n+                            \"Check the value of [Exec] key references [%s] app launcher\",\n+                            launcherName.get()));\n+        }\n+\n+        for (var e : List.<Map.Entry<Map.Entry<String, Optional<String>>, Function<ApplicationLayout, Path>>>of(\n+                Map.entry(Map.entry(\"Exec\", Optional.of(launcherPath)), ApplicationLayout::launchersDirectory),\n+                Map.entry(Map.entry(\"Icon\", Optional.empty()), ApplicationLayout::destktopIntegrationDirectory))) {\n+            var path = e.getKey().getValue().or(() -> Optional.of(data.get(\n+                    e.getKey().getKey()))).map(Path::of).get();\n+            TKit.assertFileExists(cmd.pathToUnpackedPackageFile(path));\n+            Path expectedDir = cmd.pathToPackageFile(e.getValue().apply(cmd.appLayout()));\n+            TKit.assertTrue(path.getParent().equals(expectedDir), String.format(\n+                    \"Check the value of [%s] key references a file in [%s] folder\",\n+                    e.getKey().getKey(), expectedDir));\n+        }\n@@ -728,1 +753,1 @@\n-    private final static Pattern XDG_CMD_ICON_SIZE_PATTERN = Pattern.compile(\"\\\\s--size\\\\s+(\\\\d+)\\\\b\");\n+    private static final Pattern XDG_CMD_ICON_SIZE_PATTERN = Pattern.compile(\"\\\\s--size\\\\s+(\\\\d+)\\\\b\");\n@@ -731,1 +756,1 @@\n-    private final static Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);\n+    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);\n@@ -733,1 +758,1 @@\n-    private final static Method getServiceUnitFileName = initGetServiceUnitFileName();\n+    private static final Method getServiceUnitFileName = initGetServiceUnitFileName();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n@@ -27,0 +30,2 @@\n+import java.util.Comparator;\n+import java.util.Deque;\n@@ -30,1 +35,2 @@\n-import java.util.stream.Collectors;\n+import static java.util.stream.Collectors.toCollection;\n+import java.util.stream.Stream;\n@@ -39,1 +45,3 @@\n-            for (var arg : args) {\n+            Deque<String> argsAsList = new ArrayDeque<>(List.of(args));\n+            while (!argsAsList.isEmpty()) {\n+                var arg = argsAsList.pop();\n@@ -47,0 +55,23 @@\n+                if (arg.startsWith(\"@\")) {\n+                    \/\/ Command file\n+                    \/\/ @=args will read arguments from the \"args\" file, one argument per line\n+                    \/\/ @args will read arguments from the \"args\" file, splitting lines into arguments at whitespaces\n+                    arg = arg.substring(1);\n+                    var oneArgPerLine = arg.startsWith(\"=\");\n+                    if (oneArgPerLine) {\n+                        arg = arg.substring(1);\n+                    }\n+\n+                    var newArgsStream = Files.readAllLines(Path.of(arg)).stream();\n+                    if (!oneArgPerLine) {\n+                        newArgsStream.map(line -> {\n+                            return Stream.of(line.split(\"\\\\s+\"));\n+                        }).flatMap(x -> x);\n+                    }\n+\n+                    var newArgs = newArgsStream.collect(toCollection(ArrayDeque::new));\n+                    newArgs.addAll(argsAsList);\n+                    argsAsList = newArgs;\n+                    continue;\n+                }\n+\n@@ -65,2 +96,1 @@\n-                .sorted((a, b) -> a.fullName().compareTo(b.fullName()))\n-                .collect(Collectors.toList());\n+                .sorted(Comparator.comparing(TestInstance::fullName)).toList();\n@@ -70,1 +100,1 @@\n-            orderedTests.stream().forEach(test -> System.out.println(String.format(\n+            orderedTests.forEach(test -> System.out.println(String.format(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.lang.reflect.Array;\n@@ -26,0 +27,1 @@\n+import java.lang.reflect.Executable;\n@@ -30,1 +32,3 @@\n-import java.util.List;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -33,2 +37,2 @@\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n+import java.util.function.Predicate;\n+import java.util.stream.IntStream;\n@@ -41,6 +45,3 @@\n-    MethodCall(Object[] instanceCtorArgs, Method method) {\n-        this.ctorArgs = Optional.ofNullable(instanceCtorArgs).orElse(\n-                DEFAULT_CTOR_ARGS);\n-        this.method = method;\n-        this.methodArgs = new Object[0];\n-    }\n+    MethodCall(Object[] instanceCtorArgs, Method method, Object ... args) {\n+        Objects.requireNonNull(instanceCtorArgs);\n+        Objects.requireNonNull(method);\n@@ -48,3 +49,1 @@\n-    MethodCall(Object[] instanceCtorArgs, Method method, Object arg) {\n-        this.ctorArgs = Optional.ofNullable(instanceCtorArgs).orElse(\n-                DEFAULT_CTOR_ARGS);\n+        this.ctorArgs = instanceCtorArgs;\n@@ -52,1 +51,1 @@\n-        this.methodArgs = new Object[]{arg};\n+        this.methodArgs = args;\n@@ -79,6 +78,1 @@\n-        Constructor ctor = findRequiredConstructor(method.getDeclaringClass(),\n-                ctorArgs);\n-        if (ctor.isVarArgs()) {\n-            \/\/ Assume constructor doesn't have fixed, only variable parameters.\n-            return ctor.newInstance(new Object[]{ctorArgs});\n-        }\n+        var ctor = findMatchingConstructor(method.getDeclaringClass(), ctorArgs);\n@@ -86,1 +80,5 @@\n-        return ctor.newInstance(ctorArgs);\n+        return ctor.newInstance(mapArgs(ctor, ctorArgs));\n+    }\n+\n+    static Object[] mapArgs(Executable executable, final Object ... args) {\n+        return mapPrimitiveTypeArgs(executable, mapVarArgs(executable, args));\n@@ -91,1 +89,1 @@\n-            findRequiredConstructor(method.getDeclaringClass(), ctorArgs);\n+            findMatchingConstructor(method.getDeclaringClass(), ctorArgs);\n@@ -95,6 +93,1 @@\n-    private static Constructor findVarArgConstructor(Class type) {\n-        return Stream.of(type.getConstructors()).filter(\n-                Constructor::isVarArgs).findFirst().orElse(null);\n-    }\n-\n-    private Constructor findRequiredConstructor(Class type, Object... ctorArgs)\n+    private static Constructor findMatchingConstructor(Class type, Object... ctorArgs)\n@@ -103,2 +96,6 @@\n-        Supplier<NoSuchMethodException> notFoundException = () -> {\n-            return new NoSuchMethodException(String.format(\n+        var ctors = filterMatchingExecutablesForParameterValues(Stream.of(\n+                type.getConstructors()), ctorArgs).toList();\n+\n+        if (ctors.size() != 1) {\n+            \/\/ No public constructors that can handle the given arguments.\n+            throw new NoSuchMethodException(String.format(\n@@ -107,16 +104,29 @@\n-        };\n-\n-        if (Stream.of(ctorArgs).allMatch(Objects::nonNull)) {\n-            \/\/ No `null` in constructor args, take easy path\n-            try {\n-                return type.getConstructor(Stream.of(ctorArgs).map(\n-                        Object::getClass).collect(Collectors.toList()).toArray(\n-                        Class[]::new));\n-            } catch (NoSuchMethodException ex) {\n-                \/\/ Failed to find ctor that can take the given arguments.\n-                Constructor varArgCtor = findVarArgConstructor(type);\n-                if (varArgCtor != null) {\n-                    \/\/ There is one with variable number of arguments. Use it.\n-                    return varArgCtor;\n-                }\n-                throw notFoundException.get();\n+        }\n+\n+        return ctors.get(0);\n+    }\n+\n+    @Override\n+    public void accept(Object thiz) throws Throwable {\n+        method.invoke(thiz, methodArgs);\n+    }\n+\n+    private static Object[] mapVarArgs(Executable executable, final Object ... args) {\n+        if (executable.isVarArgs()) {\n+            var paramTypes = executable.getParameterTypes();\n+            Class varArgParamType = paramTypes[paramTypes.length - 1];\n+\n+            Object[] newArgs;\n+            if (paramTypes.length - args.length == 1) {\n+                \/\/ Empty var args\n+\n+                \/\/ \"args\" can be of type String[] if the \"executable\" is \"foo(String ... str)\"\n+                newArgs = Arrays.copyOf(args, args.length + 1, Object[].class);\n+                newArgs[newArgs.length - 1] = Array.newInstance(varArgParamType.componentType(), 0);\n+            } else {\n+                var varArgs = Arrays.copyOfRange(args, paramTypes.length - 1,\n+                        args.length, varArgParamType);\n+\n+                \/\/ \"args\" can be of type String[] if the \"executable\" is \"foo(String ... str)\"\n+                newArgs = Arrays.copyOfRange(args, 0, paramTypes.length, Object[].class);\n+                newArgs[newArgs.length - 1] = varArgs;\n@@ -124,0 +134,1 @@\n+            return newArgs;\n@@ -126,3 +137,2 @@\n-        List<Constructor> ctors = Stream.of(type.getConstructors())\n-                .filter(ctor -> ctor.getParameterCount() == ctorArgs.length)\n-                .collect(Collectors.toList());\n+        return args;\n+    }\n@@ -130,3 +140,5 @@\n-        if (ctors.isEmpty()) {\n-            \/\/ No public constructors that can handle the given arguments.\n-            throw notFoundException.get();\n+    private static Object[] mapPrimitiveTypeArgs(Executable executable, final Object ... args) {\n+        var paramTypes = executable.getParameterTypes();\n+        if (paramTypes.length != args.length) {\n+            throw new IllegalArgumentException(\n+                    \"The number of arguments must be equal to the number of parameters of the executable\");\n@@ -135,2 +147,24 @@\n-        if (ctors.size() == 1) {\n-            return ctors.iterator().next();\n+        if (IntStream.range(0, args.length).allMatch(idx -> {\n+            return Optional.ofNullable(args[idx]).map(Object::getClass).map(paramTypes[idx]::isAssignableFrom).orElse(true);\n+        })) {\n+            return args;\n+        } else {\n+            final var newArgs = Arrays.copyOf(args, args.length, Object[].class);\n+            for (var idx = 0; idx != args.length; ++idx) {\n+                final var paramType = paramTypes[idx];\n+                final var argValue = args[idx];\n+                newArgs[idx] = Optional.ofNullable(argValue).map(Object::getClass).map(argType -> {\n+                    if(argType.isArray() && !paramType.isAssignableFrom(argType) ) {\n+                        var length = Array.getLength(argValue);\n+                        var newArray = Array.newInstance(paramType.getComponentType(), length);\n+                        for (var arrayIdx = 0; arrayIdx != length; ++arrayIdx) {\n+                            Array.set(newArray, arrayIdx, Array.get(argValue, arrayIdx));\n+                        }\n+                        return newArray;\n+                    } else {\n+                        return argValue;\n+                    }\n+                }).orElse(argValue);\n+            }\n+\n+            return newArgs;\n@@ -138,0 +172,1 @@\n+    }\n@@ -139,2 +174,7 @@\n-        \/\/ Revisit this tricky case when it will start bothering.\n-        throw notFoundException.get();\n+    private static <T extends Executable> Stream<T> filterMatchingExecutablesForParameterValues(\n+            Stream<T> executables, Object... args) {\n+        return filterMatchingExecutablesForParameterTypes(\n+                executables,\n+                Stream.of(args)\n+                        .map(arg -> arg != null ? arg.getClass() : null)\n+                        .toArray(Class[]::new));\n@@ -143,3 +183,54 @@\n-    @Override\n-    public void accept(Object thiz) throws Throwable {\n-        method.invoke(thiz, methodArgs);\n+    private static <T extends Executable> Stream<T> filterMatchingExecutablesForParameterTypes(\n+            Stream<T> executables, Class<?>... argTypes) {\n+        return executables.filter(executable -> {\n+            var parameterTypes = executable.getParameterTypes();\n+\n+            final int checkArgTypeCount;\n+            if (parameterTypes.length <= argTypes.length) {\n+                checkArgTypeCount = parameterTypes.length;\n+            } else if (parameterTypes.length - argTypes.length == 1 && executable.isVarArgs()) {\n+                \/\/ Empty optional arguments.\n+                checkArgTypeCount = argTypes.length;\n+            } else {\n+                \/\/ Not enough mandatory arguments.\n+                return false;\n+            }\n+\n+            var unmatched = IntStream.range(0, checkArgTypeCount).dropWhile(idx -> {\n+                return new ParameterTypeMatcher(parameterTypes[idx]).test(argTypes[idx]);\n+            }).toArray();\n+\n+            if (argTypes.length == parameterTypes.length && unmatched.length == 0) {\n+                \/\/ Number of argument types equals to the number of parameters\n+                \/\/ of the executable and all types match.\n+                return true;\n+            }\n+\n+            if (executable.isVarArgs()) {\n+                var varArgType = parameterTypes[parameterTypes.length - 1].componentType();\n+                return IntStream.of(unmatched).allMatch(idx -> {\n+                    return new ParameterTypeMatcher(varArgType).test(argTypes[idx]);\n+                });\n+            }\n+\n+            return false;\n+        });\n+    }\n+\n+    private static final class ParameterTypeMatcher implements Predicate<Class<?>> {\n+        ParameterTypeMatcher(Class<?> parameterType) {\n+            Objects.requireNonNull(parameterType);\n+            this.parameterType = NORM_TYPES.getOrDefault(parameterType, parameterType);\n+        }\n+\n+        @Override\n+        public boolean test(Class<?> paramaterValueType) {\n+            if (paramaterValueType == null) {\n+                return true;\n+            }\n+\n+            paramaterValueType = NORM_TYPES.getOrDefault(paramaterValueType, paramaterValueType);\n+            return parameterType.isAssignableFrom(paramaterValueType);\n+        }\n+\n+        private final Class<?> parameterType;\n@@ -152,1 +243,26 @@\n-    final static Object[] DEFAULT_CTOR_ARGS = new Object[0];\n+    private static final Map<Class<?>, Class<?>> NORM_TYPES;\n+\n+    static {\n+        Map<Class<?>, Class<?>> primitives = Map.of(\n+            boolean.class, Boolean.class,\n+            byte.class, Byte.class,\n+            short.class, Short.class,\n+            int.class, Integer.class,\n+            long.class, Long.class,\n+            float.class, Float.class,\n+            double.class, Double.class);\n+\n+        Map<Class<?>, Class<?>> primitiveArrays = Map.of(\n+            boolean[].class, Boolean[].class,\n+            byte[].class, Byte[].class,\n+            short[].class, Short[].class,\n+            int[].class, Integer[].class,\n+            long[].class, Long[].class,\n+            float[].class, Float[].class,\n+            double[].class, Double[].class);\n+\n+        Map<Class<?>, Class<?>> combined = new HashMap<>(primitives);\n+        combined.putAll(primitiveArrays);\n+\n+        NORM_TYPES = Collections.unmodifiableMap(combined);\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MethodCall.java","additions":176,"deletions":60,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -784,1 +784,1 @@\n-            if (!comm.unique1.isEmpty() && !comm.unique2.isEmpty()) {\n+            if (!comm.unique1().isEmpty() && !comm.unique2().isEmpty()) {\n@@ -787,2 +787,2 @@\n-                        baseDir, format(comm.common), format(comm.unique1), format(comm.unique2)));\n-            } else if (!comm.unique1.isEmpty()) {\n+                        baseDir, format(comm.common()), format(comm.unique1()), format(comm.unique2())));\n+            } else if (!comm.unique1().isEmpty()) {\n@@ -791,2 +791,2 @@\n-                        baseDir, format(comm.common), format(comm.unique1)));\n-            } else if (!comm.unique2.isEmpty()) {\n+                        baseDir, format(comm.common()), format(comm.unique1())));\n+            } else if (!comm.unique2().isEmpty()) {\n@@ -795,1 +795,1 @@\n-                        baseDir, format(comm.common), format(comm.unique2)));\n+                        baseDir, format(comm.common()), format(comm.unique2())));\n@@ -811,1 +811,1 @@\n-            if (!comm.unique2.isEmpty()) {\n+            if (!comm.unique2().isEmpty()) {\n@@ -814,1 +814,1 @@\n-                        baseDir, format(comm.common), format(comm.unique2)));\n+                        baseDir, format(comm.common()), format(comm.unique2())));\n@@ -841,15 +841,0 @@\n-        private static record Comm(Set<Path> common, Set<Path> unique1, Set<Path> unique2) {\n-            static Comm compare(Set<Path> a, Set<Path> b) {\n-                Set<Path> common = new HashSet<>(a);\n-                common.retainAll(b);\n-\n-                Set<Path> unique1 = new HashSet<>(a);\n-                unique1.removeAll(common);\n-\n-                Set<Path> unique2 = new HashSet<>(b);\n-                unique2.removeAll(common);\n-\n-                return new Comm(common, unique1, unique2);\n-            }\n-        }\n-\n@@ -964,0 +949,10 @@\n+        public TextStreamVerifier andThen(Consumer<? super Stream<String>> anotherVerifier) {\n+            this.anotherVerifier = anotherVerifier;\n+            return this;\n+        }\n+\n+        public TextStreamVerifier andThen(TextStreamVerifier anotherVerifier) {\n+            this.anotherVerifier = anotherVerifier::apply;\n+            return this;\n+        }\n+\n@@ -974,3 +969,16 @@\n-            String matchedStr = lines.filter(line -> predicate.test(line, value)).findFirst().orElse(\n-                    null);\n-            String labelStr = Optional.ofNullable(label).orElse(\"output\");\n+            final String matchedStr;\n+\n+            lines = lines.dropWhile(line -> !predicate.test(line, value));\n+            if (anotherVerifier == null) {\n+                matchedStr = lines.findFirst().orElse(null);\n+            } else {\n+                var tail = lines.toList();\n+                if (tail.isEmpty()) {\n+                    matchedStr = null;\n+                } else {\n+                    matchedStr = tail.get(0);\n+                }\n+                lines = tail.stream().skip(1);\n+            }\n+\n+            final String labelStr = Optional.ofNullable(label).orElse(\"output\");\n@@ -1000,0 +1008,4 @@\n+\n+            if (anotherVerifier != null) {\n+                anotherVerifier.accept(lines);\n+            }\n@@ -1006,0 +1018,1 @@\n+        private Consumer<? super Stream<String>> anotherVerifier;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.lang.reflect.Array;\n@@ -29,1 +28,0 @@\n-import java.lang.reflect.Modifier;\n@@ -31,1 +29,1 @@\n-import java.util.Collection;\n+import java.util.Comparator;\n@@ -38,1 +36,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -40,1 +37,0 @@\n-import java.util.function.Function;\n@@ -46,3 +42,0 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.ParameterGroup;\n-import jdk.jpackage.test.Annotations.Parameters;\n@@ -51,0 +44,1 @@\n+import static jdk.jpackage.test.Functional.ThrowingConsumer.toConsumer;\n@@ -52,0 +46,2 @@\n+import jdk.jpackage.test.TestMethodSupplier.InvalidAnnotationException;\n+import static jdk.jpackage.test.TestMethodSupplier.MethodQuery.fromQualifiedMethodName;\n@@ -61,0 +57,1 @@\n+        this.testMethodSupplier = TestBuilderConfig.getDefault().createTestMethodSupplier();\n@@ -73,1 +70,1 @@\n-                                TestBuilder::toMethodCalls)).flatMap(s -> s).collect(\n+                                this::toMethodCalls)).flatMap(s -> s).collect(\n@@ -222,1 +219,1 @@\n-                .sorted((a, b) -> a.getName().compareTo(b.getName()));\n+                .sorted(Comparator.comparing(Method::getName));\n@@ -225,1 +222,1 @@\n-    private static Stream<String> cmdLineArgValueToMethodNames(String v) {\n+    private Stream<String> cmdLineArgValueToMethodNames(String v) {\n@@ -231,0 +228,4 @@\n+                if (testMethodSupplier.isTestClass(testSet)) {\n+                    toConsumer(testMethodSupplier::verifyTestClass).accept(testSet);\n+                }\n+\n@@ -235,4 +236,6 @@\n-                Stream.of(testSet.getMethods()).filter(\n-                        m -> m.isAnnotationPresent(Test.class)).map(\n-                                Method::getName).distinct().forEach(\n-                                name -> result.add(String.join(\".\", token, name)));\n+                result.addAll(Stream.of(testSet.getMethods())\n+                        .filter(m -> m.isAnnotationPresent(Test.class))\n+                        .filter(testMethodSupplier::isEnabled)\n+                        .map(Method::getName).distinct()\n+                        .map(name -> String.join(\".\", token, name))\n+                        .toList());\n@@ -249,1 +252,1 @@\n-                throw new ParseException(\"Default class name not found in\");\n+                throw new ParseException(\"Missing default class name in\");\n@@ -258,20 +261,1 @@\n-    private static boolean filterMethod(String expectedMethodName, Method method) {\n-        if (!method.getName().equals(expectedMethodName)) {\n-            return false;\n-        }\n-        switch (method.getParameterCount()) {\n-            case 0:\n-                return !isParametrized(method);\n-            case 1:\n-                return isParametrized(method);\n-        }\n-        return false;\n-    }\n-\n-    private static boolean isParametrized(Method method) {\n-        return method.isAnnotationPresent(ParameterGroup.class) || method.isAnnotationPresent(\n-                Parameter.class);\n-    }\n-\n-    private static List<Method> getJavaMethodFromString(\n-            String qualifiedMethodName) {\n+    private List<Method> getJavaMethodFromString(String qualifiedMethodName) {\n@@ -280,18 +264,1 @@\n-            throw new ParseException(\"Class name not found in\");\n-        }\n-        String className = qualifiedMethodName.substring(0, lastDotIdx);\n-        String methodName = qualifiedMethodName.substring(lastDotIdx + 1);\n-        Class methodClass;\n-        try {\n-            methodClass = Class.forName(className);\n-        } catch (ClassNotFoundException ex) {\n-            throw new ParseException(String.format(\"Class [%s] not found;\",\n-                    className));\n-        }\n-        \/\/ Get the list of all public methods as need to deal with overloads.\n-        List<Method> methods = Stream.of(methodClass.getMethods()).filter(\n-                (m) -> filterMethod(methodName, m)).collect(Collectors.toList());\n-        if (methods.isEmpty()) {\n-            throw new ParseException(String.format(\n-                    \"Method [%s] not found in [%s] class;\",\n-                    methodName, className));\n+            throw new ParseException(\"Missing class name in\");\n@@ -300,48 +267,5 @@\n-        trace(String.format(\"%s -> %s\", qualifiedMethodName, methods));\n-        return methods;\n-    }\n-\n-    private static Stream<Method> getJavaMethodsFromArg(String argValue) {\n-        return cmdLineArgValueToMethodNames(argValue).map(\n-                ThrowingFunction.toFunction(\n-                        TestBuilder::getJavaMethodFromString)).flatMap(\n-                        List::stream).sequential();\n-    }\n-\n-    private static Parameter[] getMethodParameters(Method method) {\n-        if (method.isAnnotationPresent(ParameterGroup.class)) {\n-            return ((ParameterGroup) method.getAnnotation(ParameterGroup.class)).value();\n-        }\n-\n-        if (method.isAnnotationPresent(Parameter.class)) {\n-            return new Parameter[]{(Parameter) method.getAnnotation(\n-                Parameter.class)};\n-        }\n-\n-        \/\/ Unexpected\n-        return null;\n-    }\n-\n-    private static Stream<Object[]> toCtorArgs(Method method) throws\n-            IllegalAccessException, InvocationTargetException {\n-        Class type = method.getDeclaringClass();\n-        List<Method> paremetersProviders = Stream.of(type.getMethods())\n-                .filter(m -> m.getParameterCount() == 0)\n-                .filter(m -> (m.getModifiers() & Modifier.STATIC) != 0)\n-                .filter(m -> m.isAnnotationPresent(Parameters.class))\n-                .sorted()\n-                .collect(Collectors.toList());\n-        if (paremetersProviders.isEmpty()) {\n-            \/\/ Single instance using the default constructor.\n-            return Stream.ofNullable(MethodCall.DEFAULT_CTOR_ARGS);\n-        }\n-\n-        \/\/ Pick the first method from the list.\n-        Method paremetersProvider = paremetersProviders.iterator().next();\n-        if (paremetersProviders.size() > 1) {\n-            trace(String.format(\n-                    \"Found %d public static methods without arguments with %s annotation. Will use %s\",\n-                    paremetersProviders.size(), Parameters.class,\n-                    paremetersProvider));\n-            paremetersProviders.stream().map(Method::toString).forEach(\n-                    TestBuilder::trace);\n+        try {\n+            return testMethodSupplier.findNullaryLikeMethods(\n+                    fromQualifiedMethodName(qualifiedMethodName));\n+        } catch (NoSuchMethodException ex) {\n+            throw new ParseException(ex.getMessage() + \";\", ex);\n@@ -349,3 +273,0 @@\n-\n-        \/\/ Construct collection of arguments for test class instances.\n-        return ((Collection) paremetersProvider.invoke(null)).stream();\n@@ -354,14 +275,6 @@\n-    private static Stream<MethodCall> toMethodCalls(Method method) throws\n-            IllegalAccessException, InvocationTargetException {\n-        return toCtorArgs(method).map(v -> toMethodCalls(v, method)).flatMap(\n-                s -> s).peek(methodCall -> {\n-                    \/\/ Make sure required constructor is accessible if the one is needed.\n-                    \/\/ Need to probe all methods as some of them might be static\n-                    \/\/ and some class members.\n-                    \/\/ Only class members require ctors.\n-                    try {\n-                        methodCall.checkRequiredConstructor();\n-                    } catch (NoSuchMethodException ex) {\n-                        throw new ParseException(ex.getMessage() + \".\");\n-                    }\n-                });\n+    private Stream<Method> getJavaMethodsFromArg(String argValue) {\n+        var methods = cmdLineArgValueToMethodNames(argValue)\n+                .map(this::getJavaMethodFromString)\n+                .flatMap(List::stream).toList();\n+        trace(String.format(\"%s -> %s\", argValue, methods));\n+        return methods.stream();\n@@ -370,19 +283,11 @@\n-    private static Stream<MethodCall> toMethodCalls(Object[] ctorArgs, Method method) {\n-        if (!isParametrized(method)) {\n-            return Stream.of(new MethodCall(ctorArgs, method));\n-        }\n-        Parameter[] annotations = getMethodParameters(method);\n-        if (annotations.length == 0) {\n-            return Stream.of(new MethodCall(ctorArgs, method));\n-        }\n-        return Stream.of(annotations).map((a) -> {\n-            Class paramType = method.getParameterTypes()[0];\n-            final Object annotationValue;\n-            if (!paramType.isArray()) {\n-                annotationValue = fromString(a.value()[0], paramType);\n-            } else {\n-                Class paramComponentType = paramType.getComponentType();\n-                annotationValue = Array.newInstance(paramComponentType, a.value().length);\n-                var idx = new AtomicInteger(-1);\n-                Stream.of(a.value()).map(v -> fromString(v, paramComponentType)).sequential().forEach(\n-                        v -> Array.set(annotationValue, idx.incrementAndGet(), v));\n+    private Stream<MethodCall> toMethodCalls(Method method) throws\n+            IllegalAccessException, InvocationTargetException, InvalidAnnotationException {\n+        return testMethodSupplier.mapToMethodCalls(method).peek(methodCall -> {\n+            \/\/ Make sure required constructor is accessible if the one is needed.\n+            \/\/ Need to probe all methods as some of them might be static\n+            \/\/ and some class members.\n+            \/\/ Only class members require ctors.\n+            try {\n+                methodCall.checkRequiredConstructor();\n+            } catch (NoSuchMethodException ex) {\n+                throw new ParseException(ex.getMessage() + \".\", ex);\n@@ -390,1 +295,0 @@\n-            return new MethodCall(ctorArgs, method, annotationValue);\n@@ -394,13 +298,0 @@\n-    private static Object fromString(String value, Class toType) {\n-        if (toType.isEnum()) {\n-            return Enum.valueOf(toType, value);\n-        }\n-        Function<String, Object> converter = conv.get(toType);\n-        if (converter == null) {\n-            throw new RuntimeException(String.format(\n-                    \"Failed to find a conversion of [%s] string to %s type\",\n-                    value, toType));\n-        }\n-        return converter.apply(value);\n-    }\n-\n@@ -430,0 +321,4 @@\n+        ParseException(String msg, Exception ex) {\n+            super(msg, ex);\n+        }\n+\n@@ -451,0 +346,1 @@\n+    private final TestMethodSupplier testMethodSupplier;\n@@ -452,1 +348,1 @@\n-    private Consumer<TestInstance> testConsumer;\n+    private final Consumer<TestInstance> testConsumer;\n@@ -461,10 +357,1 @@\n-    private final static Map<Class, Function<String, Object>> conv = Map.of(\n-            boolean.class, Boolean::valueOf,\n-            Boolean.class, Boolean::valueOf,\n-            int.class, Integer::valueOf,\n-            Integer.class, Integer::valueOf,\n-            long.class, Long::valueOf,\n-            Long.class, Long::valueOf,\n-            String.class, String::valueOf);\n-\n-    final static String CMDLINE_ARG_PREFIX = \"--jpt-\";\n+    static final String CMDLINE_ARG_PREFIX = \"--jpt-\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":51,"deletions":164,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.test;\n+\n+import java.util.Objects;\n+import jdk.internal.util.OperatingSystem;\n+\n+final class TestBuilderConfig {\n+    TestBuilderConfig() {\n+    }\n+\n+    TestMethodSupplier createTestMethodSupplier() {\n+        return new TestMethodSupplier(os);\n+    }\n+\n+    OperatingSystem getOperatingSystem() {\n+        return os;\n+    }\n+\n+    static TestBuilderConfig getDefault() {\n+        return DEFAULT.get();\n+    }\n+\n+    static void setOperatingSystem(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        DEFAULT.get().os = os;\n+    }\n+\n+    static void setDefaults() {\n+        DEFAULT.set(new TestBuilderConfig());\n+    }\n+\n+    private OperatingSystem os = OperatingSystem.current();\n+\n+    private static final ThreadLocal<TestBuilderConfig> DEFAULT = new ThreadLocal<>() {\n+        @Override\n+        protected TestBuilderConfig initialValue() {\n+            return new TestBuilderConfig();\n+        }\n+    };\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilderConfig.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -37,0 +38,1 @@\n+import java.util.function.Function;\n@@ -53,1 +55,1 @@\n-            sb.append(clazz.getSimpleName());\n+            sb.append(clazz.getName());\n@@ -81,1 +83,1 @@\n-                ctorArgs = ofNullable(v);\n+                ctorArgs = Arrays.asList(v);\n@@ -86,1 +88,1 @@\n-                methodArgs = ofNullable(v);\n+                methodArgs = Arrays.asList(v);\n@@ -110,3 +112,7 @@\n-                        return String.format(\"%s(length=%d)\",\n-                                Arrays.deepToString((Object[]) v),\n-                                Array.getLength(v));\n+                        String asString;\n+                        if (v.getClass().getComponentType().isPrimitive()) {\n+                            asString = PRIMITIVE_ARRAY_FORMATTERS.get(v.getClass()).apply(v);\n+                        } else {\n+                            asString = Arrays.deepToString((Object[]) v);\n+                        }\n+                        return String.format(\"%s(length=%d)\", asString, Array.getLength(v));\n@@ -118,8 +124,0 @@\n-            private static List<Object> ofNullable(Object... values) {\n-                List<Object> result = new ArrayList();\n-                for (var v: values) {\n-                    result.add(v);\n-                }\n-                return result;\n-            }\n-\n@@ -334,1 +332,1 @@\n-    private final static Set<Status> KEEP_WORK_DIR = Functional.identity(\n+    private static final Set<Status> KEEP_WORK_DIR = Functional.identity(\n@@ -358,0 +356,11 @@\n+    private static final Map<Class<?>, Function<Object, String>> PRIMITIVE_ARRAY_FORMATTERS = Map.of(\n+            boolean[].class, v -> Arrays.toString((boolean[])v),\n+            byte[].class, v -> Arrays.toString((byte[])v),\n+            char[].class, v -> Arrays.toString((char[])v),\n+            short[].class, v -> Arrays.toString((short[])v),\n+            int[].class, v -> Arrays.toString((int[])v),\n+            long[].class, v -> Arrays.toString((long[])v),\n+            float[].class, v -> Arrays.toString((float[])v),\n+            double[].class, v -> Arrays.toString((double[])v)\n+    );\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestInstance.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterGroup;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.ParameterSupplierGroup;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import static jdk.jpackage.test.Functional.ThrowingFunction.toFunction;\n+import static jdk.jpackage.test.Functional.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.MethodCall.mapArgs;\n+\n+final class TestMethodSupplier {\n+\n+    TestMethodSupplier(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        this.os = os;\n+    }\n+\n+    record MethodQuery(String className, String methodName) {\n+\n+        List<Method> lookup() throws ClassNotFoundException {\n+            final Class methodClass = Class.forName(className);\n+\n+            \/\/ Get the list of all public methods as need to deal with overloads.\n+            return Stream.of(methodClass.getMethods()).filter(method -> {\n+                return method.getName().equals(methodName);\n+            }).toList();\n+        }\n+\n+        static MethodQuery fromQualifiedMethodName(String qualifiedMethodName) {\n+            int lastDotIdx = qualifiedMethodName.lastIndexOf('.');\n+            if (lastDotIdx == -1) {\n+                throw new IllegalArgumentException(\"Class name not specified\");\n+            }\n+\n+            var className = qualifiedMethodName.substring(0, lastDotIdx);\n+            var methodName = qualifiedMethodName.substring(lastDotIdx + 1);\n+\n+            return new MethodQuery(className, methodName);\n+        }\n+    }\n+\n+    List<Method> findNullaryLikeMethods(MethodQuery query) throws NoSuchMethodException {\n+        List<Method> methods;\n+\n+        try {\n+            methods = query.lookup();\n+        } catch (ClassNotFoundException ex) {\n+            throw new NoSuchMethodException(\n+                    String.format(\"Class [%s] not found\", query.className()));\n+        }\n+\n+        if (methods.isEmpty()) {\n+            throw new NoSuchMethodException(String.format(\n+                    \"Public method [%s] not found in [%s] class\",\n+                    query.methodName(), query.className()));\n+        }\n+\n+        methods = methods.stream().filter(method -> {\n+            if (isParameterized(method) && isTest(method)) {\n+                \/\/ Always accept test method with annotations producing arguments for its invocation.\n+                return true;\n+            } else {\n+                return method.getParameterCount() == 0;\n+            }\n+        }).filter(this::isEnabled).toList();\n+\n+        if (methods.isEmpty()) {\n+            throw new NoSuchMethodException(String.format(\n+                    \"Suitable public method [%s] not found in [%s] class\",\n+                    query.methodName(), query.className()));\n+        }\n+\n+        return methods;\n+    }\n+\n+    boolean isTestClass(Class<?> type) {\n+        var typeStatus = processedTypes.get(type);\n+        if (typeStatus == null) {\n+            typeStatus = Verifier.isTestClass(type) ? TypeStatus.TEST_CLASS : TypeStatus.NOT_TEST_CLASS;\n+            processedTypes.put(type, typeStatus);\n+        }\n+\n+        return !TypeStatus.NOT_TEST_CLASS.equals(typeStatus);\n+    }\n+\n+    void verifyTestClass(Class<?> type) throws InvalidAnnotationException {\n+        var typeStatus = processedTypes.get(type);\n+        if (typeStatus == null) {\n+            try {\n+                Verifier.verifyTestClass(type);\n+                processedTypes.put(type, TypeStatus.VALID_TEST_CLASS);\n+                return;\n+            } catch (InvalidAnnotationException ex) {\n+                processedTypes.put(type, TypeStatus.TEST_CLASS);\n+                throw ex;\n+            }\n+        }\n+\n+        switch (typeStatus) {\n+            case NOT_TEST_CLASS -> Verifier.throwNotTestClassException(type);\n+            case TEST_CLASS -> Verifier.verifyTestClass(type);\n+            case VALID_TEST_CLASS -> {}\n+        }\n+    }\n+\n+    boolean isEnabled(Method method) {\n+        return Stream.of(Test.class, Parameters.class)\n+                .filter(method::isAnnotationPresent)\n+                .findFirst()\n+                .map(method::getAnnotation)\n+                .map(this::canRunOnTheOperatingSystem)\n+                .orElse(true);\n+    }\n+\n+    Stream<MethodCall> mapToMethodCalls(Method method) throws\n+            IllegalAccessException, InvocationTargetException {\n+        return toCtorArgs(method).map(v -> toMethodCalls(v, method)).flatMap(x -> x);\n+    }\n+\n+    private Stream<Object[]> toCtorArgs(Method method) throws\n+            IllegalAccessException, InvocationTargetException {\n+\n+        if ((method.getModifiers() & Modifier.STATIC) != 0) {\n+            \/\/ Static method, no instance\n+            return Stream.ofNullable(DEFAULT_CTOR_ARGS);\n+        }\n+\n+        final var type = method.getDeclaringClass();\n+\n+        final var paremeterSuppliers = filterParameterSuppliers(type)\n+                .filter(m -> m.isAnnotationPresent(Parameters.class))\n+                .filter(this::isEnabled)\n+                .sorted(Comparator.comparing(Method::getName)).toList();\n+        if (paremeterSuppliers.isEmpty()) {\n+            \/\/ Single instance using the default constructor.\n+            return Stream.ofNullable(DEFAULT_CTOR_ARGS);\n+        }\n+\n+        \/\/ Construct collection of arguments for test class instances.\n+        return createArgs(paremeterSuppliers.toArray(Method[]::new));\n+    }\n+\n+    private Stream<MethodCall> toMethodCalls(Object[] ctorArgs, Method method) {\n+        if (!isParameterized(method)) {\n+            return Stream.of(new MethodCall(ctorArgs, method));\n+        }\n+\n+        var fromParameter = Stream.of(getMethodParameters(method)).map(a -> {\n+            return createArgsForAnnotation(method, a);\n+        }).flatMap(List::stream);\n+\n+        var fromParameterSupplier = Stream.of(getMethodParameterSuppliers(method)).map(a -> {\n+            return toSupplier(() -> createArgsForAnnotation(method, a)).get();\n+        }).flatMap(List::stream);\n+\n+        return Stream.concat(fromParameter, fromParameterSupplier).map(args -> {\n+            return new MethodCall(ctorArgs, method, args);\n+        });\n+    }\n+\n+    private List<Object[]> createArgsForAnnotation(Executable exec, Parameter a) {\n+        if (!canRunOnTheOperatingSystem(a)) {\n+            return List.of();\n+        }\n+\n+        final var annotationArgs = a.value();\n+        final var execParameterTypes = exec.getParameterTypes();\n+\n+        if (execParameterTypes.length > annotationArgs.length) {\n+            if (execParameterTypes.length - annotationArgs.length == 1 && exec.isVarArgs()) {\n+            } else {\n+                throw new RuntimeException(String.format(\n+                        \"Not enough annotation values %s for [%s]\",\n+                        List.of(annotationArgs), exec));\n+            }\n+        }\n+\n+        final Class<?>[] argTypes;\n+        if (exec.isVarArgs()) {\n+            List<Class<?>> argTypesBuilder = new ArrayList<>();\n+            var lastExecParameterTypeIdx = execParameterTypes.length - 1;\n+            argTypesBuilder.addAll(List.of(execParameterTypes).subList(0,\n+                    lastExecParameterTypeIdx));\n+            argTypesBuilder.addAll(Collections.nCopies(\n+                    Integer.max(0, annotationArgs.length - lastExecParameterTypeIdx),\n+                    execParameterTypes[lastExecParameterTypeIdx].componentType()));\n+            argTypes = argTypesBuilder.toArray(Class[]::new);\n+        } else {\n+            argTypes = execParameterTypes;\n+        }\n+\n+        if (argTypes.length < annotationArgs.length) {\n+            throw new RuntimeException(String.format(\n+                    \"Too many annotation values %s for [%s]\",\n+                    List.of(annotationArgs), exec));\n+        }\n+\n+        var args = mapArgs(exec, IntStream.range(0, argTypes.length).mapToObj(idx -> {\n+            return fromString(annotationArgs[idx], argTypes[idx]);\n+        }).toArray(Object[]::new));\n+\n+        return List.<Object[]>of(args);\n+    }\n+\n+    private List<Object[]> createArgsForAnnotation(Executable exec,\n+            ParameterSupplier a) throws IllegalAccessException,\n+            InvocationTargetException {\n+        if (!canRunOnTheOperatingSystem(a)) {\n+            return List.of();\n+        }\n+\n+        final Class<?> execClass = exec.getDeclaringClass();\n+        final var supplierFuncName = a.value();\n+\n+        final MethodQuery methodQuery;\n+        if (!a.value().contains(\".\")) {\n+            \/\/ No class name specified\n+            methodQuery = new MethodQuery(execClass.getName(), a.value());\n+        } else {\n+            methodQuery = MethodQuery.fromQualifiedMethodName(supplierFuncName);\n+        }\n+\n+        final Method supplierMethod;\n+        try {\n+            final var parameterSupplierCandidates = findNullaryLikeMethods(methodQuery);\n+            final Function<String, Class> classForName = toFunction(Class::forName);\n+            final var supplierMethodClass = classForName.apply(methodQuery.className());\n+            if (parameterSupplierCandidates.isEmpty()) {\n+                throw new RuntimeException(String.format(\n+                        \"No parameter suppliers in [%s] class\",\n+                        supplierMethodClass.getName()));\n+            }\n+\n+            var allParameterSuppliers = filterParameterSuppliers(supplierMethodClass).toList();\n+\n+            supplierMethod = findNullaryLikeMethods(methodQuery)\n+                    .stream()\n+                    .filter(allParameterSuppliers::contains)\n+                    .findFirst().orElseThrow(() -> {\n+                        var msg = String.format(\n+                                \"No suitable parameter supplier found for %s(%s) annotation\",\n+                                a, supplierFuncName);\n+                        trace(String.format(\n+                                \"%s. Parameter suppliers of %s class:\", msg,\n+                                execClass.getName()));\n+                        IntStream.range(0, allParameterSuppliers.size()).mapToObj(idx -> {\n+                            return String.format(\"  [%d\/%d] %s()\", idx + 1,\n+                                    allParameterSuppliers.size(),\n+                                    allParameterSuppliers.get(idx).getName());\n+                        }).forEachOrdered(TestMethodSupplier::trace);\n+\n+                        return new RuntimeException(msg);\n+                    });\n+        } catch (NoSuchMethodException ex) {\n+            throw new RuntimeException(String.format(\n+                    \"Method not found for %s(%s) annotation\", a, supplierFuncName));\n+        }\n+\n+        return createArgs(supplierMethod).map(args -> {\n+            return mapArgs(exec, args);\n+        }).toList();\n+    }\n+\n+    private boolean canRunOnTheOperatingSystem(Annotation a) {\n+        switch (a) {\n+            case Test t -> {\n+                return canRunOnTheOperatingSystem(os, t.ifOS(), t.ifNotOS());\n+            }\n+            case Parameters t -> {\n+                return canRunOnTheOperatingSystem(os, t.ifOS(), t.ifNotOS());\n+            }\n+            case Parameter t -> {\n+                return canRunOnTheOperatingSystem(os, t.ifOS(), t.ifNotOS());\n+            }\n+            case ParameterSupplier t -> {\n+                return canRunOnTheOperatingSystem(os, t.ifOS(), t.ifNotOS());\n+            }\n+            default -> {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    private static boolean isParameterized(Method method) {\n+        return Stream.of(\n+                Parameter.class, ParameterGroup.class,\n+                ParameterSupplier.class, ParameterSupplierGroup.class\n+        ).anyMatch(method::isAnnotationPresent);\n+    }\n+\n+    private static boolean isTest(Method method) {\n+        return method.isAnnotationPresent(Test.class);\n+    }\n+\n+    private static boolean canRunOnTheOperatingSystem(OperatingSystem value,\n+            OperatingSystem[] include, OperatingSystem[] exclude) {\n+        Set<OperatingSystem> suppordOperatingSystems = new HashSet<>();\n+        suppordOperatingSystems.addAll(List.of(include));\n+        suppordOperatingSystems.removeAll(List.of(exclude));\n+        return suppordOperatingSystems.contains(value);\n+    }\n+\n+    private static Parameter[] getMethodParameters(Method method) {\n+        if (method.isAnnotationPresent(ParameterGroup.class)) {\n+            return ((ParameterGroup) method.getAnnotation(ParameterGroup.class)).value();\n+        }\n+\n+        if (method.isAnnotationPresent(Parameter.class)) {\n+            return new Parameter[]{(Parameter) method.getAnnotation(Parameter.class)};\n+        }\n+\n+        return new Parameter[0];\n+    }\n+\n+    private static ParameterSupplier[] getMethodParameterSuppliers(Method method) {\n+        if (method.isAnnotationPresent(ParameterSupplierGroup.class)) {\n+            return ((ParameterSupplierGroup) method.getAnnotation(ParameterSupplierGroup.class)).value();\n+        }\n+\n+        if (method.isAnnotationPresent(ParameterSupplier.class)) {\n+            return new ParameterSupplier[]{(ParameterSupplier) method.getAnnotation(\n+                ParameterSupplier.class)};\n+        }\n+\n+        return new ParameterSupplier[0];\n+    }\n+\n+    private static Stream<Method> filterParameterSuppliers(Class<?> type) {\n+        return Stream.of(type.getMethods())\n+                .filter(m -> m.getParameterCount() == 0)\n+                .filter(m -> (m.getModifiers() & Modifier.STATIC) != 0)\n+                .sorted(Comparator.comparing(Method::getName));\n+    }\n+\n+    private static Stream<Object[]> createArgs(Method ... parameterSuppliers) throws\n+            IllegalAccessException, InvocationTargetException {\n+        List<Object[]> args = new ArrayList<>();\n+        for (var parameterSupplier : parameterSuppliers) {\n+            args.addAll((Collection) parameterSupplier.invoke(null));\n+        }\n+        return args.stream();\n+    }\n+\n+    private static Object fromString(String value, Class toType) {\n+        if (toType.isEnum()) {\n+            return Enum.valueOf(toType, value);\n+        }\n+        Function<String, Object> converter = FROM_STRING.get(toType);\n+        if (converter == null) {\n+            throw new RuntimeException(String.format(\n+                    \"Failed to find a conversion of [%s] string to %s type\",\n+                    value, toType.getName()));\n+        }\n+        return converter.apply(value);\n+    }\n+\n+    private static void trace(String msg) {\n+        if (TKit.VERBOSE_TEST_SETUP) {\n+            TKit.log(msg);\n+        }\n+    }\n+\n+    static class InvalidAnnotationException extends Exception {\n+        InvalidAnnotationException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    private static class Verifier {\n+        static boolean isTestClass(Class<?> type) {\n+            for (var method : type.getDeclaredMethods()) {\n+                method.setAccessible(true);\n+                if (isParameterized(method) || isTest(method)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        static void verifyTestClass(Class<?> type) throws InvalidAnnotationException {\n+            boolean withTestAnnotations = false;\n+            for (var method : type.getDeclaredMethods()) {\n+                method.setAccessible(true);\n+                if (withTestAnnotations) {\n+                } else if (isParameterized(method) || isTest(method)) {\n+                    withTestAnnotations = true;\n+                }\n+                verifyAnnotationsCorrect(method);\n+            }\n+\n+            if (!withTestAnnotations) {\n+                throwNotTestClassException(type);\n+            }\n+        }\n+\n+        static void throwNotTestClassException(Class<?> type) throws InvalidAnnotationException {\n+            throw new InvalidAnnotationException(String.format(\n+                    \"Type [%s] is not a test class\", type.getName()));\n+        }\n+\n+        private static void verifyAnnotationsCorrect(Method method) throws\n+                InvalidAnnotationException {\n+            var parameterized = isParameterized(method);\n+            if (parameterized && !isTest(method)) {\n+                throw new InvalidAnnotationException(String.format(\n+                        \"Missing %s annotation on [%s] method\", Test.class.getName(), method));\n+            }\n+\n+            var isPublic = Modifier.isPublic(method.getModifiers());\n+\n+            if (isTest(method) && !isPublic) {\n+                throw new InvalidAnnotationException(String.format(\n+                        \"Non-public method [%s] with %s annotation\",\n+                        method, Test.class.getName()));\n+            }\n+\n+            if (method.isAnnotationPresent(Parameters.class) && !isPublic) {\n+                throw new InvalidAnnotationException(String.format(\n+                        \"Non-public method [%s] with %s annotation\",\n+                        method, Test.class.getName()));\n+            }\n+        }\n+    }\n+\n+    private enum TypeStatus {\n+        NOT_TEST_CLASS,\n+        TEST_CLASS,\n+        VALID_TEST_CLASS,\n+    }\n+\n+    private final OperatingSystem os;\n+    private final Map<Class<?>, TypeStatus> processedTypes = new HashMap<>();\n+\n+    private static final Object[] DEFAULT_CTOR_ARGS = new Object[0];\n+\n+    private static final Map<Class, Function<String, Object>> FROM_STRING;\n+\n+    static {\n+        Map<Class, Function<String, Object>> primitives = Map.of(\n+            boolean.class, Boolean::valueOf,\n+            byte.class, Byte::valueOf,\n+            short.class, Short::valueOf,\n+            int.class, Integer::valueOf,\n+            long.class, Long::valueOf,\n+            float.class, Float::valueOf,\n+            double.class, Double::valueOf);\n+\n+        Map<Class, Function<String, Object>> boxed = Map.of(\n+            Boolean.class, Boolean::valueOf,\n+            Byte.class, Byte::valueOf,\n+            Short.class, Short::valueOf,\n+            Integer.class, Integer::valueOf,\n+            Long.class, Long::valueOf,\n+            Float.class, Float::valueOf,\n+            Double.class, Double::valueOf);\n+\n+        Map<Class, Function<String, Object>> other = Map.of(\n+            String.class, String::valueOf,\n+            Path.class, Path::of);\n+\n+        Map<Class, Function<String, Object>> combined = new HashMap<>(primitives);\n+        combined.putAll(other);\n+        combined.putAll(boxed);\n+\n+        FROM_STRING = Collections.unmodifiableMap(combined);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestMethodSupplier.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import static java.util.stream.Collectors.toSet;\n@@ -34,0 +33,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -37,1 +37,1 @@\n-import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.Annotations.Parameters;\n@@ -58,1 +58,1 @@\n-    @Annotations.Parameters\n+    @Parameters\n@@ -62,1 +62,1 @@\n-        for (var packageTypes : List.of(PackageType.IMAGE.toString(), ALL_NATIVE_PACKAGE_TYPES)) {\n+        for (var packageTypeAlias : PackageTypeAlias.values()) {\n@@ -64,4 +64,4 @@\n-                {packageTypes, wrap(InOutPathTest::outputDirInInputDir, \"--dest in --input\")},\n-                {packageTypes, wrap(InOutPathTest::outputDirSameAsInputDir, \"--dest same as --input\")},\n-                {packageTypes, wrap(InOutPathTest::tempDirInInputDir, \"--temp in --input\")},\n-                {packageTypes, wrap(cmd -> {\n+                {packageTypeAlias, wrap(InOutPathTest::outputDirInInputDir, \"--dest in --input\")},\n+                {packageTypeAlias, wrap(InOutPathTest::outputDirSameAsInputDir, \"--dest same as --input\")},\n+                {packageTypeAlias, wrap(InOutPathTest::tempDirInInputDir, \"--temp in --input\")},\n+                {packageTypeAlias, wrap(cmd -> {\n@@ -72,1 +72,1 @@\n-            data.addAll(additionalContentInput(packageTypes, \"--app-content\"));\n+            data.addAll(additionalContentInput(packageTypeAlias, \"--app-content\"));\n@@ -75,14 +75,2 @@\n-        if (!TKit.isOSX()) {\n-            data.addAll(List.of(new Object[][]{\n-                {PackageType.IMAGE.toString(), wrap(cmd -> {\n-                    additionalContent(cmd, \"--app-content\", cmd.outputBundle());\n-                }, \"--app-content same as output bundle\")},\n-            }));\n-        } else {\n-            var contentsFolder = \"Contents\/MacOS\";\n-            data.addAll(List.of(new Object[][]{\n-                {PackageType.IMAGE.toString(), wrap(cmd -> {\n-                    additionalContent(cmd, \"--app-content\", cmd.outputBundle().resolve(contentsFolder));\n-                }, String.format(\"--app-content same as the \\\"%s\\\" folder in the output bundle\", contentsFolder))},\n-            }));\n-        }\n+        return data;\n+    }\n@@ -90,4 +78,8 @@\n-        if (TKit.isOSX()) {\n-            data.addAll(additionalContentInput(PackageType.MAC_DMG.toString(),\n-                    \"--mac-dmg-content\"));\n-        }\n+    @Parameters(ifNotOS = OperatingSystem.MACOS)\n+    public static Collection<Object[]> appContentInputOther() {\n+        return List.of(new Object[][]{\n+            {PackageTypeAlias.IMAGE, wrap(cmd -> {\n+                additionalContent(cmd, \"--app-content\", cmd.outputBundle());\n+            }, \"--app-content same as output bundle\")},\n+        });\n+    }\n@@ -95,1 +87,8 @@\n-        return data;\n+    @Parameters(ifOS = OperatingSystem.MACOS)\n+    public static Collection<Object[]> appContentInputOSX() {\n+        var contentsFolder = \"Contents\/MacOS\";\n+        return List.of(new Object[][]{\n+            {PackageTypeAlias.IMAGE, wrap(cmd -> {\n+                additionalContent(cmd, \"--app-content\", cmd.outputBundle().resolve(contentsFolder));\n+            }, String.format(\"--app-content same as the \\\"%s\\\" folder in the output bundle\", contentsFolder))},\n+        });\n@@ -98,1 +97,6 @@\n-    private static List<Object[]> additionalContentInput(String packageTypes, String argName) {\n+    @Parameters(ifOS = OperatingSystem.MACOS)\n+    public static Collection<Object[]> inputOSX() {\n+        return List.of(additionalContentInput(PackageType.MAC_DMG, \"--mac-dmg-content\").toArray(Object[][]::new));\n+    }\n+\n+    private static List<Object[]> additionalContentInput(Object packageTypes, String argName) {\n@@ -130,7 +134,10 @@\n-    public InOutPathTest(String packageTypes, Envelope configure) {\n-        if (ALL_NATIVE_PACKAGE_TYPES.equals(packageTypes)) {\n-            this.packageTypes = PackageType.NATIVE;\n-        } else {\n-            this.packageTypes = Stream.of(packageTypes.split(\",\")).map(\n-                    PackageType::valueOf).collect(toSet());\n-        }\n+    public InOutPathTest(PackageTypeAlias packageTypeAlias, Envelope configure) {\n+        this(packageTypeAlias.packageTypes, configure);\n+    }\n+\n+    public InOutPathTest(PackageType packageType, Envelope configure) {\n+        this(Set.of(packageType), configure);\n+    }\n+\n+    public InOutPathTest(Set<PackageType> packageTypes, Envelope configure) {\n+        this.packageTypes = packageTypes;\n@@ -274,0 +281,12 @@\n+    private enum PackageTypeAlias {\n+        IMAGE(Set.of(PackageType.IMAGE)),\n+        NATIVE(PackageType.NATIVE),\n+        ;\n+\n+        PackageTypeAlias(Set<PackageType> packageTypes) {\n+            this.packageTypes = packageTypes;\n+        }\n+\n+        private final Set<PackageType> packageTypes;\n+    }\n+\n@@ -282,2 +301,0 @@\n-\n-    private static final String ALL_NATIVE_PACKAGE_TYPES = \"NATIVE\";\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":55,"deletions":38,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-import java.util.HashMap;\n-import java.util.Map;\n+import jdk.internal.util.OperatingSystem;\n@@ -30,1 +29,0 @@\n-import jdk.jpackage.test.Functional;\n@@ -32,0 +30,1 @@\n+import jdk.jpackage.test.Annotations.Test;\n@@ -79,15 +78,5 @@\n-    public static void testCommon() {\n-        final Map<PackageType, Path> INSTALL_DIRS = Functional.identity(() -> {\n-            Map<PackageType, Path> reply = new HashMap<>();\n-            reply.put(PackageType.WIN_MSI, Path.of(\"TestVendor\\\\InstallDirTest1234\"));\n-            reply.put(PackageType.WIN_EXE, reply.get(PackageType.WIN_MSI));\n-\n-            reply.put(PackageType.LINUX_DEB, Path.of(\"\/opt\/jpackage\"));\n-            reply.put(PackageType.LINUX_RPM, reply.get(PackageType.LINUX_DEB));\n-\n-            reply.put(PackageType.MAC_PKG, Path.of(\"\/Applications\/jpackage\"));\n-            reply.put(PackageType.MAC_DMG, reply.get(PackageType.MAC_PKG));\n-\n-            return reply;\n-        }).get();\n-\n+    @Test\n+    @Parameter(value = \"TestVendor\\\\InstallDirTest1234\", ifOS = OperatingSystem.WINDOWS)\n+    @Parameter(value = \"\/opt\/jpackage\", ifOS = OperatingSystem.LINUX)\n+    @Parameter(value = \"\/Applications\/jpackage\", ifOS = OperatingSystem.MACOS)\n+    public static void testCommon(Path installDir) {\n@@ -96,2 +85,1 @@\n-            cmd.addArguments(\"--install-dir\", INSTALL_DIRS.get(\n-                    cmd.packageType()));\n+            cmd.addArguments(\"--install-dir\", installDir);\n@@ -101,0 +89,1 @@\n+    @Test(ifOS = OperatingSystem.LINUX)\n","filename":"test\/jdk\/tools\/jpackage\/share\/InstallDirTest.java","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import jdk.jpackage.test.Annotations.Parameters;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -30,0 +32,1 @@\n+import jdk.jpackage.test.CannedFormattedString;\n@@ -31,0 +34,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -57,4 +61,0 @@\n-    private final String expectedError;\n-    private final JPackageCommand cmd;\n-\n-    @Parameters\n@@ -67,1 +67,1 @@\n-                    \"Invalid Option: [--no-such-argument]\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_InvalidOption\", \"--no-such-argument\")},\n@@ -72,1 +72,1 @@\n-                    \"--main-jar or --module\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_NoEntryPoint\")},\n@@ -77,1 +77,2 @@\n-                    \"main class was not specified\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.no-main-class-with-main-jar\", \"hello.jar\"),\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.no-main-class-with-main-jar.advice\", \"hello.jar\")},\n@@ -82,1 +83,1 @@\n-                    \"main jar does not exist\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.main-jar-does-not-exist\", \"non-existent.jar\")},\n@@ -87,1 +88,1 @@\n-                    \"does not exist\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"message.runtime-image-dir-does-not-exist\", \"runtime-image\", \"non-existent.runtime\")},\n@@ -92,1 +93,1 @@\n-                    \"does not exist\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"message.resource-dir-does-not-exist\", \"resource-dir\", \"non-existent.dir\")},\n@@ -97,1 +98,1 @@\n-                    \"Invalid or unsupported type: [invalid-type]\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_InvalidInstallerType\", \"invalid-type\")},\n@@ -102,1 +103,1 @@\n-                    \"Missing argument: --input\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_MissingArgument\", \"--input\")},\n@@ -107,1 +108,1 @@\n-                    \"Missing argument: --runtime-image or --module-path\"},\n+                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_MissingArgument\", \"--runtime-image or --module-path\")},\n@@ -111,4 +112,13 @@\n-    public ErrorTest(String javaAppDesc, String[] jpackageArgs,\n-                String[] removeArgs,\n-                String expectedError) {\n-        this.expectedError = expectedError;\n+    @Test\n+    @ParameterSupplier(\"input\")\n+    public static void test(String javaAppDesc, String[] jpackageArgs,\n+            String[] removeArgs, CannedFormattedString... expectedErrors) {\n+        \/\/ Init default jpackage test command line.\n+        var cmd = JPackageCommand.helloAppImage(javaAppDesc)\n+                \/\/ Disable default logic adding `--verbose` option\n+                \/\/ to jpackage command line.\n+                \/\/ It will affect jpackage error messages if the command line is malformed.\n+                .ignoreDefaultVerbose(true)\n+                \/\/ Ignore external runtime as it will interfer\n+                \/\/ with jpackage arguments in this test.\n+                .ignoreDefaultRuntime(true);\n@@ -116,10 +126,2 @@\n-        cmd = JPackageCommand.helloAppImage(javaAppDesc)\n-                .saveConsoleOutput(true).dumpOutput(true);\n-        if (jpackageArgs != null) {\n-            cmd.addArguments(jpackageArgs);\n-        } if (removeArgs != null) {\n-            for (String arg : removeArgs) {\n-                cmd.removeArgumentWithValue(arg);\n-            }\n-        }\n-    }\n+        \/\/ Add arguments if requested.\n+        Optional.ofNullable(jpackageArgs).ifPresent(cmd::addArguments);\n@@ -127,6 +129,10 @@\n-    @Test\n-    public void test() {\n-        List<String> output = cmd.execute(1).getOutput();\n-        TKit.assertNotNull(output, \"output is null\");\n-        TKit.assertTextStream(expectedError).apply(output.stream());\n-    }\n+        \/\/ Remove arguments if requested.\n+        Optional.ofNullable(removeArgs).map(List::of).ifPresent(\n+                args -> args.forEach(cmd::removeArgumentWithValue));\n+\n+        \/\/ Configure jpackage output verifier to look up the list of provided\n+        \/\/ errors in the order they specified.\n+        cmd.validateOutput(Stream.of(expectedErrors)\n+                .map(CannedFormattedString::getValue)\n+                .map(TKit::assertTextStream)\n+                .reduce(TKit.TextStreamVerifier::andThen).get());\n@@ -134,0 +140,2 @@\n+        cmd.execute(1);\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/ErrorTest.java","additions":42,"deletions":34,"binary":false,"changes":76,"status":"modified"}]}