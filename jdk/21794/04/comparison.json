{"files":[{"patch":"@@ -1675,0 +1675,6 @@\n+            \/* there are three cases for ts and ss:\n+             *   - one is a class and the other one is an interface (case I)\n+             *   - both are classes                                 (case II)\n+             *   - both are interfaces                              (case III)\n+             * all those cases are covered in JLS 23, section: \"5.1.6.1 Allowed Narrowing Reference Conversion\"\n+             *\/\n@@ -1682,23 +1688,24 @@\n-                if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n-                    return false;\n-                }\n-                \/\/ if both are classes or both are interfaces, shortcut\n-                if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n-                    return false;\n-                }\n-                if (ts.isInterface() && !ss.isInterface()) {\n-                    \/* so ts is interface but ss is a class\n-                     * an interface is disjoint from a class if the class is disjoint form the interface\n-                     *\/\n-                    return areDisjoint(ss, ts);\n-                }\n-                \/\/ a final class that is not subtype of ss is disjoint\n-                if (!ts.isInterface() && ts.isFinal()) {\n-                    return true;\n-                }\n-                \/\/ if at least one is sealed\n-                if (ts.isSealed() || ss.isSealed()) {\n-                    \/\/ permitted subtypes have to be disjoint with the other symbol\n-                    ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n-                    ClassSymbol other = sealedOne == ts ? ss : ts;\n-                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n+\n+                if (ts.isInterface() != ss.isInterface()) { \/\/ case I: one is a class and the other one is an interface\n+                    ClassSymbol isym = ts.isInterface() ? ts : ss; \/\/ isym is the interface and csym the class\n+                    ClassSymbol csym = isym == ts ? ss : ts;\n+                    if (!isSubtype(erasure(csym.type), erasure(isym.type))) {\n+                        if (csym.isFinal()) {\n+                            return true;\n+                        } else if (csym.isSealed()) {\n+                            return areDisjoint(isym, csym.getPermittedSubclasses());\n+                        } else if (isym.isSealed()) {\n+                            return areDisjoint(csym, isym.getPermittedSubclasses());\n+                        }\n+                    }\n+                } else if (!ts.isInterface() &&              \/\/ case II: both are classes\n+                        !ss.isInterface()) {\n+                    return !isSubtype(erasure(ss.type), erasure(ts.type)) && !isSubtype(erasure(ts.type), erasure(ss.type));\n+                } else {                                     \/\/ case III: both are interfaces\n+                    if (!isSubtype(erasure(ts.type), erasure(ss.type)) && !isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                        if (ts.isSealed()) {\n+                            return areDisjoint(ss, ts.getPermittedSubclasses());\n+                        } else if (ss.isSealed()) {\n+                            return areDisjoint(ts, ss.getPermittedSubclasses());\n+                        }\n+                    }\n@@ -1706,0 +1713,1 @@\n+                \/\/ at this point we haven't been able to statically prove that the classes or interfaces are disjoint\n@@ -1708,0 +1716,4 @@\n+\n+            boolean areDisjoint(ClassSymbol csym, List<Type> permittedSubtypes) {\n+                return permittedSubtypes.stream().allMatch(psubtype -> areDisjoint(csym, (ClassSymbol) psubtype.tsym));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1181,0 +1181,33 @@\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    sealed interface I permits C1 {}\n+                    non-sealed class C1 implements I {}\n+                    class C2 extends C1 {}\n+                    class C3 {}\n+                    I m(int s, C3 c3) {\n+                        I i = (I)c3;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    sealed interface I permits C1 {}\n+                    non-sealed class C1 implements I {}\n+                    class C2 extends C1 {}\n+                    class C3 {}\n+                    I m(int s, C3 c3) {\n+                        I i = (C1)c3;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    sealed interface I permits C1 {}\n+                    non-sealed class C1 implements I {}\n+                    class C2 extends C1 {}\n+                    class C3 {}\n+                    I m(int s, C3 c3) {\n+                        I i = (C2)c3;\n+                    }\n+                }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}