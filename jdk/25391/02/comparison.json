{"files":[{"patch":"@@ -32,4 +32,0 @@\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n@@ -38,1 +34,7 @@\n-import java.util.stream.Stream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n@@ -42,0 +44,2 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n@@ -50,1 +54,1 @@\n-                    \".*\\\\Rkeystore\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\";\n+            \".*\\\\Rkeystore\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\";\n@@ -53,30 +57,80 @@\n-                    \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\"\n-                    + DATE_REGEX + \".*\\\\]:\";\n-\n-    private static Stream<Arguments> patternMatches() {\n-        return Stream.of(\n-                \/\/ test for thread and timestamp info\n-                Arguments.of(\"properties\",\n-                        EXPECTED_PROP_REGEX,\n-                        \"properties:\"),\n-                \/\/ test for thread and timestamp info\n-                Arguments.of(\"properties+thread\",\n-                        EXPECTED_PROP_REGEX,\n-                        \"properties:\"),\n-                \/\/ flip the arguments of previous test\n-                Arguments.of(\"properties+thread+timestamp\",\n-                        EXPECTED_PROP_REGEX,\n-                        \"properties:\"),\n-                \/\/ regular keystore,properties component string\n-                Arguments.of(\"keystore,properties\",\n-                        EXPECTED_PROP_KEYSTORE_REGEX,\n-                        \"properties:\"),\n-                \/\/ turn on all\n-                Arguments.of(\"all\",\n-                        EXPECTED_ALL_REGEX,\n-                        \"properties:\"),\n-                \/\/ expect thread and timestamp info\n-                Arguments.of(\"all+thread\",\n-                        EXPECTED_ALL_REGEX,\n-                        \"properties:\")\n-        );\n+            \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\"\n+            + DATE_REGEX + \".*\\\\]:\";\n+\n+    private static final List<String[]> patternMatches = List.of(\n+            \/\/ test for thread and timestamp info\n+            new String[]{\"properties\",\n+                    EXPECTED_PROP_REGEX,\n+                    \"properties:\"},\n+            \/\/ test for thread and timestamp info\n+            new String[]{\"properties+thread\",\n+                    EXPECTED_PROP_REGEX,\n+                    \"properties:\"},\n+            \/\/ flip the arguments of previous test\n+            new String[]{\"properties+thread+timestamp\",\n+                    EXPECTED_PROP_REGEX,\n+                    \"properties:\"},\n+            \/\/ regular keystore,properties component string\n+            new String[]{\"keystore,properties\",\n+                    EXPECTED_PROP_KEYSTORE_REGEX,\n+                    \"properties:\"},\n+            \/\/ turn on all\n+            new String[]{\"all\",\n+                    EXPECTED_ALL_REGEX,\n+                    \"properties:\"},\n+            \/\/ expect thread and timestamp info\n+            new String[]{\"all+thread\",\n+                    EXPECTED_ALL_REGEX,\n+                    \"properties:\"}\n+    );\n+\n+    \/**\n+     * This will execute the test logic without any param manipulation\n+     *\n+     * @param paramName   name of the parameter e.g. -Djava.security.debug=\n+     * @param paramVal    value of the parameter\n+     * @param expected    expected output\n+     * @param notExpected not expected output\n+     *\/\n+    public void testParameter(String paramName,\n+                              String paramVal,\n+                              String expected,\n+                              String notExpected) throws Exception {\n+\n+        System.out.printf(\"Executing: {%s%s DebugOptions}%n\",\n+                paramName,\n+                paramVal);\n+\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                paramName + paramVal,\n+                \"DebugOptions\");\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    \/**\n+     * This will execute the test logic, but first change the param\n+     * to be mixed case\n+     *\n+     * @param paramName   name of the parameter e.g. -Djava.security.debug=\n+     * @param paramVal    value of the parameter\n+     * @param expected    expected output\n+     * @param notExpected not expected output\n+     *\/\n+    public void testMixedCaseParameter(String paramName,\n+                                       String paramVal,\n+                                       String expected,\n+                                       String notExpected) throws Exception {\n+\n+        final String formattedParam = makeFirstAndLastLetterUppercase(paramVal);\n+        System.out.printf(\"Executing: {%s%s DebugOptions}%n\",\n+                paramName,\n+                formattedParam);\n+\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                paramName + formattedParam,\n+                \"DebugOptions\");\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n@@ -85,7 +139,22 @@\n-    @ParameterizedTest\n-    @MethodSource(\"patternMatches\")\n-    public void shouldContain(String params, String expected, String notExpected) throws Exception {\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n-                \"-Djava.security.debug=\" + params,\n-                \"DebugOptions\"\n-        );\n+    \/**\n+     * This will execute the test logic, but first change the param\n+     * to be uppercase\n+     *\n+     * @param paramName   name of the parameter e.g. -Djava.security.debug=\n+     * @param paramVal    value of the parameter\n+     * @param expected    expected output\n+     * @param notExpected not expected output\n+     *\/\n+    public void testUpperCaseParameter(String paramName,\n+                                       String paramVal,\n+                                       String expected,\n+                                       String notExpected) throws Exception {\n+\n+        final String formattedParam = paramVal.toUpperCase();\n+        System.out.printf(\"Executing: {%s%s DebugOptions}%n\",\n+                paramName,\n+                formattedParam);\n+\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                paramName + formattedParam,\n+                \"DebugOptions\");\n@@ -97,0 +166,142 @@\n+    \/**\n+     * This method will change the input string to have all letters uppercase\n+     * <p>\n+     * e.g.:\n+     * hello -> HELLO\n+     *\n+     * @param paramString string to change. Must not be null or empty\n+     * @return resulting string\n+     *\/\n+    private String makeFirstAndLastLetterUppercase(final String paramString) {\n+        Assertions.assertTrue(paramString != null && !paramString.isEmpty());\n+\n+        final int length = paramString.length();\n+        final String firstLetter = paramString.substring(0, 1);\n+        final String lastLetter = paramString.substring((length - 1),\n+                length);\n+\n+        return firstLetter.toUpperCase()\n+               + paramString.substring(1, length - 1)\n+               + lastLetter.toUpperCase();\n+    }\n+\n+    \/**\n+     * This test will run all options in parallel with all param names\n+     * in lowercase\n+     *\/\n+    @Test\n+    public void debugOptionsLowerCaseTest() throws Exception {\n+\n+        try (final ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n+            final List<Callable<Void>> testsCallables = new ArrayList<>();\n+\n+            patternMatches.forEach(params -> {\n+                testsCallables.add(() -> {\n+                    testParameter(\n+                            \"-Djava.security.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+                testsCallables.add(() -> {\n+                    testParameter(\n+                            \"-Djava.security.auth.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+\n+                System.out.println(\"Option added to all lowercase tests \" + Arrays.toString(params));\n+            });\n+\n+            System.out.println(\"Starting all the threads\");\n+            final List<Future<Void>> res = executorService.invokeAll(testsCallables);\n+            for (final Future<Void> future : res) {\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This test will run all options in parallel with all param names\n+     * in mixed case\n+     *\/\n+    @Test\n+    public void debugOptionsMixedCaseTest() throws Exception {\n+\n+        try (final ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n+            final List<Callable<Void>> testsCallables = new ArrayList<>();\n+\n+            patternMatches.forEach(params -> {\n+                testsCallables.add(() -> {\n+                    testMixedCaseParameter(\n+                            \"-Djava.security.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+                testsCallables.add(() -> {\n+                    testMixedCaseParameter(\n+                            \"-Djava.security.auth.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+\n+                System.out.println(\"Option added to all mixed case tests \" + Arrays.toString(params));\n+            });\n+\n+            System.out.println(\"Starting all the threads\");\n+            final List<Future<Void>> res = executorService.invokeAll(testsCallables);\n+            for (final Future<Void> future : res) {\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This test will run all options in parallel with all param names\n+     * in uppercase\n+     *\/\n+    @Test\n+    public void debugOptionsUpperCaseTest() throws Exception {\n+\n+        try (final ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n+            final List<Callable<Void>> testsCallables = new ArrayList<>();\n+\n+            patternMatches.forEach(params -> {\n+                testsCallables.add(() -> {\n+                    testUpperCaseParameter(\n+                            \"-Djava.security.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+                testsCallables.add(() -> {\n+                    testUpperCaseParameter(\n+                            \"-Djava.security.auth.debug=\",\n+                            params[0],\n+                            params[1],\n+                            params[2]);\n+                    return null;\n+                });\n+\n+                System.out.println(\"Option added to all upper case tests \" + Arrays.toString(params));\n+            });\n+\n+            System.out.println(\"Starting all the threads\");\n+            final List<Future<Void>> res = executorService.invokeAll(testsCallables);\n+            for (final Future<Void> future : res) {\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This is used for the test logic itself\n+     *\/\n@@ -98,0 +309,1 @@\n+\n","filename":"test\/jdk\/sun\/security\/util\/Debug\/DebugOptions.java","additions":255,"deletions":43,"binary":false,"changes":298,"status":"modified"}]}