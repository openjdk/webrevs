{"files":[{"patch":"@@ -278,0 +278,20 @@\n+HeapWord* ParallelScavengeHeap::mem_allocate_cas_noexpand(size_t size, bool is_tlab) {\n+  \/\/ Try young-gen first.\n+  HeapWord* result = young_gen()->allocate(size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+\n+  \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+  if (!is_tlab) {\n+    if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+      result = old_gen()->cas_allocate_noexpand(size);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -280,2 +300,1 @@\n-    \/\/ Try young-gen first.\n-    HeapWord* result = young_gen()->allocate(size);\n+    HeapWord* result = mem_allocate_cas_noexpand(size, is_tlab);\n@@ -286,21 +305,2 @@\n-    \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n-    if (!is_tlab) {\n-      if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n-        result = old_gen()->cas_allocate_noexpand(size);\n-        if (result != nullptr) {\n-          return result;\n-        }\n-      }\n-    }\n-\n-    \/\/ We don't want to have multiple collections for a single filled generation.\n-    \/\/ To prevent this, each thread tracks the total_collections() value, and if\n-    \/\/ the count has changed, does not do a new collection.\n-    \/\/\n-    \/\/ The collection count must be read only while holding the heap lock. VM\n-    \/\/ operations also hold the heap lock during collections. There is a lock\n-    \/\/ contention case where thread A blocks waiting on the Heap_lock, while\n-    \/\/ thread B is holding it doing a collection. When thread A gets the lock,\n-    \/\/ the collection count has already changed. To prevent duplicate collections,\n-    \/\/ The policy MUST attempt allocations during the same period it reads the\n-    \/\/ total_collections() value!\n+    \/\/ Read total_collections() under the lock so that multiple\n+    \/\/ allocation-failures result in one GC.\n@@ -310,0 +310,8 @@\n+\n+      \/\/ Re-try after acquiring the lock, because a GC might have occurred\n+      \/\/ while waiting for this lock.\n+      result = mem_allocate_cas_noexpand(size, is_tlab);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  HeapWord* mem_allocate_cas_noexpand(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}