{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,7 +144,1 @@\n-vmTestbase\/vm\/mlvm\/meth\/func\/java\/throwException\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/deoptimize\/Test.java#id1 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/gc\/callSequencesDuringGC\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/java\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8058176 generic-all\n+vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8257761 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.management.MemoryUsage;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.ManagementFactory;\n@@ -32,0 +35,2 @@\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n@@ -66,0 +71,19 @@\n+    private static final Optional<MemoryPoolMXBean> NON_SEGMENTED_CODE_CACHE_POOL;\n+    private static final Optional<MemoryPoolMXBean> NON_NMETHODS_POOL;\n+    private static final Optional<MemoryPoolMXBean> PROFILED_NMETHODS_POOL;\n+    private static final Optional<MemoryPoolMXBean> NON_PROFILED_NMETHODS_POOL ;\n+    private static final int NON_SEGMENTED_CACHE_ALLOWANCE = 2_000_000;\n+    private static final int SEGMENTED_CACHE_ALLOWANCE = 1_000_000;\n+\n+    static {\n+        var pools = ManagementFactory.getMemoryPoolMXBeans();\n+        NON_SEGMENTED_CODE_CACHE_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeCache\")).findFirst();\n+        NON_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-nmethods'\")).findFirst();\n+        PROFILED_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'profiled nmethods'\")).findFirst();\n+        NON_PROFILED_NMETHODS_POOL = pools.stream()\n+            .filter(pool -> pool.getName().equals(\"CodeHeap 'non-profiled nmethods'\")).findFirst();\n+    }\n+\n@@ -70,0 +94,17 @@\n+    private static final boolean isCodeCacheEffectivelyFull() {\n+        var result = new Object() { boolean value = false; };\n+\n+        BiConsumer<MemoryPoolMXBean, Integer> check = (pool, limit) -> {\n+            var usage = pool.getUsage();\n+            result.value |= usage.getMax() - usage.getUsed() < limit;\n+        };\n+\n+        \/\/ Limit numbers are arbitrary, feel free to change if arguably necessary\n+        NON_SEGMENTED_CODE_CACHE_POOL.ifPresent(pool -> check.accept(pool, NON_SEGMENTED_CACHE_ALLOWANCE));\n+        NON_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+        PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+        NON_PROFILED_NMETHODS_POOL.ifPresent(pool -> check.accept(pool, SEGMENTED_CACHE_ALLOWANCE));\n+\n+        return result.value;\n+    }\n+\n@@ -90,1 +131,8 @@\n-        for ( int i = nextInt(MAX_CYCLES); i > 0; i-- ) {\n+        final int cyclesToBuild = nextInt(MAX_CYCLES);\n+        for ( int i = 0; i < cyclesToBuild; i++) {\n+            if (isCodeCacheEffectivelyFull()) {\n+                Env.traceNormal(\"Not enought code cache to build up MH sequences anymore. \" +\n+                        \" Has only been able to achieve \" + i + \" out of \" + cyclesToBuild);\n+                break;\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/share\/MHTransformationGen.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"}]}