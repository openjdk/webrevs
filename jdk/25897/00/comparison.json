{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,0 +207,2 @@\n+        openClipboard(null);\n+\n@@ -208,1 +210,0 @@\n-            openClipboard(null);\n@@ -321,6 +322,1 @@\n-        try {\n-            openClipboard(null);\n-            return getClipboardFormats();\n-        } finally {\n-            closeClipboard();\n-        }\n+        return getClipboardFormats();\n@@ -359,9 +355,1 @@\n-            long[] currentFormats = null;\n-            try {\n-                openClipboard(null);\n-                currentFormats = getClipboardFormats();\n-            } catch (final IllegalStateException ignored) {\n-            } finally {\n-                closeClipboard();\n-            }\n-            this.currentFormats = currentFormats;\n+            this.currentFormats = getClipboardFormats();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/SunClipboard.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.System.Logger.Level;\n@@ -33,0 +34,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -54,0 +56,2 @@\n+    private final ReentrantLock clipboardLocked = new ReentrantLock();\n+\n@@ -56,0 +60,2 @@\n+        \/\/ Register java side of the clipboard with the native side\n+        registerClipboard();\n@@ -107,1 +113,2 @@\n-     * we also call EmptyClipboard and take ownership.\n+     * we also call EmptyClipboard and take ownership. If this method call\n+     * succeeds, it must be followed by a call to {@link #closeClipboard()}.\n@@ -112,1 +119,12 @@\n-    public native void openClipboard(SunClipboard newOwner) throws IllegalStateException;\n+    public void openClipboard(SunClipboard newOwner) throws IllegalStateException {\n+        if (!clipboardLocked.tryLock()) {\n+            throw new IllegalStateException(\"Failed to acquire clipboard lock\");\n+        }\n+        try {\n+            openClipboard0(newOwner);\n+        } catch (IllegalStateException ex) {\n+            clipboardLocked.unlock();\n+            throw ex;\n+        }\n+    }\n+\n@@ -118,1 +136,13 @@\n-    public native void closeClipboard();\n+    public void closeClipboard() {\n+        if (clipboardLocked.isLocked()) {\n+            try {\n+                closeClipboard0();\n+            } finally {\n+                clipboardLocked.unlock();\n+            }\n+        }\n+    }\n+\n+    private native void openClipboard0(SunClipboard newOwner) throws IllegalStateException;\n+    private native void closeClipboard0();\n+\n@@ -160,1 +190,0 @@\n-        long[] formats = null;\n@@ -162,6 +191,4 @@\n-            openClipboard(null);\n-            formats = getClipboardFormats();\n-        } catch (IllegalStateException exc) {\n-            \/\/ do nothing to handle the exception, call checkChange(null)\n-        } finally {\n-            closeClipboard();\n+            long[] formats = getClipboardFormats();\n+            checkChange(formats);\n+        } catch (Throwable ex) {\n+            System.getLogger(WClipboard.class.getName()).log(Level.DEBUG, \"Failed to process handleContentsChanged\", ex);\n@@ -169,1 +196,0 @@\n-        checkChange(formats);\n@@ -217,0 +243,2 @@\n+\n+    private native void registerClipboard();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WClipboard.java","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,3 +72,2 @@\n-    if (theCurrentClipboard == NULL) {\n-        theCurrentClipboard = env->NewGlobalRef(jclipboard);\n-    }\n+    DASSERT(AwtClipboard::theCurrentClipboard != NULL);\n+    DASSERT(env->IsSameObject(AwtClipboard::theCurrentClipboard, jclipboard));\n@@ -131,1 +130,1 @@\n-Java_sun_awt_windows_WClipboard_openClipboard(JNIEnv *env, jobject self,\n+Java_sun_awt_windows_WClipboard_openClipboard0(JNIEnv *env, jobject self,\n@@ -136,0 +135,2 @@\n+    DASSERT(AwtClipboard::theCurrentClipboard != NULL);\n+    DASSERT(newOwner == NULL || env->IsSameObject(AwtClipboard::theCurrentClipboard, newOwner));\n@@ -145,4 +146,0 @@\n-        if (AwtClipboard::theCurrentClipboard != NULL) {\n-            env->DeleteGlobalRef(AwtClipboard::theCurrentClipboard);\n-        }\n-        AwtClipboard::theCurrentClipboard = env->NewGlobalRef(newOwner);\n@@ -160,1 +157,1 @@\n-Java_sun_awt_windows_WClipboard_closeClipboard(JNIEnv *env, jobject self)\n+Java_sun_awt_windows_WClipboard_closeClipboard0(JNIEnv *env, jobject self)\n@@ -300,1 +297,3 @@\n-    DASSERT(::GetOpenClipboardWindow() == AwtToolkit::GetInstance().GetHWnd());\n+    unsigned int cFormats = 128; \/\/ Allocate enough space to hold all\n+    unsigned int pcFormatsOut = 0;\n+    unsigned int lpuiFormats[128] = { 0 };\n@@ -302,2 +301,3 @@\n-    jsize nFormats = ::CountClipboardFormats();\n-    jlongArray formats = env->NewLongArray(nFormats);\n+    VERIFY(::GetUpdatedClipboardFormats(lpuiFormats, 128, &pcFormatsOut));\n+\n+    jlongArray formats = env->NewLongArray(pcFormatsOut);\n@@ -307,1 +307,1 @@\n-    if (nFormats == 0) {\n+    if (pcFormatsOut == 0) {\n@@ -313,1 +313,0 @@\n-    UINT num = 0;\n@@ -315,2 +314,2 @@\n-    for (jsize i = 0; i < nFormats; i++, lFormats++) {\n-        *lFormats = num = ::EnumClipboardFormats(num);\n+    for (unsigned int i = 0; i < pcFormatsOut; i++, lFormats++) {\n+        *lFormats = lpuiFormats[i];\n@@ -481,0 +480,12 @@\n+\/*\n+ * Class:     sun_awt_windows_WClipboard\n+ * Method:    registerClipboard\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_awt_windows_WClipboard_registerClipboard(JNIEnv *env, jobject self)\n+{\n+    DASSERT(AwtClipboard::theCurrentClipboard == NULL);\n+    AwtClipboard::theCurrentClipboard = env->NewGlobalRef(self);\n+}\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.cpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+  @test\n+  @bug 8332271\n+  @summary tests that concurrent access to the clipboard does not crash the JVM\n+  @key headful\n+  @requires (os.family == \"windows\")\n+  @run main ConcurrentClipboardAccessTest\n+ *\/\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+\n+public class ConcurrentClipboardAccessTest {\n+\n+    public static void main(String[] args) {\n+        Thread clipboardLoader1 = new Thread(new ClipboardLoader());\n+        clipboardLoader1.setDaemon(true);\n+        clipboardLoader1.start();\n+        Thread clipboardLoader2 = new Thread(new ClipboardLoader());\n+        clipboardLoader2.setDaemon(true);\n+        clipboardLoader2.start();\n+        long start = System.currentTimeMillis();\n+        while (true) {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException ignored) {\n+            }\n+            long now = System.currentTimeMillis();\n+            if ((now - start) > (10L * 1000L)) {\n+                break;\n+            }\n+        }\n+        \/\/ Test is considered successful if the concurrent repeated reading\n+        \/\/ from clipboard succeeds for the allotted time and the JVM does not\n+        \/\/ crash.\n+        System.out.println(\"Shutdown normally\");\n+    }\n+\n+    public static class ClipboardLoader implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            final Clipboard systemClipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+            while (true) {\n+                try {\n+                    if (systemClipboard.isDataFlavorAvailable(DataFlavor.stringFlavor)) {\n+                        systemClipboard.getData(DataFlavor.stringFlavor);\n+                    }\n+                } catch (Exception ignored) {\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/ConcurrentClipboardAccessTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}