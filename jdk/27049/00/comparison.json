{"files":[{"patch":"@@ -348,1 +348,1 @@\n-                List<String> doc;\n+                List<AttributedString> doc;\n@@ -352,1 +352,4 @@\n-                    doc = repl.commandDocumentation(text, cursor, true);\n+                    doc = repl.commandDocumentation(text, cursor, true)\n+                              .stream()\n+                              .map(AttributedString::new)\n+                              .toList();\n@@ -359,1 +362,1 @@\n-                                       .map(Documentation::signature)\n+                                       .map(this::renderSignature)\n@@ -505,0 +508,35 @@\n+    private AttributedString renderSignature(Documentation doc) {\n+        int activeParamIndex = doc.activeParameterIndex();\n+        String signature = doc.signature();\n+\n+        if (activeParamIndex == (-1)) {\n+            return new AttributedString(signature);\n+        }\n+\n+        int lparen = signature.indexOf('(');\n+        int rparen = signature.indexOf(')', lparen);\n+\n+        if (lparen == (-1) || rparen == (-1)) {\n+            return new AttributedString(signature);\n+        }\n+\n+        AttributedStringBuilder result = new AttributedStringBuilder();\n+\n+        result.append(signature.substring(0, lparen + 1), AttributedStyle.DEFAULT);\n+\n+        String[] params = signature.substring(lparen + 1, rparen).split(\", *\");\n+        String sep = \"\";\n+\n+        for (int i = 0; i < params.length; i++) {\n+            result.append(sep);\n+            result.append(params[i], i == activeParamIndex ? AttributedStyle.BOLD\n+                                                           : AttributedStyle.DEFAULT);\n+\n+            sep = \", \";\n+        }\n+\n+        result.append(signature.substring(rparen), AttributedStyle.DEFAULT);\n+\n+        return result.toAttributedString();\n+    }\n+\n@@ -725,1 +763,1 @@\n-        private final List<String> synopsis;\n+        private final List<AttributedString> synopsis;\n@@ -727,1 +765,1 @@\n-        public CommandSynopsisTask(List<String> synposis) {\n+        public CommandSynopsisTask(List<AttributedString> synposis) {\n@@ -741,0 +779,1 @@\n+                                   .map(doc -> doc.toAnsi(in.getTerminal()))\n@@ -774,1 +813,1 @@\n-        private final List<String> doc;\n+        private final List<AttributedString> doc;\n@@ -776,1 +815,1 @@\n-        public ExpressionSignaturesTask(List<String> doc) {\n+        public ExpressionSignaturesTask(List<AttributedString> doc) {\n@@ -789,1 +828,3 @@\n-            in.getTerminal().writer().println(doc.stream().collect(Collectors.joining(LINE_SEPARATOR)));\n+            in.getTerminal().writer().println(doc.stream()\n+                                                 .map(doc -> doc.toAnsi(in.getTerminal()))\n+                                                 .collect(Collectors.joining(LINE_SEPARATOR)));\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-            return new OnDemandJavadocHelper(mainTask, fm);\n+            return new OnDemandJavadocHelper(mainTask, fm, sourceLocations);\n@@ -138,0 +138,15 @@\n+\n+                @Override\n+                public String getResolvedDocComment(StoredElement forElement) throws IOException {\n+                    return null;\n+                }\n+\n+                @Override\n+                public StoredElement getHandle(Element forElement) {\n+                    return null;\n+                }\n+\n+                @Override\n+                public Collection<? extends Path> getSourceLocations() {\n+                    return List.of();\n+                }\n@@ -150,0 +165,1 @@\n+    public abstract String getResolvedDocComment(StoredElement forElement) throws IOException;\n@@ -161,0 +177,3 @@\n+    public abstract StoredElement getHandle(Element forElement);\n+    public abstract Collection<? extends Path> getSourceLocations();\n+\n@@ -168,0 +187,2 @@\n+    public record StoredElement(String module, String binaryName, String handle) {}\n+\n@@ -173,0 +194,1 @@\n+        private final Collection<? extends Path> sourceLocations;\n@@ -174,1 +196,1 @@\n-        private OnDemandJavadocHelper(JavacTask mainTask, StandardJavaFileManager fm) {\n+        private OnDemandJavadocHelper(JavacTask mainTask, StandardJavaFileManager fm, Collection<? extends Path> sourceLocations) {\n@@ -178,0 +200,1 @@\n+            this.sourceLocations = sourceLocations;\n@@ -190,0 +213,10 @@\n+        @Override\n+        public String getResolvedDocComment(StoredElement forElement) throws IOException {\n+            Pair<JavacTask, TreePath> sourceElement = getSourceElement(forElement);\n+\n+            if (sourceElement == null)\n+                return null;\n+\n+            return getResolvedDocComment(sourceElement.fst, sourceElement.snd);\n+        }\n+\n@@ -205,1 +238,24 @@\n-        private String getResolvedDocComment(JavacTask task, TreePath el) throws IOException {\n+        @Override\n+        public StoredElement getHandle(Element forElement) {\n+            TypeElement type = topLevelType(forElement);\n+\n+            if (type == null)\n+                return null;\n+\n+            Elements elements = mainTask.getElements();\n+            ModuleElement module = elements.getModuleOf(type);\n+            String moduleName = module == null || module.isUnnamed()\n+                    ? null\n+                    : module.getQualifiedName().toString();\n+            String binaryName = elements.getBinaryName(type).toString();\n+            String handle = elementSignature(forElement);\n+\n+            return new StoredElement(moduleName, binaryName, handle);\n+        }\n+\n+        @Override\n+        public Collection<? extends Path> getSourceLocations() {\n+            return sourceLocations;\n+        }\n+\n+         private String getResolvedDocComment(JavacTask task, TreePath el) throws IOException {\n@@ -637,1 +693,1 @@\n-        \/* Find types from which methods in type may inherit javadoc, in the proper order.*\/\n+        \/* Find types from which methods in binaryName may inherit javadoc, in the proper order.*\/\n@@ -704,0 +760,29 @@\n+        private Pair<JavacTask, TreePath> getSourceElement(StoredElement el) throws IOException {\n+            if (el == null) {\n+                return null;\n+            }\n+\n+            String handle = el.handle();\n+            Pair<JavacTask, TreePath> cached = signature2Source.get(handle);\n+\n+            if (cached != null) {\n+                return cached.fst != null ? cached : null;\n+            }\n+\n+            Pair<JavacTask, CompilationUnitTree> source = findSource(el.module(), el.binaryName());\n+\n+            if (source == null)\n+                return null;\n+\n+            fillElementCache(source.fst, source.snd);\n+\n+            cached = signature2Source.get(handle);\n+\n+            if (cached != null) {\n+                return cached;\n+            } else {\n+                signature2Source.put(handle, Pair.of(null, null));\n+                return null;\n+            }\n+        }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","additions":89,"deletions":4,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+import java.util.function.Supplier;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n@@ -67,0 +73,12 @@\n+    \/**\n+     * Compute possible follow-ups for the given input.\n+     * Uses information from the current {@code JShell} state, including\n+     * type information, to filter the suggestions.\n+     * @param input the user input, so far\n+     * @param cursor the current position of the cursors in the given {@code input} text\n+     * @param convertor convert the given {@linkplain ElementSuggestion} to a custom completion suggestions.\n+     * @return list of candidate continuations of the given input.\n+     * @since 26\n+     *\/\n+    public abstract <S> List<S> completionSuggestions(String input, int cursor, ElementSuggestionConvertor<S> convertor);\n+\n@@ -318,0 +336,129 @@\n+    \/**\n+     * A description of an {@linkplain Element} that is a possible continuation of\n+     * a given snippet.\n+     *\n+     * @apiNote Instances of this interface and instances of the returned {@linkplain Elements}\n+     * should only be used and held during the execution of the\n+     * {@link #completionSuggestions(java.lang.String, int, jdk.jshell.SourceCodeAnalysis.ElementSuggestionConvertor) }\n+     * method. Their use outside of the context of the method is not supported and\n+     * the effect is undefined.\n+     *\n+     * @since 26\n+     *\/\n+    public sealed interface ElementSuggestion permits SourceCodeAnalysisImpl.ElementSuggestionImpl {\n+        \/**\n+         * {@return a possible continuation {@linkplain Element}, or {@code null}\n+         *  if this item does not represent an {@linkplain Element}.}\n+         *\/\n+        Element element();\n+        \/**\n+         * {@return a possible continuation keyword, or {@code null}\n+         *  if this item does not represent a keyword.}\n+         *\/\n+        String keyword();\n+        \/**\n+         * {@return {@code true} if this {@linkplain Element}'s type fits into\n+         *  the context.}\n+         *\n+         * Typically used when the type of the element fits the expected type.\n+         *\/\n+        boolean matchesType();\n+        \/**\n+         * {@return the offset in the original snippet at which point this {@linkplain Element}\n+         *  should be inserted.}\n+         *\/\n+        int anchor();\n+        \/**\n+         * {@return a {@linkplain Supplier} for the javadoc documentation for this Element.}\n+         *\n+         * @apiNote The instance returned from this method is safe to hold for extended\n+         * periods of time, and can be called outside of the context of the\n+         * {@link #completionSuggestions(java.lang.String, int, jdk.jshell.SourceCodeAnalysis.ElementSuggestionConvertor) } method.\n+         *\/\n+        Supplier<String> documentation();\n+    }\n+\n+    \/**\n+     * Permit access to completion state.\n+     *\n+     * @since 26\n+     *\/\n+    public sealed interface CompletionState permits SourceCodeAnalysisImpl.CompletionStateImpl {\n+        \/**\n+         * {@return true if the given element is available using the simple name at\n+         *  the place of the cursor.}\n+         *\n+         * @param el {@linkplain Element} to check\n+         *\/\n+        public boolean availableUsingSimpleName(Element el);\n+        \/**\n+         * {@return flags describing the overall completion context.}\n+         *\/\n+        public Set<CompletionContext> completionContext();\n+        \/**\n+         * {@return if the context is a qualified expression\n+         * (i.e. {@link CompletionContext#QUALIFIED} is set),\n+         * the type of the selector expression; {@code null} otherwise.}\n+         *\/\n+        public TypeMirror selectorType();\n+        \/**\n+         * {@return an implementation of some utility methods for\n+         * operating on elements}\n+         *\/\n+        Elements elementUtils();\n+        \/**\n+         * {@return an implementation of some utility methods for\n+         * operating on types}\n+         *\/\n+        Types typeUtils();\n+    }\n+\n+    \/**\n+     * Various flags describing the context in which the completion happens.\n+     *\n+     * @since 26\n+     *\/\n+    public enum CompletionContext {\n+        \/**\n+         * The context is inside annotation attributes.\n+         *\/\n+        ANNOTATION_ATTRIBUTE,\n+        \/**\n+         * Parentheses should not be filled for methods and constructor\n+         * in the current context.\n+         *\n+         * Typically used in the import or method reference contexts.\n+         *\/\n+        NO_PAREN,\n+        \/**\n+         * Interpret {@link ElementKind#ANNOTATION_TYPE}s as annotation uses. Typically means\n+         * they should be prefixed with {@code @}.\n+         *\/\n+        TYPES_AS_ANNOTATIONS,\n+        \/**\n+         * The context is in a qualified expression (like member access). Simple\n+         * names only should be used.\n+         *\/\n+        QUALIFIED,\n+        ;\n+    }\n+\n+    \/**\n+     * A convertor from a list of {@linkplain ElementSuggestion} to a list\n+     * of custom target completion items.\n+     *\n+     * @param <S> a custom target completion type.\n+     * @since 26\n+     *\/\n+    public interface ElementSuggestionConvertor<S> {\n+        \/**\n+         * Convert a list of {@linkplain ElementSuggestion} to a list\n+         * of custom completion items.\n+         *\n+         * @param state the state of the completion\n+         * @param suggestions the input suggestions\n+         * @return the converted suggestions\n+         *\/\n+        public List<S> convert(CompletionState state, List<? extends ElementSuggestion> suggestions);\n+    }\n+\n@@ -336,0 +483,12 @@\n+\n+        \/**\n+         * If this {@code Documentation} is created for a method invocation,\n+         * return the current parameter index.\n+         *\n+         * @implNote the default implementation returns {@code -1}\n+         * @return the active parameter index, or {@code -1} if not available\n+         * @since 26\n+         *\/\n+        default int activeParameterIndex() {\n+            return -1;\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysis.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+import java.util.concurrent.Callable;\n@@ -122,0 +123,1 @@\n+import java.util.function.Supplier;\n@@ -155,0 +157,3 @@\n+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;\n+import static javax.lang.model.element.ElementKind.MODULE;\n+import static javax.lang.model.element.ElementKind.PACKAGE;\n@@ -157,0 +162,2 @@\n+import javax.lang.model.util.Elements;\n+import jdk.internal.shellsupport.doc.JavadocHelper.StoredElement;\n@@ -281,1 +288,51 @@\n-        suspendIndexing();\n+        ElementSuggestionConvertor<Suggestion> convertor = (state, suggestions) -> {\n+            Set<String> haveParams = suggestions.stream()\n+                    .map(s -> s.element())\n+                    .filter(el -> el != null)\n+                    .filter(IS_CONSTRUCTOR.or(IS_METHOD))\n+                    .filter(c -> !((ExecutableElement)c).getParameters().isEmpty())\n+                    .map(this::simpleContinuationName)\n+                    .collect(toSet());\n+            List<Suggestion> result = new ArrayList<>();\n+\n+            for (ElementSuggestion s : suggestions) {\n+                Element el = s.element();\n+                if (el != null) {\n+                    String continuation = continuationName(state, el);\n+\n+                    switch (el.getKind()) {\n+                        case CONSTRUCTOR, METHOD -> {\n+                            if (state.completionContext().contains(CompletionContext.ANNOTATION_ATTRIBUTE)) {\n+                                continuation += \" = \";\n+                            } else if (!state.completionContext().contains(CompletionContext.NO_PAREN)) {\n+                                \/\/ add trailing open or matched parenthesis, as approriate:\n+                                continuation += haveParams.contains(continuation) ? \"(\" : \"()\";\n+                            }\n+                        }\n+                        case ANNOTATION_TYPE -> {\n+                            if (state.completionContext().contains(CompletionContext.TYPES_AS_ANNOTATIONS)) {\n+                                boolean hasAnyAttributes =\n+                                        ElementFilter.methodsIn(el.getEnclosedElements())\n+                                                     .stream()\n+                                                     .anyMatch(attribute -> attribute.getParameters().isEmpty());\n+                                String paren = hasAnyAttributes ? \"(\" : \"\";\n+                                continuation = \"@\" + continuation + paren;\n+                            }\n+                        }\n+                        case PACKAGE ->\n+                            \/\/ add trailing dot to package names\n+                            continuation += \".\";\n+                    }\n+\n+                    result.add(new SuggestionImpl(continuation, s.matchesType()));\n+                } else if (s.keyword() != null) {\n+                    result.add(new SuggestionImpl(s.keyword(), s.matchesType()));\n+                }\n+\n+                anchor[0] = s.anchor();\n+            }\n+\n+            Collections.sort(result, Comparator.comparing(Suggestion::continuation));\n+\n+            return result;\n+        };\n@@ -283,1 +340,1 @@\n-            return completionSuggestionsImpl(code, cursor, anchor);\n+            return completionSuggestions(code, cursor, convertor);\n@@ -287,0 +344,8 @@\n+        }\n+    }\n+\n+    @Override\n+    public <Suggestion> List<Suggestion> completionSuggestions(String code, int cursor, ElementSuggestionConvertor<Suggestion> convertor) {\n+        suspendIndexing();\n+        try {\n+            return completionSuggestionsImpl(code, cursor, convertor);\n@@ -292,1 +357,1 @@\n-    private List<Suggestion> completionSuggestionsImpl(String code, int cursor, int[] anchor) {\n+    private <Suggestion> List<Suggestion> completionSuggestionsImpl(String code, int cursor, ElementSuggestionConvertor<Suggestion> suggestionConvertor) {\n@@ -305,5 +370,1 @@\n-        String[] requiredPrefix = new String[] {identifier};\n-        return computeSuggestions(codeWrap, code, cursor, requiredPrefix, anchor).stream()\n-                .filter(s -> filteringText(s).startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n-                .sorted(Comparator.comparing(Suggestion::continuation))\n-                .toList();\n+        return computeSuggestions(codeWrap, code, cursor, identifier, suggestionConvertor);\n@@ -312,5 +373,1 @@\n-    private static String filteringText(Suggestion suggestion) {\n-        return suggestion instanceof SuggestionImpl impl\n-                ? impl.filteringText\n-                : suggestion.continuation();\n-    }\n+    private static List<String> COMPLETION_EXTRA_PARAMETERS = List.of(\"-parameters\");\n@@ -318,2 +375,3 @@\n-    private List<Suggestion> computeSuggestions(OuterWrap code, String inputCode, int cursor, String[] requiredPrefix, int[] anchor) {\n-        return proc.taskFactory.analyze(code, at -> {\n+    private <Suggestion> List<Suggestion> computeSuggestions(OuterWrap code, String inputCode, int cursor, String prefix, ElementSuggestionConvertor<Suggestion> suggestionConvertor) {\n+        return proc.taskFactory.analyze(code, COMPLETION_EXTRA_PARAMETERS, at -> {\n+            try (JavadocHelper javadoc = JavadocHelper.create(at.task, findSources())) {\n@@ -322,1 +380,0 @@\n-            List<Suggestion> result = new ArrayList<>();\n@@ -325,0 +382,1 @@\n+                List<ElementSuggestion> result = new ArrayList<>();\n@@ -326,0 +384,2 @@\n+                Collection<? extends Element> scopeContent = scopeContent(at, scope, IDENTITY);\n+                Set<CompletionContext> completionContext = EnumSet.noneOf(CompletionContext.class);\n@@ -330,0 +390,1 @@\n+                TypeMirror selectorType = null;\n@@ -389,0 +450,2 @@\n+                        completionContext.add(CompletionContext.QUALIFIED);\n+\n@@ -391,1 +454,0 @@\n-                        Function<Boolean, String> paren;\n@@ -396,1 +458,0 @@\n-                            paren = DEFAULT_PAREN;\n@@ -401,1 +462,1 @@\n-                            paren = NO_PAREN;\n+                            completionContext.add(CompletionContext.NO_PAREN);\n@@ -406,1 +467,1 @@\n-                        TypeMirror site = at.trees().getTypeMirror(exprPath);\n+                        selectorType = at.trees().getTypeMirror(exprPath);\n@@ -416,1 +477,1 @@\n-                            addModuleElements(at, qualifiedPrefix, result);\n+                            addModuleElements(at, javadoc, selectStart, qualifiedPrefix + prefix, result);\n@@ -418,4 +479,1 @@\n-                            requiredPrefix[0] = qualifiedPrefix + requiredPrefix[0];\n-                            anchor[0] = selectStart;\n-\n-                            return result;\n+                            break;\n@@ -426,1 +484,1 @@\n-                        List<? extends Element> members = membersOf(at, site, staticOnly && !isImport && tp.getLeaf().getKind() == Kind.MEMBER_SELECT);\n+                        List<? extends Element> members = membersOf(at, selectorType, staticOnly && !isImport && tp.getLeaf().getKind() == Kind.MEMBER_SELECT);\n@@ -437,1 +495,1 @@\n-                            addElements(membersOf(at, members), constructorFilter, smartFilter, result);\n+                            addElements(javadoc, membersOf(at, members), constructorFilter, smartFilter, cursor, prefix, result);\n@@ -445,1 +503,1 @@\n-                            paren = NO_PAREN;\n+                            completionContext.add(CompletionContext.NO_PAREN);\n@@ -455,1 +513,1 @@\n-                        addElements(members, filter, smartFilter, paren, result);\n+                        addElements(javadoc, members, filter, smartFilter, cursor, prefix, result);\n@@ -469,1 +527,1 @@\n-                                addElements(membersOf(at, membersOf(at, site, false)), filter, smartFilter, result);\n+                                addElements(javadoc, membersOf(at, membersOf(at, site, false)), filter, smartFilter, cursor, prefix, result);\n@@ -471,1 +529,1 @@\n-                                addScopeElements(at, scope, listEnclosed, filter, smartFilter, result);\n+                                addScopeElements(at, javadoc, scope, listEnclosed, filter, smartFilter, cursor, prefix, result);\n@@ -478,1 +536,1 @@\n-                            addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);\n+                            addElements(javadoc, scopeContent, accept, IS_PACKAGE.negate().and(smartTypeFilter), cursor, prefix, result);\n@@ -482,0 +540,2 @@\n+                            completionContext.add(CompletionContext.TYPES_AS_ANNOTATIONS);\n+\n@@ -484,3 +544,9 @@\n-                                result = completionSuggestionsImpl(inputCode, cursor - 1, anchor);\n-                                requiredPrefix[0] = \"@\" + requiredPrefix[0];\n-                                return result;\n+                                return completionSuggestionsImpl(inputCode, cursor - 1, (state, items) -> {\n+                                    CompletionState newState = new CompletionStateImpl(((CompletionStateImpl) state).scopeContent, completionContext, state.selectorType(), state.elementUtils(), state.typeUtils());\n+                                    return suggestionConvertor.convert(newState,\n+                                                                       items.stream()\n+                                                                            .filter(s -> s.element().getKind() == ElementKind.ANNOTATION_TYPE)\n+                                                                            .filter(s -> s.element().getSimpleName().toString().startsWith(prefix))\n+                                                                            .map(s -> new ElementSuggestionImpl(s.element(), s.keyword(), s.matchesType(), s.anchor(), s.documentation()))\n+                                                                            .<ElementSuggestion>toList());\n+                                });\n@@ -491,1 +557,1 @@\n-                            addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);\n+                            addElements(javadoc, scopeContent, accept, IS_PACKAGE.negate().and(smartTypeFilter), cursor - 1, prefix, result);\n@@ -497,1 +563,1 @@\n-                                addModuleElements(at, \"\", result);\n+                                addModuleElements(at, javadoc, cursor, prefix, result);\n@@ -506,1 +572,1 @@\n-                                addElements(listPackages(at, \"\"),\n+                                addElements(javadoc, listPackages(at, \"\"),\n@@ -510,1 +576,1 @@\n-                                        smartFilter, result);\n+                                        smartFilter, cursor, prefix, result);\n@@ -512,1 +578,1 @@\n-                                result.add(new SuggestionImpl(\"module \", false));\n+                                result.add(new ElementSuggestionImpl(null, \"module \", false, cursor, () -> null)); \/\/TODO: better javadoc?\n@@ -518,2 +584,2 @@\n-                        addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);\n-                        addElements(primitivesOrVoid(at), TRUE, smartFilter, result);\n+                        addElements(javadoc, scopeContent, accept, smartFilter, cursor, prefix, result);\n+                        addElements(javadoc, primitivesOrVoid(at), TRUE, smartFilter, cursor, prefix, result);\n@@ -556,0 +622,2 @@\n+                            completionContext.add(CompletionContext.ANNOTATION_ATTRIBUTE);\n+\n@@ -566,1 +634,1 @@\n-                            addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), el -> !present.contains(el.getSimpleName().toString()), TRUE, _ -> \" = \", result);\n+                            addElements(javadoc, ElementFilter.methodsIn(annotationType.getEnclosedElements()), el -> !present.contains(el.getSimpleName().toString()), TRUE, cursor, prefix, \/*_ -> \" = \", *\/result);\n@@ -569,0 +637,2 @@\n+                            completionContext.add(CompletionContext.ANNOTATION_ATTRIBUTE);\n+\n@@ -574,1 +644,2 @@\n-                                addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), TRUE, TRUE, _ -> \" = \", result);\n+                                \/\/TODO: filter out existing:\n+                                addElements(javadoc, ElementFilter.methodsIn(annotationType.getEnclosedElements()), TRUE, TRUE, cursor, prefix, result);\n@@ -591,9 +662,3 @@\n-                                    boolean hasAnyAttributes =\n-                                            ElementFilter.methodsIn(attributeTypeEl.getEnclosedElements())\n-                                                         .stream()\n-                                                         .anyMatch(attribute -> attribute.getParameters().isEmpty());\n-                                    String paren = hasAnyAttributes ? \"(\" : \"\";\n-                                    String name = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n-                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n-                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n-                                    result.add(new SuggestionImpl(\"@\" + name + paren, true));\n+                                    completionContext.add(CompletionContext.TYPES_AS_ANNOTATIONS);\n+\n+                                    addElements(javadoc, List.of(attributeTypeEl), TRUE, TRUE, cursor, prefix, result);\n@@ -602,12 +667,7 @@\n-                                    String typeName = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n-                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n-                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n-                                    result.add(new SuggestionImpl(typeName, true));\n-                                    result.addAll(ElementFilter.fieldsIn(attributeTypeEl.getEnclosedElements())\n-                                                               .stream()\n-                                                               .filter(e -> e.getKind() == ElementKind.ENUM_CONSTANT)\n-                                                               .map(c -> new SuggestionImpl(scopeContent(at, scope, IDENTITY).contains(c)\n-                                                                       ? c.getSimpleName().toString()\n-                                                                       : typeName + \".\" + c.getSimpleName(), c.getSimpleName().toString(),\n-                                                                       true))\n-                                                               .toList());\n+                                    List<Element> elements = new ArrayList<>();\n+                                    elements.add(attributeTypeEl);\n+                                    ElementFilter.fieldsIn(attributeTypeEl.getEnclosedElements())\n+                                                 .stream()\n+                                                 .filter(e -> e.getKind() == ElementKind.ENUM_CONSTANT)\n+                                                 .forEach(elements::add);\n+                                    addElements(javadoc, elements, TRUE, TRUE, cursor, prefix, result);\n@@ -628,1 +688,1 @@\n-                        addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);\n+                        addElements(javadoc, scopeContent, accept, smartFilter, cursor, prefix, result);\n@@ -640,1 +700,1 @@\n-                            addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                            addElements(javadoc, primitivesOrVoid(at), accept, smartFilter, cursor, prefix, result);\n@@ -647,2 +707,5 @@\n-                            result.add(new SuggestionImpl(\"true\", true));\n-                            result.add(new SuggestionImpl(\"false\", true));\n+                            for (String booleanKeyword : new String[] {\"false\", \"true\"}) {\n+                                if (booleanKeyword.startsWith(prefix)) {\n+                                    result.add(new ElementSuggestionImpl(null, booleanKeyword, true, cursor, () -> null));\n+                                }\n+                            }\n@@ -653,0 +716,4 @@\n+\n+                CompletionState completionState = new CompletionStateImpl(scopeContent, completionContext, selectorType, at.getElements(), at.getTypes());\n+\n+                return suggestionConvertor.convert(completionState, result);\n@@ -654,2 +721,5 @@\n-            anchor[0] = cursor;\n-            return result;\n+            } catch (IOException ex) {\n+                \/\/TODO:\n+                ex.printStackTrace();\n+            }\n+            return Collections.emptyList();\n@@ -1165,13 +1235,0 @@\n-    private final Function<Boolean, String> DEFAULT_PAREN = hasParams -> hasParams ? \"(\" : \"()\";\n-    private final Function<Boolean, String> NO_PAREN = hasParams -> \"\";\n-\n-    private void addElements(Iterable<? extends Element> elements, Predicate<Element> accept, Predicate<Element> smart, List<Suggestion> result) {\n-        addElements(elements, accept, smart, DEFAULT_PAREN, result);\n-    }\n-    private void addElements(Iterable<? extends Element> elements, Predicate<Element> accept, Predicate<Element> smart, Function<Boolean, String> paren, List<Suggestion> result) {\n-        Set<String> hasParams = Util.stream(elements)\n-                .filter(accept)\n-                .filter(IS_CONSTRUCTOR.or(IS_METHOD))\n-                .filter(c -> !((ExecutableElement)c).getParameters().isEmpty())\n-                .map(this::simpleName)\n-                .collect(toSet());\n@@ -1179,0 +1236,1 @@\n+    private void addElements(JavadocHelper javadoc, Iterable<? extends Element> elements, Predicate<Element> accept, Predicate<Element> smart, int anchor, String prefix, List<ElementSuggestion> result) {\n@@ -1180,1 +1238,1 @@\n-            if (!accept.test(c))\n+            if (!accept.test(c) || !simpleContinuationName(c).startsWith(prefix))\n@@ -1187,13 +1245,12 @@\n-            String simpleName = simpleName(c);\n-            switch (c.getKind()) {\n-                case CONSTRUCTOR:\n-                case METHOD:\n-                    \/\/ add trailing open or matched parenthesis, as approriate\n-                    simpleName += paren.apply(hasParams.contains(simpleName));\n-                    break;\n-                case PACKAGE:\n-                    \/\/ add trailing dot to package names\n-                    simpleName += \".\";\n-                    break;\n-            }\n-            result.add(new SuggestionImpl(simpleName, smart.test(c)));\n+            StoredElement stored = javadoc.getHandle(c);\n+            Collection<? extends Path> sourceLocations = javadoc.getSourceLocations();\n+            result.add(new ElementSuggestionImpl(c, null, smart.test(c), anchor, () -> {\n+                return proc.taskFactory.analyze(proc.outerMap.wrapInTrialClass(Wrap.methodWrap(\";\")), task -> {\n+                    try (JavadocHelper nestedJavadoc = JavadocHelper.create(task.task, sourceLocations)) {\n+                        return nestedJavadoc.getResolvedDocComment(stored);\n+                    } catch (IOException ex) {\n+                        ex.printStackTrace();\n+                    }\n+                    return null;\n+                });\n+            }));\n@@ -1203,1 +1260,1 @@\n-    private void addModuleElements(AnalyzeTask at,\n+    private void addModuleElements(AnalyzeTask at, JavadocHelper javadoc, int anchor,\n@@ -1205,1 +1262,1 @@\n-                                   List<Suggestion> result) {\n+                                   List<ElementSuggestion> result) {\n@@ -1210,2 +1267,1 @@\n-            result.add(new SuggestionImpl(me.getQualifiedName().toString(),\n-                                          false));\n+            result.add(new ElementSuggestionImpl(me, null, false, anchor, () -> null)); \/\/TODO: better javadoc!\n@@ -1215,3 +1271,32 @@\n-    private String simpleName(Element el) {\n-        return el.getKind() == ElementKind.CONSTRUCTOR ? el.getEnclosingElement().getSimpleName().toString()\n-                                                       : el.getSimpleName().toString();\n+    private String simpleContinuationName(Element el) {\n+        return switch (el.getKind()) {\n+            case CONSTRUCTOR -> el.getEnclosingElement().getSimpleName().toString();\n+            case MODULE -> ((ModuleElement) el).getQualifiedName().toString();\n+            default -> el.getSimpleName().toString();\n+        };\n+    }\n+\n+    private String continuationName(CompletionState state, Element el) {\n+        if (state.completionContext().contains(CompletionContext.QUALIFIED)) {\n+            return simpleContinuationName(el);\n+        } else if (state.availableUsingSimpleName(el)) {\n+            return el.getSimpleName().toString();\n+        } else {\n+            return (switch (el.getKind()) {\n+                case PACKAGE -> ((PackageElement) el).getQualifiedName();\n+                case ANNOTATION_TYPE, CLASS, ENUM, INTERFACE, RECORD ->\n+                        primitiveLikeClass(el)\n+                            ? el.getSimpleName()\n+                            : continuationName(state, el.getEnclosingElement()) + \".\" + el.getSimpleName();\n+                case ENUM_CONSTANT, FIELD, METHOD ->\n+                    el.getModifiers().contains(Modifier.STATIC)\n+                        ? continuationName(state, el.getEnclosingElement()) + \".\" + el.getSimpleName()\n+                        : el.getSimpleName();\n+                default -> simpleContinuationName(el);\n+            }).toString();\n+        }\n+    }\n+\n+    private boolean primitiveLikeClass(Element el) {\n+        return el.asType().getKind().isPrimitive() ||\n+               el.asType().getKind() == TypeKind.VOID;\n@@ -1628,2 +1713,2 @@\n-    private void addScopeElements(AnalyzeTask at, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor, Predicate<Element> filter, Predicate<Element> smartFilter, List<Suggestion> result) {\n-        addElements(scopeContent(at, scope, elementConvertor), filter, smartFilter, result);\n+    private void addScopeElements(AnalyzeTask at, JavadocHelper javadoc, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor, Predicate<Element> filter, Predicate<Element> smartFilter, int anchor, String prefix, List<ElementSuggestion> result) {\n+        addElements(javadoc, scopeContent(at, scope, elementConvertor), filter, smartFilter, anchor, prefix, result);\n@@ -1762,0 +1847,1 @@\n+            int parameterIndex = -1;\n@@ -1786,0 +1872,4 @@\n+\n+                if (prevPath != null) {\n+                    parameterIndex = arguments.indexOf(prevPath.getLeaf());\n+                }\n@@ -1823,1 +1913,2 @@\n-                result = elements.map(el -> constructDocumentation(at, helper, el, computeJavadoc))\n+                int parameterIndexFin = parameterIndex;\n+                result = elements.map(el -> constructDocumentation(at, helper, el, parameterIndexFin, computeJavadoc))\n@@ -1834,1 +1925,1 @@\n-    private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, boolean computeJavadoc) {\n+    private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, int parameterIndex, boolean computeJavadoc) {\n@@ -1847,1 +1938,1 @@\n-        return new DocumentationImpl(signature,  javadoc);\n+        return new DocumentationImpl(signature, javadoc, parameterIndex);\n@@ -1860,21 +1951,1 @@\n-    private static final class DocumentationImpl implements Documentation {\n-\n-        private final String signature;\n-        private final String javadoc;\n-\n-        public DocumentationImpl(String signature, String javadoc) {\n-            this.signature = signature;\n-            this.javadoc = javadoc;\n-        }\n-\n-        @Override\n-        public String signature() {\n-            return signature;\n-        }\n-\n-        @Override\n-        public String javadoc() {\n-            return javadoc;\n-        }\n-\n-    }\n+    private record DocumentationImpl(String signature, String javadoc, int activeParameterIndex) implements Documentation {}\n@@ -2523,1 +2594,0 @@\n-        private final String filteringText;\n@@ -2533,11 +2603,0 @@\n-            this(continuation, continuation, matchesType);\n-        }\n-\n-        \/**\n-         * Create a {@code Suggestion} instance.\n-         *\n-         * @param continuation a candidate continuation of the user's input\n-         * @param filteringText a text that should be used for filtering\n-         * @param matchesType does the candidate match the target type\n-         *\/\n-        public SuggestionImpl(String continuation, String filteringText, boolean matchesType) {\n@@ -2545,1 +2604,0 @@\n-            this.filteringText = filteringText;\n@@ -2623,0 +2681,49 @@\n+    record ElementSuggestionImpl(Element element, String keyword, boolean matchesType, int anchor, Supplier<String> documentation) implements ElementSuggestion {\n+    }\n+\n+    final static class CompletionStateImpl implements CompletionState {\n+\n+        private final Collection<? extends Element> scopeContent;\n+        private final Set<CompletionContext> completionContext;\n+        private final TypeMirror selectorType;\n+        private final Elements elementUtils;\n+        private final Types typeUtils;\n+\n+        public CompletionStateImpl(Collection<? extends Element> scopeContent,\n+                                   Set<CompletionContext> completionContext,\n+                                   TypeMirror selectorType,\n+                                   Elements elementUtils,\n+                                   Types typeUtils) {\n+            this.scopeContent = scopeContent;\n+            this.completionContext = completionContext;\n+            this.selectorType = selectorType;\n+            this.elementUtils = elementUtils;\n+            this.typeUtils = typeUtils;\n+        }\n+\n+        @Override\n+        public boolean availableUsingSimpleName(Element el) {\n+            return scopeContent.contains(el);\n+        }\n+\n+        @Override\n+        public Set<CompletionContext> completionContext() {\n+            return completionContext;\n+        }\n+\n+        @Override\n+        public TypeMirror selectorType() {\n+            return selectorType;\n+        }\n+\n+        @Override\n+        public Elements elementUtils() {\n+            return elementUtils;\n+        }\n+\n+        @Override\n+        public Types typeUtils() {\n+            return typeUtils;\n+        }\n+\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":251,"deletions":144,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366691\n+ * @summary Test JShell Completion API\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.jshell:open\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build KullaTesting TestingInputStream Compiler\n+ * @run junit CompletionAPITest\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Field;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.QualifiedNameable;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import jdk.jshell.SourceCodeAnalysis.CompletionContext;\n+import jdk.jshell.SourceCodeAnalysis.CompletionState;\n+import jdk.jshell.SourceCodeAnalysis.ElementSuggestion;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+public class CompletionAPITest extends KullaTesting {\n+\n+    private static final long TIMEOUT = 2_000;\n+\n+    @Test\n+    public void testAPI() {\n+        waitIndexingFinished();\n+        assertEval(\"String str = \\\"\\\";\");\n+        List<String> actual;\n+        actual = completionSuggestions(\"str.\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.String.length()\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"java.lang.\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.String\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"java.\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang\"), String.valueOf(actual));\n+        assertEval(\"@interface Ann2 { }\");\n+        assertEval(\"@interface Ann1 { Ann2 value(); }\");\n+        actual = completionSuggestions(\"@Ann\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.TYPES_AS_ANNOTATIONS), state.completionContext());\n+        });\n+        assertTrue(actual.containsAll(Set.of(\"Ann1\", \"Ann2\")), String.valueOf(actual));\n+        actual = completionSuggestions(\"@Ann1(\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.ANNOTATION_ATTRIBUTE,\n+                                    CompletionContext.TYPES_AS_ANNOTATIONS),\n+                         state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"Ann2\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"import static java.lang.String.\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED, CompletionContext.NO_PAREN), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.String.valueOf(int arg0)\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"java.util.function.IntFunction<String> f = String::\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED, CompletionContext.NO_PAREN), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.String.valueOf(int arg0)\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"str.^len\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.QUALIFIED), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.String.length()\"), String.valueOf(actual));\n+        actual = completionSuggestions(\"^@Depr\", (state, suggestions) -> {\n+            assertEquals(EnumSet.of(CompletionContext.TYPES_AS_ANNOTATIONS), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.lang.Deprecated\"), String.valueOf(actual));\n+        assertEval(\"import java.util.*;\");\n+        actual = completionSuggestions(\"^ArrayL\", (state, suggestions) -> {\n+            TypeElement arrayList =\n+                suggestions.stream()\n+                           .filter(el -> el.element() != null)\n+                           .map(el -> el.element())\n+                           .filter(el -> el.getKind() == ElementKind.CLASS)\n+                           .map(el -> (TypeElement) el)\n+                           .filter(el -> el.getQualifiedName().contentEquals(\"java.util.ArrayList\"))\n+                           .findAny()\n+                           .orElseThrow();\n+            assertTrue(state.availableUsingSimpleName(arrayList));\n+            assertEquals(EnumSet.noneOf(CompletionContext.class), state.completionContext());\n+        });\n+        assertTrue(actual.contains(\"java.util.ArrayList\"), String.valueOf(actual));\n+        completionSuggestions(\"(new java.util.ArrayList<String>()).\", (state, suggestions) -> {\n+            List<String> elsWithTypes =\n+                suggestions.stream()\n+                           .filter(el -> el.element() != null)\n+                           .map(el -> el.element())\n+                           .filter(el -> el.getKind() == ElementKind.METHOD)\n+                           .map(el -> el.getSimpleName() + state.typeUtils()\n+                                                                .asMemberOf((DeclaredType) state.selectorType(), el)\n+                                                                .toString())\n+                           .toList();\n+            assertTrue(elsWithTypes.contains(\"add(java.lang.String)boolean\"));\n+        });\n+    }\n+\n+    @Test\n+    public void testDocumentation() {\n+        waitIndexingFinished();\n+\n+        Path classes = prepareZip();\n+        getState().addToClasspath(classes.toString());\n+\n+        AtomicReference<Supplier<String>> documentation = new AtomicReference<>();\n+        AtomicReference<Reference<Element>> clazz = new AtomicReference<>();\n+        completionSuggestions(\"jshelltest.JShellTest\", (state, suggestions) -> {\n+            ElementSuggestion test =\n+                    suggestions.stream()\n+                               .filter(el -> el.element() != null)\n+                               .filter(el -> el.element().getKind() == ElementKind.CLASS)\n+                               .filter(el -> ((TypeElement) el.element()).getQualifiedName().contentEquals(\"jshelltest.JShellTest\"))\n+                               .findAny()\n+                               .orElseThrow();\n+            documentation.set(test.documentation());\n+            clazz.set(new WeakReference<>(test.element()));\n+        });\n+\n+        \/\/throw away the JavacTaskPool, so that the cached javac instances are dropped:\n+        getState().addToClasspath(\"undefined\");\n+\n+        long start = System.currentTimeMillis();\n+\n+        while (clazz.get().get() != null && (System.currentTimeMillis() - start) < TIMEOUT) {\n+            System.gc();\n+        }\n+\n+        assertNull(clazz.get().get());\n+        assertEquals(\"JShellTest 0 \", documentation.get().get());\n+    }\n+\n+    @Test\n+    public void testSignature() {\n+        waitIndexingFinished();\n+\n+        assertEval(\"void test(int i) {}\");\n+        assertEval(\"void test(int i, int j) {}\");\n+        assertSignature(\"test(|\", true, \"void test(int i):0\", \"void test(int i, int j):0\");\n+        assertSignature(\"test(0, |\", true, \"void test(int i, int j):1\");\n+    }\n+\n+    private List<String> completionSuggestions(String input,\n+                                               BiConsumer<CompletionState, List<? extends ElementSuggestion>> validator) {\n+        int expectedAnchor = input.indexOf('^');\n+\n+        if (expectedAnchor != (-1)) {\n+            input = input.substring(0, expectedAnchor) + input.substring(expectedAnchor + 1);\n+        }\n+\n+        AtomicInteger mergedAnchor = new AtomicInteger(-1);\n+\n+        List<String> result = getAnalysis().completionSuggestions(input, input.length(), (state, suggestions) -> {\n+            validator.accept(state, suggestions);\n+\n+            if (expectedAnchor != (-1)) {\n+                for (ElementSuggestion sugg : suggestions) {\n+                    if (mergedAnchor.get() == (-1)) {\n+                        mergedAnchor.set(sugg.anchor());\n+                    } else {\n+                        assertEquals(mergedAnchor.get(), sugg.anchor());\n+                    }\n+                }\n+            }\n+\n+            return suggestions.stream()\n+                           .map(this::convertElement)\n+                           .toList();\n+        });\n+\n+        if (expectedAnchor != (-1)) {\n+            assertEquals(expectedAnchor, mergedAnchor.get());\n+        }\n+\n+        return result;\n+    }\n+\n+    private String convertElement(ElementSuggestion suggestion) {\n+        if (suggestion.keyword() != null) {\n+            return suggestion.keyword();\n+        }\n+\n+        Element el = suggestion.element();\n+\n+        if (el.getKind().isClass() || el.getKind().isInterface() || el.getKind() == ElementKind.PACKAGE) {\n+            String qualifiedName = ((QualifiedNameable) el).getQualifiedName().toString();\n+            if (qualifiedName.startsWith(\"REPL.$JShell$\")) {\n+                String[] parts = qualifiedName.split(\"\\\\.\", 3);\n+\n+                return parts[2];\n+            } else {\n+                return qualifiedName;\n+            }\n+        } else if (el.getKind().isField()) {\n+            return ((QualifiedNameable) el.getEnclosingElement()).getQualifiedName().toString() +\n+                   \".\" +\n+                   el.getSimpleName();\n+        } else if (el.getKind() == ElementKind.CONSTRUCTOR || el.getKind() == ElementKind.METHOD) {\n+            String name = el.getKind() == ElementKind.CONSTRUCTOR ? \"\" : \".\" + el.getSimpleName();\n+            ExecutableElement method = (ExecutableElement) el;\n+\n+            return ((QualifiedNameable) el.getEnclosingElement()).getQualifiedName().toString() +\n+                    name +\n+                    method.getParameters()\n+                          .stream()\n+                          .map(var -> var.asType().toString() + \" \" + var.getSimpleName())\n+                          .collect(Collectors.joining(\", \", \"(\", \")\"));\n+        } else {\n+            return el.getSimpleName().toString();\n+        }\n+    }\n+\n+    private Path prepareZip() {\n+        String clazz =\n+                \"package jshelltest;\\n\" +\n+                \"\/**JShellTest 0\" +\n+                \" *\/\\n\" +\n+                \"public class JShellTest {\\n\" +\n+                \"}\\n\";\n+\n+        Path srcZip = Paths.get(\"src.zip\");\n+\n+        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(srcZip))) {\n+            out.putNextEntry(new JarEntry(\"jshelltest\/JShellTest.java\"));\n+            out.write(clazz.getBytes());\n+        } catch (IOException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n+        compiler.compile(clazz);\n+\n+        try {\n+            Field availableSources = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\").getDeclaredField(\"availableSourcesOverride\");\n+            availableSources.setAccessible(true);\n+            availableSources.set(null, Arrays.asList(srcZip));\n+        } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException | ClassNotFoundException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n+        return compiler.getClassDir();\n+    }\n+    \/\/where:\n+        private final Compiler compiler = new Compiler();\n+\n+    static {\n+        try {\n+            \/\/disable reading of paramater names, to improve stability:\n+            Class<?> analysisClass = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\");\n+            Field params = analysisClass.getDeclaredField(\"COMPLETION_EXTRA_PARAMETERS\");\n+            params.setAccessible(true);\n+            params.set(null, List.of());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/CompletionAPITest.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.List;\n@@ -904,1 +905,1 @@\n-        assertCompletion(\"@Deprec|\", \"Deprecated\");\n+        assertCompletion(\"@Deprec|\", \"@Deprecated(\");\n@@ -954,0 +955,12 @@\n+\n+    static {\n+        try {\n+            \/\/disable reading of paramater names, to improve stability:\n+            Class<?> analysisClass = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\");\n+            Field params = analysisClass.getDeclaredField(\"COMPLETION_EXTRA_PARAMETERS\");\n+            params.setAccessible(true);\n+            params.set(null, List.of());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.function.Function;\n@@ -972,0 +973,4 @@\n+        assertSignature(code, false, expected);\n+    }\n+\n+    public void assertSignature(String code, boolean includeActive, String... expected) {\n@@ -976,1 +981,7 @@\n-        Set<String> docSet = documentation.stream().map(doc -> doc.signature()).collect(Collectors.toSet());\n+        Function<Documentation, String> convert;\n+        if (includeActive) {\n+            convert = doc -> doc.signature() + \":\" + doc.activeParameterIndex();\n+        } else {\n+            convert = doc -> doc.signature();\n+        }\n+        Set<String> docSet = documentation.stream().map(convert).collect(Collectors.toSet());\n","filename":"test\/langtools\/jdk\/jshell\/KullaTesting.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -106,2 +106,2 @@\n-                            \"JShellTest\\\\(String str\\\\)\\n\" +\n-                            \"JShellTest\\\\(String str, int i\\\\)\\n\" +\n+                            \"JShellTest\\\\(\\\\u001B\\\\[1mString str\\\\u001B\\\\[0m\\\\)\\n\" +\n+                            \"JShellTest\\\\(\\\\u001B\\\\[1mString str\\\\u001B\\\\[0m, int i\\\\)\\n\" +\n@@ -141,2 +141,2 @@\n-                            \"JShellTest\\\\(String str\\\\)\\n\" +\n-                            \"JShellTest\\\\(String str, int i\\\\)\\n\" +\n+                            \"JShellTest\\\\(\\\\u001B\\\\[1mString str\\\\u001B\\\\[0m\\\\)\\n\" +\n+                            \"JShellTest\\\\(\\\\u001B\\\\[1mString str\\\\u001B\\\\[0m, int i\\\\)\\n\" +\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}