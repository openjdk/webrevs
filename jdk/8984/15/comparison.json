{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+ * Where a method returns a type mirror or a collection of type\n+ * mirrors, any type mirrors represent types with no type annotations,\n+ * unless otherwise indicated.\n+ *\n@@ -156,0 +160,2 @@\n+     * Annotations on the direct super types are preserved.\n+     *\n@@ -238,0 +244,2 @@\n+     * Annotations on the component type are preserved.\n+     *\n@@ -248,0 +256,2 @@\n+     * Annotations on the bounds are preserved.\n+     *\n@@ -263,0 +273,2 @@\n+     * Annotations on the type arguments are preserved.\n+     *\n@@ -294,0 +306,2 @@\n+     * Annotations on the type arguments are preserved.\n+     *\n@@ -327,0 +341,25 @@\n+\n+    \/**\n+     * {@return a type mirror equivalent to the argument, but with no annotations}\n+     * If the type mirror is a composite type, such as an array type\n+     * or a wildcard type, any constitute types, such as the\n+     * component type of an array and the type of the bounds of a\n+     * wildcard type, also have no annotations, recursively.\n+     *\n+     * <p>For most kinds of type mirrors, the result of\n+     * {@snippet lang=\"java\" :\n+     *   types.isSameType(typeMirror, types.stripAnnotations(typeMirror))\n+     * }\n+     * is {@code true}. The predicate is {@code false} on wildcard\n+     * types for {@linkplain #isSameType(TypeMirror, TypeMirror)\n+     * reasons discussed elsewhere}.\n+     *\n+     * @param t the type mirror\n+     * @param <T> the specific type of type mirror\n+     * @implSpec\n+     * The default implementation throws {@code UnsupportedOperationException}.\n+     * @since 23\n+     *\/\n+    default <T extends TypeMirror> T stripAnnotations(T t) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        return metadata.isEmpty() ? this : baseType();\n+        return metadata.isEmpty() ? this : stripMetadata();\n@@ -429,0 +429,6 @@\n+        \/**\n+         * Note: this visitor only needs to handle cases where\n+         * 'contained' types can be annotated. These cases are\n+         * described in JVMS 4.7.20.2 and are : classes (for type\n+         * parameters and enclosing types), wildcards, and arrays.\n+         *\/\n@@ -432,1 +438,1 @@\n-                return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);\n+                return super.visitClassType((ClassType) dropMetadata(t), aVoid);\n@@ -437,1 +443,1 @@\n-                return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);\n+                return super.visitArrayType((ArrayType) dropMetadata(t), aVoid);\n@@ -441,2 +447,2 @@\n-            public Type visitTypeVar(TypeVar t, Void aVoid) {\n-                return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);\n+            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n+                return super.visitWildcardType((WildcardType) dropMetadata(wt), aVoid);\n@@ -446,2 +452,13 @@\n-            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n-                return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);\n+            public Type visitType(Type t, Void aVoid) {\n+                return dropMetadata(t);\n+            }\n+\n+            private static Type dropMetadata(Type t) {\n+                if (t.getMetadata().isEmpty()) {\n+                    return t;\n+                }\n+                Type baseType = t.baseType();\n+                if (baseType.getMetadata().isEmpty()) {\n+                    return baseType;\n+                }\n+                return baseType.cloneWithMetadata(List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        return types.erasure((Type)t).stripMetadataIfNeeded();\n+        return types.erasure((Type)t).stripMetadata();\n@@ -158,1 +158,1 @@\n-        return types.capture((Type)t).stripMetadataIfNeeded();\n+        return types.capture((Type)t).stripMetadata();\n@@ -307,0 +307,7 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends TypeMirror> T stripAnnotations(T t) {\n+        return (T)((Type) t).stripMetadata();\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.lang.model.type.*;\n@@ -325,0 +326,69 @@\n+\n+    \/**\n+     * Vacuous implementation of javax.lang.model.util.Types to aid\n+     * in test development. Methods with defaults in the interface are\n+     * *not* overridden to allow them to be tested.\n+     *\/\n+    public static class VacuousTypes implements Types {\n+        public VacuousTypes() {}\n+\n+        @Override\n+        public Element asElement(TypeMirror t) {return null;}\n+\n+        @Override\n+        public boolean isSameType(TypeMirror t1, TypeMirror t2) {return false;}\n+\n+        @Override\n+        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean contains(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {return false;}\n+\n+        @Override\n+        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror erasure(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeElement boxedClass(PrimitiveType p) {return null;}\n+\n+        @Override\n+        public PrimitiveType unboxedType(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror capture(TypeMirror t) {return null;}\n+\n+        @Override\n+        public PrimitiveType getPrimitiveType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public NullType getNullType() {return null;}\n+\n+        @Override\n+        public NoType getNoType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public ArrayType getArrayType(TypeMirror componentType) {return null;}\n+\n+        @Override\n+        public WildcardType getWildcardType(TypeMirror extendsBound,\n+                                 TypeMirror superBound) {return null;}\n+\n+        @Override\n+        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+\n+        @Override\n+        public DeclaredType getDeclaredType(DeclaredType containing,\n+                                 TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+        @Override\n+        public TypeMirror asMemberOf(DeclaredType containing, Element element) {return null;}\n+    }\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8042981\n+ * @summary Test if annotations are stripped from the results of Types' methods\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * jdk.compiler\n+ * @build JavacTestingAbstractProcessor TestAnnotationStripping\n+ * @compile -processor TestAnnotationStripping -proc:only TestAnnotationStripping.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import static java.util.Objects.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import static javax.lang.model.util.ElementFilter.*;\n+import static javax.tools.Diagnostic.Kind.*;\n+import static javax.tools.StandardLocation.*;\n+\n+\/**\n+ * Test if annotations are stripped from the results of Types' methods\n+ *\/\n+public class TestAnnotationStripping extends JavacTestingAbstractProcessor {\n+    private Types vacuousTypes = new VacuousTypes();\n+\n+    \/**\n+     * Check expected behavior on classes and packages.\n+     *\/\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement hostClassElt = eltUtils.getTypeElement(\"HostClass\");\n+            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TestTypeAnnotation\").asType();\n+\n+            for (ExecutableElement m : methodsIn(hostClassElt.getEnclosedElements())) {\n+                \/*\n+                 * The kinds of types include:\n+                 *\n+                 * arrays\n+                 * declared types (classes, interfaces, etc.)\n+                 * error types\n+                 * executable types\n+                 * intersection types\n+                 * no-type\n+                 * null type\n+                 * primitive types\n+                 * type variable\n+                 * union type\n+                 * wildcards\n+                 *\n+                 * A subset of these can appear at the return type of\n+                 * a method. The general methodology is to verify that\n+                 * types that can appear as return types when\n+                 * annotated with type annotations appear as specified\n+                 * as the result of type operations or when new types\n+                 * are constructed.\n+                 *\/\n+\n+                TypeMirror returnType = m.getReturnType();\n+\n+                System.err.println(\"Checking \" + returnType);\n+\n+                testVacuous(returnType);\n+                checkDeepEmptyAnnotations(typeUtils.stripAnnotations(returnType));\n+\n+                checkExpectedTypeAnnotations(returnType, expectedAnnotation);\n+\n+                \/\/ Note: the result of Types.asElement is *not*\n+                \/\/ checked for its annotations since the return value\n+                \/\/ is an Element and not a TypeMirror.\n+\n+                System.err.print(\"\\tcapture()\");\n+                checkDeepEmptyAnnotations(typeUtils.capture(returnType));\n+\n+                System.err.print(\"\\terasure()\");\n+                checkDeepEmptyAnnotations(typeUtils.erasure(returnType));\n+\n+                System.err.print(\"\\tgetArrayType()\");\n+                ArrayType arrayType = typeUtils.getArrayType(returnType);\n+                checkEmptyAnnotations(arrayType);\n+                \/*\n+                 * \"Annotations on the component type are preserved.\"\n+                 *\/\n+                checkEqualTypeAndAnnotations(returnType, arrayType.getComponentType());\n+\n+                if (!returnType.getKind().isPrimitive()) {\n+                    \/*\n+                     * For getWildcardType()\n+                     * \"Annotations on the bounds are preserved.\"\n+                     *\/\n+                    WildcardType wcType;\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(returnType, null));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getExtendsBound());\n+\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(null,       returnType));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getSuperBound());\n+\n+                    \/*\n+                     * For getDeclaredType()\n+                     * \"Annotations on the type arguments are preserved.\"\n+                     *\/\n+                    DeclaredType declaredType =\n+                        typeUtils.getDeclaredType(elements.getTypeElement(\"java.util.Set\"),\n+                                                  returnType);\n+                    checkEqualTypeAndAnnotations(returnType, declaredType.getTypeArguments().get(0));\n+                }\n+\n+                System.out.println(returnType.getAnnotation(TestTypeAnnotation.class));\n+                System.out.println(returnType.getAnnotationsByType(TestTypeAnnotation.class).length);\n+                TestTypeAnnotation ta = requireNonNull(returnType.getAnnotation(TestTypeAnnotation.class),\n+                                                       returnType.toString());\n+\n+                System.err.println();\n+                System.err.println();\n+            }\n+\n+            if (failures > 0)\n+                throw new RuntimeException(failures + \" failures occured.\");\n+        }\n+        return true;\n+    }\n+\n+    void testVacuous(TypeMirror tm ) {\n+        try {\n+            var result = vacuousTypes.stripAnnotations(tm);\n+            messager.printError(\"Unexpected non-exceptional result returned \" +  result);\n+        } catch(UnsupportedOperationException uoe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private int failures = 0;\n+\n+    void checkExpectedTypeAnnotations(AnnotatedConstruct ac, TypeMirror expectedAnnotation) {\n+        List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+        if (annotations.size() != 1) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations size: \" + annotations.size());\n+        } else if (!typeUtils.isSameType(annotations.get(0).getAnnotationType(), expectedAnnotation)) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations type: \" + annotations);\n+        }\n+    }\n+\n+    void checkEmptyAnnotations(AnnotatedConstruct ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null)\n+            return;\n+        else {\n+            List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+            int count = annotations.size();\n+            if (count != 0) {\n+                failures++;\n+                System.err.println(ac.getClass());\n+                System.err.println(\"\\t\\t\\tUnexpected nonzero annotations size: \" + annotations);\n+            }\n+        }\n+    }\n+\n+    void checkDeepEmptyAnnotations(TypeMirror ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null) {\n+            return;\n+        }\n+        new SimpleTypeVisitor14<Void, Void>() {\n+            @Override\n+            protected Void defaultAction(TypeMirror t, Void o) {\n+                checkEmptyAnnotations(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitArray(ArrayType t, Void o) {\n+                scan(t.getComponentType());\n+                return super.visitArray(t, o);\n+            }\n+\n+            @Override\n+            public Void visitDeclared(DeclaredType t, Void o) {\n+                scan(t.getEnclosingType());\n+                t.getTypeArguments().stream().forEach(this::scan);\n+                return super.visitDeclared(t, o);\n+            }\n+\n+            @Override\n+            public Void visitTypeVariable(TypeVariable t, Void o) {\n+                \/\/ the bounds correspond to the type variable declaration, not its use\n+                \/\/ scan(t.getUpperBound());\n+                \/\/ scan(t.getLowerBound());\n+                return super.visitTypeVariable(t, o);\n+            }\n+\n+            @Override\n+            public Void visitWildcard(WildcardType t, Void o) {\n+                scan(t.getExtendsBound());\n+                scan(t.getSuperBound());\n+                return super.visitWildcard(t, o);\n+            }\n+\n+            private void scan(TypeMirror t) {\n+                if (t != null) {\n+                    visit(t);\n+                }\n+            }\n+        }.visit(ac);\n+    }\n+\n+    void checkEqualTypeAndAnnotations(TypeMirror tm1, TypeMirror tm2) {\n+        if (!typeUtils.isSameType(tm1, tm2)) {\n+            failures++;\n+            System.err.printf(\"Unequal types %s and %s.%n\", tm1, tm2);\n+        }\n+\n+        if (!Objects.equals(tm1.getAnnotationMirrors(), tm1.getAnnotationMirrors())) {\n+            failures++;\n+            System.err.printf(\"Unequal annotations on and %s.%n\", tm1, tm2);\n+        }\n+    }\n+}\n+\n+\/*\n+ * Class to host annotations for testing\n+ *\/\n+class HostClass {\n+    \/\/ Declared type Integer\n+    public static @TestTypeAnnotation(\"foo\") Integer foo() {return null;}\n+\n+    \/\/ Primitive type int\n+    public static @TestTypeAnnotation(\"foo2\") int foo2() {return 0;}\n+\n+    public static @TestTypeAnnotation(\"foo3\") String foo3() {return null;}\n+\n+    \/\/ Declared raw type Set\n+    public static  java.util.@TestTypeAnnotation(\"foo4\")Set foo4() {return null;}\n+\n+    \/\/ Array type\n+    public static  String @TestTypeAnnotation(\"foo5\")[]  foo5() {return null;}\n+\n+    \/\/ Declared type Set with instantiated type parameter\n+    public static  java.util. @TestTypeAnnotation(\"foo6\") Set < @TestTypeAnnotation(\"foo7\") String> foo6() {return null;}\n+\n+    \/\/ Type variable\n+    public static <@TestTypeAnnotation(\"foo8\") T extends @TestTypeAnnotation(\"foo9\") String> @TestTypeAnnotation(\"foo10\") T foo7() {return null;}\n+\n+    \/\/ Declared type including wildcard\n+    public static  java.util. @TestTypeAnnotation(\"foo11\") Set < @TestTypeAnnotation(\"foo12\") ? extends @TestTypeAnnotation(\"foo13\") Number> foo8() {return null;}\n+\n+    \/\/ Type variable with intersection type\n+    public static <@TestTypeAnnotation(\"foo14\") S extends Number &  Runnable> @TestTypeAnnotation(\"foo15\") S foo9() {return null;}\n+\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface TestTypeAnnotation {\n+    String value() default \"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"}]}