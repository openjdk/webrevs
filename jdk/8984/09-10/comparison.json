{"files":[{"patch":"@@ -65,0 +65,23 @@\n+                \/*\n+                 * The kinds of types include:\n+                 *\n+                 * arrays\n+                 * declared types (classes, interfaces, etc.)\n+                 * error types\n+                 * executable types\n+                 * intersection types\n+                 * no-type\n+                 * null type\n+                 * primitive types\n+                 * type variable\n+                 * union type\n+                 * wildcards\n+                 *\n+                 * A subset of these can appear at the return type of\n+                 * a method. The general methodology is to verify that\n+                 * types that can appear as return types when\n+                 * annotated with type annotations appear as specified\n+                 * as the result of type operations or when new types\n+                 * are constructed.\n+                 *\/\n+\n@@ -74,4 +97,3 @@\n-                \/\/ System.err.print(\"\\tasElement()\");\n-                \/\/ When mapping from a type to its element, the\n-                \/\/ element may have declaration annotations on it.\n-                \/\/ checkEmptyAnnotations(typeUtils.asElement(returnType));\n+                \/\/ Note: the result of Types.asElement is *not*\n+                \/\/ checked for its annotations since the return value\n+                \/\/ is an Element and not a TypeMirror.\n@@ -147,3 +169,0 @@\n-            \/\/ Previously, was likely getting by-catch of annotations\n-            \/\/ on element declartions, can likely just print the size\n-            \/\/ of the list.\n@@ -151,7 +170,1 @@\n-            int count = 0;\n-            for (AnnotationMirror annotation : annotations) {\n-\/\/               if (((TypeElement) annotation.getAnnotationType().asElement()).getQualifiedName().contentEquals(\"jdk.internal.ValueBased\")) {\n-\/\/                 continue;\n-\/\/               }\n-              count++;\n-            }\n+            int count = annotations.size();\n@@ -166,1 +179,0 @@\n-\n@@ -226,1 +238,0 @@\n-\n@@ -233,0 +244,1 @@\n+    \/\/ Declared type Integer\n@@ -235,0 +247,1 @@\n+    \/\/ Primitive type int\n@@ -239,0 +252,1 @@\n+    \/\/ Declared raw type Set\n@@ -241,0 +255,1 @@\n+    \/\/ Array type\n@@ -243,0 +258,1 @@\n+    \/\/ Declared type Set with instantiated type parameter\n@@ -245,1 +261,9 @@\n-    public static <@TestTypeAnnotation(\"foo8\") T extends @TestTypeAnnotation(\"foo9\") String> @TestTypeAnnotation(\"foo10\") T foo8() {return null;}\n+    \/\/ Type variable\n+    public static <@TestTypeAnnotation(\"foo8\") T extends @TestTypeAnnotation(\"foo9\") String> @TestTypeAnnotation(\"foo10\") T foo7() {return null;}\n+\n+    \/\/ Declared type including wildcard\n+    public static  java.util. @TestTypeAnnotation(\"foo11\") Set < @TestTypeAnnotation(\"foo12\") ? extends @TestTypeAnnotation(\"foo13\") Number> foo8() {return null;}\n+\n+    \/\/ Type variable with intersection type\n+    public static <@TestTypeAnnotation(\"foo14\") S extends Number &  Runnable> @TestTypeAnnotation(\"foo15\") S foo9() {return null;}\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"}]}