{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+ * Where a method returns a type mirror or a collection of type\n+ * mirrors, any type mirrors represent types with no type annotations,\n+ * unless otherwise indicated.\n+ *\n@@ -156,0 +160,2 @@\n+     * Annotations on the direct super types are preserved.\n+     *\n@@ -238,0 +244,2 @@\n+     * Annotations on the component type are preserved.\n+     *\n@@ -248,0 +256,2 @@\n+     * Annotations on the bounds are preserved.\n+     *\n@@ -327,0 +337,12 @@\n+\n+    \/**\n+     * {@return a type mirror equal to the argument and with no annotations}\n+     * @param t the type mirror\n+     * @param <T> the specific type of type mirror\n+     * @implSpec\n+     * The default implementation throws {@code UnsupportedOperationException}.\n+     * @since 23\n+     *\/\n+    default <T extends TypeMirror> T stripAnnotations(T t) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        return metadata.isEmpty() ? this : baseType();\n+        return metadata.isEmpty() ? this : stripMetadata();\n@@ -432,1 +432,1 @@\n-                return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);\n+                return super.visitClassType((ClassType) dropMetadata(t), aVoid);\n@@ -437,1 +437,1 @@\n-                return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);\n+                return super.visitArrayType((ArrayType) dropMetadata(t), aVoid);\n@@ -441,2 +441,2 @@\n-            public Type visitTypeVar(TypeVar t, Void aVoid) {\n-                return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);\n+            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n+                return super.visitWildcardType((WildcardType) dropMetadata(wt), aVoid);\n@@ -446,2 +446,13 @@\n-            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n-                return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);\n+            public Type visitType(Type t, Void aVoid) {\n+                return dropMetadata(t);\n+            }\n+\n+            private static Type dropMetadata(Type t) {\n+                if (t.getMetadata().isEmpty()) {\n+                    return t;\n+                }\n+                Type baseType = t.baseType();\n+                if (baseType.getMetadata().isEmpty()) {\n+                    return baseType;\n+                }\n+                return baseType.cloneWithMetadata(List.nil());\n@@ -469,4 +480,4 @@\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n-        return null;\n-    }\n+\/\/     @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+\/\/     public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n+\/\/         return null;\n+\/\/     }\n@@ -475,6 +486,6 @@\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n-        @SuppressWarnings(\"unchecked\")\n-        A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n-        return tmp;\n-    }\n+\/\/     @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+\/\/     public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n+\/\/         @SuppressWarnings(\"unchecked\")\n+\/\/         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n+\/\/         return tmp;\n+\/\/     }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        return types.erasure((Type)t).stripMetadataIfNeeded();\n+        return types.erasure((Type)t).stripMetadata();\n@@ -158,1 +158,1 @@\n-        return types.capture((Type)t).stripMetadataIfNeeded();\n+        return types.capture((Type)t).stripMetadata();\n@@ -307,0 +307,7 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends TypeMirror> T stripAnnotations(T t) {\n+        return (T)((Type) t).stripMetadata();\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.lang.model.type.*;\n@@ -325,0 +326,69 @@\n+\n+    \/**\n+     * Vacuous implementation of javax.lang.model.util.Types to aid\n+     * in test development. Methods with defaults in the interface are\n+     * *not* overridden to allow them to be tested.\n+     *\/\n+    public static class VacuousTypes implements Types {\n+        public VacuousTypes() {}\n+\n+        @Override\n+        public Element asElement(TypeMirror t) {return null;}\n+\n+        @Override\n+        public boolean isSameType(TypeMirror t1, TypeMirror t2) {return false;}\n+\n+        @Override\n+        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean contains(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {return false;}\n+\n+        @Override\n+        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror erasure(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeElement boxedClass(PrimitiveType p) {return null;}\n+\n+        @Override\n+        public PrimitiveType unboxedType(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror capture(TypeMirror t) {return null;}\n+\n+        @Override\n+        public PrimitiveType getPrimitiveType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public NullType getNullType() {return null;}\n+\n+        @Override\n+        public NoType getNoType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public ArrayType getArrayType(TypeMirror componentType) {return null;}\n+\n+        @Override\n+        public WildcardType getWildcardType(TypeMirror extendsBound,\n+                                 TypeMirror superBound) {return null;}\n+\n+        @Override\n+        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+\n+        @Override\n+        public DeclaredType getDeclaredType(DeclaredType containing,\n+                                 TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+        @Override\n+        public TypeMirror asMemberOf(DeclaredType containing, Element element) {return null;}\n+    }\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8042981\n+ * @summary Test if annotations are stripped from the results of Types' methods\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * jdk.compiler\n+ * @build JavacTestingAbstractProcessor TestAnnotationStripping\n+ * @compile -processor TestAnnotationStripping -proc:only TestAnnotationStripping.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import static java.util.Objects.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import static javax.lang.model.util.ElementFilter.*;\n+import static javax.tools.Diagnostic.Kind.*;\n+import static javax.tools.StandardLocation.*;\n+\n+\/**\n+ * Test if annotations are stripped from the results of Types' methods\n+ *\/\n+public class TestAnnotationStripping extends JavacTestingAbstractProcessor {\n+    private Types vacuousTypes = new VacuousTypes();\n+\n+    \/**\n+     * Check expected behavior on classes and packages.\n+     *\/\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement hostClassElt = eltUtils.getTypeElement(\"HostClass\");\n+            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TestTypeAnnotation\").asType();\n+\n+            for (ExecutableElement m : methodsIn(hostClassElt.getEnclosedElements())) {\n+                TypeMirror returnType = m.getReturnType();\n+\n+                System.err.println(\"Checking \" + returnType);\n+\n+                testVacuous(returnType);\n+                checkEmptyAnnotations(typeUtils.stripAnnotations(returnType));\n+\n+                checkExpectedTypeAnnotations(returnType, expectedAnnotation);\n+\n+                System.err.print(\"\\tasElement()\");\n+                checkEmptyAnnotations(typeUtils.asElement(returnType));\n+\n+                System.err.print(\"\\tcapture()\");\n+                checkEmptyAnnotations(typeUtils.capture(returnType));\n+\n+                System.err.print(\"\\terasure()\");\n+                checkEmptyAnnotations(typeUtils.erasure(returnType));\n+\n+                System.err.print(\"\\tgetArrayType()\");\n+                ArrayType arrayType = typeUtils.getArrayType(returnType);\n+                checkEmptyAnnotations(arrayType);\n+                \/*\n+                 * \"Annotations on the component type are preserved.\"\n+                 *\/\n+                checkEqualTypeAndAnnotations(returnType, arrayType.getComponentType());\n+\n+                if (!returnType.getKind().isPrimitive()) {\n+                    \/*\n+                     * \"Annotations on the bounds are preserved.\"\n+                     *\/\n+                    WildcardType wcType;\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(returnType, null));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getExtendsBound());\n+\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(null,       returnType));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getSuperBound());\n+                }\n+\n+                 System.out.println(returnType.getAnnotation(TestTypeAnnotation.class));\n+                 System.out.println(returnType.getAnnotationsByType(TestTypeAnnotation.class).length);\n+                 TestTypeAnnotation ta = requireNonNull(returnType.getAnnotation(TestTypeAnnotation.class),\n+                                                        returnType.toString());\n+\n+                System.err.println();\n+                System.err.println();\n+            }\n+\n+            if (failures > 0)\n+                throw new RuntimeException(failures + \" failures occured.\");\n+        }\n+        return true;\n+    }\n+\n+    void testVacuous(TypeMirror tm ) {\n+        try {\n+            var result = vacuousTypes.stripAnnotations(tm);\n+            messager.printError(\"Unexpected non-exceptional result returned\" +  result);\n+        } catch(UnsupportedOperationException uoe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private int failures = 0;\n+\n+    void checkExpectedTypeAnnotations(AnnotatedConstruct ac, TypeMirror expectedAnnotation) {\n+        List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+        if (annotations.size() != 1) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations size: \" + annotations.size());\n+        } else if (!typeUtils.isSameType(annotations.get(0).getAnnotationType(), expectedAnnotation)) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations type: \" + annotations);\n+        }\n+    }\n+\n+    void checkEmptyAnnotations(AnnotatedConstruct ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null)\n+            return;\n+        else {\n+            List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+            int count = 0;\n+            for (AnnotationMirror annotation : annotations) {\n+              if (((TypeElement) annotation.getAnnotationType().asElement()).getQualifiedName().contentEquals(\"jdk.internal.ValueBased\")) {\n+                continue;\n+              }\n+              count++;\n+            }\n+            if (count != 0) {\n+                failures++;\n+                System.err.println(ac.getClass());\n+                System.err.println(\"\\t\\t\\tUnexpected nonzero annotations size: \" + annotations);\n+            }\n+        }\n+    }\n+\n+    void checkEqualTypeAndAnnotations(TypeMirror tm1, TypeMirror tm2) {\n+        if (!typeUtils.isSameType(tm1, tm2)) {\n+            failures++;\n+            System.err.printf(\"Unequal types %s and %s.%n\", tm1, tm2);\n+        }\n+\n+        if (!Objects.equals(tm1.getAnnotationMirrors(), tm1.getAnnotationMirrors())) {\n+            failures++;\n+            System.err.printf(\"Unequal annotations on and %s.%n\", tm1, tm2);\n+        }\n+    }\n+\n+}\n+\n+\/*\n+ * Class to host annotations for testing\n+ *\/\n+class HostClass {\n+    public static @TestTypeAnnotation(\"foo\") Integer foo() {return null;}\n+\n+    public static @TestTypeAnnotation(\"foo2\") int foo2() {return 0;}\n+\n+    public static @TestTypeAnnotation(\"foo3\") String foo3() {return null;}\n+\n+    public static  java.util.@TestTypeAnnotation(\"foo4\")Set foo4() {return null;}\n+\n+    public static  String @TestTypeAnnotation(\"foo5\")[]  foo5() {return null;}\n+\n+    public static  java.util. @TestTypeAnnotation(\"foo6\") Set < @TestTypeAnnotation(\"foo7\") String> foo6() {return null;}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface TestTypeAnnotation {\n+    String value() default \"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}