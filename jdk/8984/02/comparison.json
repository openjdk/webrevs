{"files":[{"patch":"@@ -38,0 +38,4 @@\n+ * Where a method returns a type mirror or a collection of type\n+ * mirrors, any type mirrors represent types with no type annotations,\n+ * unless otherwise indicated.\n+ *\n@@ -156,0 +160,2 @@\n+     * Annotations on the direct super types are preserved.\n+     *\n@@ -238,0 +244,2 @@\n+     * Annotations on the component type are preserved.\n+     *\n@@ -248,0 +256,2 @@\n+     * Annotations on the bounds are preserved.\n+     *\n@@ -327,0 +337,12 @@\n+\n+    \/**\n+     * {@return a type mirror equal to the argument and with no annotations}\n+     * @param t the type mirror\n+     * @param <T> the specific type of type mirror\n+     * @implSpec\n+     * The default implementation throws {@code UnsupportedOperationException}.\n+     * @since 20\n+     *\/\n+    default <T extends TypeMirror> T stripAnnotations(T t) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -449,0 +449,40 @@\n+\n+            @Override\n+            public Type visitMethodType(MethodType t, Void aVoid) {\n+                return super.visitMethodType((MethodType)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitPackageType(PackageType t, Void aVoid) {\n+                return super.visitPackageType((PackageType)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitModuleType(ModuleType t, Void aVoid) {\n+                return super.visitModuleType((ModuleType)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitCapturedType(CapturedType t, Void aVoid) {\n+                return super.visitCapturedType((CapturedType)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitForAll(ForAll t, Void aVoid) {\n+                return super.visitForAll((ForAll)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitUndetVar(UndetVar t, Void aVoid) {\n+                return super.visitUndetVar((UndetVar)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitErrorType(ErrorType t, Void aVoid) {\n+                return super.visitErrorType((ErrorType)t.typeNoMetadata(), aVoid);\n+            }\n+\n+            @Override\n+            public Type visitType(Type t, Void aVoid) {\n+                return super.visitType(t.typeNoMetadata(), aVoid);\n+            }\n@@ -2449,1 +2489,1 @@\n-    public interface Visitor<R,S> {\n+    public interface Visitor<R,S> {  \/\/ Primitive types omitted?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -128,2 +128,2 @@\n-                .map(Type::stripMetadataIfNeeded)\n-                .toList();\n+            .map(Type::stripMetadataIfNeeded)\n+            .toList();\n@@ -137,1 +137,1 @@\n-        return types.erasure((Type)t).stripMetadataIfNeeded();\n+        return types.erasure((Type)t).stripMetadata();\n@@ -158,1 +158,1 @@\n-        return types.capture((Type)t).stripMetadataIfNeeded();\n+        return types.capture((Type)t).stripMetadata();\n@@ -307,0 +307,7 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends TypeMirror> T stripAnnotations(T t) {\n+        return (T)((Type) t).stripMetadata();\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8042981\n+ * @summary Test if annotations are stripped from the results of Types' methods\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * jdk.compiler\n+ * @build JavacTestingAbstractProcessor TestAnnotationStripping\n+ * @compile -processor TestAnnotationStripping -proc:only TestAnnotationStripping.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import static java.util.Objects.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import static javax.lang.model.util.ElementFilter.*;\n+import static javax.tools.Diagnostic.Kind.*;\n+import static javax.tools.StandardLocation.*;\n+\n+\/**\n+ * Test if annotations are stripped from the results of Types' methods\n+ *\/\n+public class TestAnnotationStripping extends JavacTestingAbstractProcessor {\n+    \/**\n+     * Check expected behavior on classes and packages.\n+     *\/\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement hostClassElt = eltUtils.getTypeElement(\"HostClass\");\n+            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TypeAnnotation\").asType();\n+\n+            for (ExecutableElement m : methodsIn(hostClassElt.getEnclosedElements())) {\n+                TypeMirror returnType = m.getReturnType();\n+\n+                System.err.println(\"Checking \" + returnType);\n+\n+\n+                checkExpectedTypeAnnotations(returnType, expectedAnnotation);\n+\n+\/\/                 System.err.print(\"\\tasElement()\");\n+\/\/                 checkEmptyAnnotations(typeUtils.asElement(returnType));\n+\n+                System.err.print(\"\\tcapture()\");\n+                checkEmptyAnnotations(typeUtils.capture(returnType));\n+\n+                System.err.print(\"\\terasure()\");\n+                checkEmptyAnnotations(typeUtils.erasure(returnType));\n+\n+\/\/                 System.err.print(\"\\tgetArrayType()\");\n+\/\/                 checkEmptyAnnotations(typeUtils.getArrayType(returnType));\n+\n+                \/\/ System.out.println(returnType.getAnnotation(TypeAnnotation.class));\n+                \/\/ System.out.println(returnType.getAnnotationsByType(TypeAnnotation.class).length);\n+                \/\/ TypeAnnotation ta = requireNonNull(returnType.getAnnotation(TypeAnnotation.class));\n+\n+                System.err.println();\n+                System.err.println();\n+            }\n+\n+            if (failures > 0)\n+                throw new RuntimeException(failures + \" failures occured.\");\n+        }\n+        return true;\n+    }\n+\n+    private int failures = 0;\n+\n+    void checkExpectedTypeAnnotations(AnnotatedConstruct ac, TypeMirror expectedAnnotation) {\n+        List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+        if (annotations.size() != 1) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations size: \" + annotations);\n+        }\n+        if (!typeUtils.isSameType(annotations.get(0).getAnnotationType(), expectedAnnotation)) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations type: \" + annotations);\n+        }\n+    }\n+\n+    void checkEmptyAnnotations(AnnotatedConstruct ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null)\n+            return;\n+        else {\n+            List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+            if (annotations.size() != 0) {\n+                failures++;\n+                System.err.println(ac.getClass());\n+                System.err.println(\"\\t\\t\\tUnexpected nonzero annotations size: \" + annotations);\n+            }\n+        }\n+    }\n+}\n+\n+\/*\n+ * Class to host annotations for testing\n+ *\/\n+class HostClass {\n+    public static @TypeAnnotation(\"foo\") Integer foo() {return null;}\n+\n+    public static @TypeAnnotation(\"foo2\") int foo2() {return 0;}\n+\n+    public static @TypeAnnotation(\"foo3\") String foo3() {return null;}\n+\n+    public static  java.util.@TypeAnnotation(\"foo4\")Set foo4() {return null;}\n+\n+    \/\/ Erasure on an annotated array not acting properly\n+    \/\/    public static  String@TypeAnnotation(\"foo5\")[] foo5() {return null;}\n+\n+    \/\/ public static java.util.Set < @TypeAnnotation(\"foo5\") String> foo6() {return null;}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface TypeAnnotation {\n+    String value() default \"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}