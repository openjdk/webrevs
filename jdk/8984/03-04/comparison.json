{"files":[{"patch":"@@ -480,12 +480,12 @@\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n-        return null;\n-    }\n-\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n-        @SuppressWarnings(\"unchecked\")\n-        A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n-        return tmp;\n-    }\n+\/\/     @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+\/\/     public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n+\/\/         return null;\n+\/\/     }\n+\n+\n+\/\/     @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+\/\/     public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n+\/\/         @SuppressWarnings(\"unchecked\")\n+\/\/         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);\n+\/\/         return tmp;\n+\/\/     }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.lang.model.type.*;\n@@ -325,0 +326,69 @@\n+\n+    \/**\n+     * Vacuous implementation of javax.lang.model.util.Types to aid\n+     * in test development. Methods with defaults in the interface are\n+     * *not* overridden to allow them to be tested.\n+     *\/\n+    public static class VacuousTypes implements Types {\n+        public VacuousTypes() {}\n+\n+        @Override\n+        public Element asElement(TypeMirror t) {return null;}\n+\n+        @Override\n+        public boolean isSameType(TypeMirror t1, TypeMirror t2) {return false;}\n+\n+        @Override\n+        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean contains(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {return false;}\n+\n+        @Override\n+        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror erasure(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeElement boxedClass(PrimitiveType p) {return null;}\n+\n+        @Override\n+        public PrimitiveType unboxedType(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror capture(TypeMirror t) {return null;}\n+\n+        @Override\n+        public PrimitiveType getPrimitiveType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public NullType getNullType() {return null;}\n+\n+        @Override\n+        public NoType getNoType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public ArrayType getArrayType(TypeMirror componentType) {return null;}\n+\n+        @Override\n+        public WildcardType getWildcardType(TypeMirror extendsBound,\n+                                 TypeMirror superBound) {return null;}\n+\n+        @Override\n+        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+\n+        @Override\n+        public DeclaredType getDeclaredType(DeclaredType containing,\n+                                 TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+        @Override\n+        public TypeMirror asMemberOf(DeclaredType containing, Element element) {return null;}\n+    }\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,2 @@\n+    private Types vacuousTypes = new VacuousTypes();\n+\n@@ -60,1 +62,1 @@\n-            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TypeAnnotation\").asType();\n+            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TestTypeAnnotation\").asType();\n@@ -67,0 +69,2 @@\n+                testVacuous(returnType);\n+                checkEmptyAnnotations(typeUtils.stripAnnotations(returnType));\n@@ -80,5 +84,23 @@\n-                checkEmptyAnnotations(typeUtils.getArrayType(returnType));\n-\n-                \/\/ System.out.println(returnType.getAnnotation(TypeAnnotation.class));\n-                \/\/ System.out.println(returnType.getAnnotationsByType(TypeAnnotation.class).length);\n-                \/\/ TypeAnnotation ta = requireNonNull(returnType.getAnnotation(TypeAnnotation.class));\n+                ArrayType arrayType = typeUtils.getArrayType(returnType);\n+                checkEmptyAnnotations(arrayType);\n+                \/*\n+                 * \"Annotations on the component type are preserved.\"\n+                 *\/\n+                checkEqualTypeAndAnnotations(returnType, arrayType.getComponentType());\n+\n+                if (!returnType.getKind().isPrimitive()) {\n+                    \/*\n+                     * \"Annotations on the bounds are preserved.\"\n+                     *\/\n+                    WildcardType wcType;\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(returnType, null));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getExtendsBound());\n+\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(null,       returnType));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getSuperBound());\n+                }\n+\n+                 System.out.println(returnType.getAnnotation(TestTypeAnnotation.class));\n+                 System.out.println(returnType.getAnnotationsByType(TestTypeAnnotation.class).length);\n+                 TestTypeAnnotation ta = requireNonNull(returnType.getAnnotation(TestTypeAnnotation.class),\n+                                                        returnType.toString());\n@@ -96,0 +118,9 @@\n+    void testVacuous(TypeMirror tm ) {\n+        try {\n+            var result = vacuousTypes.stripAnnotations(tm);\n+            messager.printError(\"Unexpected non-exceptional result returned\" +  result);\n+        } catch(UnsupportedOperationException uoe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n@@ -129,0 +160,13 @@\n+\n+    void checkEqualTypeAndAnnotations(TypeMirror tm1, TypeMirror tm2) {\n+        if (!typeUtils.isSameType(tm1, tm2)) {\n+            failures++;\n+            System.err.printf(\"Unequal types %s and %s.%n\", tm1, tm2);\n+        }\n+\n+        if (!Objects.equals(tm1.getAnnotationMirrors(), tm1.getAnnotationMirrors())) {\n+            failures++;\n+            System.err.printf(\"Unequal annotations on and %s.%n\", tm1, tm2);\n+        }\n+    }\n+\n@@ -135,1 +179,1 @@\n-    public static @TypeAnnotation(\"foo\") Integer foo() {return null;}\n+    public static @TestTypeAnnotation(\"foo\") Integer foo() {return null;}\n@@ -137,1 +181,1 @@\n-    public static @TypeAnnotation(\"foo2\") int foo2() {return 0;}\n+    public static @TestTypeAnnotation(\"foo2\") int foo2() {return 0;}\n@@ -139,1 +183,1 @@\n-    public static @TypeAnnotation(\"foo3\") String foo3() {return null;}\n+    public static @TestTypeAnnotation(\"foo3\") String foo3() {return null;}\n@@ -141,1 +185,1 @@\n-    public static  java.util.@TypeAnnotation(\"foo4\")Set foo4() {return null;}\n+    public static  java.util.@TestTypeAnnotation(\"foo4\")Set foo4() {return null;}\n@@ -143,1 +187,1 @@\n-    public static  String @TypeAnnotation(\"foo5\")[]  foo5() {return null;}\n+    public static  String @TestTypeAnnotation(\"foo5\")[]  foo5() {return null;}\n@@ -145,1 +189,1 @@\n-    public static  java.util. @TypeAnnotation(\"foo6\") Set < @TypeAnnotation(\"foo7\") String> foo6() {return null;}\n+    public static  java.util. @TestTypeAnnotation(\"foo6\") Set < @TestTypeAnnotation(\"foo7\") String> foo6() {return null;}\n@@ -150,1 +194,1 @@\n-@interface TypeAnnotation {\n+@interface TestTypeAnnotation {\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":58,"deletions":14,"binary":false,"changes":72,"status":"modified"}]}