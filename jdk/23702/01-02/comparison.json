{"files":[{"patch":"@@ -2793,1 +2793,1 @@\n-        arrangeTimeout(unit.toNanos(timeout),\n+        arrangeTimeout(unit.toNanos(timeout), \/\/ Implicit null-check of unit\n@@ -2840,1 +2840,1 @@\n-            if (f != null)\n+            if (f != null) \/\/ currently never null\n@@ -2874,1 +2874,1 @@\n-        return new DelayedExecutor(unit.toNanos(delay),\n+        return new DelayedExecutor(unit.toNanos(delay), \/\/ implicit null check\n@@ -2891,1 +2891,2 @@\n-        return new DelayedExecutor(unit.toNanos(delay), ASYNC_POOL);\n+        return new DelayedExecutor(unit.toNanos(delay), \/\/ implicit null check\n+                                   ASYNC_POOL);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,7 +52,9 @@\n-     * queue of tasks submitted by other threads. When ready, tasks\n-     * are relayed to the pool, or run directly if task.isImmediate.\n-     * Immediate mode is designed for internal jdk usages in which the\n-     * (known, non-blocking) action is to cancel, unblock or\n-     * differently relay another async task. If processing encounters\n-     * resource failures (possible when growing heap or ForkJoinPool\n-     * WorkQueue arrays), tasks are cancelled.\n+     * queue of tasks submitted by other threads. When enabled (their\n+     * delays elapse), tasks are relayed to the pool, or run directly\n+     * if task.isImmediate.  Immediate mode is designed for internal\n+     * jdk usages in which the (known, non-blocking) action is to\n+     * cancel, unblock or differently relay another async task (in\n+     * some cases, this relies on user code to trigger async tasks\n+     * actually being async). If processing encounters resource\n+     * failures (possible when growing heap or ForkJoinPool WorkQueue\n+     * arrays), tasks are cancelled.\n@@ -84,1 +86,1 @@\n-     * tryTerminate checks as well as to suppress reactivation while\n+     * termination checks as well as to suppress reactivation while\n@@ -164,1 +166,1 @@\n-     * Inserts the task (if non-null) to pending queue, to add,\n+     * Inserts the task (if nonnull) to pending queue, to add,\n@@ -174,0 +176,1 @@\n+            signal();\n@@ -175,1 +178,0 @@\n-        signal();\n@@ -214,1 +216,1 @@\n-                p.tryStopIfShutdown();\n+                p.tryStopIfShutdown(this);\n@@ -223,1 +225,1 @@\n-     * 3. Trigger all ready tasks by externally submitting them to pool\n+     * 3. Trigger all enabled tasks by externally submitting them to pool\n@@ -228,1 +230,1 @@\n-        p.onDelaySchedulerStart();\n+        p.onDelaySchedulerStart(this);\n@@ -280,1 +282,1 @@\n-            if ((runStatus = p.shutdownStatus()) != 0) {\n+            if ((runStatus = p.shutdownStatus(this)) != 0) {\n@@ -287,1 +289,1 @@\n-            if (n > 0 && h.length > 0) {    \/\/ submit ready tasks\n+            if (n > 0 && h.length > 0) {    \/\/ submit enabled tasks\n@@ -302,1 +304,1 @@\n-                                p.executeReadyScheduledTask(f);\n+                                p.executeEnabledScheduledTask(f);\n@@ -407,1 +409,1 @@\n-            if (n > 0 || p == null || !p.tryStopIfShutdown())\n+            if (n > 0 || p == null || !p.tryStopIfShutdown(this))\n@@ -499,1 +501,1 @@\n-                if (p.shutdownStatus() == 0) {\n+                if (p.shutdownStatus(ds) == 0) {\n@@ -517,1 +519,1 @@\n-            int s; Thread t; ForkJoinPool p; DelayScheduler ds;\n+            int s; ForkJoinPool p; DelayScheduler ds;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.Arrays;\n@@ -50,1 +49,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -146,1 +144,1 @@\n- * tasks when their delays elapse.  schedule methods return\n+ * tasks when their delays elapse.  Scheduling methods return\n@@ -157,4 +155,4 @@\n- * termination. Monitoring methods such as {@link getQueuedTaskCount}\n- * do not include scheduled tasks that are not yet ready to execute,\n- * whcih are reported separately by method {@link\n- * getDelayedTaskCount}.\n+ * termination. Monitoring methods such as {@link #getQueuedTaskCount}\n+ * do not include scheduled tasks that are not yet enabled to execute,\n+ * which are reported separately by method {@link\n+ * #getDelayedTaskCount}.\n@@ -187,1 +185,1 @@\n- * never execute. It is also possible but strongly discouraged to set\n+ * never execute. While possible, it is strongly discouraged to set\n@@ -926,12 +924,14 @@\n-     * its own thread, relaying tasks to the pool to execute as they\n-     * become ready (see method executeReadyScheduledTask).  The only\n-     * other interactions with the delayScheduler are to control\n-     * shutdown and maintain shutdown-related policies in methods\n-     * quiescent() and tryTerminate(). In particular, to conform to\n-     * policies, shutdown-related processing must deal with cases in\n-     * which tasks are submitted before shutdown, but not ready until\n-     * afterwards, in which case they must bypass some screening to be\n-     * allowed to run. Conversely, the DelayScheduler interacts with\n-     * the pool only to check runState status and complete\n-     * termination, using only methods shutdownStatus and\n-     * tryStopIfShutdown.\n+     * its own thread, relaying tasks to the pool to execute when\n+     * their delays elapse (see method executeEnabledScheduledTask).\n+     * The only other interactions with the delayScheduler are to\n+     * control shutdown and maintain shutdown-related policies in\n+     * methods quiescent() and tryTerminate(). In particular, to\n+     * conform to policies, shutdown-related processing must deal with\n+     * cases in which tasks are submitted before shutdown, but not\n+     * ready until afterwards, in which case they must bypass some\n+     * screening to be allowed to run. Conversely, the DelayScheduler\n+     * checks runState status and when enabled, completes termination,\n+     * using only methods shutdownStatus and tryStopIfShutdown. All of\n+     * these methods are final and have signatures referencing\n+     * DelaySchedulers, so cannot conflict with those of any existing\n+     * FJP subclasses.\n@@ -1748,8 +1748,0 @@\n-    \/**\n-     * Returns STOP and SHUTDOWN status (zero if neither), masking or\n-     * truncating out other bits.\n-     *\/\n-    final int shutdownStatus() {\n-        return (int)(runState & (SHUTDOWN | STOP));\n-    }\n-\n@@ -1879,1 +1871,2 @@\n-        if (!tryStopIfShutdown() && phase != 0 && w != null && w.source != DROPPED) {\n+        if ((tryTerminate(false, false) & STOP) == 0L &&\n+            phase != 0 && w != null && w.source != DROPPED) {\n@@ -2585,1 +2578,2 @@\n-     * @param rejectOnShutdown true if throw RJE when shutdown\n+     * @param rejectOnShutdown true if RejectedExecutionException\n+     *        should be thrown when shutdown (else only if terminating)\n@@ -2815,7 +2809,0 @@\n-    \/**\n-     * Tries to stop and possibly terminate if already enabled, return success.\n-     *\/\n-    final boolean tryStopIfShutdown() {\n-        return (tryTerminate(false, false) & STOP) != 0L;\n-    }\n-\n@@ -3456,0 +3443,15 @@\n+    \/**\n+     * Returns STOP and SHUTDOWN status (zero if neither), masking or\n+     * truncating out other bits.\n+     *\/\n+    final int shutdownStatus(DelayScheduler ds) {\n+        return (int)(runState & (SHUTDOWN | STOP));\n+    }\n+\n+    \/**\n+     * Tries to stop and possibly terminate if already enabled, return success.\n+     *\/\n+    final boolean tryStopIfShutdown(DelayScheduler ds) {\n+        return (tryTerminate(false, false) & STOP) != 0L;\n+    }\n+\n@@ -3490,1 +3492,1 @@\n-    final void onDelaySchedulerStart() {\n+    final void onDelaySchedulerStart(DelayScheduler ds) {\n@@ -3497,2 +3499,2 @@\n-     * Arranges execution of a ready task from DelayScheduler, or\n-     * cancels it on error\n+     * Arranges execution of a ScheduledForkJoinTask whose delay has\n+     * elapsed, or cancels it on error\n@@ -3500,1 +3502,1 @@\n-    final void executeReadyScheduledTask(ScheduledForkJoinTask<?> task) {\n+    final void executeEnabledScheduledTask(ScheduledForkJoinTask<?> task) {\n@@ -3526,1 +3528,1 @@\n-            task == null || (runState & SHUTDOWN) != 0L)\n+            (runState & SHUTDOWN) != 0L)\n@@ -3534,1 +3536,1 @@\n-     * delay, At which point it will execute unless explicitly\n+     * delay.  At that point it will execute unless explicitly\n@@ -3556,1 +3558,1 @@\n-            new ScheduledForkJoinTask<Void>(\n+            new ScheduledForkJoinTask<Void>( \/\/ implicit null check of unit\n@@ -3562,1 +3564,1 @@\n-     * after the given delay. At which point it will execute unless\n+     * after the given delay. At that point it will execute unless\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -48,0 +48,1 @@\n+        assertEquals(delayer.getDelayedTaskCount(), 0);\n@@ -61,0 +62,1 @@\n+        assertEquals(delayer.getDelayedTaskCount(), 0);\n","filename":"test\/jdk\/java\/util\/concurrent\/CompletableFuture\/CompletableFutureOrTimeoutExceptionallyTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}