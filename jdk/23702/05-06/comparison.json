{"files":[{"patch":"@@ -221,1 +221,0 @@\n-                p.onDelaySchedulerStart(this);\n@@ -241,13 +240,16 @@\n-        ScheduledForkJoinTask<?>[] h =         \/\/ heap array\n-            new ScheduledForkJoinTask<?>[INITIAL_HEAP_CAPACITY];\n-        int cap = h.length, n = 0, prevRunStatus = 0; \/\/ n is heap size\n-        long parkTime = 0L;                    \/\/ zero for untimed park\n-        for (;;) {                             \/\/ loop until stopped\n-            ScheduledForkJoinTask<?> q, t; int runStatus;\n-            if ((q = pending) == null) {\n-                restingSize = n;\n-                if (active != 0)               \/\/ deactivate and recheck\n-                    U.compareAndSetInt(this, ACTIVE, 1, 0);\n-                else {\n-                    Thread.interrupted();      \/\/ clear before park\n-                    U.park(false, parkTime);\n+        if (p != null) {                           \/\/ currently always true\n+            ScheduledForkJoinTask<?>[] h =         \/\/ heap array\n+                new ScheduledForkJoinTask<?>[INITIAL_HEAP_CAPACITY];\n+            int cap = h.length, n = 0, prevRunStatus = 0; \/\/ n is heap size\n+            long parkTime = 0L;                    \/\/ zero for untimed park\n+            for (;;) {                             \/\/ loop until stopped\n+                ScheduledForkJoinTask<?> q, t; int runStatus;\n+                if ((q = pending) == null) {\n+                    restingSize = n;\n+                    if (active != 0)               \/\/ deactivate and recheck\n+                        U.compareAndSetInt(this, ACTIVE, 1, 0);\n+                    else {\n+                        Thread.interrupted();      \/\/ clear before park\n+                        U.park(false, parkTime);\n+                    }\n+                    q = pending;\n@@ -255,2 +257,0 @@\n-                q = pending;\n-            }\n@@ -258,34 +258,26 @@\n-            while (q != null &&                \/\/ process pending tasks\n-                   (t = (ScheduledForkJoinTask<?>)\n-                    U.getAndSetReference(this, PENDING, null)) != null) {\n-                ScheduledForkJoinTask<?> next;\n-                do {\n-                    int i;\n-                    if ((next = t.nextPending) != null)\n-                        t.nextPending = null;\n-                    if ((i = t.heapIndex) >= 0) {\n-                        t.heapIndex = -1;      \/\/ remove cancelled task\n-                        if (i < cap && h[i] == t)\n-                            n = replace(h, i, n);\n-                    }\n-                    else if (n >= cap || n < 0)\n-                        t.trySetCancelled();   \/\/ couldn't resize\n-                    else {\n-                        long d = t.when;       \/\/ add and sift up\n-                        if (t.status >= 0) {\n-                            ScheduledForkJoinTask<?> parent;\n-                            int k = n++, pk, newCap;\n-                            while (k > 0 &&\n-                                   (parent = h[pk = (k - 1) >>> 2]) != null &&\n-                                   (parent.when > d)) {\n-                                parent.heapIndex = k;\n-                                h[k] = parent;\n-                                k = pk;\n-                            }\n-                            t.heapIndex = k;\n-                            h[k] = t;\n-                            if (n >= cap && (newCap = cap << 1) > cap) {\n-                                ScheduledForkJoinTask<?>[] a = null;\n-                                try {          \/\/ try to resize\n-                                    a = Arrays.copyOf(h, newCap);\n-                                } catch (Error | RuntimeException ex) {\n+                while (q != null &&                \/\/ process pending tasks\n+                       (t = (ScheduledForkJoinTask<?>)\n+                        U.getAndSetReference(this, PENDING, null)) != null) {\n+                    ScheduledForkJoinTask<?> next;\n+                    do {\n+                        int i;\n+                        if ((next = t.nextPending) != null)\n+                            t.nextPending = null;\n+                        if ((i = t.heapIndex) >= 0) {\n+                            t.heapIndex = -1;      \/\/ remove cancelled task\n+                            if (i < cap && h[i] == t)\n+                                n = replace(h, i, n);\n+                        }\n+                        else if (n >= cap || n < 0)\n+                            t.trySetCancelled();   \/\/ couldn't resize\n+                        else {\n+                            long d = t.when;       \/\/ add and sift up\n+                            if (t.status >= 0) {\n+                                ScheduledForkJoinTask<?> parent;\n+                                int k = n++, pk, newCap;\n+                                while (k > 0 &&\n+                                       (parent = h[pk = (k - 1) >>> 2]) != null &&\n+                                       (parent.when > d)) {\n+                                    parent.heapIndex = k;\n+                                    h[k] = parent;\n+                                    k = pk;\n@@ -293,3 +285,12 @@\n-                                if (a != null && a.length == newCap) {\n-                                    cap = newCap;\n-                                    h = a;     \/\/ else keep using old array\n+                                t.heapIndex = k;\n+                                h[k] = t;\n+                                if (n >= cap && (newCap = cap << 1) > cap) {\n+                                    ScheduledForkJoinTask<?>[] a = null;\n+                                    try {          \/\/ try to resize\n+                                        a = Arrays.copyOf(h, newCap);\n+                                    } catch (Error | RuntimeException ex) {\n+                                    }\n+                                    if (a != null && a.length == newCap) {\n+                                        cap = newCap;\n+                                        h = a;     \/\/ else keep using old array\n+                                    }\n@@ -299,4 +300,3 @@\n-                    }\n-                } while ((t = next) != null);\n-                q = pending;\n-            }\n+                    } while ((t = next) != null);\n+                    q = pending;\n+                }\n@@ -304,5 +304,5 @@\n-            if (p != null && (runStatus = p.shutdownStatus(this)) != 0) {\n-                if ((n = tryStop(p, h, n, runStatus, prevRunStatus)) < 0)\n-                    break;\n-                prevRunStatus = runStatus;\n-            }\n+                if ((runStatus = p.shutdownStatus(this)) != 0) {\n+                    if ((n = tryStop(p, h, n, runStatus, prevRunStatus)) < 0)\n+                        break;\n+                    prevRunStatus = runStatus;\n+                }\n@@ -310,14 +310,15 @@\n-            parkTime = 0L;\n-            if (n > 0 && h.length > 0) {    \/\/ submit enabled tasks\n-                long now = now();\n-                do {\n-                    ScheduledForkJoinTask<?> f; int stat;\n-                    if ((f = h[0]) != null) {\n-                        long d = f.when - now;\n-                        if ((stat = f.status) >= 0 && d > 0L) {\n-                            parkTime = d;\n-                            break;\n-                        }\n-                        f.heapIndex = -1;\n-                        if (stat >= 0) {\n-                            if (f.isImmediate)\n+                parkTime = 0L;\n+                if (n > 0 && h.length > 0) {    \/\/ submit enabled tasks\n+                    long now = now();\n+                    do {\n+                        ScheduledForkJoinTask<?> f; int stat;\n+                        if ((f = h[0]) != null) {\n+                            long d = f.when - now;\n+                            if ((stat = f.status) >= 0 && d > 0L) {\n+                                parkTime = d;\n+                                break;\n+                            }\n+                            f.heapIndex = -1;\n+                            if (stat < 0)\n+                                ;               \/\/ already cancelled\n+                            else if (f.isImmediate)\n@@ -325,2 +326,8 @@\n-                            else if (p != null)\n-                                p.executeEnabledScheduledTask(f);\n+                            else {\n+                                try {\n+                                    p.executeEnabledScheduledTask(f);\n+                                }\n+                                catch (Error | RuntimeException ex) {\n+                                    f.trySetCancelled();\n+                                }\n+                            }\n@@ -328,2 +335,2 @@\n-                    }\n-                } while ((n = replace(h, 0, n)) > 0);\n+                    } while ((n = replace(h, 0, n)) > 0);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":87,"deletions":80,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -922,15 +922,15 @@\n-     * methods (via startDelayScheduler, with callback\n-     * onDelaySchedulerStart). The scheduler operates independently in\n-     * its own thread, relaying tasks to the pool to execute when\n-     * their delays elapse (see method executeEnabledScheduledTask).\n-     * The only other interactions with the delayScheduler are to\n-     * control shutdown and maintain shutdown-related policies in\n-     * methods quiescent() and tryTerminate(). In particular,\n-     * processing must deal with cases in which tasks are submitted\n-     * before shutdown, but not enabled until afterwards, in which\n-     * case they must bypass some screening to be allowed to\n-     * run. Conversely, the DelayScheduler checks runState status and\n-     * when enabled, completes termination, using only methods\n-     * shutdownStatus and tryStopIfShutdown. All of these methods are\n-     * final and have signatures referencing DelaySchedulers, so\n-     * cannot conflict with those of any existing FJP subclasses.\n+     * methods (via startDelayScheduler). The scheduler operates\n+     * independently in its own thread, relaying tasks to the pool to\n+     * execute when their delays elapse (see method\n+     * executeEnabledScheduledTask).  The only other interactions with\n+     * the delayScheduler are to control shutdown and maintain\n+     * shutdown-related policies in methods quiescent() and\n+     * tryTerminate(). In particular, processing must deal with cases\n+     * in which tasks are submitted before shutdown, but not enabled\n+     * until afterwards, in which case they must bypass some screening\n+     * to be allowed to run. Conversely, the DelayScheduler checks\n+     * runState status and when enabled, completes termination, using\n+     * only methods shutdownStatus and tryStopIfShutdown. All of these\n+     * methods are final and have signatures referencing\n+     * DelaySchedulers, so cannot conflict with those of any existing\n+     * FJP subclasses.\n@@ -1105,1 +1105,1 @@\n-    static final int MIN_QUEUES_SIZE  = 4;        \/\/ ensure > 1 external slot\n+    static final int MIN_QUEUES_SIZE  = 1 << 4;   \/\/ ensure external slots\n@@ -2583,1 +2583,2 @@\n-        if (r == 0) {\n+        int reuse;                                   \/\/ nonzero if prefer create\n+        if ((reuse = r) == 0) {\n@@ -2587,2 +2588,2 @@\n-        for (;;) {\n-            int n, i, id; WorkQueue[] qs; WorkQueue q, w = null;\n+        for (int probes = 0; ; ++probes) {\n+            int n, i, id; WorkQueue[] qs; WorkQueue q;\n@@ -2594,2 +2595,1 @@\n-                if (w == null)\n-                    w = new WorkQueue(null, id, 0, false);\n+                WorkQueue w = new WorkQueue(null, id, 0, false);\n@@ -2599,4 +2599,2 @@\n-                if (!reject && queues == qs && qs[i] == null) {\n-                    q = qs[i] = w;                   \/\/ else retry\n-                    w = null;\n-                }\n+                if (!reject && queues == qs && qs[i] == null)\n+                    q = qs[i] = w;                   \/\/ else lost race to install\n@@ -2608,0 +2606,1 @@\n+                reuse = 0;\n@@ -2609,1 +2608,7 @@\n-            else if (!q.tryLockPhase())              \/\/ move index\n+            if (reuse == 0 || !q.tryLockPhase()) {   \/\/ move index\n+                if (reuse == 0) {\n+                    if (probes >= n >> 1)\n+                        reuse = r;                   \/\/ stop prefering free slot\n+                }\n+                else if (q != null)\n+                    reuse = 0;                       \/\/ probe on collision\n@@ -2611,0 +2616,1 @@\n+            }\n@@ -3483,9 +3489,0 @@\n-    \/**\n-     * Callback upon starting DelayScheduler\n-     *\/\n-    final void onDelaySchedulerStart(DelayScheduler ds) {\n-        WorkQueue q;           \/\/ set up default submission queue\n-        if ((q = submissionQueue(0, false)) != null)\n-            q.unlockPhase();\n-    }\n-\n@@ -3494,1 +3491,1 @@\n-     * elapsed, or cancels it on error\n+     * elapsed\n@@ -3497,14 +3494,1 @@\n-        if (task != null) {\n-            WorkQueue q;\n-            boolean cancel = false;\n-            try {\n-                if ((q = externalSubmissionQueue(false)) == null)\n-                    cancel = true; \/\/ terminating\n-                else\n-                    q.push(task, this, false);\n-            } catch(Error | RuntimeException ex) {\n-                cancel = true;     \/\/ OOME or VM error\n-            }\n-            if (cancel)\n-                task.trySetCancelled();\n-        }\n+        externalSubmissionQueue(false).push(task, this, false);\n@@ -3694,2 +3678,2 @@\n-        Consumer<ForkJoinTask<V>> action;\n-        TimeoutAction(Consumer<ForkJoinTask<V>> action) {\n+        Consumer<? super ForkJoinTask<V>> action;\n+        TimeoutAction(Consumer<? super ForkJoinTask<V>> action) {\n@@ -3700,1 +3684,1 @@\n-            Consumer<ForkJoinTask<V>> a = action;\n+            Consumer<? super ForkJoinTask<V>> a = action;\n@@ -3741,1 +3725,1 @@\n-                                                 Consumer<ForkJoinTask<V>> timeoutAction) {\n+                                                 Consumer<? super ForkJoinTask<V>> timeoutAction) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":38,"deletions":54,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -161,2 +162,0 @@\n-        int p = probeGenerator.addAndGet(PROBE_INCREMENT);\n-        int probe = (p == 0) ? 1 : p; \/\/ skip 0\n@@ -164,1 +163,1 @@\n-        Thread t = Thread.currentThread();\n+        Thread t = Thread.currentThread(), carrier;\n@@ -166,0 +165,10 @@\n+        int probe = 0; \/\/ if virtual, share probe with carrier\n+        if ((carrier = JLA.currentCarrierThread()) != t &&\n+            (probe = U.getInt(carrier, PROBE)) == 0) {\n+            seed = RandomSupport.mixMurmur64(seeder.getAndAdd(SEEDER_INCREMENT));\n+            U.putLong(carrier, SEED, seed);\n+        }\n+        if (probe == 0 && (probe = probeGenerator.addAndGet(PROBE_INCREMENT)) == 0)\n+            probe = 1; \/\/ skip 0\n+        if (carrier != t)\n+            U.putInt(carrier, PROBE, probe);\n@@ -254,1 +263,1 @@\n-        return U.getInt(Thread.currentThread(), PROBE);\n+        return U.getInt(JLA.currentCarrierThread(), PROBE);\n@@ -265,1 +274,1 @@\n-        U.putInt(Thread.currentThread(), PROBE, probe);\n+        U.putInt(JLA.currentCarrierThread(), PROBE, probe);\n@@ -381,0 +390,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}