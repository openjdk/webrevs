{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import static java.util.concurrent.DelayScheduler.ScheduledForkJoinTask;\n@@ -72,12 +73,9 @@\n- * argument are performed using the {@link ForkJoinPool#commonPool()}\n- * (unless it does not support a parallelism level of at least two, in\n- * which case, a new Thread is created to run each task).  This may be\n- * overridden for non-static methods in subclasses by defining method\n- * {@link #defaultExecutor()}. To simplify monitoring, debugging,\n- * and tracking, all generated asynchronous tasks are instances of the\n- * marker interface {@link AsynchronousCompletionTask}.  Operations\n- * with time-delays can use adapter methods defined in this class, for\n- * example: {@code supplyAsync(supplier, delayedExecutor(timeout,\n- * timeUnit))}.  To support methods with delays and timeouts, this\n- * class maintains at most one daemon thread for triggering and\n- * cancelling actions, not for running them.\n+ * argument, as well as those involving delays are performed using the\n+ * {@link ForkJoinPool#commonPool()}.  The default async Executor may\n+ * be overridden for non-static methods in subclasses by defining\n+ * method {@link #defaultExecutor()}. To simplify monitoring,\n+ * debugging, and tracking, all generated asynchronous tasks are\n+ * instances of the marker interface {@link\n+ * AsynchronousCompletionTask}.  Operations with time-delays can use\n+ * adapter methods defined in this class, for example: {@code\n+ * supplyAsync(supplier, delayedExecutor(timeout, timeUnit))}.\n@@ -476,3 +474,0 @@\n-    private static final boolean USE_COMMON_POOL =\n-        (ForkJoinPool.getCommonPoolParallelism() > 1);\n-\n@@ -480,2 +475,1 @@\n-     * Default executor -- ForkJoinPool.commonPool() unless it cannot\n-     * support parallelism.\n+     * Default Executor\n@@ -483,21 +477,2 @@\n-    private static final Executor ASYNC_POOL = USE_COMMON_POOL ?\n-        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n-\n-    \/** Fallback if ForkJoinPool.commonPool() cannot support parallelism *\/\n-    private static final class ThreadPerTaskExecutor implements Executor {\n-        public void execute(Runnable r) {\n-            Objects.requireNonNull(r);\n-            new Thread(r).start();\n-        }\n-    }\n-\n-    \/**\n-     * Null-checks user executor argument, and translates uses of\n-     * commonPool to ASYNC_POOL in case parallelism disabled.\n-     *\/\n-    static Executor screenExecutor(Executor e) {\n-        if (!USE_COMMON_POOL && e == ForkJoinPool.commonPool())\n-            return ASYNC_POOL;\n-        if (e == null) throw new NullPointerException();\n-        return e;\n-    }\n+    private static final ForkJoinPool ASYNC_POOL =\n+        ForkJoinPool.asyncCommonPool(); \/\/ ensures minimal parallelism\n@@ -705,1 +680,0 @@\n-        if (f == null) throw new NullPointerException();\n@@ -707,0 +681,1 @@\n+        Objects.requireNonNull(f);\n@@ -778,1 +753,0 @@\n-        if (f == null) throw new NullPointerException();\n@@ -780,0 +754,1 @@\n+        Objects.requireNonNull(f);\n@@ -846,1 +821,0 @@\n-        if (f == null) throw new NullPointerException();\n@@ -848,0 +822,1 @@\n+        Objects.requireNonNull(f);\n@@ -927,1 +902,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -990,1 +965,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -1048,1 +1023,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -1108,1 +1083,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -1215,1 +1190,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -1826,1 +1801,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -1862,1 +1837,1 @@\n-        if (f == null) throw new NullPointerException();\n+        Objects.requireNonNull(f);\n@@ -2051,1 +2026,1 @@\n-        return asyncSupplyStage(screenExecutor(executor), supplier);\n+        return asyncSupplyStage(Objects.requireNonNull(executor), supplier);\n@@ -2079,1 +2054,1 @@\n-        return asyncRunStage(screenExecutor(executor), runnable);\n+        return asyncRunStage(Objects.requireNonNull(executor), runnable);\n@@ -2244,1 +2219,1 @@\n-        if (ex == null) throw new NullPointerException();\n+        Objects.requireNonNull(ex);\n@@ -2262,1 +2237,1 @@\n-        return uniApplyStage(screenExecutor(executor), fn);\n+        return uniApplyStage(Objects.requireNonNull(executor), fn);\n@@ -2275,1 +2250,1 @@\n-        return uniAcceptStage(screenExecutor(executor), action);\n+        return uniAcceptStage(Objects.requireNonNull(executor), action);\n@@ -2288,1 +2263,1 @@\n-        return uniRunStage(screenExecutor(executor), action);\n+        return uniRunStage(Objects.requireNonNull(executor), action);\n@@ -2306,1 +2281,1 @@\n-        return biApplyStage(screenExecutor(executor), other, fn);\n+        return biApplyStage(Objects.requireNonNull(executor), other, fn);\n@@ -2324,1 +2299,1 @@\n-        return biAcceptStage(screenExecutor(executor), other, action);\n+        return biAcceptStage(Objects.requireNonNull(executor), other, action);\n@@ -2340,1 +2315,1 @@\n-        return biRunStage(screenExecutor(executor), other, action);\n+        return biRunStage(Objects.requireNonNull(executor), other, action);\n@@ -2356,1 +2331,1 @@\n-        return orApplyStage(screenExecutor(executor), other, fn);\n+        return orApplyStage(Objects.requireNonNull(executor), other, fn);\n@@ -2372,1 +2347,1 @@\n-        return orAcceptStage(screenExecutor(executor), other, action);\n+        return orAcceptStage(Objects.requireNonNull(executor), other, action);\n@@ -2388,1 +2363,1 @@\n-        return orRunStage(screenExecutor(executor), other, action);\n+        return orRunStage(Objects.requireNonNull(executor), other, action);\n@@ -2404,1 +2379,1 @@\n-        return uniComposeStage(screenExecutor(executor), fn);\n+        return uniComposeStage(Objects.requireNonNull(executor), fn);\n@@ -2419,1 +2394,1 @@\n-        return uniWhenCompleteStage(screenExecutor(executor), action);\n+        return uniWhenCompleteStage(Objects.requireNonNull(executor), action);\n@@ -2434,1 +2409,1 @@\n-        return uniHandleStage(screenExecutor(executor), fn);\n+        return uniHandleStage(Objects.requireNonNull(executor), fn);\n@@ -2464,1 +2439,1 @@\n-        return uniExceptionallyStage(screenExecutor(executor), fn);\n+        return uniExceptionallyStage(Objects.requireNonNull(executor), fn);\n@@ -2489,1 +2464,1 @@\n-        return uniComposeExceptionallyStage(screenExecutor(executor), fn);\n+        return uniComposeExceptionallyStage(Objects.requireNonNull(executor), fn);\n@@ -2655,2 +2630,1 @@\n-        if (ex == null) throw new NullPointerException();\n-        result = new AltResult(ex);\n+        result = new AltResult(Objects.requireNonNull(ex));\n@@ -2787,3 +2761,2 @@\n-        if (supplier == null || executor == null)\n-            throw new NullPointerException();\n-        executor.execute(new AsyncSupply<T>(this, supplier));\n+        executor.execute(new AsyncSupply<T>(\n+                             this, Objects.requireNonNull(supplier)));\n@@ -2820,5 +2793,2 @@\n-        if (unit == null)\n-            throw new NullPointerException();\n-        if (result == null)\n-            whenComplete(new Canceller(Delayer.delay(new Timeout(this),\n-                                                     timeout, unit)));\n+        arrangeTimeout(unit.toNanos(timeout), \/\/ Implicit null-check of unit\n+                       new Timeout<T>(this, null, true));\n@@ -2842,6 +2812,2 @@\n-        if (unit == null)\n-            throw new NullPointerException();\n-        if (result == null)\n-            whenComplete(new Canceller(Delayer.delay(\n-                                           new DelayedCompleter<T>(this, value),\n-                                           timeout, unit)));\n+        arrangeTimeout(unit.toNanos(timeout),\n+                       new Timeout<T>(this, value, false));\n@@ -2851,0 +2817,42 @@\n+    \/** Action to complete (possibly exceptionally) on timeout *\/\n+    static final class Timeout<U> implements Runnable {\n+        final CompletableFuture<U> f;\n+        final U value;\n+        final boolean exceptional;\n+        Timeout(CompletableFuture<U> f, U value, boolean exceptional) {\n+            this.f = f; this.value = value; this.exceptional = exceptional;\n+        }\n+        public void run() {\n+            if (f != null && !f.isDone()) {\n+                if (exceptional)\n+                    f.completeExceptionally(new TimeoutException());\n+                else\n+                    f.complete(value);\n+            }\n+        }\n+    }\n+\n+    \/** Action to cancel unneeded timeouts *\/\n+    static final class Canceller implements BiConsumer<Object, Throwable> {\n+        final Future<?> f;\n+        Canceller(Future<?> f) { this.f = f; }\n+        public void accept(Object ignore, Throwable ex) {\n+            if (f != null) \/\/ currently never null\n+                f.cancel(false);\n+        }\n+    }\n+\n+    \/**\n+     * Schedules a timeout action, as well as whenComplete handling to\n+     * cancel the action if not needed.\n+     *\/\n+    private <U> void arrangeTimeout(long nanoDelay, Timeout<U> onTimeout) {\n+        ForkJoinPool e = ASYNC_POOL;\n+        if (result == null) {\n+            ScheduledForkJoinTask<Void> t =  new ScheduledForkJoinTask<Void>(\n+                nanoDelay, 0L, true, onTimeout, null, e);\n+            whenComplete(new Canceller(t));\n+            e.scheduleDelayedTask(t);\n+        }\n+    }\n+\n@@ -2866,3 +2874,2 @@\n-        if (unit == null || executor == null)\n-            throw new NullPointerException();\n-        return new DelayedExecutor(delay, unit, executor);\n+        return new DelayedExecutor(unit.toNanos(delay), \/\/ implicit null check\n+                                   Objects.requireNonNull(executor));\n@@ -2884,3 +2891,2 @@\n-        if (unit == null)\n-            throw new NullPointerException();\n-        return new DelayedExecutor(delay, unit, ASYNC_POOL);\n+        return new DelayedExecutor(unit.toNanos(delay), \/\/ implicit null check\n+                                   ASYNC_POOL);\n@@ -2913,2 +2919,1 @@\n-        if (ex == null) throw new NullPointerException();\n-        return new CompletableFuture<U>(new AltResult(ex));\n+        return new CompletableFuture<U>(new AltResult(Objects.requireNonNull(ex)));\n@@ -2928,29 +2933,1 @@\n-        if (ex == null) throw new NullPointerException();\n-        return new MinimalStage<U>(new AltResult(ex));\n-    }\n-\n-    \/**\n-     * Singleton delay scheduler, used only for starting and\n-     * cancelling tasks.\n-     *\/\n-    static final class Delayer {\n-        static ScheduledFuture<?> delay(Runnable command, long delay,\n-                                        TimeUnit unit) {\n-            return delayer.schedule(command, delay, unit);\n-        }\n-\n-        static final class DaemonThreadFactory implements ThreadFactory {\n-            public Thread newThread(Runnable r) {\n-                Thread t = new Thread(r);\n-                t.setDaemon(true);\n-                t.setName(\"CompletableFutureDelayScheduler\");\n-                return t;\n-            }\n-        }\n-\n-        static final ScheduledThreadPoolExecutor delayer;\n-        static {\n-            (delayer = new ScheduledThreadPoolExecutor(\n-                1, new DaemonThreadFactory())).\n-                setRemoveOnCancelPolicy(true);\n-        }\n+        return new MinimalStage<U>(new AltResult(Objects.requireNonNull(ex)));\n@@ -2962,2 +2939,1 @@\n-        final long delay;\n-        final TimeUnit unit;\n+        final long nanoDelay;\n@@ -2965,2 +2941,2 @@\n-        DelayedExecutor(long delay, TimeUnit unit, Executor executor) {\n-            this.delay = delay; this.unit = unit; this.executor = executor;\n+        DelayedExecutor(long nanoDelay, Executor executor) {\n+            this.nanoDelay = nanoDelay; this.executor = executor;\n@@ -2969,1 +2945,5 @@\n-            Delayer.delay(new TaskSubmitter(executor, r), delay, unit);\n+            ForkJoinPool e = ASYNC_POOL;  \/\/ Use immediate mode to relay task\n+            e.scheduleDelayedTask(\n+                new ScheduledForkJoinTask<Void>(\n+                    nanoDelay, 0L, true,\n+                    new TaskSubmitter(executor, r), null, e));\n@@ -2984,31 +2964,0 @@\n-    \/** Action to completeExceptionally on timeout *\/\n-    static final class Timeout implements Runnable {\n-        final CompletableFuture<?> f;\n-        Timeout(CompletableFuture<?> f) { this.f = f; }\n-        public void run() {\n-            if (f != null && !f.isDone())\n-                f.completeExceptionally(new TimeoutException());\n-        }\n-    }\n-\n-    \/** Action to complete on timeout *\/\n-    static final class DelayedCompleter<U> implements Runnable {\n-        final CompletableFuture<U> f;\n-        final U u;\n-        DelayedCompleter(CompletableFuture<U> f, U u) { this.f = f; this.u = u; }\n-        public void run() {\n-            if (f != null)\n-                f.complete(u);\n-        }\n-    }\n-\n-    \/** Action to cancel unneeded timeouts *\/\n-    static final class Canceller implements BiConsumer<Object, Throwable> {\n-        final Future<?> f;\n-        Canceller(Future<?> f) { this.f = f; }\n-        public void accept(Object ignore, Throwable ex) {\n-            if (f != null && !f.isDone())\n-                f.cancel(false);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":103,"deletions":154,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -0,0 +1,568 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ *\/\n+\n+package java.util.concurrent;\n+\n+import java.util.Arrays;\n+import jdk.internal.misc.Unsafe;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+\/**\n+ * An add-on for ForkJoinPools that provides scheduling for\n+ * delayed and periodic tasks\n+ *\/\n+final class DelayScheduler extends Thread {\n+\n+    \/*\n+     * A DelayScheduler maintains a 4-ary heap (see\n+     * https:\/\/en.wikipedia.org\/wiki\/D-ary_heap) based on trigger\n+     * times (field ScheduledForkJoinTask.when) along with a pending\n+     * queue of tasks submitted by other threads. When enabled (their\n+     * delays elapse), tasks are relayed to the pool, or run directly\n+     * if task.isImmediate.  Immediate mode is designed for internal\n+     * jdk usages in which the (non-blocking) action is to cancel,\n+     * unblock or differently relay another async task (in some cases,\n+     * this relies on user code to trigger async tasks).  If\n+     * processing encounters resource failures (possible when growing\n+     * heap or ForkJoinPool WorkQueue arrays), tasks are cancelled.\n+     *\n+     * To reduce memory contention, the heap is maintained solely via\n+     * local variables in method loop() (forcing noticeable code\n+     * sprawl), recording only the current heap size when blocked to\n+     * allow method canShutDown to conservatively check emptiness, and\n+     * to report approximate current size for monitoring.\n+     *\n+     * The pending queue uses a design similar to ForkJoinTask.Aux\n+     * queues: Incoming requests prepend (Treiber-stack-style) to the\n+     * pending list. The scheduler thread takes and nulls out the\n+     * entire list per step to process them as a batch. The pending\n+     * queue may encounter contention and retries among requesters,\n+     * but much less so versus the scheduler. It is possible to use\n+     * multiple pending queues to reduce this form of contention but\n+     * it doesn't seem worthwhile even under heavy loads.\n+     *\n+     * The implementation relies on the scheduler being a non-virtual\n+     * final Thread subclass.  Field \"active\" records whether the\n+     * scheduler may have any pending tasks (and\/or shutdown actions)\n+     * to process, otherwise parking either indefinitely or until the\n+     * next task deadline. Incoming pending tasks ensure active\n+     * status, unparking if necessary. The scheduler thread sets\n+     * status to inactive when there is apparently no work, and then\n+     * rechecks before actually parking.  The active field takes on a\n+     * negative value on termination, as a sentinel used in pool\n+     * termination checks as well as to suppress reactivation after\n+     * terminating.\n+     *\n+     * We avoid the need for auxilliary data structures by embedding\n+     * pending queue links, heap indices, and pool references inside\n+     * ScheduledForkJoinTasks. (We use the same structure for both\n+     * Runnable and Callable versions, since including an extra field\n+     * in either case doesn't hurt -- it seems mildly preferable for\n+     * these objects to be larger than other kinds of tasks to reduce\n+     * false sharing during possibly frequent bookkeeping updates.) To\n+     * reduce GC pressure and memory retention, these are nulled out\n+     * as soon as possible.\n+     *\n+     * The implementation is designed to accommodate usages in which\n+     * many or even most tasks are cancelled before executing (which\n+     * is typical with IO-based timeouts). The use of a 4-ary heap (in\n+     * which each element has up to 4 children) improves locality, and\n+     * reduces the need for array movement and memory writes compared\n+     * to a standard binary heap, at the expense of more expensive\n+     * replace() operations (with about half the writes but twice the\n+     * reads).  Especially in the presence of cancellations, this is\n+     * often faster because the replace method removes cancelled tasks\n+     * seen while performing sift-down operations, in which case these\n+     * elements are not further recorded or accessed, even before\n+     * processing the removal request generated by method\n+     * ScheduledForkJoinTask.cancel() (which is then a no-op or not\n+     * generated at all).\n+     *\n+     * To ensure that comparisons do not encounter integer wraparound\n+     * errors, times are offset with the most negative possible value\n+     * (nanoTimeOffset) determined during static initialization.\n+     * Negative delays are screened out before use.\n+     *\n+     * Upon noticing pool shutdown, delayed and\/or periodic tasks are\n+     * purged according to pool configuration and policy; the\n+     * scheduler then tries to terminate the pool if the heap is\n+     * empty. The asynchronicity of these steps with respect to pool\n+     * runState weakens guarantees about exactly when purged tasks\n+     * report isCancelled to callers (they do not run, but there may\n+     * be a lag setting their status).\n+     *\/\n+\n+    ForkJoinPool pool;               \/\/ read once and detached upon starting\n+    volatile ScheduledForkJoinTask<?> pending; \/\/ submitted adds and removes\n+    volatile int active;             \/\/ 0: inactive, -1: stopped, +1: running\n+    int restingSize;                 \/\/ written only before parking\n+    volatile int cancelDelayedTasksOnShutdown; \/\/ policy control\n+    int pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;\n+    int pad8, pad9, padA, padB, padC, padD, padE; \/\/ reduce false sharing\n+\n+    private static final int INITIAL_HEAP_CAPACITY = 1 << 6;\n+    private static final int POOL_STOPPING = 1; \/\/ must match ForkJoinPool\n+    static final long nanoTimeOffset = \/\/ Most negative possible time base\n+        Math.min(System.nanoTime(), 0L) + Long.MIN_VALUE;\n+\n+    private static final Unsafe U;     \/\/ for atomic operations\n+    private static final long ACTIVE;\n+    private static final long PENDING;\n+    static {\n+        U = Unsafe.getUnsafe();\n+        Class<DelayScheduler> klass = DelayScheduler.class;\n+        ACTIVE = U.objectFieldOffset(klass, \"active\");\n+        PENDING = U.objectFieldOffset(klass, \"pending\");\n+    }\n+\n+    DelayScheduler(ForkJoinPool p, String name) {\n+        super(name);\n+        setDaemon(true);\n+        pool = p;\n+    }\n+\n+    \/**\n+     * Returns System.nanoTime() with nanoTimeOffset\n+     *\/\n+    static final long now() {\n+        return nanoTimeOffset + System.nanoTime();\n+    }\n+\n+    \/**\n+     * Ensures the scheduler is not parked unless stopped.\n+     * Returns negative if already stopped\n+     *\/\n+    final int signal() {\n+        int state;\n+        if ((state = active) == 0 && U.getAndBitwiseOrInt(this, ACTIVE, 1) == 0)\n+            U.unpark(this);\n+        return state;\n+    }\n+\n+    \/**\n+     * Inserts the task (if nonnull) to pending queue, to add,\n+     * remove, or ignore depending on task status when processed.\n+     *\/\n+    final void pend(ScheduledForkJoinTask<?> task) {\n+        ScheduledForkJoinTask<?> f = pending;\n+        if (task != null) {\n+            do {} while (\n+                f != (f = (ScheduledForkJoinTask<?>)\n+                      U.compareAndExchangeReference(\n+                          this, PENDING, task.nextPending = f, task)));\n+            signal();\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if (momentarily) inactive and heap is empty\n+     *\/\n+    final boolean canShutDown() {\n+        return (active <= 0 && restingSize <= 0);\n+    }\n+\n+    \/**\n+     * Returns the number of elements in heap when last idle\n+     *\/\n+    final int lastStableSize() {\n+        return (active < 0) ? 0 : restingSize;\n+    }\n+\n+    \/**\n+     * Turns on cancelDelayedTasksOnShutdown policy\n+     *\/\n+    final void  cancelDelayedTasksOnShutdown() {\n+        cancelDelayedTasksOnShutdown = 1;\n+        signal();\n+    }\n+\n+    \/**\n+     * Sets up and runs scheduling loop\n+     *\/\n+    public final void run() {\n+        ForkJoinPool p = pool;\n+        pool = null;   \/\/ detach\n+        if (p == null) \/\/ failed initialization\n+            active = -1;\n+        else {\n+            try {\n+                loop(p);\n+            } finally {\n+                restingSize = 0;\n+                active = -1;\n+                p.tryStopIfShutdown(this);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * After initialization, repeatedly:\n+     * 1. If apparently no work,\n+     *    if active, set tentatively inactive,\n+     *    else park until next trigger time, or indefinitely if none\n+     * 2. Process pending tasks in batches, to add or remove from heap\n+     * 3. Check for shutdown, either exiting or preparing for shutdown when empty\n+     * 4. Trigger all enabled tasks by submitting them to pool or run if immediate\n+     *\/\n+    private void loop(ForkJoinPool p) {\n+        if (p != null) {                           \/\/ currently always true\n+            ScheduledForkJoinTask<?>[] h =         \/\/ heap array\n+                new ScheduledForkJoinTask<?>[INITIAL_HEAP_CAPACITY];\n+            int cap = h.length, n = 0, prevRunStatus = 0; \/\/ n is heap size\n+            long parkTime = 0L;                    \/\/ zero for untimed park\n+            for (;;) {                             \/\/ loop until stopped\n+                ScheduledForkJoinTask<?> q, t; int runStatus;\n+                if ((q = pending) == null) {\n+                    restingSize = n;\n+                    if (active != 0)               \/\/ deactivate and recheck\n+                        U.compareAndSetInt(this, ACTIVE, 1, 0);\n+                    else {\n+                        Thread.interrupted();      \/\/ clear before park\n+                        U.park(false, parkTime);\n+                    }\n+                    q = pending;\n+                }\n+\n+                while (q != null &&                \/\/ process pending tasks\n+                       (t = (ScheduledForkJoinTask<?>)\n+                        U.getAndSetReference(this, PENDING, null)) != null) {\n+                    ScheduledForkJoinTask<?> next;\n+                    do {\n+                        int i;\n+                        if ((next = t.nextPending) != null)\n+                            t.nextPending = null;\n+                        if ((i = t.heapIndex) >= 0) {\n+                            t.heapIndex = -1;      \/\/ remove cancelled task\n+                            if (i < cap && h[i] == t)\n+                                n = replace(h, i, n);\n+                        }\n+                        else if (n >= cap || n < 0)\n+                            t.trySetCancelled();   \/\/ couldn't resize\n+                        else {\n+                            long d = t.when;       \/\/ add and sift up\n+                            if (t.status >= 0) {\n+                                ScheduledForkJoinTask<?> parent;\n+                                int k = n++, pk, newCap;\n+                                while (k > 0 &&\n+                                       (parent = h[pk = (k - 1) >>> 2]) != null &&\n+                                       (parent.when > d)) {\n+                                    parent.heapIndex = k;\n+                                    h[k] = parent;\n+                                    k = pk;\n+                                }\n+                                t.heapIndex = k;\n+                                h[k] = t;\n+                                if (n >= cap && (newCap = cap << 1) > cap) {\n+                                    ScheduledForkJoinTask<?>[] a = null;\n+                                    try {          \/\/ try to resize\n+                                        a = Arrays.copyOf(h, newCap);\n+                                    } catch (Error | RuntimeException ex) {\n+                                    }\n+                                    if (a != null && a.length == newCap) {\n+                                        cap = newCap;\n+                                        h = a;     \/\/ else keep using old array\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    } while ((t = next) != null);\n+                    q = pending;\n+                }\n+\n+                if ((runStatus = p.shutdownStatus(this)) != 0) {\n+                    if ((n = tryStop(p, h, n, runStatus, prevRunStatus)) < 0)\n+                        break;\n+                    prevRunStatus = runStatus;\n+                }\n+\n+                parkTime = 0L;\n+                if (n > 0 && h.length > 0) {    \/\/ submit enabled tasks\n+                    long now = now();\n+                    do {\n+                        ScheduledForkJoinTask<?> f; int stat;\n+                        if ((f = h[0]) != null) {\n+                            long d = f.when - now;\n+                            if ((stat = f.status) >= 0 && d > 0L) {\n+                                parkTime = d;\n+                                break;\n+                            }\n+                            f.heapIndex = -1;\n+                            if (stat < 0)\n+                                ;               \/\/ already cancelled\n+                            else if (f.isImmediate)\n+                                f.doExec();\n+                            else {\n+                                try {\n+                                    p.executeEnabledScheduledTask(f);\n+                                }\n+                                catch (Error | RuntimeException ex) {\n+                                    f.trySetCancelled();\n+                                }\n+                            }\n+                        }\n+                    } while ((n = replace(h, 0, n)) > 0);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Replaces removed heap element at index k, along with other\n+     * cancelled nodes found while doing so.\n+     * @return current heap size\n+     *\/\n+    private static int replace(ScheduledForkJoinTask<?>[] h, int k, int n) {\n+        if (h != null && h.length >= n) { \/\/ hoist checks\n+            while (k >= 0 && n > k) {\n+                int alsoReplace = -1;  \/\/ non-negative if cancelled task seen\n+                ScheduledForkJoinTask<?> t = null, u;\n+                long d = 0L;\n+                while (--n > k) {      \/\/ find uncancelled replacement\n+                    if ((u = h[n]) != null) {\n+                        h[n] = null;\n+                        d = u.when;\n+                        if (u.status >= 0) {\n+                            t = u;\n+                            break;\n+                        }\n+                        u.heapIndex = -1;\n+                    }\n+                }\n+                if (t != null) {       \/\/ sift down\n+                    for (int cs; (cs = (k << 2) + 1) < n; ) {\n+                        ScheduledForkJoinTask<?> leastChild = null, c;\n+                        int leastIndex = 0;\n+                        long leastValue = Long.MAX_VALUE;\n+                        for (int ck = cs, j = 4;;) { \/\/ at most 4 children\n+                            if ((c = h[ck]) == null)\n+                                break;\n+                            long cd = c.when;\n+                            if (c.status < 0 && alsoReplace < 0) {\n+                                alsoReplace = ck;    \/\/ at most once per pass\n+                                c.heapIndex = -1;\n+                            }\n+                            else if (leastChild == null || cd < leastValue) {\n+                                leastValue = cd;\n+                                leastIndex = ck;\n+                                leastChild = c;\n+                            }\n+                            if (--j == 0 || ++ck >= n)\n+                                break;\n+                        }\n+                        if (leastChild == null || d <= leastValue)\n+                            break;\n+                        leastChild.heapIndex = k;\n+                        h[k] = leastChild;\n+                        k = leastIndex;\n+                    }\n+                    t.heapIndex = k;\n+                }\n+                h[k] = t;\n+                k = alsoReplace;\n+            }\n+        }\n+        return n;\n+    }\n+\n+    \/**\n+     * Call only when pool run status is nonzero. Possibly cancels\n+     * tasks and stops during pool shutdown and termination. If called\n+     * when shutdown but not stopping, removes tasks according to\n+     * policy if not already done so, and if not empty or pool not\n+     * terminating, returns.  Otherwise, cancels all tasks in heap and\n+     * pending queue.\n+     * @return negative if stop, else current heap size.\n+     *\/\n+    private int tryStop(ForkJoinPool p, ScheduledForkJoinTask<?>[] h, int n,\n+                        int runStatus, int prevRunStatus) {\n+        if ((runStatus & POOL_STOPPING) == 0) {\n+            if (n > 0) {\n+                if (cancelDelayedTasksOnShutdown != 0) {\n+                    cancelAll(h, n);\n+                    n = 0;\n+                }\n+                else if (prevRunStatus == 0 && h != null && h.length >= n) {\n+                    ScheduledForkJoinTask<?> t; int stat; \/\/ remove periodic tasks\n+                    for (int i = n - 1; i >= 0; --i) {\n+                        if ((t = h[i]) != null &&\n+                            ((stat = t.status) < 0 || t.nextDelay != 0L)) {\n+                            t.heapIndex = -1;\n+                            if (stat >= 0)\n+                                t.trySetCancelled();\n+                            n = replace(h, i, n);\n+                        }\n+                    }\n+                }\n+            }\n+            if (n > 0 || p == null || !p.tryStopIfShutdown(this))\n+                return n;       \/\/ check for quiescent shutdown\n+        }\n+        if (n > 0)\n+            cancelAll(h, n);\n+        for (ScheduledForkJoinTask<?> a = (ScheduledForkJoinTask<?>)\n+                 U.getAndSetReference(this, PENDING, null);\n+             a != null; a = a.nextPending)\n+            a.trySetCancelled(); \/\/ clear pending requests\n+        return -1;\n+    }\n+\n+    private static void cancelAll(ScheduledForkJoinTask<?>[] h, int n) {\n+        if (h != null && h.length >= n) {\n+            ScheduledForkJoinTask<?> t;\n+            for (int i = 0; i < n; ++i) {\n+                if ((t = h[i]) != null) {\n+                    h[i] = null;\n+                    t.heapIndex = -1;\n+                    t.trySetCancelled();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Task class for DelayScheduler operations\n+     *\/\n+    @SuppressWarnings(\"serial\")    \/\/ Not designed to be serializable\n+    static final class ScheduledForkJoinTask<T>\n+        extends ForkJoinTask.InterruptibleTask<T>\n+        implements ScheduledFuture<T> {\n+        ForkJoinPool pool;         \/\/ nulled out after use\n+        Runnable runnable;         \/\/ at most one of runnable or callable nonnull\n+        Callable<? extends T> callable;\n+        T result;\n+        ScheduledForkJoinTask<?> nextPending; \/\/ for DelayScheduler pending queue\n+        long when;                  \/\/ nanoTime-based trigger time\n+        final long nextDelay;       \/\/ 0: once; <0: fixedDelay; >0: fixedRate\n+        int heapIndex;              \/\/ if non-negative, index on heap\n+        final boolean isImmediate;  \/\/ run by scheduler vs submitted when ready\n+\n+        \/**\n+         * Creates a new ScheduledForkJoinTask\n+         * @param delay initial delay, in nanoseconds\n+         * @param nextDelay 0 for one-shot, negative for fixed delay,\n+         *        positive for fixed rate, in nanoseconds\n+         * @param isImmediate if action is to be performed\n+         *        by scheduler versus submitting to a WorkQueue\n+         * @param runnable action (null if implementing callable version)\n+         * @param callable function (null if implementing runnable versions)\n+         * @param pool the pool for resubmissions and cancellations\n+         *        (disabled if null)\n+         *\/\n+        public ScheduledForkJoinTask(long delay, long nextDelay,\n+                                     boolean isImmediate, Runnable runnable,\n+                                     Callable<T> callable, ForkJoinPool pool) {\n+            this.when = DelayScheduler.now() + Math.max(delay, 0L);\n+            this.heapIndex = -1;\n+            this.nextDelay = nextDelay;\n+            this.isImmediate = isImmediate;\n+            this.runnable = runnable;\n+            this.callable = callable;\n+            this.pool = pool;\n+        }\n+\n+        public void schedule() { \/\/ relay to pool, to allow independent use\n+            ForkJoinPool p;\n+            if ((p = pool) != null) \/\/ else already run\n+                p.scheduleDelayedTask(this);\n+        }\n+\n+        \/\/ InterruptibleTask methods\n+        public final T getRawResult() { return result; }\n+        public final void setRawResult(T v) { result = v; }\n+        final Object adaptee() { return (runnable != null) ? runnable : callable; }\n+\n+        final T compute() throws Exception {\n+            Callable<? extends T> c; Runnable r;\n+            T res = null;\n+            if ((r = runnable) != null)\n+                r.run();\n+            else if ((c = callable) != null)\n+                res = c.call();\n+            return res;\n+        }\n+\n+        final boolean postExec() {       \/\/ possibly resubmit\n+            long d; ForkJoinPool p; DelayScheduler ds;\n+            if ((d = nextDelay) != 0L && \/\/ is periodic\n+                status >= 0 &&           \/\/ not abnormally completed\n+                (p = pool) != null && (ds = p.delayScheduler) != null) {\n+                if (p.shutdownStatus(ds) == 0) {\n+                    heapIndex = -1;\n+                    if (d < 0L)\n+                        when = DelayScheduler.now() - d;\n+                    else\n+                        when += d;\n+                    ds.pend(this);\n+                    return false;\n+                }\n+                trySetCancelled();       \/\/ pool is shutdown\n+            }\n+            pool = null;                 \/\/ reduce memory retention\n+            runnable = null;\n+            callable = null;\n+            return true;\n+        }\n+\n+        public final boolean cancel(boolean mayInterruptIfRunning) {\n+            int s; ForkJoinPool p; DelayScheduler ds;\n+            if ((s = trySetCancelled()) < 0)\n+                return ((s & (ABNORMAL | THROWN)) == ABNORMAL);\n+            if ((p = pool) != null &&\n+                !interruptIfRunning(mayInterruptIfRunning)) {\n+                pool = null;\n+                runnable = null;\n+                callable = null;\n+                if (heapIndex >= 0 && nextPending == null &&\n+                    (ds = p.delayScheduler) != null)\n+                    ds.pend(this);      \/\/ for heap cleanup\n+            }\n+            return true;\n+        }\n+\n+\n+        \/\/ ScheduledFuture methods\n+        public final long getDelay(TimeUnit unit) {\n+            return unit.convert(when - DelayScheduler.now(), NANOSECONDS);\n+        }\n+        public int compareTo(Delayed other) { \/\/ never used internally\n+            long diff = (other instanceof ScheduledForkJoinTask<?> t) ?\n+                when - t.when : \/\/ avoid nanoTime calls and conversions\n+                getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);\n+            return (diff < 0) ? -1 : (diff > 0) ? 1 : 0;\n+        }\n+    }\n+\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":568,"deletions":0,"binary":false,"changes":568,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -53,0 +54,1 @@\n+import static java.util.concurrent.DelayScheduler.ScheduledForkJoinTask;\n@@ -136,0 +138,22 @@\n+ * <p>Additionally, this class supports {@link\n+ * ScheduledExecutorService} methods to delay or periodically execute\n+ * tasks, as well as method {@link #submitWithTimeout} to cancel tasks\n+ * that take too long. The scheduled functions or actions may create\n+ * and invoke other {@linkplain ForkJoinTask ForkJoinTasks}. Delayed\n+ * actions become <em>enabled<\/em> and behave as ordinary submitted\n+ * tasks when their delays elapse.  Scheduling methods return\n+ * {@linkplain ForkJoinTask ForkJoinTasks} that implement the {@link\n+ * ScheduledFuture} interface. Resource exhaustion encountered after\n+ * initial submission results in task cancellation. When time-based\n+ * methods are used, shutdown policies match the default policies of\n+ * class {@link ScheduledThreadPoolExecutor}: upon {@link #shutdown},\n+ * existing periodic tasks will not re-execute, and the pool\n+ * terminates when quiescent and existing delayed tasks\n+ * complete. Method {@link #cancelDelayedTasksOnShutdown} may be used\n+ * to disable all delayed tasks upon shutdown, and method {@link\n+ * #shutdownNow} may be used to instead unconditionally initiate pool\n+ * termination. Monitoring methods such as {@link #getQueuedTaskCount}\n+ * do not include scheduled tasks that are not yet enabled to execute,\n+ * which are reported separately by method {@link\n+ * #getDelayedTaskCount}.\n+ *\n@@ -140,1 +164,2 @@\n- * - the parallelism level, a non-negative integer\n+ * - the parallelism level, a non-negative integer. Usage is discouraged.\n+ *   Use {@link #setParallelism} instead.\n@@ -158,4 +183,5 @@\n- * are used. It is possible to disable or limit the use of threads in\n- * the common pool by setting the parallelism property to zero, and\/or\n- * using a factory that may return {@code null}. However doing so may\n- * cause unjoined tasks to never be executed.\n+ * are used. It is possible to disable use of threads by using a\n+ * factory that may return {@code null}, in which case some tasks may\n+ * never execute. While possible, it is strongly discouraged to set\n+ * the parallelism property to zero, which may be internally\n+ * overridden in the presence of intrinsically async tasks.\n@@ -174,1 +200,2 @@\n-public class ForkJoinPool extends AbstractExecutorService {\n+public class ForkJoinPool extends AbstractExecutorService\n+    implements ScheduledExecutorService {\n@@ -218,0 +245,1 @@\n+     * 6. Support ScheduledExecutorService methods\n@@ -362,12 +390,12 @@\n-     * with submitting threads, using a form of hashing.  The\n-     * ThreadLocalRandom probe value serves as a hash code for\n-     * choosing existing queues, and may be randomly repositioned upon\n-     * contention with other submitters.  In essence, submitters act\n-     * like workers except that they are restricted to executing local\n-     * tasks that they submitted (or when known, subtasks thereof).\n-     * Insertion of tasks in shared mode requires a lock. We use only\n-     * a simple spinlock (as one role of field \"phase\") because\n-     * submitters encountering a busy queue move to a different\n-     * position to use or create other queues.  They (spin) block when\n-     * registering new queues, or indirectly elsewhere, by revisiting\n-     * later.\n+     * with submitting threads (or carriers when using VirtualThreads)\n+     * using a form of hashing.  The ThreadLocalRandom probe value\n+     * serves as a hash code for choosing existing queues, and may be\n+     * randomly repositioned upon contention with other submitters.\n+     * In essence, submitters act like workers except that they are\n+     * restricted to executing local tasks that they submitted (or\n+     * when known, subtasks thereof).  Insertion of tasks in shared\n+     * mode requires a lock. We use only a simple spinlock (as one\n+     * role of field \"phase\") because submitters encountering a busy\n+     * queue move to a different position to use or create other\n+     * queues.  They (spin) block when registering new queues, or\n+     * indirectly elsewhere, by revisiting later.\n@@ -829,1 +857,7 @@\n-     * none apply if there are no workers.\n+     * none apply if there are no workers. To deal with conflicting\n+     * requirements, uses of the commonPool that require async because\n+     * caller-runs need not apply, ensure threads are enabled (by\n+     * setting parallelism) via method asyncCommonPool before\n+     * proceeding. (In principle, overriding zero parallelism needs to\n+     * ensure at least one worker, but due to other backward\n+     * compatibility contraints, ensures two.)\n@@ -854,1 +888,2 @@\n-     * submitters never run these tasks, even if in the common pool.\n+     * submitters never run these tasks, even if in the common pool\n+     * (as indicated by ForkJoinTask.noUserHelp status bit).\n@@ -883,0 +918,21 @@\n+     * DelayScheduler\n+     * ================\n+     *\n+     * This class supports ScheduledExecutorService methods by\n+     * creating and starting a DelayScheduler on first use of these\n+     * methods (via startDelayScheduler). The scheduler operates\n+     * independently in its own thread, relaying tasks to the pool to\n+     * execute when their delays elapse (see method\n+     * executeEnabledScheduledTask).  The only other interactions with\n+     * the delayScheduler are to control shutdown and maintain\n+     * shutdown-related policies in methods quiescent() and\n+     * tryTerminate(). In particular, processing must deal with cases\n+     * in which tasks are submitted before shutdown, but not enabled\n+     * until afterwards, in which case they must bypass some screening\n+     * to be allowed to run. Conversely, the DelayScheduler checks\n+     * runState status and when enabled, completes termination, using\n+     * only methods shutdownStatus and tryStopIfShutdown. All of these\n+     * methods are final and have signatures referencing\n+     * DelaySchedulers, so cannot conflict with those of any existing\n+     * FJP subclasses.\n+     *\n@@ -953,1 +1009,3 @@\n-     * effectiveness) JVMs about where (not) to place safepoints.\n+     * effectiveness) JVMs about where (not) to place safepoints. All\n+     * public methods screen arguments (mainly null checks) before\n+     * creating or executing tasks.\n@@ -1048,0 +1106,1 @@\n+    static final int MIN_QUEUES_SIZE  = 1 << 4;   \/\/ ensure external slots\n@@ -1217,1 +1276,1 @@\n-         * @param task the task. Caller must ensure non-null.\n+         * @param task the task; no-op if null\n@@ -1225,1 +1284,3 @@\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n+            if ((a = array) != null && (cap = a.length) > 0 && \/\/ else disabled\n+                task != null) {\n+                int pk = task.noUserHelp() + 1;             \/\/ prev slot offset\n@@ -1240,4 +1301,1 @@\n-                if ((room == 0 ||        \/\/ pad for InterruptibleTasks\n-                     a[m & (s - ((internal || task == null ||\n-                                  task.getClass().getSuperclass() !=\n-                                  interruptibleTaskClass) ? 1 : 2))] == null) &&\n+                if ((room == 0 || a[m & (s - pk)] == null) &&\n@@ -1582,5 +1640,0 @@\n-    \/**\n-     * Cached for faster type tests.\n-     *\/\n-    static final Class<?> interruptibleTaskClass;\n-\n@@ -1599,0 +1652,2 @@\n+    final String poolName;\n+    volatile DelayScheduler delayScheduler;  \/\/ lazily constructed\n@@ -1605,0 +1660,1 @@\n+\n@@ -1888,0 +1944,1 @@\n+                DelayScheduler ds;\n@@ -1910,0 +1967,2 @@\n+                else if ((ds = delayScheduler) != null && !ds.canShutDown())\n+                    return 0;\n@@ -1960,1 +2019,1 @@\n-                                int nb = q.base = b + 1;\n+                                int nb = q.base = b + 1, prevSrc = src;\n@@ -1962,1 +2021,1 @@\n-                                w.source = j;             \/\/ volatile\n+                                w.source = src = j;       \/\/ volatile\n@@ -1964,0 +2023,1 @@\n+                                int nh = t.noUserHelp();\n@@ -1965,4 +2025,1 @@\n-                                    ((src != (src = j) ||\n-                                      t.getClass().getSuperclass() ==\n-                                      interruptibleTaskClass) &&\n-                                     a[nb & m] != null))\n+                                    (prevSrc != src || nh != 0) && a[nb & m] != null)\n@@ -2007,2 +2064,2 @@\n-        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n-        for (int k = Math.max(n << 2, SPIN_WAITS << 1);;) {\n+        int k = Math.max(n << 2, SPIN_WAITS << 1);\n+        for (int prechecks = k \/ n;;) {       \/\/ reactivation threshold\n@@ -2017,1 +2074,1 @@\n-                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks <= 0 &&\n@@ -2080,1 +2137,2 @@\n-                     c, nc = (w.stackPred & LMASK) | (UMASK & (c - TC_UNIT))))\n+                     c, nc = ((w.stackPred & LMASK) | (RC_MASK & c) |\n+                              (TC_MASK & (c - TC_UNIT)))))\n@@ -2515,1 +2573,2 @@\n-     * @param isSubmit false if this is for a common pool fork\n+     * @param rejectOnShutdown true if RejectedExecutionException\n+     *        should be thrown when shutdown (else only if terminating)\n@@ -2517,2 +2576,3 @@\n-    private WorkQueue submissionQueue(int r) {\n-        if (r == 0) {\n+    private WorkQueue submissionQueue(int r, boolean rejectOnShutdown) {\n+        int reuse;                                   \/\/ nonzero if prefer create\n+        if ((reuse = r) == 0) {\n@@ -2522,2 +2582,2 @@\n-        for (;;) {\n-            int n, i, id; WorkQueue[] qs; WorkQueue q, w = null;\n+        for (int probes = 0; ; ++probes) {\n+            int n, i, id; WorkQueue[] qs; WorkQueue q;\n@@ -2529,2 +2589,1 @@\n-                if (w == null)\n-                    w = new WorkQueue(null, id, 0, false);\n+                WorkQueue w = new WorkQueue(null, id, 0, false);\n@@ -2532,5 +2591,4 @@\n-                long isShutdown = lockRunState() & SHUTDOWN;\n-                if (isShutdown == 0L && queues == qs && qs[i] == null) {\n-                    q = qs[i] = w;                   \/\/ else retry\n-                    w = null;\n-                }\n+                boolean reject = ((lockRunState() & SHUTDOWN) != 0 &&\n+                                  rejectOnShutdown);\n+                if (!reject && queues == qs && qs[i] == null)\n+                    q = qs[i] = w;                   \/\/ else lost race to install\n@@ -2540,1 +2598,1 @@\n-                if (isShutdown != 0L)\n+                if (reject)\n@@ -2542,0 +2600,1 @@\n+                reuse = 0;\n@@ -2543,1 +2602,7 @@\n-            else if (!q.tryLockPhase())              \/\/ move index\n+            if (reuse == 0 || !q.tryLockPhase()) {   \/\/ move index\n+                if (reuse == 0) {\n+                    if (probes >= n >> 1)\n+                        reuse = r;                   \/\/ stop prefering free slot\n+                }\n+                else if (q != null)\n+                    reuse = 0;                       \/\/ probe on collision\n@@ -2545,1 +2610,2 @@\n-            else if ((runState & SHUTDOWN) != 0L) {\n+            }\n+            else if (rejectOnShutdown && (runState & SHUTDOWN) != 0L) {\n@@ -2555,1 +2621,1 @@\n-    private void poolSubmit(boolean signalIfEmpty, ForkJoinTask<?> task) {\n+    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty, ForkJoinTask<T> task) {\n@@ -2564,1 +2630,1 @@\n-            q = submissionQueue(ThreadLocalRandom.getProbe());\n+            q = submissionQueue(ThreadLocalRandom.getProbe(), true);\n@@ -2567,0 +2633,1 @@\n+        return task;\n@@ -2573,1 +2640,1 @@\n-    final WorkQueue externalSubmissionQueue() {\n+    final WorkQueue externalSubmissionQueue(boolean rejectOnShutdown) {\n@@ -2578,1 +2645,1 @@\n-                 q.tryLockPhase()) ? q : submissionQueue(r));\n+                 q.tryLockPhase()) ? q : submissionQueue(r, rejectOnShutdown));\n@@ -2702,0 +2769,1 @@\n+            long quiet; DelayScheduler ds;\n@@ -2704,1 +2772,1 @@\n-            if (quiescent() > 0)\n+            if ((quiet = quiescent()) > 0)\n@@ -2706,0 +2774,2 @@\n+            else if (quiet == 0 && (ds = delayScheduler) != null)\n+                ds.signal();\n@@ -2709,0 +2779,1 @@\n+            DelayScheduler ds;\n@@ -2710,0 +2781,2 @@\n+            if ((ds = delayScheduler) != null)\n+                ds.signal();\n@@ -2720,0 +2793,2 @@\n+                if ((ds = delayScheduler) != null && ds.signal() >= 0)\n+                    break;\n@@ -2890,6 +2965,3 @@\n-     * @param corePoolSize the number of threads to keep in the pool\n-     * (unless timed out after an elapsed keep-alive). Normally (and\n-     * by default) this is the same value as the parallelism level,\n-     * but may be set to a larger value to reduce dynamic overhead if\n-     * tasks regularly block. Using a smaller value (for example\n-     * {@code 0}) has the same effect as the default.\n+     * @param corePoolSize ignored: used in previous releases of this\n+     * class but no longer applicable. Using {@code 0} maintains\n+     * compatibility across releases.\n@@ -2959,1 +3031,2 @@\n-        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n+        int size = Math.max(MIN_QUEUES_SIZE,\n+                            1 << (33 - Integer.numberOfLeadingZeros(p - 1)));\n@@ -2973,0 +3046,1 @@\n+        this.poolName = name;\n@@ -2982,0 +3056,1 @@\n+        String name = \"ForkJoinPool.commonPool\";\n@@ -3015,1 +3090,3 @@\n-        int size = (p == 0) ? 1 : 1 << (33 - Integer.numberOfLeadingZeros(p-1));\n+        int size = Math.max(MIN_QUEUES_SIZE,\n+                            (p == 0) ? 1 :\n+                            1 << (33 - Integer.numberOfLeadingZeros(p-1)));\n@@ -3024,0 +3101,1 @@\n+        this.poolName = name;\n@@ -3025,1 +3103,1 @@\n-        this.container = SharedThreadContainer.create(\"ForkJoinPool.commonPool\");\n+        this.container = SharedThreadContainer.create(name);\n@@ -3046,0 +3124,10 @@\n+    \/**\n+     * Package-private access to commonPool overriding zero parallelism\n+     *\/\n+    static ForkJoinPool asyncCommonPool() {\n+        ForkJoinPool cp; int p;\n+        if ((p = (cp = common).parallelism) == 0)\n+            U.compareAndSetInt(cp, PARALLELISM, 0, 2);\n+        return cp;\n+    }\n+\n@@ -3066,2 +3154,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n+        poolSubmit(true, Objects.requireNonNull(task));\n@@ -3086,2 +3173,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n+        poolSubmit(true,  Objects.requireNonNull(task));\n@@ -3100,1 +3186,1 @@\n-        poolSubmit(true, (task instanceof ForkJoinTask<?>)\n+        poolSubmit(true, (Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n@@ -3120,3 +3206,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n-        return task;\n+        return poolSubmit(true,  Objects.requireNonNull(task));\n@@ -3132,1 +3216,3 @@\n-        ForkJoinTask<T> t =\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n@@ -3135,3 +3221,1 @@\n-            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task);\n-        poolSubmit(true, t);\n-        return t;\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task));\n@@ -3147,1 +3231,3 @@\n-        ForkJoinTask<T> t =\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n@@ -3150,3 +3236,1 @@\n-            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result);\n-        poolSubmit(true, t);\n-        return t;\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result));\n@@ -3163,1 +3247,4 @@\n-        ForkJoinTask<?> f = (task instanceof ForkJoinTask<?>) ?\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n+            (task instanceof ForkJoinTask<?>) ?\n@@ -3167,3 +3254,1 @@\n-             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null));\n-        poolSubmit(true, f);\n-        return f;\n+             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null)));\n@@ -3191,1 +3276,1 @@\n-        externalSubmissionQueue().push(task, this, false);\n+        externalSubmissionQueue(true).push(task, this, false);\n@@ -3212,3 +3297,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(false, task);\n-        return task;\n+        return poolSubmit(false,  Objects.requireNonNull(task));\n@@ -3352,0 +3435,315 @@\n+    \/\/ Support for delayed tasks\n+\n+    \/**\n+     * Returns STOP and SHUTDOWN status (zero if neither), masking or\n+     * truncating out other bits.\n+     *\/\n+    final int shutdownStatus(DelayScheduler ds) {\n+        return (int)(runState & (SHUTDOWN | STOP));\n+    }\n+\n+    \/**\n+     * Tries to stop and possibly terminate if already enabled, return success.\n+     *\/\n+    final boolean tryStopIfShutdown(DelayScheduler ds) {\n+        return (tryTerminate(false, false) & STOP) != 0L;\n+    }\n+\n+    \/**\n+     *  Creates and starts DelayScheduler\n+     *\/\n+    private DelayScheduler startDelayScheduler() {\n+        DelayScheduler ds;\n+        if ((ds = delayScheduler) == null) {\n+            boolean start = false;\n+            String name = poolName + \"-delayScheduler\";\n+            if (workerNamePrefix == null)\n+                asyncCommonPool();  \/\/ override common parallelism zero\n+            lockRunState();\n+            try {\n+                if ((ds = delayScheduler) == null) {\n+                    ds = delayScheduler = new DelayScheduler(this, name);\n+                    start = true;\n+                }\n+            } finally {\n+                unlockRunState();\n+            }\n+            if (start) { \/\/ start outside of lock\n+                \/\/ exceptions on start passed to (external) callers\n+                SharedThreadContainer ctr;\n+                if ((ctr = container) != null)\n+                    ctr.start(ds);\n+                else\n+                    ds.start();\n+            }\n+        }\n+        return ds;\n+    }\n+\n+    \/**\n+     * Arranges execution of a ScheduledForkJoinTask whose delay has\n+     * elapsed\n+     *\/\n+    final void executeEnabledScheduledTask(ScheduledForkJoinTask<?> task) {\n+        externalSubmissionQueue(false).push(task, this, false);\n+    }\n+\n+    \/**\n+     * Arranges delayed execution of a ScheduledForkJoinTask via the\n+     * DelayScheduler, creating and starting it if necessary.\n+     * @return the task\n+     *\/\n+    final <T> ScheduledForkJoinTask<T> scheduleDelayedTask(ScheduledForkJoinTask<T> task) {\n+        DelayScheduler ds;\n+        if (((ds = delayScheduler) == null &&\n+             (ds = startDelayScheduler()) == null) ||\n+            (runState & SHUTDOWN) != 0L)\n+            throw new RejectedExecutionException();\n+        ds.pend(task);\n+        return task;\n+    }\n+\n+    \/**\n+     * Submits a one-shot task that becomes enabled after the given\n+     * delay.  At that point it will execute unless explicitly\n+     * cancelled, or fail to execute (eventually reporting\n+     * cancellation) when encountering resource exhaustion, or the\n+     * pool is {@link #shutdownNow}, or is {@link #shutdown} when\n+     * otherwise quiescent and {@link #cancelDelayedTasksOnShutdown}\n+     * is in effect.\n+     *\n+     * @param command the task to execute\n+     * @param delay the time from now to delay execution\n+     * @param unit the time unit of the delay parameter\n+     * @return a ForkJoinTask implementing the ScheduledFuture\n+     *         interface, whose {@code get()} method will return\n+     *         {@code null} upon normal completion.\n+     * @throws RejectedExecutionException if the pool is shutdown or\n+     *         submission encounters resource exhaustion.\n+     * @throws NullPointerException if command or unit is null\n+     * @since 25\n+     *\/\n+    public ScheduledFuture<?> schedule(Runnable command,\n+                                       long delay, TimeUnit unit) {\n+        return scheduleDelayedTask(\n+            new ScheduledForkJoinTask<Void>(\n+                unit.toNanos(delay), 0L, false, \/\/ implicit null check of unit\n+                Objects.requireNonNull(command), null, this));\n+    }\n+\n+    \/**\n+     * Submits a value-returning one-shot task that becomes enabled\n+     * after the given delay. At that point it will execute unless\n+     * explicitly cancelled, or fail to execute (eventually reporting\n+     * cancellation) when encountering resource exhaustion, or the\n+     * pool is {@link #shutdownNow}, or is {@link #shutdown} when\n+     * otherwise quiescent and {@link #cancelDelayedTasksOnShutdown}\n+     * is in effect.\n+     *\n+     * @param callable the function to execute\n+     * @param delay the time from now to delay execution\n+     * @param unit the time unit of the delay parameter\n+     * @param <V> the type of the callable's result\n+     * @return a ForkJoinTask implementing the ScheduledFuture\n+     *         interface, whose {@code get()} method will return the\n+     *         value from the callable upon normal completion.\n+     * @throws RejectedExecutionException if the pool is shutdown or\n+     *         submission encounters resource exhaustion.\n+     * @throws NullPointerException if command or unit is null\n+     * @since 25\n+     *\/\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable,\n+                                           long delay, TimeUnit unit) {\n+        return scheduleDelayedTask(\n+            new ScheduledForkJoinTask<V>(\n+                unit.toNanos(delay), 0L, false, null,\n+                Objects.requireNonNull(callable), this));\n+    }\n+\n+    \/**\n+     * Submits a periodic action that becomes enabled first after the\n+     * given initial delay, and subsequently with the given period;\n+     * that is, executions will commence after\n+     * {@code initialDelay}, then {@code initialDelay + period}, then\n+     * {@code initialDelay + 2 * period}, and so on.\n+     *\n+     * <p>The sequence of task executions continues indefinitely until\n+     * one of the following exceptional completions occur:\n+     * <ul>\n+     * <li>The task is {@linkplain Future#cancel explicitly cancelled}\n+     * <li>Method {@link #shutdownNow} is called\n+     * <li>Method {@link #shutdown} is called and the pool is\n+     * otherwise quiescent, in which case existing executions continue\n+     * but subsequent executions do not.\n+     * <li>An execution or the task encounters resource exhaustion.\n+     * <li>An execution of the task throws an exception.  In this case\n+     * calling {@link Future#get() get} on the returned future will throw\n+     * {@link ExecutionException}, holding the exception as its cause.\n+     * <\/ul>\n+     * Subsequent executions are suppressed.  Subsequent calls to\n+     * {@link Future#isDone isDone()} on the returned future will\n+     * return {@code true}.\n+     *\n+     * <p>If any execution of this task takes longer than its period, then\n+     * subsequent executions may start late, but will not concurrently\n+     * execute.\n+     * @param command the task to execute\n+     * @param initialDelay the time to delay first execution\n+     * @param period the period between successive executions\n+     * @param unit the time unit of the initialDelay and period parameters\n+     * @return a ForkJoinTask implementing the ScheduledFuture\n+     *         interface.  The future's {@link Future#get() get()}\n+     *         method will never return normally, and will throw an\n+     *         exception upon task cancellation or abnormal\n+     *         termination of a task execution.\n+     * @throws RejectedExecutionException if the pool is shutdown or\n+     *         submission encounters resource exhaustion.\n+     * @throws NullPointerException if command or unit is null\n+     * @throws IllegalArgumentException if period less than or equal to zero\n+     * @since 25\n+     *\/\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n+                                                  long initialDelay,\n+                                                  long period, TimeUnit unit) {\n+        if (period <= 0L)\n+            throw new IllegalArgumentException();\n+        return scheduleDelayedTask(\n+            new ScheduledForkJoinTask<Void>(\n+                unit.toNanos(initialDelay),\n+                unit.toNanos(period), false,\n+                Objects.requireNonNull(command), null, this));\n+    }\n+\n+    \/**\n+     * Submits a periodic action that becomes enabled first after the\n+     * given initial delay, and subsequently with the given delay\n+     * between the termination of one execution and the commencement of\n+     * the next.\n+     * <p>The sequence of task executions continues indefinitely until\n+     * one of the following exceptional completions occur:\n+     * <ul>\n+     * <li>The task is {@linkplain Future#cancel explicitly cancelled}\n+     * <li>Method {@link #shutdownNow} is called\n+     * <li>Method {@link #shutdown} is called and the pool is\n+     * otherwise quiescent, in which case existing executions continue\n+     * but subsequent executions do not.\n+     * <li>An execution or the task encounters resource exhaustion.\n+     * <li>An execution of the task throws an exception.  In this case\n+     * calling {@link Future#get() get} on the returned future will throw\n+     * {@link ExecutionException}, holding the exception as its cause.\n+     * <\/ul>\n+     * Subsequent executions are suppressed.  Subsequent calls to\n+     * {@link Future#isDone isDone()} on the returned future will\n+     * return {@code true}.\n+     * @param command the task to execute\n+     * @param initialDelay the time to delay first execution\n+     * @param delay the delay between the termination of one\n+     * execution and the commencement of the next\n+     * @param unit the time unit of the initialDelay and delay parameters\n+     * @return a ForkJoinTask implementing the ScheduledFuture\n+     *         interface.  The future's {@link Future#get() get()}\n+     *         method will never return normally, and will throw an\n+     *         exception upon task cancellation or abnormal\n+     *         termination of a task execution.\n+     * @throws RejectedExecutionException if the pool is shutdown or\n+     *         submission encounters resource exhaustion.\n+     * @throws NullPointerException if command or unit is null\n+     * @throws IllegalArgumentException if delay less than or equal to zero\n+     * @since 25\n+     *\/\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n+                                                     long initialDelay,\n+                                                     long delay, TimeUnit unit) {\n+        if (delay <= 0L)\n+            throw new IllegalArgumentException();\n+        return scheduleDelayedTask(\n+            new ScheduledForkJoinTask<Void>(\n+                unit.toNanos(initialDelay),\n+                -unit.toNanos(delay), false, \/\/ negative for fixed delay\n+                Objects.requireNonNull(command), null, this));\n+    }\n+\n+    \/**\n+     * Body of a task performed on timeout of another task\n+     *\/\n+    static final class TimeoutAction<V> implements Runnable {\n+        \/\/ set after construction, nulled after use\n+        ForkJoinTask.CallableWithTimeout<V> task;\n+        Consumer<? super ForkJoinTask<V>> action;\n+        TimeoutAction(Consumer<? super ForkJoinTask<V>> action) {\n+            this.action = action;\n+        }\n+        public void run() {\n+            ForkJoinTask.CallableWithTimeout<V> t = task;\n+            Consumer<? super ForkJoinTask<V>> a = action;\n+            task = null;\n+            action = null;\n+            if (t != null && t.status >= 0) {\n+                if (a == null)\n+                    t.cancel(true);\n+                else {\n+                    a.accept(t);\n+                    t.interruptIfRunning(true);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Submits a task executing the given function, cancelling the\n+     * task or performing a given timeoutAction if not completed\n+     * within the given timeout period. If the optional {@code\n+     * timeoutAction} is null, the task is cancelled (via {@code\n+     * cancel(true)}.  Otherwise, the action is applied and the task\n+     * may be interrupted if running. Actions may include {@link\n+     * ForkJoinTask#complete} to set a replacement value or {@link\n+     * ForkJoinTask#completeExceptionally} to throw an appropriate\n+     * exception. Note that these can succeed only if the task has\n+     * not already completed when the timeoutAction executes.\n+     *\n+     * @param callable the function to execute\n+     * @param <V> the type of the callable's result\n+     * @param timeout the time to wait before cancelling if not completed\n+     * @param timeoutAction if nonnull, an action to perform on\n+     *        timeout, otherwise the default action is to cancel using\n+     *        {@code cancel(true)}.\n+     * @param unit the time unit of the timeout parameter\n+     * @return a Future that can be used to extract result or cancel\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if callable or unit is null\n+     * @since 25\n+     *\/\n+    public <V> ForkJoinTask<V> submitWithTimeout(Callable<V> callable,\n+                                                 long timeout, TimeUnit unit,\n+                                                 Consumer<? super ForkJoinTask<V>> timeoutAction) {\n+        ForkJoinTask.CallableWithTimeout<V> task; TimeoutAction<V> onTimeout;\n+        Objects.requireNonNull(callable);\n+        ScheduledForkJoinTask<Void> timeoutTask =\n+            new ScheduledForkJoinTask<Void>(\n+                unit.toNanos(timeout), 0L, true,\n+                onTimeout = new TimeoutAction<V>(timeoutAction), null, this);\n+        onTimeout.task = task =\n+            new ForkJoinTask.CallableWithTimeout<V>(callable, timeoutTask);\n+        scheduleDelayedTask(timeoutTask);\n+        return poolSubmit(true, task);\n+    }\n+\n+    \/**\n+     * Arranges that scheduled tasks that are not executing and have\n+     * not already been enabled for execution will not be executed and\n+     * will be cancelled upon {@link #shutdown}. This method may be\n+     * invoked either before {@link #shutdown} to take effect upon the\n+     * next call, or afterwards to cancel such tasks, which may then\n+     * allow termination. Note that subsequent executions of periodic\n+     * tasks are always disabled upon shutdown, so this method applies\n+     * meaningfully only to non-periodic tasks.\n+     * @since 25\n+     *\/\n+    public void cancelDelayedTasksOnShutdown() {\n+        DelayScheduler ds;\n+        if ((ds = delayScheduler) != null ||\n+            (ds = startDelayScheduler()) != null)\n+            ds.cancelDelayedTasksOnShutdown();\n+    }\n+\n@@ -3487,1 +3885,3 @@\n-     * granularities.\n+     * granularities.The returned count does not include scheduled\n+     * tasks that are not yet ready to execute, which are reported\n+     * separately by method {@link getDelayedTaskCount}.\n@@ -3494,1 +3894,1 @@\n-        int count = 0;\n+        long count = 0;\n@@ -3523,0 +3923,14 @@\n+    \/**\n+     * Returns an estimate of the number of delayed (including\n+     * periodic) tasks scheduled in this pool that are not yet ready\n+     * to submit for execution. The returned value is innacurate when\n+     * delayed tasks are being processed.\n+     *\n+     * @return an estimate of the number of delayed tasks\n+     * @since 25\n+     *\/\n+    public int getDelayedTaskCount() {\n+        DelayScheduler ds;\n+        return ((ds = delayScheduler) == null ? 0 : ds.lastStableSize());\n+    }\n+\n@@ -3586,0 +4000,1 @@\n+        DelayScheduler ds;\n@@ -3605,1 +4020,2 @@\n-\n+        String delayed = ((ds = delayScheduler) == null ? \"\" :\n+                          \", delayed = \" + ds.lastStableSize());\n@@ -3625,0 +4041,1 @@\n+            delayed +\n@@ -3950,0 +4367,1 @@\n+        Objects.requireNonNull(runnable);\n@@ -3957,0 +4375,1 @@\n+        Objects.requireNonNull(callable);\n@@ -3984,1 +4403,0 @@\n-        interruptibleTaskClass = ForkJoinTask.InterruptibleTask.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":517,"deletions":99,"binary":false,"changes":616,"status":"modified"},{"patch":"@@ -276,0 +276,2 @@\n+    static final int NUH_BIT        = 24;      \/\/ no external caller helping\n+    static final int NO_USER_HELP   = 1 << NUH_BIT;\n@@ -295,0 +297,6 @@\n+    final int noUserHelp() {     \/\/ nonvolatile read; return 0 or 1\n+        return (U.getInt(this, STATUS) & NO_USER_HELP) >>> NUH_BIT;\n+    }\n+    final void setNoUserHelp() { \/\/ for use in constructors only\n+        U.putInt(this, STATUS, NO_USER_HELP);\n+    }\n@@ -333,8 +341,3 @@\n-        for (;;) {\n-            if ((s = status) < 0)\n-                break;\n-            if (casStatus(s, s | (DONE | ABNORMAL))) {\n-                signalWaiters();\n-                break;\n-            }\n-        }\n+        if ((s = status) >= 0 &&\n+            (s = getAndBitwiseOrStatus(DONE | ABNORMAL)) >= 0)\n+            signalWaiters();\n@@ -484,1 +487,1 @@\n-        Thread t; boolean internal; int s;\n+        Thread t; boolean internal; int s, ss;\n@@ -495,1 +498,1 @@\n-                   (this instanceof InterruptibleTask) && !internal ? status :\n+                   !internal && ((ss = status) & NO_USER_HELP) != 0 ? ss :\n@@ -645,1 +648,1 @@\n-            q = (p = ForkJoinPool.common).externalSubmissionQueue();\n+            q = (p = ForkJoinPool.common).externalSubmissionQueue(false);\n@@ -1163,1 +1166,1 @@\n-        status = 0;\n+        status &= NO_USER_HELP;\n@@ -1417,1 +1420,2 @@\n-        return new AdaptedRunnableAction(runnable);\n+        return new AdaptedRunnableAction(\n+            Objects.requireNonNull(runnable));\n@@ -1431,1 +1435,2 @@\n-        return new AdaptedRunnable<T>(runnable, result);\n+        return new AdaptedRunnable<T>(\n+            Objects.requireNonNull(runnable), result);\n@@ -1445,1 +1450,2 @@\n-        return new AdaptedCallable<T>(callable);\n+        return new AdaptedCallable<T>(\n+            Objects.requireNonNull(callable));\n@@ -1463,1 +1469,2 @@\n-        return new AdaptedInterruptibleCallable<T>(callable);\n+        return new AdaptedInterruptibleCallable<T>(\n+            Objects.requireNonNull(callable));\n@@ -1482,1 +1489,2 @@\n-        return new AdaptedInterruptibleRunnable<T>(runnable, result);\n+        return new AdaptedInterruptibleRunnable<T>(\n+            Objects.requireNonNull(runnable), result);\n@@ -1500,1 +1508,2 @@\n-        return new AdaptedInterruptibleRunnable<Void>(runnable, null);\n+        return new AdaptedInterruptibleRunnable<Void>(\n+            Objects.requireNonNull(runnable), null);\n@@ -1559,1 +1568,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1581,1 +1589,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1604,1 +1611,0 @@\n-            Objects.requireNonNull(callable);\n@@ -1639,0 +1645,3 @@\n+        InterruptibleTask() {\n+            setNoUserHelp();\n+        }\n@@ -1658,0 +1667,3 @@\n+            return postExec();\n+        }\n+        boolean postExec() { \/\/ cleanup and return completion status to doExec\n@@ -1660,0 +1672,12 @@\n+        final boolean interruptIfRunning(boolean enabled) {\n+             Thread t;\n+             if ((t = runner) == null) \/\/ return false if not running\n+                 return false;\n+             if (enabled) {\n+                 try {\n+                     t.interrupt();\n+                 } catch (Throwable ignore) {\n+                 }\n+             }\n+             return true;\n+        }\n@@ -1661,11 +1685,5 @@\n-            Thread t;\n-            if (trySetCancelled() >= 0) {\n-                if (mayInterruptIfRunning && (t = runner) != null) {\n-                    try {\n-                        t.interrupt();\n-                    } catch (Throwable ignore) {\n-                    }\n-                }\n-                return true;\n-            }\n-            return isCancelled();\n+            int s;\n+            if ((s = trySetCancelled()) < 0)\n+                return ((s & (ABNORMAL | THROWN)) == ABNORMAL);\n+            interruptIfRunning(mayInterruptIfRunning);\n+            return true;\n@@ -1693,1 +1711,0 @@\n-            Objects.requireNonNull(callable);\n@@ -1712,1 +1729,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1730,1 +1746,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1796,1 +1811,3 @@\n-                for (Callable<T> c : tasks)\n+                for (Callable<T> c : tasks) {\n+                    if (c == null)\n+                        throw new NullPointerException();\n@@ -1799,0 +1816,1 @@\n+                }\n@@ -1825,1 +1843,0 @@\n-            Objects.requireNonNull(callable);\n@@ -1860,0 +1877,35 @@\n+\n+    \/**\n+     * Adapter for Callable-based interruptible tasks with timeout actions.\n+     *\/\n+    @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+    static final class CallableWithTimeout<T> extends InterruptibleTask<T> {\n+        Callable<? extends T> callable; \/\/ nulled out after use\n+        ForkJoinTask<?> timeoutAction;\n+        T result;\n+        CallableWithTimeout(Callable<? extends T> callable,\n+                            ForkJoinTask<?> timeoutAction) {\n+            this.callable = callable;\n+            this.timeoutAction = timeoutAction;\n+        }\n+        public final T getRawResult() { return result; }\n+        public final void setRawResult(T v) { result = v; }\n+        final Object adaptee() { return callable; }\n+        final T compute() throws Exception {\n+            Callable<? extends T> c;\n+            return ((c = callable) != null) ? c.call() : null;\n+        }\n+        final boolean postExec() {       \/\/ cancel timeout action\n+            ForkJoinTask<?> t;\n+            callable = null;\n+            if ((t = timeoutAction) != null) {\n+                timeoutAction = null;\n+                try {\n+                    t.cancel(false);\n+                } catch (Error | RuntimeException ex) {\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":89,"deletions":37,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -209,16 +209,0 @@\n-    \/\/ default Executor setup; nearly the same as CompletableFuture\n-\n-    \/**\n-     * Default executor -- ForkJoinPool.commonPool() unless it cannot\n-     * support parallelism.\n-     *\/\n-    private static final Executor ASYNC_POOL =\n-        (ForkJoinPool.getCommonPoolParallelism() > 1) ?\n-        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\n-\n-    \/** Fallback if ForkJoinPool.commonPool() cannot support parallelism *\/\n-    private static final class ThreadPerTaskExecutor implements Executor {\n-        ThreadPerTaskExecutor() {}      \/\/ prevent access constructor creation\n-        public void execute(Runnable r) { new Thread(r).start(); }\n-    }\n-\n@@ -319,1 +303,1 @@\n-        this(ASYNC_POOL, Flow.defaultBufferSize(), null);\n+        this(ForkJoinPool.asyncCommonPool(), Flow.defaultBufferSize(), null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SubmissionPublisher.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -161,2 +162,0 @@\n-        int p = probeGenerator.addAndGet(PROBE_INCREMENT);\n-        int probe = (p == 0) ? 1 : p; \/\/ skip 0\n@@ -164,1 +163,1 @@\n-        Thread t = Thread.currentThread();\n+        Thread t = Thread.currentThread(), carrier;\n@@ -166,0 +165,10 @@\n+        int probe = 0; \/\/ if virtual, share probe with carrier\n+        if ((carrier = JLA.currentCarrierThread()) != t &&\n+            (probe = U.getInt(carrier, PROBE)) == 0) {\n+            seed = RandomSupport.mixMurmur64(seeder.getAndAdd(SEEDER_INCREMENT));\n+            U.putLong(carrier, SEED, seed);\n+        }\n+        if (probe == 0 && (probe = probeGenerator.addAndGet(PROBE_INCREMENT)) == 0)\n+            probe = 1; \/\/ skip 0\n+        if (carrier != t)\n+            U.putInt(carrier, PROBE, probe);\n@@ -236,7 +245,9 @@\n-     * collision space. When it does collide, it is pseudo-randomly\n-     * adjusted (using a Marsaglia XorShift). The nextSecondarySeed\n-     * method is used in the same contexts as ThreadLocalRandom, but\n-     * only for transient usages such as random adaptive spin\/block\n-     * sequences for which a cheap RNG suffices and for which it could\n-     * in principle disrupt user-visible statistical properties of the\n-     * main ThreadLocalRandom if we were to use it.\n+     * collision space, based on carrier threads in the case of\n+     * VirtualThreads to reduce the expected collision rate. When it\n+     * does collide, it is pseudo-randomly adjusted (using a Marsaglia\n+     * XorShift). The nextSecondarySeed method is used in the same\n+     * contexts as ThreadLocalRandom, but only for transient usages\n+     * such as random adaptive spin\/block sequences for which a cheap\n+     * RNG suffices and for which it could in principle disrupt\n+     * user-visible statistical properties of the main\n+     * ThreadLocalRandom if we were to use it.\n@@ -244,2 +255,2 @@\n-     * Note: Because of package-protection issues, versions of some\n-     * these methods also appear in some subpackage classes.\n+     * Note: jdk SharedSecrets are used enable use in jdk classes\n+     * outside this package.\n@@ -254,1 +265,1 @@\n-        return U.getInt(Thread.currentThread(), PROBE);\n+        return U.getInt(JLA.currentCarrierThread(), PROBE);\n@@ -265,1 +276,1 @@\n-        U.putInt(Thread.currentThread(), PROBE, probe);\n+        U.putInt(JLA.currentCarrierThread(), PROBE, probe);\n@@ -381,0 +392,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -389,0 +402,6 @@\n+                    public int getThreadLocalRandomProbe() {\n+                        return getProbe();\n+                    }\n+                    public int advanceThreadLocalRandomProbe(int r) {\n+                        return advanceProbe(r);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n@@ -191,2 +193,1 @@\n-     * Returns the probe value for the current thread.\n-     * Duplicated from ThreadLocalRandom because of packaging restrictions.\n+     * Returns the ThreadLocalRandom probe value for the current carrier thread.\n@@ -195,1 +196,1 @@\n-        return (int) THREAD_PROBE.get(Thread.currentThread());\n+        return TLR.getThreadLocalRandomProbe();\n@@ -200,2 +201,1 @@\n-     * given thread.\n-     * Duplicated from ThreadLocalRandom because of packaging restrictions.\n+     * given carrier thread.\n@@ -204,5 +204,1 @@\n-        probe ^= probe << 13;   \/\/ xorshift\n-        probe ^= probe >>> 17;\n-        probe ^= probe << 5;\n-        THREAD_PROBE.set(Thread.currentThread(), probe);\n-        return probe;\n+        return TLR.advanceThreadLocalRandomProbe(probe);\n@@ -374,0 +370,3 @@\n+    private static final JavaUtilConcurrentTLRAccess TLR =\n+        SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n@@ -377,1 +376,0 @@\n-    private static final VarHandle THREAD_PROBE;\n@@ -383,6 +381,0 @@\n-        try {\n-            MethodHandles.Lookup l2 = MethodHandles.privateLookupIn(Thread.class, l1);\n-            THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+    int getThreadLocalRandomProbe();\n+    int advanceThreadLocalRandomProbe(int r);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilConcurrentTLRAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ForkJoinPool;\n@@ -35,1 +35,0 @@\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n@@ -39,1 +38,1 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -42,14 +41,1 @@\n-    static final BlockingQueue<Runnable> delayerQueue;\n-    static {\n-        try {\n-            var delayerClass = Class.forName(\"java.util.concurrent.CompletableFuture$Delayer\",\n-                                             true,\n-                                             CompletableFuture.class.getClassLoader());\n-            var delayerField = delayerClass.getDeclaredField(\"delayer\");\n-            delayerField.setAccessible(true);\n-            delayerQueue = ((ScheduledThreadPoolExecutor)delayerField.get(null)).getQueue();\n-        } catch (Throwable t) {\n-            throw new ExceptionInInitializerError(t);\n-        }\n-    }\n-\n+    \/\/ updated February 2025 to adapt to CompletableFuture DelayScheduler changes\n@@ -61,1 +47,2 @@\n-        assertTrue(delayerQueue.peek() == null);\n+        ForkJoinPool delayer = ForkJoinPool.commonPool();\n+        assertEquals(delayer.getDelayedTaskCount(), 0);\n@@ -63,1 +50,0 @@\n-        assertTrue(delayerQueue.peek() != null);\n@@ -65,1 +51,1 @@\n-        while (delayerQueue.peek() != null) {\n+        while (delayer.getDelayedTaskCount() != 0) {\n@@ -75,1 +61,2 @@\n-        assertTrue(delayerQueue.peek() == null);\n+        ForkJoinPool delayer = ForkJoinPool.commonPool();\n+        assertEquals(delayer.getDelayedTaskCount(), 0);\n@@ -77,1 +64,0 @@\n-        assertTrue(delayerQueue.peek() != null);\n@@ -79,1 +65,1 @@\n-        while (delayerQueue.peek() != null) {\n+        while (delayer.getDelayedTaskCount() != 0) {\n@@ -83,0 +69,1 @@\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/CompletableFuture\/CompletableFutureOrTimeoutExceptionallyTest.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -104,1 +105,1 @@\n-            f.get(randomExpiredTimeout(), randomTimeUnit());\n+            f.get(1, NANOSECONDS);\n@@ -661,2 +662,0 @@\n-    static final boolean defaultExecutorIsCommonPool\n-        = ForkJoinPool.getCommonPoolParallelism() > 1;\n@@ -753,2 +752,1 @@\n-                mustEqual(defaultExecutorIsCommonPool,\n-                             (ForkJoinPool.commonPool() == ForkJoinTask.getPool()));\n+                mustEqual(ForkJoinPool.commonPool(), ForkJoinTask.getPool());\n@@ -3797,4 +3795,1 @@\n-        if (ForkJoinPool.getCommonPoolParallelism() > 1)\n-            assertSame(e, c);\n-        else\n-            assertNotSame(e, c);\n+        assertSame(e, c);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,11 @@\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n@@ -39,0 +50,7 @@\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -41,0 +59,4 @@\n+import java.util.stream.Stream;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -219,0 +241,412 @@\n+\n+    \/\/ additions for ScheduledExecutorService\n+\n+\n+    \/**\n+     * delayed schedule of callable successfully executes after delay\n+     *\/\n+    public void testSchedule1() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(1);\n+            Callable<Boolean> task = new CheckedCallable<>() {\n+                public Boolean realCall() {\n+                    done.countDown();\n+                    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+                    return Boolean.TRUE;\n+                }};\n+            Future<Boolean> f = p.schedule(task, timeoutMillis(), MILLISECONDS);\n+            assertSame(Boolean.TRUE, f.get());\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+            assertEquals(0L, done.getCount());\n+        }\n+    }\n+\n+    \/**\n+     * delayed schedule of callable successfully executes after delay\n+     * even if shutdown.\n+     *\/\n+    public void testSchedule1b() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(1);\n+            Callable<Boolean> task = new CheckedCallable<>() {\n+                public Boolean realCall() {\n+                    done.countDown();\n+                    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+                    return Boolean.TRUE;\n+                }};\n+            Future<Boolean> f = p.schedule(task, timeoutMillis(), MILLISECONDS);\n+            p.shutdown();\n+            assertSame(Boolean.TRUE, f.get());\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+            assertEquals(0L, done.getCount());\n+        }\n+    }\n+\n+    \/**\n+     * delayed schedule of runnable successfully executes after delay\n+     *\/\n+    public void testSchedule3() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(1);\n+            Runnable task = new CheckedRunnable() {\n+                public void realRun() {\n+                    done.countDown();\n+                    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+                }};\n+            Future<?> f = p.schedule(task, timeoutMillis(), MILLISECONDS);\n+            await(done);\n+            assertNull(f.get(LONG_DELAY_MS, MILLISECONDS));\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+        }\n+    }\n+\n+    \/**\n+     * scheduleAtFixedRate executes runnable after given initial delay\n+     *\/\n+    public void testSchedule4() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(1);\n+            Runnable task = new CheckedRunnable() {\n+                public void realRun() {\n+                    done.countDown();\n+                    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+                }};\n+            ScheduledFuture<?> f =\n+                p.scheduleAtFixedRate(task, timeoutMillis(),\n+                                      LONG_DELAY_MS, MILLISECONDS);\n+            await(done);\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+            f.cancel(true);\n+        }\n+    }\n+\n+    \/**\n+     * scheduleAtFixedRate with 0 initial delay re-rexecutes\n+     *\/\n+    public void testSchedule4a() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(2);\n+            Runnable task = new Runnable() {\n+                public void run() {\n+                    done.countDown();\n+                }};\n+            ScheduledFuture<?> f =\n+                p.scheduleAtFixedRate(task, 0L, timeoutMillis(),\n+                                      MILLISECONDS);\n+            await(done);\n+            f.cancel(true);\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+        }\n+    }\n+\n+    \/**\n+     * scheduleWithFixedDelay executes runnable after given initial delay\n+     *\/\n+    public void testSchedule5() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(1);\n+            Runnable task = new CheckedRunnable() {\n+                public void realRun() {\n+                    done.countDown();\n+                    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+                }};\n+            ScheduledFuture<?> f =\n+                p.scheduleWithFixedDelay(task, timeoutMillis(),\n+                                         LONG_DELAY_MS, MILLISECONDS);\n+            await(done);\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+            f.cancel(true);\n+        }\n+    }\n+\n+    \/**\n+     * scheduleWithFixedDelay with 0 initial delay re-rexecutes\n+     *\/\n+    public void testSchedule5a() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final long startTime = System.nanoTime();\n+            final CountDownLatch done = new CountDownLatch(2);\n+            Runnable task = new Runnable() {\n+                public void run() {\n+                    done.countDown();\n+                }};\n+            ScheduledFuture<?> f =\n+                p.scheduleWithFixedDelay(task, 0L, timeoutMillis(),\n+                                         MILLISECONDS);\n+            await(done);\n+            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\n+            f.cancel(true);\n+        }\n+    }\n+\n+    static class RunnableCounter implements Runnable {\n+        AtomicInteger count = new AtomicInteger(0);\n+        public void run() { count.getAndIncrement(); }\n+    }\n+\n+    \/**\n+     * scheduleAtFixedRate executes series of tasks at given rate.\n+     * Eventually, it must hold that:\n+     *   cycles - 1 <= elapsedMillis\/delay < cycles\n+     * Additionally, periodic tasks are not run after shutdown.\n+     *\/\n+    public void testFixedRateSequence() throws InterruptedException {\n+        final ForkJoinPool p = new ForkJoinPool(4);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            for (int delay = 1; delay <= LONG_DELAY_MS; delay *= 3) {\n+                final long startTime = System.nanoTime();\n+                final int cycles = 8;\n+                final CountDownLatch done = new CountDownLatch(cycles);\n+                final Runnable task = new CheckedRunnable() {\n+                    public void realRun() { done.countDown(); }};\n+                final ScheduledFuture<?> periodicTask =\n+                    p.scheduleAtFixedRate(task, 0, delay, MILLISECONDS);\n+                final int totalDelayMillis = (cycles - 1) * delay;\n+                await(done, totalDelayMillis + LONG_DELAY_MS);\n+                final long elapsedMillis = millisElapsedSince(startTime);\n+                assertTrue(elapsedMillis >= totalDelayMillis);\n+                if (elapsedMillis <= cycles * delay)\n+                    return;\n+                periodicTask.cancel(true); \/\/ retry with longer delay\n+            }\n+            fail(\"unexpected execution rate\");\n+        }\n+    }\n+    \/**\n+     * scheduleWithFixedDelay executes series of tasks with given\n+     * period.  Eventually, it must hold that each task starts at\n+     * least delay and at most 2 * delay after the termination of the\n+     * previous task. Additionally, periodic tasks are not run after\n+     * shutdown.\n+     *\/\n+    public void testFixedDelaySequence() throws InterruptedException {\n+        final ForkJoinPool p = new ForkJoinPool(1);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            for (int delay = 1; delay <= LONG_DELAY_MS; delay *= 3) {\n+                final long startTime = System.nanoTime();\n+                final AtomicLong previous = new AtomicLong(startTime);\n+                final AtomicBoolean tryLongerDelay = new AtomicBoolean(false);\n+                final int cycles = 8;\n+                final CountDownLatch done = new CountDownLatch(cycles);\n+                final int d = delay;\n+                final Runnable task = new CheckedRunnable() {\n+                    public void realRun() {\n+                        long now = System.nanoTime();\n+                        long elapsedMillis\n+                            = NANOSECONDS.toMillis(now - previous.get());\n+                        if (done.getCount() == cycles) { \/\/ first execution\n+                            if (elapsedMillis >= d)\n+                                tryLongerDelay.set(true);\n+                        } else {\n+                            if (elapsedMillis >= 2 * d)\n+                                tryLongerDelay.set(true);\n+                        }\n+                        previous.set(now);\n+                        done.countDown();\n+                    }};\n+                final ScheduledFuture<?> periodicTask =\n+                    p.scheduleWithFixedDelay(task, 0, delay, MILLISECONDS);\n+                final int totalDelayMillis = (cycles - 1) * delay;\n+                await(done, totalDelayMillis + cycles * LONG_DELAY_MS);\n+                final long elapsedMillis = millisElapsedSince(startTime);\n+                assertTrue(elapsedMillis >= totalDelayMillis);\n+                if (!tryLongerDelay.get())\n+                    return;\n+                periodicTask.cancel(true); \/\/ retry with longer delay\n+            }\n+            fail(\"unexpected execution rate\");\n+        }\n+    }\n+\n+    \/**\n+     * Submitting null tasks throws NullPointerException\n+     *\/\n+    public void testNullTaskSubmission() {\n+        final ForkJoinPool p = new ForkJoinPool(1);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            assertNullTaskSubmissionThrowsNullPointerException(p);\n+        }\n+    }\n+\n+    \/**\n+     * Submitted tasks are rejected when shutdown\n+     *\/\n+    public void testSubmittedTasksRejectedWhenShutdown() throws InterruptedException {\n+        final ForkJoinPool p = new ForkJoinPool(4);\n+        final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        final CountDownLatch threadsStarted = new CountDownLatch(p.getParallelism());\n+        final CountDownLatch done = new CountDownLatch(1);\n+        final Runnable r = () -> {\n+            threadsStarted.countDown();\n+            for (;;) {\n+                try {\n+                    done.await();\n+                    return;\n+                } catch (InterruptedException shutdownNowDeliberatelyIgnored) {}\n+            }};\n+        final Callable<Boolean> c = () -> {\n+            threadsStarted.countDown();\n+            for (;;) {\n+                try {\n+                    done.await();\n+                    return Boolean.TRUE;\n+                } catch (InterruptedException shutdownNowDeliberatelyIgnored) {}\n+            }};\n+\n+        try (PoolCleaner cleaner = cleaner(p, done)) {\n+            for (int i = p.getParallelism(); i-- > 0; ) {\n+                switch (rnd.nextInt(4)) {\n+                case 0: p.execute(r); break;\n+                case 1: assertFalse(p.submit(r).isDone()); break;\n+                case 2: assertFalse(p.submit(r, Boolean.TRUE).isDone()); break;\n+                case 3: assertFalse(p.submit(c).isDone()); break;\n+                }\n+            }\n+\n+            await(threadsStarted);\n+            p.shutdown();\n+            done.countDown();   \/\/ release blocking tasks\n+            assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\n+        }\n+    }\n+\n+    \/**\n+     * A fixed delay task with overflowing period should not prevent a\n+     * one-shot task from executing.\n+     * https:\/\/bugs.openjdk.org\/browse\/JDK-8051859\n+     *\/\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    public void testScheduleWithFixedDelay_overflow() throws Exception {\n+        final CountDownLatch delayedDone = new CountDownLatch(1);\n+        final CountDownLatch immediateDone = new CountDownLatch(1);\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            final Runnable delayed = () -> {\n+                delayedDone.countDown();\n+                p.submit(() -> immediateDone.countDown());\n+            };\n+            p.scheduleWithFixedDelay(delayed, 0L, Long.MAX_VALUE, SECONDS);\n+            await(delayedDone);\n+            await(immediateDone);\n+        }\n+    }\n+\n+    \/**\n+     * shutdownNow cancels tasks that were not run\n+     *\/\n+    public void testShutdownNow_delayedTasks() throws InterruptedException {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        List<ScheduledFuture<?>> tasks = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Runnable r = new NoOpRunnable();\n+            tasks.add(p.schedule(r, 9, SECONDS));\n+            tasks.add(p.scheduleAtFixedRate(r, 9, 9, SECONDS));\n+            tasks.add(p.scheduleWithFixedDelay(r, 9, 9, SECONDS));\n+        }\n+        p.shutdownNow();\n+        assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\n+        for (ScheduledFuture<?> task : tasks) {\n+            assertTrue(task.isDone());\n+        }\n+        assertTrue(p.isTerminated());\n+    }\n+\n+    \/**\n+     * submitWithTimeout (eventually) cancels task after timeout\n+     *\/\n+    public void testSubmitWithTimeoutCancels() throws InterruptedException {\n+        final ForkJoinPool p = ForkJoinPool.commonPool();\n+        Callable<Boolean> c = new Callable<Boolean>() {\n+            public Boolean call() throws Exception {\n+                Thread.sleep(LONGER_DELAY_MS); return Boolean.TRUE; }};\n+        ForkJoinTask<?> task = p.submitWithTimeout(c, 1, NANOSECONDS, null);\n+        Thread.sleep(timeoutMillis());\n+        assertTrue(task.isCancelled());\n+    }\n+\n+    static final class SubmitWithTimeoutException extends RuntimeException {}\n+\n+    \/**\n+     * submitWithTimeout using complete completes after timeout\n+     *\/\n+    public void testSubmitWithCompleterTimeoutCompletes() throws InterruptedException {\n+        final ForkJoinPool p = ForkJoinPool.commonPool();\n+        Callable<Item> c = new Callable<Item>() {\n+            public Item call() throws Exception {\n+                Thread.sleep(LONGER_DELAY_MS); return one; }};\n+        ForkJoinTask<Item> task = p.submitWithTimeout(\n+            c, 1, NANOSECONDS,\n+            (ForkJoinTask<Item> t) ->\n+            t.complete(two));\n+        Thread.sleep(timeoutMillis());\n+        assertEquals(task.join(), two);\n+    }\n+\n+    \/**\n+     * submitWithTimeout using completeExceptionally throws after timeout\n+     *\/\n+    public void testSubmitWithTimeoutThrows() throws InterruptedException {\n+        final ForkJoinPool p = ForkJoinPool.commonPool();\n+        Callable<Boolean> c = new Callable<Boolean>() {\n+            public Boolean call() throws Exception {\n+                Thread.sleep(LONGER_DELAY_MS); return Boolean.TRUE; }};\n+        ForkJoinTask<Boolean> task = p.submitWithTimeout(\n+            c, 1, NANOSECONDS,\n+            (ForkJoinTask<Boolean> t) ->\n+            t.completeExceptionally(new SubmitWithTimeoutException()));\n+        Thread.sleep(timeoutMillis());\n+        try {\n+            task.join();\n+            shouldThrow();\n+        }\n+        catch (Exception ex) {\n+            assertTrue(ex instanceof SubmitWithTimeoutException);\n+        }\n+    }\n+\n+    \/**\n+     * submitWithTimeout doesn't cancel if completed before timeout\n+     *\/\n+    public void testSubmitWithTimeout_NoTimeout() throws InterruptedException {\n+        final ForkJoinPool p = ForkJoinPool.commonPool();\n+        Callable<Boolean> c = new Callable<Boolean>() {\n+            public Boolean call() throws Exception {\n+                return Boolean.TRUE; }};\n+        ForkJoinTask<?> task = p.submitWithTimeout(c, LONGER_DELAY_MS, MILLISECONDS, null);\n+        Thread.sleep(timeoutMillis());\n+        assertFalse(task.isCancelled());\n+        assertEquals(task.join(), Boolean.TRUE);\n+    }\n+\n+    \/**\n+     * A delayed task completes (possibly abnormally) if shutdown after\n+     * calling cancelDelayedTasksOnShutdown()\n+     *\/\n+    public void testCancelDelayedTasksOnShutdown() throws Exception {\n+        final ForkJoinPool p = new ForkJoinPool(2);\n+        p.cancelDelayedTasksOnShutdown();\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            Callable<Boolean> task = new CheckedCallable<>() {\n+                public Boolean realCall() {\n+                    return Boolean.TRUE;\n+                }};\n+            Future<Boolean> f = p.schedule(task, LONGER_DELAY_MS, MILLISECONDS);\n+            p.shutdown();\n+            assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\n+            assertTrue(f.isDone());\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool20Test.java","additions":434,"deletions":0,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -181,4 +181,1 @@\n-        if (ForkJoinPool.getCommonPoolParallelism() > 1)\n-            assertSame(e, c);\n-        else\n-            assertNotSame(e, c);\n+        assertSame(e, c);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SubmissionPublisherTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}