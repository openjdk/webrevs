{"files":[{"patch":"@@ -55,6 +55,5 @@\n-     * jdk usages in which the (known, non-blocking) action is to\n-     * cancel, unblock or differently relay another async task (in\n-     * some cases, this relies on user code to trigger async tasks\n-     * actually being async). If processing encounters resource\n-     * failures (possible when growing heap or ForkJoinPool WorkQueue\n-     * arrays), tasks are cancelled.\n+     * jdk usages in which the (non-blocking) action is to cancel,\n+     * unblock or differently relay another async task (in some cases,\n+     * this relies on user code to trigger async tasks).  If\n+     * processing encounters resource failures (possible when growing\n+     * heap or ForkJoinPool WorkQueue arrays), tasks are cancelled.\n@@ -86,1 +85,1 @@\n-     * termination checks as well as to suppress reactivation while\n+     * termination checks as well as to suppress reactivation after\n@@ -89,0 +88,7 @@\n+     * We avoid the need for auxilliary data structures by embedding\n+     * pending queue links, heap indices, and pool references inside\n+     * ScheduledForkJoinTasks. (We use the same structure for both\n+     * Runnable and Callable versions, since including an extra field\n+     * in either case doesn't hurt.) To reduce GC pressure and memory\n+     * retention, these are nulled out as soon as possible.\n+     *\n@@ -97,2 +103,2 @@\n-     * faster because the replace method removes any cancelled tasks\n-     * seen while performing sift-down operations, in which case these\n+     * faster because the replace method removes cancelled tasks seen\n+     * while performing sift-down operations, in which case these\n@@ -100,2 +106,2 @@\n-     * processing the removal request generated by\n-     * ScheduledForkJoinTask.cancel() (which is then a no-op if\n+     * processing the removal request generated by method\n+     * ScheduledForkJoinTask.cancel() (which is then a no-op or not\n@@ -327,1 +333,1 @@\n-        if (h != null && h.length >= n) {\n+        if (h != null && h.length >= n) { \/\/ hoist checks\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -148,4 +148,4 @@\n- * methods are used, shutdown policies are based on the default\n- * policies of class {@link ScheduledThreadPoolExecutor}: upon {@link\n- * #shutdown}, existing periodic tasks will not re-execute, and the\n- * pool terminates when quiescent and existing delayed tasks\n+ * methods are used, shutdown policies match the default policies of\n+ * class {@link ScheduledThreadPoolExecutor}: upon {@link #shutdown},\n+ * existing periodic tasks will not re-execute, and the pool\n+ * terminates when quiescent and existing delayed tasks\n@@ -928,10 +928,9 @@\n-     * methods quiescent() and tryTerminate(). In particular, to\n-     * conform to policies, shutdown-related processing must deal with\n-     * cases in which tasks are submitted before shutdown, but not\n-     * ready until afterwards, in which case they must bypass some\n-     * screening to be allowed to run. Conversely, the DelayScheduler\n-     * checks runState status and when enabled, completes termination,\n-     * using only methods shutdownStatus and tryStopIfShutdown. All of\n-     * these methods are final and have signatures referencing\n-     * DelaySchedulers, so cannot conflict with those of any existing\n-     * FJP subclasses.\n+     * methods quiescent() and tryTerminate(). In particular,\n+     * processing must deal with cases in which tasks are submitted\n+     * before shutdown, but not enabled until afterwards, in which\n+     * case they must bypass some screening to be allowed to\n+     * run. Conversely, the DelayScheduler checks runState status and\n+     * when enabled, completes termination, using only methods\n+     * shutdownStatus and tryStopIfShutdown. All of these methods are\n+     * final and have signatures referencing DelaySchedulers, so\n+     * cannot conflict with those of any existing FJP subclasses.\n@@ -1009,1 +1008,3 @@\n-     * effectiveness) JVMs about where (not) to place safepoints.\n+     * effectiveness) JVMs about where (not) to place safepoints. All\n+     * public methods screen arguments (mainly null checks) before\n+     * creating or executing tasks.\n@@ -2620,1 +2621,1 @@\n-    private void poolSubmit(boolean signalIfEmpty, ForkJoinTask<?> task) {\n+    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty, ForkJoinTask<T> task) {\n@@ -2632,0 +2633,1 @@\n+        return task;\n@@ -2963,6 +2965,3 @@\n-     * @param corePoolSize the number of threads to keep in the pool\n-     * (unless timed out after an elapsed keep-alive). Normally (and\n-     * by default) this is the same value as the parallelism level,\n-     * but may be set to a larger value to reduce dynamic overhead if\n-     * tasks regularly block. Using a smaller value (for example\n-     * {@code 0}) has the same effect as the default.\n+     * @param corePoolSize ignored: used in previous versions of this\n+     * class but no longer applicable. Using {@code 0} maintains\n+     * compatibility across versions.\n@@ -3155,2 +3154,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n+        poolSubmit(true, Objects.requireNonNull(task));\n@@ -3175,2 +3173,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n+        poolSubmit(true,  Objects.requireNonNull(task));\n@@ -3189,1 +3186,1 @@\n-        poolSubmit(true, (task instanceof ForkJoinTask<?>)\n+        poolSubmit(true, (Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n@@ -3209,3 +3206,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(true, task);\n-        return task;\n+        return poolSubmit(true,  Objects.requireNonNull(task));\n@@ -3221,1 +3216,3 @@\n-        ForkJoinTask<T> t =\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n@@ -3224,3 +3221,1 @@\n-            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task);\n-        poolSubmit(true, t);\n-        return t;\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task));\n@@ -3236,1 +3231,3 @@\n-        ForkJoinTask<T> t =\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n@@ -3239,3 +3236,1 @@\n-            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result);\n-        poolSubmit(true, t);\n-        return t;\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result));\n@@ -3252,1 +3247,4 @@\n-        ForkJoinTask<?> f = (task instanceof ForkJoinTask<?>) ?\n+        Objects.requireNonNull(task);\n+        return poolSubmit(\n+            true,\n+            (task instanceof ForkJoinTask<?>) ?\n@@ -3256,3 +3254,1 @@\n-             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null));\n-        poolSubmit(true, f);\n-        return f;\n+             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null)));\n@@ -3301,3 +3297,1 @@\n-        Objects.requireNonNull(task);\n-        poolSubmit(false, task);\n-        return task;\n+        return poolSubmit(false,  Objects.requireNonNull(task));\n@@ -3556,1 +3550,0 @@\n-        Objects.requireNonNull(command);\n@@ -3558,2 +3551,3 @@\n-            new ScheduledForkJoinTask<Void>( \/\/ implicit null check of unit\n-                unit.toNanos(delay), 0L, false, command, null, this));\n+            new ScheduledForkJoinTask<Void>(\n+                unit.toNanos(delay), 0L, false, \/\/ implicit null check of unit\n+                Objects.requireNonNull(command), null, this));\n@@ -3585,1 +3579,0 @@\n-        Objects.requireNonNull(callable);\n@@ -3588,1 +3581,2 @@\n-                unit.toNanos(delay), 0L, false, null, callable, this));\n+                unit.toNanos(delay), 0L, false, null,\n+                Objects.requireNonNull(callable), this));\n@@ -3636,1 +3630,0 @@\n-        Objects.requireNonNull(command);\n@@ -3642,2 +3635,2 @@\n-                unit.toNanos(period),\n-                false, command, null, this));\n+                unit.toNanos(period), false,\n+                Objects.requireNonNull(command), null, this));\n@@ -3686,1 +3679,0 @@\n-        Objects.requireNonNull(command);\n@@ -3692,2 +3684,2 @@\n-                -unit.toNanos(delay),  \/\/ negative for fixed delay\n-                false, command, null, this));\n+                -unit.toNanos(delay), false, \/\/ negative for fixed delay\n+                Objects.requireNonNull(command), null, this));\n@@ -3731,1 +3723,1 @@\n-     * exception. Note that these will only succeed if the task has\n+     * exception. Note that these can succeed only if the task has\n@@ -3759,2 +3751,1 @@\n-        poolSubmit(true, task);\n-        return task;\n+        return poolSubmit(true, task);\n@@ -4398,0 +4389,1 @@\n+        Objects.requireNonNull(runnable);\n@@ -4405,0 +4397,1 @@\n+        Objects.requireNonNull(callable);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":52,"deletions":59,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1413,1 +1413,2 @@\n-        return new AdaptedRunnableAction(runnable);\n+        return new AdaptedRunnableAction(\n+            Objects.requireNonNull(runnable));\n@@ -1427,1 +1428,2 @@\n-        return new AdaptedRunnable<T>(runnable, result);\n+        return new AdaptedRunnable<T>(\n+            Objects.requireNonNull(runnable), result);\n@@ -1441,1 +1443,2 @@\n-        return new AdaptedCallable<T>(callable);\n+        return new AdaptedCallable<T>(\n+            Objects.requireNonNull(callable));\n@@ -1459,1 +1462,2 @@\n-        return new AdaptedInterruptibleCallable<T>(callable);\n+        return new AdaptedInterruptibleCallable<T>(\n+            Objects.requireNonNull(callable));\n@@ -1478,1 +1482,2 @@\n-        return new AdaptedInterruptibleRunnable<T>(runnable, result);\n+        return new AdaptedInterruptibleRunnable<T>(\n+            Objects.requireNonNull(runnable), result);\n@@ -1496,1 +1501,2 @@\n-        return new AdaptedInterruptibleRunnable<Void>(runnable, null);\n+        return new AdaptedInterruptibleRunnable<Void>(\n+            Objects.requireNonNull(runnable), null);\n@@ -1555,1 +1561,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1577,1 +1582,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1600,1 +1604,0 @@\n-            Objects.requireNonNull(callable);\n@@ -1698,1 +1701,0 @@\n-            Objects.requireNonNull(callable);\n@@ -1717,1 +1719,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1735,1 +1736,0 @@\n-            Objects.requireNonNull(runnable);\n@@ -1801,1 +1801,3 @@\n-                for (Callable<T> c : tasks)\n+                for (Callable<T> c : tasks) {\n+                    if (c == null)\n+                        throw new NullPointerException();\n@@ -1804,0 +1806,1 @@\n+                }\n@@ -1830,1 +1833,0 @@\n-            Objects.requireNonNull(callable);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"}]}