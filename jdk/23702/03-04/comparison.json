{"files":[{"patch":"@@ -92,2 +92,5 @@\n-     * in either case doesn't hurt.) To reduce GC pressure and memory\n-     * retention, these are nulled out as soon as possible.\n+     * in either case doesn't hurt -- it seems mildly preferable for\n+     * these objects to be larger than other kinds of tasks to reduce\n+     * false sharing during possibly frequent bookkeeping updates.) To\n+     * reduce GC pressure and memory retention, these are nulled out\n+     * as soon as possible.\n@@ -98,7 +101,7 @@\n-     * which each element has up to 4 children) improves locality and\n-     * reduces movement and memory writes compared to a standard\n-     * binary heap, at the expense of more expensive replace()\n-     * operations (with about half the writes but twice the reads).\n-     * Especially in the presence of cancellations, this is often\n-     * faster because the replace method removes cancelled tasks seen\n-     * while performing sift-down operations, in which case these\n+     * which each element has up to 4 children) improves locality, and\n+     * reduces the need for array movement and memory writes compared\n+     * to a standard binary heap, at the expense of more expensive\n+     * replace() operations (with about half the writes but twice the\n+     * reads).  Especially in the presence of cancellations, this is\n+     * often faster because the replace method removes cancelled tasks\n+     * seen while performing sift-down operations, in which case these\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -861,3 +861,3 @@\n-     * proceeding. (In principle, these need to ensure at least one\n-     * worker, but due to other backward compatibility contraints,\n-     * ensure two.)\n+     * proceeding. (In principle, overriding zero parallelism needs to\n+     * ensure at least one worker, but due to other backward\n+     * compatibility contraints, ensures two.)\n@@ -2071,2 +2071,2 @@\n-        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n-        for (int k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n+        int prechecks = 3;                    \/\/ reactivation threshold\n+        for (int k = Math.max(n << 2, SPIN_WAITS << 1);;) {\n@@ -2965,1 +2965,1 @@\n-     * @param corePoolSize ignored: used in previous versions of this\n+     * @param corePoolSize ignored: used in previous releases of this\n@@ -2967,1 +2967,1 @@\n-     * compatibility across versions.\n+     * compatibility across releases.\n@@ -3129,2 +3129,2 @@\n-        if ((p = (cp = common).parallelism) < 2)\n-            U.compareAndSetInt(cp, PARALLELISM, p, 2);\n+        if ((p = (cp = common).parallelism) == 0)\n+            U.compareAndSetInt(cp, PARALLELISM, 0, 2);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -104,1 +105,1 @@\n-            f.get(randomExpiredTimeout(), randomTimeUnit());\n+            f.get(1, NANOSECONDS);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-            for (int i = p.getParallelism(); i--> 0; ) {\n+            for (int i = p.getParallelism(); i-- > 0; ) {\n@@ -523,1 +523,0 @@\n-\n@@ -569,1 +568,1 @@\n-     * submitWithTimeout cancels task after timeout\n+     * submitWithTimeout (eventually) cancels task after timeout\n@@ -632,0 +631,1 @@\n+        assertEquals(task.join(), Boolean.TRUE);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool20Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}