{"files":[{"patch":"@@ -1276,1 +1276,1 @@\n-         * @param task the task. Caller must ensure non-null.\n+         * @param task the task; no-op if null\n@@ -1284,1 +1284,3 @@\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n+            if ((a = array) != null && (cap = a.length) > 0 && \/\/ else disabled\n+                task != null) {\n+                int pk = task.noUserHelp() + 1;             \/\/ prev slot offset\n@@ -1299,3 +1301,1 @@\n-                if ((room == 0 ||        \/\/ pad if no caller-run\n-                     a[m & (s - ((internal || task == null ||\n-                                  task.noUserHelp() == 0) ? 1 : 2))] == null) &&\n+                if ((room == 0 || a[m & (s - pk)] == null) &&\n@@ -2019,1 +2019,1 @@\n-                                int nb = q.base = b + 1;\n+                                int nb = q.base = b + 1, prevSrc = src;\n@@ -2021,2 +2021,1 @@\n-                                int ts = t.status;\n-                                w.source = j;             \/\/ volatile\n+                                w.source = src = j;       \/\/ volatile\n@@ -2024,0 +2023,1 @@\n+                                int nh = t.noUserHelp();\n@@ -2025,2 +2025,1 @@\n-                                    ((src != (src = j) || t.noUserHelp() != 0) &&\n-                                     a[nb & m] != null))\n+                                    (prevSrc != src || nh != 0) && a[nb & m] != null)\n@@ -2065,2 +2064,2 @@\n-        int prechecks = 3;                    \/\/ reactivation threshold\n-        for (int k = Math.max(n << 2, SPIN_WAITS << 1);;) {\n+        int k = Math.max(n << 2, SPIN_WAITS << 1);\n+        for (int prechecks = k \/ n;;) {       \/\/ reactivation threshold\n@@ -2075,1 +2074,1 @@\n-                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks <= 0 &&\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -276,1 +276,2 @@\n-    static final int NO_USER_HELP   = 1 << 24; \/\/ no external caller-run helping\n+    static final int NUH_BIT        = 24;      \/\/ no external caller helping\n+    static final int NO_USER_HELP   = 1 << NUH_BIT;\n@@ -296,2 +297,2 @@\n-    final int noUserHelp() {    \/\/ nonvolatile read\n-        return U.getInt(this, STATUS) & NO_USER_HELP;\n+    final int noUserHelp() {     \/\/ nonvolatile read; return 0 or 1\n+        return (U.getInt(this, STATUS) & NO_USER_HELP) >>> NUH_BIT;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -245,7 +245,9 @@\n-     * collision space. When it does collide, it is pseudo-randomly\n-     * adjusted (using a Marsaglia XorShift). The nextSecondarySeed\n-     * method is used in the same contexts as ThreadLocalRandom, but\n-     * only for transient usages such as random adaptive spin\/block\n-     * sequences for which a cheap RNG suffices and for which it could\n-     * in principle disrupt user-visible statistical properties of the\n-     * main ThreadLocalRandom if we were to use it.\n+     * collision space, based on carrier threads in the case of\n+     * VirtualThreads to reduce the expected collision rate. When it\n+     * does collide, it is pseudo-randomly adjusted (using a Marsaglia\n+     * XorShift). The nextSecondarySeed method is used in the same\n+     * contexts as ThreadLocalRandom, but only for transient usages\n+     * such as random adaptive spin\/block sequences for which a cheap\n+     * RNG suffices and for which it could in principle disrupt\n+     * user-visible statistical properties of the main\n+     * ThreadLocalRandom if we were to use it.\n@@ -253,2 +255,2 @@\n-     * Note: Because of package-protection issues, versions of some\n-     * these methods also appear in some subpackage classes.\n+     * Note: jdk SharedSecrets are used enable use in jdk classes\n+     * outside this package.\n@@ -400,0 +402,6 @@\n+                    public int getThreadLocalRandomProbe() {\n+                        return getProbe();\n+                    }\n+                    public int advanceThreadLocalRandomProbe(int r) {\n+                        return advanceProbe(r);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n@@ -191,2 +193,1 @@\n-     * Returns the probe value for the current thread.\n-     * Duplicated from ThreadLocalRandom because of packaging restrictions.\n+     * Returns the ThreadLocalRandom probe value for the current thread.\n@@ -195,1 +196,1 @@\n-        return (int) THREAD_PROBE.get(Thread.currentThread());\n+        return TLR.getThreadLocalRandomProbe();\n@@ -201,1 +202,0 @@\n-     * Duplicated from ThreadLocalRandom because of packaging restrictions.\n@@ -204,5 +204,1 @@\n-        probe ^= probe << 13;   \/\/ xorshift\n-        probe ^= probe >>> 17;\n-        probe ^= probe << 5;\n-        THREAD_PROBE.set(Thread.currentThread(), probe);\n-        return probe;\n+        return TLR.advanceThreadLocalRandomProbe(probe);\n@@ -374,0 +370,3 @@\n+    private static final JavaUtilConcurrentTLRAccess TLR =\n+        SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n@@ -377,1 +376,0 @@\n-    private static final VarHandle THREAD_PROBE;\n@@ -383,6 +381,0 @@\n-        try {\n-            MethodHandles.Lookup l2 = MethodHandles.privateLookupIn(Thread.class, l1);\n-            THREAD_PROBE = MhUtil.findVarHandle(l2, \"threadLocalRandomProbe\", int.class);\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+    int getThreadLocalRandomProbe();\n+    int advanceThreadLocalRandomProbe(int r);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilConcurrentTLRAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}