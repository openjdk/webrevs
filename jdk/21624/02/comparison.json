{"files":[{"patch":"@@ -795,1 +795,8 @@\n-        (void)FillLocArray(mv->possible_objects()->length(), sfpt, obj_node, mv->possible_objects(), objs);\n+        int idx = mv->possible_objects()->length();\n+        (void)FillLocArray(idx, sfpt, obj_node, mv->possible_objects(), objs);\n+\n+        \/\/ By default ObjectValues that are in 'possible_objects' are not root objects.\n+        \/\/ They will be marked as root later if they are directly referenced in a JVMS.\n+        assert(mv->possible_objects()->length() > idx, \"Didn't add entry to possible_objects?!\");\n+        assert(mv->possible_objects()->at(idx)->is_object(), \"Entries in possible_objects should be ObjectValue.\");\n+        mv->possible_objects()->at(idx)->as_ObjectValue()->set_root(false);\n@@ -1130,1 +1137,8 @@\n-            FillLocArray(mv->possible_objects()->length(), sfn, obj_node, mv->possible_objects(), objs);\n+            int idx = mv->possible_objects()->length();\n+            (void)FillLocArray(idx, sfn, obj_node, mv->possible_objects(), objs);\n+\n+            \/\/ By default ObjectValues that are in 'possible_objects' are not root objects.\n+            \/\/ They will be marked as root later if they are directly referenced in a JVMS.\n+            assert(mv->possible_objects()->length() > idx, \"Didn't add entry to possible_objects?!\");\n+            assert(mv->possible_objects()->at(idx)->is_object(), \"Entries in possible_objects should be ObjectValue.\");\n+            mv->possible_objects()->at(idx)->as_ObjectValue()->set_root(false);\n@@ -1161,5 +1175,11 @@\n-          bool is_root = locarray->contains(ov) ||\n-                         exparray->contains(ov) ||\n-                         contains_as_owner(monarray, ov) ||\n-                         contains_as_scalarized_obj(jvms, sfn, objs, ov);\n-          ov->set_root(is_root);\n+          if (ov->is_root()) {\n+            \/\/ Already flagged as 'root' by something else. We shouldn't change it\n+            \/\/ to non-root in a younger JVMS because it may need to be alive in\n+            \/\/ a younger JVMS.\n+          } else {\n+            bool is_root = locarray->contains(ov) ||\n+                           exparray->contains(ov) ||\n+                           contains_as_owner(monarray, ov) ||\n+                           contains_as_scalarized_obj(jvms, sfn, objs, ov);\n+            ov->set_root(is_root);\n+          }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335977\n+ * @summary Check that Reduce Allocation Merges doesn't crash when there\n+ *          is an uncommon_trap with a chain of JVMS and, the reduced phi\n+ *          input(s) are local(s) in an old JVMS but not in a younger JVMS.\n+ *          I.e., check that we don't lose track of \"_is_root\" when traversing\n+ *          a JVMS chain.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileOnly=compiler.escapeAnalysis.TestReduceAllocationAndJVMStates::test*\n+ *                   compiler.escapeAnalysis.TestReduceAllocationAndJVMStates\n+ * @run main compiler.escapeAnalysis.TestReduceAllocationAndJVMStates\n+ *\/\n+package compiler.escapeAnalysis;\n+\n+public class TestReduceAllocationAndJVMStates {\n+    static boolean bFld;\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        bFld = false;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            test(i % 2 == 0);\n+        }\n+        bFld = true;\n+\n+        \/\/ This will trigger a deoptimization which\n+        \/\/ will make the issue manifest to the user\n+        test(true);\n+    }\n+\n+    static int test(boolean flag) {\n+        Super a = new A();\n+        Super b = new B();\n+        Super s = (flag ? a : b);\n+\n+        \/\/ This needs to be inlined by C2\n+        check();\n+\n+        return a.i + b.i + s.i;\n+    }\n+\n+    \/\/ This shouldn't be manually inlined\n+    static void check() {\n+        if (bFld) {\n+            iFld = 34;\n+        }\n+    }\n+}\n+\n+class Super {\n+    int i;\n+}\n+class A extends Super {}\n+class B extends Super {}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationAndJVMStates.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}