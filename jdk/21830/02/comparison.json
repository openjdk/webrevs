{"files":[{"patch":"@@ -123,1 +123,1 @@\n-        validateBinaryClassName(packageName);\n+        validateBinaryPackageName(packageName);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        ConstantUtils.validateBinaryPackageName(requireNonNull(name));\n+        ConstantUtils.validateBinaryPackageName(name);\n@@ -78,1 +78,1 @@\n-        ConstantUtils.validateInternalPackageName(requireNonNull(name));\n+        ConstantUtils.validateInternalPackageName(name);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDesc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,2 +177,47 @@\n-     * Validates the correctness of a binary class name. In particular checks for the presence of\n-     * invalid characters in the name.\n+     * Validates the correctness of a path-based name, which is a class or\n+     * interface name or a package name.\n+     * In particular checks for the presence of invalid characters,\n+     * consecutive, leading, or trailing separator char,\n+     * and the empty string for class or interface names.\n+     *\n+     * @param name the name\n+     * @param usesSlash {@code true} means {@code \/} is the separator char,\n+     *     otherwise {@code .} is the separator char\n+     * @param allowsEmpty {@code true} means the empty string is a valid name\n+     * @return the name passed if valid\n+     * @throws IllegalArgumentException if the name is invalid\n+     * @throws NullPointerException if name is {@code null}\n+     *\/\n+    private static String validatePathBasedName(String name, boolean usesSlash, boolean allowsEmpty) {\n+        int len = name.length();  \/\/ implicit null check\n+        \/\/ empty name special rule\n+        if (allowsEmpty && len == 0)\n+            return name;\n+        \/\/ state variable for detection of illegal states of\n+        \/\/ empty name, consecutive, leading, or trailing separators\n+        int afterSeparator = 0;\n+        for (int i = 0; i < len; i++) {\n+            char ch = name.charAt(i);\n+            \/\/ reject ';' or '['\n+            if (ch == ';' || ch == '[')\n+                throw invalidClassName(name);\n+            \/\/ encounter a separator\n+            boolean foundSlash = ch == '\/';\n+            if (foundSlash || ch == '.') {\n+                \/\/ reject the other separator char\n+                \/\/ reject consecutive or leading separators\n+                if (foundSlash != usesSlash || i == afterSeparator)\n+                    throw invalidClassName(name);\n+                afterSeparator = i + 1;\n+            }\n+        }\n+        \/\/ reject empty name or trailing separators\n+        if (len == afterSeparator)\n+            throw invalidClassName(name);\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of a binary class name.\n+     * In particular checks for the presence of invalid characters, empty\n+     * name, consecutive, leading, or trailing {@code .}.\n@@ -186,7 +231,1 @@\n-        for (int i = 0; i < name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/'\n-                    || ch == '.' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '.'))\n-                throw invalidClassName(name);\n-        }\n-        return name;\n+        return validatePathBasedName(name, false, false);\n@@ -197,1 +236,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n+     * In particular checks for the presence of invalid characters, empty\n+     * name, consecutive, leading, or trailing {@code \/}.\n@@ -205,7 +245,1 @@\n-        for (int i = 0; i < name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '.'\n-                    || ch == '\/' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '\/'))\n-                throw invalidClassName(name);\n-        }\n-        return name;\n+        return validatePathBasedName(name, true, false);\n@@ -216,2 +250,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n+     * In particular checks for the presence of invalid characters, consecutive,\n+     * leading, or trailing {@code .}.  Allows empty strings for the unnamed package.\n@@ -225,6 +259,1 @@\n-        for (int i = 0; i < name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n+        return validatePathBasedName(name, false, true);\n@@ -235,2 +264,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n+     * In particular checks for the presence of invalid characters, consecutive,\n+     * leading, or trailing {@code \/}.  Allows empty strings for the unnamed package.\n@@ -244,6 +273,1 @@\n-        for (int i = 0; i < name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '.')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n+        return validatePathBasedName(name, true, true);\n@@ -426,3 +450,3 @@\n-                    \/\/ state variable for detection of illegal states, such as:\n-                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n-                    boolean legal = false;\n+                    \/\/ state variable for detection of illegal states of\n+                    \/\/ empty name, '\/\/', leading '\/', or trailing '\/'\n+                    int afterSeparator = index + 1; \/\/ start of internal name\n@@ -430,7 +454,10 @@\n-                        switch (descriptor.charAt(index++)) {\n-                            case ';' -> {\n-                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n-                                return legal ? index - start : 0;\n-                            }\n-                            case '.', '[' -> {\n-                                \/\/ do not permit '.' or '['\n+                        ch = descriptor.charAt(index++);\n+                        if (ch == ';')\n+                            \/\/ reject empty name or trailing '\/'\n+                            return index == afterSeparator ? 0 : index - start;\n+                        \/\/ reject '.' or '['\n+                        if (ch == '.' || ch == '[')\n+                            return 0;\n+                        if (ch == '\/') {\n+                            \/\/ reject '\/\/' or leading '\/'\n+                            if (index == afterSeparator)\n@@ -438,8 +465,1 @@\n-                            }\n-                            case '\/' -> {\n-                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n-                                if (!legal) return 0;\n-                                legal = false;\n-                            }\n-                            default ->\n-                                legal = true;\n+                            afterSeparator = index + 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":71,"deletions":51,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -282,1 +282,2 @@\n-                                              \"Ljava.lang.String;\", \"java\/lang\/String\");\n+                                              \"Ljava.lang.String;\", \"java\/lang\/String\", \"L;\",\n+                                              \"La\/\/b;\", \"L\/a;\", \"La\/;\");\n@@ -295,1 +296,1 @@\n-                \"Ljava.lang.String;\", \"java\/lang\/String\");\n+                \"Ljava.lang.String;\", \"java\/lang\/String\", \"\");\n@@ -306,1 +307,1 @@\n-                \"Ljava.lang.String;\", \"java.lang.String\");\n+                \"Ljava.lang.String;\", \"java.lang.String\", \"\");\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\"})\n+    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\", \"a..b\", \"a.b.\", \".a.b\"})\n@@ -44,1 +44,1 @@\n-    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\"})\n+    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\", \"a\/\/b\", \"a\/b\/\", \"\/a\/b\"})\n","filename":"test\/jdk\/java\/lang\/constant\/PackageDescTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}