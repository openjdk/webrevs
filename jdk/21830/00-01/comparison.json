{"files":[{"patch":"@@ -177,2 +177,3 @@\n-     * Validates the correctness of a binary class name. In particular checks for the presence of\n-     * invalid characters in the name.\n+     * Validates the correctness of a binary class name.\n+     * In particular checks for the presence of invalid characters, empty\n+     * name, consecutive, leading, or trailing {@code .}.\n@@ -186,0 +187,2 @@\n+        \/\/ state variable for detection of illegal states, such as:\n+        \/\/ empty unqualified name, consecutive, leading, or trailing separators\n@@ -190,0 +193,1 @@\n+            \/\/ reject ';' or '[' or other form's separator\n@@ -193,1 +197,3 @@\n-                if (i == afterSeparator) {\n+                \/\/ illegal state when received separator indicates consecutive\n+                \/\/ or leading separators\n+                if (i == afterSeparator)\n@@ -195,3 +201,1 @@\n-                } else {\n-                    afterSeparator = i + 1;\n-                }\n+                afterSeparator = i + 1;\n@@ -200,0 +204,1 @@\n+        \/\/ reject empty unqualified name or trailing separators\n@@ -207,1 +212,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n+     * In particular checks for the presence of invalid characters, empty\n+     * name, consecutive, leading, or trailing {@code \/}.\n@@ -215,0 +221,2 @@\n+        \/\/ state variable for detection of illegal states, such as:\n+        \/\/ empty unqualified name, consecutive, leading, or trailing separators\n@@ -219,0 +227,1 @@\n+            \/\/ reject ';' or '[' or other form's separator\n@@ -222,1 +231,3 @@\n-                if (i == afterSeparator) {\n+                \/\/ illegal state when received separator indicates consecutive\n+                \/\/ or leading separators\n+                if (i == afterSeparator)\n@@ -224,3 +235,1 @@\n-                } else {\n-                    afterSeparator = i + 1;\n-                }\n+                afterSeparator = i + 1;\n@@ -229,0 +238,1 @@\n+        \/\/ reject empty unqualified name or trailing separators\n@@ -236,2 +246,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n+     * In particular checks for the presence of invalid characters, consecutive,\n+     * leading, or trailing {@code .}.  Allows empty strings for the unnamed package.\n@@ -245,1 +255,1 @@\n-        \/\/ Empty names are explicitly allowed\n+        \/\/ the unnamed package + null check\n@@ -253,2 +263,2 @@\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n+     * In particular checks for the presence of invalid characters, consecutive,\n+     * leading, or trailing {@code \/}.  Allows empty strings for the unnamed package.\n@@ -262,1 +272,1 @@\n-        \/\/ Empty names are explicitly allowed\n+        \/\/ the unnamed package + null check\n@@ -444,1 +454,1 @@\n-                    boolean legal = false;\n+                    int afterSeparator = index + 1; \/\/ start of internal name\n@@ -446,7 +456,10 @@\n-                        switch (descriptor.charAt(index++)) {\n-                            case ';' -> {\n-                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n-                                return legal ? index - start : 0;\n-                            }\n-                            case '.', '[' -> {\n-                                \/\/ do not permit '.' or '['\n+                        ch = descriptor.charAt(index++);\n+                        if (ch == ';')\n+                            \/\/ reject empty unqualified name or trailing '\/'\n+                            return index == afterSeparator ? 0 : index - start;\n+                        \/\/ reject '.' or '['\n+                        if (ch == '[' || ch == '.')\n+                            return 0;\n+                        if (ch == '\/') {\n+                            \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n+                            if (index == afterSeparator)\n@@ -454,8 +467,1 @@\n-                            }\n-                            case '\/' -> {\n-                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n-                                if (!legal) return 0;\n-                                legal = false;\n-                            }\n-                            default ->\n-                                legal = true;\n+                            afterSeparator = index + 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -282,1 +282,2 @@\n-                                              \"Ljava.lang.String;\", \"java\/lang\/String\");\n+                                              \"Ljava.lang.String;\", \"java\/lang\/String\", \"L;\",\n+                                              \"La\/\/b;\", \"L\/a;\", \"La\/;\");\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}