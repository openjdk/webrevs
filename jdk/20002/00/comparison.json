{"files":[{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n-\n- *\/\n-\n-#ifndef SHARE_NMT_ARRAYWITHFREELIST_HPP\n-#define SHARE_NMT_ARRAYWITHFREELIST_HPP\n-\n-#include \"utilities\/growableArray.hpp\"\n-#include <type_traits>\n-\n-\/\/ A flat array of elements E, backed by C-heap, growing on-demand. It allows for\n-\/\/ returning arbitrary elements and keeps them in a freelist. Elements can be uniquely\n-\/\/ identified via array index.\n-template<typename E, MEMFLAGS flag>\n-class ArrayWithFreeList {\n-\n-  \/\/ An E must be trivially copyable and destructible, but it may be constructed\n-  \/\/ however it likes.\n-  constexpr void static_assert_E_satisfies_type_requirements() const {\n-    static_assert(std::is_trivially_copyable<E>::value && std::is_trivially_destructible<E>::value, \"must be\");\n-  }\n-\n-public:\n-  using I = int32_t;\n-  static constexpr const I nil = -1;\n-\n-private:\n-  \/\/ A free list allocator element is either a link to the next free space\n-  \/\/ or an actual element.\n-  union BackingElement {\n-    I link;\n-    E e;\n-  };\n-\n-  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n-  I _free_start;\n-\n-  bool is_in_bounds(I i) {\n-    return i >= 0 && i < _backing_storage.length();\n-  }\n-\n-public:\n-  NONCOPYABLE(ArrayWithFreeList);\n-\n-  ArrayWithFreeList(int initial_capacity = 8)\n-    : _backing_storage(initial_capacity),\n-    _free_start(nil) {}\n-\n-  template<typename... Args>\n-  I allocate(Args... args) {\n-    static_assert_E_satisfies_type_requirements();\n-    BackingElement* be;\n-    I i;\n-    if (_free_start != nil) {\n-      \/\/ Must point to already existing index\n-      be = &_backing_storage.at(_free_start);\n-      i = _free_start;\n-      _free_start = be->link;\n-    } else {\n-      \/\/ There are no free elements, allocate a new one.\n-      i = _backing_storage.append(BackingElement());\n-      be = _backing_storage.adr_at(i);\n-    }\n-\n-    ::new (be) E{args...};\n-    return i;\n-  }\n-\n-  void deallocate(I i) {\n-    static_assert_E_satisfies_type_requirements();\n-    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n-    if (i == nil) return;\n-    BackingElement& be_freed = _backing_storage.at(i);\n-    be_freed.link = _free_start;\n-    _free_start = i;\n-  }\n-\n-  E& at(I i) {\n-    static_assert_E_satisfies_type_requirements();\n-    assert(i != nil, \"null pointer dereference\");\n-    assert(is_in_bounds(i), \"out of bounds dereference\");\n-    return _backing_storage.at(i).e;\n-  }\n-};\n-\n-#endif \/\/ SHARE_NMT_ARRAYWITHFREELIST_HPP\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/arrayWithFreeList.hpp\"\n+#include \"utilities\/arrayWithFreeList.hpp\"\n@@ -69,0 +69,2 @@\n+    TableEntry(TableEntryIndex next, StackIndex stack)\n+    : next(next), stack(stack) {}\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#ifndef SHARE_NMT_ARRAYWITHFREELIST_HPP\n+#define SHARE_NMT_ARRAYWITHFREELIST_HPP\n+\n+#include \"nmt\/memflags.hpp\"\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+#include \"runtime\/os.hpp\"\n+\n+\/\/ A flat array of elements E, backed by C-heap, growing on-demand. It allows for\n+\/\/ returning arbitrary elements and keeps them in a freelist. Elements can be uniquely\n+\/\/ identified via array index.\n+template<typename E, MEMFLAGS flag, typename II = int32_t>\n+class ArrayWithFreeList {\n+  constexpr void static_assert_E_satisfies_type_requirements(bool fixed) const {\n+    static_assert(std::numeric_limits<II>::is_exact, \"must be\");\n+    static_assert(std::numeric_limits<II>::max() <= std::numeric_limits<uint64_t>::max(), \"cannot have index larger than uint64_t\");\n+    if (fixed) {\n+      static_assert(std::is_trivially_destructible<E>::value, \"must be\");\n+    } else {\n+      static_assert(std::is_trivially_copyable<E>::value && std::is_trivially_destructible<E>::value, \"must be\");\n+    }\n+  }\n+\n+public:\n+  \/\/ Export the I so it's easily available for consumption by users\n+  using I = II;\n+  static constexpr const I nil = std::numeric_limits<I>::max();\n+  static constexpr const I max = nil - 1;\n+\n+  \/\/ A free list allocator element is either a link to the next free space\n+  \/\/ or an actual element.\n+  union BackingElement {\n+    I link;\n+    E e;\n+  };\n+\n+private:\n+  \/\/ A minimal resizable array with customizable len\/cap properties.\n+  class resizable_array {\n+    bool _fixed_size;\n+    I _len;\n+    I _cap;\n+    BackingElement* _data;\n+\n+    bool grow() {\n+      if (_cap == std::numeric_limits<I>::max() - 1) {\n+        \/\/ Already at max capacity.\n+        return false;\n+      }\n+\n+      \/\/ Widen the capacity temporarily.\n+      uint64_t widened_cap = static_cast<uint64_t>(_cap);\n+      if (std::numeric_limits<uint64_t>::max() - widened_cap < widened_cap) {\n+        \/\/ Overflow of uint64_t in case of resize, we fail.\n+        return  false;\n+      }\n+      \/\/ Safe to double the widened_cap\n+      widened_cap *= 2;\n+      \/\/ If I has max size (2**X) - 1, is cap at 2**(X-1)?\n+      if (std::numeric_limits<I>::max() - _cap == (_cap - 1)) {\n+        \/\/ Reduce widened_cap\n+        widened_cap -= 1;\n+      }\n+\n+      I next_cap = static_cast<I>(widened_cap);\n+      void* next_array = os::realloc(_data, next_cap * sizeof(BackingElement), flag);\n+      if (next_array == nullptr) {\n+        return false;\n+      }\n+      _data = static_cast<BackingElement*>(next_array);\n+      _cap = next_cap;\n+      return true;\n+    }\n+\n+  public:\n+    resizable_array(I initial_cap)\n+    : _fixed_size(false),\n+      _len(0),\n+      _cap(initial_cap),\n+      _data(static_cast<BackingElement*>(os::malloc(initial_cap * sizeof(BackingElement), flag))) {\n+    }\n+\n+    resizable_array(BackingElement* data, II capacity)\n+    : _fixed_size(true),\n+      _len(0),\n+      _cap(capacity),\n+      _data(data) {}\n+\n+    ~resizable_array() {\n+      if (!_fixed_size) {\n+        os::free(_data);\n+      }\n+    }\n+\n+    I length() {\n+      return _len;\n+    }\n+\n+    BackingElement& at(I i) {\n+      assert(i < _len, \"oob\");\n+      return _data[i];\n+    }\n+\n+    BackingElement* adr_at(I i) {\n+      return &at(i);\n+    }\n+\n+    I append() {\n+      if (_len == _cap) {\n+        if (_fixed_size) return nil;\n+        if (!grow()) {\n+          return nil;\n+        }\n+      }\n+      I idx = _len++;\n+      return idx;\n+    }\n+\n+    void remove_last() {\n+      I idx = _len - 1;\n+      --_len;\n+    }\n+  };\n+\n+  resizable_array _backing_storage;\n+  I _free_start;\n+\n+  bool is_in_bounds(I i) {\n+    return i >= 0 && i < _backing_storage.length();\n+  }\n+\n+public:\n+  NONCOPYABLE(ArrayWithFreeList);\n+\n+  ArrayWithFreeList(int initial_capacity = 8)\n+    : _backing_storage(initial_capacity),\n+    _free_start(nil) {\n+    static_assert_E_satisfies_type_requirements(false);\n+  }\n+\n+  ArrayWithFreeList(BackingElement* data, II capacity)\n+  : _backing_storage(data, capacity), _free_start(nil) {\n+    static_assert_E_satisfies_type_requirements(true);\n+  }\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    BackingElement* be;\n+    I i;\n+    if (_free_start != nil) {\n+      \/\/ Must point to already existing index\n+      be = _backing_storage.adr_at(_free_start);\n+      i = _free_start;\n+      _free_start = be->link;\n+    } else {\n+      \/\/ There are no free elements, allocate a new one.\n+      i = _backing_storage.append();\n+      if (i == nil) return i;\n+      be = _backing_storage.adr_at(i);\n+    }\n+\n+    ::new (be) E{args...};\n+    return i;\n+  }\n+\n+  void deallocate(I i) {\n+    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n+    if (i == nil) return;\n+    if (i == _backing_storage.length()) {\n+      _backing_storage.remove_last();\n+    } else {\n+      BackingElement& be_freed = _backing_storage.at(i);\n+      be_freed.link = _free_start;\n+      _free_start = i;\n+    }\n+  }\n+\n+  E& at(I i) {\n+    assert(i != nil, \"null pointer dereference\");\n+    assert(is_in_bounds(i), \"out of bounds dereference\");\n+    return _backing_storage.at(i).e;\n+  }\n+};\n+\n+#endif \/\/ SHARE_NMT_ARRAYWITHFREELIST_HPP\n","filename":"src\/hotspot\/share\/utilities\/arrayWithFreeList.hpp","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n-\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"unittest.hpp\"\n-#include \"nmt\/arrayWithFreeList.hpp\"\n-\n-using A = ArrayWithFreeList<int, mtTest>;\n-\n-class ArrayWithFreeListTest  : public testing::Test {\n-};\n-\n-\/\/ A linked list which sets the allocator itself\n-template<typename E>\n-struct LL {\n-  struct Node;\n-  using NodeAllocator = ArrayWithFreeList<Node, mtTest>;\n-  using NodePtr = typename NodeAllocator::I;\n-  NodeAllocator alloc;\n-  struct Node {\n-    E e;\n-    NodePtr next;\n-  };\n-\n-  NodePtr start;\n-  LL()\n-  : start{NodeAllocator::nil} {\n-  }\n-\n-  void push(E e) {\n-    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-    NodePtr& current = start;\n-    if (current == NodeAllocator::nil) {\n-      current = new_element;\n-      return;\n-    }\n-    alloc.at(new_element).next = current;\n-    current = new_element;\n-  };\n-\n-  E pop() {\n-    assert(start != NodeAllocator::nil, \"must be\");\n-    Node& n = alloc.at(start);\n-    E e = n.e;\n-    NodePtr next_start = n.next;\n-    alloc.deallocate(start);\n-    start = next_start;\n-    return e;\n-  }\n-};\n-\n-\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n-\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n-\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n-\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n-template<typename E, template<typename, MEMFLAGS> class Allocator>\n-struct LL2 {\n-  struct Node;\n-  using NodeAllocator = Allocator<Node, mtTest>;\n-  using NodePtr = typename NodeAllocator::I;\n-  NodeAllocator alloc;\n-  struct Node {\n-    E e;\n-    NodePtr next;\n-  };\n-\n-  NodePtr start;\n-  LL2()\n-    : start(NodeAllocator::nil) {\n-  }\n-\n-  void push(E e) {\n-    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-    NodePtr& current = start;\n-    if (current == NodeAllocator::nil) {\n-      current = new_element;\n-      return;\n-    }\n-    alloc.at(new_element).next = current;\n-    current = new_element;\n-  };\n-\n-  E pop() {\n-    assert(start != NodeAllocator::nil, \"must be\");\n-    Node& n = alloc.at(start);\n-    E e = n.e;\n-    NodePtr next_start = n.next;\n-    alloc.deallocate(start);\n-    start = next_start;\n-    return e;\n-  }\n-};\n-\n-template<typename List>\n-void test_with_list(List& list) {\n-  list.push(1);\n-  list.push(2);\n-  EXPECT_EQ(2, list.pop());\n-  EXPECT_EQ(1, list.pop());\n-}\n-\n-TEST_VM_F(ArrayWithFreeListTest, TestLinkedLists) {\n-  {\n-    LL<int> list;\n-    test_with_list(list);\n-  }\n-  {\n-    LL2<int, ArrayWithFreeList> list;\n-    test_with_list(list);\n-  }\n-}\n-\n-TEST_VM_F(ArrayWithFreeListTest, FreeingShouldReuseMemory) {\n-  A alloc;\n-  A::I i = alloc.allocate(1);\n-  int* x = &alloc.at(i);\n-  alloc.deallocate(i);\n-  i = alloc.allocate(1);\n-  int* y = &alloc.at(i);\n-  EXPECT_EQ(x, y);\n-}\n-\n-TEST_VM_F(ArrayWithFreeListTest, FreeingInTheMiddleWorks) {\n-  A alloc;\n-  A::I i0 = alloc.allocate(0);\n-  A::I i1 = alloc.allocate(0);\n-  A::I i2 = alloc.allocate(0);\n-  int* p1 = &alloc.at(i1);\n-  alloc.deallocate(i1);\n-  A::I i3 = alloc.allocate(0);\n-  EXPECT_EQ(p1, &alloc.at(i3));\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_arrayWithFreeList.cpp","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/arrayWithFreeList.hpp\"\n+\n+using A = ArrayWithFreeList<int, mtTest>;\n+\n+class ArrayWithFreeListTest  : public testing::Test {\n+};\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingShouldReuseMemory) {\n+  A alloc;\n+  A::I i = alloc.allocate(1);\n+  int* x = &alloc.at(i);\n+  alloc.deallocate(i);\n+  i = alloc.allocate(1);\n+  int* y = &alloc.at(i);\n+  EXPECT_EQ(x, y);\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, FreeingInTheMiddleWorks) {\n+  A alloc;\n+  A::I i0 = alloc.allocate(0);\n+  A::I i1 = alloc.allocate(0);\n+  A::I i2 = alloc.allocate(0);\n+  int* p1 = &alloc.at(i1);\n+  alloc.deallocate(i1);\n+  A::I i3 = alloc.allocate(0);\n+  EXPECT_EQ(p1, &alloc.at(i3));\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, MakeVerySmallArray) {\n+  using Elem = int; using Index = uint8_t;\n+  using SmallArray = ArrayWithFreeList<Elem, mtTest, Index>;\n+  SmallArray a;\n+\n+  int success_count = 0;\n+  int failure_count = 0;\n+  for (int i = 0; i < 128; i++) {\n+    SmallArray::I x = a.allocate(0);\n+    if (x != SmallArray::nil) success_count++;\n+    else failure_count++;\n+  }\n+  EXPECT_EQ(0, failure_count);\n+  EXPECT_EQ(128, success_count);\n+\n+  for (int i = 0; i < 128; i++) {\n+    SmallArray::I x = a.allocate(0);\n+    if (x != SmallArray::nil) success_count++;\n+    else failure_count++;\n+  }\n+  EXPECT_EQ(1, failure_count);\n+  EXPECT_EQ(255, success_count);\n+}\n+\n+TEST_VM_F(ArrayWithFreeListTest, BackedByFixedArray) {\n+  A::BackingElement data[8];\n+  A a(data, 8);\n+\n+  int success_count = 0;\n+  int failure_count = 0;\n+  for (int i = 0; i < 8; i++) {\n+    A::I x = a.allocate(0);\n+    if (x != A::nil) success_count++;\n+    else failure_count++;\n+  }\n+  EXPECT_EQ(8, success_count);\n+  EXPECT_EQ(0, failure_count);\n+  A::I x = a.allocate(0);\n+  A::I n = A::nil;\n+  EXPECT_EQ(n, x);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_arrayWithFreeList.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}