{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -36,1 +35,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -52,2 +50,1 @@\n-        \/\/ use polling implementation until we implement a BSD\/kqueue one\n-        return new PollingWatchService();\n+        return new MacOSXWatchService();\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,634 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import jdk.internal.misc.InnocuousThread;\n+import jdk.internal.misc.Unsafe;\n+\n+import java.io.IOException;\n+import java.nio.file.ClosedWatchServiceException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.LinkOption;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+\n+class MacOSXWatchService extends AbstractWatchService {\n+    private static final MacOSXFileSystemProvider theFSProvider = DefaultFileSystemProvider.instance();\n+    private static final MacOSXFileSystem theFS = (MacOSXFileSystem) theFSProvider.theFileSystem();\n+\n+    private final HashMap<Object, MacOSXWatchKey> dirKeyToWatchKey      = new HashMap<>();\n+    private final HashMap<Long, MacOSXWatchKey>   eventStreamToWatchKey = new HashMap<>();\n+    private final Object                          watchKeysLock         = new Object();\n+\n+    private final CFRunLoopThread runLoopThread;\n+\n+    MacOSXWatchService() throws IOException {\n+        runLoopThread = new CFRunLoopThread();\n+        Thread t = InnocuousThread.newThread(\"FileSystemWatcher\", runLoopThread);\n+        t.setDaemon(true);\n+        t.start();\n+\n+        \/\/ In order to be able to schedule any FSEventStream's, a reference to a run loop is required.\n+        runLoopThread.waitForRunLoopRef();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    @Override\n+    WatchKey register(Path dir,\n+                      WatchEvent.Kind<?>[] events,\n+                      WatchEvent.Modifier... modifiers) throws IOException {\n+        checkIsOpen();\n+\n+        final UnixPath unixDir = (UnixPath)dir;\n+        final Object dirKey    = checkPath(unixDir);\n+        final EnumSet<FSEventKind>   eventSet    = FSEventKind.setOf(events);\n+        final EnumSet<WatchModifier> modifierSet = WatchModifier.setOf(modifiers);\n+\n+        try {\n+            return AccessController.doPrivileged(\n+                    new PrivilegedExceptionAction<MacOSXWatchKey>() {\n+                @Override\n+                public MacOSXWatchKey run() throws IOException {\n+                    return doPrivilegedRegister(unixDir, dirKey, eventSet, modifierSet);\n+                }\n+            });\n+        } catch (PrivilegedActionException pae) {\n+            final Throwable cause = pae.getCause();\n+            if (cause instanceof IOException ioe)\n+                throw ioe;\n+            throw new AssertionError(pae);\n+        }\n+    }\n+\n+    private MacOSXWatchKey doPrivilegedRegister(UnixPath unixDir,\n+                                                Object dirKey,\n+                                                EnumSet<FSEventKind> eventSet,\n+                                                EnumSet<WatchModifier> modifierSet) throws IOException {\n+        synchronized (closeLock()) {\n+            checkIsOpen();\n+\n+            synchronized (watchKeysLock) {\n+                MacOSXWatchKey watchKey = dirKeyToWatchKey.get(dirKey);\n+                final boolean keyForDirAlreadyExists = (watchKey != null);\n+                if (keyForDirAlreadyExists) {\n+                    eventStreamToWatchKey.remove(watchKey.getEventStreamRef());\n+                    watchKey.disable();\n+                } else {\n+                    watchKey = new MacOSXWatchKey(this, unixDir, dirKey);\n+                    dirKeyToWatchKey.put(dirKey, watchKey);\n+                }\n+\n+                watchKey.enable(runLoopThread, eventSet, modifierSet);\n+                eventStreamToWatchKey.put(watchKey.getEventStreamRef(), watchKey);\n+                watchKeysLock.notify(); \/\/ So that run loop gets running again\n+                                        \/\/ if stopped due to lack of event streams\n+                return watchKey;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invoked on the CFRunLoopThread by the native code to report directories\n+     * that need to be re-scanned.\n+     *\/\n+    private void callback(final long eventStreamRef,\n+                          final String[] paths,\n+                          final long eventFlagsPtr) {\n+        synchronized (watchKeysLock) {\n+            final MacOSXWatchKey watchKey = eventStreamToWatchKey.get(eventStreamRef);\n+            if (watchKey != null) {\n+                watchKey.handleEvents(paths, eventFlagsPtr);\n+            }\n+        }\n+    }\n+\n+    void cancel(final MacOSXWatchKey watchKey) {\n+        synchronized (watchKeysLock) {\n+            dirKeyToWatchKey.remove(watchKey.getRootPathKey());\n+            eventStreamToWatchKey.remove(watchKey.getEventStreamRef());\n+        }\n+    }\n+\n+    void waitForEventSource() {\n+        synchronized (watchKeysLock) {\n+            if (isOpen() && eventStreamToWatchKey.isEmpty()) {\n+                try {\n+                    watchKeysLock.wait();\n+                } catch (InterruptedException ignore) {}\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void implClose() {\n+        synchronized (watchKeysLock) {\n+            eventStreamToWatchKey.clear();\n+            dirKeyToWatchKey.forEach((key, watchKey) -> watchKey.invalidate());\n+            dirKeyToWatchKey.clear();\n+            watchKeysLock.notify(); \/\/ Let waitForEventSource() go if it was waiting\n+            runLoopThread.runLoopStop(); \/\/ Force exit from CFRunLoopRun()\n+        }\n+    }\n+\n+    private class CFRunLoopThread implements Runnable {\n+        \/\/ Native reference to the CFRunLoop object of the watch service run loop.\n+        private volatile long runLoopRef;\n+        private final CountDownLatch runLoopRefAvailabilitySignal = new CountDownLatch(1);\n+\n+        private void waitForRunLoopRef() throws IOException {\n+            try {\n+                runLoopRefAvailabilitySignal.await();\n+            } catch (InterruptedException e) {\n+                throw new IOException(e);\n+            }\n+        }\n+\n+        long getRunLoopRef() {\n+            return runLoopRef;\n+        }\n+\n+        void runLoopStop() {\n+            if (runLoopRef != 0) {\n+                \/\/ The run loop may have stuck in CFRunLoopRun() even though\n+                \/\/ all of its input sources have been removed. Need to terminate\n+                \/\/ it explicitly so that it can run to completion.\n+                MacOSXWatchService.CFRunLoopStop(runLoopRef);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            runLoopRef = CFRunLoopGetCurrent();\n+            runLoopRefAvailabilitySignal.countDown();\n+\n+            while (isOpen()) {\n+                CFRunLoopRun(MacOSXWatchService.this);\n+                waitForEventSource();\n+            }\n+\n+            runLoopRef = 0; \/\/ CFRunLoopRef is no longer usable when the loop has been terminated\n+        }\n+    }\n+\n+    private void checkIsOpen() {\n+        if (!isOpen())\n+            throw new ClosedWatchServiceException();\n+    }\n+\n+    private Object checkPath(UnixPath dir) throws IOException {\n+        if (dir == null)\n+            throw new NullPointerException(\"No path to watch\");\n+\n+        UnixFileAttributes attrs;\n+        try {\n+            attrs = UnixFileAttributes.get(dir, true);\n+        } catch (UnixException x) {\n+            throw x.asIOException(dir);\n+        }\n+\n+        if (!attrs.isDirectory())\n+            throw new NotDirectoryException(dir.getPathForExceptionMessage());\n+\n+        final Object fileKey = attrs.fileKey();\n+        if (fileKey == null)\n+            throw new AssertionError(\"File keys must be supported\");\n+\n+        return fileKey;\n+    }\n+\n+    private enum FSEventKind {\n+        CREATE, MODIFY, DELETE, OVERFLOW;\n+\n+        public static FSEventKind of(final WatchEvent.Kind<?> watchEventKind) {\n+            if (StandardWatchEventKinds.ENTRY_CREATE == watchEventKind) {\n+                return CREATE;\n+            } else if (StandardWatchEventKinds.ENTRY_MODIFY == watchEventKind) {\n+                return MODIFY;\n+            } else if (StandardWatchEventKinds.ENTRY_DELETE == watchEventKind) {\n+                return DELETE;\n+            } else if (StandardWatchEventKinds.OVERFLOW == watchEventKind) {\n+                return OVERFLOW;\n+            } else {\n+                throw new UnsupportedOperationException(watchEventKind.name());\n+            }\n+        }\n+\n+        public static EnumSet<FSEventKind> setOf(final WatchEvent.Kind<?>[] events) {\n+            final EnumSet<FSEventKind> eventSet = EnumSet.noneOf(FSEventKind.class);\n+            for (final WatchEvent.Kind<?> event: events) {\n+                if (event == null) {\n+                    throw new NullPointerException(\"An element in event set is 'null'\");\n+                } else if (event == StandardWatchEventKinds.OVERFLOW) {\n+                    continue;\n+                }\n+\n+                eventSet.add(FSEventKind.of(event));\n+            }\n+\n+            if (eventSet.isEmpty())\n+                throw new IllegalArgumentException(\"No events to register\");\n+\n+            return eventSet;\n+        }\n+    }\n+\n+    private enum WatchModifier {\n+        SENSITIVITY_HIGH, SENSITIVITY_MEDIUM, SENSITIVITY_LOW;\n+\n+        public static WatchModifier of(final WatchEvent.Modifier watchEventModifier) {\n+            if (ExtendedOptions.SENSITIVITY_HIGH.matches(watchEventModifier)) {\n+                return SENSITIVITY_HIGH;\n+            } if (ExtendedOptions.SENSITIVITY_MEDIUM.matches(watchEventModifier)) {\n+                return SENSITIVITY_MEDIUM;\n+            } if (ExtendedOptions.SENSITIVITY_LOW.matches(watchEventModifier)) {\n+                return SENSITIVITY_LOW;\n+            } else {\n+                throw new UnsupportedOperationException(watchEventModifier.name());\n+            }\n+        }\n+\n+        public static EnumSet<WatchModifier> setOf(final WatchEvent.Modifier[] modifiers) {\n+            final EnumSet<WatchModifier> modifierSet = EnumSet.noneOf(WatchModifier.class);\n+            for (final WatchEvent.Modifier modifier : modifiers) {\n+                if (modifier == null)\n+                    throw new NullPointerException(\"An element in modifier set is 'null'\");\n+\n+                modifierSet.add(WatchModifier.of(modifier));\n+            }\n+\n+            return modifierSet;\n+        }\n+\n+        public static double sensitivityOf(final EnumSet<WatchModifier> modifiers) {\n+            if (modifiers.contains(SENSITIVITY_HIGH)) {\n+                return 0.1;\n+            } else if (modifiers.contains(SENSITIVITY_LOW)) {\n+                return 1;\n+            } else {\n+                return 0.5; \/\/ aka SENSITIVITY_MEDIUM\n+            }\n+        }\n+    }\n+\n+    private static class MacOSXWatchKey extends AbstractWatchKey {\n+        private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        private static final long kFSEventStreamEventFlagRootChanged     = 0x00000020;\n+\n+        private final static Path relativeRootPath = theFS.getPath(\"\");\n+\n+        \/\/ Full path to this key's watch root directory.\n+        private final Path   realRootPath;\n+        private final int    realRootPathLength;\n+        private final Object rootPathKey;\n+\n+        \/\/ Kinds of events to be reported.\n+        private EnumSet<FSEventKind> eventsToWatch;\n+\n+        \/\/ Native FSEventStreamRef as returned by FSEventStreamCreate().\n+        private long         eventStreamRef;\n+        private final Object eventStreamRefLock = new Object();\n+\n+        private DirectorySnapshot directorySnapshot;\n+\n+        MacOSXWatchKey(final MacOSXWatchService watchService,\n+                       final UnixPath dir,\n+                       final Object rootPathKey) throws IOException {\n+            super(dir, watchService);\n+            this.realRootPath       = dir.toRealPath().normalize();\n+            this.realRootPathLength = realRootPath.toString().length() + 1;\n+            this.rootPathKey        = rootPathKey;\n+        }\n+\n+        synchronized void enable(final CFRunLoopThread runLoopThread,\n+                                 final EnumSet<FSEventKind> eventsToWatch,\n+                                 final EnumSet<WatchModifier> modifierSet) throws IOException {\n+            assert(!isValid());\n+\n+            this.eventsToWatch = eventsToWatch;\n+\n+            directorySnapshot = DirectorySnapshot.create(getRealRootPath());\n+\n+            synchronized (eventStreamRefLock) {\n+                final int kFSEventStreamCreateFlagWatchRoot  = 0x00000004;\n+                eventStreamRef = MacOSXWatchService.eventStreamCreate(\n+                        realRootPath.toString(),\n+                        WatchModifier.sensitivityOf(modifierSet),\n+                        kFSEventStreamCreateFlagWatchRoot);\n+\n+                if (eventStreamRef == 0)\n+                    throw new IOException(\"Unable to create FSEventStream\");\n+\n+                MacOSXWatchService.eventStreamSchedule(eventStreamRef,\n+                        runLoopThread.getRunLoopRef());\n+            }\n+        }\n+\n+        synchronized void disable() {\n+            invalidate();\n+            directorySnapshot = null;\n+        }\n+\n+        synchronized void handleEvents(final String[] paths, long eventFlagsPtr) {\n+            if (paths == null) {\n+                reportOverflow(null);\n+                return;\n+            }\n+\n+            if (updateNeeded(paths, eventFlagsPtr)) {\n+                directorySnapshot.update(MacOSXWatchKey.this);\n+            }\n+        }\n+\n+        private Path toRelativePath(final String absPath) {\n+            return   (absPath.length() > realRootPathLength)\n+                    ? theFS.getPath(absPath.substring(realRootPathLength))\n+                    : relativeRootPath;\n+        }\n+\n+        private boolean updateNeeded(String[] paths, long eventFlagsPtr) {\n+            boolean rootChanged = false;\n+            for (final String absPath : paths) {\n+                if (absPath == null) {\n+                    reportOverflow(null);\n+                    continue;\n+                }\n+\n+                Path path = toRelativePath(absPath);\n+\n+                if (!relativeRootPath.equals(path)) {\n+                    \/\/ Ignore events from subdirectories for now.\n+                    continue;\n+                }\n+\n+                final int flags = unsafe.getInt(eventFlagsPtr);\n+                if ((flags & kFSEventStreamEventFlagRootChanged) != 0) {\n+                    cancel();\n+                    signal();\n+                    rootChanged = false;\n+                    break;\n+                } else {\n+                    rootChanged = true;\n+                }\n+\n+                \/\/ FSEventStreamEventFlags is UInt32.\n+                final long SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS = 4L;\n+                eventFlagsPtr += SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS;\n+            }\n+\n+            return rootChanged;\n+        }\n+\n+        \/**\n+         * Represents a snapshot of the watched directory with a millisecond\n+         * precision timestamp of the last modification.\n+         *\/\n+        private static class DirectorySnapshot {\n+            \/\/ Maps file names to their attributes.\n+            private final Map<Path, Entry> files = new HashMap<>();\n+\n+            \/\/ A counter to keep track of files that have disappeared since the last run.\n+            private long currentTick;\n+\n+            static DirectorySnapshot create(final Path realRootPath) throws IOException {\n+                final DirectorySnapshot snapshot = new DirectorySnapshot();\n+                try (final DirectoryStream<Path> directoryStream\n+                             = theFSProvider.newDirectoryStream(\n+                                     realRootPath, p -> true)) {\n+                    for (final Path file : directoryStream) {\n+                        try {\n+                            final BasicFileAttributes attrs\n+                                    = theFSProvider.readAttributes(\n+                                            file,\n+                                            BasicFileAttributes.class,\n+                                            LinkOption.NOFOLLOW_LINKS);\n+                            final Entry entry = new Entry(\n+                                    attrs.isDirectory(),\n+                                    attrs.lastModifiedTime().toMillis(),\n+                                    0);\n+                            snapshot.files.put(file.getFileName(), entry);\n+                        } catch (IOException ignore) {}\n+                    }\n+                } catch (DirectoryIteratorException e) {\n+                    throw e.getCause();\n+                }\n+\n+                return snapshot;\n+            }\n+\n+            void update(final MacOSXWatchKey watchKey) {\n+                currentTick++;\n+\n+                try (final DirectoryStream<Path> directoryStream\n+                             = theFSProvider.newDirectoryStream(\n+                                     watchKey.getRealRootPath().resolve(relativeRootPath),\n+                                     p -> true)) {\n+                    for (final Path file : directoryStream) {\n+                        try {\n+                            final BasicFileAttributes attrs\n+                                    = theFSProvider.readAttributes(\n+                                            file,\n+                                            BasicFileAttributes.class,\n+                                            LinkOption.NOFOLLOW_LINKS);\n+                            final Path fileName     = file.getFileName();\n+                            final Entry entry       = files.get(fileName);\n+                            final boolean isNew     = (entry == null);\n+                            final long lastModified = attrs.lastModifiedTime().toMillis();\n+                            final Path relativePath = relativeRootPath.resolve(fileName);\n+\n+                            if (attrs.isDirectory()) {\n+                                if (isNew) {\n+                                    files.put(fileName,\n+                                            new Entry(true, lastModified, currentTick));\n+                                    watchKey.reportCreated(relativePath);\n+                                } else {\n+                                    if (!entry.isDirectory) { \/\/ Used to be a file, now a directory\n+                                        watchKey.reportCreated(relativePath);\n+                                        files.put(fileName,\n+                                                new Entry(true, lastModified, currentTick));\n+                                        watchKey.reportDeleted(relativePath);\n+                                    } else if (entry.isModified(lastModified)) {\n+                                        watchKey.reportModified(relativePath);\n+                                    }\n+                                    entry.update(lastModified, currentTick);\n+                                }\n+                            } else {\n+                                if (isNew) {\n+                                    files.put(fileName,\n+                                            new Entry(false, lastModified, currentTick));\n+                                    watchKey.reportCreated(relativePath);\n+                                } else {\n+                                    if (entry.isDirectory) { \/\/ Used to be a directory, now a file.\n+                                        watchKey.reportDeleted(relativePath);\n+                                        files.put(fileName,\n+                                                new Entry(false, lastModified, currentTick));\n+                                        watchKey.reportCreated(relativeRootPath.resolve(fileName));\n+                                    } else if (entry.isModified(lastModified)) {\n+                                        watchKey.reportModified(relativePath);\n+                                    }\n+                                    entry.update(lastModified, currentTick);\n+                                }\n+                            }\n+                        } catch (IOException ignore) {\n+                            \/\/ Simply skip the file we couldn't read; it'll get marked as deleted later.\n+                        }\n+                    }\n+                } catch (IOException | DirectoryIteratorException ignore) {\n+                    \/\/ Most probably this directory has just been deleted; its parent will notice that.\n+                }\n+\n+                checkDeleted(watchKey);\n+            }\n+\n+            private void checkDeleted(final MacOSXWatchKey watchKey) {\n+                final Iterator<Map.Entry<Path, Entry>> it = files.entrySet().iterator();\n+                while (it.hasNext()) {\n+                    final Map.Entry<Path, Entry> mapEntry = it.next();\n+                    final Entry entry = mapEntry.getValue();\n+                    if (entry.lastTickCount != currentTick) {\n+                        final Path file = mapEntry.getKey();\n+                        it.remove();\n+                        watchKey.reportDeleted(relativeRootPath.resolve(file));\n+                    }\n+                }\n+            }\n+\n+            \/**\n+             * Information about an entry in a directory.\n+             *\/\n+            private static class Entry {\n+                private long lastModified;\n+                private long lastTickCount;\n+                private final boolean isDirectory;\n+\n+                Entry(final boolean isDirectory, final long lastModified, final long lastTickCount) {\n+                    this.lastModified  = lastModified;\n+                    this.lastTickCount = lastTickCount;\n+                    this.isDirectory   = isDirectory;\n+                }\n+\n+                boolean isModified(final long lastModified) {\n+                    return (this.lastModified != lastModified);\n+                }\n+\n+                void update(final long lastModified, final long lastTickCount) {\n+                    this.lastModified = lastModified;\n+                    this.lastTickCount = lastTickCount;\n+                }\n+            }\n+        }\n+\n+        private void reportCreated(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.CREATE))\n+                signalEvent(StandardWatchEventKinds.ENTRY_CREATE, path);\n+        }\n+\n+        private void reportDeleted(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.DELETE))\n+                signalEvent(StandardWatchEventKinds.ENTRY_DELETE, path);\n+        }\n+\n+        private void reportModified(final Path path) {\n+           if (eventsToWatch.contains(FSEventKind.MODIFY))\n+                signalEvent(StandardWatchEventKinds.ENTRY_MODIFY, path);\n+        }\n+\n+        private void reportOverflow(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.OVERFLOW))\n+                signalEvent(StandardWatchEventKinds.OVERFLOW, path);\n+        }\n+\n+        public Object getRootPathKey() {\n+            return rootPathKey;\n+        }\n+\n+        public Path getRealRootPath() {\n+            return realRootPath;\n+        }\n+\n+        @Override\n+        public boolean isValid() {\n+            synchronized (eventStreamRefLock) {\n+                return eventStreamRef != 0;\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (!isValid()) return;\n+\n+            \/\/ First, must stop the corresponding run loop:\n+            ((MacOSXWatchService) watcher()).cancel(this);\n+\n+            \/\/ Next, invalidate the corresponding native FSEventStream.\n+            invalidate();\n+        }\n+\n+        void invalidate() {\n+            synchronized (eventStreamRefLock) {\n+                if (isValid()) {\n+                    eventStreamStop(eventStreamRef);\n+                    eventStreamRef = 0;\n+                }\n+            }\n+        }\n+\n+        long getEventStreamRef() {\n+            synchronized (eventStreamRefLock) {\n+                assert (isValid());\n+                return eventStreamRef;\n+            }\n+        }\n+    }\n+\n+    \/* native methods *\/\n+\n+    private static native long eventStreamCreate(String dir, double latencyInSeconds, int flags);\n+    private static native void eventStreamSchedule(long eventStreamRef, long runLoopRef);\n+    private static native void eventStreamStop(long eventStreamRef);\n+    private static native long CFRunLoopGetCurrent();\n+    private static native void CFRunLoopRun(final MacOSXWatchService watchService);\n+    private static native void CFRunLoopStop(long runLoopRef);\n+\n+    private static native void initIDs();\n+\n+    static {\n+        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n+        initIDs();\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXWatchService.java","additions":634,"deletions":0,"binary":false,"changes":634,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"nio_util.h\"\n+\n+#include <CoreFoundation\/CoreFoundation.h>\n+#include <CoreServices\/CoreServices.h>\n+\n+\/\/ MacOSXWatchService.callback()\n+static jmethodID        callbackMID;\n+\/\/ The instance of MacOSXWatchService that is associated with this thread\n+static __thread jobject watchService;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_initIDs(JNIEnv* env, __unused jclass clazz)\n+{\n+    callbackMID = (*env)->GetMethodID(env, clazz,\n+                                      \"callback\", \"(J[Ljava\/lang\/String;J)V\");\n+}\n+\n+extern CFStringRef\n+toCFString(JNIEnv *env, jstring javaString);\n+\n+static jboolean\n+convertToJavaStringArray(JNIEnv* env,\n+                         char **eventPaths,\n+                         const jsize numEventsToReport,\n+                         jobjectArray javaEventPathsArray)\n+{\n+    for (jsize i = 0; i < numEventsToReport; i++) {\n+        const jstring path = JNU_NewStringPlatform(env, eventPaths[i]);\n+        CHECK_NULL_RETURN(path, FALSE);\n+        (*env)->SetObjectArrayElement(env, javaEventPathsArray, i, path);\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+static void\n+callJavaCallback(JNIEnv* env,\n+                 jlong streamRef,\n+                 jobjectArray javaEventPathsArray,\n+                 jlong eventFlags)\n+{\n+    if (callbackMID != NULL && watchService != NULL) {\n+        \/\/ We are called on the run loop thread, so it's OK to use\n+        \/\/ the thread-local reference to the watch service.\n+        (*env)->CallVoidMethod(env, watchService, callbackMID,\n+                               streamRef, javaEventPathsArray, eventFlags);\n+    }\n+}\n+\n+\/**\n+ * Callback that is invoked on the run loop thread and informs of new\n+ * file-system events from an FSEventStream.\n+ *\/\n+static void\n+callback(__unused ConstFSEventStreamRef streamRef,\n+         __unused void *clientCallBackInfo,\n+         size_t numEventsTotal,\n+         void *eventPaths,\n+         const FSEventStreamEventFlags eventFlags[],\n+         __unused const FSEventStreamEventId eventIds[])\n+{\n+    JNIEnv *env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);\n+    if (!env) { \/\/ Shouldn't happen as run loop starts from Java code\n+        return;\n+    }\n+\n+    \/\/ We can get more events at once than the number of Java array elements,\n+    \/\/ so report them in chunks.\n+    const size_t MAX_EVENTS_TO_REPORT_AT_ONCE = (INT_MAX - 2);\n+\n+    jboolean success = JNI_TRUE;\n+    for(size_t eventIndex = 0; success && (eventIndex < numEventsTotal); ) {\n+        const size_t numEventsRemaining = (numEventsTotal - eventIndex);\n+        const jsize  numEventsToReport  = (numEventsRemaining > MAX_EVENTS_TO_REPORT_AT_ONCE)\n+                                        ? MAX_EVENTS_TO_REPORT_AT_ONCE\n+                                        : numEventsRemaining;\n+\n+        const jboolean localFramePushed\n+            = ((*env)->PushLocalFrame(env, numEventsToReport + 5) == JNI_OK);\n+        success = localFramePushed;\n+\n+        jobjectArray javaEventPathsArray = NULL;\n+        if (success) {\n+            javaEventPathsArray = (*env)->NewObjectArray(env,\n+                                                         (jsize)numEventsToReport,\n+                                                         JNU_ClassString(env),\n+                                                         NULL);\n+            success = (javaEventPathsArray != NULL);\n+        }\n+\n+        if (success) {\n+            success = convertToJavaStringArray(env,\n+                                               &((char**)eventPaths)[eventIndex],\n+                                               numEventsToReport,\n+                                               javaEventPathsArray);\n+        }\n+\n+        callJavaCallback(env,\n+                         ptr_to_jlong(streamRef),\n+                         javaEventPathsArray,\n+                         ptr_to_jlong(&eventFlags[eventIndex]));\n+\n+        if ((*env)->ExceptionCheck(env)) {\n+            (*env)->ExceptionDescribe(env);\n+        }\n+\n+        if (localFramePushed) {\n+            (*env)->PopLocalFrame(env, NULL);\n+        }\n+\n+        eventIndex += numEventsToReport;\n+    }\n+}\n+\n+\/**\n+ * Creates a new FSEventStream and returns FSEventStreamRef for it.\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamCreate(JNIEnv* env,\n+                                                     __unused jclass clazz,\n+                                                     jstring dir,\n+                                                     jdouble latencyInSeconds,\n+                                                     jint flags)\n+{\n+    const CFStringRef path = toCFString(env, dir);\n+    CHECK_NULL_RETURN(path, 0);\n+    const CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **) &path,\n+                                                  1, NULL);\n+    CHECK_NULL_RETURN(pathsToWatch, 0);\n+\n+    const FSEventStreamRef stream = FSEventStreamCreate(\n+            NULL,\n+            &callback,\n+            NULL,\n+            pathsToWatch,\n+            kFSEventStreamEventIdSinceNow,\n+            (CFAbsoluteTime) latencyInSeconds,\n+            flags);\n+\n+    return ptr_to_jlong(stream);\n+}\n+\n+\n+\/**\n+ * Schedules the given FSEventStream with the given run loop. Starts the stream\n+ * so that the run loop can receive events from the stream.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamSchedule(__unused JNIEnv* env,\n+                                                       __unused jclass clazz,\n+                                                       jlong eventStreamRef,\n+                                                       jlong runLoopRef)\n+{\n+    const FSEventStreamRef stream  = jlong_to_ptr(eventStreamRef);\n+    const CFRunLoopRef     runLoop = jlong_to_ptr(runLoopRef);\n+\n+    FSEventStreamScheduleWithRunLoop(stream, runLoop, kCFRunLoopDefaultMode);\n+    FSEventStreamStart(stream);\n+}\n+\n+\/**\n+ * Performs the steps necessary to dispose of the given FSEventStreamRef.\n+ * The stream must have been started and scheduled with a run loop.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamStop(__unused JNIEnv* env,\n+                                                   __unused jclass clazz,\n+                                                   jlong eventStreamRef)\n+{\n+    const FSEventStreamRef streamRef = jlong_to_ptr(eventStreamRef);\n+\n+    FSEventStreamStop(streamRef);       \/\/ Unregister with the FS Events service.\n+                                        \/\/ No more callbacks from this stream.\n+    FSEventStreamInvalidate(streamRef); \/\/ De-schedule from any runloops.\n+    FSEventStreamRelease(streamRef);    \/\/ Decrement the stream's refcount.\n+}\n+\n+\/**\n+ * Returns the CFRunLoop object for the current thread.\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopGetCurrent(__unused JNIEnv* env,\n+                                                       __unused jclass clazz)\n+{\n+    return ptr_to_jlong(CFRunLoopGetCurrent());\n+}\n+\n+\/**\n+ * Simply calls CFRunLoopRun() to run current thread's run loop for as long as\n+ * there are event sources attached to it.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopRun(__unused JNIEnv* env,\n+                                                __unused jclass clazz,\n+                                                jlong watchServiceObject)\n+{\n+    \/\/ Thread-local pointer to the WatchService instance will be used by the callback\n+    \/\/ on this thread.\n+    watchService = (*env)->NewGlobalRef(env, jlong_to_ptr(watchServiceObject));\n+    CFRunLoopRun();\n+    (*env)->DeleteGlobalRef(env, watchService);\n+    watchService = NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopStop(__unused JNIEnv* env,\n+                                                 __unused jclass clazz,\n+                                                 jlong runLoopRef)\n+{\n+    CFRunLoopStop(jlong_to_ptr(runLoopRef));\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/MacOSXWatchService.c","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static CFStringRef toCFString(JNIEnv *env, jstring javaString)\n+CFStringRef toCFString(JNIEnv *env, jstring javaString)\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/UTIFileTypeDetector.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+#include \"nio_util.h\"\n+\n+JavaVM *jvm;\n@@ -34,0 +37,1 @@\n+    jvm = vm;\n","filename":"src\/java.base\/share\/native\/libnio\/nio_util.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+extern JavaVM *jvm;\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/nio_util.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Run several WatchService tests with -Xcheck:jni to check for\n+ *          warnings.\n+ * @requires os.family == \"mac\"\n+ * @library \/test\/lib\n+ * @build UpdateInterference DeleteInterference LotsOfCancels LotsOfCloses\n+ * @run main JNIChecks\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class JNIChecks {\n+\n+    public static void main(String[] args) throws Exception {\n+        {\n+            System.out.println(\"Test 1: UpdateInterference\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", UpdateInterference.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 2: DeleteInterference\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", DeleteInterference.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 3: LotsOfCancels\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", LotsOfCancels.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 4: LotsOfCloses\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", LotsOfCloses.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/JNIChecks.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Verifies that Files.move() of a directory hierarchy is correctly\n+ *          reported by WatchService.\n+ * @requires os.family == \"mac\"\n+ * @library ..\n+ * @run main Move\n+ *\/\n+\n+import java.nio.file.*;\n+import static java.nio.file.StandardWatchEventKinds.*;\n+import java.nio.file.attribute.*;\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import com.sun.nio.file.ExtendedWatchEventModifier;\n+\n+public class Move {\n+\n+    static void checkKey(WatchKey key, Path dir) {\n+        if (!key.isValid())\n+            throw new RuntimeException(\"Key is not valid\");\n+        if (key.watchable() != dir)\n+            throw new RuntimeException(\"Unexpected watchable\");\n+    }\n+\n+    static void takeExpectedKey(WatchService watcher, WatchKey expected) {\n+        System.out.println(\"take events...\");\n+        WatchKey key;\n+        try {\n+            key = watcher.take();\n+        } catch (InterruptedException x) {\n+            \/\/ not expected\n+            throw new RuntimeException(x);\n+        }\n+        if (key != expected)\n+            throw new RuntimeException(\"removed unexpected key\");\n+    }\n+\n+    static void dumpEvents(final List<WatchEvent<?>> events) {\n+        System.out.println(\"Got events: \");\n+        for(WatchEvent<?> event : events) {\n+            System.out.println(event.kind() + \" for '\" + event.context() + \"' count = \" + event.count());\n+        }\n+    }\n+\n+    static void assertHasEvent(final List<WatchEvent<?>> events, final Path path, final WatchEvent.Kind<Path> kind) {\n+        for (final WatchEvent<?> event : events) {\n+            if (event.context().equals(path) && event.kind().equals(kind)) {\n+                if (event.count() != 1) {\n+                    throw new RuntimeException(\"Expected count 1 for event \" + event);\n+                }\n+                return;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Didn't find event \" + kind + \" for path '\" + path + \"'\");\n+    }\n+\n+    \/**\n+     * Verifies move of a directory sub-tree with and without FILE_TREE option.\n+     *\/\n+    static void testMoveSubtree(final Path dir) throws IOException {\n+        final FileSystem fs = FileSystems.getDefault();\n+        final WatchService rootWatcher = fs.newWatchService();\n+        final WatchService subtreeWatcher = fs.newWatchService();\n+        try {\n+            Path path = dir.resolve(\"root\");\n+            Files.createDirectory(path);\n+            System.out.println(\"Created \" + path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\");\n+            Files.createDirectories(path);\n+            System.out.println(\"Created \" + path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"file1\");\n+            Files.createFile(path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\").resolve(\"file3\");\n+            Files.createFile(path);\n+\n+            \/\/ register with both watch services (different events)\n+            System.out.println(\"register for different events\");\n+            final WatchKey rootKey = dir.resolve(dir.resolve(\"root\")).register(rootWatcher,\n+                    new WatchEvent.Kind<?>[]{ ENTRY_CREATE, ENTRY_DELETE });\n+\n+            System.out.println(\"Move root\/subdir\/1\/2 -> root\/subdir\/2.moved\");\n+            Files.move(dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\"),\n+                       dir.resolve(\"root\").resolve(\"subdir\").resolve(\"2.moved\"));\n+\n+            \/\/ Check that changes in a subdirectory were not noticed by the root directory watcher\n+            {\n+                final WatchKey key = rootWatcher.poll();\n+                if (key != null)\n+                    throw new RuntimeException(\"key not expected\");\n+            }\n+\n+            rootKey.reset();\n+\n+            System.out.println(\"Move root\/subdir\/2.moved -> root\/2\");\n+            Files.move(dir.resolve(\"root\").resolve(\"subdir\").resolve(\"2.moved\"),\n+                       dir.resolve(\"root\").resolve(\"2\"));\n+\n+            \/\/ Check that the root directory watcher has noticed one new directory.\n+            {\n+                takeExpectedKey(rootWatcher, rootKey);\n+                final List<WatchEvent<?>> events = rootKey.pollEvents();\n+                dumpEvents(events);\n+                assertHasEvent(events, Path.of(\"2\"), ENTRY_CREATE);\n+                if (events.size() > 1) {\n+                    throw new RuntimeException(\"Too many events\");\n+                }\n+            }\n+\n+        } finally {\n+            rootWatcher.close();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies quickly deleting a file and creating a directory with the same name (and back)\n+     * is recognized by WatchService.\n+     *\/\n+    static void testMoveFileToDirectory(final Path dir) throws IOException {\n+        final FileSystem fs = FileSystems.getDefault();\n+        try (final WatchService watcher = fs.newWatchService()) {\n+            Files.createDirectory(dir.resolve(\"dir\"));\n+            Files.createFile(dir.resolve(\"file\"));\n+\n+            final WatchKey key = dir.register(watcher, new WatchEvent.Kind<?>[]{ENTRY_CREATE, ENTRY_DELETE});\n+\n+            for (int i = 0; i < 4; i++) {\n+                System.out.println(\"Iteration \" + i);\n+                Files.delete(dir.resolve(\"dir\"));\n+                Files.delete(dir.resolve(\"file\"));\n+                if (i % 2 == 1) {\n+                    Files.createDirectory(dir.resolve(\"dir\"));\n+                    Files.createFile(dir.resolve(\"file\"));\n+                } else {\n+                    Files.createDirectory(dir.resolve(\"file\"));\n+                    Files.createFile(dir.resolve(\"dir\"));\n+                }\n+\n+                takeExpectedKey(watcher, key);\n+                final List<WatchEvent<?>> events = key.pollEvents();\n+                dumpEvents(events);\n+\n+                final long countDirCreated = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"dir\")) && event.kind().equals(ENTRY_CREATE)).count();\n+                final long countDirDeleted = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"dir\")) && event.kind().equals(ENTRY_DELETE)).count();\n+                final long countFileCreated = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"file\")) && event.kind().equals(ENTRY_CREATE)).count();\n+                final long countFileDeleted = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"file\")) && event.kind().equals(ENTRY_DELETE)).count();\n+                if (countDirCreated != 1) throw new RuntimeException(\"Not one CREATE for dir\");\n+                if (countDirDeleted != 1) throw new RuntimeException(\"Not one DELETE for dir\");\n+                if (countFileCreated != 1) throw new RuntimeException(\"Not one CREATE for file\");\n+                if (countFileDeleted != 1) throw new RuntimeException(\"Not one DELETE for file\");\n+\n+                key.reset();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Path dir = TestUtil.createTemporaryDirectory();\n+        try {\n+            testMoveSubtree(dir);\n+        } catch(UnsupportedOperationException e) {\n+            System.out.println(\"FILE_TREE watching is not supported; test considered passed\");\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+\n+        dir = TestUtil.createTemporaryDirectory();\n+        try {\n+            testMoveFileToDirectory(dir);\n+        } catch(UnsupportedOperationException e) {\n+            System.out.println(\"FILE_TREE watching is not supported; test considered passed\");\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/Move.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -7,0 +7,1 @@\n+    permission java.lang.RuntimePermission \"loadLibrary.nio\";\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/test.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}