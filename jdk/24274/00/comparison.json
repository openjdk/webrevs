{"files":[{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/--------------------------------------------------------\n-\/\/               FpuStackSim\n-\/\/--------------------------------------------------------\n-\n-\/\/ No FPU stack on AARCH64\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FpuStackSim_aarch64.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_AARCH64_C1_FPUSTACKSIM_AARCH64_HPP\n-#define CPU_AARCH64_C1_FPUSTACKSIM_AARCH64_HPP\n-\n-\/\/ No FPU stack on AARCH64\n-class FpuStackSim;\n-\n-#endif \/\/ CPU_AARCH64_C1_FPUSTACKSIM_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FpuStackSim_aarch64.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -587,1 +587,1 @@\n-        reg2stack(FrameMap::rscratch1_opr, dest, c->type(), false);\n+        reg2stack(FrameMap::rscratch1_opr, dest, c->type());\n@@ -594,1 +594,1 @@\n-      reg2stack(FrameMap::rscratch1_opr, dest, c->type(), false);\n+      reg2stack(FrameMap::rscratch1_opr, dest, c->type());\n@@ -719,1 +719,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {\n@@ -755,1 +755,1 @@\n-void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n+void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -908,1 +908,1 @@\n-  reg2stack(temp, dest, dest->type(), false);\n+  reg2stack(temp, dest, dest->type());\n@@ -1601,1 +1601,1 @@\n-void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {\n+void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info) {\n@@ -1772,3 +1772,0 @@\n-void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }\n-\n-\n@@ -2852,2 +2849,1 @@\n-    move_op(src, dest, type, lir_patch_none, info,\n-            \/*pop_fpu_stack*\/false, \/*wide*\/false);\n+    move_op(src, dest, type, lir_patch_none, info, \/*wide*\/false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  void arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ No FPU stack on AArch64\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LinearScan_aarch64.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/ Nothing needed here\n","filename":"src\/hotspot\/cpu\/arm\/c1_FpuStackSim_arm.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ARM_C1_FPUSTACKSIM_ARM_HPP\n-#define CPU_ARM_C1_FPUSTACKSIM_ARM_HPP\n-\n-\/\/ Nothing needed here\n-\n-#endif \/\/ CPU_ARM_C1_FPUSTACKSIM_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/c1_FpuStackSim_arm.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -457,1 +457,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {\n@@ -496,1 +496,1 @@\n-                            bool pop_fpu_stack, bool wide) {\n+                            bool wide) {\n@@ -1515,1 +1515,1 @@\n-void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {\n+void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ No FPU stack on ARM\n-}\n","filename":"src\/hotspot\/cpu\/arm\/c1_LinearScan_arm.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_PPC_C1_FPUSTACKSIM_PPC_HPP\n-#define CPU_PPC_C1_FPUSTACKSIM_PPC_HPP\n-\n-\/\/ No FPU stack on PPC.\n-class FpuStackSim;\n-\n-#endif \/\/ CPU_PPC_C1_FPUSTACKSIM_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/c1_FpuStackSim_ppc.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1206,1 +1206,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type) {\n@@ -1249,1 +1249,1 @@\n-                            LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,\n+                            LIR_PatchCode patch_code, CodeEmitInfo* info,\n@@ -1620,1 +1620,1 @@\n-                             CodeEmitInfo* info, bool pop_fpu_stack) {\n+                             CodeEmitInfo* info) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-void LinearScan::allocate_fpu_stack() {\n-  Unimplemented();\n-  \/\/ No FPU stack on PPC\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LinearScan_ppc.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/--------------------------------------------------------\n-\/\/               FpuStackSim\n-\/\/--------------------------------------------------------\n-\n-\/\/ No FPU stack on RISCV\n","filename":"src\/hotspot\/cpu\/riscv\/c1_FpuStackSim_riscv.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_RISCV_C1_FPUSTACKSIM_RISCV_HPP\n-#define CPU_RISCV_C1_FPUSTACKSIM_RISCV_HPP\n-\n-\/\/ No FPU stack on RISCV\n-class FpuStackSim;\n-\n-#endif \/\/ CPU_RISCV_C1_FPUSTACKSIM_RISCV_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/c1_FpuStackSim_riscv.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -268,1 +268,1 @@\n-                             CodeEmitInfo* info, bool pop_fpu_stack) {\n+                             CodeEmitInfo* info) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arith_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-        reg2stack(FrameMap::t1_opr, dest, c->type(), false);\n+        reg2stack(FrameMap::t1_opr, dest, c->type());\n@@ -506,1 +506,1 @@\n-      reg2stack(FrameMap::t1_opr, dest, c->type(), false);\n+      reg2stack(FrameMap::t1_opr, dest, c->type());\n@@ -623,1 +623,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {\n@@ -656,1 +656,1 @@\n-void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n+void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -775,1 +775,1 @@\n-  reg2stack(temp, dest, dest->type(), false);\n+  reg2stack(temp, dest, dest->type());\n@@ -894,1 +894,0 @@\n-          false,   \/\/ pop_fpu_stack\n@@ -899,1 +898,0 @@\n-          false,   \/\/ pop_fpu_stack\n@@ -1871,1 +1869,1 @@\n-    move_op(src, dest, type, lir_patch_none, info, \/* pop_fpu_stack *\/ false, \/* wide *\/ false);\n+    move_op(src, dest, type, lir_patch_none, info, \/* wide *\/ false);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ No FPU stack on RISCV\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LinearScan_riscv.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_S390_C1_FPUSTACKSIM_S390_HPP\n-#define CPU_S390_C1_FPUSTACKSIM_S390_HPP\n-\n-\/\/ No FPU stack on ZARCH_64\n-class FpuStackSim;\n-\n-#endif \/\/ CPU_S390_C1_FPUSTACKSIM_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/c1_FpuStackSim_s390.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1019,1 +1019,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {\n@@ -1077,1 +1077,1 @@\n-                            LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,\n+                            LIR_PatchCode patch_code, CodeEmitInfo* info,\n@@ -1504,1 +1504,1 @@\n-                             CodeEmitInfo* info, bool pop_fpu_stack) {\n+                             CodeEmitInfo* info) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ No FPU stack on ZARCH_64.\n-  ShouldNotCallThis();\n-}\n","filename":"src\/hotspot\/cpu\/s390\/c1_LinearScan_s390.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,200 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_FpuStackSim.hpp\"\n-#include \"c1\/c1_FrameMap.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-\/\/--------------------------------------------------------\n-\/\/               FpuStackSim\n-\/\/--------------------------------------------------------\n-\n-\/\/ This class maps the FPU registers to their stack locations; it computes\n-\/\/ the offsets between individual registers and simulates the FPU stack.\n-\n-const int EMPTY = -1;\n-\n-int FpuStackSim::regs_at(int i) const {\n-  assert(i >= 0 && i < FrameMap::nof_fpu_regs, \"out of bounds\");\n-  return _regs[i];\n-}\n-\n-void FpuStackSim::set_regs_at(int i, int val) {\n-  assert(i >= 0 && i < FrameMap::nof_fpu_regs, \"out of bounds\");\n-  _regs[i] = val;\n-}\n-\n-void FpuStackSim::dec_stack_size() {\n-  _stack_size--;\n-  assert(_stack_size >= 0, \"FPU stack underflow\");\n-}\n-\n-void FpuStackSim::inc_stack_size() {\n-  _stack_size++;\n-  assert(_stack_size <= FrameMap::nof_fpu_regs, \"FPU stack overflow\");\n-}\n-\n-FpuStackSim::FpuStackSim(Compilation* compilation)\n- : _compilation(compilation)\n-{\n-  _stack_size = 0;\n-  for (int i = 0; i < FrameMap::nof_fpu_regs; i++) {\n-    set_regs_at(i, EMPTY);\n-  }\n-}\n-\n-\n-void FpuStackSim::pop() {\n-  if (TraceFPUStack) { tty->print(\"FPU-pop \"); print(); tty->cr(); }\n-  set_regs_at(tos_index(), EMPTY);\n-  dec_stack_size();\n-}\n-\n-void FpuStackSim::pop(int rnr) {\n-  if (TraceFPUStack) { tty->print(\"FPU-pop %d\", rnr); print(); tty->cr(); }\n-  assert(regs_at(tos_index()) == rnr, \"rnr is not on TOS\");\n-  set_regs_at(tos_index(), EMPTY);\n-  dec_stack_size();\n-}\n-\n-\n-void FpuStackSim::push(int rnr) {\n-  if (TraceFPUStack) { tty->print(\"FPU-push %d\", rnr); print(); tty->cr(); }\n-  assert(regs_at(stack_size()) == EMPTY, \"should be empty\");\n-  set_regs_at(stack_size(), rnr);\n-  inc_stack_size();\n-}\n-\n-\n-void FpuStackSim::swap(int offset) {\n-  if (TraceFPUStack) { tty->print(\"FPU-swap %d\", offset); print(); tty->cr(); }\n-  int t = regs_at(tos_index() - offset);\n-  set_regs_at(tos_index() - offset, regs_at(tos_index()));\n-  set_regs_at(tos_index(), t);\n-}\n-\n-\n-int FpuStackSim::offset_from_tos(int rnr) const {\n-  for (int i = tos_index(); i >= 0; i--) {\n-    if (regs_at(i) == rnr) {\n-      return tos_index() - i;\n-    }\n-  }\n-  assert(false, \"FpuStackSim: register not found\");\n-  BAILOUT_(\"FpuStackSim: register not found\", 0);\n-}\n-\n-\n-int FpuStackSim::get_slot(int tos_offset) const {\n-  return regs_at(tos_index() - tos_offset);\n-}\n-\n-void FpuStackSim::set_slot(int tos_offset, int rnr) {\n-  set_regs_at(tos_index() - tos_offset, rnr);\n-}\n-\n-void FpuStackSim::rename(int old_rnr, int new_rnr) {\n-  if (TraceFPUStack) { tty->print(\"FPU-rename %d %d\", old_rnr, new_rnr); print(); tty->cr(); }\n-  if (old_rnr == new_rnr)\n-    return;\n-  bool found = false;\n-  for (int i = 0; i < stack_size(); i++) {\n-    assert(regs_at(i) != new_rnr, \"should not see old occurrences of new_rnr on the stack\");\n-    if (regs_at(i) == old_rnr) {\n-      set_regs_at(i, new_rnr);\n-      found = true;\n-    }\n-  }\n-  assert(found, \"should have found at least one instance of old_rnr\");\n-}\n-\n-\n-bool FpuStackSim::contains(int rnr) {\n-  for (int i = 0; i < stack_size(); i++) {\n-    if (regs_at(i) == rnr) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool FpuStackSim::is_empty() {\n-#ifdef ASSERT\n-  if (stack_size() == 0) {\n-    for (int i = 0; i < FrameMap::nof_fpu_regs; i++) {\n-      assert(regs_at(i) == EMPTY, \"must be empty\");\n-    }\n-  }\n-#endif\n-  return stack_size() == 0;\n-}\n-\n-\n-bool FpuStackSim::slot_is_empty(int tos_offset) {\n-  return (regs_at(tos_index() - tos_offset) == EMPTY);\n-}\n-\n-\n-void FpuStackSim::clear() {\n-  if (TraceFPUStack) { tty->print(\"FPU-clear\"); print(); tty->cr(); }\n-  for (int i = tos_index(); i >= 0; i--) {\n-    set_regs_at(i, EMPTY);\n-  }\n-  _stack_size = 0;\n-}\n-\n-\n-intArray* FpuStackSim::write_state() {\n-  intArray* res = new intArray(1 + FrameMap::nof_fpu_regs);\n-  res->append(stack_size());\n-  for (int i = 0; i < FrameMap::nof_fpu_regs; i++) {\n-    res->append(regs_at(i));\n-  }\n-  return res;\n-}\n-\n-\n-void FpuStackSim::read_state(intArray* fpu_stack_state) {\n-  _stack_size = fpu_stack_state->at(0);\n-  for (int i = 0; i < FrameMap::nof_fpu_regs; i++) {\n-    set_regs_at(i, fpu_stack_state->at(1 + i));\n-  }\n-}\n-\n-\n-#ifndef PRODUCT\n-void FpuStackSim::print() {\n-  tty->print(\" N=%d[\", stack_size());\\\n-  for (int i = 0; i < stack_size(); i++) {\n-    int reg = regs_at(i);\n-    if (reg != EMPTY) {\n-      tty->print(\"%d\", reg);\n-    } else {\n-      tty->print(\"_\");\n-    }\n-  };\n-  tty->print(\" ]\");\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_FpuStackSim_x86.cpp","additions":0,"deletions":200,"binary":false,"changes":200,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_X86_C1_FPUSTACKSIM_X86_HPP\n-#define CPU_X86_C1_FPUSTACKSIM_X86_HPP\n-\n-\/\/  Simulates the FPU stack and maintains mapping [fpu-register -> stack offset]\n-\/\/  FPU registers are described as numbers from 0..nof_fpu_regs-1\n-\n-class Compilation;\n-\n-class FpuStackSim {\n- private:\n-  Compilation* _compilation;\n-  int          _stack_size;\n-  int          _regs[FrameMap::nof_fpu_regs];\n-\n-  int tos_index() const                        { return _stack_size - 1; }\n-\n-  int regs_at(int i) const;\n-  void set_regs_at(int i, int val);\n-  void dec_stack_size();\n-  void inc_stack_size();\n-\n-  \/\/ unified bailout support\n-  Compilation*  compilation() const              { return _compilation; }\n-  void          bailout(const char* msg) const   { compilation()->bailout(msg); }\n-  bool          bailed_out() const               { return compilation()->bailed_out(); }\n-\n- public:\n-  FpuStackSim(Compilation* compilation);\n-  void pop ();\n-  void pop (int rnr);                          \/\/ rnr must be on tos\n-  void push(int rnr);\n-  void swap(int offset);                       \/\/ exchange tos with tos + offset\n-  int offset_from_tos(int rnr) const;          \/\/ return the offset of the topmost instance of rnr from TOS\n-  int  get_slot(int tos_offset) const;         \/\/ return the entry at the given offset from TOS\n-  void set_slot(int tos_offset, int rnr);      \/\/ set the entry at the given offset from TOS\n-  void rename(int old_rnr, int new_rnr);       \/\/ rename all instances of old_rnr to new_rnr\n-  bool contains(int rnr);                      \/\/ debugging support only\n-  bool is_empty();\n-  bool slot_is_empty(int tos_offset);\n-  int stack_size() const                       { return _stack_size; }\n-  void clear();\n-  intArray* write_state();\n-  void read_state(intArray* fpu_stack_state);\n-\n-  void print() PRODUCT_RETURN;\n-};\n-\n-#endif \/\/ CPU_X86_C1_FPUSTACKSIM_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/c1_FpuStackSim_x86.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -111,2 +111,0 @@\n-LIR_Opr FrameMap::fpu0_float_opr;\n-LIR_Opr FrameMap::fpu0_double_opr;\n@@ -197,2 +195,0 @@\n-  fpu0_float_opr   = LIR_OprFact::single_fpu(0);\n-  fpu0_double_opr  = LIR_OprFact::double_fpu(0);\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,2 +115,0 @@\n-  static LIR_Opr fpu0_float_opr;\n-  static LIR_Opr fpu0_double_opr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,18 +164,0 @@\n-#ifndef _LP64\n-void LIR_Assembler::fpop() {\n-  __ fpop();\n-}\n-\n-void LIR_Assembler::fxch(int i) {\n-  __ fxch(i);\n-}\n-\n-void LIR_Assembler::fld(int i) {\n-  __ fld_s(i);\n-}\n-\n-void LIR_Assembler::ffree(int i) {\n-  __ ffree(i);\n-}\n-#endif \/\/ !_LP64\n-\n@@ -605,1 +587,1 @@\n-        if (LP64_ONLY(UseAVX <= 2 &&) c->is_zero_float()) {\n+        if (UseAVX <= 2 && c->is_zero_float()) {\n@@ -612,11 +594,0 @@\n-#ifndef _LP64\n-        assert(dest->is_single_fpu(), \"must be\");\n-        assert(dest->fpu_regnr() == 0, \"dest must be TOS\");\n-        if (c->is_zero_float()) {\n-          __ fldz();\n-        } else if (c->is_one_float()) {\n-          __ fld1();\n-        } else {\n-          __ fld_s (InternalAddress(float_constant(c->as_jfloat())));\n-        }\n-#else\n@@ -624,1 +595,0 @@\n-#endif \/\/ !_LP64\n@@ -631,1 +601,1 @@\n-        if (LP64_ONLY(UseAVX <= 2 &&) c->is_zero_double()) {\n+        if (UseAVX <= 2 && c->is_zero_double()) {\n@@ -638,11 +608,0 @@\n-#ifndef _LP64\n-        assert(dest->is_double_fpu(), \"must be\");\n-        assert(dest->fpu_regnrLo() == 0, \"dest must be TOS\");\n-        if (c->is_zero_double()) {\n-          __ fldz();\n-        } else if (c->is_one_double()) {\n-          __ fld1();\n-        } else {\n-          __ fld_d (InternalAddress(double_constant(c->as_jdouble())));\n-        }\n-#else\n@@ -650,1 +609,0 @@\n-#endif \/\/ !_LP64\n@@ -844,17 +802,0 @@\n-#ifndef _LP64\n-    \/\/ special moves from fpu-register to xmm-register\n-    \/\/ necessary for method results\n-  } else if (src->is_single_xmm() && !dest->is_single_xmm()) {\n-    __ movflt(Address(rsp, 0), src->as_xmm_float_reg());\n-    __ fld_s(Address(rsp, 0));\n-  } else if (src->is_double_xmm() && !dest->is_double_xmm()) {\n-    __ movdbl(Address(rsp, 0), src->as_xmm_double_reg());\n-    __ fld_d(Address(rsp, 0));\n-  } else if (dest->is_single_xmm() && !src->is_single_xmm()) {\n-    __ fstp_s(Address(rsp, 0));\n-    __ movflt(dest->as_xmm_float_reg(), Address(rsp, 0));\n-  } else if (dest->is_double_xmm() && !src->is_double_xmm()) {\n-    __ fstp_d(Address(rsp, 0));\n-    __ movdbl(dest->as_xmm_double_reg(), Address(rsp, 0));\n-#endif \/\/ !_LP64\n-\n@@ -869,7 +810,0 @@\n-#ifndef _LP64\n-    \/\/ move between fpu-registers (no instruction necessary because of fpu-stack)\n-  } else if (dest->is_single_fpu() || dest->is_double_fpu()) {\n-    assert(src->is_single_fpu() || src->is_double_fpu(), \"must match\");\n-    assert(src->fpu() == dest->fpu(), \"currently should be nothing to do\");\n-#endif \/\/ !_LP64\n-\n@@ -881,1 +815,1 @@\n-void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {\n+void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {\n@@ -910,14 +844,0 @@\n-#ifndef _LP64\n-  } else if (src->is_single_fpu()) {\n-    assert(src->fpu_regnr() == 0, \"argument must be on TOS\");\n-    Address dst_addr = frame_map()->address_for_slot(dest->single_stack_ix());\n-    if (pop_fpu_stack)     __ fstp_s (dst_addr);\n-    else                   __ fst_s  (dst_addr);\n-\n-  } else if (src->is_double_fpu()) {\n-    assert(src->fpu_regnrLo() == 0, \"argument must be on TOS\");\n-    Address dst_addr = frame_map()->address_for_slot(dest->double_stack_ix());\n-    if (pop_fpu_stack)     __ fstp_d (dst_addr);\n-    else                   __ fst_d  (dst_addr);\n-#endif \/\/ !_LP64\n-\n@@ -930,1 +850,1 @@\n-void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n+void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -957,1 +877,0 @@\n-#ifdef _LP64\n@@ -960,10 +879,0 @@\n-#else\n-      if (src->is_single_xmm()) {\n-        __ movflt(as_Address(to_addr), src->as_xmm_float_reg());\n-      } else {\n-        assert(src->is_single_fpu(), \"must be\");\n-        assert(src->fpu_regnr() == 0, \"argument must be on TOS\");\n-        if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));\n-        else                    __ fst_s (as_Address(to_addr));\n-      }\n-#endif \/\/ _LP64\n@@ -974,1 +883,0 @@\n-#ifdef _LP64\n@@ -977,10 +885,0 @@\n-#else\n-      if (src->is_double_xmm()) {\n-        __ movdbl(as_Address(to_addr), src->as_xmm_double_reg());\n-      } else {\n-        assert(src->is_double_fpu(), \"must be\");\n-        assert(src->fpu_regnrLo() == 0, \"argument must be on TOS\");\n-        if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));\n-        else                    __ fst_d (as_Address(to_addr));\n-      }\n-#endif \/\/ _LP64\n@@ -1103,12 +1001,0 @@\n-#ifndef _LP64\n-  } else if (dest->is_single_fpu()) {\n-    assert(dest->fpu_regnr() == 0, \"dest must be TOS\");\n-    Address src_addr = frame_map()->address_for_slot(src->single_stack_ix());\n-    __ fld_s(src_addr);\n-\n-  } else if (dest->is_double_fpu()) {\n-    assert(dest->fpu_regnrLo() == 0, \"dest must be TOS\");\n-    Address src_addr = frame_map()->address_for_slot(src->double_stack_ix());\n-    __ fld_d(src_addr);\n-#endif \/\/ _LP64\n-\n@@ -1197,5 +1083,0 @@\n-#ifndef _LP64\n-        assert(dest->is_single_fpu(), \"must be\");\n-        assert(dest->fpu_regnr() == 0, \"dest must be TOS\");\n-        __ fld_s(from_addr);\n-#else\n@@ -1203,1 +1084,0 @@\n-#endif \/\/ !LP64\n@@ -1212,5 +1092,0 @@\n-#ifndef _LP64\n-        assert(dest->is_double_fpu(), \"must be\");\n-        assert(dest->fpu_regnrLo() == 0, \"dest must be TOS\");\n-        __ fld_d(from_addr);\n-#else\n@@ -1218,1 +1093,0 @@\n-#endif \/\/ !LP64\n@@ -1460,2 +1334,0 @@\n-\n-#ifdef _LP64\n@@ -1501,68 +1373,0 @@\n-#else\n-    case Bytecodes::_f2d:\n-    case Bytecodes::_d2f:\n-      if (dest->is_single_xmm()) {\n-        __ cvtsd2ss(dest->as_xmm_float_reg(), src->as_xmm_double_reg());\n-      } else if (dest->is_double_xmm()) {\n-        __ cvtss2sd(dest->as_xmm_double_reg(), src->as_xmm_float_reg());\n-      } else {\n-        assert(src->fpu() == dest->fpu(), \"register must be equal\");\n-        \/\/ do nothing (float result is rounded later through spilling)\n-      }\n-      break;\n-\n-    case Bytecodes::_i2f:\n-    case Bytecodes::_i2d:\n-      if (dest->is_single_xmm()) {\n-        __ cvtsi2ssl(dest->as_xmm_float_reg(), src->as_register());\n-      } else if (dest->is_double_xmm()) {\n-        __ cvtsi2sdl(dest->as_xmm_double_reg(), src->as_register());\n-      } else {\n-        assert(dest->fpu() == 0, \"result must be on TOS\");\n-        __ movl(Address(rsp, 0), src->as_register());\n-        __ fild_s(Address(rsp, 0));\n-      }\n-      break;\n-\n-    case Bytecodes::_l2f:\n-    case Bytecodes::_l2d:\n-      assert(!dest->is_xmm_register(), \"result in xmm register not supported (no SSE instruction present)\");\n-      assert(dest->fpu() == 0, \"result must be on TOS\");\n-      __ movptr(Address(rsp, 0),          src->as_register_lo());\n-      __ movl(Address(rsp, BytesPerWord), src->as_register_hi());\n-      __ fild_d(Address(rsp, 0));\n-      \/\/ float result is rounded later through spilling\n-      break;\n-\n-    case Bytecodes::_f2i:\n-    case Bytecodes::_d2i:\n-      if (src->is_single_xmm()) {\n-        __ cvttss2sil(dest->as_register(), src->as_xmm_float_reg());\n-      } else if (src->is_double_xmm()) {\n-        __ cvttsd2sil(dest->as_register(), src->as_xmm_double_reg());\n-      } else {\n-        assert(src->fpu() == 0, \"input must be on TOS\");\n-        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_trunc()));\n-        __ fist_s(Address(rsp, 0));\n-        __ movl(dest->as_register(), Address(rsp, 0));\n-        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n-      }\n-      \/\/ IA32 conversion instructions do not match JLS for overflow, underflow and NaN -> fixup in stub\n-      assert(op->stub() != nullptr, \"stub required\");\n-      __ cmpl(dest->as_register(), 0x80000000);\n-      __ jcc(Assembler::equal, *op->stub()->entry());\n-      __ bind(*op->stub()->continuation());\n-      break;\n-\n-    case Bytecodes::_f2l:\n-    case Bytecodes::_d2l:\n-      assert(!src->is_xmm_register(), \"input in xmm register not supported (no SSE instruction present)\");\n-      assert(src->fpu() == 0, \"input must be on TOS\");\n-      assert(dest == FrameMap::long0_opr, \"runtime stub places result in these registers\");\n-\n-      \/\/ instruction sequence too long to inline it here\n-      {\n-        __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::fpu2long_stub_id)));\n-      }\n-      break;\n-#endif \/\/ _LP64\n@@ -2035,1 +1839,1 @@\n-void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {\n+void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info) {\n@@ -2216,74 +2020,0 @@\n-#ifndef _LP64\n-  } else if (left->is_single_fpu()) {\n-    assert(dest->is_single_fpu(),  \"fpu stack allocation required\");\n-\n-    if (right->is_single_fpu()) {\n-      arith_fpu_implementation(code, left->fpu_regnr(), right->fpu_regnr(), dest->fpu_regnr(), pop_fpu_stack);\n-\n-    } else {\n-      assert(left->fpu_regnr() == 0, \"left must be on TOS\");\n-      assert(dest->fpu_regnr() == 0, \"dest must be on TOS\");\n-\n-      Address raddr;\n-      if (right->is_single_stack()) {\n-        raddr = frame_map()->address_for_slot(right->single_stack_ix());\n-      } else if (right->is_constant()) {\n-        address const_addr = float_constant(right->as_jfloat());\n-        assert(const_addr != nullptr, \"incorrect float\/double constant maintenance\");\n-        \/\/ hack for now\n-        raddr = __ as_Address(InternalAddress(const_addr));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      switch (code) {\n-        case lir_add: __ fadd_s(raddr); break;\n-        case lir_sub: __ fsub_s(raddr); break;\n-        case lir_mul: __ fmul_s(raddr); break;\n-        case lir_div: __ fdiv_s(raddr); break;\n-        default:      ShouldNotReachHere();\n-      }\n-    }\n-\n-  } else if (left->is_double_fpu()) {\n-    assert(dest->is_double_fpu(),  \"fpu stack allocation required\");\n-\n-    if (code == lir_mul || code == lir_div) {\n-      \/\/ Double values require special handling for strictfp mul\/div on x86\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n-      __ fmulp(left->fpu_regnrLo() + 1);\n-    }\n-\n-    if (right->is_double_fpu()) {\n-      arith_fpu_implementation(code, left->fpu_regnrLo(), right->fpu_regnrLo(), dest->fpu_regnrLo(), pop_fpu_stack);\n-\n-    } else {\n-      assert(left->fpu_regnrLo() == 0, \"left must be on TOS\");\n-      assert(dest->fpu_regnrLo() == 0, \"dest must be on TOS\");\n-\n-      Address raddr;\n-      if (right->is_double_stack()) {\n-        raddr = frame_map()->address_for_slot(right->double_stack_ix());\n-      } else if (right->is_constant()) {\n-        \/\/ hack for now\n-        raddr = __ as_Address(InternalAddress(double_constant(right->as_jdouble())));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      switch (code) {\n-        case lir_add: __ fadd_d(raddr); break;\n-        case lir_sub: __ fsub_d(raddr); break;\n-        case lir_mul: __ fmul_d(raddr); break;\n-        case lir_div: __ fdiv_d(raddr); break;\n-        default: ShouldNotReachHere();\n-      }\n-    }\n-\n-    if (code == lir_mul || code == lir_div) {\n-      \/\/ Double values require special handling for strictfp mul\/div on x86\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n-      __ fmulp(dest->fpu_regnrLo() + 1);\n-    }\n-#endif \/\/ !_LP64\n-\n@@ -2331,58 +2061,0 @@\n-#ifndef _LP64\n-void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {\n-  assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), \"invalid LIR\");\n-  assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), \"invalid LIR\");\n-  assert(left_index == 0 || right_index == 0, \"either must be on top of stack\");\n-\n-  bool left_is_tos = (left_index == 0);\n-  bool dest_is_tos = (dest_index == 0);\n-  int non_tos_index = (left_is_tos ? right_index : left_index);\n-\n-  switch (code) {\n-    case lir_add:\n-      if (pop_fpu_stack)       __ faddp(non_tos_index);\n-      else if (dest_is_tos)    __ fadd (non_tos_index);\n-      else                     __ fadda(non_tos_index);\n-      break;\n-\n-    case lir_sub:\n-      if (left_is_tos) {\n-        if (pop_fpu_stack)     __ fsubrp(non_tos_index);\n-        else if (dest_is_tos)  __ fsub  (non_tos_index);\n-        else                   __ fsubra(non_tos_index);\n-      } else {\n-        if (pop_fpu_stack)     __ fsubp (non_tos_index);\n-        else if (dest_is_tos)  __ fsubr (non_tos_index);\n-        else                   __ fsuba (non_tos_index);\n-      }\n-      break;\n-\n-    case lir_mul:\n-      if (pop_fpu_stack)       __ fmulp(non_tos_index);\n-      else if (dest_is_tos)    __ fmul (non_tos_index);\n-      else                     __ fmula(non_tos_index);\n-      break;\n-\n-    case lir_div:\n-      if (left_is_tos) {\n-        if (pop_fpu_stack)     __ fdivrp(non_tos_index);\n-        else if (dest_is_tos)  __ fdiv  (non_tos_index);\n-        else                   __ fdivra(non_tos_index);\n-      } else {\n-        if (pop_fpu_stack)     __ fdivp (non_tos_index);\n-        else if (dest_is_tos)  __ fdivr (non_tos_index);\n-        else                   __ fdiva (non_tos_index);\n-      }\n-      break;\n-\n-    case lir_rem:\n-      assert(left_is_tos && dest_is_tos && right_index == 1, \"must be guaranteed by FPU stack allocation\");\n-      __ fremr(noreg);\n-      break;\n-\n-    default:\n-      ShouldNotReachHere();\n-  }\n-}\n-#endif \/\/ _LP64\n-\n@@ -2410,9 +2082,0 @@\n-#ifndef _LP64\n-  } else if (value->is_double_fpu()) {\n-    assert(value->fpu_regnrLo() == 0 && dest->fpu_regnrLo() == 0, \"both must be on TOS\");\n-    switch(code) {\n-      case lir_abs   : __ fabs() ; break;\n-      case lir_sqrt  : __ fsqrt(); break;\n-      default      : ShouldNotReachHere();\n-    }\n-#endif \/\/ !_LP64\n@@ -2736,7 +2399,0 @@\n-#ifndef _LP64\n-  } else if(opr1->is_single_fpu() || opr1->is_double_fpu()) {\n-    assert(opr1->is_fpu_register() && opr1->fpu() == 0, \"currently left-hand side must be on TOS (relax this restriction)\");\n-    assert(opr2->is_fpu_register(), \"both must be registers\");\n-    __ fcmp(noreg, opr2->fpu(), op->fpu_pop_count() > 0, op->fpu_pop_count() > 1);\n-#endif \/\/ LP64\n-\n@@ -2785,1 +2441,0 @@\n-#ifdef _LP64\n@@ -2787,8 +2442,0 @@\n-#else\n-      assert(left->is_single_fpu() || left->is_double_fpu(), \"must be\");\n-      assert(right->is_single_fpu() || right->is_double_fpu(), \"must match\");\n-\n-      assert(left->fpu() == 0, \"left must be on TOS\");\n-      __ fcmp2int(dst->as_register(), code == lir_ucmp_fd2i, right->fpu(),\n-                  op->fpu_pop_count() > 0, op->fpu_pop_count() > 1);\n-#endif \/\/ LP64\n@@ -3807,7 +3454,0 @@\n-#ifndef _LP64\n-  } else if (left->is_single_fpu() || left->is_double_fpu()) {\n-    assert(left->fpu() == 0, \"arg must be on TOS\");\n-    assert(dest->fpu() == 0, \"dest must be TOS\");\n-    __ fchs();\n-#endif \/\/ !_LP64\n-\n@@ -3882,23 +3522,0 @@\n-\n-#ifndef _LP64\n-  } else if (src->is_double_fpu()) {\n-    assert(src->fpu_regnrLo() == 0, \"must be TOS\");\n-    if (dest->is_double_stack()) {\n-      __ fistp_d(frame_map()->address_for_slot(dest->double_stack_ix()));\n-    } else if (dest->is_address()) {\n-      __ fistp_d(as_Address(dest->as_address_ptr()));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-\n-  } else if (dest->is_double_fpu()) {\n-    assert(dest->fpu_regnrLo() == 0, \"must be TOS\");\n-    if (src->is_double_stack()) {\n-      __ fild_d(frame_map()->address_for_slot(src->double_stack_ix()));\n-    } else if (src->is_address()) {\n-      __ fild_d(as_Address(src->as_address_ptr()));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":388,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -61,9 +61,0 @@\n-#ifndef _LP64\n-  void arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack);\n-\n-  void fpop();\n-  void fxch(int i);\n-  void fld(int i);\n-  void ffree(int i);\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-#ifdef _LP64\n@@ -98,4 +97,0 @@\n-#else\n-    case floatTag:   opr = UseSSE >= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;\n-    case doubleTag:  opr = UseSSE >= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;\n-#endif \/\/ _LP64\n@@ -873,56 +868,0 @@\n-#ifndef _LP64\n-  LIR_Opr tmp = FrameMap::fpu0_double_opr;\n-  result_reg = tmp;\n-  switch(x->id()) {\n-    case vmIntrinsics::_dexp:\n-      if (StubRoutines::dexp() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dlog:\n-      if (StubRoutines::dlog() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dlog10:\n-      if (StubRoutines::dlog10() != nullptr) {\n-       __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dpow:\n-      if (StubRoutines::dpow() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dsin:\n-      if (VM_Version::supports_sse2() && StubRoutines::dsin() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dcos:\n-      if (VM_Version::supports_sse2() && StubRoutines::dcos() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    case vmIntrinsics::_dtan:\n-      if (StubRoutines::dtan() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc->args());\n-      }\n-      break;\n-    default:  ShouldNotReachHere();\n-  }\n-#else\n@@ -987,1 +926,1 @@\n-#endif \/\/ _LP64\n+\n@@ -1277,14 +1216,0 @@\n-#ifndef _LP64\n-\/\/ _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f\n-\/\/ _i2b, _i2c, _i2s\n-static LIR_Opr fixed_register_for(BasicType type) {\n-  switch (type) {\n-    case T_FLOAT:  return FrameMap::fpu0_float_opr;\n-    case T_DOUBLE: return FrameMap::fpu0_double_opr;\n-    case T_INT:    return FrameMap::rax_opr;\n-    case T_LONG:   return FrameMap::long0_opr;\n-    default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":76,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,1123 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"c1\/c1_LinearScan.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-\n-#ifdef _LP64\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ No FPU stack used on x86-64\n-}\n-#else\n-\/\/----------------------------------------------------------------------\n-\/\/ Allocation of FPU stack slots (Intel x86 only)\n-\/\/----------------------------------------------------------------------\n-\n-void LinearScan::allocate_fpu_stack() {\n-  \/\/ First compute which FPU registers are live at the start of each basic block\n-  \/\/ (To minimize the amount of work we have to do if we have to merge FPU stacks)\n-  if (ComputeExactFPURegisterUsage) {\n-    Interval* intervals_in_register, *intervals_in_memory;\n-    create_unhandled_lists(&intervals_in_register, &intervals_in_memory, is_in_fpu_register, nullptr);\n-\n-    \/\/ ignore memory intervals by overwriting intervals_in_memory\n-    \/\/ the dummy interval is needed to enforce the walker to walk until the given id:\n-    \/\/ without it, the walker stops when the unhandled-list is empty -> live information\n-    \/\/ beyond this point would be incorrect.\n-    Interval* dummy_interval = new Interval(any_reg);\n-    dummy_interval->add_range(max_jint - 2, max_jint - 1);\n-    dummy_interval->set_next(Interval::end());\n-    intervals_in_memory = dummy_interval;\n-\n-    IntervalWalker iw(this, intervals_in_register, intervals_in_memory);\n-\n-    const int num_blocks = block_count();\n-    for (int i = 0; i < num_blocks; i++) {\n-      BlockBegin* b = block_at(i);\n-\n-      \/\/ register usage is only needed for merging stacks -> compute only\n-      \/\/ when more than one predecessor.\n-      \/\/ the block must not have any spill moves at the beginning (checked by assertions)\n-      \/\/ spill moves would use intervals that are marked as handled and so the usage bit\n-      \/\/ would been set incorrectly\n-\n-      \/\/ NOTE: the check for number_of_preds > 1 is necessary. A block with only one\n-      \/\/       predecessor may have spill moves at the begin of the block.\n-      \/\/       If an interval ends at the current instruction id, it is not possible\n-      \/\/       to decide if the register is live or not at the block begin -> the\n-      \/\/       register information would be incorrect.\n-      if (b->number_of_preds() > 1) {\n-        int id = b->first_lir_instruction_id();\n-        ResourceBitMap regs(FrameMap::nof_fpu_regs);\n-\n-        iw.walk_to(id);   \/\/ walk after the first instruction (always a label) of the block\n-        assert(iw.current_position() == id, \"did not walk completely to id\");\n-\n-        \/\/ Only consider FPU values in registers\n-        Interval* interval = iw.active_first(fixedKind);\n-        while (interval != Interval::end()) {\n-          int reg = interval->assigned_reg();\n-          assert(reg >= pd_first_fpu_reg && reg <= pd_last_fpu_reg, \"no fpu register\");\n-          assert(interval->assigned_regHi() == -1, \"must not have hi register (doubles stored in one register)\");\n-          assert(interval->from() <= id && id < interval->to(), \"interval out of range\");\n-\n-#ifndef PRODUCT\n-          if (TraceFPURegisterUsage) {\n-            tty->print(\"fpu reg %d is live because of \", reg - pd_first_fpu_reg); interval->print();\n-          }\n-#endif\n-\n-          regs.set_bit(reg - pd_first_fpu_reg);\n-          interval = interval->next();\n-        }\n-\n-        b->set_fpu_register_usage(regs);\n-\n-#ifndef PRODUCT\n-        if (TraceFPURegisterUsage) {\n-          tty->print(\"FPU regs for block %d, LIR instr %d): \", b->block_id(), id); regs.print_on(tty); tty->cr();\n-        }\n-#endif\n-      }\n-    }\n-  }\n-\n-  FpuStackAllocator alloc(ir()->compilation(), this);\n-  _fpu_stack_allocator = &alloc;\n-  alloc.allocate();\n-  _fpu_stack_allocator = nullptr;\n-}\n-\n-\n-FpuStackAllocator::FpuStackAllocator(Compilation* compilation, LinearScan* allocator)\n-  : _compilation(compilation)\n-  , _allocator(allocator)\n-  , _lir(nullptr)\n-  , _pos(-1)\n-  , _sim(compilation)\n-  , _temp_sim(compilation)\n-{}\n-\n-void FpuStackAllocator::allocate() {\n-  int num_blocks = allocator()->block_count();\n-  for (int i = 0; i < num_blocks; i++) {\n-    \/\/ Set up to process block\n-    BlockBegin* block = allocator()->block_at(i);\n-    intArray* fpu_stack_state = block->fpu_stack_state();\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->cr();\n-      tty->print_cr(\"------- Begin of new Block %d -------\", block->block_id());\n-    }\n-#endif\n-\n-    assert(fpu_stack_state != nullptr ||\n-           block->end()->as_Base() != nullptr ||\n-           block->is_set(BlockBegin::exception_entry_flag),\n-           \"FPU stack state must be present due to linear-scan order for FPU stack allocation\");\n-    \/\/ note: exception handler entries always start with an empty fpu stack\n-    \/\/       because stack merging would be too complicated\n-\n-    if (fpu_stack_state != nullptr) {\n-      sim()->read_state(fpu_stack_state);\n-    } else {\n-      sim()->clear();\n-    }\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Reading FPU state for block %d:\", block->block_id());\n-      sim()->print();\n-      tty->cr();\n-    }\n-#endif\n-\n-    allocate_block(block);\n-    CHECK_BAILOUT();\n-  }\n-}\n-\n-void FpuStackAllocator::allocate_block(BlockBegin* block) {\n-  bool processed_merge = false;\n-  LIR_OpList* insts = block->lir()->instructions_list();\n-  set_lir(block->lir());\n-  set_pos(0);\n-\n-\n-  \/\/ Note: insts->length() may change during loop\n-  while (pos() < insts->length()) {\n-    LIR_Op* op = insts->at(pos());\n-    _debug_information_computed = false;\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      op->print();\n-    }\n-    check_invalid_lir_op(op);\n-#endif\n-\n-    LIR_OpBranch* branch = op->as_OpBranch();\n-    LIR_Op1* op1 = op->as_Op1();\n-    LIR_Op2* op2 = op->as_Op2();\n-    LIR_OpCall* opCall = op->as_OpCall();\n-\n-    if (branch != nullptr && branch->block() != nullptr) {\n-      if (!processed_merge) {\n-        \/\/ propagate stack at first branch to a successor\n-        processed_merge = true;\n-        bool required_merge = merge_fpu_stack_with_successors(block);\n-\n-        assert(!required_merge || branch->cond() == lir_cond_always, \"splitting of critical edges should prevent FPU stack mismatches at cond branches\");\n-      }\n-\n-    } else if (op1 != nullptr) {\n-      handle_op1(op1);\n-    } else if (op2 != nullptr) {\n-      handle_op2(op2);\n-    } else if (opCall != nullptr) {\n-      handle_opCall(opCall);\n-    }\n-\n-    compute_debug_information(op);\n-\n-    set_pos(1 + pos());\n-  }\n-\n-  \/\/ Propagate stack when block does not end with branch\n-  if (!processed_merge) {\n-    merge_fpu_stack_with_successors(block);\n-  }\n-}\n-\n-\n-void FpuStackAllocator::compute_debug_information(LIR_Op* op) {\n-  if (!_debug_information_computed && op->id() != -1 && allocator()->has_info(op->id())) {\n-    visitor.visit(op);\n-\n-    \/\/ exception handling\n-    if (allocator()->compilation()->has_exception_handlers()) {\n-      XHandlers* xhandlers = visitor.all_xhandler();\n-      int n = xhandlers->length();\n-      for (int k = 0; k < n; k++) {\n-        allocate_exception_handler(xhandlers->handler_at(k));\n-      }\n-    } else {\n-      assert(visitor.all_xhandler()->length() == 0, \"missed exception handler\");\n-    }\n-\n-    \/\/ compute debug information\n-    int n = visitor.info_count();\n-    assert(n > 0, \"should not visit operation otherwise\");\n-\n-    for (int j = 0; j < n; j++) {\n-      CodeEmitInfo* info = visitor.info_at(j);\n-      \/\/ Compute debug information\n-      allocator()->compute_debug_info(info, op->id());\n-    }\n-  }\n-  _debug_information_computed = true;\n-}\n-\n-void FpuStackAllocator::allocate_exception_handler(XHandler* xhandler) {\n-  if (!sim()->is_empty()) {\n-    LIR_List* old_lir = lir();\n-    int old_pos = pos();\n-    intArray* old_state = sim()->write_state();\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->cr();\n-      tty->print_cr(\"------- begin of exception handler -------\");\n-    }\n-#endif\n-\n-    if (xhandler->entry_code() == nullptr) {\n-      \/\/ need entry code to clear FPU stack\n-      LIR_List* entry_code = new LIR_List(_compilation);\n-      entry_code->jump(xhandler->entry_block());\n-      xhandler->set_entry_code(entry_code);\n-    }\n-\n-    LIR_OpList* insts = xhandler->entry_code()->instructions_list();\n-    set_lir(xhandler->entry_code());\n-    set_pos(0);\n-\n-    \/\/ Note: insts->length() may change during loop\n-    while (pos() < insts->length()) {\n-      LIR_Op* op = insts->at(pos());\n-\n-#ifndef PRODUCT\n-      if (TraceFPUStack) {\n-        op->print();\n-      }\n-      check_invalid_lir_op(op);\n-#endif\n-\n-      switch (op->code()) {\n-        case lir_move:\n-          assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n-          assert(pos() != insts->length() - 1, \"must not be last operation\");\n-\n-          handle_op1((LIR_Op1*)op);\n-          break;\n-\n-        case lir_branch:\n-          assert(op->as_OpBranch()->cond() == lir_cond_always, \"must be unconditional branch\");\n-          assert(pos() == insts->length() - 1, \"must be last operation\");\n-\n-          \/\/ remove all remaining dead registers from FPU stack\n-          clear_fpu_stack(LIR_OprFact::illegalOpr);\n-          break;\n-\n-        default:\n-          \/\/ other operations not allowed in exception entry code\n-          ShouldNotReachHere();\n-      }\n-\n-      set_pos(pos() + 1);\n-    }\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->cr();\n-      tty->print_cr(\"------- end of exception handler -------\");\n-    }\n-#endif\n-\n-    set_lir(old_lir);\n-    set_pos(old_pos);\n-    sim()->read_state(old_state);\n-  }\n-}\n-\n-\n-int FpuStackAllocator::fpu_num(LIR_Opr opr) {\n-  assert(opr->is_fpu_register() && !opr->is_xmm_register(), \"shouldn't call this otherwise\");\n-  return opr->is_single_fpu() ? opr->fpu_regnr() : opr->fpu_regnrLo();\n-}\n-\n-int FpuStackAllocator::tos_offset(LIR_Opr opr) {\n-  return sim()->offset_from_tos(fpu_num(opr));\n-}\n-\n-\n-LIR_Opr FpuStackAllocator::to_fpu_stack(LIR_Opr opr) {\n-  assert(opr->is_fpu_register() && !opr->is_xmm_register(), \"shouldn't call this otherwise\");\n-\n-  int stack_offset = tos_offset(opr);\n-  if (opr->is_single_fpu()) {\n-    return LIR_OprFact::single_fpu(stack_offset)->make_fpu_stack_offset();\n-  } else {\n-    assert(opr->is_double_fpu(), \"shouldn't call this otherwise\");\n-    return LIR_OprFact::double_fpu(stack_offset)->make_fpu_stack_offset();\n-  }\n-}\n-\n-LIR_Opr FpuStackAllocator::to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset) {\n-  assert(opr->is_fpu_register() && !opr->is_xmm_register(), \"shouldn't call this otherwise\");\n-  assert(dont_check_offset || tos_offset(opr) == 0, \"operand is not on stack top\");\n-\n-  int stack_offset = 0;\n-  if (opr->is_single_fpu()) {\n-    return LIR_OprFact::single_fpu(stack_offset)->make_fpu_stack_offset();\n-  } else {\n-    assert(opr->is_double_fpu(), \"shouldn't call this otherwise\");\n-    return LIR_OprFact::double_fpu(stack_offset)->make_fpu_stack_offset();\n-  }\n-}\n-\n-\n-\n-void FpuStackAllocator::insert_op(LIR_Op* op) {\n-  lir()->insert_before(pos(), op);\n-  set_pos(1 + pos());\n-}\n-\n-\n-void FpuStackAllocator::insert_exchange(int offset) {\n-  if (offset > 0) {\n-    LIR_Op1* fxch_op = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);\n-    insert_op(fxch_op);\n-    sim()->swap(offset);\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Exchanged register: %d         New state: \", sim()->get_slot(0)); sim()->print(); tty->cr();\n-    }\n-#endif\n-\n-  }\n-}\n-\n-void FpuStackAllocator::insert_exchange(LIR_Opr opr) {\n-  insert_exchange(tos_offset(opr));\n-}\n-\n-\n-void FpuStackAllocator::insert_free(int offset) {\n-  \/\/ move stack slot to the top of stack and then pop it\n-  insert_exchange(offset);\n-\n-  LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);\n-  insert_op(fpop);\n-  sim()->pop();\n-\n-#ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Inserted pop                   New state: \"); sim()->print(); tty->cr();\n-    }\n-#endif\n-}\n-\n-\n-void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr) {\n-  if (sim()->contains(fpu_num(opr))) {\n-    int res_slot = tos_offset(opr);\n-    insert_free(res_slot);\n-  }\n-}\n-\n-void FpuStackAllocator::insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore) {\n-  if (fpu_num(opr) != fpu_num(ignore) && sim()->contains(fpu_num(opr))) {\n-    int res_slot = tos_offset(opr);\n-    insert_free(res_slot);\n-  }\n-}\n-\n-void FpuStackAllocator::insert_copy(LIR_Opr from, LIR_Opr to) {\n-  int offset = tos_offset(from);\n-  LIR_Op1* fld = new LIR_Op1(lir_fld, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);\n-  insert_op(fld);\n-\n-  sim()->push(fpu_num(to));\n-\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->print(\"Inserted copy (%d -> %d)         New state: \", fpu_num(from), fpu_num(to)); sim()->print(); tty->cr();\n-  }\n-#endif\n-}\n-\n-void FpuStackAllocator::do_rename(LIR_Opr from, LIR_Opr to) {\n-  sim()->rename(fpu_num(from), fpu_num(to));\n-}\n-\n-void FpuStackAllocator::do_push(LIR_Opr opr) {\n-  sim()->push(fpu_num(opr));\n-}\n-\n-void FpuStackAllocator::pop_if_last_use(LIR_Op* op, LIR_Opr opr) {\n-  assert(op->fpu_pop_count() == 0, \"fpu_pop_count already set\");\n-  assert(tos_offset(opr) == 0, \"can only pop stack top\");\n-\n-  if (opr->is_last_use()) {\n-    op->set_fpu_pop_count(1);\n-    sim()->pop();\n-  }\n-}\n-\n-void FpuStackAllocator::pop_always(LIR_Op* op, LIR_Opr opr) {\n-  assert(op->fpu_pop_count() == 0, \"fpu_pop_count already set\");\n-  assert(tos_offset(opr) == 0, \"can only pop stack top\");\n-\n-  op->set_fpu_pop_count(1);\n-  sim()->pop();\n-}\n-\n-void FpuStackAllocator::clear_fpu_stack(LIR_Opr preserve) {\n-  int result_stack_size = (preserve->is_fpu_register() && !preserve->is_xmm_register() ? 1 : 0);\n-  while (sim()->stack_size() > result_stack_size) {\n-    assert(!sim()->slot_is_empty(0), \"not allowed\");\n-\n-    if (result_stack_size == 0 || sim()->get_slot(0) != fpu_num(preserve)) {\n-      insert_free(0);\n-    } else {\n-      \/\/ move \"preserve\" to bottom of stack so that all other stack slots can be popped\n-      insert_exchange(sim()->stack_size() - 1);\n-    }\n-  }\n-}\n-\n-\n-void FpuStackAllocator::handle_op1(LIR_Op1* op1) {\n-  LIR_Opr in  = op1->in_opr();\n-  LIR_Opr res = op1->result_opr();\n-\n-  LIR_Opr new_in  = in;  \/\/ new operands relative to the actual fpu stack top\n-  LIR_Opr new_res = res;\n-\n-  \/\/ Note: this switch is processed for all LIR_Op1, regardless if they have FPU-arguments,\n-  \/\/       so checks for is_float_kind() are necessary inside the cases\n-  switch (op1->code()) {\n-\n-    case lir_return: {\n-      \/\/ FPU-Stack must only contain the (optional) fpu return value.\n-      \/\/ All remaining dead values are popped from the stack\n-      \/\/ If the input operand is a fpu-register, it is exchanged to the bottom of the stack\n-\n-      clear_fpu_stack(in);\n-      if (in->is_fpu_register() && !in->is_xmm_register()) {\n-        new_in = to_fpu_stack_top(in);\n-      }\n-\n-      break;\n-    }\n-\n-    case lir_move: {\n-      if (in->is_fpu_register() && !in->is_xmm_register()) {\n-        if (res->is_xmm_register()) {\n-          \/\/ move from fpu register to xmm register (necessary for operations that\n-          \/\/ are not available in the SSE instruction set)\n-          insert_exchange(in);\n-          new_in = to_fpu_stack_top(in);\n-          pop_always(op1, in);\n-\n-        } else if (res->is_fpu_register() && !res->is_xmm_register()) {\n-          \/\/ move from fpu-register to fpu-register:\n-          \/\/ * input and result register equal:\n-          \/\/   nothing to do\n-          \/\/ * input register is last use:\n-          \/\/   rename the input register to result register -> input register\n-          \/\/   not present on fpu-stack afterwards\n-          \/\/ * input register not last use:\n-          \/\/   duplicate input register to result register to preserve input\n-          \/\/\n-          \/\/ Note: The LIR-Assembler does not produce any code for fpu register moves,\n-          \/\/       so input and result stack index must be equal\n-\n-          if (fpu_num(in) == fpu_num(res)) {\n-            \/\/ nothing to do\n-          } else if (in->is_last_use()) {\n-            insert_free_if_dead(res);\/\/, in);\n-            do_rename(in, res);\n-          } else {\n-            insert_free_if_dead(res);\n-            insert_copy(in, res);\n-          }\n-          new_in = to_fpu_stack(res);\n-          new_res = new_in;\n-\n-        } else {\n-          \/\/ move from fpu-register to memory\n-          \/\/ input operand must be on top of stack\n-\n-          insert_exchange(in);\n-\n-          \/\/ create debug information here because afterwards the register may have been popped\n-          compute_debug_information(op1);\n-\n-          new_in = to_fpu_stack_top(in);\n-          pop_if_last_use(op1, in);\n-        }\n-\n-      } else if (res->is_fpu_register() && !res->is_xmm_register()) {\n-        \/\/ move from memory\/constant to fpu register\n-        \/\/ result is pushed on the stack\n-\n-        insert_free_if_dead(res);\n-\n-        \/\/ create debug information before register is pushed\n-        compute_debug_information(op1);\n-\n-        do_push(res);\n-        new_res = to_fpu_stack_top(res);\n-      }\n-      break;\n-    }\n-\n-    case lir_convert: {\n-      Bytecodes::Code bc = op1->as_OpConvert()->bytecode();\n-      switch (bc) {\n-        case Bytecodes::_d2f:\n-        case Bytecodes::_f2d:\n-          assert(res->is_fpu_register(), \"must be\");\n-          assert(in->is_fpu_register(), \"must be\");\n-\n-          if (!in->is_xmm_register() && !res->is_xmm_register()) {\n-            \/\/ this is quite the same as a move from fpu-register to fpu-register\n-            \/\/ Note: input and result operands must have different types\n-            if (fpu_num(in) == fpu_num(res)) {\n-              \/\/ nothing to do\n-              new_in = to_fpu_stack(in);\n-            } else if (in->is_last_use()) {\n-              insert_free_if_dead(res);\/\/, in);\n-              new_in = to_fpu_stack(in);\n-              do_rename(in, res);\n-            } else {\n-              insert_free_if_dead(res);\n-              insert_copy(in, res);\n-              new_in = to_fpu_stack_top(in, true);\n-            }\n-            new_res = to_fpu_stack(res);\n-          }\n-\n-          break;\n-\n-        case Bytecodes::_i2f:\n-        case Bytecodes::_l2f:\n-        case Bytecodes::_i2d:\n-        case Bytecodes::_l2d:\n-          assert(res->is_fpu_register(), \"must be\");\n-          if (!res->is_xmm_register()) {\n-            insert_free_if_dead(res);\n-            do_push(res);\n-            new_res = to_fpu_stack_top(res);\n-          }\n-          break;\n-\n-        case Bytecodes::_f2i:\n-        case Bytecodes::_d2i:\n-          assert(in->is_fpu_register(), \"must be\");\n-          if (!in->is_xmm_register()) {\n-            insert_exchange(in);\n-            new_in = to_fpu_stack_top(in);\n-\n-            \/\/ TODO: update registers of stub\n-          }\n-          break;\n-\n-        case Bytecodes::_f2l:\n-        case Bytecodes::_d2l:\n-          assert(in->is_fpu_register(), \"must be\");\n-          if (!in->is_xmm_register()) {\n-            insert_exchange(in);\n-            new_in = to_fpu_stack_top(in);\n-            pop_always(op1, in);\n-          }\n-          break;\n-\n-        case Bytecodes::_i2l:\n-        case Bytecodes::_l2i:\n-        case Bytecodes::_i2b:\n-        case Bytecodes::_i2c:\n-        case Bytecodes::_i2s:\n-          \/\/ no fpu operands\n-          break;\n-\n-        default:\n-          ShouldNotReachHere();\n-      }\n-      break;\n-    }\n-\n-    case lir_roundfp: {\n-      assert(in->is_fpu_register() && !in->is_xmm_register(), \"input must be in register\");\n-      assert(res->is_stack(), \"result must be on stack\");\n-\n-      insert_exchange(in);\n-      new_in = to_fpu_stack_top(in);\n-      pop_if_last_use(op1, in);\n-      break;\n-    }\n-\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_neg: {\n-      assert(in->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(in->is_last_use(), \"old value gets destroyed\");\n-\n-      insert_free_if_dead(res, in);\n-      insert_exchange(in);\n-      do_rename(in, res);\n-\n-      new_in = to_fpu_stack_top(res);\n-      new_res = new_in;\n-\n-      break;\n-    }\n-\n-    default: {\n-      assert(!in->is_float_kind() && !res->is_float_kind(), \"missed a fpu-operation\");\n-    }\n-  }\n-\n-  op1->set_in_opr(new_in);\n-  op1->set_result_opr(new_res);\n-}\n-\n-void FpuStackAllocator::handle_op2(LIR_Op2* op2) {\n-  LIR_Opr left  = op2->in_opr1();\n-  if (!left->is_float_kind()) {\n-    return;\n-  }\n-  if (left->is_xmm_register()) {\n-    return;\n-  }\n-\n-  LIR_Opr right = op2->in_opr2();\n-  LIR_Opr res   = op2->result_opr();\n-  LIR_Opr new_left  = left;  \/\/ new operands relative to the actual fpu stack top\n-  LIR_Opr new_right = right;\n-  LIR_Opr new_res   = res;\n-\n-  assert(!left->is_xmm_register() && !right->is_xmm_register() && !res->is_xmm_register(), \"not for xmm registers\");\n-\n-  switch (op2->code()) {\n-    case lir_cmp:\n-    case lir_cmp_fd2i:\n-    case lir_ucmp_fd2i:\n-    case lir_assert: {\n-      assert(left->is_fpu_register(), \"invalid LIR\");\n-      assert(right->is_fpu_register(), \"invalid LIR\");\n-\n-      \/\/ the left-hand side must be on top of stack.\n-      \/\/ the right-hand side is never popped, even if is_last_use is set\n-      insert_exchange(left);\n-      new_left = to_fpu_stack_top(left);\n-      new_right = to_fpu_stack(right);\n-      pop_if_last_use(op2, left);\n-      break;\n-    }\n-\n-    case lir_mul:\n-    case lir_div: {\n-      if (res->is_double_fpu()) {\n-        assert(op2->tmp1_opr()->is_fpu_register(), \"strict operations need temporary fpu stack slot\");\n-        insert_free_if_dead(op2->tmp1_opr());\n-        assert(sim()->stack_size() <= 7, \"at least one stack slot must be free\");\n-      }\n-      \/\/ fall-through: continue with the normal handling of lir_mul and lir_div\n-    }\n-    case lir_add:\n-    case lir_sub: {\n-      assert(left->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(left->is_equal(res), \"must be\");\n-\n-      \/\/ either the left-hand or the right-hand side must be on top of stack\n-      \/\/ (if right is not a register, left must be on top)\n-      if (!right->is_fpu_register()) {\n-        insert_exchange(left);\n-        new_left = to_fpu_stack_top(left);\n-      } else {\n-        \/\/ no exchange necessary if right is already on top of stack\n-        if (tos_offset(right) == 0) {\n-          new_left = to_fpu_stack(left);\n-          new_right = to_fpu_stack_top(right);\n-        } else {\n-          insert_exchange(left);\n-          new_left = to_fpu_stack_top(left);\n-          new_right = to_fpu_stack(right);\n-        }\n-\n-        if (right->is_last_use()) {\n-          op2->set_fpu_pop_count(1);\n-\n-          if (tos_offset(right) == 0) {\n-            sim()->pop();\n-          } else {\n-            \/\/ if left is on top of stack, the result is placed in the stack\n-            \/\/ slot of right, so a renaming from right to res is necessary\n-            assert(tos_offset(left) == 0, \"must be\");\n-            sim()->pop();\n-            do_rename(right, res);\n-          }\n-        }\n-      }\n-      new_res = to_fpu_stack(res);\n-\n-      break;\n-    }\n-\n-    case lir_rem: {\n-      assert(left->is_fpu_register(), \"must be\");\n-      assert(right->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(left->is_equal(res), \"must be\");\n-\n-      \/\/ Must bring both operands to top of stack with following operand ordering:\n-      \/\/ * fpu stack before rem: ... right left\n-      \/\/ * fpu stack after rem:  ... left\n-      if (tos_offset(right) != 1) {\n-        insert_exchange(right);\n-        insert_exchange(1);\n-      }\n-      insert_exchange(left);\n-      assert(tos_offset(right) == 1, \"check\");\n-      assert(tos_offset(left) == 0, \"check\");\n-\n-      new_left = to_fpu_stack_top(left);\n-      new_right = to_fpu_stack(right);\n-\n-      op2->set_fpu_pop_count(1);\n-      sim()->pop();\n-      do_rename(right, res);\n-\n-      new_res = to_fpu_stack_top(res);\n-      break;\n-    }\n-\n-    default: {\n-      assert(false, \"missed a fpu-operation\");\n-    }\n-  }\n-\n-  op2->set_in_opr1(new_left);\n-  op2->set_in_opr2(new_right);\n-  op2->set_result_opr(new_res);\n-}\n-\n-void FpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {\n-  LIR_Opr res = opCall->result_opr();\n-\n-  \/\/ clear fpu-stack before call\n-  \/\/ it may contain dead values that could not have been removed by previous operations\n-  clear_fpu_stack(LIR_OprFact::illegalOpr);\n-  assert(sim()->is_empty(), \"fpu stack must be empty now\");\n-\n-  \/\/ compute debug information before (possible) fpu result is pushed\n-  compute_debug_information(opCall);\n-\n-  if (res->is_fpu_register() && !res->is_xmm_register()) {\n-    do_push(res);\n-    opCall->set_result_opr(to_fpu_stack_top(res));\n-  }\n-}\n-\n-#ifndef PRODUCT\n-void FpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {\n-  switch (op->code()) {\n-    case lir_fpop_raw:\n-    case lir_fxch:\n-    case lir_fld:\n-      assert(false, \"operations only inserted by FpuStackAllocator\");\n-      break;\n-\n-    default:\n-      break;\n-  }\n-}\n-#endif\n-\n-\n-void FpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {\n-  LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)->make_fpu_stack_offset());\n-\n-  instrs->instructions_list()->push(move);\n-\n-  cur_sim->push(reg);\n-  move->set_result_opr(to_fpu_stack(move->result_opr()));\n-\n-  #ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Added new register: %d         New state: \", reg); cur_sim->print(); tty->cr();\n-    }\n-  #endif\n-}\n-\n-void FpuStackAllocator::merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot) {\n-  assert(slot > 0, \"no exchange necessary\");\n-\n-  LIR_Op1* fxch = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(slot));\n-  instrs->instructions_list()->push(fxch);\n-  cur_sim->swap(slot);\n-\n-  #ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Exchanged register: %d         New state: \", cur_sim->get_slot(slot)); cur_sim->print(); tty->cr();\n-    }\n-  #endif\n-}\n-\n-void FpuStackAllocator::merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim) {\n-  int reg = cur_sim->get_slot(0);\n-\n-  LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);\n-  instrs->instructions_list()->push(fpop);\n-  cur_sim->pop(reg);\n-\n-  #ifndef PRODUCT\n-    if (TraceFPUStack) {\n-      tty->print(\"Removed register: %d           New state: \", reg); cur_sim->print(); tty->cr();\n-    }\n-  #endif\n-}\n-\n-bool FpuStackAllocator::merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot) {\n-  int reg = cur_sim->get_slot(change_slot);\n-\n-  for (int slot = start_slot; slot >= 0; slot--) {\n-    int new_reg = sux_sim->get_slot(slot);\n-\n-    if (!cur_sim->contains(new_reg)) {\n-      cur_sim->set_slot(change_slot, new_reg);\n-\n-      #ifndef PRODUCT\n-        if (TraceFPUStack) {\n-          tty->print(\"Renamed register %d to %d       New state: \", reg, new_reg); cur_sim->print(); tty->cr();\n-        }\n-      #endif\n-\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\n-void FpuStackAllocator::merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim) {\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->cr();\n-    tty->print(\"before merging: pred: \"); cur_sim->print(); tty->cr();\n-    tty->print(\"                 sux: \"); sux_sim->print(); tty->cr();\n-  }\n-\n-  int slot;\n-  for (slot = 0; slot < cur_sim->stack_size(); slot++) {\n-    assert(!cur_sim->slot_is_empty(slot), \"not handled by algorithm\");\n-  }\n-  for (slot = 0; slot < sux_sim->stack_size(); slot++) {\n-    assert(!sux_sim->slot_is_empty(slot), \"not handled by algorithm\");\n-  }\n-#endif\n-\n-  \/\/ size difference between cur and sux that must be resolved by adding or removing values form the stack\n-  int size_diff = cur_sim->stack_size() - sux_sim->stack_size();\n-\n-  if (!ComputeExactFPURegisterUsage) {\n-    \/\/ add slots that are currently free, but used in successor\n-    \/\/ When the exact FPU register usage is computed, the stack does\n-    \/\/ not contain dead values at merging -> no values must be added\n-\n-    int sux_slot = sux_sim->stack_size() - 1;\n-    while (size_diff < 0) {\n-      assert(sux_slot >= 0, \"slot out of bounds -> error in algorithm\");\n-\n-      int reg = sux_sim->get_slot(sux_slot);\n-      if (!cur_sim->contains(reg)) {\n-        merge_insert_add(instrs, cur_sim, reg);\n-        size_diff++;\n-\n-        if (sux_slot + size_diff != 0) {\n-          merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);\n-        }\n-      }\n-     sux_slot--;\n-    }\n-  }\n-\n-  assert(cur_sim->stack_size() >= sux_sim->stack_size(), \"stack size must be equal or greater now\");\n-  assert(size_diff == cur_sim->stack_size() - sux_sim->stack_size(), \"must be\");\n-\n-  \/\/ stack merge algorithm:\n-  \/\/ 1) as long as the current stack top is not in the right location (that means\n-  \/\/    it should not be on the stack top), exchange it into the right location\n-  \/\/ 2) if the stack top is right, but the remaining stack is not ordered correctly,\n-  \/\/    the stack top is exchanged away to get another value on top ->\n-  \/\/    now step 1) can be continued\n-  \/\/ the stack can also contain unused items -> these items are removed from stack\n-\n-  int finished_slot = sux_sim->stack_size() - 1;\n-  while (finished_slot >= 0 || size_diff > 0) {\n-    while (size_diff > 0 || (cur_sim->stack_size() > 0 && cur_sim->get_slot(0) != sux_sim->get_slot(0))) {\n-      int reg = cur_sim->get_slot(0);\n-      if (sux_sim->contains(reg)) {\n-        int sux_slot = sux_sim->offset_from_tos(reg);\n-        merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);\n-\n-      } else if (!merge_rename(cur_sim, sux_sim, finished_slot, 0)) {\n-        assert(size_diff > 0, \"must be\");\n-\n-        merge_insert_pop(instrs, cur_sim);\n-        size_diff--;\n-      }\n-      assert(cur_sim->stack_size() == 0 || cur_sim->get_slot(0) != reg, \"register must have been changed\");\n-    }\n-\n-    while (finished_slot >= 0 && cur_sim->get_slot(finished_slot) == sux_sim->get_slot(finished_slot)) {\n-      finished_slot--;\n-    }\n-\n-    if (finished_slot >= 0) {\n-      int reg = cur_sim->get_slot(finished_slot);\n-\n-      if (sux_sim->contains(reg) || !merge_rename(cur_sim, sux_sim, finished_slot, finished_slot)) {\n-        assert(sux_sim->contains(reg) || size_diff > 0, \"must be\");\n-        merge_insert_xchg(instrs, cur_sim, finished_slot);\n-      }\n-      assert(cur_sim->get_slot(finished_slot) != reg, \"register must have been changed\");\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->print(\"after merging:  pred: \"); cur_sim->print(); tty->cr();\n-    tty->print(\"                 sux: \"); sux_sim->print(); tty->cr();\n-    tty->cr();\n-  }\n-#endif\n-  assert(cur_sim->stack_size() == sux_sim->stack_size(), \"stack size must be equal now\");\n-}\n-\n-\n-void FpuStackAllocator::merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap& live_fpu_regs) {\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->cr();\n-    tty->print(\"before cleanup: state: \"); cur_sim->print(); tty->cr();\n-    tty->print(\"                live:  \"); live_fpu_regs.print_on(tty); tty->cr();\n-  }\n-#endif\n-\n-  int slot = 0;\n-  while (slot < cur_sim->stack_size()) {\n-    int reg = cur_sim->get_slot(slot);\n-    if (!live_fpu_regs.at(reg)) {\n-      if (slot != 0) {\n-        merge_insert_xchg(instrs, cur_sim, slot);\n-      }\n-      merge_insert_pop(instrs, cur_sim);\n-    } else {\n-      slot++;\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->print(\"after cleanup:  state: \"); cur_sim->print(); tty->cr();\n-    tty->print(\"                live:  \"); live_fpu_regs.print_on(tty); tty->cr();\n-    tty->cr();\n-  }\n-\n-  \/\/ check if fpu stack only contains live registers\n-  for (unsigned int i = 0; i < live_fpu_regs.size(); i++) {\n-    if (live_fpu_regs.at(i) != cur_sim->contains(i)) {\n-      tty->print_cr(\"mismatch between required and actual stack content\");\n-      break;\n-    }\n-  }\n-#endif\n-}\n-\n-\n-bool FpuStackAllocator::merge_fpu_stack_with_successors(BlockBegin* block) {\n-#ifndef PRODUCT\n-  if (TraceFPUStack) {\n-    tty->print_cr(\"Propagating FPU stack state for B%d at LIR_Op position %d to successors:\",\n-                  block->block_id(), pos());\n-    sim()->print();\n-    tty->cr();\n-  }\n-#endif\n-\n-  bool changed = false;\n-  int number_of_sux = block->number_of_sux();\n-\n-  if (number_of_sux == 1 && block->sux_at(0)->number_of_preds() > 1) {\n-    \/\/ The successor has at least two incoming edges, so a stack merge will be necessary\n-    \/\/ If this block is the first predecessor, cleanup the current stack and propagate it\n-    \/\/ If this block is not the first predecessor, a stack merge will be necessary\n-\n-    BlockBegin* sux = block->sux_at(0);\n-    intArray* state = sux->fpu_stack_state();\n-    LIR_List* instrs = new LIR_List(_compilation);\n-\n-    if (state != nullptr) {\n-      \/\/ Merge with a successors that already has a FPU stack state\n-      \/\/ the block must only have one successor because critical edges must been split\n-      FpuStackSim* cur_sim = sim();\n-      FpuStackSim* sux_sim = temp_sim();\n-      sux_sim->read_state(state);\n-\n-      merge_fpu_stack(instrs, cur_sim, sux_sim);\n-\n-    } else {\n-      \/\/ propagate current FPU stack state to successor without state\n-      \/\/ clean up stack first so that there are no dead values on the stack\n-      if (ComputeExactFPURegisterUsage) {\n-        FpuStackSim* cur_sim = sim();\n-        ResourceBitMap live_fpu_regs = block->sux_at(0)->fpu_register_usage();\n-        assert(live_fpu_regs.size() == FrameMap::nof_fpu_regs, \"missing register usage\");\n-\n-        merge_cleanup_fpu_stack(instrs, cur_sim, live_fpu_regs);\n-      }\n-\n-      intArray* state = sim()->write_state();\n-      if (TraceFPUStack) {\n-        tty->print_cr(\"Setting FPU stack state of B%d (merge path)\", sux->block_id());\n-        sim()->print(); tty->cr();\n-      }\n-      sux->set_fpu_stack_state(state);\n-    }\n-\n-    if (instrs->instructions_list()->length() > 0) {\n-      lir()->insert_before(pos(), instrs);\n-      set_pos(instrs->instructions_list()->length() + pos());\n-      changed = true;\n-    }\n-\n-  } else {\n-    \/\/ Propagate unmodified Stack to successors where a stack merge is not necessary\n-    intArray* state = sim()->write_state();\n-    for (int i = 0; i < number_of_sux; i++) {\n-      BlockBegin* sux = block->sux_at(i);\n-\n-#ifdef ASSERT\n-      for (int j = 0; j < sux->number_of_preds(); j++) {\n-        assert(block == sux->pred_at(j), \"all critical edges must be broken\");\n-      }\n-\n-      \/\/ check if new state is same\n-      if (sux->fpu_stack_state() != nullptr) {\n-        intArray* sux_state = sux->fpu_stack_state();\n-        assert(state->length() == sux_state->length(), \"overwriting existing stack state\");\n-        for (int j = 0; j < state->length(); j++) {\n-          assert(state->at(j) == sux_state->at(j), \"overwriting existing stack state\");\n-        }\n-      }\n-#endif\n-#ifndef PRODUCT\n-      if (TraceFPUStack) {\n-        tty->print_cr(\"Setting FPU stack state of B%d\", sux->block_id());\n-        sim()->print(); tty->cr();\n-      }\n-#endif\n-\n-      sux->set_fpu_stack_state(state);\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  \/\/ assertions that FPU stack state conforms to all successors' states\n-  intArray* cur_state = sim()->write_state();\n-  for (int i = 0; i < number_of_sux; i++) {\n-    BlockBegin* sux = block->sux_at(i);\n-    intArray* sux_state = sux->fpu_stack_state();\n-\n-    assert(sux_state != nullptr, \"no fpu state\");\n-    assert(cur_state->length() == sux_state->length(), \"incorrect length\");\n-    for (int i = 0; i < cur_state->length(); i++) {\n-      assert(cur_state->at(i) == sux_state->at(i), \"element not equal\");\n-    }\n-  }\n-#endif\n-\n-  return changed;\n-}\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":0,"deletions":1123,"binary":false,"changes":1123,"status":"deleted"},{"patch":"@@ -91,74 +91,0 @@\n-\n-class FpuStackAllocator {\n- private:\n-  Compilation* _compilation;\n-  LinearScan* _allocator;\n-\n-  LIR_OpVisitState visitor;\n-\n-  LIR_List* _lir;\n-  int _pos;\n-  FpuStackSim _sim;\n-  FpuStackSim _temp_sim;\n-\n-  bool _debug_information_computed;\n-\n-  LinearScan*   allocator()                      { return _allocator; }\n-  Compilation*  compilation() const              { return _compilation; }\n-\n-  \/\/ unified bailout support\n-  void          bailout(const char* msg) const   { compilation()->bailout(msg); }\n-  bool          bailed_out() const               { return compilation()->bailed_out(); }\n-\n-  int pos() { return _pos; }\n-  void set_pos(int pos) { _pos = pos; }\n-  LIR_Op* cur_op() { return lir()->instructions_list()->at(pos()); }\n-  LIR_List* lir() { return _lir; }\n-  void set_lir(LIR_List* lir) { _lir = lir; }\n-  FpuStackSim* sim() { return &_sim; }\n-  FpuStackSim* temp_sim() { return &_temp_sim; }\n-\n-  int fpu_num(LIR_Opr opr);\n-  int tos_offset(LIR_Opr opr);\n-  LIR_Opr to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset = false);\n-\n-  \/\/ Helper functions for handling operations\n-  void insert_op(LIR_Op* op);\n-  void insert_exchange(int offset);\n-  void insert_exchange(LIR_Opr opr);\n-  void insert_free(int offset);\n-  void insert_free_if_dead(LIR_Opr opr);\n-  void insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore);\n-  void insert_copy(LIR_Opr from, LIR_Opr to);\n-  void do_rename(LIR_Opr from, LIR_Opr to);\n-  void do_push(LIR_Opr opr);\n-  void pop_if_last_use(LIR_Op* op, LIR_Opr opr);\n-  void pop_always(LIR_Op* op, LIR_Opr opr);\n-  void clear_fpu_stack(LIR_Opr preserve);\n-  void handle_op1(LIR_Op1* op1);\n-  void handle_op2(LIR_Op2* op2);\n-  void handle_opCall(LIR_OpCall* opCall);\n-  void compute_debug_information(LIR_Op* op);\n-  void allocate_exception_handler(XHandler* xhandler);\n-  void allocate_block(BlockBegin* block);\n-\n-#ifndef PRODUCT\n-  void check_invalid_lir_op(LIR_Op* op);\n-#endif\n-\n-  \/\/ Helper functions for merging of fpu stacks\n-  void merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg);\n-  void merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot);\n-  void merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim);\n-  bool merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot);\n-  void merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim);\n-  void merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap& live_fpu_regs);\n-  bool merge_fpu_stack_with_successors(BlockBegin* block);\n-\n- public:\n-  LIR_Opr to_fpu_stack(LIR_Opr opr); \/\/ used by LinearScan for creation of debug information\n-\n-  FpuStackAllocator(Compilation* compilation, LinearScan* allocator);\n-  void allocate();\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -335,6 +335,0 @@\n-#if !defined(_LP64) && defined(COMPILER2)\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n-    \/\/ c2 leaves fpu stack dirty. Clean it on entry\n-    empty_FPU_stack();\n-  }\n-#endif \/\/ !_LP64 && COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_C1_C1_FPUSTACKSIM_HPP\n-#define SHARE_C1_C1_FPUSTACKSIM_HPP\n-\n-#include \"c1\/c1_FrameMap.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ Provides location for forward declaration of this class, which is\n-\/\/ only implemented on Intel\n-class FpuStackSim;\n-\n-#include CPU_HEADER(c1_FpuStackSim)\n-\n-#endif \/\/ SHARE_C1_C1_FPUSTACKSIM_HPP\n","filename":"src\/hotspot\/share\/c1\/c1_FpuStackSim.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1613,1 +1613,0 @@\n-  intArray*      _fpu_stack_state;               \/\/ For x86 FPU code generation with UseLinearScan\n@@ -1660,1 +1659,0 @@\n-  , _fpu_stack_state(nullptr)\n@@ -1688,1 +1686,0 @@\n-  intArray* fpu_stack_state() const              { return _fpu_stack_state;    }\n@@ -1711,1 +1708,0 @@\n-  void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -406,1 +406,0 @@\n-    case lir_fpop_raw:                 \/\/ result and info always invalid\n@@ -446,2 +445,0 @@\n-    case lir_fxch:           \/\/ input always valid, result and info always invalid\n-    case lir_fld:            \/\/ input always valid, result and info always invalid\n@@ -1719,1 +1716,0 @@\n-     case lir_fpop_raw:              s = \"fpop_raw\";      break;\n@@ -1723,2 +1719,0 @@\n-     case lir_fxch:                  s = \"fxch\";          break;\n-     case lir_fld:                   s = \"fld\";           break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-class FpuStackSim;\n@@ -239,1 +238,0 @@\n-    , is_fpu_stack_offset_bits = 1        \/\/ used in assertion checking on x86 for FPU stack slot allocation\n@@ -241,1 +239,1 @@\n-                       + is_xmm_bits + last_use_bits + is_fpu_stack_offset_bits\n+                       + is_xmm_bits + last_use_bits\n@@ -252,2 +250,1 @@\n-    , is_fpu_stack_offset_shift = last_use_shift + last_use_bits\n-    , virtual_shift  = is_fpu_stack_offset_shift + is_fpu_stack_offset_bits\n+    , virtual_shift = last_use_shift + last_use_bits\n@@ -271,1 +268,0 @@\n-    , is_fpu_stack_offset_mask = right_n_bits(is_fpu_stack_offset_bits) << is_fpu_stack_offset_shift\n@@ -276,1 +272,1 @@\n-    , no_type_mask   = (int)(~(type_mask | last_use_mask | is_fpu_stack_offset_mask))\n+    , no_type_mask   = (int)(~(type_mask | last_use_mask))\n@@ -429,1 +425,0 @@\n-  bool is_fpu_stack_offset() const { assert(is_register(), \"only works for registers\"); return (value() & is_fpu_stack_offset_mask) != 0; }\n@@ -431,1 +426,0 @@\n-  LIR_Opr make_fpu_stack_offset()  { assert(is_register(), \"only works for registers\"); return (LIR_Opr)(value() | is_fpu_stack_offset_mask); }\n@@ -916,1 +910,0 @@\n-      , lir_fpop_raw\n@@ -930,2 +923,0 @@\n-      , lir_fxch\n-      , lir_fld\n@@ -1075,1 +1066,0 @@\n-  int           _fpu_pop_count;\n@@ -1095,1 +1085,0 @@\n-    , _fpu_pop_count(0)\n@@ -1109,1 +1098,0 @@\n-    , _fpu_pop_count(0)\n@@ -1130,5 +1118,0 @@\n-  \/\/ FPU stack simulation helpers -- only used on Intel\n-  void set_fpu_pop_count(int count)           { assert(count >= 0 && count <= 1, \"currently only 0 and 1 are valid\"); _fpu_pop_count = count; }\n-  int  fpu_pop_count() const                  { return _fpu_pop_count; }\n-  bool pop_fpu_stack()                        { return _fpu_pop_count > 0; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -488,13 +488,0 @@\n-\n-#if defined(IA32) && defined(COMPILER2)\n-  \/\/ C2 leave fpu stack dirty clean it\n-  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_jvmci()) {\n-    int i;\n-    for ( i = 1; i <= 7 ; i++ ) {\n-      ffree(i);\n-    }\n-    if (!op->result_opr()->is_float_kind()) {\n-      ffree(0);\n-    }\n-  }\n-#endif \/\/ IA32 && COMPILER2\n@@ -517,1 +504,1 @@\n-                op->patch_code(), op->info(), op->pop_fpu_stack(),\n+                op->patch_code(), op->info(),\n@@ -524,1 +511,1 @@\n-      roundfp_op(round_op->in_opr(), round_op->tmp(), round_op->result_opr(), round_op->pop_fpu_stack());\n+      roundfp_op(round_op->in_opr(), round_op->tmp(), round_op->result_opr());\n@@ -556,10 +543,0 @@\n-#ifdef IA32\n-    case lir_fxch:\n-      fxch(op->in_opr()->as_jint());\n-      break;\n-\n-    case lir_fld:\n-      fld(op->in_opr()->as_jint());\n-      break;\n-#endif \/\/ IA32\n-\n@@ -641,6 +618,0 @@\n-#ifdef IA32\n-    case lir_fpop_raw:\n-      fpop();\n-      break;\n-#endif \/\/ IA32\n-\n@@ -726,1 +697,0 @@\n-      assert(op->fpu_pop_count() < 2, \"\");\n@@ -732,2 +702,1 @@\n-        op->info(),\n-        op->fpu_pop_count() == 1);\n+        op->info());\n@@ -778,1 +747,1 @@\n-void LIR_Assembler::roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack) {\n+void LIR_Assembler::roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest) {\n@@ -784,1 +753,1 @@\n-  reg2stack (src, dest, src->type(), pop_fpu_stack);\n+  reg2stack (src, dest, src->type());\n@@ -788,1 +757,1 @@\n-void LIR_Assembler::move_op(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n+void LIR_Assembler::move_op(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -795,1 +764,1 @@\n-      reg2stack(src, dest, type, pop_fpu_stack);\n+      reg2stack(src, dest, type);\n@@ -797,1 +766,1 @@\n-      reg2mem(src, dest, type, patch_code, info, pop_fpu_stack, wide);\n+      reg2mem(src, dest, type, patch_code, info, wide);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":8,"deletions":39,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  void reg2stack  (LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack);\n+  void reg2stack  (LIR_Opr src, LIR_Opr dest, BasicType type);\n@@ -173,1 +173,1 @@\n-                   bool pop_fpu_stack, bool wide);\n+                   bool wide);\n@@ -209,1 +209,1 @@\n-  void arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack);\n+  void arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info);\n@@ -218,1 +218,1 @@\n-  void roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack);\n+  void roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest);\n@@ -220,1 +220,1 @@\n-               LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide);\n+               LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,3 +94,0 @@\n-#ifdef IA32\n- , _fpu_stack_allocator(nullptr)\n-#endif\n@@ -1871,2 +1868,1 @@\n-  if ((reg < nof_regs && interval->always_in_memory()) ||\n-      (use_fpu_stack_allocation() && reg >= pd_first_fpu_reg && reg <= pd_last_fpu_reg)) {\n+  if ((reg < nof_regs && interval->always_in_memory())) {\n@@ -1874,1 +1870,1 @@\n-    \/\/ in the following two cases:\n+    \/\/ in the following case:\n@@ -1878,2 +1874,0 @@\n-    \/\/ * the interval would be on the fpu stack at the begin of the exception handler\n-    \/\/   this is not allowed because of the complicated fpu stack handling on Intel\n@@ -2668,8 +2662,1 @@\n-#ifdef IA32\n-    \/\/ the exact location of fpu stack values is only known\n-    \/\/ during fpu stack allocation, so the stack allocator object\n-    \/\/ must be present\n-    assert(use_fpu_stack_allocation(), \"should not have float stack values without fpu stack allocation (all floats must be SSE2)\");\n-    assert(_fpu_stack_allocator != nullptr, \"must be present\");\n-    opr = _fpu_stack_allocator->to_fpu_stack(opr);\n-#elif defined(AMD64)\n+#if defined(AMD64)\n@@ -2678,1 +2665,0 @@\n-\n@@ -2781,10 +2767,0 @@\n-#ifdef IA32\n-      \/\/ the exact location of fpu stack values is only known\n-      \/\/ during fpu stack allocation, so the stack allocator object\n-      \/\/ must be present\n-      assert(use_fpu_stack_allocation(), \"should not have float stack values without fpu stack allocation (all floats must be SSE2)\");\n-      assert(_fpu_stack_allocator != nullptr, \"must be present\");\n-      opr = _fpu_stack_allocator->to_fpu_stack(opr);\n-\n-      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), \"assumed in calculation (only fpu_regnrLo is used)\");\n-#endif\n@@ -3024,9 +3000,3 @@\n-      if (!use_fpu_stack_allocation()) {\n-        \/\/ compute debug information if fpu stack allocation is not needed.\n-        \/\/ when fpu stack allocation is needed, the debug information can not\n-        \/\/ be computed here because the exact location of fpu operands is not known\n-        \/\/ -> debug information is created inside the fpu stack allocator\n-        int n = visitor.info_count();\n-        for (int k = 0; k < n; k++) {\n-          compute_debug_info(visitor.info_at(k), op_id);\n-        }\n+      int n = visitor.info_count();\n+      for (int k = 0; k < n; k++) {\n+        compute_debug_info(visitor.info_at(k), op_id);\n@@ -3129,8 +3099,0 @@\n-  { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);\n-\n-    if (use_fpu_stack_allocation()) {\n-      allocate_fpu_stack(); \/\/ Only has effect on Intel\n-      NOT_PRODUCT(print_lir(2, \"LIR after FPU stack allocation:\"));\n-    }\n-  }\n-\n@@ -6011,14 +5973,0 @@\n-\n-  } else if (op1->code() == lir_fxch && op2->code() == lir_fxch) {\n-    assert(op1->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n-    assert(op2->as_Op1() != nullptr, \"fxch must be LIR_Op1\");\n-    LIR_Op1* fxch1 = (LIR_Op1*)op1;\n-    LIR_Op1* fxch2 = (LIR_Op1*)op2;\n-    if (fxch1->in_opr()->as_jint() == fxch2->in_opr()->as_jint()) {\n-      \/\/ equal FPU stack operations can be optimized\n-      return false;\n-    }\n-\n-  } else if (op1->code() == lir_fpop_raw && op2->code() == lir_fpop_raw) {\n-    \/\/ equal FPU stack operations can be optimized\n-    return false;\n@@ -6544,1 +6492,0 @@\n-    case counter_fpu_stack:       return \"fpu-stack\";\n@@ -6765,4 +6712,0 @@\n-        case lir_fpop_raw:\n-        case lir_fxch:\n-        case lir_fld:             inc_counter(counter_fpu_stack); break;\n-\n@@ -6822,1 +6765,0 @@\n-    case timer_allocate_fpu_stack:       return \"Allocate FPU Stack\";\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":6,"deletions":64,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"c1\/c1_FpuStackSim.hpp\"\n@@ -180,9 +179,0 @@\n-  \/\/ handling of fpu stack allocation (platform dependent, needed for debug information generation)\n-#ifdef IA32\n-  FpuStackAllocator* _fpu_stack_allocator;\n-  bool use_fpu_stack_allocation() const          { return UseSSE < 2 && has_fpu_registers(); }\n-#else\n-  bool use_fpu_stack_allocation() const          { return false; }\n-#endif\n-\n-\n@@ -360,6 +350,0 @@\n-\n-  \/\/ Phase 8: fpu stack allocation\n-  \/\/ (Used only on x86 when fpu operands are present)\n-  void allocate_fpu_stack();\n-\n-\n@@ -956,1 +940,0 @@\n-    timer_allocate_fpu_stack,\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -283,6 +283,0 @@\n-  develop(bool, TraceFPUStack, false,                                       \\\n-          \"Trace emulation of the FPU stack (intel only)\")                  \\\n-                                                                            \\\n-  develop(bool, TraceFPURegisterUsage, false,                               \\\n-          \"Trace usage of FPU registers at start of blocks (intel only)\")   \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}