{"files":[{"patch":"@@ -56,3 +56,7 @@\n-  \/\/ Remove double negation\n-  const Type *zero = add_id();\n-  if( phase->type( in(1) )->higher_equal( zero ) &&\n+  const Type* zero = add_id();\n+\n+  \/\/ Remove double negation if it is not a floating point number since negation\n+  \/\/ is not the same as subtraction for floating point numbers\n+  \/\/ (cf. JLS ยง 15.15.4). `0-(0-(-0.0))` must be equal to positive 0.0 according to\n+  \/\/ JLS ยง 15.8.2, but would result in -0.0 if this folding would be applied.\n+  if (phase->type(in(1))->higher_equal(zero) &&\n@@ -60,1 +64,2 @@\n-      phase->type( in(2)->in(1) )->higher_equal( zero ) ) {\n+      phase->type(in(2)->in(1))->higher_equal(zero) &&\n+      !phase->type(in(2)->in(2))->is_floatingpoint()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8351515\n+ * @summary The compiler must not fold `0-(0-x)` for x: float | double\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ * @run driver compiler.floatingpoint.TestSubNodeFloatDoubleNegation\n+ *\/\n+package compiler.floatingpoint;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.Asserts;\n+\n+public class TestSubNodeFloatDoubleNegation {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,jdk.incubator.vector.Float16::*\");\n+    }\n+\n+    @Run(test = { \"testHalfFloat\", \"testFloat\", \"testDouble\" })\n+    public static void assertResults() {\n+        short halfFloatRes = Float16.float16ToShortBits(testHalfFloat(Float16.valueOf(-0.0f)));\n+        int floatRes = Float.floatToIntBits(testFloat(-0.0f));\n+        long doubleRes = Double.doubleToLongBits(testDouble(-0.0));\n+\n+        Asserts.assertEQ((short) 0, halfFloatRes);\n+        Asserts.assertEQ((int) 0, floatRes);\n+        Asserts.assertEQ((long) 0, doubleRes);\n+    }\n+\n+    @Test\n+    \/\/ Match a generic SubNode, because scalar Float16 operations are often\n+    \/\/ performed as float operations.\n+    @IR(counts = { IRNode.SUB, \"2\" })\n+    \/\/ Checks that the subtractions in 0 - (0 - hf) do not get eliminiated\n+    public static Float16 testHalfFloat(Float16 hf) {\n+        return Float16.subtract(\n+                Float16.shortBitsToFloat16((short) 0),\n+                Float16.subtract(Float16.shortBitsToFloat16((short) 0), hf));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_F, \"2\" })\n+    \/\/ Checks that the subtractions in 0 - (0 - f) do not get eliminated\n+    public static float testFloat(float f) {\n+        return 0 - (0 - f);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_D, \"2\" })\n+    \/\/ Checks that the subtractions in 0 - (0 - d) do not get eliminated\n+    public static double testDouble(double d) {\n+        return 0 - (0 - d);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestSubNodeFloatDoubleNegation.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1836,1 +1836,1 @@\n-        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D)\");\n+        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D|HF)\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}