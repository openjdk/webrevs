{"files":[{"patch":"@@ -102,1 +102,1 @@\n-    @Param({\"128\", \"256\", \"512\", \"768\", \"1024\"})\n+    @Param({\"256\", \"512\", \"1024\"})\n@@ -105,1 +105,1 @@\n-    @Param({\"1\", \"32\", \"48\", \"64\", \"80\", \"96\", \"112\"})\n+    @Param({\"1\", \"32\", \"64\", \"128\"})\n@@ -298,0 +298,10 @@\n+\n+            \/\/ We have disabled code cache flushing. This should guarantee our just compiled\n+            \/\/ not yet used code will not be flushed.\n+            \/\/ Besides our test methods, we don't use a lot of Java methods in this benchmark.\n+            \/\/ This should guarantee that most of code in the code cache is our test methods.\n+            \/\/ If C2 occasionally compiles other methods, it should not affect test methods code placement much.\n+            \/\/ We don't expect a lot of deoptimizations in this benchmark. So we don't expect\n+            \/\/ CodeCache to be fragmented.\n+            \/\/ We assume addresses of our compiled methods and dummy code blobs are in increasing order.\n+            \/\/ Methods compiled during the same iteration are in the same code region.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SparseCodeCache.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}