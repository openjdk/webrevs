{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -42,0 +43,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -74,2 +76,2 @@\n-    \"-XX:ReservedCodeCacheSize=320m\",\n-    \"-XX:InitialCodeCacheSize=320m\",\n+    \"-XX:ReservedCodeCacheSize=512m\",\n+    \"-XX:InitialCodeCacheSize=512m\",\n@@ -81,0 +83,4 @@\n+    private static final int C2_LEVEL = 4;\n+    private static final int DUMMY_BLOB_SIZE = 1024 * 1024;\n+    private static final int DUMMY_BLOB_COUNT = 128;\n+\n@@ -139,1 +145,0 @@\n-        private static final int C2_LEVEL = 4;\n@@ -186,0 +191,1 @@\n+            getWhiteBox().testSetDontInlineMethod(method, true);\n@@ -221,0 +227,13 @@\n+        allocateDummyBlobs(DUMMY_BLOB_COUNT, DUMMY_BLOB_SIZE, methods[activeMethodCount - 1].getNMethod().code_blob_type.id);\n+        compileCallMethods();\n+    }\n+\n+    private void allocateDummyBlobs(int count, int size, int codeBlobType) {\n+        getWhiteBox().lockCompilation();\n+        for (int i = 0; i < count; i++) {\n+            var dummyBlob = getWhiteBox().allocateCodeBlob(size, codeBlobType);\n+            if (dummyBlob == 0) {\n+                throw new IllegalStateException(\"Failed to allocate dummy blob.\");\n+            }\n+        }\n+        getWhiteBox().unlockCompilation();\n@@ -280,2 +299,5 @@\n-                getWhiteBox().allocateCodeBlob(regionEnd - lastNmethodInPrevGroup.address - lastNmethodInPrevGroup.size,\n-                    lastNmethodInPrevGroup.code_blob_type.id);\n+                var dummyBlob = getWhiteBox().allocateCodeBlob(regionEnd - lastNmethodInPrevGroup.address - lastNmethodInPrevGroup.size,\n+                                                               lastNmethodInPrevGroup.code_blob_type.id);\n+                if (dummyBlob == 0) {\n+                    throw new IllegalStateException(\"Failed to allocate dummy blob.\");\n+                }\n@@ -297,0 +319,19 @@\n+\n+        allocateDummyBlobs(DUMMY_BLOB_COUNT, DUMMY_BLOB_SIZE, methods[j - 1].getNMethod().code_blob_type.id);\n+        compileCallMethods();\n+    }\n+\n+    private void compileCallMethods() throws Exception {\n+        var threadState = new ThreadState();\n+        threadState.setup();\n+        callMethods(threadState);\n+        Method method = SparseCodeCache.class.getDeclaredMethod(\"callMethods\", ThreadState.class);\n+        getWhiteBox().markMethodProfiled(method);\n+        getWhiteBox().enqueueMethodForCompilation(method, C2_LEVEL);\n+        while (getWhiteBox().isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        if (getWhiteBox().getMethodCompilationLevel(method) != C2_LEVEL) {\n+            throw new IllegalStateException(\"Method SparseCodeCache::callMethods is not compiled by C2.\");\n+        }\n+        getWhiteBox().testSetDontInlineMethod(method, true);\n@@ -305,2 +346,2 @@\n-    @Benchmark\n-    public void runMethods(ThreadState s) throws Exception {\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private void callMethods(ThreadState s) throws Exception {\n@@ -311,0 +352,6 @@\n+\n+    @Benchmark\n+    @Warmup(iterations = 2)\n+    public void runMethodsWithReflection(ThreadState s) throws Exception {\n+        callMethods(s);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SparseCodeCache.java","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"}]}