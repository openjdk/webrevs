{"files":[{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.lang.reflect.Method;\n+import java.util.Random;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * This benchmark is used to check performance when the code cache is sparse.\n+ *\n+ * We use C2 compiler to compile the same Java method multiple times\n+ * to produce as many code as needed.\n+ * These compiled methods represent the active methods in the code cache.\n+ * We split active methods into groups.\n+ * We put a group into a fixed size code region.\n+ * We make a code region size aligned.\n+ * CodeCache becomes sparse when code regions are not fully filled.\n+ *\n+ * The benchmark parameters are active method count, group count, and code region size.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgs = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:CompileCommand=dontinline,A::sum\",\n+    \"-XX:-UseCodeCacheFlushing\",\n+    \"-XX:-TieredCompilation\",\n+    \"-XX:+SegmentedCodeCache\",\n+    \"-XX:ReservedCodeCacheSize=512m\",\n+    \"-XX:InitialCodeCacheSize=512m\",\n+    \"-XX:+UseSerialGC\",\n+    \"-XX:+PrintCodeCache\"\n+})\n+public class SparseCodeCache {\n+\n+    private static final int C2_LEVEL = 4;\n+    private static final int DUMMY_BLOB_SIZE = 1024 * 1024;\n+    private static final int DUMMY_BLOB_COUNT = 128;\n+\n+    static byte[] num1;\n+    static byte[] num2;\n+\n+    @State(Scope.Thread)\n+    public static class ThreadState {\n+        byte[] result;\n+\n+        @Setup\n+        public void setup() {\n+            result = new byte[num1.length + 1];\n+        }\n+    }\n+\n+    private static Object WB;\n+\n+    @Param({\"128\", \"256\", \"512\", \"768\", \"1024\"})\n+    public int activeMethodCount;\n+\n+    @Param({\"1\", \"32\", \"48\", \"64\", \"80\", \"96\", \"112\"})\n+    public int groupCount;\n+\n+    @Param({\"2097152\"})\n+    public int codeRegionSize;\n+\n+    private TestMethod[] methods = {};\n+\n+    private static byte[] genNum(Random random, int digitCount) {\n+        byte[] num = new byte[digitCount];\n+        int d;\n+        do {\n+            d = random.nextInt(10);\n+        } while (d == 0);\n+\n+        num[0] = (byte)d;\n+        for (int i = 1; i < digitCount; ++i) {\n+            num[i] = (byte)random.nextInt(10);\n+        }\n+        return num;\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    private static void initNums() {\n+        final long seed = 8374592837465123L;\n+        Random random = new Random(seed);\n+\n+        final int digitCount = 40;\n+        num1 = genNum(random, digitCount);\n+        num2 = genNum(random, digitCount);\n+    }\n+\n+    private static WhiteBox getWhiteBox() {\n+        return (WhiteBox)WB;\n+    }\n+\n+    private static final class TestMethod {\n+        private static final String CLASS_NAME = \"A\";\n+        private static final String METHOD_TO_COMPILE = \"sum\";\n+        private static final String JAVA_CODE = \"\"\"\n+        public class A {\n+\n+            public static void sum(byte[] n1, byte[] n2, byte[] out) {\n+                final int digitCount = n1.length;\n+                int carry = 0;\n+                for (int i = digitCount - 1; i >= 0; --i) {\n+                    int sum = n1[i] + n2[i] + carry;\n+                    out[i] = (byte)(sum % 10);\n+                    carry = sum \/ 10;\n+                }\n+                if (carry != 0) {\n+                    for (int i = digitCount; i > 0; --i) {\n+                        out[i] = out[i - 1];\n+                    }\n+                    out[0] = (byte)carry;\n+                }\n+            }\n+        }\"\"\";\n+\n+        private static final byte[] BYTE_CODE;\n+\n+        static {\n+            BYTE_CODE = InMemoryJavaCompiler.compile(CLASS_NAME, JAVA_CODE);\n+        }\n+\n+        private final Method method;\n+\n+        private static ClassLoader createClassLoaderFor() {\n+            return new ClassLoader() {\n+                @Override\n+                public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                    if (!name.equals(CLASS_NAME)) {\n+                        return super.loadClass(name);\n+                    }\n+\n+                    return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+                }\n+            };\n+        }\n+\n+        public TestMethod() throws Exception {\n+            var cl = createClassLoaderFor().loadClass(CLASS_NAME);\n+            method = cl.getMethod(METHOD_TO_COMPILE, byte[].class, byte[].class, byte[].class);\n+            getWhiteBox().testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+            getWhiteBox().markMethodProfiled(method);\n+        }\n+\n+        public void invoke(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+        }\n+\n+        public void compileWithC2() throws Exception {\n+            getWhiteBox().enqueueMethodForCompilation(method, C2_LEVEL);\n+            while (getWhiteBox().isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (getWhiteBox().getMethodCompilationLevel(method) != C2_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled by C2.\");\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private void generateOneGroupCode() throws Exception {\n+        byte[] result = new byte[num1.length + 1];\n+\n+        methods = new TestMethod[activeMethodCount];\n+        for (int i = 0; i < activeMethodCount; ++i) {\n+            methods[i] = new TestMethod();\n+            methods[i].profile(num1, num2, result);\n+            methods[i].compileWithC2();\n+        }\n+        allocateDummyBlobs(DUMMY_BLOB_COUNT, DUMMY_BLOB_SIZE, methods[activeMethodCount - 1].getNMethod().code_blob_type.id);\n+        compileCallMethods();\n+    }\n+\n+    private void allocateDummyBlobs(int count, int size, int codeBlobType) {\n+        getWhiteBox().lockCompilation();\n+        for (int i = 0; i < count; i++) {\n+            var dummyBlob = getWhiteBox().allocateCodeBlob(size, codeBlobType);\n+            if (dummyBlob == 0) {\n+                throw new IllegalStateException(\"Failed to allocate dummy blob.\");\n+            }\n+        }\n+        getWhiteBox().unlockCompilation();\n+    }\n+\n+    private void generateCode() throws Exception {\n+        initNums();\n+\n+        if (groupCount == 1) {\n+            generateOneGroupCode();\n+            return;\n+        }\n+\n+        final int defaultMethodsPerGroup = activeMethodCount \/ groupCount;\n+        if (defaultMethodsPerGroup == 0) {\n+            throw new IllegalArgumentException(\"activeMethodCount = \" + activeMethodCount\n+                + \",  groupCount = \" + groupCount\n+                + \". 'activeMethodCount' must be greater than or equal to 'groupCount'.\");\n+        }\n+\n+        if ((codeRegionSize & (codeRegionSize - 1)) != 0) {\n+            throw new IllegalArgumentException(\"codeRegionSize = \" + codeRegionSize\n+                + \". 'codeRegionSize' must be a power of 2.\");\n+        }\n+\n+        byte[] result = new byte[num1.length + 1];\n+        methods = new TestMethod[activeMethodCount];\n+        methods[0] = new TestMethod();\n+        methods[0].profile(num1, num2, result);\n+        methods[0].compileWithC2();\n+        final var nmethod = methods[0].getNMethod();\n+        if (nmethod.size * defaultMethodsPerGroup > codeRegionSize) {\n+            throw new IllegalArgumentException(\"codeRegionSize = \" + codeRegionSize\n+                    + \", methodsPerRegion = \" + defaultMethodsPerGroup\n+                    + \", nmethod size = \" + nmethod.size\n+                    + \". One code region does not have enough space to hold \" + defaultMethodsPerGroup + \" nmethods.\");\n+        }\n+\n+        final var codeHeapSize = nmethod.code_blob_type.getSize();\n+        final var neededSpace = groupCount * codeRegionSize;\n+        if (neededSpace > codeHeapSize) {\n+            throw new IllegalArgumentException(nmethod.code_blob_type.sizeOptionName + \" = \" + codeHeapSize\n+                    + \". Not enough space to hold \" + groupCount + \" groups \"\n+                    + \"of code region size \" + codeRegionSize + \".\");\n+        }\n+\n+        int j = 1;\n+        for (; j < defaultMethodsPerGroup; ++j) {\n+            methods[j] = new TestMethod();\n+            methods[j].profile(num1, num2, result);\n+            methods[j].compileWithC2();\n+        }\n+\n+        int methodsPerGroup = defaultMethodsPerGroup;\n+        int remainingMethods = activeMethodCount % groupCount;\n+        for (int i = 1; i < groupCount; ++i) {\n+            getWhiteBox().lockCompilation();\n+            var firstNmethodInPrevGroup = methods[j - methodsPerGroup].getNMethod();\n+            var regionStart = firstNmethodInPrevGroup.address & ~(codeRegionSize - 1);\n+            var regionEnd = regionStart + codeRegionSize;\n+            var lastNmethodInPrevGroup = methods[j - 1].getNMethod();\n+            if ((lastNmethodInPrevGroup.address + lastNmethodInPrevGroup.size) < regionEnd) {\n+                var dummyBlob = getWhiteBox().allocateCodeBlob(regionEnd - lastNmethodInPrevGroup.address - lastNmethodInPrevGroup.size,\n+                                                               lastNmethodInPrevGroup.code_blob_type.id);\n+                if (dummyBlob == 0) {\n+                    throw new IllegalStateException(\"Failed to allocate dummy blob.\");\n+                }\n+            }\n+            getWhiteBox().unlockCompilation();\n+\n+            methodsPerGroup = defaultMethodsPerGroup;\n+            if (remainingMethods > 0) {\n+                ++methodsPerGroup;\n+                --remainingMethods;\n+            }\n+\n+            for (int k = 0; k < methodsPerGroup; ++k, ++j) {\n+                methods[j] = new TestMethod();\n+                methods[j].profile(num1, num2, result);\n+                methods[j].compileWithC2();\n+            }\n+        }\n+\n+        allocateDummyBlobs(DUMMY_BLOB_COUNT, DUMMY_BLOB_SIZE, methods[j - 1].getNMethod().code_blob_type.id);\n+        compileCallMethods();\n+    }\n+\n+    private void compileCallMethods() throws Exception {\n+        var threadState = new ThreadState();\n+        threadState.setup();\n+        callMethods(threadState);\n+        Method method = SparseCodeCache.class.getDeclaredMethod(\"callMethods\", ThreadState.class);\n+        getWhiteBox().markMethodProfiled(method);\n+        getWhiteBox().enqueueMethodForCompilation(method, C2_LEVEL);\n+        while (getWhiteBox().isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        if (getWhiteBox().getMethodCompilationLevel(method) != C2_LEVEL) {\n+            throw new IllegalStateException(\"Method SparseCodeCache::callMethods is not compiled by C2.\");\n+        }\n+        getWhiteBox().testSetDontInlineMethod(method, true);\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        generateCode();\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private void callMethods(ThreadState s) throws Exception {\n+        for (var m : methods) {\n+            m.invoke(num1, num2, s.result);\n+        }\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 2)\n+    public void runMethodsWithReflection(ThreadState s) throws Exception {\n+        callMethods(s);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SparseCodeCache.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"}]}