{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+            extra-libs: libsleef-dev\n@@ -137,1 +138,1 @@\n-          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype-dev,libpng-dev\n+          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype-dev,libpng-dev,${{ extra-libs }}\n","filename":".github\/workflows\/build-cross-compile.yml","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+<li><a href=\"#libsleef\" id=\"toc-libsleef\">libsleef<\/a><\/li>\n@@ -819,0 +820,13 @@\n+<h3 id=\"libsleef\">libsleef<\/h3>\n+<p>libsleef, the <a href=\"https:\/\/sleef.org\/\">SIMD Library for\n+Evaluating Elementary Functions<\/a> is optional. But it will provide\n+performance enhancement for vector math operations on Linux\/aarch64\n+platforms.<\/p>\n+<ul>\n+<li>To install on an apt-based Linux, try running\n+<code>sudo apt-get install     libsleef-dev<\/code>.<\/li>\n+<li>To install on an rpm-based Linux, try running\n+<code>sudo yum install     sleef-devel<\/code>.<\/li>\n+<\/ul>\n+<p>Use <code>--with-libsleef=&lt;path&gt;<\/code> if\n+<code>configure<\/code> does not properly locate your libsleef files.<\/p>\n","filename":"doc\/building.html","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -637,0 +637,14 @@\n+### libsleef\n+\n+libsleef, the [SIMD Library for Evaluating Elementary Functions](\n+https:\/\/sleef.org\/) is optional. But it will provide performance enhancement\n+for vector math operations on Linux\/aarch64 platforms.\n+\n+  * To install on an apt-based Linux, try running `sudo apt-get install\n+    libsleef-dev`.\n+  * To install on an rpm-based Linux, try running `sudo yum install\n+    sleef-devel`.\n+\n+Use `--with-libsleef=<path>` if `configure` does not properly locate your libsleef\n+files.\n+\n","filename":"doc\/building.md","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -990,0 +990,32 @@\n+\n+  # Check whether the compiler supports the Arm C Language Extensions (ACLE)\n+  # for SVE. Set SVE_CFLAGS to -march=armv8-a+sve if it does. Empty otherwise.\n+  # ACLE and this flag are required to build the Arm SVE related functions in\n+  # libvmath.\n+  if test \"x${OPENJDK_TARGET_CPU}\" = \"xaarch64\"; then\n+    if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n+      AC_LANG_PUSH(C)\n+      OLD_CFLAGS=\"$CFLAGS\"\n+      CFLAGS=\"$CFLAGS -march=armv8-a+sve\"\n+\n+      AC_MSG_CHECKING([if Arm SVE ACLE is supported])\n+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <arm_sve.h>],\n+          [\n+            svint32_t r = svdup_n_s32(1);\n+            return 0;\n+          ])],\n+          [\n+            AC_MSG_RESULT([yes])\n+            $2SVE_CFLAGS=\"-march=armv8-a+sve\"\n+          ],\n+          [\n+            AC_MSG_RESULT([no])\n+            $2SVE_CFLAGS=\"\"\n+          ]\n+      )\n+\n+      CFLAGS=\"$OLD_CFLAGS\"\n+      AC_LANG_POP(C)\n+    fi\n+  fi\n+  AC_SUBST($2SVE_CFLAGS)\n","filename":"make\/autoconf\/flags-cflags.m4","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,2 @@\n+    sleef)\n+      PKGHANDLER_COMMAND=\"sudo apt-get install libsleef-dev\" ;;\n@@ -164,0 +166,2 @@\n+    sleef)\n+      PKGHANDLER_COMMAND=\"sudo yum install sleef-devel\" ;;\n","filename":"make\/autoconf\/help.m4","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+#\n+# Copyright (c) 2024, Arm Limited. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+###############################################################################\n+#\n+# Setup sleef framework\n+#\n+AC_DEFUN_ONCE([LIB_SETUP_SLEEF],\n+[\n+  AC_ARG_WITH(libsleef, [AS_HELP_STRING([--with-libsleef],\n+      [specify prefix directory for the libsleef library\n+      (expecting the libraries under PATH\/lib and the headers under PATH\/include)])])\n+  AC_ARG_WITH(libsleef-include, [AS_HELP_STRING([--with-libsleef-include],\n+      [specify directory for the libsleef include files\n+      (should be used together with --with-libsleef-lib)])])\n+  AC_ARG_WITH(libsleef-lib, [AS_HELP_STRING([--with-libsleef-lib],\n+      [specify directory for the libsleef library\n+      (should be used together with --with-libsleef-include)])])\n+\n+  ENABLE_LIBSLEEF=false\n+  LIBSLEEF_CFLAGS=\n+  LIBSLEEF_LIBS=\n+\n+  if test \"x${NEEDS_LIB_SLEEF}\" = xfalse; then\n+    if (test \"x${with_libsleef}\" != x && test \"x${with_libsleef}\" != xno) || \\\n+       (test \"x${with_libsleef_include}\" != x && test \"x${with_libsleef_include}\" != xno) || \\\n+       (test \"x${with_libsleef_lib}\" != x && test \"x${with_libsleef_lib}\" != xno); then\n+      AC_MSG_WARN([libsleef is not used, so --with-libsleef[-*] is ignored])\n+    fi\n+  elif test \"x${with_libsleef}\" = \"xno\" ||\n+       test \"x${with_libsleef_include}\" = \"xno\" ||\n+       test \"x${with_libsleef_lib}\" = \"xno\"; then\n+    AC_MSG_NOTICE([libsleef is disabled])\n+  elif test \"x${with_libsleef_lib}\" = \"xyes\" ||\n+       test \"x${with_libsleef_include}\" = \"xyes\"; then\n+    AC_MSG_ERROR([Must specify a value for --with-libsleef-*])\n+  elif (test \"x${with_libsleef_lib}\" != \"x\" && test \"x${with_libsleef_include}\" = \"x\") ||\n+       (test \"x${with_libsleef_include}\" != \"x\" && test \"x${with_libsleef_lib}\" = \"x\"); then\n+    AC_MSG_ERROR([--with-libsleef-lib and --with-libsleef-include should be specified together])\n+  else\n+    LIBSLEEF_FOUND=no\n+\n+    # Check the specified libsleef\n+    if test \"x${with_libsleef}\" != \"x\" &&\n+       test \"x${with_libsleef}\" != \"xyes\"; then\n+      AC_MSG_CHECKING([for the specified LIBSLEEF])\n+      if test -e ${with_libsleef}\/lib\/libsleef.so &&\n+         test -e ${with_libsleef}\/include\/sleef.h; then\n+        LIBSLEEF_LIBS=\"-L${with_libsleef}\/lib -lsleef\"\n+        LIBSLEEF_CFLAGS=\"-I${with_libsleef}\/include\"\n+        AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([Could not locate libsleef.so or sleef.h in ${with_libsleef}])\n+      fi\n+    fi\n+    if test \"x${with_libsleef_lib}\" != \"x\"; then\n+      AC_MSG_CHECKING([for the specified LIBSLEEF lib])\n+      if test -e ${with_libsleef_lib}\/libsleef.so; then\n+        LIBSLEEF_LIBS=\"-L${with_libsleef_lib} -lsleef\"\n+        AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([Could not locate libsleef.so in ${with_libsleef_lib}])\n+      fi\n+    fi\n+    if test \"x${with_libsleef_include}\" != \"x\"; then\n+      AC_MSG_CHECKING([for the specified LIBSLEEF header])\n+      if test -e ${with_libsleef_include}\/sleef.h; then\n+        LIBSLEEF_CFLAGS=\"-I${with_libsleef_include}\"\n+        AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([Could not locate sleef.h in ${with_libsleef_include}])\n+      fi\n+    fi\n+\n+    # Check whether LIBSLEEF_CFLAGS and LIBSLEEF_LIBS are both set.\n+    # Set LIBSLEEF_FOUND to \"yes\" if both of them are set.\n+    if test \"x${LIBSLEEF_CFLAGS}\" != \"x\" &&\n+       test \"x${LIBSLEEF_LIBS}\" != \"x\"; then\n+      LIBSLEEF_FOUND=yes\n+    fi\n+\n+    # Check for the libsleef under system locations\n+    # Do not try pkg-config if we have a sysroot set.\n+    if test \"x$SYSROOT\" = \"x\" && test \"x${LIBSLEEF_FOUND}\" = \"xno\"; then\n+      PKG_CHECK_MODULES([LIBSLEEF], [sleef], [LIBSLEEF_FOUND=yes], [LIBSLEEF_FOUND=no])\n+    fi\n+    if test \"x${LIBSLEEF_FOUND}\" = \"xno\"; then\n+      AC_CHECK_HEADERS([sleef.h],\n+          [\n+            LIBSLEEF_FOUND=yes\n+            LIBSLEEF_LIBS=\"-lsleef\"\n+          ],\n+          []\n+      )\n+    fi\n+\n+    # Print error if user runs just with \"--with-libsleef\",\n+    # but libsleef is not installed.\n+    if test \"x${with_libsleef}\" = \"xyes\" &&\n+       test \"x${LIBSLEEF_FOUND}\" = \"xno\"; then\n+      HELP_MSG_MISSING_DEPENDENCY([sleef])\n+      AC_MSG_ERROR([Could not find libsleef! $HELP_MSG])\n+    fi\n+\n+    if test \"x${LIBSLEEF_FOUND}\" = \"xyes\"; then\n+      ENABLE_LIBSLEEF=true\n+    fi\n+\n+  fi\n+\n+  AC_SUBST(ENABLE_LIBSLEEF)\n+  AC_SUBST(LIBSLEEF_CFLAGS)\n+  AC_SUBST(LIBSLEEF_LIBS)\n+])\n","filename":"make\/autoconf\/lib-sleef.m4","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+m4_include([lib-sleef.m4])\n@@ -90,0 +91,8 @@\n+\n+  # Check if sleef is needed\n+  if test \"x$OPENJDK_TARGET_OS\" = xlinux && test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+    NEEDS_LIB_SLEEF=true\n+  else\n+    # All other instances do not need sleef\n+    NEEDS_LIB_SLEEF=false\n+  fi\n@@ -128,0 +137,1 @@\n+  LIB_SETUP_SLEEF\n","filename":"make\/autoconf\/libraries.m4","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -839,0 +839,3 @@\n+ENABLE_LIBSLEEF := @ENABLE_LIBSLEEF@\n+LIBSLEEF_CFLAGS := @LIBSLEEF_CFLAGS@\n+LIBSLEEF_LIBS := @LIBSLEEF_LIBS@\n@@ -852,0 +855,3 @@\n+# Arm SVE\n+SVE_CFLAGS := @SVE_CFLAGS@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,13 @@\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, aarch64)+$(INCLUDE_COMPILER2)+$(ENABLE_LIBSLEEF), true+true+true+true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBVMATH, \\\n+      NAME := vmath, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) $(LIBSLEEF_CFLAGS), \\\n+      vect_math_sve.c_CFLAGS := $(SVE_CFLAGS), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := $(JDKLIB_LIBS) $(LIBSLEEF_LIBS) \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBVMATH)\n+endif\n+\n","filename":"make\/modules\/jdk.incubator.vector\/Lib.gmk","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2322,1 +2322,0 @@\n-\/\/ Vector calling convention not yet implemented.\n@@ -2324,1 +2323,1 @@\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n@@ -2328,2 +2327,7 @@\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n@@ -16149,0 +16153,16 @@\n+\/\/ Call Runtime Instruction without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf vector $meth\" %}\n+\n+  ins_encode(aarch64_enc_java_to_runtime(meth));\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -887,1 +887,14 @@\n-  Unimplemented();\n+  \/\/ More than 8 argument inputs are not supported now.\n+  assert(total_args_passed <= Argument::n_float_register_parameters_c, \"unsupported\");\n+  assert(num_bits >= 64 && num_bits <= 2048 && is_power_of_2(num_bits), \"unsupported\");\n+\n+  static const FloatRegister VEC_ArgReg[Argument::n_float_register_parameters_c] = {\n+    v0, v1, v2, v3, v4, v5, v6, v7\n+  };\n+\n+  \/\/ On SVE, we use the same vector registers with 128-bit vector registers on NEON.\n+  int next_reg_val = num_bits == 64 ? 1 : 3;\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[i]->as_VMReg();\n+    regs[i].set_pair(vmreg->next(next_reg_val), vmreg);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -8538,0 +8539,66 @@\n+\n+#ifdef COMPILER2\n+    \/\/ Get native vector math stub routine addresses\n+    void* libvmath = nullptr;\n+    char ebuf[1024];\n+    char dll_name[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"vmath\")) {\n+      libvmath = os::dll_load(dll_name, ebuf, sizeof ebuf);\n+    }\n+    if (libvmath != nullptr) {\n+      \/\/ Method naming convention\n+      \/\/   All the methods are named as <OP><T><N>_<U><suffix>\n+      \/\/   Where:\n+      \/\/     <OP>     is the operation name, e.g. sin\n+      \/\/     <T>      is optional to indicate float\/double\n+      \/\/              \"f\/d\" for vector float\/double operation\n+      \/\/     <N>      is the number of elements in the vector\n+      \/\/              \"2\/4\" for neon, and \"x\" for sve\n+      \/\/     <U>      is the precision level\n+      \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+      \/\/               We use \"u10\" for all operations by default\n+      \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n+      \/\/     <suffix> indicates neon\/sve\n+      \/\/              \"sve\/advsimd\" for sve\/neon implementations\n+      \/\/     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n+      \/\/          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n+      \/\/\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"vmath\" JNI_LIB_SUFFIX, p2i(libvmath));\n+\n+      \/\/ Math vector stubs implemented with SVE for scalable vector size.\n+      if (UseSVE > 0) {\n+        for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+          int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+\n+          \/\/ The native library does not support u10 level of \"hypot\".\n+          const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+          snprintf(ebuf, sizeof(ebuf), \"%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+          snprintf(ebuf, sizeof(ebuf), \"%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libvmath, ebuf);\n+        }\n+      }\n+\n+      \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+\n+        \/\/ The native library does not support u10 level of \"hypot\".\n+        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libvmath, ebuf);\n+      }\n+    } else {\n+      log_info(library)(\"Failed to load native vector math library!\");\n+    }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4337,2 +4337,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4343,1 +4343,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4346,1 +4346,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4351,2 +4351,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4356,1 +4356,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4359,1 +4359,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4362,1 +4362,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4365,1 +4365,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4368,1 +4368,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4371,1 +4371,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,1 +367,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -539,1 +539,1 @@\n-    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n@@ -542,3 +542,3 @@\n-        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n-                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+        tty->print_cr(\"  ** Vector math call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n+                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n@@ -2177,1 +2177,1 @@\n-static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n@@ -2181,2 +2181,2 @@\n-  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n@@ -2190,1 +2190,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2194,1 +2194,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2205,0 +2205,10 @@\n+  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n+    if (bt == T_FLOAT) {\n+      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    } else {\n+      assert(bt == T_DOUBLE, \"must be FP type only\");\n+      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    }\n+  }\n@@ -2208,1 +2218,1 @@\n-Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -2210,1 +2220,1 @@\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n@@ -2216,2 +2226,2 @@\n-  \/\/ Get address for svml method.\n-  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n+  \/\/ Get address for vector math method.\n+  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-const char* VectorSupport::svmlname[VectorSupport::NUM_SVML_OP] = {\n+const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,3 +124,3 @@\n-    VECTOR_OP_SVML_START = VECTOR_OP_TAN,\n-    VECTOR_OP_SVML_END   = VECTOR_OP_HYPOT,\n-    NUM_SVML_OP = VECTOR_OP_SVML_END - VECTOR_OP_SVML_START + 1\n+    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n+    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n+    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -134,1 +134,2 @@\n-    NUM_VEC_SIZES = 4\n+    VEC_SIZE_SCALABLE = 4,\n+    NUM_VEC_SIZES = 5\n@@ -142,1 +143,1 @@\n-  static const char* svmlname[VectorSupport::NUM_SVML_OP];\n+  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,2 +176,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -272,2 +272,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef _VECT_MATH_H_\n+#define _VECT_MATH_H_\n+\n+#ifndef __has_attribute\n+#define __has_attribute(x) 0\n+#endif\n+\n+#ifndef VMATH_EXPORT\n+  #if (defined(__GNUC__) && (__GNUC__ >= 4)) || __has_attribute(visibility)\n+    #define VMATH_EXPORT __attribute__((visibility(\"default\")))\n+  #else\n+    #define VMATH_EXPORT\n+  #endif\n+#endif \/* VMATH_EXPORT *\/\n+\n+#endif \/* _VECT_MATH_H_ *\/\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libvmath\/vect_math.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sleef.h>\n+#include <vect_math.h>\n+\n+#define DEFINE_VECTOR_MATH_UNARY(op, type) \\\n+VMATH_EXPORT                               \\\n+type op##advsimd(type input) {             \\\n+  return Sleef_##op##advsimd(input);       \\\n+}\n+\n+#define DEFINE_VECTOR_MATH_BINARY(op, type)   \\\n+VMATH_EXPORT                                  \\\n+type op##advsimd(type input1, type input2) {  \\\n+  return Sleef_##op##advsimd(input1, input2); \\\n+}\n+\n+DEFINE_VECTOR_MATH_UNARY(tanf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(tanhf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(sinf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(sinhf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(cosf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(coshf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(asinf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(acosf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(atanf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(cbrtf4_u10,  float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(logf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(log10f4_u10, float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(log1pf4_u10, float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(expf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_UNARY(expm1f4_u10, float32x4_t)\n+\n+DEFINE_VECTOR_MATH_UNARY(tand2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(tanhd2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(sind2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(sinhd2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(cosd2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(coshd2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(asind2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(acosd2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(atand2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(cbrtd2_u10,  float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(logd2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(log10d2_u10, float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(log1pd2_u10, float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(expd2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_UNARY(expm1d2_u10, float64x2_t)\n+\n+DEFINE_VECTOR_MATH_BINARY(atan2f4_u10, float32x4_t)\n+DEFINE_VECTOR_MATH_BINARY(powf4_u10,   float32x4_t)\n+DEFINE_VECTOR_MATH_BINARY(hypotf4_u05, float32x4_t)\n+\n+DEFINE_VECTOR_MATH_BINARY(atan2d2_u10, float64x2_t)\n+DEFINE_VECTOR_MATH_BINARY(powd2_u10,   float64x2_t)\n+DEFINE_VECTOR_MATH_BINARY(hypotd2_u05, float64x2_t)\n+\n+#undef DEFINE_VECTOR_MATH_UNARY\n+\n+#undef DEFINE_VECTOR_MATH_BINARY\n+\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libvmath\/vect_math_neon.c","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sleef.h>\n+#include <vect_math.h>\n+\n+#define DEFINE_VECTOR_MATH_UNARY_SVE(op, type) \\\n+VMATH_EXPORT                                   \\\n+type op##sve(type input) {                     \\\n+  return Sleef_##op##sve(input);               \\\n+}\n+\n+#define DEFINE_VECTOR_MATH_BINARY_SVE(op, type) \\\n+VMATH_EXPORT                                    \\\n+type op##sve(type input1, type input2) {        \\\n+  return Sleef_##op##sve(input1, input2);       \\\n+}\n+\n+#ifdef __ARM_FEATURE_SVE\n+DEFINE_VECTOR_MATH_UNARY_SVE(tanfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(sinfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(sinhfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(cosfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(coshfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(asinfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(acosfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(atanfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(cbrtfx_u10,  svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(logfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(log10fx_u10, svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(log1pfx_u10, svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(expfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(expm1fx_u10, svfloat32_t)\n+\n+DEFINE_VECTOR_MATH_UNARY_SVE(tandx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(sindx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(sinhdx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(cosdx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(coshdx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(asindx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(acosdx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(atandx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(cbrtdx_u10,  svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(logdx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(log10dx_u10, svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(log1pdx_u10, svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(expdx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_UNARY_SVE(expm1dx_u10, svfloat64_t)\n+\n+DEFINE_VECTOR_MATH_BINARY_SVE(atan2fx_u10, svfloat32_t)\n+DEFINE_VECTOR_MATH_BINARY_SVE(powfx_u10,   svfloat32_t)\n+DEFINE_VECTOR_MATH_BINARY_SVE(hypotfx_u05, svfloat32_t)\n+\n+DEFINE_VECTOR_MATH_BINARY_SVE(atan2dx_u10, svfloat64_t)\n+DEFINE_VECTOR_MATH_BINARY_SVE(powdx_u10,   svfloat64_t)\n+DEFINE_VECTOR_MATH_BINARY_SVE(hypotdx_u05, svfloat64_t)\n+#endif \/* __ARM_FEATURE_SVE *\/\n+\n+#undef DEFINE_VECTOR_MATH_UNARY_SVE\n+\n+#undef DEFINE_VECTOR_MATH_BINARY_SVE\n+\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libvmath\/vect_math_sve.c","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}