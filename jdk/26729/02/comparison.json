{"files":[{"patch":"@@ -544,1 +544,1 @@\n-  typedef ResizeableResourceHashtable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n+  typedef ResizeableHashTable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -50,1 +50,1 @@\n-using ClassesTable = ResourceHashtable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+using ClassesTable = HashTable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -72,1 +72,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -56,1 +56,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -95,1 +95,1 @@\n-class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+class KeepAliveObjectsTable : public HashTable<oop, bool,\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -232,2 +232,2 @@\n-  ResizeableResourceHashtable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n-  ResizeableResourceHashtable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n+  ResizeableHashTable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n+  ResizeableHashTable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-  ResourceHashtable<uintptr_t, bool>* _table;\n+  HashTable<uintptr_t, bool>* _table;\n@@ -354,1 +354,1 @@\n-  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n+  VerifyLoadedHeapEmbeddedPointers(HashTable<uintptr_t, bool>* table) : _table(table) {}\n@@ -414,1 +414,1 @@\n-  ResourceHashtable<uintptr_t, bool> table;\n+  HashTable<uintptr_t, bool> table;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -155,1 +155,1 @@\n-  typedef ResizeableResourceHashtable<size_t, oop,\n+  typedef ResizeableHashTable<size_t, oop,\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -50,1 +50,1 @@\n-  ResourceHashtable<oop, StaticFieldInfo,\n+  HashTable<oop, StaticFieldInfo,\n@@ -82,1 +82,1 @@\n-  \/\/ For ResourceHashtable::iterate()\n+  \/\/ For HashTable::iterate()\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+  typedef ResizeableHashTable<int, InstanceKlass*,\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-class ClassListWriter::IDTable : public ResourceHashtable<\n+class ClassListWriter::IDTable : public HashTable<\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-using DumpTimeSharedClassTableBaseType = ResourceHashtable<\n+using DumpTimeSharedClassTableBaseType = HashTable<\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-class MetaspaceObjToOopHandleTable: public ResourceHashtable<MetaspaceObj*, OopHandle,\n+class MetaspaceObjToOopHandleTable: public HashTable<MetaspaceObj*, OopHandle,\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -205,1 +205,1 @@\n-  typedef ResizeableResourceHashtable<oop, CachedOopInfo,\n+  typedef ResizeableHashTable<oop, CachedOopInfo,\n@@ -212,1 +212,1 @@\n-    : public ResourceHashtable<Klass*, KlassSubGraphInfo,\n+    : public HashTable<Klass*, KlassSubGraphInfo,\n@@ -267,1 +267,1 @@\n-  typedef ResizeableResourceHashtable<oop, bool,\n+  typedef ResizeableHashTable<oop, bool,\n@@ -471,1 +471,1 @@\n-  public ResizeableResourceHashtable<oop, bool,\n+  public ResizeableHashTable<oop, bool,\n@@ -478,1 +478,1 @@\n-    ResizeableResourceHashtable<oop, bool,\n+    ResizeableHashTable<oop, bool,\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -252,1 +252,1 @@\n-  : public ResourceHashtable<LambdaProxyClassKey,\n+  : public HashTable<LambdaProxyClassKey,\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"cds\/cds_globals.hpp\"\n@@ -39,0 +39,1 @@\n+#include \"cds\/cds_globals.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -65,1 +65,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -67,0 +66,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -100,0 +100,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -102,1 +103,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -181,1 +181,1 @@\n-  ResizeableResourceHashtable<InstanceKlass*, bool,\n+  ResizeableHashTable<InstanceKlass*, bool,\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"cds\/archiveBuilder.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -37,1 +37,1 @@\n-using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n+using RegeneratedObjTable = HashTable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashtable.hpp\"\n@@ -128,1 +127,1 @@\n-  typedef ResourceHashtable<BytecodeCPEntry, u2,\n+  typedef HashTable<BytecodeCPEntry, u2,\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -26,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"classfile\/classLoadInfo.hpp\"\n@@ -84,0 +84,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -86,1 +87,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -785,1 +785,1 @@\n-using NameSigHashtable = ResourceHashtable<NameSigHash, int,\n+using NameSigHashtable = HashTable<NameSigHash, int,\n@@ -852,1 +852,1 @@\n-    ResourceHashtable<Symbol*, int>* interface_names = new ResourceHashtable<Symbol*, int>();\n+    HashTable<Symbol*, int>* interface_names = new HashTable<Symbol*, int>();\n@@ -2025,1 +2025,1 @@\n-  typedef ResourceHashtable<LocalVariableTableElement, LocalVariableTableElement*,\n+  typedef HashTable<LocalVariableTableElement, LocalVariableTableElement*,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -35,2 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashtable.hpp\"\n@@ -108,1 +106,1 @@\n-  typedef ResourceHashtable<oop, ClassLoaderStats,\n+  typedef HashTable<oop, ClassLoaderStats,\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/loaderConstraints.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"classfile\/loaderConstraints.hpp\"\n@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -150,1 +150,1 @@\n-using InternalLoaderConstraintTable = ResourceHashtable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InternalLoaderConstraintTable = HashTable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"classfile\/moduleEntry.hpp\"\n@@ -48,0 +48,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -406,1 +406,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -215,1 +215,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -52,1 +52,1 @@\n-using InternalPlaceholderTable = ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n+using InternalPlaceholderTable = HashTable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -56,1 +56,1 @@\n-using InternalResolutionErrorTable = ResourceHashtable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n+using InternalResolutionErrorTable = HashTable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -813,1 +813,1 @@\n-  ResizeableResourceHashtable<oop, bool, AnyObj::C_HEAP, mtInternal,\n+  ResizeableHashTable<oop, bool, AnyObj::C_HEAP, mtInternal,\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-using InvokeMethodIntrinsicTable = ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n+using InvokeMethodIntrinsicTable = HashTable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n@@ -117,1 +117,1 @@\n-using InvokeMethodTypeTable = ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InvokeMethodTypeTable = HashTable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -77,1 +78,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -448,1 +449,1 @@\n-class UnregisteredClassesTable : public ResourceHashtable<\n+class UnregisteredClassesTable : public HashTable<\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -273,1 +273,1 @@\n-typedef ResourceHashtable<int, sig_as_verification_types*, 1007>\n+typedef HashTable<int, sig_as_verification_types*, 1007>\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1188,1 +1188,1 @@\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n+  typedef HashTable<DependencySignature, int, 11027,\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -82,1 +82,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -43,1 +44,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -192,1 +193,1 @@\n-  typedef ResourceHashtable<\n+  typedef HashTable<\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -55,1 +56,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -519,1 +519,1 @@\n-typedef ResourceHashtable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n+typedef HashTable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-         bool (*EQUALS)(K const&, K const&)> class ResizeableResourceHashtable;\n+         bool (*EQUALS)(K const&, K const&)> class ResizeableHashTable;\n@@ -51,1 +51,1 @@\n-typedef ResizeableResourceHashtable<traceid, jclass,\n+typedef ResizeableHashTable<traceid, jclass,\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  typedef ResizeableResourceHashtable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n+  typedef ResizeableHashTable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -440,2 +440,2 @@\n-  ResourceHashtable<jlong, JVMCIObject> longs;\n-  ResourceHashtable<const char*, JVMCIObject,\n+  HashTable<jlong, JVMCIObject> longs;\n+  HashTable<const char*, JVMCIObject,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -69,1 +69,1 @@\n-  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*,\n+  using AsyncLogMap = HashTable<LogFileStreamOutput*,\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  ResizeableResourceHashtable<address, bool, AnyObj::C_HEAP,\n+  ResizeableHashTable<address, bool, AnyObj::C_HEAP,\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -44,1 +44,1 @@\n-  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  mutable HashTable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -875,1 +875,1 @@\n-    ResourceHashtable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+    HashTable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1119,1 +1119,1 @@\n-using InitializationErrorTable = ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n+using InitializationErrorTable = HashTable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-    ResizeableResourceHashtable<const Key*, TrainingData*,\n+    ResizeableHashTable<const Key*, TrainingData*,\n@@ -232,1 +232,1 @@\n-    ResizeableResourceHashtable<TrainingData*, bool> _visited;\n+    ResizeableHashTable<TrainingData*, bool> _visited;\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -91,1 +92,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -2790,1 +2790,1 @@\n-static uint eval_operand(Node* n, ResourceHashtable<Node*,uint>& eval_map) {\n+static uint eval_operand(Node* n, HashTable<Node*,uint>& eval_map) {\n@@ -2798,1 +2798,1 @@\n-                          ResourceHashtable<Node*,uint>& eval_map) {\n+                          HashTable<Node*,uint>& eval_map) {\n@@ -2822,1 +2822,1 @@\n-  ResourceHashtable<Node*,uint> eval_map;\n+  HashTable<Node*,uint> eval_map;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1985,1 +1985,1 @@\n-        \/\/ Use 107 as best guess which is the first resize value in ResizeableResourceHashtable::large_table_sizes.\n+        \/\/ Use 107 as best guess which is the first resize value in ResizeableHashTable::large_table_sizes.\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-typedef ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n+typedef ResizeableHashTable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+  HashTable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -204,1 +204,1 @@\n-  using KillerTable = ResourceHashtable<\n+  using KillerTable = HashTable<\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-ResizeableResourceHashtable <JvmtiTagMapKey, jlong,\n+ResizeableHashTable <JvmtiTagMapKey, jlong,\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/allStatic.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -2453,1 +2453,1 @@\n-using AdapterHandlerTable = ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+using AdapterHandlerTable = HashTable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -194,1 +194,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -196,1 +196,1 @@\n-  typedef ResourceHashtable<void *, int, 1031,\n+  typedef HashTable<void *, int, 1031,\n@@ -202,1 +202,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -296,1 +296,1 @@\n-  typedef ResourceHashtable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+  typedef HashTable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n@@ -329,1 +329,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -834,1 +834,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -844,1 +844,1 @@\n-  typedef ResourceHashtable<InstanceKlass*, DumperClassCacheTableEntry*,\n+  typedef HashTable<InstanceKlass*, DumperClassCacheTableEntry*,\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable\n+\/\/ Default hash\/equals functions used by HashTable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_HASHTABLE_HPP\n+#define SHARE_UTILITIES_HASHTABLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+#include \"utilities\/tableStatistics.hpp\"\n+\n+#include <type_traits>\n+\n+template<typename K, typename V>\n+class HashTableNode : public AnyObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  HashTableNode* _next;\n+\n+  HashTableNode(unsigned hash, K const& key, V const& value,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(value), _next(next) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  HashTableNode(unsigned hash, K const& key,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(), _next(next) {}\n+};\n+\n+template<\n+    class STORAGE,\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE,\n+    MemTag MEM_TAG,\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&)\n+    >\n+class HashTableBase : public STORAGE {\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n+                \"Destructor for K is only called with C_HEAP\");\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n+                \"Destructor for V is only called with C_HEAP\");\n+  using Node = HashTableNode<K, V>;\n+ private:\n+  int _number_of_entries;\n+\n+  Node** bucket_at(unsigned index) {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  const Node* const* bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  \/\/ Returns a pointer to where the node where the value would reside if\n+  \/\/ it's in the table.\n+  Node** lookup_node(unsigned hash, K const& key) {\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n+    while (*ptr != nullptr) {\n+      Node* node = *ptr;\n+      if (node->_hash == hash && EQUALS(key, node->_key)) {\n+        break;\n+      }\n+      ptr = &(node->_next);\n+    }\n+    return ptr;\n+  }\n+\n+  Node const** lookup_node(unsigned hash, K const& key) const {\n+    return const_cast<Node const**>(\n+        const_cast<HashTableBase*>(this)->lookup_node(hash, key));\n+  }\n+\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n+\n+  HashTableBase() : STORAGE(), _number_of_entries(0) {}\n+  HashTableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n+  NONCOPYABLE(HashTableBase);\n+\n+  ~HashTableBase() {\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n+        Node* node = *bucket;\n+        while (node != nullptr) {\n+          Node* cur = node;\n+          node = node->_next;\n+          delete cur;\n+        }\n+        ++bucket;\n+      }\n+    }\n+  }\n+\n+ public:\n+  unsigned table_size() const { return STORAGE::table_size(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n+  bool contains(K const& key) const {\n+    return get(key) != nullptr;\n+  }\n+\n+  V* get(K const& key) const {\n+    unsigned hv = HASH(key);\n+    Node const** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      return const_cast<V*>(&(*ptr)->_value);\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+ \/**\n+  * Inserts a value in the front of the table, assuming that\n+  * the entry is absent.\n+  * The table must be locked for the get or test that the entry\n+  * is absent, and for this operation.\n+  * This is a faster variant of put_if_absent because it adds to the\n+  * head of the bucket, and doesn't search the bucket.\n+  * @return: true: a new item is always added\n+  *\/\n+  bool put_when_absent(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    unsigned index = hv % table_size();\n+    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n+    Node** ptr = bucket_at(index);\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n+    } else {\n+      *ptr = new Node(hv, key, value, *ptr);\n+    }\n+    _number_of_entries ++;\n+    return true;\n+  }\n+\n+ \/**\n+  * Inserts or replaces a value in the table.\n+  * @return: true:  if a new item is added\n+  *          false: if the item already existed and the value is updated\n+  *\/\n+  bool put(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      (*ptr)->_value = value;\n+      return false;\n+    } else {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      _number_of_entries ++;\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n+  \/\/  and return a pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key);\n+      } else {\n+        *ptr = new Node(hv, key);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n+  \/\/  pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  template<typename Function>\n+  bool remove(K const& key, Function function) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+\n+    Node* node = *ptr;\n+    if (node != nullptr) {\n+      *ptr = node->_next;\n+      function(node->_key, node->_value);\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        delete node;\n+      }\n+      _number_of_entries --;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  bool remove(K const& key) {\n+    auto dummy = [&] (K& k, V& v) { };\n+    return remove(key, dummy);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns false,\n+  \/\/ the iteration is cancelled.\n+  template<class ITER>\n+  void iterate(ITER* iter) const {\n+    auto function = [&] (K& k, V& v) {\n+      return iter->do_entry(k, v);\n+    };\n+    iterate(function);\n+  }\n+\n+  template<typename Function>\n+  void iterate(Function function) const { \/\/ lambda enabled API\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    int cnt = _number_of_entries;\n+\n+    while (cnt > 0 && bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        bool cont = function(node->_key, node->_value);\n+        if (!cont) { return; }\n+        node = node->_next;\n+        --cnt;\n+      }\n+      ++bucket;\n+    }\n+  }\n+\n+  \/\/ same as above, but unconditionally iterate all entries\n+  template<typename Function>\n+  void iterate_all(Function function) const { \/\/ lambda enabled API\n+    auto wrapper = [&] (K& k, V& v) {\n+      function(k, v);\n+      return true;\n+    };\n+    iterate(wrapper);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns true,\n+  \/\/ the entry is deleted.\n+  template<class ITER>\n+  void unlink(ITER* iter) {\n+    const unsigned sz = table_size();\n+    for (unsigned index = 0; index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      while (*ptr != nullptr) {\n+        Node* node = *ptr;\n+        \/\/ do_entry must clean up the key and value in Node.\n+        bool clean = iter->do_entry(node->_key, node->_value);\n+        if (clean) {\n+          *ptr = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete node;\n+          }\n+          _number_of_entries --;\n+        } else {\n+          ptr = &(node->_next);\n+        }\n+      }\n+    }\n+  }\n+\n+  template<typename Function>\n+  TableStatistics statistics_calculate(Function size_function) const {\n+    NumberSeq summary;\n+    size_t literal_bytes = 0;\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      int count = 0;\n+      while (node != nullptr) {\n+        literal_bytes += size_function(node->_key, node->_value);\n+        count++;\n+        node = node->_next;\n+      }\n+      summary.add((double)count);\n+      ++bucket;\n+    }\n+    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n+  }\n+\n+  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      table_size() * sizeof(Node*) +\n+      number_of_entries() * sizeof(Node);\n+  }\n+};\n+\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n+\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedHashTableStorage() { memset(_table, 0, sizeof(_table)); }\n+  ~FixedHashTableStorage() = default;\n+\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n+\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    unsigned SIZE = 256,\n+    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n+    MemTag MEM_TAG = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class HashTable : public HashTableBase<\n+  FixedHashTableStorage<SIZE, K, V>,\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n+  NONCOPYABLE(HashTable);\n+public:\n+  HashTable() : HashTableBase<FixedHashTableStorage<SIZE, K, V>,\n+                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_HASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  typedef ResizeableResourceHashtable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n+  typedef ResizeableHashTable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ destructors for ResourceHashtable base deletes nodes, and\n-  \/\/ ResizeableResourceHashtableStorage deletes the table.\n+  \/\/ destructors for HashTable base deletes nodes, and\n+  \/\/ ResizeableHashTableStorage deletes the table.\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -34,2 +34,2 @@\n-class ResizeableResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n+class ResizeableHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n@@ -41,1 +41,1 @@\n-  ResizeableResourceHashtableStorage(unsigned table_size) {\n+  ResizeableHashTableStorage(unsigned table_size) {\n@@ -46,1 +46,1 @@\n-  ~ResizeableResourceHashtableStorage() {\n+  ~ResizeableHashTableStorage() {\n@@ -79,2 +79,2 @@\n-class ResizeableResourceHashtable : public ResourceHashtableBase<\n-    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+class ResizeableHashTable : public HashTableBase<\n+    ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n@@ -84,1 +84,1 @@\n-  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+  using BASE = HashTableBase<ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n@@ -86,2 +86,2 @@\n-  using Node = ResourceHashtableNode<K, V>;\n-  NONCOPYABLE(ResizeableResourceHashtable);\n+  using Node = HashTableNode<K, V>;\n+  NONCOPYABLE(ResizeableHashTable);\n@@ -114,1 +114,1 @@\n-  ResizeableResourceHashtable(unsigned size, unsigned max_size)\n+  ResizeableHashTable(unsigned size, unsigned max_size)\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,380 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_RESOURCEHASH_HPP\n-#define SHARE_UTILITIES_RESOURCEHASH_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/numberSeq.hpp\"\n-#include \"utilities\/tableStatistics.hpp\"\n-\n-#include <type_traits>\n-\n-template<typename K, typename V>\n-class ResourceHashtableNode : public AnyObj {\n-public:\n-  unsigned _hash;\n-  K _key;\n-  V _value;\n-  ResourceHashtableNode* _next;\n-\n-  ResourceHashtableNode(unsigned hash, K const& key, V const& value,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(value), _next(next) {}\n-\n-  \/\/ Create a node with a default-constructed value.\n-  ResourceHashtableNode(unsigned hash, K const& key,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(), _next(next) {}\n-};\n-\n-template<\n-    class STORAGE,\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE,\n-    MemTag MEM_TAG,\n-    unsigned (*HASH)  (K const&),\n-    bool     (*EQUALS)(K const&, K const&)\n-    >\n-class ResourceHashtableBase : public STORAGE {\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n-                \"Destructor for K is only called with C_HEAP\");\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n-                \"Destructor for V is only called with C_HEAP\");\n-  using Node = ResourceHashtableNode<K, V>;\n- private:\n-  int _number_of_entries;\n-\n-  Node** bucket_at(unsigned index) {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  const Node* const* bucket_at(unsigned index) const {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  \/\/ Returns a pointer to where the node where the value would reside if\n-  \/\/ it's in the table.\n-  Node** lookup_node(unsigned hash, K const& key) {\n-    unsigned index = hash % table_size();\n-    Node** ptr = bucket_at(index);\n-    while (*ptr != nullptr) {\n-      Node* node = *ptr;\n-      if (node->_hash == hash && EQUALS(key, node->_key)) {\n-        break;\n-      }\n-      ptr = &(node->_next);\n-    }\n-    return ptr;\n-  }\n-\n-  Node const** lookup_node(unsigned hash, K const& key) const {\n-    return const_cast<Node const**>(\n-        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n-  }\n-\n- protected:\n-  Node** table() const { return STORAGE::table(); }\n-\n-  ResourceHashtableBase() : STORAGE(), _number_of_entries(0) {}\n-  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n-  NONCOPYABLE(ResourceHashtableBase);\n-\n-  ~ResourceHashtableBase() {\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n-    }\n-  }\n-\n- public:\n-  unsigned table_size() const { return STORAGE::table_size(); }\n-  int number_of_entries() const { return _number_of_entries; }\n-\n-  bool contains(K const& key) const {\n-    return get(key) != nullptr;\n-  }\n-\n-  V* get(K const& key) const {\n-    unsigned hv = HASH(key);\n-    Node const** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      return const_cast<V*>(&(*ptr)->_value);\n-    } else {\n-      return nullptr;\n-    }\n-  }\n-\n- \/**\n-  * Inserts a value in the front of the table, assuming that\n-  * the entry is absent.\n-  * The table must be locked for the get or test that the entry\n-  * is absent, and for this operation.\n-  * This is a faster variant of put_if_absent because it adds to the\n-  * head of the bucket, and doesn't search the bucket.\n-  * @return: true: a new item is always added\n-  *\/\n-  bool put_when_absent(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    unsigned index = hv % table_size();\n-    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n-    Node** ptr = bucket_at(index);\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n-    } else {\n-      *ptr = new Node(hv, key, value, *ptr);\n-    }\n-    _number_of_entries ++;\n-    return true;\n-  }\n-\n- \/**\n-  * Inserts or replaces a value in the table.\n-  * @return: true:  if a new item is added\n-  *          false: if the item already existed and the value is updated\n-  *\/\n-  bool put(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      (*ptr)->_value = value;\n-      return false;\n-    } else {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      _number_of_entries ++;\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n-  \/\/  and return a pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key);\n-      } else {\n-        *ptr = new Node(hv, key);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n-  \/\/  pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  template<typename Function>\n-  bool remove(K const& key, Function function) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-\n-    Node* node = *ptr;\n-    if (node != nullptr) {\n-      *ptr = node->_next;\n-      function(node->_key, node->_value);\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        delete node;\n-      }\n-      _number_of_entries --;\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  bool remove(K const& key) {\n-    auto dummy = [&] (K& k, V& v) { };\n-    return remove(key, dummy);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns false,\n-  \/\/ the iteration is cancelled.\n-  template<class ITER>\n-  void iterate(ITER* iter) const {\n-    auto function = [&] (K& k, V& v) {\n-      return iter->do_entry(k, v);\n-    };\n-    iterate(function);\n-  }\n-\n-  template<typename Function>\n-  void iterate(Function function) const { \/\/ lambda enabled API\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    int cnt = _number_of_entries;\n-\n-    while (cnt > 0 && bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        bool cont = function(node->_key, node->_value);\n-        if (!cont) { return; }\n-        node = node->_next;\n-        --cnt;\n-      }\n-      ++bucket;\n-    }\n-  }\n-\n-  \/\/ same as above, but unconditionally iterate all entries\n-  template<typename Function>\n-  void iterate_all(Function function) const { \/\/ lambda enabled API\n-    auto wrapper = [&] (K& k, V& v) {\n-      function(k, v);\n-      return true;\n-    };\n-    iterate(wrapper);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns true,\n-  \/\/ the entry is deleted.\n-  template<class ITER>\n-  void unlink(ITER* iter) {\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n-      }\n-    }\n-  }\n-\n-  template<typename Function>\n-  TableStatistics statistics_calculate(Function size_function) const {\n-    NumberSeq summary;\n-    size_t literal_bytes = 0;\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    while (bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      int count = 0;\n-      while (node != nullptr) {\n-        literal_bytes += size_function(node->_key, node->_value);\n-        count++;\n-        node = node->_next;\n-      }\n-      summary.add((double)count);\n-      ++bucket;\n-    }\n-    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n-  }\n-\n-  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n-  size_t mem_size() const {\n-    return sizeof(*this) +\n-      table_size() * sizeof(Node*) +\n-      number_of_entries() * sizeof(Node);\n-  }\n-};\n-\n-template<unsigned TABLE_SIZE, typename K, typename V>\n-class FixedResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n-\n-  Node* _table[TABLE_SIZE];\n-protected:\n-  FixedResourceHashtableStorage() { memset(_table, 0, sizeof(_table)); }\n-  ~FixedResourceHashtableStorage() = default;\n-\n-  constexpr unsigned table_size() const {\n-    return TABLE_SIZE;\n-  }\n-\n-  Node** table() const {\n-    return const_cast<Node**>(_table);\n-  }\n-};\n-\n-template<\n-    typename K, typename V,\n-    unsigned SIZE = 256,\n-    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n-    MemTag MEM_TAG = mtInternal,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class ResourceHashtable : public ResourceHashtableBase<\n-  FixedResourceHashtableStorage<SIZE, K, V>,\n-    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n-  NONCOPYABLE(ResourceHashtable);\n-public:\n-  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>,\n-                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_RESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":0,"deletions":380,"binary":false,"changes":380,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -209,1 +209,1 @@\n-  ResourceHashtable<char*, unsigned> ht;\n+  HashTable<char*, unsigned> ht;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_reserve_between.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+\n+class CommonHashTableTest : public ::testing::Test {\n+ protected:\n+  typedef void* K;\n+  typedef uintx V;\n+  const static MemTag MEM_TAG = mtInternal;\n+\n+  static unsigned identity_hash(const K& k) {\n+    return (unsigned) (uintptr_t) k;\n+  }\n+\n+  static unsigned bad_hash(const K& k) {\n+    return 1;\n+  }\n+\n+  static void* as_K(uintptr_t val) {\n+    return (void*) val;\n+  }\n+\n+  class EqualityTestIter {\n+   public:\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k != (uintptr_t) v) {\n+        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n+        return false;\n+      } else {\n+        return true; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+  class DeleterTestIter {\n+    int _val;\n+   public:\n+    DeleterTestIter(int i) : _val(i) {}\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k == (uintptr_t) _val) {\n+        \/\/ Delete me!\n+        return true;\n+      } else {\n+        return false; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+};\n+\n+class SmallHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(V step) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+\n+      ASSERT_TRUE(rh.put(as_K(step), step));\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+\n+      ASSERT_FALSE(rh.put(as_K(step), step));\n+\n+      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n+      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n+      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n+      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n+\n+      ASSERT_FALSE(rh.remove(as_K(0x0)));\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+      \/\/ Test put_if_absent(key) (creating a default-created value)\n+      bool created = false;\n+      V* v = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+      *v = (V)step;\n+\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      V* v2 = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, *v);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+      \/\/ Test put_if_absent(key, value)\n+      v = rh.put_if_absent(as_K(step), step, &created);\n+      ASSERT_EQ(*v, step);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+\n+      v2 = rh.put_if_absent(as_K(step), step, &created);\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, (V)step);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+    }\n+  };\n+};\n+\n+TEST_VM_F(SmallHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, default_shifted) {\n+  ResourceMark rm;\n+  Runner<>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm_shifted) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm_shifted) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm_shifted) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+class GenericHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(unsigned num_elements = SIZE) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      for (uintptr_t i = 0; i < num_elements; ++i) {\n+        ASSERT_TRUE(rh.put(as_K(i), i));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE((rh.remove(as_K(index))));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.remove(as_K(index)));\n+      }\n+      rh.iterate(&et);\n+\n+      \/\/ Add more entries in and then delete one.\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE(rh.put(as_K(index), index));\n+      }\n+      DeleterTestIter dt(5);\n+      rh.unlink(&dt);\n+      ASSERT_FALSE(rh.get(as_K(5)));\n+    }\n+  };\n+};\n+\n+TEST_VM_F(GenericHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n+}\n+\n+\/\/ Simple HashTable whose key is a SymbolHandle and value is an int\n+\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n+\/\/ in the table.\n+class SimpleHashTableDeleteTest : public ::testing::Test {\n+ public:\n+    HashTable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n+\n+    class SimpleDeleter : public StackObj {\n+      public:\n+        bool do_entry(SymbolHandle& key, int value) {\n+          return true;\n+        }\n+    };\n+};\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_remove) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 55);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable\n+  _simple_test_table.remove(s);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_delete) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink to remove the matching (or all) values from the table.\n+  SimpleDeleter deleter;\n+  _simple_test_table.unlink(&deleter);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+\/\/ More complicated HashTable with SymbolHandle in the key. Since the *same* Symbol is part\n+\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n+\/\/ Luckily SymbolHandle does this.\n+class HashTableDeleteTest : public ::testing::Test {\n+ public:\n+    class TestValue : public CHeapObj<mtTest> {\n+        SymbolHandle _s;\n+      public:\n+        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n+        \/\/ Unless it's declared and used as a CHeapObj with\n+        \/\/ NONCOPYABLE(TestValue)\n+\n+        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n+        \/\/ have dtors, copy ctors and assignment operators to do so.\n+        TestValue(Symbol* name) : _s(name) { }\n+        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n+    };\n+\n+    \/\/ HashTable whose value is a *copy* of TestValue.\n+    HashTable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class Deleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue& value) {\n+          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n+          \/\/ Calling delete on the hashtable Node which contains value will\n+          \/\/ decrement the refcount.  That's actually best since the whole\n+          \/\/ entry will be gone at once.\n+          return true;\n+        }\n+    };\n+\n+    \/\/ HashTable whose value is a pointer to TestValue.\n+    HashTable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n+\n+    class PtrDeleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue*& value) {\n+          \/\/ If the hashtable value is a pointer, need to delete it from here.\n+          \/\/ This will also potentially make the refcount of the Key = 0, but the\n+          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n+          delete value;\n+          return true;\n+        }\n+    };\n+};\n+\n+\n+TEST_VM_F(HashTableDeleteTest, value_remove) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue tv(s);\n+    \/\/ Since TestValue contains the pointer to the key, it will handle the\n+    \/\/ refcounting.\n+    _test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable calls the destructor!\n+  _test_table.remove(s);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, value_delete) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  Deleter deleter;\n+  _test_table.unlink(&deleter);\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, check_delete_ptr) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n+  \/\/ do_entry function.\n+  PtrDeleter deleter;\n+  _ptr_test_table.unlink(&deleter);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+class HashTablePrintTest : public ::testing::Test {\n+ public:\n+    class TestValue {\n+      int _i;\n+      int _j;\n+      int _k;\n+     public:\n+      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n+    };\n+    HashTable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class TableDeleter {\n+     public:\n+      bool do_entry(int& key, TestValue*& val) {\n+        delete val;\n+        return true;\n+      }\n+    };\n+};\n+\n+TEST_VM_F(HashTablePrintTest, print_test) {\n+  for (int i = 0; i < 300; i++) {\n+    TestValue* tv = new TestValue(i);\n+    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n+  }\n+  auto printer = [&] (int& key, TestValue*& val) {\n+    return sizeof(*val);\n+  };\n+  TableStatistics ts = _test_table.statistics_calculate(printer);\n+  ResourceMark rm;\n+  stringStream st;\n+  ts.print(&st, \"TestTable\");\n+  \/\/ Verify output in string\n+  const char* strings[] = {\n+      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n+  for (const auto& str : strings) {\n+    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n+  }\n+  \/\/ Cleanup: need to delete pointers in entries\n+  TableDeleter deleter;\n+  _test_table.unlink(&deleter);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_hashtable.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/symbolHandle.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class CommonResourceHashtableTest : public ::testing::Test {\n- protected:\n-  typedef void* K;\n-  typedef uintx V;\n-  const static MemTag MEM_TAG = mtInternal;\n-\n-  static unsigned identity_hash(const K& k) {\n-    return (unsigned) (uintptr_t) k;\n-  }\n-\n-  static unsigned bad_hash(const K& k) {\n-    return 1;\n-  }\n-\n-  static void* as_K(uintptr_t val) {\n-    return (void*) val;\n-  }\n-\n-  class EqualityTestIter {\n-   public:\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k != (uintptr_t) v) {\n-        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n-        return false;\n-      } else {\n-        return true; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-  class DeleterTestIter {\n-    int _val;\n-   public:\n-    DeleterTestIter(int i) : _val(i) {}\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k == (uintptr_t) _val) {\n-        \/\/ Delete me!\n-        return true;\n-      } else {\n-        return false; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-};\n-\n-class SmallResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(V step) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-\n-      ASSERT_TRUE(rh.put(as_K(step), step));\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-\n-      ASSERT_FALSE(rh.put(as_K(step), step));\n-\n-      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n-      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n-      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n-      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n-\n-      ASSERT_FALSE(rh.remove(as_K(0x0)));\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-      \/\/ Test put_if_absent(key) (creating a default-created value)\n-      bool created = false;\n-      V* v = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-      *v = (V)step;\n-\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      V* v2 = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, *v);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-      \/\/ Test put_if_absent(key, value)\n-      v = rh.put_if_absent(as_K(step), step, &created);\n-      ASSERT_EQ(*v, step);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-\n-      v2 = rh.put_if_absent(as_K(step), step, &created);\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, (V)step);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-    }\n-  };\n-};\n-\n-TEST_VM_F(SmallResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, default_shifted) {\n-  ResourceMark rm;\n-  Runner<>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm_shifted) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm_shifted) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm_shifted) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-class GenericResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(unsigned num_elements = SIZE) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      for (uintptr_t i = 0; i < num_elements; ++i) {\n-        ASSERT_TRUE(rh.put(as_K(i), i));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE((rh.remove(as_K(index))));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_FALSE(rh.remove(as_K(index)));\n-      }\n-      rh.iterate(&et);\n-\n-      \/\/ Add more entries in and then delete one.\n-      for (uintptr_t i = 10; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE(rh.put(as_K(index), index));\n-      }\n-      DeleterTestIter dt(5);\n-      rh.unlink(&dt);\n-      ASSERT_FALSE(rh.get(as_K(5)));\n-    }\n-  };\n-};\n-\n-TEST_VM_F(GenericResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n-}\n-\n-\/\/ Simple ResourceHashtable whose key is a SymbolHandle and value is an int\n-\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n-\/\/ in the table.\n-class SimpleResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    ResourceHashtable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n-\n-    class SimpleDeleter : public StackObj {\n-      public:\n-        bool do_entry(SymbolHandle& key, int value) {\n-          return true;\n-        }\n-    };\n-};\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_remove) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 55);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable\n-  _simple_test_table.remove(s);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 66);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Use unlink to remove the matching (or all) values from the table.\n-  SimpleDeleter deleter;\n-  _simple_test_table.unlink(&deleter);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-\/\/ More complicated ResourceHashtable with SymbolHandle in the key. Since the *same* Symbol is part\n-\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n-\/\/ Luckily SymbolHandle does this.\n-class ResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    class TestValue : public CHeapObj<mtTest> {\n-        SymbolHandle _s;\n-      public:\n-        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n-        \/\/ Unless it's declared and used as a CHeapObj with\n-        \/\/ NONCOPYABLE(TestValue)\n-\n-        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n-        \/\/ have dtors, copy ctors and assignment operators to do so.\n-        TestValue(Symbol* name) : _s(name) { }\n-        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a *copy* of TestValue.\n-    ResourceHashtable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class Deleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue& value) {\n-          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n-          \/\/ Calling delete on the hashtable Node which contains value will\n-          \/\/ decrement the refcount.  That's actually best since the whole\n-          \/\/ entry will be gone at once.\n-          return true;\n-        }\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a pointer to TestValue.\n-    ResourceHashtable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n-\n-    class PtrDeleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue*& value) {\n-          \/\/ If the hashtable value is a pointer, need to delete it from here.\n-          \/\/ This will also potentially make the refcount of the Key = 0, but the\n-          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n-          delete value;\n-          return true;\n-        }\n-    };\n-};\n-\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_remove) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue tv(s);\n-    \/\/ Since TestValue contains the pointer to the key, it will handle the\n-    \/\/ refcounting.\n-    _test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable calls the destructor!\n-  _test_table.remove(s);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_delete) {\n-  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n-  int d_orig_count = d->refcount();\n-  {\n-    TestValue tv(d);\n-    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n-    \/\/ hashtable node is deleted.\n-    _test_table.put(d, tv);\n-    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n-  Deleter deleter;\n-  _test_table.unlink(&deleter);\n-  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue* tv = new TestValue(s);\n-    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n-    \/\/ handle the refcounting.\n-    _ptr_test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n-  \/\/ do_entry function.\n-  PtrDeleter deleter;\n-  _ptr_test_table.unlink(&deleter);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-class ResourceHashtablePrintTest : public ::testing::Test {\n- public:\n-    class TestValue {\n-      int _i;\n-      int _j;\n-      int _k;\n-     public:\n-      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n-    };\n-    ResourceHashtable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class TableDeleter {\n-     public:\n-      bool do_entry(int& key, TestValue*& val) {\n-        delete val;\n-        return true;\n-      }\n-    };\n-};\n-\n-TEST_VM_F(ResourceHashtablePrintTest, print_test) {\n-  for (int i = 0; i < 300; i++) {\n-    TestValue* tv = new TestValue(i);\n-    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n-  }\n-  auto printer = [&] (int& key, TestValue*& val) {\n-    return sizeof(*val);\n-  };\n-  TableStatistics ts = _test_table.statistics_calculate(printer);\n-  ResourceMark rm;\n-  stringStream st;\n-  ts.print(&st, \"TestTable\");\n-  \/\/ Verify output in string\n-  const char* strings[] = {\n-      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n-  for (const auto& str : strings) {\n-    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n-  }\n-  \/\/ Cleanup: need to delete pointers in entries\n-  TableDeleter deleter;\n-  _test_table.unlink(&deleter);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"}]}