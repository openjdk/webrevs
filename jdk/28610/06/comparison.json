{"files":[{"patch":"@@ -94,0 +94,2 @@\n+        if (used.get())\n+            throw new IllegalStateException();\n@@ -210,1 +212,0 @@\n-            compiler.genEndPos = true;\n@@ -248,0 +249,2 @@\n+        if (used.get())\n+            throw new IllegalStateException();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -243,2 +242,1 @@\n-                    EndPosTable endPosTable = ((JCCompilationUnit) file).endPositions;\n-                    return TreeInfo.getEndPos((JCTree) tree, endPosTable);\n+                    return TreeInfo.getEndPos((JCTree) tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -137,1 +136,1 @@\n-    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree) {\n@@ -139,1 +138,1 @@\n-        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+        fileInfoMap.get(sourceFile).afterAttr(tree);\n@@ -187,1 +186,1 @@\n-                    unmappedDecls.add(new Span(decl, tree.endPositions));\n+                    unmappedDecls.add(new Span(decl));\n@@ -192,1 +191,1 @@\n-        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+        void afterAttr(JCTree tree) {\n@@ -195,1 +194,1 @@\n-                    rootRange.populateSubtree(tree, endPositions);\n+                    rootRange.populateSubtree(tree);\n@@ -228,2 +227,2 @@\n-        Span(JCTree tree, EndPosTable endPositions) {\n-            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n+        Span(JCTree tree) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree));\n@@ -259,2 +258,2 @@\n-        LintRange(JCTree tree, EndPosTable endPositions, Lint lint) {\n-            this(new Span(tree, endPositions), lint, new LinkedList<>());\n+        LintRange(JCTree tree, Lint lint) {\n+            this(new Span(tree), lint, new LinkedList<>());\n@@ -280,1 +279,1 @@\n-        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+        void populateSubtree(JCTree tree) {\n@@ -323,1 +322,1 @@\n-                    currentNode = new LintRange(tree, endPositions, newLint);\n+                    currentNode = new LintRange(tree, newLint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2765,2 +2765,1 @@\n-            EndPosTable endPosTable = this.env.toplevel.endPositions;\n-            endPosTable.storeEnd(clazzid1, clazzid.getEndPosition(endPosTable));\n+            clazzid1.endpos = clazzid.getEndPosition();\n@@ -5314,1 +5313,1 @@\n-        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -159,4 +158,0 @@\n-    \/** A hash table mapping syntax trees to their ending source positions.\n-     *\/\n-    EndPosTable endPosTable;\n-\n@@ -2062,2 +2057,2 @@\n-            if (endPosTable != null && result != tree) {\n-                endPosTable.replaceTree(tree, result);\n+            if (result != null && result != tree) {\n+                result.endpos = tree.endpos;\n@@ -4355,1 +4350,0 @@\n-            endPosTable = env.toplevel.endPositions;\n@@ -4385,1 +4379,0 @@\n-            endPosTable = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -60,4 +59,0 @@\n-    \/** The object for ending positions stored in the parser.\n-     *\/\n-    private EndPosTable endPosTable;\n-\n@@ -71,1 +66,1 @@\n-    public CRTable(JCTree.JCMethodDecl tree, EndPosTable endPosTable) {\n+    public CRTable(JCTree.JCMethodDecl tree) {\n@@ -73,1 +68,0 @@\n-        this.endPosTable = endPosTable;\n@@ -587,1 +581,1 @@\n-            return TreeInfo.getEndPos(tree, endPosTable);\n+            return TreeInfo.getEndPos(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -165,5 +164,0 @@\n-    \/** An object containing mappings of syntax trees to their\n-     *  ending source positions.\n-     *\/\n-    EndPosTable endPosTable;\n-\n@@ -458,1 +452,1 @@\n-                        endPosTable.replaceTree(vdef, init);\n+                        init.endpos = vdef.endpos;\n@@ -466,1 +460,1 @@\n-                        endPosTable.replaceTree(vdef, init);\n+                        init.endpos = vdef.endpos;\n@@ -1030,2 +1024,1 @@\n-                                        genCrt ? new CRTable(tree, env.toplevel.endPositions)\n-                                               : null,\n+                                        genCrt ? new CRTable(tree) : null,\n@@ -2481,1 +2474,0 @@\n-            this.endPosTable = toplevel.endPositions;\n@@ -2511,1 +2503,0 @@\n-            endPosTable = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -441,2 +441,0 @@\n-        genEndPos     = options.isSet(XJCOV) ||\n-                        context.get(DiagnosticListener.class) != null;\n@@ -507,4 +505,0 @@\n-    \/** Switch: should we store the ending positions?\n-     *\/\n-    public boolean genEndPos;\n-\n@@ -658,1 +652,0 @@\n-                genEndPos = true;\n@@ -660,1 +653,1 @@\n-            Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,\n+            Parser parser = parserFactory.newParser(content, keepComments(),\n@@ -700,4 +693,1 @@\n-            JCTree.JCCompilationUnit t = parse(filename, readSource(filename));\n-            if (t.endPositions != null)\n-                log.setEndPosTable(filename, t.endPositions);\n-            return t;\n+            return parse(filename, readSource(filename));\n@@ -1165,1 +1155,0 @@\n-                genEndPos = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -1218,1 +1217,1 @@\n-                public int getEndPosition(EndPosTable endPosTable) {\n+                public int getEndPosition() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,2 +113,1 @@\n-    \/** End position mappings container *\/\n-    protected final AbstractEndPosTable endPosTable;\n+    protected int errorEndPos = Position.NOPOS;\n@@ -170,3 +169,2 @@\n-                          boolean keepLineMap,\n-                          boolean keepEndPositions) {\n-        this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);\n+                          boolean keepLineMap) {\n+        this(fac, S, keepDocComments, keepLineMap, false);\n@@ -182,1 +180,0 @@\n-                     boolean keepEndPositions,\n@@ -197,1 +194,0 @@\n-        this.endPosTable = newEndPosTable(keepEndPositions);\n@@ -221,1 +217,0 @@\n-        this.endPosTable = newEndPosTable(false);\n@@ -228,6 +223,0 @@\n-    protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {\n-        return  keepEndPositions\n-                ? new SimpleEndPosTable()\n-                : new MinimalEndPosTable();\n-    }\n-\n@@ -670,1 +659,1 @@\n-                src.getLineNumber(pos.getEndPosition(src.getEndPosTable())) == 1;\n+                src.getLineNumber(pos.getEndPosition()) == 1;\n@@ -684,1 +673,3 @@\n-        endPosTable.setErrorEndPos(errPos);\n+        if (errPos > errorEndPos) {\n+            errorEndPos = errPos;\n+        }\n@@ -689,1 +680,1 @@\n-     * last error position in {@link #endPosTable} and the given ending position.\n+     * {@link #errorEndPos} and the given ending position.\n@@ -695,1 +686,2 @@\n-        return endPosTable.storeEnd(tree, endpos);\n+        tree.endpos = Math.max(endpos, errorEndPos);\n+        return tree;\n@@ -700,1 +692,1 @@\n-     * will be the greater of last error position in {@link #endPosTable}\n+     * will be the greater of {@link #errorEndPos}\n@@ -710,1 +702,1 @@\n-     * will be the greater of last error position in {@link #endPosTable}\n+     * will be the greater of {@link #errorEndPos}\n@@ -736,1 +728,1 @@\n-        return endPosTable.getEndPos(tree);\n+        return tree.endpos;\n@@ -1272,1 +1264,1 @@\n-                                            endPosTable.replaceTree(decl, typeAnno);\n+                                            typeAnno.endpos = decl.endpos;\n@@ -1361,1 +1353,1 @@\n-                storeEnd(t, litBuf.last().getEndPosition(endPosTable));\n+                storeEnd(t, litBuf.last().getEndPosition());\n@@ -1657,1 +1649,1 @@\n-                        if (token.pos <= endPosTable.errorEndPos &&\n+                        if (token.pos <= errorEndPos &&\n@@ -1881,1 +1873,1 @@\n-                    if (token.pos <= endPosTable.errorEndPos &&\n+                    if (token.pos <= errorEndPos &&\n@@ -2536,1 +2528,1 @@\n-            if (token.pos == endPosTable.errorEndPos) {\n+            if (token.pos == errorEndPos) {\n@@ -2870,1 +2862,1 @@\n-                if (token.pos <= endPosTable.errorEndPos) {\n+                if (token.pos <= errorEndPos) {\n@@ -4048,1 +4040,1 @@\n-            if (token.pos <= endPosTable.errorEndPos) {\n+            if (token.pos <= errorEndPos) {\n@@ -4159,1 +4151,0 @@\n-        toplevel.endPositions = this.endPosTable;\n@@ -4579,1 +4570,1 @@\n-                if (token.pos <= endPosTable.errorEndPos) {\n+                if (token.pos <= errorEndPos) {\n@@ -4602,1 +4593,1 @@\n-                if (token.pos <= endPosTable.errorEndPos) {\n+                if (token.pos <= errorEndPos) {\n@@ -4699,1 +4690,1 @@\n-        if (token.pos <= endPosTable.errorEndPos) {\n+        if (token.pos <= errorEndPos) {\n@@ -4710,1 +4701,1 @@\n-            if (token.pos <= endPosTable.errorEndPos) {\n+            if (token.pos <= errorEndPos) {\n@@ -5070,1 +5061,1 @@\n-                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n+                unclosedParameterList = token.pos == errorEndPos;\n@@ -5096,1 +5087,1 @@\n-                if (token.pos <= endPosTable.errorEndPos) {\n+                if (token.pos <= errorEndPos) {\n@@ -5634,66 +5625,0 @@\n-\n-    \/**\n-     * A straightforward {@link EndPosTable} implementation.\n-     *\/\n-    protected static class SimpleEndPosTable extends AbstractEndPosTable {\n-\n-        private final IntHashTable endPosMap = new IntHashTable();\n-\n-        @Override\n-        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n-            endPosMap.put(tree, Math.max(endpos, errorEndPos));\n-            return tree;\n-        }\n-\n-        @Override\n-        public int getEndPos(JCTree tree) {\n-            int value = endPosMap.get(tree);\n-            \/\/ As long as Position.NOPOS==-1, this just returns value.\n-            return (value == -1) ? Position.NOPOS : value;\n-        }\n-\n-        @Override\n-        public int replaceTree(JCTree oldTree, JCTree newTree) {\n-            int pos = endPosMap.remove(oldTree);\n-            if (pos != -1 && newTree != null) {\n-                storeEnd(newTree, pos);\n-            }\n-            return pos;\n-        }\n-    }\n-\n-    \/**\n-     * A minimal implementation that only stores what's required.\n-     *\/\n-    protected static class MinimalEndPosTable extends SimpleEndPosTable {\n-\n-        @Override\n-        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n-            switch (tree.getTag()) {\n-            case MODULEDEF:\n-            case PACKAGEDEF:\n-            case CLASSDEF:\n-            case METHODDEF:\n-            case VARDEF:\n-                break;\n-            default:\n-                return tree;\n-            }\n-            return super.storeEnd(tree, endpos);\n-        }\n-    }\n-\n-    protected abstract static class AbstractEndPosTable implements EndPosTable {\n-\n-        \/**\n-         * Store the last error position.\n-         *\/\n-        public int errorEndPos = Position.NOPOS;\n-\n-        @Override\n-        public void setErrorEndPos(int errPos) {\n-            if (errPos > errorEndPos) {\n-                errorEndPos = errPos;\n-            }\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":26,"deletions":101,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -92,2 +92,2 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) {\n-        return newParser(input, keepDocComments, keepEndPos, keepLineMap, false);\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap) {\n+        return newParser(input, keepDocComments, keepLineMap, false);\n@@ -96,1 +96,1 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap, boolean parseModuleInfo) {\n@@ -98,1 +98,1 @@\n-        return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos, parseModuleInfo);\n+        return new JavacParser(this, lexer, keepDocComments, keepLineMap, parseModuleInfo);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-            public int getEndPosition(EndPosTable endPosTable) {\n+            public int getEndPosition() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.tree;\n-\n-import com.sun.tools.javac.util.Position;\n-\n-\/**\n- * Specifies the methods to access a mappings of syntax trees to end positions.\n- *\n- * <p>\n- * Implementations <b>must<\/b> store end positions for at least these node types:\n- * <ul>\n- *  <li>{@link JCTree.JCModuleDecl}\n- *  <li>{@link JCTree.JCPackageDecl}\n- *  <li>{@link JCTree.JCClassDecl}\n- *  <li>{@link JCTree.JCMethodDecl}\n- *  <li>{@link JCTree.JCVariableDecl}\n- * <\/ul>\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own\n- * risk.  This code and its internal interfaces are subject to change\n- * or deletion without notice.<\/b><\/p>\n- *\/\n-public interface EndPosTable {\n-\n-    \/**\n-     * This method will return the end position of a given tree, otherwise a\n-     * Positions.NOPOS will be returned.\n-     * @param tree JCTree\n-     * @return position of the source tree or Positions.NOPOS for non-existent mapping\n-     *\/\n-    int getEndPos(JCTree tree);\n-\n-    \/**\n-     * Store ending position for a tree, the value of which is the greater of\n-     * last error position and the given ending position.\n-     * @param tree The tree.\n-     * @param endpos The ending position to associate with the tree.\n-     * @return the {@code tree}\n-     *\/\n-    <T extends JCTree> T storeEnd(T tree, int endpos);\n-\n-    \/**\n-     * Set the error position during the parsing phases, the value of which\n-     * will be set only if it is greater than the last stored error position.\n-     * @param errPos The error position\n-     *\/\n-    void setErrorEndPos(int errPos);\n-\n-    \/**\n-     * Give an old tree and a new tree, the old tree will be replaced with\n-     * the new tree, the position of the new tree will be that of the old\n-     * tree.\n-     * @param oldtree a JCTree to be replaced\n-     * @param newtree a JCTree to be replaced with, or null to just remove {@code oldtree}\n-     * @return position of the old tree or Positions.NOPOS for non-existent mapping\n-     *\/\n-    int replaceTree(JCTree oldtree, JCTree newtree);\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/EndPosTable.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -434,0 +434,4 @@\n+    \/* The (encoded) end position in the source file. @see util.Position.\n+     *\/\n+    public int endpos = Position.NOPOS;\n+\n@@ -517,2 +521,2 @@\n-    public int getEndPosition(EndPosTable endPosTable) {\n-        return noNoPos(TreeInfo.getEndPos(this, endPosTable));\n+    public int getEndPosition() {\n+        return noNoPos(TreeInfo.getEndPos(this));\n@@ -555,3 +559,0 @@\n-        \/* An object encapsulating ending positions of source ranges indexed by\n-         * the tree nodes they belong to. Defined only if option -Xjcov is set. *\/\n-        public EndPosTable endPositions = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.comp.AttrContext;\n@@ -650,1 +649,1 @@\n-    public static int getEndPos(JCTree tree, EndPosTable endPosTable) {\n+    public static int getEndPos(JCTree tree) {\n@@ -654,6 +653,1 @@\n-        if (endPosTable == null) {\n-            \/\/ fall back on limited info in the tree\n-            return endPos(tree);\n-        }\n-\n-        int mapPos = endPosTable.getEndPos(tree);\n+        int mapPos = tree.endpos;\n@@ -681,1 +675,1 @@\n-                return getEndPos(((JCOperatorExpression) tree).getOperand(RIGHT), endPosTable);\n+                return getEndPos(((JCOperatorExpression) tree).getOperand(RIGHT));\n@@ -683,1 +677,1 @@\n-                return getEndPos(((JCCase) tree).stats.last(), endPosTable);\n+                return getEndPos(((JCCase) tree).stats.last());\n@@ -685,1 +679,1 @@\n-                return getEndPos(((JCCatch) tree).body, endPosTable);\n+                return getEndPos(((JCCatch) tree).body);\n@@ -687,1 +681,1 @@\n-                return getEndPos(((JCConditional) tree).falsepart, endPosTable);\n+                return getEndPos(((JCConditional) tree).falsepart);\n@@ -689,1 +683,1 @@\n-                return getEndPos(((JCForLoop) tree).body, endPosTable);\n+                return getEndPos(((JCForLoop) tree).body);\n@@ -691,1 +685,1 @@\n-                return getEndPos(((JCEnhancedForLoop) tree).body, endPosTable);\n+                return getEndPos(((JCEnhancedForLoop) tree).body);\n@@ -695,1 +689,1 @@\n-                    return getEndPos(node.thenpart, endPosTable);\n+                    return getEndPos(node.thenpart);\n@@ -697,1 +691,1 @@\n-                    return getEndPos(node.elsepart, endPosTable);\n+                    return getEndPos(node.elsepart);\n@@ -701,1 +695,1 @@\n-                return getEndPos(((JCLabeledStatement) tree).body, endPosTable);\n+                return getEndPos(((JCLabeledStatement) tree).body);\n@@ -703,1 +697,1 @@\n-                return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);\n+                return getEndPos(((JCModifiers) tree).annotations.last());\n@@ -705,1 +699,1 @@\n-                return getEndPos(((JCSynchronized) tree).body, endPosTable);\n+                return getEndPos(((JCSynchronized) tree).body);\n@@ -707,1 +701,1 @@\n-                return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);\n+                return getEndPos(((JCCompilationUnit) tree).defs.last());\n@@ -711,1 +705,1 @@\n-                    return getEndPos(node.finalizer, endPosTable);\n+                    return getEndPos(node.finalizer);\n@@ -713,1 +707,1 @@\n-                    return getEndPos(node.catchers.last(), endPosTable);\n+                    return getEndPos(node.catchers.last());\n@@ -715,1 +709,1 @@\n-                    return getEndPos(node.body, endPosTable);\n+                    return getEndPos(node.body);\n@@ -719,1 +713,1 @@\n-                return getEndPos(((JCWildcard) tree).inner, endPosTable);\n+                return getEndPos(((JCWildcard) tree).inner);\n@@ -721,1 +715,1 @@\n-                return getEndPos(((JCTypeCast) tree).expr, endPosTable);\n+                return getEndPos(((JCTypeCast) tree).expr);\n@@ -723,1 +717,1 @@\n-                return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);\n+                return getEndPos(((JCInstanceOf) tree).pattern);\n@@ -725,1 +719,1 @@\n-                return getEndPos(((JCWhileLoop) tree).body, endPosTable);\n+                return getEndPos(((JCWhileLoop) tree).body);\n@@ -727,1 +721,1 @@\n-                return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);\n+                return getEndPos(((JCAnnotatedType) tree).underlyingType);\n@@ -731,1 +725,1 @@\n-                    return getEndPos(node.errs.last(), endPosTable);\n+                    return getEndPos(node.errs.last());\n@@ -748,2 +742,2 @@\n-            public int getEndPosition(EndPosTable endPosTable) {\n-                return TreeInfo.getEndPos(tree, endPosTable);\n+            public int getEndPosition() {\n+                return TreeInfo.getEndPos(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -130,10 +129,0 @@\n-    public EndPosTable getEndPosTable() {\n-        return endPosTable;\n-    }\n-\n-    public void setEndPosTable(EndPosTable t) {\n-        if (endPosTable != null && endPosTable != t)\n-            throw new IllegalStateException(\"endPosTable already set\");\n-        endPosTable = t;\n-    }\n-\n@@ -200,2 +189,0 @@\n-    protected EndPosTable endPosTable;\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/DiagnosticSource.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-\/**\n- * A hash table that maps Object to int.\n- *\n- * This is a custom hash table optimised for the Object {@literal ->} int\n- * maps. This is done to avoid unnecessary object allocation in the image set.\n- *\n- * @author Charles Turner\n- * @author Per Bothner\n- *\/\n-public class IntHashTable {\n-    private static final int DEFAULT_INITIAL_SIZE = 64;\n-    protected Object[] objs; \/\/ the domain set\n-    protected int[] ints; \/\/ the image set\n-    protected int mask; \/\/ used to clip int's into the domain\n-    protected int num_bindings; \/\/ the number of mappings (including DELETED)\n-    private static final Object DELETED = new Object();\n-\n-    \/**\n-     * Construct an Object {@literal ->} int hash table.\n-     *\n-     * The default size of the hash table is 64 mappings.\n-     *\/\n-    public IntHashTable() {\n-        objs = new Object[DEFAULT_INITIAL_SIZE];\n-        ints = new int[DEFAULT_INITIAL_SIZE];\n-        mask = DEFAULT_INITIAL_SIZE - 1;\n-    }\n-\n-    \/**\n-     * Construct an Object {@literal ->} int hash table with a specified amount of mappings.\n-     * @param capacity The number of default mappings in this hash table.\n-     *\/\n-    public IntHashTable(int capacity) {\n-        int log2Size = 4;\n-        while (capacity > (1 << log2Size)) {\n-            log2Size++;\n-        }\n-        capacity = 1 << log2Size;\n-        objs = new Object[capacity];\n-        ints = new int[capacity];\n-        mask = capacity - 1;\n-    }\n-\n-    \/**\n-     * Compute the hash code of a given object.\n-     *\n-     * @param key The object whose hash code is to be computed.\n-     * @return zero if the object is null, otherwise the identityHashCode\n-     *\/\n-    protected int hash(Object key) {\n-        return System.identityHashCode(key);\n-    }\n-\n-    \/**\n-     * Find either the index of a key's value, or the index of an available space.\n-     *\n-     * @param key The key to whose index you want to find.\n-     * @return Either the index of the key's value, or an index pointing to\n-     * unoccupied space.\n-     *\/\n-    protected int lookup(Object key) {\n-        Object node;\n-        int hash = hash(key);\n-        int hash1 = hash ^ (hash >>> 15);\n-        int hash2 = (hash ^ (hash << 6)) | 1; \/\/ensure coprimeness\n-        int deleted = -1;\n-        for (int i = hash1 & mask;; i = (i + hash2) & mask) {\n-            node = objs[i];\n-            if (node == key)\n-                return i;\n-            if (node == null)\n-                return deleted >= 0 ? deleted : i;\n-            if (node == DELETED && deleted < 0)\n-                deleted = i;\n-        }\n-    }\n-\n-    \/**\n-     * Return the value to which the specified key is mapped.\n-     *\n-     * @param key The key to whose value you want to find.\n-     * @return A non-negative integer if the value is found.\n-     *         Otherwise, it is -1.\n-     *\/\n-    public int get(Object key) {\n-        int index = lookup(key);\n-        Object node = objs[index];\n-        return node == null || node == DELETED ? -1 : ints[index];\n-    }\n-\n-    \/**\n-     * Associates the specified key with the specified value in this map.\n-     *\n-     * @param key key with which the specified value is to be associated.\n-     * @param value value to be associated with the specified key.\n-     * @return previous value associated with specified key, or -1 if there was\n-     * no mapping for key.\n-     *\/\n-    public int put(Object key, int value) {\n-        int index = lookup(key);\n-        Object old = objs[index];\n-        if (old == null || old == DELETED) {\n-            objs[index] = key;\n-            ints[index] = value;\n-            if (old != DELETED)\n-                num_bindings++;\n-            if (3 * num_bindings >= 2 * objs.length)\n-                rehash();\n-            return -1;\n-        } else { \/\/ update existing mapping\n-            int oldValue = ints[index];\n-            ints[index] = value;\n-            return oldValue;\n-        }\n-    }\n-\n-    \/**\n-     * Remove the mapping(key and value) of the specified key.\n-     *\n-     * @param key the key to whose value you want to remove.\n-     * @return the removed value associated with the specified key,\n-     *         or -1 if there was no mapping for the specified key.\n-     *\/\n-    public int remove(Object key) {\n-        int index = lookup(key);\n-        Object old = objs[index];\n-        if (old == null || old == DELETED)\n-            return -1;\n-        objs[index] = DELETED;\n-        return ints[index];\n-    }\n-\n-    \/**\n-     * Expand the hash table when it exceeds the load factor.\n-     *\n-     * Rehash the existing objects.\n-     *\/\n-    protected void rehash() {\n-        Object[] oldObjsTable = objs;\n-        int[] oldIntsTable = ints;\n-        int newCapacity = oldObjsTable.length << 1;\n-        objs = new Object[newCapacity];\n-        ints = new int[newCapacity];\n-        mask = newCapacity - 1;\n-        num_bindings = 0; \/\/ this is recomputed below\n-        Object key;\n-        for (int i = oldIntsTable.length; --i >= 0;) {\n-            key = oldObjsTable[i];\n-            if (key != null && key != DELETED)\n-                put(key, oldIntsTable[i]);\n-        }\n-    }\n-\n-    \/**\n-     * Removes all mappings from this map.\n-     *\/\n-    public void clear() {\n-        for (int i = objs.length; --i >= 0;) {\n-            objs[i] = null;\n-        }\n-        num_bindings = 0;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/IntHashTable.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -367,4 +366,2 @@\n-        \/** If there is a tree node, and if endPositions are available, get\n-         *  the end position of the tree node. Otherwise, just returns the\n-         *  same as getPreferredPosition(). *\/\n-        int getEndPosition(EndPosTable endPosTable);\n+        \/** If there is a tree node, get the end position of the tree node. *\/\n+        int getEndPosition();\n@@ -392,2 +389,2 @@\n-                public int getEndPosition(EndPosTable endPosTable) {\n-                    return orig.getEndPosition(endPosTable);\n+                public int getEndPosition() {\n+                    return orig.getEndPosition();\n@@ -424,1 +421,1 @@\n-        public int getEndPosition(EndPosTable endPosTable) {\n+        public int getEndPosition() {\n@@ -750,1 +747,1 @@\n-        return (position == null ? Position.NOPOS : position.getEndPosition(source.getEndPosTable()));\n+        return (position == null ? Position.NOPOS : position.getEndPosition());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -597,5 +596,0 @@\n-    public void setEndPosTable(JavaFileObject name, EndPosTable endPosTable) {\n-        Assert.checkNonNull(name);\n-        getSource(name).setEndPosTable(endPosTable);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -619,1 +618,1 @@\n-            public int getEndPosition(EndPosTable endPosTable) {\n+            public int getEndPosition() {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocLog.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-            boolean keepEndPositions,\n@@ -80,1 +79,1 @@\n-        super(fac, S, keepDocComments, keepLineMap, keepEndPositions);\n+        super(fac, S, keepDocComments, keepLineMap);\n@@ -106,1 +105,1 @@\n-            if (token.pos > 0 && token.pos <= endPosTable.errorEndPos) {\n+            if (token.pos > 0 && token.pos <= errorEndPos) {\n@@ -144,1 +143,0 @@\n-        toplevel.endPositions = this.endPosTable;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParser.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) {\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap) {\n@@ -65,1 +65,1 @@\n-        return new ReplParser(this, lexer, keepDocComments, keepLineMap, keepEndPos, forceExpression);\n+        return new ReplParser(this, lexer, keepDocComments, keepLineMap, forceExpression);\n@@ -69,2 +69,2 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n-        return newParser(input, keepDocComments, keepEndPos, keepLineMap);\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap, boolean parseModuleInfo) {\n+        return newParser(input, keepDocComments, keepLineMap);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParserFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-        public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n+        public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap, boolean parseModuleInfo) {\n@@ -824,1 +824,1 @@\n-            return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos, parseModuleInfo) {\n+            return new JavacParser(this, lexer, keepDocComments, keepLineMap, parseModuleInfo) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -99,1 +98,0 @@\n-        log.setEndPosTable(fo, tree.endPositions);\n@@ -101,1 +99,1 @@\n-        TreeScanner ts = new LogTester(log, tree.endPositions);\n+        TreeScanner ts = new LogTester(log);\n@@ -120,1 +118,1 @@\n-        LogTester(Log log, EndPosTable endPosTable) {\n+        LogTester(Log log) {\n@@ -122,1 +120,0 @@\n-            this.endPosTable = endPosTable;\n@@ -141,1 +138,0 @@\n-        private EndPosTable endPosTable;\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,3 +121,10 @@\n-                d -> assertEquals(\"\", \/\/ideally would be \"0\", but the positions are not fully set yet\n-                                  implCode.substring((int) d.getStartPosition(),\n-                                                     (int) d.getEndPosition())),\n+                d -> {\n+                    \/\/ Use line and column instead of start and end positions\n+                    \/\/ to handle platform-dependent newlines, which could be\n+                    \/\/ different between the text block and the written file.\n+                    int line = (int) d.getLineNumber();\n+                    int col = (int) d.getColumnNumber();\n+                    assertEquals(1, d.getEndPosition() - d.getStartPosition());\n+                    String substring = implCode.split(\"\\\\R\")[line - 1].substring(col - 1, col);\n+                    assertEquals(\"0\", substring);\n+                },\n","filename":"test\/langtools\/tools\/javac\/diags\/DiagnosticGetEndPosition.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -370,2 +369,1 @@\n-                endPosTable = cut.endPositions;\n-                encl = new Info(tree, endPosTable);\n+                encl = new Info(tree);\n@@ -382,1 +380,1 @@\n-                Info self = new Info(tree, endPosTable);\n+                Info self = new Info(tree);\n@@ -457,1 +455,0 @@\n-            EndPosTable endPosTable;\n@@ -501,1 +498,1 @@\n-        Info(JCTree tree, EndPosTable endPosTable) {\n+        Info(JCTree tree) {\n@@ -506,1 +503,1 @@\n-            end = TreeInfo.getEndPos(tree, endPosTable);\n+            end = TreeInfo.getEndPos(tree);\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                    int end = TreeInfo.getEndPos(tree, unit.endPositions);\n+                    int end = TreeInfo.getEndPos(tree);\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                    int end = tree.getEndPosition(unit.endPositions);\n+                    int end = tree.getEndPosition();\n","filename":"test\/langtools\/tools\/javac\/parser\/ReversedSourcePositions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,3 +69,2 @@\n-            boolean keepLineMap,\n-            boolean keepEndPositions) {\n-        super(fac, S, keepDocComments, keepLineMap, keepEndPositions);\n+            boolean keepLineMap) {\n+        super(fac, S, keepDocComments, keepLineMap);\n@@ -105,1 +104,1 @@\n-            if (token.pos > 0 && token.pos <= endPosTable.errorEndPos) {\n+            if (token.pos > 0 && token.pos <= errorEndPos) {\n@@ -142,1 +141,0 @@\n-        toplevel.endPositions = this.endPosTable;\n","filename":"test\/langtools\/tools\/javac\/parser\/extend\/TrialParser.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap) {\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap) {\n@@ -53,1 +53,1 @@\n-        return new TrialParser(this, lexer, keepDocComments, keepLineMap, keepEndPos);\n+        return new TrialParser(this, lexer, keepDocComments, keepLineMap);\n@@ -57,2 +57,2 @@\n-    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n-        return newParser(input, keepDocComments, keepEndPos, keepLineMap);\n+    public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepLineMap, boolean parseModuleInfo) {\n+        return newParser(input, keepDocComments, keepLineMap);\n","filename":"test\/langtools\/tools\/javac\/parser\/extend\/TrialParserFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-                    int end = ((JCTree) tree).getEndPosition(unit.endPositions);\n+                    int end = ((JCTree) tree).getEndPosition();\n@@ -137,1 +137,1 @@\n-                    int end = ((JCTree) tree).getEndPosition(updated.endPositions);\n+                    int end = ((JCTree) tree).getEndPosition();\n","filename":"test\/langtools\/tools\/javac\/tree\/MissingSemicolonTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-import com.sun.tools.javac.tree.EndPosTable;\n@@ -350,1 +349,0 @@\n-            endPosTable = tree.endPositions;\n@@ -358,1 +356,1 @@\n-                                tree.endPositions.getEndPos(classDecl) == NOPOS;\n+                                classDecl.endpos == NOPOS;\n@@ -367,1 +365,1 @@\n-            Info self = new Info(tree, endPosTable);\n+            Info self = new Info(tree);\n@@ -507,1 +505,0 @@\n-        EndPosTable endPosTable;\n@@ -524,1 +521,1 @@\n-        Info(JCTree tree, EndPosTable endPosTable) {\n+        Info(JCTree tree) {\n@@ -529,1 +526,1 @@\n-            end = TreeInfo.getEndPos(tree, endPosTable);\n+            end = TreeInfo.getEndPos(tree);\n","filename":"test\/langtools\/tools\/javac\/tree\/TreePosTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}