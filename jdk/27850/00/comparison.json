{"files":[{"patch":"@@ -1844,0 +1844,9 @@\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  mv(t0, oopDesc::base_offset_in_bytes());\n+  bge(reg, t0, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -303,0 +303,2 @@\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -199,1 +200,5 @@\n-  \/\/ patch bytecode\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n@@ -3031,0 +3036,1 @@\n+  __ verify_field_offset(x11);\n@@ -3118,0 +3124,2 @@\n+  __ verify_field_offset(x11);\n+\n@@ -3173,0 +3181,1 @@\n+\n@@ -3174,0 +3183,1 @@\n+  __ verify_field_offset(x11);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}