{"files":[{"patch":"@@ -297,10 +297,0 @@\n-\n-        ThrowingConsumer<Path, IOException> createBulkFile = path -> {\n-            Files.createDirectories(path.getParent());\n-            try (FileOutputStream out = new FileOutputStream(path.toFile())) {\n-                byte[] bytes = new byte[4 * 1024];\n-                new SecureRandom().nextBytes(bytes);\n-                out.write(bytes);\n-            }\n-        };\n-\n@@ -308,17 +298,1 @@\n-            Path fakeRuntimeDir = TKit.createTempDirectory(\"fake_runtime\");\n-\n-            TKit.trace(String.format(\"Init fake runtime in [%s] directory\",\n-                    fakeRuntimeDir));\n-\n-            if (TKit.isOSX()) {\n-                \/\/ Make MacAppImageBuilder happy\n-                createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(\n-                        \"lib\/jli\/libjli.dylib\")));\n-            }\n-\n-            \/\/ Make sure fake runtime takes some disk space.\n-            \/\/ Package bundles with 0KB size are unexpected and considered\n-            \/\/ an error by PackageTest.\n-            createBulkFile.accept(fakeRuntimeDir.resolve(Path.of(\"lib\", \"bulk\")));\n-\n-            cmd.setArgumentValue(\"--runtime-image\", fakeRuntimeDir);\n+            cmd.setArgumentValue(\"--runtime-image\", createInputRuntimeImage(RuntimeImageType.RUNTIME_TYPE_FAKE));\n@@ -393,0 +367,15 @@\n+    public enum RuntimeImageType {\n+\n+        \/**\n+         * Runtime suitable for running the default \"Hello\" test app.\n+         *\/\n+        RUNTIME_TYPE_HELLO_APP,\n+\n+        \/**\n+         * Fake runtime.\n+         *\/\n+        RUNTIME_TYPE_FAKE,\n+\n+        ;\n+    }\n+\n@@ -394,0 +383,5 @@\n+        return createInputRuntimeImage(RuntimeImageType.RUNTIME_TYPE_HELLO_APP);\n+    }\n+\n+    public static Path createInputRuntimeImage(RuntimeImageType role) {\n+        Objects.requireNonNull(role);\n@@ -396,0 +390,1 @@\n+        switch (role) {\n@@ -397,14 +392,46 @@\n-        if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n-            runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n-        } else {\n-            runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n-\n-            new Executor().setToolProvider(JavaTool.JLINK)\n-                    .dumpOutput()\n-                    .addArguments(\n-                            \"--output\", runtimeImageDir.toString(),\n-                            \"--add-modules\", \"java.desktop\",\n-                            \"--strip-debug\",\n-                            \"--no-header-files\",\n-                            \"--no-man-pages\")\n-                    .execute();\n+            case RUNTIME_TYPE_FAKE -> {\n+                Consumer<Path> createBulkFile = ThrowingConsumer.toConsumer(path -> {\n+                    Files.createDirectories(path.getParent());\n+                    try (FileOutputStream out = new FileOutputStream(path.toFile())) {\n+                        byte[] bytes = new byte[4 * 1024];\n+                        new SecureRandom().nextBytes(bytes);\n+                        out.write(bytes);\n+                    }\n+                });\n+\n+                runtimeImageDir = TKit.createTempDirectory(\"fake_runtime\");\n+\n+                TKit.trace(String.format(\"Init fake runtime in [%s] directory\", runtimeImageDir));\n+\n+                if (TKit.isOSX()) {\n+                    \/\/ Make MacAppImageBuilder happy\n+                    createBulkFile.accept(runtimeImageDir.resolve(Path.of(\"lib\/jli\/libjli.dylib\")));\n+                }\n+\n+                \/\/ Make sure fake runtime takes some disk space.\n+                \/\/ Package bundles with 0KB size are unexpected and considered\n+                \/\/ an error by PackageTest.\n+                createBulkFile.accept(runtimeImageDir.resolve(Path.of(\"lib\", \"bulk\")));\n+            }\n+\n+            case RUNTIME_TYPE_HELLO_APP -> {\n+                if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null && !isFakeRuntime(DEFAULT_RUNTIME_IMAGE)) {\n+                    runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n+                } else {\n+                    runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n+\n+                    new Executor().setToolProvider(JavaTool.JLINK)\n+                            .dumpOutput()\n+                            .addArguments(\n+                                    \"--output\", runtimeImageDir.toString(),\n+                                    \"--add-modules\", \"java.desktop\",\n+                                    \"--strip-debug\",\n+                                    \"--no-header-files\",\n+                                    \"--no-man-pages\")\n+                            .execute();\n+                }\n+            }\n+\n+            default -> {\n+                throw ExceptionBox.reachedUnreachable();\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":68,"deletions":41,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.security.cert.X509Certificate;\n@@ -69,0 +70,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n@@ -78,0 +80,2 @@\n+import jdk.jpackage.test.MacSign.CertificateType;\n+import jdk.jpackage.test.MacSign.ResolvedKeychain;\n@@ -433,0 +437,32 @@\n+    public static final class RuntimeBundleBuilder {\n+\n+        public Path create() {\n+            return createRuntimeBundle(type, Optional.ofNullable(mutator));\n+        }\n+\n+        public RuntimeBundleBuilder type(JPackageCommand.RuntimeImageType v) {\n+            type = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        public RuntimeBundleBuilder mutator(Consumer<JPackageCommand> v) {\n+            mutator = v;\n+            return this;\n+        }\n+\n+        public RuntimeBundleBuilder mutate(Consumer<RuntimeBundleBuilder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        private RuntimeBundleBuilder() {\n+        }\n+\n+        private JPackageCommand.RuntimeImageType type = JPackageCommand.RuntimeImageType.RUNTIME_TYPE_HELLO_APP;\n+        private Consumer<JPackageCommand> mutator;\n+    };\n+\n+    public static RuntimeBundleBuilder buildRuntimeBundle() {\n+        return new RuntimeBundleBuilder();\n+    }\n+\n@@ -434,1 +470,1 @@\n-        return createRuntimeBundle(Optional.of(mutator));\n+        return buildRuntimeBundle().mutator(Objects.requireNonNull(mutator)).create();\n@@ -438,1 +474,1 @@\n-        return createRuntimeBundle(Optional.empty());\n+        return buildRuntimeBundle().create();\n@@ -441,1 +477,1 @@\n-    public static Path createRuntimeBundle(Optional<Consumer<JPackageCommand>> mutator) {\n+    private static Path createRuntimeBundle(JPackageCommand.RuntimeImageType type, Optional<Consumer<JPackageCommand>> mutator) {\n@@ -444,1 +480,1 @@\n-        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n+        final var runtimeImage = JPackageCommand.createInputRuntimeImage(type);\n@@ -498,1 +534,88 @@\n-    public record SignKeyOption(Type type, CertificateRequest certRequest) {\n+    public static final class ResolvableCertificateRequest {\n+\n+        public ResolvableCertificateRequest(\n+                CertificateRequest certRequest,\n+                Function<CertificateRequest, X509Certificate> certResolver,\n+                String label) {\n+\n+            Objects.requireNonNull(certRequest);\n+            Objects.requireNonNull(certResolver);\n+            Objects.requireNonNull(label);\n+            if (label.isBlank()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.certRequest = certRequest;\n+            this.certResolver = certResolver;\n+            this.label = label;\n+        }\n+\n+        public ResolvableCertificateRequest(\n+                CertificateRequest certRequest,\n+                ResolvedKeychain keychain,\n+                String label) {\n+            this(certRequest, keychain.asCertificateResolver(), label);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return label;\n+        }\n+\n+        public CertificateRequest certRequest() {\n+            return certRequest;\n+        }\n+\n+        public X509Certificate cert() {\n+            return certResolver.apply(certRequest);\n+        }\n+\n+        public CertificateType type() {\n+            return certRequest.type();\n+        }\n+\n+        public String name() {\n+            return certRequest.name();\n+        }\n+\n+        public String shortName() {\n+            return certRequest.shortName();\n+        }\n+\n+        public int days() {\n+            return certRequest.days();\n+        }\n+\n+        public boolean expired() {\n+            return certRequest.expired();\n+        }\n+\n+        public boolean trusted() {\n+            return certRequest.trusted();\n+        }\n+\n+        private final CertificateRequest certRequest;\n+        private final Function<CertificateRequest, X509Certificate> certResolver;\n+        private final String label;\n+    }\n+\n+    public interface NamedCertificateRequestSupplier {\n+\n+        String name();\n+\n+        CertificateRequest certRequest();\n+\n+        default ResolvableCertificateRequest certRequest(ResolvedKeychain keychain) {\n+            Objects.requireNonNull(keychain);\n+            var certRequest = Objects.requireNonNull(certRequest());\n+            if (keychain.spec().certificateRequests().contains(certRequest)) {\n+                return new ResolvableCertificateRequest(certRequest, keychain.asCertificateResolver(), name());\n+            } else {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Certificate request %s not found in [%s] keychain\",\n+                        name(), keychain.spec().keychain().name()));\n+            }\n+        }\n+    }\n+\n+    public record SignKeyOption(Type type, ResolvableCertificateRequest certRequest, Optional<String> customOptionValue) {\n@@ -503,0 +626,49 @@\n+            Objects.requireNonNull(customOptionValue);\n+            if (customOptionValue.isEmpty() == (type == Type.SIGN_KEY_USER_NAME)) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        public SignKeyOption(Type type, ResolvableCertificateRequest certRequest) {\n+            this(type, certRequest, Optional.empty());\n+        }\n+\n+        public SignKeyOption(\n+                Type type,\n+                NamedCertificateRequestSupplier certRequestSupplier,\n+                ResolvedKeychain keychain) {\n+\n+            this(type, certRequestSupplier.certRequest(keychain));\n+        }\n+\n+        public SignKeyOption(String optionValue, ResolvableCertificateRequest certRequest) {\n+            this(Type.SIGN_KEY_USER_NAME, certRequest, Optional.of(optionValue));\n+        }\n+\n+        public SignKeyOption(\n+                String optionValue,\n+                NamedCertificateRequestSupplier certRequestSupplier,\n+                ResolvedKeychain keychain) {\n+\n+            this(optionValue, certRequestSupplier.certRequest(keychain));\n+        }\n+\n+        public enum Name {\n+            KEY_USER_NAME(\"--mac-signing-key-user-name\"),\n+            KEY_IDENTITY_APP_IMAGE(\"--mac-app-image-sign-identity\"),\n+            KEY_IDENTITY_INSTALLER(\"--mac-installer-sign-identity\"),\n+            ;\n+\n+            Name(String optionName) {\n+                this.optionName = Objects.requireNonNull(optionName);\n+            }\n+\n+            public String optionName() {\n+                return optionName;\n+            }\n+\n+            public boolean passThrough() {\n+                return this != KEY_USER_NAME;\n+            }\n+\n+            private final String optionName;\n@@ -506,2 +678,39 @@\n-            SIGN_KEY_USER_NAME,\n-            SIGN_KEY_IDENTITY,\n+            \/**\n+             * \"--mac-signing-key-user-name\" option with custom value\n+             *\/\n+            SIGN_KEY_USER_NAME(Name.KEY_USER_NAME),\n+\n+            \/**\n+             * \"--mac-signing-key-user-name\" option with the short user name, e.g.:\n+             * {@code --mac-signing-key-user-name foo}\n+             *\/\n+            SIGN_KEY_USER_SHORT_NAME(Name.KEY_USER_NAME),\n+\n+            \/**\n+             * \"--mac-signing-key-user-name\" option with the full user name (aka signing\n+             * identity name), e.g.:\n+             * {@code --mac-signing-key-user-name 'Developer ID Application: foo'}\n+             *\/\n+            SIGN_KEY_USER_FULL_NAME(Name.KEY_USER_NAME),\n+\n+            \/**\n+             * \"--mac-installer-sign-identity\" or \"--mac-app-image-sign-identity\" option\n+             * with the signing identity name, e.g.:\n+             * {@code --mac-app-image-sign-identity 'Developer ID Application: foo'}\n+             *\/\n+            SIGN_KEY_IDENTITY(Map.of(\n+                    MacSign.CertificateType.CODE_SIGN, Name.KEY_IDENTITY_APP_IMAGE,\n+                    MacSign.CertificateType.INSTALLER, Name.KEY_IDENTITY_INSTALLER)),\n+\n+            \/**\n+             * \"--mac-app-image-sign-identity\" regardless of the type of signing identity\n+             * (for signing app image or .pkg installer).\n+             *\/\n+            SIGN_KEY_IDENTITY_APP_IMAGE(Name.KEY_IDENTITY_APP_IMAGE),\n+\n+            \/**\n+             * \"--mac-installer-sign-identity\" regardless of the type of signing identity\n+             * (for signing app image or .pkg installer).\n+             *\/\n+            SIGN_KEY_IDENTITY_INSTALLER(Name.KEY_IDENTITY_INSTALLER),\n+\n@@ -509,0 +718,30 @@\n+\n+            Type(Map<MacSign.CertificateType, Name> optionNameMap) {\n+                Objects.requireNonNull(optionNameMap);\n+                this.optionNameMapper = certType -> {\n+                    return Optional.of(optionNameMap.get(certType));\n+                };\n+            }\n+\n+            Type(Name optionName) {\n+                Objects.requireNonNull(optionName);\n+                this.optionNameMapper = _ -> Optional.of(optionName);\n+            }\n+\n+            Type() {\n+                this.optionNameMapper = _ -> Optional.empty();\n+            }\n+\n+            public Optional<Name> mapOptionName(MacSign.CertificateType certType) {\n+                return optionNameMapper.apply(Objects.requireNonNull(certType));\n+            }\n+\n+            public static Type[] defaultValues() {\n+                return new Type[] {\n+                        SIGN_KEY_USER_SHORT_NAME,\n+                        SIGN_KEY_USER_FULL_NAME,\n+                        SIGN_KEY_IDENTITY\n+                };\n+            }\n+\n+            private final Function<MacSign.CertificateType, Optional<Name>> optionNameMapper;\n@@ -514,0 +753,1 @@\n+            sb.append('{');\n@@ -515,1 +755,15 @@\n-                sb.append(String.format(\"{%s: %s}\", optionName, certRequest));\n+                sb.append(optionName);\n+                switch (type) {\n+                    case SIGN_KEY_USER_FULL_NAME -> {\n+                        sb.append(\"\/full\");\n+                    }\n+                    case SIGN_KEY_USER_NAME -> {\n+                        customOptionValue.ifPresent(optionValue -> {\n+                            sb.append(\"=\").append(ENQUOTER.applyTo(optionValue));\n+                        });\n+                    }\n+                    default -> {\n+                        \/\/ NOP\n+                    }\n+                }\n+                sb.append(\": \");\n@@ -517,0 +771,1 @@\n+            sb.append(certRequest).append('}');\n@@ -530,0 +785,9 @@\n+        public List<String> asCmdlineArgs() {\n+            String[] args = new String[2];\n+            applyTo((optionName, optionValue) -> {\n+                args[0] = optionName;\n+                args[1] = optionValue;\n+            });\n+            return List.of(args);\n+        }\n+\n@@ -531,11 +795,13 @@\n-            switch (certRequest.type()) {\n-                case INSTALLER -> {\n-                    switch (type) {\n-                        case SIGN_KEY_IDENTITY -> {\n-                            sink.accept(\"--mac-installer-sign-identity\", certRequest.name());\n-                            return;\n-                        }\n-                        case SIGN_KEY_USER_NAME -> {\n-                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n-                            return;\n-                        }\n+            type.mapOptionName(certRequest.type()).ifPresent(optionName -> {\n+                sink.accept(optionName.optionName(), optionValue());\n+            });\n+        }\n+\n+        private String optionValue() {\n+            return customOptionValue.orElseGet(() -> {\n+                switch (type) {\n+                    case    SIGN_KEY_IDENTITY,\n+                            SIGN_KEY_USER_FULL_NAME,\n+                            SIGN_KEY_IDENTITY_APP_IMAGE,\n+                            SIGN_KEY_IDENTITY_INSTALLER -> {\n+                        return certRequest.name();\n@@ -543,11 +809,5 @@\n-                }\n-                case CODE_SIGN -> {\n-                    switch (type) {\n-                        case SIGN_KEY_IDENTITY -> {\n-                            sink.accept(\"--mac-app-image-sign-identity\", certRequest.name());\n-                            return;\n-                        }\n-                        case SIGN_KEY_USER_NAME -> {\n-                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n-                            return;\n-                        }\n+                    case SIGN_KEY_USER_SHORT_NAME -> {\n+                        return certRequest.shortName();\n+                    }\n+                    default -> {\n+                        throw new IllegalStateException();\n@@ -556,1 +816,45 @@\n-            }\n+            });\n+        }\n+\n+        private static final Enquoter ENQUOTER = Enquoter.identity()\n+                .setEnquotePredicate(Enquoter.QUOTE_IF_WHITESPACES).setQuoteChar('\\'');\n+    }\n+\n+    public record SignKeyOptionWithKeychain(SignKeyOption signKeyOption, ResolvedKeychain keychain) {\n+\n+        public SignKeyOptionWithKeychain {\n+            Objects.requireNonNull(signKeyOption);\n+            Objects.requireNonNull(keychain);\n+        }\n+\n+        public SignKeyOptionWithKeychain(\n+                SignKeyOption.Type type,\n+                ResolvableCertificateRequest certRequest,\n+                ResolvedKeychain keychain) {\n+\n+            this(new SignKeyOption(type, certRequest), keychain);\n+        }\n+\n+        public SignKeyOptionWithKeychain(\n+                SignKeyOption.Type type,\n+                NamedCertificateRequestSupplier certRequestSupplier,\n+                ResolvedKeychain keychain) {\n+\n+            this(type, certRequestSupplier.certRequest(keychain), keychain);\n+        }\n+\n+        public SignKeyOptionWithKeychain(\n+                String optionValue,\n+                ResolvableCertificateRequest certRequest,\n+                ResolvedKeychain keychain) {\n+\n+            this(new SignKeyOption(optionValue, certRequest), keychain);\n+        }\n+\n+        public SignKeyOptionWithKeychain(\n+                String optionValue,\n+                NamedCertificateRequestSupplier certRequestSupplier,\n+                ResolvedKeychain keychain) {\n+\n+            this(optionValue, certRequestSupplier.certRequest(keychain), keychain);\n+        }\n@@ -558,1 +862,44 @@\n-            throw new AssertionError();\n+        public SignKeyOptionWithKeychain(\n+                SignKeyOption.Type type,\n+                CertificateRequest certRequest,\n+                ResolvedKeychain keychain) {\n+\n+            this(new SignKeyOption(\n+                    type,\n+                    new ResolvableCertificateRequest(\n+                            certRequest,\n+                            keychain.asCertificateResolver(),\n+                            certRequest.toString())),\n+                    keychain);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s@%s\", signKeyOption, keychain.name());\n+        }\n+\n+        public SignKeyOption.Type type() {\n+            return signKeyOption.type();\n+        }\n+\n+        public ResolvableCertificateRequest certRequest() {\n+            return signKeyOption.certRequest();\n+        }\n+\n+        public JPackageCommand addTo(JPackageCommand cmd) {\n+            Optional.ofNullable(cmd.getArgumentValue(\"--mac-signing-keychain\")).ifPresentOrElse(configuredKeychain -> {\n+                if (!configuredKeychain.equals(keychain.name())) {\n+                    throw new IllegalStateException(String.format(\n+                            \"Command line [%s] already has the '--mac-signing-keychain' option, not adding another one with [%s] value\",\n+                            cmd, keychain.name()));\n+                }\n+            }, () -> {\n+                useKeychain(cmd, keychain);\n+            });\n+            return signKeyOption.addTo(cmd);\n+        }\n+\n+        public JPackageCommand setTo(JPackageCommand cmd) {\n+            cmd.removeArgumentWithValue(\"--mac-signing-keychain\");\n+            useKeychain(cmd, keychain);\n+            return signKeyOption.setTo(cmd);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":379,"deletions":32,"binary":false,"changes":411,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.util.function.Function;\n@@ -1135,0 +1136,12 @@\n+        public Function<CertificateRequest, X509Certificate> asCertificateResolver() {\n+            return certRequest -> {\n+                if (!spec.certificateRequests().contains(certRequest)) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Certificate request %s not found in [%s] keychain\",\n+                            certRequest, name()));\n+                } else {\n+                    return Objects.requireNonNull(mapCertificateRequests().get(certRequest));\n+                }\n+            };\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.test.MacHelper.ResolvableCertificateRequest;\n@@ -44,2 +45,1 @@\n-    public static void verifyAppImageSigned(\n-            JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+    public static void verifyAppImageSigned(JPackageCommand cmd, ResolvableCertificateRequest certRequest) {\n@@ -47,1 +47,1 @@\n-        cmd.verifyIsOfType(PackageType.MAC);\n+        cmd.verifyIsOfType(PackageType.MAC_DMG, PackageType.MAC_PKG, PackageType.IMAGE);\n@@ -49,1 +49,0 @@\n-        Objects.requireNonNull(keychain);\n@@ -73,1 +72,1 @@\n-    public static void verifyPkgSigned(JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+    public static void verifyPkgSigned(JPackageCommand cmd, ResolvableCertificateRequest certRequest) {\n@@ -75,2 +74,1 @@\n-        assertPkgSigned(cmd.outputBundle(), certRequest,\n-                Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest)));\n+        assertPkgSigned(cmd.outputBundle(), certRequest);\n@@ -79,1 +77,1 @@\n-    public static void assertSigned(Path path, CertificateRequest certRequest) {\n+    public static void assertSigned(Path path, ResolvableCertificateRequest certRequest) {\n@@ -111,0 +109,4 @@\n+    public static void assertPkgSigned(Path path, ResolvableCertificateRequest certRequest) {\n+        assertPkgSigned(path, certRequest.certRequest(), certRequest.cert());\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,0 @@\n- * @library base\n- * @build SigningBase\n@@ -62,1 +60,2 @@\n- * @build EntitlementsTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror EntitlementsTest.java\n@@ -145,1 +144,2 @@\n-                SigningBase.StandardCertificateRequest.CODESIGN.spec()\n+                SigningBase.StandardCertificateRequest.CODESIGN,\n+                keychain\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/EntitlementsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,5 @@\n+import static jdk.jpackage.test.MacHelper.SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+import static jdk.jpackage.test.MacHelper.SignKeyOption.Type.SIGN_KEY_USER_FULL_NAME;\n+import static jdk.jpackage.test.MacHelper.SignKeyOption.Type.SIGN_KEY_USER_SHORT_NAME;\n+import static jdk.jpackage.test.MacHelper.SignKeyOption.Type.SIGN_KEY_IDENTITY_APP_IMAGE;\n+\n@@ -29,1 +34,0 @@\n-import java.util.Objects;\n@@ -40,0 +44,4 @@\n+import jdk.jpackage.test.MacHelper.NamedCertificateRequestSupplier;\n+import jdk.jpackage.test.MacHelper.ResolvableCertificateRequest;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacHelper.SignKeyOptionWithKeychain;\n@@ -41,1 +49,0 @@\n-import jdk.jpackage.test.MacSign.CertificateRequest;\n@@ -51,2 +58,0 @@\n- * @library base\n- * @build SigningBase\n@@ -54,1 +59,2 @@\n- * @build MacSignTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror MacSignTest.java\n@@ -82,0 +88,6 @@\n+\n+            var signingKeyOption = new SignKeyOptionWithKeychain(\n+                    SIGN_KEY_IDENTITY,\n+                    SigningBase.StandardCertificateRequest.CODESIGN,\n+                    keychain);\n+\n@@ -86,1 +98,1 @@\n-            final var cmd = JPackageCommand.helloAppImage()\n+            JPackageCommand.helloAppImage()\n@@ -90,6 +102,7 @@\n-                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n-\n-            if (MacHelper.isXcodeDevToolsInstalled()) {\n-                \/\/ Check there is no warning about missing xcode command line developer tools.\n-                cmd.validateOutput(TKit.assertTextStream(xcodeWarning.getValue()).negate());\n-            }\n+                    .mutate(signingKeyOption::addTo)\n+                    .mutate(cmd -> {\n+                        if (MacHelper.isXcodeDevToolsInstalled()) {\n+                            \/\/ Check there is no warning about missing xcode command line developer tools.\n+                            cmd.validateOutput(TKit.assertTextStream(xcodeWarning.getValue()).negate());\n+                        }\n+                    }).execute(1);\n@@ -97,1 +110,0 @@\n-            MacHelper.useKeychain(cmd, keychain).execute(1);\n@@ -119,1 +131,7 @@\n-            final var cmd = new JPackageCommand().setPackageType(PackageType.IMAGE)\n+\n+            var signingKeyOption = new SignKeyOptionWithKeychain(\n+                    SIGN_KEY_IDENTITY,\n+                    SigningBase.StandardCertificateRequest.CODESIGN,\n+                    keychain);\n+\n+            new JPackageCommand().setPackageType(PackageType.IMAGE)\n@@ -123,1 +141,2 @@\n-                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n+                    .mutate(signingKeyOption::addTo)\n+                    .execute(1);\n@@ -125,1 +144,0 @@\n-            MacHelper.useKeychain(cmd, keychain).execute(1);\n@@ -192,1 +210,1 @@\n-    public static void testSelectSigningIdentity(String signingKeyUserName, CertificateRequest certRequest) {\n+    public static void testSelectSigningIdentity(SignKeyOptionWithKeychain signKeyOption) {\n@@ -195,3 +213,1 @@\n-            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n-                    .setFakeRuntime()\n-                    .addArguments(\"--mac-signing-key-user-name\", signingKeyUserName);\n+            final var cmd = JPackageCommand.helloAppImage().setFakeRuntime().mutate(signKeyOption::addTo);\n@@ -199,1 +215,1 @@\n-            cmd.executeAndAssertHelloAppImageCreated();\n+            cmd.executeAndAssertImageCreated();\n@@ -201,1 +217,1 @@\n-            MacSignVerify.assertSigned(cmd.outputBundle(), certRequest);\n+            MacSignVerify.verifyAppImageSigned(cmd, signKeyOption.certRequest());\n@@ -206,0 +222,1 @@\n+        var keychain = SigningBase.StandardKeychain.MAIN.keychain();\n@@ -209,3 +226,9 @@\n-        ).map(SigningBase.StandardCertificateRequest::spec).<Object[]>mapMulti((certRequest, acc) -> {\n-            acc.accept(new Object[] {certRequest.shortName(), certRequest});\n-            acc.accept(new Object[] {certRequest.name(), certRequest});\n+        ).map(certRequest -> {\n+            return Stream.of(\n+                    SIGN_KEY_USER_FULL_NAME,\n+                    SIGN_KEY_USER_SHORT_NAME\n+            ).map(type -> {\n+                return new SignKeyOptionWithKeychain(type, certRequest, keychain);\n+            });\n+        }).flatMap(x -> x).map(v -> {\n+            return new Object[] {v};\n@@ -217,1 +240,4 @@\n-                \"ACME Technologies Limited\", SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD.spec()\n+                new SignKeyOptionWithKeychain(\n+                        \"ACME Technologies Limited\",\n+                        SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD,\n+                        SigningBase.StandardKeychain.MAIN.keychain())\n@@ -222,15 +248,14 @@\n-        EXPIRED_SIGNING_KEY_USER_NAME(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), true, false),\n-        EXPIRED_SIGNING_KEY_USER_NAME_PKG(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.PKG_EXPIRED.spec(), true, false),\n-        EXPIRED_SIGN_IDENTITY(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), false, false),\n-        EXPIRED_CODESIGN_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), false, true),\n-        EXPIRED_PKG_SIGN_IDENTITY(\"--mac-installer-sign-identity\", SigningBase.StandardCertificateRequest.PKG_EXPIRED.spec(), false, true),\n-        GOOD_SIGNING_KEY_USER_NAME(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN.spec(), true, false),\n-        GOOD_SIGNING_KEY_USER_NAME_PKG(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.PKG.spec(), true, false),\n-        GOOD_CODESIGN_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec(), false, true),\n-        GOOD_PKG_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.PKG.spec(), false, true);\n-\n-        SignOption(String option, MacSign.CertificateRequest cert, boolean shortName, boolean passThrough) {\n-            this.option = Objects.requireNonNull(option);\n-            this.cert = Objects.requireNonNull(cert);\n-            this.shortName = shortName;\n-            this.passThrough = passThrough;\n+        EXPIRED_SIGNING_KEY_USER_NAME(SIGN_KEY_USER_SHORT_NAME, SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED),\n+        EXPIRED_SIGNING_KEY_USER_NAME_PKG(SIGN_KEY_USER_SHORT_NAME, SigningBase.StandardCertificateRequest.PKG_EXPIRED),\n+        EXPIRED_SIGN_IDENTITY(SIGN_KEY_USER_FULL_NAME, SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED),\n+        EXPIRED_CODESIGN_SIGN_IDENTITY(SIGN_KEY_IDENTITY, SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED),\n+        EXPIRED_PKG_SIGN_IDENTITY(SIGN_KEY_IDENTITY, SigningBase.StandardCertificateRequest.PKG_EXPIRED),\n+        GOOD_SIGNING_KEY_USER_NAME(SIGN_KEY_USER_SHORT_NAME, SigningBase.StandardCertificateRequest.CODESIGN),\n+        GOOD_SIGNING_KEY_USER_NAME_PKG(SIGN_KEY_USER_SHORT_NAME, SigningBase.StandardCertificateRequest.PKG),\n+        GOOD_CODESIGN_SIGN_IDENTITY(SIGN_KEY_IDENTITY, SigningBase.StandardCertificateRequest.CODESIGN),\n+        GOOD_PKG_SIGN_IDENTITY(SIGN_KEY_IDENTITY_APP_IMAGE, SigningBase.StandardCertificateRequest.PKG);\n+\n+        SignOption(SignKeyOption.Type optionType, NamedCertificateRequestSupplier certRequestSupplier) {\n+            this.option = new SignKeyOption(optionType, new ResolvableCertificateRequest(certRequestSupplier.certRequest(), _ -> {\n+                throw new UnsupportedOperationException();\n+            }, certRequestSupplier.name()));\n@@ -240,1 +265,1 @@\n-            return passThrough;\n+            return option.type().mapOptionName(option.certRequest().type()).orElseThrow().passThrough();\n@@ -244,1 +269,1 @@\n-            return cert.expired();\n+            return option.certRequest().expired();\n@@ -248,1 +273,1 @@\n-            return cert.name();\n+            return option.certRequest().name();\n@@ -252,1 +277,1 @@\n-            return cert.type();\n+            return option.certRequest().type();\n@@ -256,1 +281,1 @@\n-            return List.of(option, shortName ? cert.shortName() : cert.name());\n+            return option.asCmdlineArgs();\n@@ -277,4 +302,1 @@\n-        private final String option;\n-        private final MacSign.CertificateRequest cert;\n-        private final boolean shortName;\n-        private final boolean passThrough;\n+        private final SignKeyOption option;\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":73,"deletions":51,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,3 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n@@ -28,1 +28,1 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -31,0 +31,2 @@\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacHelper.SignKeyOptionWithKeychain;\n@@ -32,0 +34,1 @@\n+import jdk.jpackage.test.MacSignVerify;\n@@ -34,11 +37,6 @@\n- * Tests generation of app image with --mac-sign and related arguments. Test will\n- * generate app image and verify signature of main launcher and app bundle itself.\n- * This test requires that machine is configured with test certificate for\n- * \"Developer ID Application: jpackage.openjdk.java.net\" or alternately\n- * \"Developer ID Application: \" + name specified by system property:\n- * \"jpackage.mac.signing.key.user.name\"\n- * in the jpackagerTest keychain (or alternately the keychain specified with\n- * the system property \"jpackage.mac.signing.keychain\".\n- * If this certificate is self-signed, it must have be set to\n- * always allowed access to this keychain\" for user which runs test.\n- * (If cert is real (not self signed), the do not set trust to allow.)\n+ * Tests signing of an app image.\n+ *\n+ * <p>\n+ * Prerequisites: Keychains with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN} and\n+ * {@link SigningBase.StandardKeychain#SINGLE}.\n@@ -51,2 +49,0 @@\n- * @library base\n- * @build SigningBase\n@@ -54,1 +50,2 @@\n- * @build SigningAppImageTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningAppImageTest.java\n@@ -56,1 +53,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n@@ -63,14 +60,2 @@\n-    \/\/ ({\"sign or not\", \"signing-key or sign-identity\", \"certificate index\"})\n-    \/\/ Sign, signing-key and ASCII certificate\n-    @Parameter({\"true\", \"true\", \"ASCII_INDEX\"})\n-    \/\/ Sign, signing-key and UNICODE certificate\n-    @Parameter({\"true\", \"true\", \"UNICODE_INDEX\"})\n-    \/\/ Sign, signing-indentity and UNICODE certificate\n-    @Parameter({\"true\", \"false\", \"UNICODE_INDEX\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\", \"INVALID_INDEX\"})\n-    public void test(boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, doSign, signingKey, certEnum);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n+    @ParameterSupplier\n+    public static void test(SignKeyOptionWithKeychain sign) {\n@@ -78,2 +63,1 @@\n-    private void test(MacSign.ResolvedKeychain keychain, boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n-        final var certIndex = certEnum.value();\n+        var cmd = JPackageCommand.helloAppImage();\n@@ -81,14 +65,1 @@\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        if (doSign) {\n-            cmd.addArguments(\"--mac-sign\",\n-                    \"--mac-signing-keychain\",\n-                    keychain.name());\n-            if (signingKey) {\n-                cmd.addArguments(\"--mac-signing-key-user-name\",\n-                        SigningBase.getDevName(certIndex));\n-            } else {\n-                cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                        SigningBase.getAppCert(certIndex));\n-            }\n-        }\n-        AdditionalLauncher testAL = new AdditionalLauncher(\"testAL\");\n+        var testAL = new AdditionalLauncher(\"testAL\");\n@@ -98,2 +69,8 @@\n-        Path launcherPath = cmd.appLauncherPath();\n-        SigningBase.verifyCodesign(launcherPath, doSign, certIndex);\n+        MacSign.withKeychain(keychain -> {\n+            sign.addTo(cmd);\n+            cmd.executeAndAssertHelloAppImageCreated();\n+            MacSignVerify.verifyAppImageSigned(cmd, sign.certRequest());\n+        }, sign.keychain());\n+    }\n+\n+    public static Collection<Object[]> test() {\n@@ -101,2 +78,1 @@\n-        Path testALPath = launcherPath.getParent().resolve(\"testAL\");\n-        SigningBase.verifyCodesign(testALPath, doSign, certIndex);\n+        List<SignKeyOptionWithKeychain> data = new ArrayList<>();\n@@ -104,4 +80,10 @@\n-        Path appImage = cmd.outputBundle();\n-        SigningBase.verifyCodesign(appImage, doSign, certIndex);\n-        if (doSign) {\n-            SigningBase.verifySpctl(appImage, \"exec\", certIndex);\n+        for (var certRequest : List.of(\n+                SigningBase.StandardCertificateRequest.CODESIGN,\n+                SigningBase.StandardCertificateRequest.CODESIGN_UNICODE\n+        )) {\n+            for (var signIdentityType : SignKeyOption.Type.defaultValues()) {\n+                data.add(new SignKeyOptionWithKeychain(\n+                        signIdentityType,\n+                        certRequest,\n+                        SigningBase.StandardKeychain.MAIN.keychain()));\n+            }\n@@ -109,0 +91,4 @@\n+\n+        return data.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":44,"deletions":58,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,7 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -28,1 +32,1 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -31,0 +35,2 @@\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacHelper.SignKeyOptionWithKeychain;\n@@ -32,0 +38,1 @@\n+import jdk.jpackage.test.MacSignVerify;\n@@ -36,10 +43,6 @@\n- * Tests generation of app image and then signs generated app image with --mac-sign\n- * and related arguments. Test will generate app image and verify signature of main\n- * launcher and app bundle itself. This test requires that machine is configured with\n- * test certificate for \"Developer ID Application: jpackage.openjdk.java.net\" or\n- * alternately \"Developer ID Application: \" + name specified by system property:\n- * \"jpackage.mac.signing.key.user.name\" in the jpackagerTest keychain\n- * (or alternately the keychain specified with the system property\n- * \"jpackage.mac.signing.keychain\". If this certificate is self-signed, it must\n- * have be set to always allowed access to this keychain\" for user which runs test.\n- * (If cert is real (not self signed), the do not set trust to allow.)\n+ * Tests signing of a signed\/unsigned predefined app image.\n+ *\n+ * <p>\n+ * Prerequisites: Keychains with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN} and\n+ * {@link SigningBase.StandardKeychain#SINGLE}.\n@@ -52,2 +55,0 @@\n- * @library base\n- * @build SigningBase\n@@ -55,1 +56,2 @@\n- * @build SigningAppImageTwoStepsTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningAppImageTwoStepsTest.java\n@@ -64,11 +66,3 @@\n-    \/\/ ({\"sign or not\", \"signing-key or sign-identity\"})\n-    \/\/ Sign and signing-key\n-    @Parameter({\"true\", \"true\"})\n-    \/\/ Sign and sign-identity\n-    @Parameter({\"true\", \"false\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\"})\n-    public void test(boolean signAppImage, boolean signingKey) throws Exception {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signAppImage, signingKey);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) {\n+        spec.test();\n@@ -77,19 +71,50 @@\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n-\n-        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n-\n-        \/\/ Generate app image. Signed or unsigned based on test\n-        \/\/ parameter. We should able to sign predfined app images\n-        \/\/ which are signed or unsigned.\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n-        if (signAppImage) {\n-            appImageCmd.addArguments(\"--mac-sign\",\n-                    \"--mac-signing-keychain\",\n-                    keychain.name());\n-            if (signingKey) {\n-                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n-                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-            } else {\n-                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                    SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+    public record TestSpec(Optional<SignKeyOptionWithKeychain> signAppImage, SignKeyOptionWithKeychain sign) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(signAppImage);\n+            Objects.requireNonNull(sign);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Stream.of(\n+                    String.format(\"app-image=%s\", signAppImage.map(Objects::toString).orElse(\"unsigned\")),\n+                    sign.toString()\n+            ).collect(Collectors.joining(\"; \"));\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(Optional.ofNullable(signAppImage), sign);\n+            }\n+\n+            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n+                certRequest = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signIdentityType(SignKeyOption.Type v) {\n+                signIdentityType = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder sign() {\n+                sign = createSignKeyOption();\n+                return this;\n+            }\n+\n+            Builder signAppImage() {\n+                signAppImage = createSignKeyOption();\n+                return this;\n+            }\n+\n+            private SignKeyOptionWithKeychain createSignKeyOption() {\n+                return new SignKeyOptionWithKeychain(\n+                        signIdentityType,\n+                        certRequest,\n+                        SigningBase.StandardKeychain.MAIN.keychain());\n@@ -97,0 +122,6 @@\n+\n+            private SigningBase.StandardCertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN;\n+            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+\n+            private SignKeyOptionWithKeychain signAppImage;\n+            private SignKeyOptionWithKeychain sign;\n@@ -99,22 +130,24 @@\n-        \/\/ Add addtional launcher\n-        AdditionalLauncher testAL = new AdditionalLauncher(\"testAL\");\n-        testAL.applyTo(appImageCmd);\n-\n-        \/\/ Generate app image\n-        appImageCmd.executeAndAssertHelloAppImageCreated();\n-\n-        \/\/ Double check if it is signed or unsigned based on signAppImage\n-        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage, \"testAL\");\n-\n-        \/\/ Sign app image\n-        JPackageCommand cmd = new JPackageCommand();\n-        cmd.setPackageType(PackageType.IMAGE)\n-            .addArguments(\"--app-image\", appImageCmd.outputBundle().toAbsolutePath())\n-            .addArguments(\"--mac-sign\")\n-            .addArguments(\"--mac-signing-keychain\", keychain.name());\n-        if (signingKey) {\n-            cmd.addArguments(\"--mac-signing-key-user-name\",\n-                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-        } else {\n-            cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+        void test() {\n+            var appImageCmd = JPackageCommand.helloAppImage()\n+                    .setFakeRuntime()\n+                    .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+\n+            \/\/ Add an additional launcher\n+            AdditionalLauncher testAL = new AdditionalLauncher(\"testAL\");\n+            testAL.applyTo(appImageCmd);\n+\n+            signAppImage.ifPresentOrElse(signOption -> {\n+                MacSign.withKeychain(keychain -> {\n+                    signOption.addTo(appImageCmd);\n+                    appImageCmd.execute();\n+                    MacSignVerify.verifyAppImageSigned(appImageCmd, signOption.certRequest());\n+                }, signOption.keychain());\n+            }, appImageCmd::execute);\n+\n+            var cmd = new JPackageCommand()\n+                    .setPackageType(PackageType.IMAGE)\n+                    .addArguments(\"--app-image\", appImageCmd.outputBundle())\n+                    .mutate(sign::addTo);\n+\n+            cmd.executeAndAssertHelloAppImageCreated();\n+            MacSignVerify.verifyAppImageSigned(cmd, sign.certRequest());\n@@ -122,1 +155,26 @@\n-        cmd.executeAndAssertImageCreated();\n+    }\n+\n+    public static Collection<Object[]> test() {\n+\n+        List<TestSpec> data = new ArrayList<>();\n+\n+        for (var appImageSign : withAndWithout(SignKeyOption.Type.SIGN_KEY_IDENTITY)) {\n+            var builder = TestSpec.build();\n+            appImageSign.ifPresent(signIdentityType -> {\n+                \/\/ Sign the input app image bundle with the key not used in the jpackage command line being tested.\n+                \/\/ This way we can test if jpackage keeps or replaces the signature of the input app image bundle.\n+                builder.signIdentityType(signIdentityType)\n+                        .certRequest(SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD)\n+                        .signAppImage();\n+            });\n+            for (var signIdentityType : SignKeyOption.Type.defaultValues()) {\n+                builder.signIdentityType(signIdentityType)\n+                        .certRequest(SigningBase.StandardCertificateRequest.CODESIGN);\n+                data.add(builder.sign().create());\n+            }\n+        }\n+\n+        return data.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n@@ -124,2 +182,2 @@\n-        \/\/ Should be signed app image\n-        SigningBase.verifyAppImageSignature(appImageCmd, true, \"testAL\");\n+    private static <T> List<Optional<T>> withAndWithout(T value) {\n+        return List.of(Optional.empty(), Optional.of(value));\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":131,"deletions":73,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.MacHelper.NamedCertificateRequestSupplier;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n+import jdk.jpackage.test.MacSign.CertificateType;\n+import jdk.jpackage.test.MacSign.KeychainWithCertsSpec;\n+import jdk.jpackage.test.MacSign.ResolvedKeychain;\n+import jdk.jpackage.test.TKit;\n+\n+\n+\/*\n+ * @test\n+ * @summary Setup the environment for jpackage macos signing tests.\n+ *          Creates required keychains and signing identities.\n+ *          Does NOT run any jpackag tests.\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @requires (jpackage.test.MacSignTests == \"setup\")\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningBase.setUp\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tear down the environment for jpackage macos signing tests.\n+ *          Deletes required keychains and signing identities.\n+ *          Does NOT run any jpackag tests.\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @requires (jpackage.test.MacSignTests == \"teardown\")\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningBase.tearDown\n+ *\/\n+\n+public class SigningBase {\n+\n+    public enum StandardCertificateRequest implements NamedCertificateRequestSupplier {\n+        CODESIGN(cert().userName(NAME_ASCII)),\n+        CODESIGN_COPY(cert().days(100).userName(NAME_ASCII)),\n+        CODESIGN_ACME_TECH_LTD(cert().days(100).userName(\"ACME Technologies Limited (ABC12345)\")),\n+        PKG(cert().type(CertificateType.INSTALLER).userName(NAME_ASCII)),\n+        PKG_COPY(cert().type(CertificateType.INSTALLER).days(100).userName(NAME_ASCII)),\n+        CODESIGN_UNICODE(cert().userName(NAME_UNICODE)),\n+        PKG_UNICODE(cert().type(CertificateType.INSTALLER).userName(NAME_UNICODE)),\n+        CODESIGN_EXPIRED(cert().expired().userName(\"expired jpackage test\")),\n+        PKG_EXPIRED(cert().expired().type(CertificateType.INSTALLER).userName(\"expired jpackage test\"));\n+\n+        StandardCertificateRequest(CertificateRequest.Builder specBuilder) {\n+            this.spec = specBuilder.create();\n+        }\n+\n+        @Override\n+        public CertificateRequest certRequest() {\n+            return spec;\n+        }\n+\n+        private static CertificateRequest.Builder cert() {\n+            return new CertificateRequest.Builder();\n+        }\n+\n+        private final CertificateRequest spec;\n+    }\n+\n+    \/**\n+     * Standard keychains used in signing tests.\n+     *\/\n+    public enum StandardKeychain {\n+        \/**\n+         * The primary keychain with good certificates.\n+         *\/\n+        MAIN(\"jpackagerTest.keychain\",\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_UNICODE,\n+                StandardCertificateRequest.PKG_UNICODE,\n+                StandardCertificateRequest.CODESIGN_ACME_TECH_LTD),\n+        \/**\n+         * A keychain with some good and some expired certificates.\n+         *\/\n+        EXPIRED(\"jpackagerTest-expired.keychain\",\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_EXPIRED,\n+                StandardCertificateRequest.PKG_EXPIRED),\n+        \/**\n+         * A keychain with duplicated certificates.\n+         *\/\n+        DUPLICATE(\"jpackagerTest-duplicate.keychain\",\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_COPY,\n+                StandardCertificateRequest.PKG_COPY),\n+        ;\n+\n+        StandardKeychain(String keychainName, StandardCertificateRequest... certs) {\n+            this(keychainName,\n+                    certs[0].certRequest(),\n+                    Stream.of(certs).skip(1).map(StandardCertificateRequest::certRequest).toArray(CertificateRequest[]::new));\n+        }\n+\n+        StandardKeychain(String keychainName, CertificateRequest cert, CertificateRequest... otherCerts) {\n+            final var builder = keychain(keychainName).addCert(cert);\n+            List.of(otherCerts).forEach(builder::addCert);\n+            this.keychain = new ResolvedKeychain(builder.create());\n+        }\n+\n+        public ResolvedKeychain keychain() {\n+            return keychain;\n+        }\n+\n+        public X509Certificate mapCertificateRequest(CertificateRequest certRequest) {\n+            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n+        }\n+\n+        public boolean contains(StandardCertificateRequest certRequest) {\n+            return keychain.spec().certificateRequests().contains(certRequest.spec);\n+        }\n+\n+        private static KeychainWithCertsSpec.Builder keychain(String name) {\n+            return new KeychainWithCertsSpec.Builder().name(name);\n+        }\n+\n+        private static List<KeychainWithCertsSpec> signingEnv() {\n+            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n+        }\n+\n+        private final ResolvedKeychain keychain;\n+    }\n+\n+    public static void setUp() {\n+        MacSign.setUp(StandardKeychain.signingEnv());\n+    }\n+\n+    public static void tearDown() {\n+        MacSign.tearDown(StandardKeychain.signingEnv());\n+    }\n+\n+    public static void verifySignTestEnvReady() {\n+        if (!Inner.SIGN_ENV_READY) {\n+            TKit.throwSkippedException(new IllegalStateException(\"Misconfigured signing test environment\"));\n+        }\n+    }\n+\n+    private final class Inner {\n+        private static final boolean SIGN_ENV_READY = MacSign.isDeployed(StandardKeychain.signingEnv());\n+    }\n+\n+    private static final String NAME_ASCII = \"jpackage.openjdk.java.net\";\n+    private static final String NAME_UNICODE = \"jpackage.openjdk.java.net ()\";\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningBase.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,12 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.nio.file.Path;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SequencedSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -29,2 +37,0 @@\n-import jdk.jpackage.test.ApplicationLayout;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -32,0 +38,2 @@\n+import jdk.jpackage.test.MacHelper.ResolvableCertificateRequest;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n@@ -33,0 +41,1 @@\n+import jdk.jpackage.test.MacSignVerify;\n@@ -37,12 +46,6 @@\n- * Tests generation of dmg and pkg with --mac-sign and related arguments.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but app image inside dmg is signed. This test requires that\n- * the machine is configured with test certificate for\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * Tests bundling of .pkg and .dmg packages with various signing options.\n+ *\n+ * <p>\n+ * Prerequisites: Keychains with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN} and\n+ * {@link SigningBase.StandardKeychain#SINGLE}.\n@@ -51,0 +54,1 @@\n+\n@@ -55,1 +59,0 @@\n- * @library base\n@@ -57,1 +60,0 @@\n- * @build SigningBase\n@@ -59,1 +61,2 @@\n- * @build SigningPackageTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningPackageTest.java\n@@ -63,4 +66,4 @@\n- * --jpt-run=SigningPackageTest\n- * --jpt-space-subst=*\n- * --jpt-include=SigningPackageTest.test(true,*true,*true,*ASCII_INDEX)\n- * --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *  --jpt-run=SigningPackageTest.test\n+ *  --jpt-space-subst=*\n+ *  --jpt-include=({--mac-signing-key-user-name:*CODESIGN},*{--mac-signing-key-user-name:*PKG},*MAC_DMG+MAC_PKG)\n+ *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n@@ -73,1 +76,0 @@\n- * @library base\n@@ -75,1 +77,0 @@\n- * @build SigningBase\n@@ -77,1 +78,2 @@\n- * @build SigningPackageTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningPackageTest.java\n@@ -80,2 +82,2 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=SigningPackageTest\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningPackageTest.test\n@@ -86,3 +88,6 @@\n-    private static boolean isAppImageSigned(JPackageCommand cmd) {\n-        return cmd.hasArgument(\"--mac-signing-key-user-name\") ||\n-               cmd.hasArgument(\"--mac-app-image-sign-identity\");\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) {\n+        MacSign.withKeychain(_ -> {\n+            spec.test();\n+        }, spec.keychain());\n@@ -91,3 +96,4 @@\n-    private static boolean isPKGSigned(JPackageCommand cmd) {\n-        return cmd.hasArgument(\"--mac-signing-key-user-name\") ||\n-               cmd.hasArgument(\"--mac-installer-sign-identity\");\n+    public static Collection<Object[]> test() {\n+        return TestSpec.testCases(true).stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n@@ -96,5 +102,44 @@\n-    private static void verifyPKG(JPackageCommand cmd) {\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyPkgutil(outputBundle, isPKGSigned(cmd), getCertIndex(cmd));\n-        if (isPKGSigned(cmd)) {\n-            SigningBase.verifySpctl(outputBundle, \"install\", getCertIndex(cmd));\n+    record TestSpec(\n+            Optional<SignKeyOption> appImageSignOption,\n+            Optional<SignKeyOption> packageSignOption,\n+            Set<PackageType> packageTypes) {\n+\n+        TestSpec {\n+            Objects.requireNonNull(appImageSignOption);\n+            Objects.requireNonNull(packageSignOption);\n+            Objects.requireNonNull(packageTypes);\n+\n+            if (appImageSignOption.isEmpty() && packageSignOption.isEmpty()) {\n+                \/\/ No signing.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (packageTypes.isEmpty() || !PackageType.MAC.containsAll(packageTypes)) {\n+                \/\/ Invalid package types.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (packageSignOption.isPresent()) {\n+                if (!packageTypes.contains(PackageType.MAC_PKG)) {\n+                    \/\/ .pkg installer should be signed, but .pkg type is missing.\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                if (appImageSignOption.isEmpty()) {\n+                    if (packageSignOption.get().type() != SignKeyOption.Type.SIGN_KEY_IDENTITY) {\n+                        \/\/ They request to sign the .pkg installer without\n+                        \/\/ the \"--mac-installer-sign-identity\" option,\n+                        \/\/ but didn't specify a signing option for the packaged app image.\n+                        \/\/ This is wrong because only the \"--mac-installer-sign-identity\" option\n+                        \/\/ allows signing a .pkg installer without signing its packaged app image.\n+                        throw new IllegalArgumentException();\n+                    }\n+                } else if (appImageSignOption.get().type() != packageSignOption.get().type()) {\n+                    \/\/ Signing option types should be the same.\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+\n+            if (!(packageTypes instanceof SequencedSet)) {\n+                packageTypes = new TreeSet<>(packageTypes);\n+            }\n@@ -102,1 +147,0 @@\n-    }\n@@ -104,4 +148,14 @@\n-    private static void verifyDMG(JPackageCommand cmd) {\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyDMG(outputBundle);\n-    }\n+        TestSpec(\n+                Optional<SignKeyOption> appImageSignOption,\n+                Optional<SignKeyOption> packageSignOption,\n+                PackageType... packageTypes) {\n+            this(appImageSignOption, packageSignOption, Set.of(packageTypes));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Stream.of(\n+                    signKeyOptions(),\n+                    Stream.of(packageTypes.stream().map(Object::toString).collect(Collectors.joining(\"+\")))\n+            ).flatMap(x -> x).map(Object::toString).collect(Collectors.joining(\", \"));\n+        }\n@@ -109,13 +163,14 @@\n-    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            Path launcherPath = ApplicationLayout.platformAppImage()\n-                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n-            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n-            \/\/ we only need to verify app.\n-            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n-                SigningBase.verifyCodesign(launcherPath, isAppImageSigned(cmd),\n-                                           getCertIndex(cmd));\n-                SigningBase.verifyCodesign(dmgImage, isAppImageSigned(cmd),\n-                                           getCertIndex(cmd));\n-                if (isAppImageSigned(cmd)) {\n-                    SigningBase.verifySpctl(dmgImage, \"exec\", getCertIndex(cmd));\n+        Stream<SignKeyOption> signKeyOptions() {\n+            return Stream.concat(appImageSignOption.stream(), packageSignOption.stream());\n+        }\n+\n+        Optional<ResolvableCertificateRequest> bundleSignIdentity(PackageType type) {\n+            switch (type) {\n+                case MAC_DMG -> {\n+                    return Optional.empty();\n+                }\n+                case MAC_PKG -> {\n+                    return packageSignOption.map(SignKeyOption::certRequest);\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n@@ -124,2 +179,1 @@\n-        });\n-    }\n+        }\n@@ -127,7 +181,6 @@\n-    private static int getCertIndex(JPackageCommand cmd) {\n-        if (cmd.hasArgument(\"--mac-signing-key-user-name\")) {\n-            String devName = cmd.getArgumentValue(\"--mac-signing-key-user-name\");\n-            return SigningBase.getDevNameIndex(devName);\n-        } else {\n-            \/\/ Signing-indentity\n-            return SigningBase.CertIndex.UNICODE_INDEX.value();\n+        void test() {\n+            initTest().configureHelloApp().addInstallVerifier(cmd -> {\n+                appImageSignOption.map(SignKeyOption::certRequest).ifPresent(signIdentity -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, signIdentity);\n+                });\n+            }).run();\n@@ -135,1 +188,0 @@\n-    }\n@@ -137,17 +189,20 @@\n-    @Test\n-    \/\/ (\"signing-key or sign-identity\", \"sign app-image\", \"sign pkg\", \"certificate index\"})\n-    \/\/ Signing-key and ASCII certificate\n-    @Parameter({\"true\", \"true\", \"true\", \"ASCII_INDEX\"})\n-    \/\/ Signing-key and UNICODE certificate\n-    @Parameter({\"true\", \"true\", \"true\", \"UNICODE_INDEX\"})\n-    \/\/ Signing-indentity and UNICODE certificate\n-    @Parameter({\"false\", \"true\", \"true\", \"UNICODE_INDEX\"})\n-    \/\/ Signing-indentity, but sign app-image only and UNICODE certificate\n-    @Parameter({\"false\", \"true\", \"false\", \"UNICODE_INDEX\"})\n-    \/\/ Signing-indentity, but sign pkg only and UNICODE certificate\n-    @Parameter({\"false\", \"false\", \"true\", \"UNICODE_INDEX\"})\n-    public static void test(boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signingKey, signAppImage, signPKG, certEnum);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n+        PackageTest initTest() {\n+            return new PackageTest().forTypes(packageTypes).mutate(test -> {\n+                appImageSignOption.ifPresent(signOption -> {\n+                    test.addInitializer(signOption::setTo);\n+                });\n+                packageSignOption.ifPresent(signOption -> {\n+                    test.forTypes(PackageType.MAC_PKG, () -> {\n+                        test.addInitializer(signOption::setTo);\n+                    });\n+                });\n+            }).addBundleVerifier(cmd -> {\n+                bundleSignIdentity(cmd.packageType()).ifPresent(signIdentity -> {\n+                    MacSignVerify.verifyPkgSigned(cmd, signIdentity);\n+                });\n+            }).addInitializer(MacHelper.useKeychain(keychain())::accept);\n+        }\n+\n+        MacSign.ResolvedKeychain keychain() {\n+            return SigningBase.StandardKeychain.MAIN.keychain();\n+        }\n@@ -155,16 +210,28 @@\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n-        final var certIndex = certEnum.value();\n-\n-        new PackageTest()\n-                .configureHelloApp()\n-                .forTypes(PackageType.MAC)\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--mac-sign\",\n-                            \"--mac-signing-keychain\", keychain.name());\n-                    if (signingKey) {\n-                        cmd.addArguments(\"--mac-signing-key-user-name\",\n-                                         SigningBase.getDevName(certIndex));\n-                    } else {\n-                        if (signAppImage) {\n-                            cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                             SigningBase.getAppCert(certIndex));\n+        static List<TestSpec> testCases(boolean withUnicode) {\n+\n+            List<TestSpec> data = new ArrayList<>();\n+\n+            List<List<SigningBase.StandardCertificateRequest>> certRequestGroups;\n+            if (withUnicode) {\n+                certRequestGroups = List.of(\n+                        List.of(SigningBase.StandardCertificateRequest.CODESIGN, SigningBase.StandardCertificateRequest.PKG),\n+                        List.of(SigningBase.StandardCertificateRequest.CODESIGN_UNICODE, SigningBase.StandardCertificateRequest.PKG_UNICODE)\n+                );\n+            } else {\n+                certRequestGroups = List.of(\n+                        List.of(SigningBase.StandardCertificateRequest.CODESIGN, SigningBase.StandardCertificateRequest.PKG)\n+                );\n+            }\n+\n+            for (var certRequests : certRequestGroups) {\n+                for (var signIdentityType : SignKeyOption.Type.defaultValues()) {\n+                    var keychain = SigningBase.StandardKeychain.MAIN.keychain();\n+                    var appImageSignKeyOption = new SignKeyOption(signIdentityType, certRequests.getFirst(), keychain);\n+                    var pkgSignKeyOption = new SignKeyOption(signIdentityType, certRequests.getLast(), keychain);\n+\n+                    switch (signIdentityType) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            \/\/ Use \"--mac-installer-sign-identity\" and \"--mac-app-image-sign-identity\" signing options.\n+                            \/\/ They allows to sign the packaged app image and the installer (.pkg) separately.\n+                            data.add(new TestSpec(Optional.of(appImageSignKeyOption), Optional.empty(), PackageType.MAC));\n+                            data.add(new TestSpec(Optional.empty(), Optional.of(pkgSignKeyOption), PackageType.MAC_PKG));\n@@ -172,3 +239,5 @@\n-                        if (signPKG) {\n-                            cmd.addArguments(\"--mac-installer-sign-identity\",\n-                                             SigningBase.getInstallerCert(certIndex));\n+                        case SIGN_KEY_USER_SHORT_NAME -> {\n+                            \/\/ Use \"--mac-signing-key-user-name\" signing option with short user name or implicit signing option.\n+                            \/\/ It signs both the packaged app image and the installer (.pkg).\n+                            \/\/ Thus, if the installer is not signed, it can be used only with .dmg packaging.\n+                            data.add(new TestSpec(Optional.of(appImageSignKeyOption), Optional.empty(), PackageType.MAC_DMG));\n@@ -176,17 +245,13 @@\n-                    }\n-                })\n-                .forTypes(PackageType.MAC_PKG)\n-                .addBundleVerifier(SigningPackageTest::verifyPKG)\n-                .forTypes(PackageType.MAC_DMG)\n-                .addInitializer(cmd -> {\n-                    if (!signingKey) {\n-                        \/\/ jpackage throws expected error with\n-                        \/\/ --mac-installer-sign-identity and DMG type\n-                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n-                        \/\/ In case of not signing app image and DMG we need to\n-                        \/\/ remove signing completely, otherwise we will default\n-                        \/\/ to --mac-signing-key-user-name once\n-                        \/\/ --mac-installer-sign-identity is removed.\n-                        if (!signAppImage) {\n-                            cmd.removeArgumentWithValue(\"--mac-signing-keychain\");\n-                            cmd.removeArgument(\"--mac-sign\");\n+                        case SIGN_KEY_USER_FULL_NAME -> {\n+                            \/\/ Use \"--mac-signing-key-user-name\" signing option with the full user name.\n+                            \/\/ Like SIGN_KEY_USER_SHORT_NAME, jpackage will try to use it to sign both\n+                            \/\/ the packaged app image and the installer (.pkg).\n+                            \/\/ It will fail to sign the installer, though, because the signing identity is unsuitable.\n+                            \/\/ That is why, use it with .dmg packaging only and not with .pkg packaging.\n+                            data.add(new TestSpec(Optional.of(appImageSignKeyOption), Optional.empty(), PackageType.MAC_DMG));\n+                            continue;\n+                        }\n+                        default -> {\n+                            \/\/ SignKeyOption.Type.defaultValues() should return\n+                            \/\/ such a sequence that makes this code location unreachable.\n+                            throw ExceptionBox.reachedUnreachable();\n@@ -195,4 +260,6 @@\n-                })\n-                .addBundleVerifier(SigningPackageTest::verifyDMG)\n-                .addBundleVerifier(SigningPackageTest::verifyAppImageInDMG)\n-                .run();\n+                    data.add(new TestSpec(Optional.of(appImageSignKeyOption), Optional.of(pkgSignKeyOption), PackageType.MAC));\n+                }\n+            }\n+\n+            return data;\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":194,"deletions":127,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -29,1 +27,0 @@\n-import java.util.HashMap;\n@@ -31,1 +28,0 @@\n-import java.util.Map;\n@@ -34,2 +30,1 @@\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n+import java.util.stream.Collectors;\n@@ -39,0 +34,1 @@\n+import jdk.jpackage.test.CannedFormattedString;\n@@ -41,1 +37,1 @@\n-import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.ResolvableCertificateRequest;\n@@ -43,0 +39,1 @@\n+import jdk.jpackage.test.MacHelper.SignKeyOptionWithKeychain;\n@@ -55,2 +52,3 @@\n- * Prerequisites: A keychain with self-signed certificates as specified in\n- * {@link SigningBase.StandardKeychain#MAIN}.\n+ * Prerequisites: Keychains with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN} and\n+ * {@link SigningBase.StandardKeychain#SINGLE}.\n@@ -63,1 +61,0 @@\n- * @library base\n@@ -65,1 +62,0 @@\n- * @build SigningBase\n@@ -67,1 +63,3 @@\n- * @build SigningPackageTwoStepTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningPackageTest.java\n+ * @compile -Xlint:all -Werror SigningPackageTwoStepTest.java\n@@ -70,1 +68,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n@@ -78,4 +76,2 @@\n-    public static void test(TestSpec spec) {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            spec.test(keychain);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    public static void test(TwoStepsTestSpec spec) {\n+        spec.test();\n@@ -84,5 +80,2 @@\n-    public record TestSpec(Optional<SignKeyOption> signAppImage, Map<PackageType, SignKeyOption> signPackage) {\n-\n-        public TestSpec {\n-            Objects.requireNonNull(signAppImage);\n-            Objects.requireNonNull(signPackage);\n+    @Test\n+    public static void testBundleSignedAppImage() {\n@@ -90,4 +83,1 @@\n-            if ((signAppImage.isEmpty() && signPackage.isEmpty()) || !PackageType.MAC.containsAll(signPackage.keySet())) {\n-                \/\/ Unexpected package types.\n-                throw new IllegalArgumentException();\n-            }\n+        var appImageCmd = JPackageCommand.helloAppImage();\n@@ -95,5 +85,1 @@\n-            \/\/ Ensure stable result of toString() call.\n-            if (!SortedMap.class.isInstance(signPackage)) {\n-                signPackage = new TreeMap<>(signPackage);\n-            }\n-        }\n+        var predefinedAppImageSignOption = predefinedAppImageSignOption();\n@@ -101,3 +87,8 @@\n-        @Override\n-        public String toString() {\n-            var sb = new StringBuilder();\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            createPredefinedAppImage(appImageCmd, Optional.of(predefinedAppImageSignOption));\n+        }).usePredefinedAppImage(appImageCmd).addInitializer(cmd -> {\n+            configureOutputValidator(cmd, true, false);\n+        }).addInstallVerifier(cmd -> {\n+            MacSignVerify.verifyAppImageSigned(cmd, predefinedAppImageSignOption.certRequest());\n+        }).run();\n+    }\n@@ -105,3 +96,1 @@\n-            signAppImage.ifPresent(signOption -> {\n-                sb.append(String.format(\"app-image=%s\", signOption));\n-            });\n+    public static Collection<Object[]> test() {\n@@ -109,2 +98,11 @@\n-            if (!sb.isEmpty() && !signPackage.isEmpty()) {\n-                sb.append(\"; \");\n+        List<TwoStepsTestSpec> data = new ArrayList<>();\n+\n+        for (var signAppImage : List.of(true, false)) {\n+            Optional<SignKeyOptionWithKeychain> appImageSignOption;\n+            if (signAppImage) {\n+                \/\/ Sign the predefined app image bundle with the key not used in the jpackage command line being tested.\n+                \/\/ This way we can test if jpackage keeps or replaces the signature of\n+                \/\/ the predefined app image bundle when backing it in the pkg or dmg installer.\n+                appImageSignOption = Optional.of(predefinedAppImageSignOption());\n+            } else {\n+                appImageSignOption = Optional.empty();\n@@ -113,2 +111,2 @@\n-            if (!signPackage.isEmpty()) {\n-                sb.append(signPackage);\n+            for (var signPackage : SigningPackageTest.TestSpec.testCases(false)) {\n+                data.add(new TwoStepsTestSpec(appImageSignOption, signPackage));\n@@ -116,10 +114,0 @@\n-\n-            return sb.toString();\n-        }\n-\n-        boolean signNativeBundle() {\n-            return signPackage.isEmpty();\n-        }\n-\n-        static Builder build() {\n-            return new Builder();\n@@ -128,9 +116,4 @@\n-        static class Builder {\n-\n-            TestSpec create() {\n-                return new TestSpec(Optional.ofNullable(signAppImage), signPackage);\n-            }\n-\n-            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n-                return certRequest(v.spec());\n-            }\n+        return data.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n@@ -138,4 +121,1 @@\n-            Builder certRequest(MacSign.CertificateRequest v) {\n-                certRequest = Objects.requireNonNull(v);\n-                return this;\n-            }\n+    record TwoStepsTestSpec(Optional<SignKeyOptionWithKeychain> signAppImage, SigningPackageTest.TestSpec signPackage) {\n@@ -143,4 +123,4 @@\n-            Builder signIdentityType(SignKeyOption.Type v) {\n-                signIdentityType = Objects.requireNonNull(v);\n-                return this;\n-            }\n+        TwoStepsTestSpec {\n+            Objects.requireNonNull(signAppImage);\n+            Objects.requireNonNull(signPackage);\n+        }\n@@ -148,4 +128,7 @@\n-            Builder signAppImage() {\n-                signAppImage = createSignKeyOption();\n-                return this;\n-            }\n+        @Override\n+        public String toString() {\n+            return Stream.of(\n+                    String.format(\"app-image=%s\", signAppImage.map(Objects::toString).orElse(\"unsigned\")),\n+                    signPackage.toString()\n+            ).collect(Collectors.joining(\"; \"));\n+        }\n@@ -153,5 +136,3 @@\n-            Builder signPackage(PackageType type) {\n-                Objects.requireNonNull(type);\n-                signPackage.put(type, createSignKeyOption());\n-                return this;\n-            }\n+        Optional<ResolvableCertificateRequest> packagedAppImageSignIdentity() {\n+            return signAppImage.map(SignKeyOptionWithKeychain::certRequest);\n+        }\n@@ -159,4 +140,1 @@\n-            Builder signPackage() {\n-                PackageType.MAC.forEach(this::signPackage);\n-                return this;\n-            }\n+        void test() {\n@@ -164,3 +142,1 @@\n-            private SignKeyOption createSignKeyOption() {\n-                return new SignKeyOption(signIdentityType, certRequest);\n-            }\n+            var appImageCmd = JPackageCommand.helloAppImage();\n@@ -168,2 +144,11 @@\n-            private MacSign.CertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN.spec();\n-            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+            var test = signPackage.initTest().addRunOnceInitializer(() -> {\n+                createPredefinedAppImage(appImageCmd, signAppImage);\n+            }).usePredefinedAppImage(appImageCmd).addInitializer(cmd -> {\n+                configureOutputValidator(cmd,\n+                        signAppImage.isPresent(),\n+                        (cmd.packageType() == PackageType.MAC_PKG) && signPackage.packageSignOption().isPresent());\n+            }).addInstallVerifier(cmd -> {\n+                packagedAppImageSignIdentity().ifPresent(certRequest -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, certRequest);\n+                });\n+            });\n@@ -171,2 +156,3 @@\n-            private SignKeyOption signAppImage;\n-            private Map<PackageType, SignKeyOption> signPackage = new HashMap<>();\n+            MacSign.withKeychain(_ -> {\n+                test.run();\n+            }, signPackage.keychain());\n@@ -174,0 +160,1 @@\n+    }\n@@ -175,7 +162,8 @@\n-        void test(MacSign.ResolvedKeychain keychain) {\n-\n-            var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n-            MacHelper.useKeychain(appImageCmd, keychain);\n-            signAppImage.ifPresent(signOption -> {\n-                signOption.setTo(appImageCmd);\n-            });\n+    private static SignKeyOptionWithKeychain predefinedAppImageSignOption() {\n+        \/\/ Sign the predefined app image bundle with the key not used in the jpackage command line being tested.\n+        \/\/ This way we can test if jpackage keeps or replaces the signature of the input app image bundle.\n+        return new SignKeyOptionWithKeychain(\n+                SignKeyOption.Type.SIGN_KEY_USER_SHORT_NAME,\n+                SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD,\n+                SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n@@ -183,1 +171,3 @@\n-            var test = new PackageTest();\n+    private static void createPredefinedAppImage(JPackageCommand appImageCmd, Optional<SignKeyOptionWithKeychain> signAppImage) {\n+        Objects.requireNonNull(appImageCmd);\n+        Objects.requireNonNull(signAppImage);\n@@ -185,6 +175,1 @@\n-            signAppImage.map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n-                \/\/ The predefined app image is signed, verify bundled app image is signed too.\n-                test.addInstallVerifier(cmd -> {\n-                    MacSignVerify.verifyAppImageSigned(cmd, certRequest, keychain);\n-                });\n-            });\n+        appImageCmd.setFakeRuntime().setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -192,7 +177,2 @@\n-            Optional.ofNullable(signPackage.get(PackageType.MAC_PKG)).map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n-                test.forTypes(PackageType.MAC_PKG, () -> {\n-                    test.addBundleVerifier(cmd -> {\n-                        MacSignVerify.verifyPkgSigned(cmd, certRequest, keychain);\n-                    });\n-                });\n-            });\n+        signAppImage.ifPresentOrElse(signOption -> {\n+            signOption.setTo(appImageCmd);\n@@ -200,7 +180,3 @@\n-            test.forTypes(signPackage.keySet()).addRunOnceInitializer(() -> {\n-                appImageCmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\")).execute(0);\n-            }).usePredefinedAppImage(appImageCmd).addInitializer(cmd -> {\n-                MacHelper.useKeychain(cmd, keychain);\n-                Optional.ofNullable(signPackage.get(cmd.packageType())).ifPresent(signOption -> {\n-                    signOption.setTo(cmd);\n-                });\n+            MacSign.withKeychain(_ -> {\n+                appImageCmd.execute(0);\n+            }, signOption.keychain());\n@@ -208,12 +184,5 @@\n-                if (signAppImage.isPresent()) {\n-                    \/\/ Predefined app image is signed. Expect a warning.\n-                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n-                            \"warning.per.user.app.image.signed\",\n-                            PackageFile.getPathInAppImage(Path.of(\"\"))));\n-                } else if (cmd.packageType() == PackageType.MAC_PKG && signPackage.containsKey(cmd.packageType())) {\n-                    \/\/ Create signed \".pkg\" bundle from the unsigned predefined app image. Expect a warning.\n-                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\"));\n-                }\n-            })\n-            .run();\n-        }\n+            \/\/ Verify that the predefined app image is signed.\n+            MacSignVerify.verifyAppImageSigned(appImageCmd, signOption.certRequest());\n+        }, () -> {\n+            appImageCmd.execute(0);\n+        });\n@@ -222,3 +191,23 @@\n-    public static Collection<Object[]> test() {\n-\n-        List<TestSpec.Builder> data = new ArrayList<>();\n+    private static void configureOutputValidator(JPackageCommand cmd, boolean signAppImage, boolean signPackage) {\n+        var signedPredefinedAppImageWarning = JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"warning.per.user.app.image.signed\",\n+                PackageFile.getPathInAppImage(Path.of(\"\")));\n+\n+        var signedInstallerFromUnsignedPredefinedAppImageWarning =\n+                JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\");\n+\n+        \/\/ The warnings are mutual exclusive\n+        final Optional<CannedFormattedString> expected;\n+        final List<CannedFormattedString> unexpected = new ArrayList<>();\n+\n+        if (signAppImage) {\n+            expected = Optional.of(signedPredefinedAppImageWarning);\n+        } else {\n+            unexpected.add(signedPredefinedAppImageWarning);\n+            if (signPackage) {\n+                expected = Optional.of(signedInstallerFromUnsignedPredefinedAppImageWarning);\n+            } else {\n+                expected = Optional.empty();\n+                unexpected.add(signedInstallerFromUnsignedPredefinedAppImageWarning);\n+            }\n+        }\n@@ -226,23 +215,4 @@\n-        Stream.of(SignKeyOption.Type.values()).flatMap(signIdentityType -> {\n-            return Stream.of(\n-                    \/\/ Sign both predefined app image and native package.\n-                    TestSpec.build().signIdentityType(signIdentityType)\n-                            .signAppImage()\n-                            .signPackage()\n-                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n-                            .signPackage(PackageType.MAC_PKG),\n-\n-                    \/\/ Don't sign predefined app image, sign native package.\n-                    TestSpec.build().signIdentityType(signIdentityType)\n-                            .signPackage()\n-                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n-                            .signPackage(PackageType.MAC_PKG),\n-\n-                    \/\/ Sign predefined app image, don't sign native package.\n-                    TestSpec.build().signIdentityType(signIdentityType).signAppImage()\n-            );\n-        }).forEach(data::add);\n-\n-        return data.stream().map(TestSpec.Builder::create).map(v -> {\n-            return new Object[] {v};\n-        }).toList();\n+        expected.ifPresent(cmd::validateOutput);\n+        unexpected.forEach(str -> {\n+            cmd.validateOutput(TKit.assertTextStream(cmd.getValue(str)).negate());\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":125,"deletions":155,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.test.JPackageCommand.RuntimeImageType.RUNTIME_TYPE_FAKE;\n@@ -27,1 +27,7 @@\n-import java.util.function.Predicate;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n@@ -29,1 +35,3 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.internal.util.MacBundle;\n+import jdk.jpackage.internal.util.Slot;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -33,0 +41,3 @@\n+import jdk.jpackage.test.MacHelper.ResolvableCertificateRequest;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacHelper.SignKeyOptionWithKeychain;\n@@ -34,0 +45,2 @@\n+import jdk.jpackage.test.MacSignVerify;\n+import jdk.jpackage.test.MacSignVerify.SpctlType;\n@@ -35,0 +48,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -46,21 +60,3 @@\n- * Following combinations are tested:\n- * <ol>\n- * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n- * provided. Expected result: runtime image ad-hoc signed.\n- * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n- * provided. Expected result: Everything is signed with provided certificate.\n- * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n- * provided. Expected result: runtime image is signed with original certificate.\n- * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n- * Expected result: runtime image is signed with provided certificate.\n- * <li>\"--runtime-image\" points to JDK image and --mac-sign is not provided.\n- * Expected result: runtime image ad-hoc signed.\n- * <li>\"--runtime-image\" points to JDK image and --mac-sign is provided.\n- * Expected result: Everything is signed with provided certificate.\n- * <\/ol>\n- *\n- * This test requires that the machine is configured with test certificate for\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in jpackagerTest keychain\n- * with always allowed access to this keychain for user which runs test. note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n- * \"jpackage.mac.signing.key.user.name\"\n+ * Prerequisites: Keychains with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN} and\n+ * {@link SigningBase.StandardKeychain#SINGLE}.\n@@ -73,1 +69,0 @@\n- * @library base\n@@ -75,1 +70,0 @@\n- * @build SigningBase\n@@ -77,1 +71,3 @@\n- * @build SigningRuntimeImagePackageTest\n+ * @compile -Xlint:all -Werror SigningBase.java\n+ * @compile -Xlint:all -Werror SigningPackageTest.java\n+ * @compile -Xlint:all -Werror SigningRuntimeImagePackageTest.java\n@@ -80,1 +76,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n@@ -86,6 +82,49 @@\n-    private static JPackageCommand addSignOptions(JPackageCommand cmd, MacSign.ResolvedKeychain keychain, int certIndex) {\n-        if (certIndex != SigningBase.CertIndex.INVALID_INDEX.value()) {\n-            cmd.addArguments(\n-                    \"--mac-sign\",\n-                    \"--mac-signing-keychain\", keychain.name(),\n-                    \"--mac-signing-key-user-name\", SigningBase.getDevName(certIndex));\n+    @Test\n+    @ParameterSupplier\n+    public static void test(RuntimeTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    @Test\n+    public static void testBundleSignedRuntime() {\n+\n+        Slot<Path> predefinedRuntime = Slot.createEmpty();\n+\n+        var signRuntime = runtimeImageSignOption();\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            predefinedRuntime.set(createRuntime(Optional.of(signRuntime), RuntimeType.BUNDLE));\n+        }).addInitializer(cmd -> {\n+            cmd.ignoreDefaultRuntime(true);\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--runtime-image\", predefinedRuntime.get());\n+        }).addInstallVerifier(cmd -> {\n+            MacSignVerify.verifyAppImageSigned(cmd, signRuntime.certRequest());\n+        }).run();\n+    }\n+\n+    public static Collection<Object[]> test() {\n+\n+        List<RuntimeTestSpec> data = new ArrayList<>();\n+\n+        for (var runtimeSpec : List.of(\n+                Map.entry(RuntimeType.IMAGE, false \/* unsigned *\/),\n+                Map.entry(RuntimeType.BUNDLE, false \/* unsigned *\/),\n+                Map.entry(RuntimeType.BUNDLE, true \/* signed *\/)\n+        )) {\n+            var runtimeType = runtimeSpec.getKey();\n+            var signRuntime = runtimeSpec.getValue();\n+\n+            Optional<SignKeyOptionWithKeychain> runtimeSignOption;\n+            if (signRuntime) {\n+                \/\/ Sign the runtime bundle with the key not used in the jpackage command line being tested.\n+                \/\/ This way we can test if jpackage keeps or replaces the signature of\n+                \/\/ the predefined runtime bundle when backing it in the pkg or dmg installer.\n+                runtimeSignOption = Optional.of(runtimeImageSignOption());\n+            } else {\n+                runtimeSignOption = Optional.empty();\n+            }\n+\n+            for (var signPackage : SigningPackageTest.TestSpec.testCases(false)) {\n+                data.add(new RuntimeTestSpec(runtimeSignOption, runtimeType, signPackage));\n+            }\n@@ -93,1 +132,4 @@\n-        return cmd;\n+\n+        return data.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n@@ -96,4 +138,4 @@\n-    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) {\n-        return MacHelper.createRuntimeBundle(cmd -> {\n-            addSignOptions(cmd, keychain, certIndex);\n-        });\n+    enum RuntimeType {\n+        IMAGE,\n+        BUNDLE,\n+        ;\n@@ -102,23 +144,62 @@\n-    @Test\n-    \/\/ useJDKBundle  - If \"true\" predefined runtime image will be converted to\n-    \/\/                 JDK bundle. If \"false\" JDK image will be used.\n-    \/\/ JDKBundleCert - Certificate to sign JDK bundle before calling jpackage.\n-    \/\/ signCert      - Certificate to sign bundle produced by jpackage.\n-    \/\/ 1) unsigned JDK bundle and --mac-sign is not provided\n-    @Parameter({\"true\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n-    \/\/ 2) unsigned JDK bundle and --mac-sign is provided\n-    @Parameter({\"true\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n-    \/\/ 3) signed JDK bundle and --mac-sign is not provided\n-    @Parameter({\"true\", \"UNICODE_INDEX\", \"INVALID_INDEX\"})\n-    \/\/ 4) signed JDK bundle and --mac-sign is provided\n-    @Parameter({\"true\", \"UNICODE_INDEX\", \"ASCII_INDEX\"})\n-    \/\/ 5) JDK image and --mac-sign is not provided\n-    @Parameter({\"false\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n-    \/\/ 6) JDK image and --mac-sign is provided\n-    @Parameter({\"false\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n-    public static void test(boolean useJDKBundle,\n-                            SigningBase.CertIndex jdkBundleCert,\n-                            SigningBase.CertIndex signCert) throws Exception {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, useJDKBundle, jdkBundleCert, signCert);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    record RuntimeTestSpec(\n+            Optional<SignKeyOptionWithKeychain> signRuntime,\n+            RuntimeType runtimeType,\n+            SigningPackageTest.TestSpec signPackage) {\n+\n+        RuntimeTestSpec {\n+            Objects.requireNonNull(signRuntime);\n+            Objects.requireNonNull(runtimeType);\n+            Objects.requireNonNull(signPackage);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var runtimeToken = new StringBuilder();\n+            runtimeToken.append(\"runtime={\").append(runtimeType);\n+            signRuntime.ifPresent(v -> {\n+                runtimeToken.append(\", \").append(v);\n+            });\n+            runtimeToken.append('}');\n+            return Stream.of(runtimeToken, signPackage).map(Objects::toString).collect(Collectors.joining(\"; \"));\n+        }\n+\n+        Optional<ResolvableCertificateRequest> packagedAppImageSignIdentity() {\n+            if (runtimeType == RuntimeType.IMAGE) {\n+                return signPackage.appImageSignOption().map(SignKeyOption::certRequest);\n+            } else {\n+                return signPackage.appImageSignOption().or(() -> {\n+                    return signRuntime.map(SignKeyOptionWithKeychain::signKeyOption);\n+                }).map(SignKeyOption::certRequest);\n+            }\n+        }\n+\n+        void test() {\n+\n+            Slot<Path> predefinedRuntime = Slot.createEmpty();\n+\n+            var test = signPackage.initTest().addRunOnceInitializer(() -> {\n+                predefinedRuntime.set(createRuntime(signRuntime, runtimeType));\n+            }).addInitializer(cmd -> {\n+                cmd.ignoreDefaultRuntime(true);\n+                cmd.removeArgumentWithValue(\"--input\");\n+                cmd.setArgumentValue(\"--runtime-image\", predefinedRuntime.get());\n+            }).addInstallVerifier(cmd -> {\n+                packagedAppImageSignIdentity().ifPresent(certRequest -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, certRequest);\n+                });\n+            });\n+\n+            MacSign.withKeychain(_ -> {\n+                test.run();\n+            }, signPackage.keychain());\n+        }\n+    }\n+\n+    private static SignKeyOptionWithKeychain runtimeImageSignOption() {\n+        \/\/ Sign the runtime bundle with the key not used in the jpackage command line being tested.\n+        \/\/ This way we can test if jpackage keeps or replaces the signature of\n+        \/\/ the predefined runtime bundle when backing it in the pkg or dmg installer.\n+        return new SignKeyOptionWithKeychain(\n+                SignKeyOption.Type.SIGN_KEY_USER_SHORT_NAME,\n+                SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD,\n+                SigningBase.StandardKeychain.MAIN.keychain());\n@@ -127,40 +208,29 @@\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean useJDKBundle,\n-            SigningBase.CertIndex jdkBundleCert,\n-            SigningBase.CertIndex signCert) throws Exception {\n-\n-        final Path inputRuntime[] = new Path[1];\n-\n-        new PackageTest()\n-                .addRunOnceInitializer(() -> {\n-                    if (useJDKBundle) {\n-                        inputRuntime[0] = createInputRuntimeBundle(keychain, jdkBundleCert.value());\n-                    } else {\n-                        inputRuntime[0] = JPackageCommand.createInputRuntimeImage();\n-                    }\n-                })\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--runtime-image\", inputRuntime[0]);\n-                    \/\/ Remove --input parameter from jpackage command line as we don't\n-                    \/\/ create input directory in the test and jpackage fails\n-                    \/\/ if --input references non existent directory.\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    addSignOptions(cmd, keychain, signCert.value());\n-                })\n-                .addInstallVerifier(cmd -> {\n-                    final var certIndex = Stream.of(signCert, jdkBundleCert)\n-                            .filter(Predicate.isEqual(SigningBase.CertIndex.INVALID_INDEX).negate())\n-                            .findFirst().orElse(SigningBase.CertIndex.INVALID_INDEX).value();\n-\n-                    final var signed = certIndex != SigningBase.CertIndex.INVALID_INDEX.value();\n-\n-                    final var unfoldedBundleDir = cmd.appRuntimeDirectory();\n-\n-                    final var libjli = unfoldedBundleDir.resolve(\"Contents\/MacOS\/libjli.dylib\");\n-\n-                    SigningBase.verifyCodesign(libjli, signed, certIndex);\n-                    SigningBase.verifyCodesign(unfoldedBundleDir, signed, certIndex);\n-                    if (signed) {\n-                        SigningBase.verifySpctl(unfoldedBundleDir, \"exec\", certIndex);\n-                    }\n-                })\n-                .run();\n+    private static Path createRuntime(Optional<SignKeyOptionWithKeychain> signRuntime, RuntimeType runtimeType) {\n+        if (runtimeType == RuntimeType.IMAGE && signRuntime.isEmpty()) {\n+            return JPackageCommand.createInputRuntimeImage(RUNTIME_TYPE_FAKE);\n+        } else {\n+            Slot<Path> runtimeBundle = Slot.createEmpty();\n+\n+            MacSign.withKeychain(keychain -> {\n+                var runtimeBundleBuilder = MacHelper.buildRuntimeBundle();\n+                signRuntime.ifPresent(signingOption -> {\n+                    runtimeBundleBuilder.mutator(signingOption::setTo);\n+                });\n+                runtimeBundle.set(runtimeBundleBuilder.type(RUNTIME_TYPE_FAKE).create());\n+            }, SigningBase.StandardKeychain.MAIN.keychain());\n+\n+            if (runtimeType == RuntimeType.IMAGE) {\n+                return MacBundle.fromPath(runtimeBundle.get()).orElseThrow().homeDir();\n+            } else {\n+                \/\/ Verify the runtime bundle is properly signed\/unsigned.\n+                signRuntime.map(SignKeyOptionWithKeychain::certRequest).ifPresentOrElse(certRequest -> {\n+                    MacSignVerify.assertSigned(runtimeBundle.get(), certRequest);\n+                    var signOrigin = MacSignVerify.findSpctlSignOrigin(SpctlType.EXEC, runtimeBundle.get()).orElse(null);\n+                    TKit.assertEquals(certRequest.name(), signOrigin,\n+                            String.format(\"Check [%s] has sign origin as expected\", runtimeBundle.get()));\n+                }, () -> {\n+                    MacSignVerify.assertAdhocSigned(runtimeBundle.get());\n+                });\n+                return runtimeBundle.get();\n+            }\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":173,"deletions":103,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -1,316 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.MacSign;\n-import jdk.jpackage.test.MacSign.CertificateRequest;\n-import jdk.jpackage.test.MacSign.CertificateType;\n-import jdk.jpackage.test.MacSign.KeychainWithCertsSpec;\n-import jdk.jpackage.test.MacSign.ResolvedKeychain;\n-import jdk.jpackage.test.MacSignVerify;\n-import jdk.jpackage.test.TKit;\n-\n-\n-\/*\n- * @test\n- * @summary Setup the environment for jpackage macos signing tests.\n- *          Creates required keychains and signing identities.\n- *          Does NOT run any jpackag tests.\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @compile -Xlint:all -Werror SigningBase.java\n- * @requires (jpackage.test.MacSignTests == \"setup\")\n- * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=SigningBase.setUp\n- *\/\n-\n-\/*\n- * @test\n- * @summary Tear down the environment for jpackage macos signing tests.\n- *          Deletes required keychains and signing identities.\n- *          Does NOT run any jpackag tests.\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @compile -Xlint:all -Werror SigningBase.java\n- * @requires (jpackage.test.MacSignTests == \"teardown\")\n- * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=SigningBase.tearDown\n- *\/\n-\n-public class SigningBase {\n-\n-    public enum StandardCertificateRequest {\n-        CODESIGN(cert().userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        CODESIGN_COPY(cert().days(100).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        CODESIGN_ACME_TECH_LTD(cert().days(100).userName(\"ACME Technologies Limited (ABC12345)\")),\n-        PKG(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        PKG_COPY(cert().type(CertificateType.INSTALLER).days(100).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        CODESIGN_UNICODE(cert().userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()])),\n-        PKG_UNICODE(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()])),\n-        CODESIGN_EXPIRED(cert().expired().userName(\"expired jpackage test\")),\n-        PKG_EXPIRED(cert().expired().type(CertificateType.INSTALLER).userName(\"expired jpackage test\"));\n-\n-        StandardCertificateRequest(CertificateRequest.Builder specBuilder) {\n-            this.spec = specBuilder.create();\n-        }\n-\n-        public CertificateRequest spec() {\n-            return spec;\n-        }\n-\n-        private static CertificateRequest.Builder cert() {\n-            return new CertificateRequest.Builder();\n-        }\n-\n-        private final CertificateRequest spec;\n-    }\n-\n-    \/**\n-     * Standard keychains used in signing tests.\n-     *\/\n-    public enum StandardKeychain {\n-        \/**\n-         * The primary keychain with good certificates.\n-         *\/\n-        MAIN(\"jpackagerTest.keychain\",\n-                StandardCertificateRequest.CODESIGN,\n-                StandardCertificateRequest.PKG,\n-                StandardCertificateRequest.CODESIGN_UNICODE,\n-                StandardCertificateRequest.PKG_UNICODE,\n-                StandardCertificateRequest.CODESIGN_ACME_TECH_LTD),\n-        \/**\n-         * A keychain with some good and some expired certificates.\n-         *\/\n-        EXPIRED(\"jpackagerTest-expired.keychain\",\n-                StandardCertificateRequest.CODESIGN,\n-                StandardCertificateRequest.PKG,\n-                StandardCertificateRequest.CODESIGN_EXPIRED,\n-                StandardCertificateRequest.PKG_EXPIRED),\n-        \/**\n-         * A keychain with duplicated certificates.\n-         *\/\n-        DUPLICATE(\"jpackagerTest-duplicate.keychain\",\n-                StandardCertificateRequest.CODESIGN,\n-                StandardCertificateRequest.PKG,\n-                StandardCertificateRequest.CODESIGN_COPY,\n-                StandardCertificateRequest.PKG_COPY);\n-\n-        StandardKeychain(String keychainName, StandardCertificateRequest... certs) {\n-            this(keychainName, certs[0].spec(), Stream.of(certs).skip(1).map(StandardCertificateRequest::spec).toArray(CertificateRequest[]::new));\n-        }\n-\n-        StandardKeychain(String keychainName, CertificateRequest cert, CertificateRequest... otherCerts) {\n-            final var builder = keychain(keychainName).addCert(cert);\n-            List.of(otherCerts).forEach(builder::addCert);\n-            this.keychain = new ResolvedKeychain(builder.create());\n-        }\n-\n-        public ResolvedKeychain keychain() {\n-            return keychain;\n-        }\n-\n-        public X509Certificate mapCertificateRequest(CertificateRequest certRequest) {\n-            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n-        }\n-\n-        private static KeychainWithCertsSpec.Builder keychain(String name) {\n-            return new KeychainWithCertsSpec.Builder().name(name);\n-        }\n-\n-        private static List<KeychainWithCertsSpec> signingEnv() {\n-            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n-        }\n-\n-        private final ResolvedKeychain keychain;\n-    }\n-\n-    public static void setUp() {\n-        MacSign.setUp(StandardKeychain.signingEnv());\n-    }\n-\n-    public static void tearDown() {\n-        MacSign.tearDown(StandardKeychain.signingEnv());\n-    }\n-\n-    public static void verifySignTestEnvReady() {\n-        if (!Inner.SIGN_ENV_READY) {\n-            TKit.throwSkippedException(new IllegalStateException(\"Misconfigured signing test environment\"));\n-        }\n-    }\n-\n-    private final class Inner {\n-        private static final boolean SIGN_ENV_READY = MacSign.isDeployed(StandardKeychain.signingEnv());\n-    }\n-\n-    enum CertIndex {\n-        ASCII_INDEX(0),\n-        UNICODE_INDEX(1),\n-        INVALID_INDEX(-1);\n-\n-        CertIndex(int value) {\n-            this.value = value;\n-        }\n-\n-        int value() {\n-            return value;\n-        }\n-\n-        private final int value;\n-    }\n-\n-    public static int DEFAULT_INDEX = 0;\n-    private static String [] DEV_NAMES = {\n-        \"jpackage.openjdk.java.net\",\n-        \"jpackage.openjdk.java.net ()\",\n-    };\n-\n-    public static String getDevName(int certIndex) {\n-        \/\/ Always use values from system properties if set\n-        String value = System.getProperty(\"jpackage.mac.signing.key.user.name\");\n-        if (value != null) {\n-            return value;\n-        }\n-\n-        return DEV_NAMES[certIndex];\n-    }\n-\n-    public static int getDevNameIndex(String devName) {\n-        return Arrays.binarySearch(DEV_NAMES, devName);\n-    }\n-\n-    public static String getAppCert(int certIndex) {\n-        return \"Developer ID Application: \" + getDevName(certIndex);\n-    }\n-\n-    public static String getInstallerCert(int certIndex) {\n-        return \"Developer ID Installer: \" + getDevName(certIndex);\n-    }\n-\n-    public static void verifyCodesign(Path target, boolean signed, int certIndex) {\n-        if (signed) {\n-            final var certRequest = getCertRequest(certIndex);\n-            MacSignVerify.assertSigned(target, certRequest);\n-        } else {\n-            MacSignVerify.assertAdhocSigned(target);\n-        }\n-    }\n-\n-    \/\/ Since we no longer have unsigned app image, but we need to check\n-    \/\/ DMG which is not adhoc or certificate signed and we cannot use verifyCodesign\n-    \/\/ for this. verifyDMG() is introduced to check that DMG is unsigned.\n-    \/\/ Should not be used to validated anything else.\n-    public static void verifyDMG(Path target) {\n-        if (!target.toString().toLowerCase().endsWith(\".dmg\")) {\n-            throw new IllegalArgumentException(\"Unexpected target: \" + target);\n-        }\n-\n-        MacSignVerify.assertUnsigned(target);\n-    }\n-\n-    public static void verifySpctl(Path target, String type, int certIndex) {\n-        final var standardCertIndex = Stream.of(CertIndex.values()).filter(v -> {\n-            return v.value() == certIndex;\n-        }).findFirst().orElseThrow();\n-\n-        final var standardType = Stream.of(MacSignVerify.SpctlType.values()).filter(v -> {\n-            return v.value().equals(type);\n-        }).findFirst().orElseThrow();\n-\n-        final String expectedSignOrigin;\n-        if (standardCertIndex == CertIndex.INVALID_INDEX) {\n-            expectedSignOrigin = null;\n-        } else if (standardType == MacSignVerify.SpctlType.EXEC) {\n-            expectedSignOrigin = getCertRequest(certIndex).name();\n-        } else if (standardType == MacSignVerify.SpctlType.INSTALL) {\n-            expectedSignOrigin = getPkgCertRequest(certIndex).name();\n-        } else {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        final var signOrigin = MacSignVerify.findSpctlSignOrigin(standardType, target).orElse(null);\n-\n-        TKit.assertEquals(signOrigin, expectedSignOrigin,\n-                String.format(\"Check [%s] has sign origin as expected\", target));\n-    }\n-\n-    public static void verifyPkgutil(Path target, boolean signed, int certIndex) {\n-        if (signed) {\n-            final var certRequest = getPkgCertRequest(certIndex);\n-            MacSignVerify.assertPkgSigned(target, certRequest, StandardKeychain.MAIN.mapCertificateRequest(certRequest));\n-        } else {\n-            MacSignVerify.assertUnsigned(target);\n-        }\n-    }\n-\n-    public static void verifyAppImageSignature(JPackageCommand appImageCmd,\n-            boolean isSigned, String... launchers) throws Exception {\n-        Path launcherPath = appImageCmd.appLauncherPath();\n-        SigningBase.verifyCodesign(launcherPath, isSigned, SigningBase.DEFAULT_INDEX);\n-\n-        final List<String> launchersList = List.of(launchers);\n-        launchersList.forEach(launcher -> {\n-            Path testALPath = launcherPath.getParent().resolve(launcher);\n-            SigningBase.verifyCodesign(testALPath, isSigned, SigningBase.DEFAULT_INDEX);\n-        });\n-\n-        Path appImage = appImageCmd.outputBundle();\n-        SigningBase.verifyCodesign(appImage, isSigned, SigningBase.DEFAULT_INDEX);\n-        if (isSigned) {\n-            SigningBase.verifySpctl(appImage, \"exec\", SigningBase.DEFAULT_INDEX);\n-        }\n-    }\n-\n-    private static CertificateRequest getCertRequest(int certIndex) {\n-        switch (CertIndex.values()[certIndex]) {\n-            case ASCII_INDEX -> {\n-                return StandardCertificateRequest.CODESIGN.spec();\n-            }\n-            case UNICODE_INDEX -> {\n-                return StandardCertificateRequest.CODESIGN_UNICODE.spec();\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-    }\n-\n-    private static CertificateRequest getPkgCertRequest(int certIndex) {\n-        switch (CertIndex.values()[certIndex]) {\n-            case ASCII_INDEX -> {\n-                return StandardCertificateRequest.PKG.spec();\n-            }\n-            case UNICODE_INDEX -> {\n-                return StandardCertificateRequest.PKG_UNICODE.spec();\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":0,"deletions":316,"binary":false,"changes":316,"status":"deleted"}]}