{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,1 +325,1 @@\n-        return ByteArray.getShort(readBuffer, 0);\n+        return ByteArray.getShortBE(readBuffer, 0);\n@@ -347,1 +347,1 @@\n-        return ByteArray.getUnsignedShort(readBuffer, 0);\n+        return ByteArray.getUnsignedShortBE(readBuffer, 0);\n@@ -369,1 +369,1 @@\n-        return ByteArray.getChar(readBuffer, 0);\n+        return ByteArray.getCharBE(readBuffer, 0);\n@@ -391,1 +391,1 @@\n-        return ByteArray.getInt(readBuffer, 0);\n+        return ByteArray.getIntBE(readBuffer, 0);\n@@ -413,1 +413,1 @@\n-        return ByteArray.getLong(readBuffer, 0);\n+        return ByteArray.getLongBE(readBuffer, 0);\n@@ -436,1 +436,1 @@\n-        return ByteArray.getFloat(readBuffer, 0);\n+        return ByteArray.getFloatBE(readBuffer, 0);\n@@ -459,1 +459,1 @@\n-        return ByteArray.getDouble(readBuffer, 0);\n+        return ByteArray.getDoubleBE(readBuffer, 0);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,1 @@\n-        ByteArray.setUnsignedShort(writeBuffer, 0, v);\n+        ByteArray.setUnsignedShortBE(writeBuffer, 0, v);\n@@ -201,1 +201,1 @@\n-        ByteArray.setUnsignedShort(writeBuffer, 0, v);\n+        ByteArray.setUnsignedShortBE(writeBuffer, 0, v);\n@@ -216,1 +216,1 @@\n-        ByteArray.setInt(writeBuffer, 0, v);\n+        ByteArray.setIntBE(writeBuffer, 0, v);\n@@ -231,1 +231,1 @@\n-        ByteArray.setLong(writeBuffer, 0, v);\n+        ByteArray.setLongBE(writeBuffer, 0, v);\n@@ -250,1 +250,1 @@\n-        ByteArray.setFloat(writeBuffer, 0, v);\n+        ByteArray.setFloatBE(writeBuffer, 0, v);\n@@ -269,1 +269,1 @@\n-        ByteArray.setDouble(writeBuffer, 0, v);\n+        ByteArray.setDoubleBE(writeBuffer, 0, v);\n@@ -309,1 +309,1 @@\n-            ByteArray.setUnsignedShort(writeBuffer, 0, v);\n+            ByteArray.setUnsignedShortBE(writeBuffer, 0, v);\n@@ -382,1 +382,1 @@\n-        ByteArray.setUnsignedShort(bytearr, count, utflen);\n+        ByteArray.setUnsignedShortBE(bytearr, count, utflen);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2543,1 +2543,1 @@\n-            return (off >= 0) ? ByteArray.getChar(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getCharBE(primValues, off) : val;\n@@ -2548,1 +2548,1 @@\n-            return (off >= 0) ? ByteArray.getShort(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getShortBE(primValues, off) : val;\n@@ -2553,1 +2553,1 @@\n-            return (off >= 0) ? ByteArray.getInt(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getIntBE(primValues, off) : val;\n@@ -2558,1 +2558,1 @@\n-            return (off >= 0) ? ByteArray.getFloat(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getFloatBE(primValues, off) : val;\n@@ -2563,1 +2563,1 @@\n-            return (off >= 0) ? ByteArray.getLong(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getLongBE(primValues, off) : val;\n@@ -2568,1 +2568,1 @@\n-            return (off >= 0) ? ByteArray.getDouble(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getDoubleBE(primValues, off) : val;\n@@ -3003,1 +3003,1 @@\n-                            int len = ByteArray.getInt(hbuf, 1);\n+                            int len = ByteArray.getIntBE(hbuf, 1);\n@@ -3302,1 +3302,1 @@\n-            char v = ByteArray.getChar(buf, pos);\n+            char v = ByteArray.getCharBE(buf, pos);\n@@ -3314,1 +3314,1 @@\n-            short v = ByteArray.getShort(buf, pos);\n+            short v = ByteArray.getShortBE(buf, pos);\n@@ -3326,1 +3326,1 @@\n-            int v = ByteArray.getShort(buf, pos) & 0xFFFF;\n+            int v = ByteArray.getShortBE(buf, pos) & 0xFFFF;\n@@ -3338,1 +3338,1 @@\n-            int v = ByteArray.getInt(buf, pos);\n+            int v = ByteArray.getIntBE(buf, pos);\n@@ -3350,1 +3350,1 @@\n-            float v = ByteArray.getFloat(buf, pos);\n+            float v = ByteArray.getFloatBE(buf, pos);\n@@ -3362,1 +3362,1 @@\n-            long v = ByteArray.getLong(buf, pos);\n+            long v = ByteArray.getLongBE(buf, pos);\n@@ -3374,1 +3374,1 @@\n-            double v = ByteArray.getDouble(buf, pos);\n+            double v = ByteArray.getDoubleBE(buf, pos);\n@@ -3433,1 +3433,1 @@\n-                    v[off++] = ByteArray.getChar(buf, pos);\n+                    v[off++] = ByteArray.getCharBE(buf, pos);\n@@ -3455,1 +3455,1 @@\n-                    v[off++] = ByteArray.getShort(buf, pos);\n+                    v[off++] = ByteArray.getShortBE(buf, pos);\n@@ -3477,1 +3477,1 @@\n-                    v[off++] = ByteArray.getInt(buf, pos);\n+                    v[off++] = ByteArray.getIntBE(buf, pos);\n@@ -3499,1 +3499,1 @@\n-                    v[off++] = ByteArray.getFloat(buf, pos);\n+                    v[off++] = ByteArray.getFloatBE(buf, pos);\n@@ -3521,1 +3521,1 @@\n-                    v[off++] = ByteArray.getLong(buf, pos);\n+                    v[off++] = ByteArray.getLongBE(buf, pos);\n@@ -3543,1 +3543,1 @@\n-                    v[off++] = ByteArray.getDouble(buf, pos);\n+                    v[off++] = ByteArray.getDoubleBE(buf, pos);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1555,1 +1555,1 @@\n-            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n+            ByteArray.setCharBE(primVals, getFieldOffset(name, Character.TYPE), val);\n@@ -1559,1 +1559,1 @@\n-            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n+            ByteArray.setShortBE(primVals, getFieldOffset(name, Short.TYPE), val);\n@@ -1563,1 +1563,1 @@\n-            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n+            ByteArray.setIntBE(primVals, getFieldOffset(name, Integer.TYPE), val);\n@@ -1567,1 +1567,1 @@\n-            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n+            ByteArray.setFloatBE(primVals, getFieldOffset(name, Float.TYPE), val);\n@@ -1571,1 +1571,1 @@\n-            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n+            ByteArray.setLongBE(primVals, getFieldOffset(name, Long.TYPE), val);\n@@ -1575,1 +1575,1 @@\n-            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n+            ByteArray.setDoubleBE(primVals, getFieldOffset(name, Double.TYPE), val);\n@@ -1817,1 +1817,1 @@\n-                ByteArray.setInt(hbuf, 1, len);\n+                ByteArray.setIntBE(hbuf, 1, len);\n@@ -1846,1 +1846,1 @@\n-                ByteArray.setChar(buf, pos, (char) v);\n+                ByteArray.setCharBE(buf, pos, (char) v);\n@@ -1855,1 +1855,1 @@\n-                ByteArray.setShort(buf, pos, (short) v);\n+                ByteArray.setShortBE(buf, pos, (short) v);\n@@ -1864,1 +1864,1 @@\n-                ByteArray.setInt(buf, pos, v);\n+                ByteArray.setIntBE(buf, pos, v);\n@@ -1873,1 +1873,1 @@\n-                ByteArray.setFloat(buf, pos, v);\n+                ByteArray.setFloatBE(buf, pos, v);\n@@ -1882,1 +1882,1 @@\n-                ByteArray.setLong(buf, pos, v);\n+                ByteArray.setLongBE(buf, pos, v);\n@@ -1891,1 +1891,1 @@\n-                ByteArray.setDouble(buf, pos, v);\n+                ByteArray.setDoubleBE(buf, pos, v);\n@@ -2004,1 +2004,1 @@\n-                        ByteArray.setChar(buf, pos, v[off++]);\n+                        ByteArray.setCharBE(buf, pos, v[off++]);\n@@ -2021,1 +2021,1 @@\n-                        ByteArray.setShort(buf, pos, v[off++]);\n+                        ByteArray.setShortBE(buf, pos, v[off++]);\n@@ -2038,1 +2038,1 @@\n-                        ByteArray.setInt(buf, pos, v[off++]);\n+                        ByteArray.setIntBE(buf, pos, v[off++]);\n@@ -2055,1 +2055,1 @@\n-                        ByteArray.setFloat(buf, pos, v[off++]);\n+                        ByteArray.setFloatBE(buf, pos, v[off++]);\n@@ -2072,1 +2072,1 @@\n-                        ByteArray.setLong(buf, pos, v[off++]);\n+                        ByteArray.setLongBE(buf, pos, v[off++]);\n@@ -2089,1 +2089,1 @@\n-                        ByteArray.setDouble(buf, pos, v[off++]);\n+                        ByteArray.setDoubleBE(buf, pos, v[off++]);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1863,6 +1863,6 @@\n-                    case 'C' -> ByteArray.setChar(buf, off, UNSAFE.getChar(obj, key));\n-                    case 'S' -> ByteArray.setShort(buf, off, UNSAFE.getShort(obj, key));\n-                    case 'I' -> ByteArray.setInt(buf, off, UNSAFE.getInt(obj, key));\n-                    case 'F' -> ByteArray.setFloat(buf, off, UNSAFE.getFloat(obj, key));\n-                    case 'J' -> ByteArray.setLong(buf, off, UNSAFE.getLong(obj, key));\n-                    case 'D' -> ByteArray.setDouble(buf, off, UNSAFE.getDouble(obj, key));\n+                    case 'C' -> ByteArray.setCharBE(buf, off, UNSAFE.getChar(obj, key));\n+                    case 'S' -> ByteArray.setShortBE(buf, off, UNSAFE.getShort(obj, key));\n+                    case 'I' -> ByteArray.setIntBE(buf, off, UNSAFE.getInt(obj, key));\n+                    case 'F' -> ByteArray.setFloatBE(buf, off, UNSAFE.getFloat(obj, key));\n+                    case 'J' -> ByteArray.setLongBE(buf, off, UNSAFE.getLong(obj, key));\n+                    case 'D' -> ByteArray.setDoubleBE(buf, off, UNSAFE.getDouble(obj, key));\n@@ -1892,6 +1892,6 @@\n-                    case 'C' -> UNSAFE.putChar(obj, key, ByteArray.getChar(buf, off));\n-                    case 'S' -> UNSAFE.putShort(obj, key, ByteArray.getShort(buf, off));\n-                    case 'I' -> UNSAFE.putInt(obj, key, ByteArray.getInt(buf, off));\n-                    case 'F' -> UNSAFE.putFloat(obj, key, ByteArray.getFloat(buf, off));\n-                    case 'J' -> UNSAFE.putLong(obj, key, ByteArray.getLong(buf, off));\n-                    case 'D' -> UNSAFE.putDouble(obj, key, ByteArray.getDouble(buf, off));\n+                    case 'C' -> UNSAFE.putChar(obj, key, ByteArray.getCharBE(buf, off));\n+                    case 'S' -> UNSAFE.putShort(obj, key, ByteArray.getShortBE(buf, off));\n+                    case 'I' -> UNSAFE.putInt(obj, key, ByteArray.getIntBE(buf, off));\n+                    case 'F' -> UNSAFE.putFloat(obj, key, ByteArray.getFloatBE(buf, off));\n+                    case 'J' -> UNSAFE.putLong(obj, key, ByteArray.getLongBE(buf, off));\n+                    case 'D' -> UNSAFE.putDouble(obj, key, ByteArray.getDoubleBE(buf, off));\n@@ -2340,6 +2340,6 @@\n-                    short.class, lkp.findStatic(ByteArray.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n-                    int.class, lkp.findStatic(ByteArray.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n-                    long.class, lkp.findStatic(ByteArray.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n-                    float.class, lkp.findStatic(ByteArray.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n-                    double.class, lkp.findStatic(ByteArray.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n-                    char.class, lkp.findStatic(ByteArray.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n+                    short.class, lkp.findStatic(ByteArray.class, \"getShortBE\", MethodType.methodType(short.class, byte[].class, int.class)),\n+                    int.class, lkp.findStatic(ByteArray.class, \"getIntBE\", MethodType.methodType(int.class, byte[].class, int.class)),\n+                    long.class, lkp.findStatic(ByteArray.class, \"getLongBE\", MethodType.methodType(long.class, byte[].class, int.class)),\n+                    float.class, lkp.findStatic(ByteArray.class, \"getFloatBE\", MethodType.methodType(float.class, byte[].class, int.class)),\n+                    double.class, lkp.findStatic(ByteArray.class, \"getDoubleBE\", MethodType.methodType(double.class, byte[].class, int.class)),\n+                    char.class, lkp.findStatic(ByteArray.class, \"getCharBE\", MethodType.methodType(char.class, byte[].class, int.class)),\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,6 +89,6 @@\n-                case 'C' -> ByteArray.setChar(bytes, offset, getField.get(fieldName, (char) 0));\n-                case 'D' -> ByteArray.setDoubleRaw(bytes, offset, getField.get(fieldName, 0.0));\n-                case 'F' -> ByteArray.setFloatRaw(bytes, offset, getField.get(fieldName, 0.0f));\n-                case 'I' -> ByteArray.setInt(bytes, offset, getField.get(fieldName, 0));\n-                case 'J' -> ByteArray.setLong(bytes, offset, getField.get(fieldName, 0L));\n-                case 'S' -> ByteArray.setShort(bytes, offset, getField.get(fieldName, (short) 0));\n+                case 'C' -> ByteArray.setCharBE(bytes, offset, getField.get(fieldName, (char) 0));\n+                case 'D' -> ByteArray.setDoubleRawBE(bytes, offset, getField.get(fieldName, 0.0));\n+                case 'F' -> ByteArray.setFloatRawBE(bytes, offset, getField.get(fieldName, 0.0f));\n+                case 'I' -> ByteArray.setIntBE(bytes, offset, getField.get(fieldName, 0));\n+                case 'J' -> ByteArray.setLongBE(bytes, offset, getField.get(fieldName, 0L));\n+                case 'S' -> ByteArray.setShortBE(bytes, offset, getField.get(fieldName, (short) 0));\n@@ -136,6 +136,6 @@\n-                case 'C' -> putField.put(fieldName, ByteArray.getChar(bytes, offset));\n-                case 'D' -> putField.put(fieldName, ByteArray.getDouble(bytes, offset));\n-                case 'F' -> putField.put(fieldName, ByteArray.getFloat(bytes, offset));\n-                case 'I' -> putField.put(fieldName, ByteArray.getInt(bytes, offset));\n-                case 'J' -> putField.put(fieldName, ByteArray.getLong(bytes, offset));\n-                case 'S' -> putField.put(fieldName, ByteArray.getShort(bytes, offset));\n+                case 'C' -> putField.put(fieldName, ByteArray.getCharBE(bytes, offset));\n+                case 'D' -> putField.put(fieldName, ByteArray.getDoubleBE(bytes, offset));\n+                case 'F' -> putField.put(fieldName, ByteArray.getFloatBE(bytes, offset));\n+                case 'I' -> putField.put(fieldName, ByteArray.getIntBE(bytes, offset));\n+                case 'J' -> putField.put(fieldName, ByteArray.getLongBE(bytes, offset));\n+                case 'S' -> putField.put(fieldName, ByteArray.getShortBE(bytes, offset));\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamReflection.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -945,1 +945,1 @@\n-        return ByteArray.getInt(buffer, 0);\n+        return ByteArray.getIntBE(buffer, 0);\n@@ -978,1 +978,1 @@\n-        return ByteArray.getLong(buffer, 0);\n+        return ByteArray.getLongBE(buffer, 0);\n@@ -1002,1 +1002,1 @@\n-        return ByteArray.getFloat(buffer, 0);\n+        return ByteArray.getFloatBE(buffer, 0);\n@@ -1026,1 +1026,1 @@\n-        return ByteArray.getDouble(buffer, 0);\n+        return ByteArray.getDoubleBE(buffer, 0);\n@@ -1165,1 +1165,1 @@\n-        ByteArray.setInt(buffer, 0, v);\n+        ByteArray.setIntBE(buffer, 0, v);\n@@ -1178,1 +1178,1 @@\n-        ByteArray.setLong(buffer, 0, v);\n+        ByteArray.setLongBE(buffer, 0, v);\n@@ -1194,1 +1194,1 @@\n-        ByteArray.setFloat(buffer, 0, v);\n+        ByteArray.setFloatBE(buffer, 0, v);\n@@ -1210,1 +1210,1 @@\n-        ByteArray.setDouble(buffer, 0, v);\n+        ByteArray.setDoubleBE(buffer, 0, v);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -122,8 +123,1 @@\n-#if[floatingPoint]\n-            $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(\n-                    ba,\n-                    ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,\n-                    handle.be);\n-            return $Type$.$rawType$BitsTo$Type$(rawValue);\n-#else[floatingPoint]\n-            return UNSAFE.get$Type$Unaligned(\n+            return ByteArray.get$Type$BO(\n@@ -131,1 +125,1 @@\n-                    ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,\n+                    index,\n@@ -133,1 +127,0 @@\n-#end[floatingPoint]\n@@ -140,2 +133,1 @@\n-#if[floatingPoint]\n-            UNSAFE.put$RawType$Unaligned(\n+            ByteArray.set$Type${#if[floatingPoint]?Raw}BO(\n@@ -143,10 +135,3 @@\n-                    ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,\n-                    $Type$.$type$ToRaw$RawType$Bits(value),\n-                    handle.be);\n-#else[floatingPoint]\n-            UNSAFE.put$RawType$Unaligned(\n-                    ba,\n-                    ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,\n-                    value,\n-                    handle.be);\n-#end[floatingPoint]\n+                    index,\n+                    handle.be,\n+                    value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.internal.util.Preconditions;\n+import jdk.internal.util.ByteArray;\n@@ -174,4 +174,1 @@\n-        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkIndex(off + 1, b.length, Preconditions.AIOOBE_FORMATTER);\n-        return Short.toUnsignedInt(\n-                UNSAFE.getShortUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n+        return ByteArray.getUnsignedShortLE(b, off);\n@@ -185,4 +182,1 @@\n-        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n-        return Integer.toUnsignedLong(\n-                UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n+        return Integer.toUnsignedLong(ByteArray.getIntLE(b, off));\n@@ -196,3 +190,1 @@\n-        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkIndex(off + 7, b.length, Preconditions.AIOOBE_FORMATTER);\n-        return UNSAFE.getLongUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n+        return ByteArray.getLongLE(b, off);\n@@ -207,3 +199,1 @@\n-        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n-        return UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n+        return ByteArray.getIntLE(b, off);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import static jdk.internal.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+import static jdk.internal.util.ArraysSupport.U;\n@@ -33,2 +32,1 @@\n- * Utility methods for packing\/unpacking primitive values in\/out of byte arrays\n- * using {@linkplain ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n+ * Utility methods for packing\/unpacking primitive values in\/out of byte arrays.\n@@ -36,2 +34,10 @@\n- * All methods in this class will throw an {@linkplain NullPointerException} if {@code null} is\n- * passed in as a method parameter for a byte array.\n+ * All methods perform checked access, throwing NPE for null arrays or AIOOBE\n+ * if the start index of the access will cause out of bounds read\/write.\n+ * <p>\n+ * Methods are grouped into 4 categories: BO for explicit byte order, BE for\n+ * big endian, LE for little endian, and there are boolean access methods that\n+ * does not depend on byte order.\n+ * <p>\n+ * Types supported including non-byte primitives numbers (char, short, int,\n+ * float, long, double), raw float\/double writes with special NaN treatment,\n+ * unsigned shorts (u2), and single-byte boolean checking != 0.\n@@ -44,21 +50,213 @@\n-    private static final VarHandle SHORT = create(short[].class);\n-    private static final VarHandle CHAR = create(char[].class);\n-    private static final VarHandle INT = create(int[].class);\n-    private static final VarHandle FLOAT = create(float[].class);\n-    private static final VarHandle LONG = create(long[].class);\n-    private static final VarHandle DOUBLE = create(double[].class);\n-\n-    \/*\n-     * Methods for unpacking primitive values from byte arrays starting at\n-     * a given offset.\n-     *\/\n-\n-    \/**\n-     * {@return a {@code boolean} from the provided {@code array} at the given {@code offset}}.\n-     *\n-     * @param array  to read a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 1]\n-     * @see #setBoolean(byte[], int, boolean)\n-     *\/\n+    \/\/ Basic types with Byte Order\n+\n+    public static char getCharBO(byte[] array, int index, boolean big) {\n+        Preconditions.checkIndex(index, array.length - Character.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        return U.getCharUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, big);\n+    }\n+\n+    public static short getShortBO(byte[] array, int index, boolean big) {\n+        Preconditions.checkIndex(index, array.length - Short.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        return U.getShortUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, big);\n+    }\n+\n+    public static int getIntBO(byte[] array, int index, boolean big) {\n+        Preconditions.checkIndex(index, array.length - Integer.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        return U.getIntUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, big);\n+    }\n+\n+    public static long getLongBO(byte[] array, int index, boolean big) {\n+        Preconditions.checkIndex(index, array.length - Long.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        return U.getLongUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, big);\n+    }\n+\n+    public static void setCharBO(byte[] array, int index, boolean big, char value) {\n+        Preconditions.checkIndex(index, array.length - Character.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        U.putCharUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, value, big);\n+    }\n+\n+    public static void setShortBO(byte[] array, int index, boolean big, short value) {\n+        Preconditions.checkIndex(index, array.length - Short.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        U.putShortUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, value, big);\n+    }\n+\n+    public static void setIntBO(byte[] array, int index, boolean big, int value) {\n+        Preconditions.checkIndex(index, array.length - Integer.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        U.putIntUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, value, big);\n+    }\n+\n+    public static void setLongBO(byte[] array, int index, boolean big, long value) {\n+        Preconditions.checkIndex(index, array.length - Long.BYTES + 1, Preconditions.AIOOBE_FORMATTER);\n+        U.putLongUnaligned(array, ARRAY_BYTE_BASE_OFFSET + index, value, big);\n+    }\n+\n+    \/\/ Derived types with Byte Order\n+\n+    public static float getFloatBO(byte[] array, int index, boolean big) {\n+        return Float.intBitsToFloat(getIntBO(array, index, big));\n+    }\n+\n+    public static double getDoubleBO(byte[] array, int index, boolean big) {\n+        return Double.longBitsToDouble(getLongBO(array, index, big));\n+    }\n+\n+    \/\/ Retains custom NaNs\n+    public static void setFloatRawBO(byte[] array, int index, boolean big, float value) {\n+        setIntBO(array, index, big, Float.floatToRawIntBits(value));\n+    }\n+\n+    public static void setDoubleRawBO(byte[] array, int index, boolean big, double value) {\n+        setLongBO(array, index, big, Double.doubleToRawLongBits(value));\n+    }\n+\n+    \/\/ Collapses custom NaNs\n+    public static void setFloatBO(byte[] array, int index, boolean big, float value) {\n+        setIntBO(array, index, big, Float.floatToIntBits(value));\n+    }\n+\n+    public static void setDoubleBO(byte[] array, int index, boolean big, double value) {\n+        setLongBO(array, index, big, Double.doubleToLongBits(value));\n+    }\n+\n+    public static int getUnsignedShortBO(byte[] array, int index, boolean big) {\n+        return getCharBO(array, index, big);\n+    }\n+\n+    \/\/ Truncates most significant bits\n+    public static void setUnsignedShortBO(byte[] array, int index, boolean big, int value) {\n+        setCharBO(array, index, big, (char) value);\n+    }\n+\n+    \/\/ BE methods\n+\n+    public static char getCharBE(byte[] array, int offset) {\n+        return getCharBO(array, offset, true);\n+    }\n+\n+    public static short getShortBE(byte[] array, int offset) {\n+        return getShortBO(array, offset, true);\n+    }\n+\n+    public static int getUnsignedShortBE(byte[] array, int offset) {\n+        return getUnsignedShortBO(array, offset, true);\n+    }\n+\n+    public static int getIntBE(byte[] array, int offset) {\n+        return getIntBO(array, offset, true);\n+    }\n+\n+    public static float getFloatBE(byte[] array, int offset) {\n+        return getFloatBO(array, offset, true);\n+    }\n+\n+    public static long getLongBE(byte[] array, int offset) {\n+        return getLongBO(array, offset, true);\n+    }\n+\n+    public static double getDoubleBE(byte[] array, int offset) {\n+        return getDoubleBO(array, offset, true);\n+    }\n+\n+    public static void setCharBE(byte[] array, int offset, char value) {\n+        setCharBO(array, offset, true, value);\n+    }\n+\n+    public static void setShortBE(byte[] array, int offset, short value) {\n+        setShortBO(array, offset, true, value);\n+    }\n+\n+    public static void setUnsignedShortBE(byte[] array, int offset, int value) {\n+        setUnsignedShortBO(array, offset, true, value);\n+    }\n+\n+    public static void setIntBE(byte[] array, int offset, int value) {\n+        setIntBO(array, offset, true, value);\n+    }\n+\n+    public static void setFloatBE(byte[] array, int offset, float value) {\n+        setFloatBO(array, offset, true, value);\n+    }\n+\n+    public static void setFloatRawBE(byte[] array, int offset, float value) {\n+        setFloatRawBO(array, offset, true, value);\n+    }\n+\n+    public static void setLongBE(byte[] array, int offset, long value) {\n+        setLongBO(array, offset, true, value);\n+    }\n+\n+    public static void setDoubleBE(byte[] array, int offset, double value) {\n+        setDoubleBO(array, offset, true, value);\n+    }\n+\n+    public static void setDoubleRawBE(byte[] array, int offset, double value) {\n+        setDoubleRawBO(array, offset, true, value);\n+    }\n+\n+    \/\/ LE\n+\n+    public static char getCharLE(byte[] array, int offset) {\n+        return getCharBO(array, offset, false);\n+    }\n+\n+    public static short getShortLE(byte[] array, int offset) {\n+        return getShortBO(array, offset, false);\n+    }\n+\n+    public static int getUnsignedShortLE(byte[] array, int offset) {\n+        return getCharBO(array, offset, false);\n+    }\n+\n+    public static int getIntLE(byte[] array, int offset) {\n+        return getIntBO(array, offset, false);\n+    }\n+\n+    public static float getFloatLE(byte[] array, int offset) {\n+        return getFloatBO(array, offset, false);\n+    }\n+\n+    public static long getLongLE(byte[] array, int offset) {\n+        return getLongBO(array, offset, false);\n+    }\n+\n+    public static double getDoubleLE(byte[] array, int offset) {\n+        return getDoubleBO(array, offset, false);\n+    }\n+\n+    public static void setCharLE(byte[] array, int offset, char value) {\n+        setCharBO(array, offset, false, value);\n+    }\n+\n+    public static void setShortLE(byte[] array, int offset, short value) {\n+        setShortBO(array, offset, false, value);\n+    }\n+\n+    public static void setUnsignedShortLE(byte[] array, int offset, int value) {\n+        setUnsignedShortBO(array, offset, false, value);\n+    }\n+\n+    public static void setIntLE(byte[] array, int offset, int value) {\n+        setIntBO(array, offset, false, value);\n+    }\n+\n+    public static void setFloatLE(byte[] array, int offset, float value) {\n+        setFloatBO(array, offset, false, value);\n+    }\n+\n+    public static void setFloatRawLE(byte[] array, int offset, float value) {\n+        setFloatRawBO(array, offset, false, value);\n+    }\n+\n+    public static void setLongLE(byte[] array, int offset, long value) {\n+        setLongBO(array, offset, false, value);\n+    }\n+\n+    public static void setDoubleLE(byte[] array, int offset, double value) {\n+        setDoubleBO(array, offset, false, value);\n+    }\n+\n+    public static void setDoubleRawLE(byte[] array, int offset, double value) {\n+        setDoubleRawBO(array, offset, false, value);\n+    }\n+\n+    \/\/ boolean\n+\n@@ -69,178 +267,0 @@\n-    \/**\n-     * {@return a {@code char} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setChar(byte[], int, char)\n-     *\/\n-    public static char getChar(byte[] array, int offset) {\n-        return (char) CHAR.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code short} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @return a {@code short} from the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setShort(byte[], int, short)\n-     *\/\n-    public static short getShort(byte[] array, int offset) {\n-        return (short) SHORT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return an {@code unsigned short} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @return an {@code int} representing an unsigned short from the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setUnsignedShort(byte[], int, int)\n-     *\/\n-    public static int getUnsignedShort(byte[] array, int offset) {\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return an {@code int} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setInt(byte[], int, int)\n-     *\/\n-    public static int getInt(byte[] array, int offset) {\n-        return (int) INT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setFloat(byte[], int, float)\n-     *\/\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setFloatRaw(byte[], int, float)\n-     *\/\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code long} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setLong(byte[], int, long)\n-     *\/\n-    public static long getLong(byte[] array, int offset) {\n-        return (long) LONG.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDouble(byte[], int, double)\n-     *\/\n-    public static double getDouble(byte[] array, int offset) {\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n-    }\n-\n-    \/*\n-     * Methods for packing primitive values into byte arrays starting at a given\n-     * offset.\n-     *\/\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length]\n-     * @see #getBoolean(byte[], int)\n-     *\/\n@@ -250,174 +270,0 @@\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getChar(byte[], int)\n-     *\/\n-    public static void setChar(byte[] array, int offset, char value) {\n-        CHAR.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getShort(byte[], int)\n-     *\/\n-    public static void setShort(byte[] array, int offset, short value) {\n-        SHORT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getUnsignedShort(byte[], int)\n-     *\/\n-    public static void setUnsignedShort(byte[] array, int offset, int value) {\n-        SHORT.set(array, offset, (short) (char) value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #getInt(byte[], int)\n-     *\/\n-    public static void setInt(byte[] array, int offset, int value) {\n-        INT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getFloat(byte[], int)\n-     *\/\n-    public static void setFloat(byte[] array, int offset, float value) {\n-        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        INT.set(array, offset, Float.floatToIntBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getFloatRaw(byte[], int)\n-     *\/\n-    public static void setFloatRaw(byte[] array, int offset, float value) {\n-        \/\/ Just sets the bits as they are\n-        FLOAT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #getLong(byte[], int)\n-     *\/\n-    public static void setLong(byte[] array, int offset, long value) {\n-        LONG.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getDouble(byte[], int)\n-     *\/\n-    public static void setDouble(byte[] array, int offset, double value) {\n-        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using big endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getDoubleRaw(byte[], int)\n-     *\/\n-    public static void setDoubleRaw(byte[] array, int offset, double value) {\n-        \/\/ Just sets the bits as they are\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle create(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":227,"deletions":381,"binary":false,"changes":608,"status":"modified"},{"patch":"@@ -1,424 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-\n-\/**\n- * Utility methods for packing\/unpacking primitive values in\/out of byte arrays\n- * using {@linkplain ByteOrder#LITTLE_ENDIAN little endian order}.\n- * <p>\n- * All methods in this class will throw an {@linkplain NullPointerException} if {@code null} is\n- * passed in as a method parameter for a byte array.\n- *\/\n-public final class ByteArrayLittleEndian {\n-\n-    private ByteArrayLittleEndian() {\n-    }\n-\n-    private static final VarHandle SHORT = createLittleEndian(short[].class);\n-    private static final VarHandle CHAR = createLittleEndian(char[].class);\n-    private static final VarHandle INT = createLittleEndian(int[].class);\n-    private static final VarHandle FLOAT = createLittleEndian(float[].class);\n-    private static final VarHandle LONG = createLittleEndian(long[].class);\n-    private static final VarHandle DOUBLE = createLittleEndian(double[].class);\n-\n-    \/*\n-     * Methods for unpacking primitive values from byte arrays starting at\n-     * a given offset.\n-     *\/\n-\n-    \/**\n-     * {@return a {@code boolean} from the provided {@code array} at the given {@code offset}}.\n-     *\n-     * @param array  to read a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 1]\n-     * @see #setBoolean(byte[], int, boolean)\n-     *\/\n-    public static boolean getBoolean(byte[] array, int offset) {\n-        return array[offset] != 0;\n-    }\n-\n-    \/**\n-     * {@return a {@code char} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setChar(byte[], int, char)\n-     *\/\n-    public static char getChar(byte[] array, int offset) {\n-        return (char) CHAR.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code short} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @return a {@code short} from the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setShort(byte[], int, short)\n-     *\/\n-    public static short getShort(byte[] array, int offset) {\n-        return (short) SHORT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return an {@code unsigned short} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @return an {@code int} representing an unsigned short from the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #setUnsignedShort(byte[], int, int)\n-     *\/\n-    public static int getUnsignedShort(byte[] array, int offset) {\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return an {@code int} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setInt(byte[], int, int)\n-     *\/\n-    public static int getInt(byte[] array, int offset) {\n-        return (int) INT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setFloat(byte[], int, float)\n-     *\/\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #setFloatRaw(byte[], int, float)\n-     *\/\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code long} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setLong(byte[], int, long)\n-     *\/\n-    public static long getLong(byte[] array, int offset) {\n-        return (long) LONG.get(array, offset);\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDouble(byte[], int, double)\n-     *\/\n-    public static double getDouble(byte[] array, int offset) {\n-        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n-    }\n-\n-    \/*\n-     * Methods for packing primitive values into byte arrays starting at a given\n-     * offset.\n-     *\/\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length]\n-     * @see #getBoolean(byte[], int)\n-     *\/\n-    public static void setBoolean(byte[] array, int offset, boolean value) {\n-        array[offset] = (byte) (value ? 1 : 0);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getChar(byte[], int)\n-     *\/\n-    public static void setChar(byte[] array, int offset, char value) {\n-        CHAR.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getShort(byte[], int)\n-     *\/\n-    public static void setShort(byte[] array, int offset, short value) {\n-        SHORT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getUnsignedShort(byte[], int)\n-     *\/\n-    public static void setUnsignedShort(byte[] array, int offset, int value) {\n-        SHORT.set(array, offset, (short) (char) value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #getInt(byte[], int)\n-     *\/\n-    public static void setInt(byte[] array, int offset, int value) {\n-        INT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getFloat(byte[], int)\n-     *\/\n-    public static void setFloat(byte[] array, int offset, float value) {\n-        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        INT.set(array, offset, Float.floatToIntBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getFloatRaw(byte[], int)\n-     *\/\n-    public static void setFloatRaw(byte[] array, int offset, float value) {\n-        \/\/ Just sets the bits as they are\n-        FLOAT.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 4]\n-     * @see #getLong(byte[], int)\n-     *\/\n-    public static void setLong(byte[] array, int offset, long value) {\n-        LONG.set(array, offset, value);\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are canonized to a single NaN value.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getDouble(byte[], int)\n-     *\/\n-    public static void setDouble(byte[] array, int offset, double value) {\n-        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n-    }\n-\n-    \/**\n-     * Sets (writes) the provided {@code value} using little endian order into\n-     * the provided {@code array} beginning at the given {@code offset}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently written according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to set (write) a value into\n-     * @param offset where setting (writing) in the array should begin\n-     * @param value  value to set in the array\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 2]\n-     * @see #getDoubleRaw(byte[], int)\n-     *\/\n-    public static void setDoubleRaw(byte[] array, int offset, double value) {\n-        \/\/ Just sets the bits as they are\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle createLittleEndian(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.LITTLE_ENDIAN);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArrayLittleEndian.java","additions":0,"deletions":424,"binary":false,"changes":424,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n@@ -247,2 +246,2 @@\n-                ? ByteArray.getShort(byteBuf, 0)\n-                : ByteArrayLittleEndian.getShort(byteBuf, 0);\n+                ? ByteArray.getShortBE(byteBuf, 0)\n+                : ByteArray.getShortLE(byteBuf, 0);\n@@ -274,2 +273,2 @@\n-                ? ByteArray.getInt(byteBuf, 0)\n-                : ByteArrayLittleEndian.getInt(byteBuf, 0);\n+                ? ByteArray.getIntBE(byteBuf, 0)\n+                : ByteArray.getIntLE(byteBuf, 0);\n@@ -517,1 +516,1 @@\n-                s[off + j] = ByteArray.getShort(b, boff);\n+                s[off + j] = ByteArray.getShortBE(b, boff);\n@@ -522,1 +521,1 @@\n-                s[off + j] = ByteArrayLittleEndian.getShort(b, boff);\n+                s[off + j] = ByteArray.getShortLE(b, boff);\n@@ -532,1 +531,1 @@\n-                c[off + j] = ByteArray.getChar(b, boff);\n+                c[off + j] = ByteArray.getCharBE(b, boff);\n@@ -537,1 +536,1 @@\n-                c[off + j] = ByteArrayLittleEndian.getChar(b, boff);\n+                c[off + j] = ByteArray.getCharLE(b, boff);\n@@ -547,1 +546,1 @@\n-                i[off + j] = ByteArray.getInt(b, boff);\n+                i[off + j] = ByteArray.getIntBE(b, boff);\n@@ -552,1 +551,1 @@\n-                i[off + j] = ByteArrayLittleEndian.getInt(b, boff);\n+                i[off + j] = ByteArray.getIntLE(b, boff);\n@@ -562,1 +561,1 @@\n-                l[off + j] = ByteArray.getLong(b, boff);\n+                l[off + j] = ByteArray.getLongBE(b, boff);\n@@ -567,1 +566,1 @@\n-                l[off + j] = ByteArrayLittleEndian.getLong(b, boff);\n+                l[off + j] = ByteArray.getLongLE(b, boff);\n@@ -577,1 +576,1 @@\n-                f[off + j] = ByteArray.getFloat(b, boff);\n+                f[off + j] = ByteArray.getFloatBE(b, boff);\n@@ -582,1 +581,1 @@\n-                f[off + j] = ByteArrayLittleEndian.getFloat(b, boff);\n+                f[off + j] = ByteArray.getFloatLE(b, boff);\n@@ -592,1 +591,1 @@\n-                d[off + j] = ByteArray.getDouble(b, boff);\n+                d[off + j] = ByteArray.getDoubleBE(b, boff);\n@@ -597,1 +596,1 @@\n-                d[off + j] = ByteArrayLittleEndian.getDouble(b, boff);\n+                d[off + j] = ByteArray.getDoubleLE(b, boff);\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n@@ -69,1 +68,1 @@\n-            ByteArray.setUnsignedShort(byteBuf, 0, v);\n+            ByteArray.setUnsignedShortBE(byteBuf, 0, v);\n@@ -71,1 +70,1 @@\n-            ByteArrayLittleEndian.setUnsignedShort(byteBuf, 0, v);\n+            ByteArray.setUnsignedShortLE(byteBuf, 0, v);\n@@ -82,1 +81,1 @@\n-            ByteArray.setInt(byteBuf, 0, v);\n+            ByteArray.setIntBE(byteBuf, 0, v);\n@@ -84,1 +83,1 @@\n-            ByteArrayLittleEndian.setInt(byteBuf, 0, v);\n+            ByteArray.setIntLE(byteBuf, 0, v);\n@@ -91,1 +90,1 @@\n-            ByteArray.setLong(byteBuf, 0, v);\n+            ByteArray.setLongBE(byteBuf, 0, v);\n@@ -93,1 +92,1 @@\n-            ByteArrayLittleEndian.setLong(byteBuf, 0, v);\n+            ByteArray.setLongLE(byteBuf, 0, v);\n@@ -126,1 +125,1 @@\n-                ByteArray.setChar(b, boff, v);\n+                ByteArray.setCharBE(b, boff, v);\n@@ -132,1 +131,1 @@\n-                ByteArrayLittleEndian.setChar(b, boff, v);\n+                ByteArray.setCharLE(b, boff, v);\n@@ -197,1 +196,1 @@\n-                ByteArray.setShort(b, boff, v);\n+                ByteArray.setShortBE(b, boff, v);\n@@ -203,1 +202,1 @@\n-                ByteArrayLittleEndian.setShort(b, boff, v);\n+                ByteArray.setShortLE(b, boff, v);\n@@ -223,1 +222,1 @@\n-                ByteArray.setChar(b, boff, v);\n+                ByteArray.setCharBE(b, boff, v);\n@@ -229,1 +228,1 @@\n-                ByteArrayLittleEndian.setChar(b, boff, v);\n+                ByteArray.setCharLE(b, boff, v);\n@@ -249,1 +248,1 @@\n-                ByteArray.setInt(b, boff, v);\n+                ByteArray.setIntBE(b, boff, v);\n@@ -255,1 +254,1 @@\n-                ByteArrayLittleEndian.setInt(b, boff, v);\n+                ByteArray.setIntLE(b, boff, v);\n@@ -275,1 +274,1 @@\n-                ByteArray.setLong(b, boff, v);\n+                ByteArray.setLongBE(b, boff, v);\n@@ -281,1 +280,1 @@\n-                ByteArrayLittleEndian.setLong(b, boff, v);\n+                ByteArray.setLongLE(b, boff, v);\n@@ -301,1 +300,1 @@\n-                ByteArray.setFloat(b, boff, v);\n+                ByteArray.setFloatBE(b, boff, v);\n@@ -307,1 +306,1 @@\n-                ByteArrayLittleEndian.setFloat(b, boff, v);\n+                ByteArray.setFloatLE(b, boff, v);\n@@ -327,1 +326,1 @@\n-                ByteArray.setDouble(b, boff, v);\n+                ByteArray.setDoubleBE(b, boff, v);\n@@ -333,1 +332,1 @@\n-                ByteArrayLittleEndian.setDouble(b, boff, v);\n+                ByteArray.setDoubleLE(b, boff, v);\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageOutputStreamImpl.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299576\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @run junit LegacyBits\n+ *\/\n+\n+import jdk.internal.util.ByteArray;\n+import org.junit.jupiter.api.*;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class LegacyBits {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, OFFSET, expected);\n+            short actual = ByteArray.getShortBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            ByteArray.setShortBE(BUFF, OFFSET, expected);\n+            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, OFFSET, expected);\n+            char actual = ByteArray.getCharBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            ByteArray.setCharBE(BUFF, OFFSET, expected);\n+            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, OFFSET, expected);\n+            int actual = ByteArray.getIntBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            ByteArray.setIntBE(BUFF, OFFSET, expected);\n+            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, OFFSET, expected);\n+            long actual = ByteArray.getLongBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            ByteArray.setLongBE(BUFF, OFFSET, expected);\n+            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, OFFSET, expected);\n+            float actual = ByteArray.getFloatBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        floats().forEach(expected -> {\n+            ByteArray.setFloatBE(BUFF, OFFSET, expected);\n+            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, OFFSET, expected);\n+            double actual = ByteArray.getDoubleBE(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            ByteArray.setDoubleBE(BUFF, OFFSET, expected);\n+            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutUnsignedShort() {\n+        longs().forEach(l -> {\n+            int expected = Short.toUnsignedInt((short) l);\n+            ByteArray.setUnsignedShortBE(BUFF, OFFSET, expected);\n+            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getIntBE(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setIntBE(null, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getIntBE(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setIntBE(BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getIntBE(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setIntBE(BUFF, BUFF.length, 1));\n+    }\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return DoubleStream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS),\n+                DoubleStream.of(Double.NaN,\n+                        Double.NEGATIVE_INFINITY,\n+                        Double.POSITIVE_INFINITY,\n+                        Double.MAX_VALUE,\n+                        Double.MIN_VALUE,\n+                        -0.0d\n+                        +0.0d)\n+        );\n+    }\n+    static Stream<Float> floats() {\n+        return Stream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n+                Stream.of(Float.NaN,\n+                        Float.NEGATIVE_INFINITY,\n+                        Float.POSITIVE_INFINITY,\n+                        Float.MAX_VALUE,\n+                        Float.MIN_VALUE,\n+                        -0.0f\n+                        +0.0f)\n+        );\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/**\n+    * Reference implementation from the old java.io.Bits implementation\n+    *\/\n+    private static final class RefImpl {\n+        private RefImpl() {}\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return ((b[off + 3] & 0xFF)) +\n+                    ((b[off + 2] & 0xFF) << 8) +\n+                    ((b[off + 1] & 0xFF) << 16) +\n+                    ((b[off]) << 24);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return ((b[off + 7] & 0xFFL)) +\n+                    ((b[off + 6] & 0xFFL) << 8) +\n+                    ((b[off + 5] & 0xFFL) << 16) +\n+                    ((b[off + 4] & 0xFFL) << 24) +\n+                    ((b[off + 3] & 0xFFL) << 32) +\n+                    ((b[off + 2] & 0xFFL) << 40) +\n+                    ((b[off + 1] & 0xFFL) << 48) +\n+                    (((long) b[off]) << 56);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            b[off + 3] = (byte) (val);\n+            b[off + 2] = (byte) (val >>> 8);\n+            b[off + 1] = (byte) (val >>> 16);\n+            b[off] = (byte) (val >>> 24);\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            putInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            b[off + 7] = (byte) (val);\n+            b[off + 6] = (byte) (val >>> 8);\n+            b[off + 5] = (byte) (val >>> 16);\n+            b[off + 4] = (byte) (val >>> 24);\n+            b[off + 3] = (byte) (val >>> 32);\n+            b[off + 2] = (byte) (val >>> 40);\n+            b[off + 1] = (byte) (val >>> 48);\n+            b[off] = (byte) (val >>> 56);\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            putLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/LegacyBits.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8299576\n- * @modules java.base\/jdk.internal.util\n- * @summary Verify that reads and writes of primitives are correct\n- * @run junit ReadWriteValues\n- *\/\n-\n-import jdk.internal.util.ByteArray;\n-import org.junit.jupiter.api.*;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.DoubleStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class ReadWriteValues {\n-\n-    \/\/ Makes sure unaligned read\/write can be made.\n-    private static final int OFFSET = 1;\n-\n-    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n-\n-    private static final int ITERATIONS = 1 << 10;\n-\n-    @Test\n-    void testGetShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            RefImpl.putShort(BUFF, OFFSET, expected);\n-            short actual = ByteArray.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutShort() {\n-        longs().forEach(l -> {\n-            short expected = (short) l;\n-            ByteArray.setShort(BUFF, OFFSET, expected);\n-            short actual = RefImpl.getShort(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            RefImpl.putChar(BUFF, OFFSET, expected);\n-            char actual = ByteArray.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutChar() {\n-        longs().forEach(l -> {\n-            char expected = (char) l;\n-            ByteArray.setChar(BUFF, OFFSET, expected);\n-            char actual = RefImpl.getChar(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            RefImpl.putInt(BUFF, OFFSET, expected);\n-            int actual = ByteArray.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutInt() {\n-        longs().forEach(l -> {\n-            int expected = (int) l;\n-            ByteArray.setInt(BUFF, OFFSET, expected);\n-            int actual = RefImpl.getInt(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetLong() {\n-        longs().forEach(expected -> {\n-            RefImpl.putLong(BUFF, OFFSET, expected);\n-            long actual = ByteArray.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutLong() {\n-        longs().forEach(expected -> {\n-            ByteArray.setLong(BUFF, OFFSET, expected);\n-            long actual = RefImpl.getLong(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetFloat() {\n-        floats().forEach(expected -> {\n-            RefImpl.putFloat(BUFF, OFFSET, expected);\n-            float actual = ByteArray.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutFloat() {\n-        floats().forEach(expected -> {\n-            ByteArray.setFloat(BUFF, OFFSET, expected);\n-            float actual = RefImpl.getFloat(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testGetDouble() {\n-        doubles().forEach(expected -> {\n-            RefImpl.putDouble(BUFF, OFFSET, expected);\n-            double actual = ByteArray.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutDouble() {\n-        doubles().forEach(expected -> {\n-            ByteArray.setDouble(BUFF, OFFSET, expected);\n-            double actual = RefImpl.getDouble(BUFF, OFFSET);\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    @Test\n-    void testPutUnsignedShort() {\n-        longs().forEach(l -> {\n-            int expected = Short.toUnsignedInt((short) l);\n-            ByteArray.setUnsignedShort(BUFF, OFFSET, expected);\n-            int actual = Short.toUnsignedInt(RefImpl.getShort(BUFF, OFFSET));\n-            assertEquals(expected, actual);\n-        });\n-    }\n-\n-    \/\/ Unusual cases\n-\n-    @Test\n-    void testNullArray() {\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.getInt(null, OFFSET));\n-        assertThrowsOriginal(NullPointerException.class, () -> ByteArray.setInt(null, OFFSET, 1));\n-    }\n-\n-    @Test\n-    void testNegArg() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, -1));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, -1, 1));\n-    }\n-\n-    @Test\n-    void testOutOfBounds() {\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.getInt(BUFF, BUFF.length));\n-        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> ByteArray.setInt(BUFF, BUFF.length, 1));\n-    }\n-\n-    static LongStream longs() {\n-        return ThreadLocalRandom.current().longs(ITERATIONS);\n-    }\n-\n-    static DoubleStream doubles() {\n-        return DoubleStream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS),\n-                DoubleStream.of(Double.NaN,\n-                        Double.NEGATIVE_INFINITY,\n-                        Double.POSITIVE_INFINITY,\n-                        Double.MAX_VALUE,\n-                        Double.MIN_VALUE,\n-                        -0.0d\n-                        +0.0d)\n-        );\n-    }\n-    static Stream<Float> floats() {\n-        return Stream.concat(\n-                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n-                Stream.of(Float.NaN,\n-                        Float.NEGATIVE_INFINITY,\n-                        Float.POSITIVE_INFINITY,\n-                        Float.MAX_VALUE,\n-                        Float.MIN_VALUE,\n-                        -0.0f\n-                        +0.0f)\n-        );\n-    }\n-\n-    @FunctionalInterface\n-    interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n-                                                    ThrowingRunnable runnable) {\n-        try {\n-            runnable.run();\n-        } catch (Exception e) {\n-            if (type.isInstance(e)) {\n-                return;\n-            }\n-            if (type.isInstance(e.getCause())) {\n-                return;\n-            }\n-            throw new AssertionError(e);\n-        }\n-\n-    }\n-\n-    \/**\n-    * Reference implementation from the old java.io.Bits implementation\n-    *\/\n-    private static final class RefImpl {\n-        private RefImpl() {}\n-\n-        static char getChar(byte[] b, int off) {\n-            return (char) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static short getShort(byte[] b, int off) {\n-            return (short) ((b[off + 1] & 0xFF) +\n-                    (b[off] << 8));\n-        }\n-\n-        static int getInt(byte[] b, int off) {\n-            return ((b[off + 3] & 0xFF)) +\n-                    ((b[off + 2] & 0xFF) << 8) +\n-                    ((b[off + 1] & 0xFF) << 16) +\n-                    ((b[off]) << 24);\n-        }\n-\n-        static float getFloat(byte[] b, int off) {\n-            return Float.intBitsToFloat(getInt(b, off));\n-        }\n-\n-        static long getLong(byte[] b, int off) {\n-            return ((b[off + 7] & 0xFFL)) +\n-                    ((b[off + 6] & 0xFFL) << 8) +\n-                    ((b[off + 5] & 0xFFL) << 16) +\n-                    ((b[off + 4] & 0xFFL) << 24) +\n-                    ((b[off + 3] & 0xFFL) << 32) +\n-                    ((b[off + 2] & 0xFFL) << 40) +\n-                    ((b[off + 1] & 0xFFL) << 48) +\n-                    (((long) b[off]) << 56);\n-        }\n-\n-        static double getDouble(byte[] b, int off) {\n-            return Double.longBitsToDouble(getLong(b, off));\n-        }\n-\n-        \/*\n-         * Methods for packing primitive values into byte arrays starting at given\n-         * offsets.\n-         *\/\n-\n-        static void putChar(byte[] b, int off, char val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putShort(byte[] b, int off, short val) {\n-            b[off + 1] = (byte) (val);\n-            b[off] = (byte) (val >>> 8);\n-        }\n-\n-        static void putInt(byte[] b, int off, int val) {\n-            b[off + 3] = (byte) (val);\n-            b[off + 2] = (byte) (val >>> 8);\n-            b[off + 1] = (byte) (val >>> 16);\n-            b[off] = (byte) (val >>> 24);\n-        }\n-\n-        static void putFloat(byte[] b, int off, float val) {\n-            putInt(b, off, Float.floatToIntBits(val));\n-        }\n-\n-        static void putLong(byte[] b, int off, long val) {\n-            b[off + 7] = (byte) (val);\n-            b[off + 6] = (byte) (val >>> 8);\n-            b[off + 5] = (byte) (val >>> 16);\n-            b[off + 4] = (byte) (val >>> 24);\n-            b[off + 3] = (byte) (val >>> 32);\n-            b[off + 2] = (byte) (val >>> 40);\n-            b[off + 1] = (byte) (val >>> 48);\n-            b[off] = (byte) (val >>> 56);\n-        }\n-\n-        static void putDouble(byte[] b, int off, double val) {\n-            putLong(b, off, Double.doubleToLongBits(val));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/ReadWriteValues.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349503\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Basic contracts for ByteArray types and functionalities\n+ * @run junit Types\n+ *\/\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.util.ByteArray;\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class Types {\n+\n+    interface OrderedReader<T> {\n+        T get(byte[] array, int index, boolean big);\n+    }\n+\n+    interface Reader<T> {\n+        T get(byte[] array, int index);\n+    }\n+\n+    record ReadCase<T>(String name, OrderedReader<T> orderedReader, Reader<T> beReader, Reader<T> leReader, int bytesCount, UnaryOperator<T> reverse, Comparator<T> comparator) {}\n+\n+    static Stream<ReadCase<?>> readCases() {\n+        return Stream.of(\n+                new ReadCase<>(\"char\", ByteArray::getCharBO, ByteArray::getCharBE, ByteArray::getCharLE, Character.BYTES, Character::reverseBytes, Comparator.naturalOrder()),\n+                new ReadCase<>(\"short\", ByteArray::getShortBO, ByteArray::getShortBE, ByteArray::getShortLE, Short.BYTES, Short::reverseBytes, Comparator.naturalOrder()),\n+                new ReadCase<>(\"u2\", ByteArray::getUnsignedShortBO, ByteArray::getUnsignedShortBE, ByteArray::getUnsignedShortLE, 2, u2 -> ((u2 >> Byte.SIZE) & 0xFF) | ((u2 << Byte.SIZE) & 0xFF00), Comparator.naturalOrder()),\n+                new ReadCase<>(\"int\", ByteArray::getIntBO, ByteArray::getIntBE, ByteArray::getIntLE, Integer.BYTES, Integer::reverseBytes, Comparator.naturalOrder()),\n+                new ReadCase<>(\"float\", ByteArray::getFloatBO, ByteArray::getFloatBE, ByteArray::getFloatLE, Float.BYTES, null, Comparator.comparing(Float::floatToRawIntBits)),\n+                new ReadCase<>(\"long\", ByteArray::getLongBO, ByteArray::getLongBE, ByteArray::getLongLE, Long.BYTES, Long::reverseBytes, Comparator.naturalOrder()),\n+                new ReadCase<>(\"double\", ByteArray::getDoubleBO, ByteArray::getDoubleBE, ByteArray::getDoubleLE, Double.BYTES, null, Comparator.comparing(Double::doubleToRawLongBits))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"readCases\")\n+    <T> void testReadType(ReadCase<T> in) {\n+        OrderedReader<T> orderedReader = in.orderedReader;\n+        Reader<T> beReader = in.beReader;\n+        Reader<T> leReader = in.leReader;\n+        int size = in.bytesCount;\n+        UnaryOperator<T> reverse = in.reverse;\n+        Comparator<T> comparator = in.comparator;\n+        int arrayLen = 128;\n+        byte[] arr = new byte[arrayLen];\n+\n+        assertThrows(NullPointerException.class, () -> orderedReader.get(null, 0, true));\n+        assertThrows(NullPointerException.class, () -> beReader.get(null, 0));\n+        assertThrows(NullPointerException.class, () -> leReader.get(null, 0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> orderedReader.get(arr, -1, false));\n+        assertThrows(IndexOutOfBoundsException.class, () -> beReader.get(arr, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> leReader.get(arr, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> orderedReader.get(arr, arrayLen - size + 1, false));\n+        assertThrows(IndexOutOfBoundsException.class, () -> beReader.get(arr, arrayLen - size + 1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> leReader.get(arr, arrayLen - size + 1));\n+\n+        Random random = RandomFactory.getRandom();\n+        random.nextBytes(arr);\n+        for (int index = 0; index + size <= arrayLen; index += random.nextInt(1, 33)) {\n+            T be = beReader.get(arr, index);\n+            T le = leReader.get(arr, index);\n+            T beO = orderedReader.get(arr, index, true);\n+            T leO = orderedReader.get(arr, index, false);\n+            assertEquals(0, comparator.compare(be, beO));\n+            assertEquals(0, comparator.compare(le, leO));\n+            if (reverse != null) {\n+                assertEquals(0, comparator.compare(reverse.apply(be), le));\n+            }\n+        }\n+    }\n+\n+    interface OrderedWriter<T> {\n+        void set(byte[] array, int index, boolean big, T value);\n+    }\n+\n+    interface Writer<T> {\n+        void set(byte[] array, int index, T value);\n+    }\n+\n+    record WriteCase<T>(String name, OrderedWriter<T> orderedWriter, Writer<T> beWriter, Writer<T> leWriter, int bytesCount, List<T> equalValues) {}\n+\n+    static Stream<WriteCase<?>> writeCases() {\n+        return Stream.of(\n+                new WriteCase<>(\"char\", ByteArray::setCharBO, ByteArray::setCharBE, ByteArray::setCharLE, Character.BYTES, List.of('e')),\n+                new WriteCase<>(\"short\", ByteArray::setShortBO, ByteArray::setShortBE, ByteArray::setShortLE, Short.BYTES, List.of((short) 56)),\n+                new WriteCase<>(\"u2\", ByteArray::setUnsignedShortBO, ByteArray::setUnsignedShortBE, ByteArray::setUnsignedShortLE, 2, List.of(32768, -32768)),\n+                new WriteCase<>(\"int\", ByteArray::setIntBO, ByteArray::setIntBE, ByteArray::setIntLE, Integer.BYTES, List.of(42)),\n+                new WriteCase<>(\"float\", ByteArray::setFloatBO, ByteArray::setFloatBE, ByteArray::setFloatLE, Float.BYTES, List.of(Float.NaN, Float.intBitsToFloat(0x7FF23847))),\n+                new WriteCase<>(\"float raw\", ByteArray::setFloatRawBO, ByteArray::setFloatRawBE, ByteArray::setFloatRawLE, Float.BYTES, List.of(1.0F)),\n+                new WriteCase<>(\"long\", ByteArray::setLongBO, ByteArray::setLongBE, ByteArray::setLongLE, Long.BYTES, List.of(233748579238L)),\n+                new WriteCase<>(\"double\", ByteArray::setDoubleBO, ByteArray::setDoubleBE, ByteArray::setDoubleLE, Double.BYTES, List.of(Double.NaN, Double.longBitsToDouble(0x7FFF_FFFF_0000_FFFFL))),\n+                new WriteCase<>(\"double raw\", ByteArray::setDoubleRawBO, ByteArray::setDoubleRawBE, ByteArray::setDoubleRawLE, Double.BYTES, List.of(1.1D + 2.3D))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"writeCases\")\n+    <T> void testWriteType(WriteCase<T> in) {\n+        OrderedWriter<T> orderedWriter = in.orderedWriter;\n+        Writer<T> beWriter = in.beWriter;\n+        Writer<T> leWriter = in.leWriter;\n+        int size = in.bytesCount;\n+        T value = in.equalValues.getFirst();\n+        int arrayLen = 25;\n+        byte[] arr = new byte[arrayLen];\n+\n+        assertThrows(NullPointerException.class, () -> orderedWriter.set(null, 0, true, value));\n+        assertThrows(NullPointerException.class, () -> beWriter.set(null, 0, value));\n+        assertThrows(NullPointerException.class, () -> leWriter.set(null, 0, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> orderedWriter.set(arr, -1, false, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> beWriter.set(arr, -1, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> leWriter.set(arr, -1, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> orderedWriter.set(arr, arrayLen - size + 1, false, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> beWriter.set(arr, arrayLen - size + 1, value));\n+        assertThrows(IndexOutOfBoundsException.class, () -> leWriter.set(arr, arrayLen - size + 1, value));\n+\n+        int index = 0;\n+        var arrBe = arr.clone();\n+        var arrLe = arr.clone();\n+        var arrBeO = arr.clone();\n+        var arrLeO = arr.clone();\n+        beWriter.set(arrBe, index, value);\n+        leWriter.set(arrLe, index, value);\n+        orderedWriter.set(arrBeO, index, true, value);\n+        orderedWriter.set(arrLeO, index, false, value);\n+\n+        assertArrayEquals(arrBe, arrBeO);\n+        assertArrayEquals(arrLe, arrLeO);\n+        var arrBeR = arrBe.clone();\n+        reverseRegion(arrBeR, index, size);\n+        assertArrayEquals(arrLe, arrBeR);\n+\n+        for (int i = 1; i < in.equalValues.size(); i++) {\n+            T v1 = in.equalValues.get(i);\n+\n+            var arrBe1 = arr.clone();\n+            beWriter.set(arrBe1, index, v1);\n+            assertArrayEquals(arrBe, arrBe1);\n+        }\n+    }\n+\n+    private static void reverseRegion(byte[] arr, int start, int size) {\n+        for (int i = start, j = start + size - 1; i < j; i++, j--) {\n+            byte t = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = t;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ByteArray\/Types.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -39,1 +40,1 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n+\n@@ -174,1 +175,1 @@\n-        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        ByteArray.setShortLE(aB, offset, (short)0x0201);\n@@ -200,1 +201,1 @@\n-        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        ByteArray.setShortLE(aB, offset, (short)0x0201);\n@@ -228,1 +229,1 @@\n-        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        ByteArray.setShortLE(aB, offset, vS);\n@@ -254,1 +255,1 @@\n-        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        ByteArray.setShortLE(aB, offset, vS);\n@@ -304,1 +305,1 @@\n-        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        ByteArray.setIntLE(aB, offset, 0x04030201);\n@@ -332,1 +333,1 @@\n-        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        ByteArray.setIntLE(aB, offset, 0x04030201);\n@@ -362,1 +363,1 @@\n-        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        ByteArray.setIntLE(aB, offset, vI);\n@@ -390,1 +391,1 @@\n-        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        ByteArray.setIntLE(aB, offset, vI);\n@@ -452,1 +453,1 @@\n-        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        ByteArray.setLongLE(aB, offset, 0x0807060504030201L);\n@@ -484,1 +485,1 @@\n-        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        ByteArray.setLongLE(aB, offset, 0x0807060504030201L);\n@@ -518,1 +519,1 @@\n-        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        ByteArray.setLongLE(aB, offset, vL);\n@@ -550,1 +551,1 @@\n-        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        ByteArray.setLongLE(aB, offset, vL);\n@@ -585,2 +586,2 @@\n-        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n-        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        ByteArray.setIntLE(aB, offset + 0, vI);\n+        ByteArray.setIntLE(aB, offset + 4, vI);\n@@ -620,2 +621,2 @@\n-        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n-        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        ByteArray.setIntLE(aB, offset + 0, vI);\n+        ByteArray.setIntLE(aB, offset + 4, vI);\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStores.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"}]}