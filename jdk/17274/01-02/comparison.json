{"files":[{"patch":"@@ -673,2 +673,2 @@\n-        \/\/ The following code is based on the snippet in the comment for StringUtils.DamerauLevenshteinDistance\n-        record Pair(String word, int distance) { }\n+        record Pair(String word, double similarity) { }\n+        final double MIN_SIMILARITY = 0.7;\n@@ -676,6 +676,6 @@\n-                             .map(v -> new Pair(v, StringUtils.DamerauLevenshteinDistance.of(v, name)))\n-                             .filter(p -> Double.compare(1.0 \/ 3, ((double) p.distance()) \/ p.word().length()) >= 0)\n-                             .sorted(Comparator.comparingDouble(Pair::distance))\n-                             .map(Pair::word)\n-                             .limit(3)\n-                             .toList();\n+                .map(t -> new Pair(t, similarity(t, name)))\n+                .sorted(Comparator.comparingDouble(Pair::similarity).reversed() \/* more similar first *\/)\n+                \/\/ .peek(p -> System.out.printf(\"%.3f, (%s ~ %s)%n\", p.similarity, p.word, name)) \/\/ debug\n+                .takeWhile(p -> Double.compare(p.similarity, MIN_SIMILARITY) >= 0)\n+                .map(Pair::word)\n+                .toList();\n@@ -690,0 +690,10 @@\n+    \/\/ a value in [0, 1] range: the closer the value is to 1, the more similar\n+    \/\/ the strings are\n+    private static double similarity(String a, String b) {\n+        \/\/ Normalize the distance so that similarity between \"x\" and \"y\" is\n+        \/\/ less than that of \"ax\" and \"ay\". Use the greater of two lengths\n+        \/\/ as normalizer, as it's an upper bound for the distance.\n+        return 1.0 - ((double) StringUtils.DamerauLevenshteinDistance.of(a, b))\n+                \/ Math.max(a.length(), b.length());\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"}]}