{"files":[{"patch":"@@ -16218,0 +16218,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -16220,1 +16221,1 @@\n-  ins_cost(1100);  \/\/ slightly larger than the next version\n+  ins_cost(20 * INSN_COST);  \/\/ slightly larger than the next version\n@@ -16230,0 +16231,29 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+\n+instruct partialSubtypeCheckSuper(iRegP_R4 sub, iRegP_R0 super, vRegD_V0 vtemp, iRegP_R5 result,\n+                                 iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                 rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(10 * INSN_COST);  \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    __ lookup_secondary_supers_table($sub$$Register, $super$$Register,\n+                                     $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                     $vtemp$$FloatRegister,\n+                                     $result$$Register, \/*L_success*\/nullptr);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16238,1 +16268,1 @@\n-  ins_cost(700);  \/\/ smaller than the next version\n+  ins_cost(5 * INSN_COST);  \/\/ smaller than the next version\n@@ -16263,15 +16293,0 @@\n-instruct partialSubtypeCheckVsZero(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, immP0 zero, rFlagsReg cr)\n-%{\n-  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));\n-  effect(KILL temp, KILL result);\n-\n-  ins_cost(1100);  \/\/ slightly larger than the next version\n-  format %{ \"partialSubtypeCheck $result, $sub, $super == 0\" %}\n-\n-  ins_encode(aarch64_enc_partial_subtype_check(sub, super, temp, result));\n-\n-  opcode(0x0); \/\/ Don't zero result reg on hit\n-\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -845,1 +845,7 @@\n-        __ check_klass_subtype_slow_path(r4, r0, r2, r5, nullptr, &miss);\n+        __ check_klass_subtype_slow_path(\/*sub_klass*\/r4,\n+                                         \/*super_klass*\/r0,\n+                                         \/*temp_reg*\/r2,\n+                                         \/*temp2_reg*\/r5,\n+                                         \/*L_success*\/nullptr,\n+                                         \/*L_failure*\/&miss);\n+        \/\/ Need extras for table lookup: r1, r3, vtemp\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1431,0 +1431,8 @@\n+\n+  \/\/ Don't check secondary_super_cache\n+  if (super_check_offset.is_register()\n+      && !UseSecondarySupersCache) {\n+    subs(zr, super_check_offset.as_register(), sc_offset);\n+    br(Assembler::EQ, *L_slow_path);\n+  }\n+\n@@ -1510,7 +1518,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register temp_reg,\n-                                                   Register temp2_reg,\n-                                                   Label* L_success,\n-                                                   Label* L_failure,\n-                                                   bool set_cond_codes) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register temp_reg,\n+                                                          Register temp2_reg,\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes) {\n@@ -1584,1 +1592,4 @@\n-  str(super_klass, super_cache_addr);\n+\n+  if (UseSecondarySupersCache) {\n+    str(super_klass, super_cache_addr);\n+  }\n@@ -1595,0 +1606,99 @@\n+\/\/ If Register r is invalid, remove a new register from\n+\/\/ available_regs, and add new register to regs_to_push.\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs;\n+    ++available_regs;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+\/\/ check_klass_subtype_slow_path_table() looks for super_klass in the\n+\/\/ hash table belonging to super_klass, branching to L_success or\n+\/\/ L_failure as appropriate. This is essentially a shim which\n+\/\/ allocates registers as necessary then calls\n+\/\/ lookup_secondary_supers_table() to do the work. Any of the temp\n+\/\/ regs may be noreg, in which case this logic will chooses some\n+\/\/ registers push and pop them from the stack.\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register result_reg,\n+                                                         FloatRegister vtemp,\n+                                                         Label* L_success,\n+                                                         Label* L_failure,\n+                                                         bool set_cond_codes) {\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+  bool temp2_reg_was_valid = temp2_reg->is_valid();\n+\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n+\n+  RegSetIterator<Register> available_regs\n+    = (RegSet::range(r0, r15) - temps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg = allocate_if_noreg(temp_reg, available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  push(pushed_regs, sp);\n+\n+  lookup_secondary_supers_table(sub_klass,\n+                                super_klass,\n+                                temp_reg, temp2_reg, temp3_reg, vtemp, result_reg,\n+                                nullptr);\n+  cmp(result_reg, zr);\n+\n+  \/\/ Unspill the temp. registers:\n+  pop(pushed_regs, sp);\n+\n+  if (temp2_reg_was_valid) {\n+    mov(temp2_reg, 1);\n+  }\n+\n+  br(Assembler::NE, *L_failure);\n+\n+  if (L_success != &L_fallthrough) {\n+    b(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  if (! UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_linear\n+      (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, set_cond_codes);\n+  } else {\n+    check_klass_subtype_slow_path_table\n+      (sub_klass, super_klass, temp_reg, temp2_reg, \/*temp3*\/noreg, \/*result*\/noreg,\n+       \/*vtemp*\/fnoreg,\n+       L_success, L_failure, set_cond_codes);\n+  }\n+}\n+\n+\n@@ -1607,1 +1717,0 @@\n-\/\/ Return true: we succeeded in generating this code\n@@ -1704,0 +1813,108 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   FloatRegister vtemp,\n+                                                   Register result,\n+                                                   Label *L_success) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, result, rscratch1, rscratch2);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index = temp3,\n+    slot          = rscratch1,\n+    r_bitmap      = rscratch2;\n+\n+  ldrb(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+\n+  \/\/ Make sure that result is nonzero if the test below misses.\n+  mov(result, 1);\n+\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+\n+  \/\/ This next instruction is equivalent to:\n+  \/\/ mov(r_array_index, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  \/\/ sub(slot, r_array_index, slot);\n+  eor(slot, slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  lslv(temp2, r_bitmap, slot);\n+  tbz(temp2, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1, L_fallthrough);\n+\n+  bool must_save_v0 = (vtemp == fnoreg);\n+  if (must_save_v0) {\n+    \/\/ temp1 and result are free, so use them to preserve vtemp\n+    vtemp = v0;\n+    mov(temp1,  vtemp, D, 0);\n+    mov(result, vtemp, D, 1);\n+  }\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  mov(vtemp, D, 0, temp2);\n+  cnt(vtemp, T8B, vtemp);\n+  addv(vtemp, T8B, vtemp);\n+  mov(r_array_index, vtemp, D, 0);\n+\n+  if (must_save_v0) {\n+    mov(vtemp, D, 0, temp1 );\n+    mov(vtemp, D, 1, result);\n+  }\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2;\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_success ? *L_success : L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  eor(slot, slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  rorv(r_bitmap, r_bitmap, slot);\n+  \/\/ rol(r_bitmap, r_bitmap, 1);\n+  tbz(r_bitmap, 1, L_fallthrough);\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, r_array_length, result, \/*is_stub*\/false);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ r4, r0\n+                                  temp1, temp2, result);      \/\/ r1, r2, r5\n+  }\n+\n+  if (L_success) {\n+    cbz(result, *L_success);\n+  }\n+}\n+\n@@ -1712,1 +1929,2 @@\n-                                                             Register result) {\n+                                                             Register result,\n+                                                             bool is_stub) {\n@@ -1719,1 +1937,3 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  if (is_stub) {\n+    LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  }\n@@ -1791,2 +2011,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":231,"deletions":13,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -1013,0 +1013,37 @@\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register result_reg,\n+                                           FloatRegister vtemp_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure,\n+                                           bool set_cond_codes = false);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Secondary subtype checking\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     FloatRegister vtemp,\n+                                     Register result,\n+                                     Label *L_success);\n+\n+\n@@ -1036,1 +1073,2 @@\n-                                               Register result);\n+                                               Register result,\n+                                               bool is_stub = true);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1978,2 +1978,28 @@\n-    __ load_klass(r19_klass, copied_oop);\/\/ query the object klass\n-    generate_type_check(r19_klass, ckoff, ckval, L_store_element);\n+    {\n+      __ load_klass(r19_klass, copied_oop);\/\/ query the object klass\n+\n+      BLOCK_COMMENT(\"type_check:\");\n+      if (!UseSecondarySupersTable) {\n+        generate_type_check(\/*sub_klass*\/r19_klass,\n+                            \/*super_check_offset*\/ckoff,\n+                            \/*super_klass*\/ckval, L_store_element);\n+      } else {\n+        Label L_miss;\n+        __ check_klass_subtype_fast_path(\/*sub_klass*\/r19_klass, \/*super_klass*\/ckval, noreg,\n+                                         &L_store_element, &L_miss, nullptr,\n+                                         \/*super_check_offset*\/ckoff);\n+        __ BIND(L_miss);\n+\n+        \/\/ We will consult the secondary-super array.\n+        __ lookup_secondary_supers_table(\/*r_sub_klass*\/r19_klass,\n+                                         \/*r_super_klass*\/ckval,\n+                                         \/*r_array_base*\/gct1,\n+                                         \/*temp2*\/gct2,\n+                                         \/*temp3*\/gct3,\n+                                         \/*vtemp*\/v0,\n+                                         \/*result*\/r10, &L_store_element);\n+\n+        \/\/ Fall through on failure!\n+      }\n+    }\n+\n@@ -1988,1 +2014,1 @@\n-    __ eon(count, count, zr);                   \/\/ report (-1^K) to caller\n+    __ eon(count, count, zr);              \/\/ report (-1^K) to caller\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -4652,7 +4652,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register temp_reg,\n-                                                   Register temp2_reg,\n-                                                   Label* L_success,\n-                                                   Label* L_failure,\n-                                                   bool set_cond_codes) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register temp_reg,\n+                                                          Register temp2_reg,\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes) {\n@@ -4744,1 +4744,123 @@\n-#ifdef _LP64\n+#ifndef _LP64\n+\n+\/\/ 32-bit x86 only: always use the linear search.\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  check_klass_subtype_slow_path_linear\n+    (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, set_cond_codes);\n+}\n+\n+#else \/\/ _LP64\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  assert(set_cond_codes == false, \"must be false on 64-bit x86\");\n+  check_klass_subtype_slow_path\n+    (sub_klass, super_klass, temp_reg, temp2_reg, noreg, noreg,\n+     L_success, L_failure);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Register temp3_reg,\n+                                                   Register temp4_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure) {\n+  if (! UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_linear\n+      (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, \/*set_cond_codes*\/false);\n+  } else {\n+    check_klass_subtype_slow_path_table\n+      (sub_klass, super_klass, temp_reg, temp2_reg, temp3_reg, temp4_reg,\n+       L_success, L_failure);\n+  }\n+}\n+\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs;\n+    ++available_regs;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register result_reg,\n+                                                         Label* L_success,\n+                                                         Label* L_failure) {\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+  bool temp2_reg_was_valid = temp2_reg->is_valid();\n+\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_table\");\n+\n+  RegSetIterator<Register> available_regs\n+    = (RegSet::of(rax, rcx, rdx, r8) + r9 + r10 + r11 + r12 - temps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg = allocate_if_noreg(temp_reg, available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+  Register temp4_reg = allocate_if_noreg(noreg, available_regs, pushed_regs);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, temp3_reg, result_reg);\n+\n+  {\n+\n+    int register_push_size = pushed_regs.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int aligned_size = align_up(register_push_size, StackAlignmentInBytes);\n+    subptr(rsp, aligned_size);\n+    push_set(pushed_regs, 0);\n+\n+    lookup_secondary_supers_table(sub_klass,\n+                                  super_klass,\n+                                  temp_reg, temp2_reg, temp3_reg, temp4_reg, result_reg);\n+    cmpq(result_reg, 0);\n+\n+    \/\/ Unspill the temp. registers:\n+    pop_set(pushed_regs, 0);\n+    \/\/ Increment SP but do not clobber flags.\n+    lea(rsp, Address(rsp, aligned_size));\n+  }\n+\n+  if (temp2_reg_was_valid) {\n+    movq(temp2_reg, 1);\n+  }\n+\n+  jcc(Assembler::notEqual, *L_failure);\n+\n+  if (L_success != &L_fallthrough) {\n+    jmp(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n@@ -4791,0 +4913,30 @@\n+\/\/ Versions of salq and rorq that don't need count to be in rcx\n+\n+void MacroAssembler::salq(Register dest, Register count) {\n+  if (count == rcx) {\n+    Assembler::salq(dest);\n+  } else {\n+    assert_different_registers(rcx, dest);\n+    xchgq(rcx, count);\n+    Assembler::salq(dest);\n+    xchgq(rcx, count);\n+  }\n+}\n+\n+void MacroAssembler::rorq(Register dest, Register count) {\n+  if (count == rcx) {\n+    Assembler::rorq(dest);\n+  } else {\n+    assert_different_registers(rcx, dest);\n+    xchgq(rcx, count);\n+    Assembler::rorq(dest);\n+    xchgq(rcx, count);\n+  }\n+}\n+\n+\/\/ Return true: we succeeded in generating this code\n+\/\/\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this if you know the\n+\/\/ super_klass_slot of the class you're looking for. This is always\n+\/\/ the case for instanceof and checkcast.\n@@ -4888,0 +5040,120 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+  assert_different_registers(r_sub_klass, r_super_klass, rcx);\n+  RegSet temps = RegSet::of(temp1, temp2, temp3, temp4);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+#ifdef DEBUG\n+  call_VM_leaf_base((address)&poo, \/*number_of_arguments*\/0);\n+#endif\n+\n+  RegSetIterator<Register> available_regs = (temps - rcx).begin();\n+\n+  \/\/ FIXME. Once we are sure that all paths reaching this point really\n+  \/\/ do pass rcx as one of our temps we can get rid of the following\n+  \/\/ workaround.\n+  assert(temps.contains(rcx), \"fix this code\");\n+\n+  \/\/ We prefer to have our shift count in rcx. If rcx is one of our\n+  \/\/ temps, use it for slot. If not, pick any of our temps.\n+  Register slot;\n+  if (!temps.contains(rcx)) {\n+    slot = *available_regs; ++available_regs;\n+  } else {\n+    slot = rcx;\n+  }\n+\n+  const Register r_array_index = *available_regs; ++available_regs;\n+  const Register r_bitmap      = *available_regs; ++available_regs;\n+\n+  \/\/ The logic above guarantees this property, but we state it here.\n+  assert_different_registers(r_array_index, r_bitmap, rcx);\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  movb(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+  xorl(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+  salq(r_array_index, slot);\n+\n+  testq(r_array_index, r_array_index);\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  const Register r_array_base = *available_regs; ++available_regs;\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  population_count(r_array_index, r_array_index, \/*temp2*\/r_array_base, \/*temp3*\/slot);\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jccb(Assembler::equal, L_success);\n+\n+  \/\/ Restore slot to its true value\n+  xorl(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  rorq(r_bitmap, slot);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, 1);\n+  jccb(Assembler::carryClear, L_failure);\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  lookup_secondary_supers_table_slow_path(r_super_klass,\n+                                          r_array_base,\n+                                          r_array_index,\n+                                          r_bitmap,\n+                                          \/*temp1*\/result,\n+                                          \/*temp2*\/slot,\n+                                          &L_success,\n+                                          nullptr);\n+\n+  bind(L_failure);\n+  movq(result, 1);\n+  jmpb(L_fallthrough);\n+\n+  bind(L_success);\n+  xorq(result, result); \/\/ = 0\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n@@ -4928,2 +5200,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n@@ -5027,2 +5297,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":280,"deletions":12,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -649,1 +649,4 @@\n-  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+\n+#ifdef _LP64\n+  \/\/ The 64-bit version, which may do a hashed subclass lookup.\n+  void check_klass_subtype_slow_path(Register sub_klass,\n@@ -653,0 +656,2 @@\n+                                     Register temp3_reg,\n+                                     Register temp4_reg,\n@@ -654,2 +659,26 @@\n-                                     Label* L_failure,\n-                                     bool set_cond_codes = false);\n+                                     Label* L_failure);\n+#endif\n+\n+  \/\/ Three parts of a hashed subclass lookup: a simple linear search,\n+  \/\/ a table lookup, and a fallback that does linear probing in the\n+  \/\/ event of a hash collision.\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register result_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure);\n+  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure);\n@@ -668,0 +697,13 @@\n+#ifdef _LP64\n+  using Assembler::salq;\n+  void salq(Register dest, Register count);\n+  using Assembler::rorq;\n+  void rorq(Register dest, Register count);\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result);\n+\n@@ -683,0 +725,1 @@\n+#endif\n@@ -688,1 +731,8 @@\n-    \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Simplified, combined version, good for typical uses.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1837,18 +1837,0 @@\n-  enc_class enc_PartialSubtypeCheck()\n-  %{\n-    Register Rrdi = as_Register(RDI_enc); \/\/ result register\n-    Register Rrax = as_Register(RAX_enc); \/\/ super class\n-    Register Rrcx = as_Register(RCX_enc); \/\/ killed\n-    Register Rrsi = as_Register(RSI_enc); \/\/ sub class\n-    Label miss;\n-    const bool set_cond_codes = true;\n-\n-    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,\n-                                     nullptr, &miss,\n-                                     \/*set_cond_codes:*\/ true);\n-    if ($primary) {\n-      __ xorptr(Rrdi, Rrdi);\n-    }\n-    __ bind(miss);\n-  %}\n-\n@@ -12181,0 +12163,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -12193,2 +12176,10 @@\n-  opcode(0x1); \/\/ Force a XOR of RDI\n-  ins_encode(enc_PartialSubtypeCheck());\n+  ins_encode %{\n+    Label miss;\n+    __ check_klass_subtype_slow_path_linear($sub$$Register, $super$$Register,\n+                                            $rcx$$Register, $result$$Register,\n+                                            nullptr, &miss,\n+                                            \/*set_cond_codes:*\/ true);\n+    __ xorptr($result$$Register, $result$$Register);\n+    __ bind(miss);\n+  %}\n+\n@@ -12198,0 +12189,8 @@\n+\/\/ ============================================================================\n+\/\/ Two versions of hashtable-based partialSubtypeCheck, both used when\n+\/\/ we need to search for a super class in the secondary supers array.\n+\/\/ The first is used when we don't know _a priori_ the class being\n+\/\/ searched for. The second, far more common, is used when we do know:\n+\/\/ this is used for instanceof, checkcast, and any case where C2 can\n+\/\/ determine it by constant propagation.\n+\n@@ -12223,4 +12222,3 @@\n-instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,\n-                                     rsi_RegP sub, rax_RegP super, rcx_RegI rcx,\n-                                     immP0 zero,\n-                                     rdi_RegP result)\n+instruct partialSubtypeCheckVarSuper(rsi_RegP sub, rax_RegP super, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n@@ -12228,2 +12226,3 @@\n-  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));\n-  effect(KILL rcx, KILL result);\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n@@ -12232,7 +12231,6 @@\n-  format %{ \"movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\\n\\t\"\n-            \"movl    rcx, [rdi + Array<Klass*>::length_offset_in_bytes()]\\t# length to scan\\n\\t\"\n-            \"addq    rdi, Array<Klass*>::base_offset_in_bytes()\\t# Skip to start of data; set NZ in case count is zero\\n\\t\"\n-            \"repne   scasq\\t# Scan *rdi++ for a match with rax while cx-- != 0\\n\\t\"\n-            \"jne,s   miss\\t\\t# Missed: flags nz\\n\\t\"\n-            \"movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\\t# Hit: update cache\\n\\t\"\n-    \"miss:\\t\" %}\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table($sub$$Register, $super$$Register, $temp1$$Register, $temp2$$Register,\n+                                     $temp3$$Register, $temp4$$Register, $result$$Register);\n+  %}\n@@ -12240,2 +12238,0 @@\n-  opcode(0x0); \/\/ No need to XOR RDI\n-  ins_encode(enc_PartialSubtypeCheck());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-    if (UseSecondarySupersTable) {\n+    {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1410,7 +1410,1 @@\n-    \/\/ The secondary super list is exactly the same as the transitive interfaces, so\n-    \/\/ let's use it instead of making a copy.\n-    \/\/ Redefine classes has to be careful not to delete this!\n-    if (!UseSecondarySupersTable) {\n-      set_secondary_supers(interfaces);\n-      return nullptr;\n-    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+    if (num_extra_slots == 0 && interfaces->length() <= 1) {\n@@ -3530,1 +3524,1 @@\n-  if (UseSecondarySupersTable) {\n+  {\n@@ -3536,1 +3530,1 @@\n-      bool is_hashed = UseSecondarySupersTable && (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n+      bool is_hashed = (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  if (UseSecondarySupersTable) {\n+  {\n@@ -166,7 +166,1 @@\n-bool Klass::search_secondary_supers(Klass* k) const {\n-  \/\/ Put some extra logic here out-of-line, before the search proper.\n-  \/\/ This cuts down the size of the inline method.\n-\n-  \/\/ This is necessary, since I am never in my own secondary_super list.\n-  if (this == k)\n-    return true;\n+bool Klass::linear_search_secondary_supers(Klass* k) const {\n@@ -174,0 +168,3 @@\n+  \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+  \/\/ comparison or a binary search, but is that worth any added\n+  \/\/ complexity?\n@@ -177,1 +174,24 @@\n-      ((Klass*)this)->set_secondary_super_cache(k);\n+      if (UseSecondarySupersCache) {\n+        ((Klass*)this)->set_secondary_super_cache(k);\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Given a secondary superklass k, an initial array index, and an\n+\/\/ occupancy bitmap rotated such that Bit 1 is the next bit to test,\n+\/\/ search for k.\n+bool Klass::fallback_search_secondary_supers(const Klass* k, int index, uintx rotated_bitmap) const {\n+  \/\/ This is conventional linear probing, but instead of terminating\n+  \/\/ when a null entry is found in the table, we maintain a bitmap\n+  \/\/ in which a 0 indicates missing entries.\n+\n+  \/\/ The check in search_secondary_supers guarantees there are 0s in\n+  \/\/ the bitmap, so this loop eventually terminates.\n+  while ((rotated_bitmap & 2) != 0) {\n+    if (++index == secondary_supers()->length()) {\n+      index = 0;\n+    }\n+    if (secondary_supers()->at(index) == k) {\n@@ -180,0 +200,1 @@\n+    rotated_bitmap = rotate_right(rotated_bitmap, 1);\n@@ -263,1 +284,2 @@\n-                           _shared_class_path_index(-1) {\n+                               _bitmap(SECONDARY_SUPERS_BITMAP_FULL),\n+                               _shared_class_path_index(-1) {\n@@ -306,1 +328,1 @@\n-  if (UseSecondarySupersTable && secondaries != nullptr) {\n+  if (secondaries != nullptr) {\n@@ -447,5 +469,1 @@\n-  if (UseSecondarySupersTable) {\n-    bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n-  } else {\n-    bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n-  }\n+  bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n@@ -1256,8 +1274,6 @@\n-    if (UseSecondarySupersTable) {\n-      st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n-      st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n-      if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n-          _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n-        st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n-        st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n-      }\n+    st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n+    st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n+    if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n+        _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n+      st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n+      st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n@@ -1274,3 +1290,2 @@\n-  fatal(\"%s: %s implements %s: is_subtype_of: %d; linear_search: %d; table_lookup: %d\",\n-        msg, sub->external_name(), super->external_name(),\n-        sub->is_subtype_of(super), linear_result, table_result);\n+  fatal(\"%s: %s implements %s: linear_search: %d; table_lookup: %d\",\n+        msg, sub->external_name(), super->external_name(), linear_result, table_result);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -398,0 +398,5 @@\n+  bool search_secondary_supers(Klass* k) const;\n+  bool lookup_secondary_supers_table(Klass *k) const;\n+  bool linear_search_secondary_supers(Klass* k) const;\n+  bool fallback_search_secondary_supers(const Klass* k, int index, uintx rotated_bitmap) const;\n+\n@@ -431,0 +436,1 @@\n+  static ByteSize hash_slot_offset()             { return byte_offset_of(Klass, _hash_slot); }\n@@ -533,1 +539,0 @@\n-    Klass* sup = *(Klass**)( (address)this + off );\n@@ -535,5 +540,1 @@\n-    if (sup == k) {\n-      return true;\n-    } else if (off != secondary_offset) {\n-      return false;\n-    } else {\n+    if (off == secondary_offset) {\n@@ -541,0 +542,3 @@\n+    } else {\n+      Klass* sup = *(Klass**)( (address)this + off );\n+      return (sup == k);\n@@ -544,2 +548,1 @@\n-  bool search_secondary_supers(Klass* k) const;\n-\n+public:\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/rotate_bits.hpp\"\n@@ -79,0 +80,56 @@\n+inline bool Klass::lookup_secondary_supers_table(Klass* k) const {\n+  uintx bitmap = _bitmap;\n+\n+  if (bitmap == SECONDARY_SUPERS_BITMAP_FULL) {\n+    return linear_search_secondary_supers(k);\n+  }\n+\n+  constexpr int highest_bit_number = SECONDARY_SUPERS_TABLE_SIZE - 1;\n+  uint8_t slot = k->_hash_slot;\n+  uintx shifted_bitmap = bitmap << (highest_bit_number - slot);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  if ((shifted_bitmap >> highest_bit_number) == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Calculate the initial hash probe\n+  int index = population_count(shifted_bitmap) - 1;\n+  if (secondary_supers()->at(index) == k) {\n+    \/\/ Yes! It worked the first time.\n+    return true;\n+  }\n+\n+  \/\/ Is there another entry to check? Consult the bitmap. If Bit 1,\n+  \/\/ the next bit to test, is zero, we are certain that super_klass is\n+  \/\/ not one of the secondary supers.\n+  bitmap = rotate_right(bitmap, slot);\n+  if ((bitmap & 2) == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Continue probing the hash table\n+  return fallback_search_secondary_supers(k, index, bitmap);\n+}\n+\n+inline bool Klass::search_secondary_supers(Klass *k) const {\n+  \/\/ This is necessary because I am never in my own secondary_super list.\n+  if (this == k)\n+    return true;\n+\n+  bool result = lookup_secondary_supers_table(k);\n+\n+#ifndef PRODUCT\n+  if (VerifySecondarySupers) {\n+    bool linear_result = linear_search_secondary_supers(k);\n+    if (linear_result != result) {\n+      on_secondary_supers_verification_failure((Klass*)this, k, linear_result, result, \"mismatch\");\n+    }\n+  }\n+#endif \/\/ PRODUCT\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"}]}