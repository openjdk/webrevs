{"files":[{"patch":"@@ -16218,0 +16218,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -16220,1 +16221,1 @@\n-  ins_cost(1100);  \/\/ slightly larger than the next version\n+  ins_cost(20 * INSN_COST);  \/\/ slightly larger than the next version\n@@ -16230,0 +16231,29 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+\n+instruct partialSubtypeCheckSuper(iRegP_R4 sub, iRegP_R0 super, vRegD_V0 vtemp, iRegP_R5 result,\n+                                 iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                 rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(10 * INSN_COST);  \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                         $vtemp$$FloatRegister,\n+                                         $result$$Register, \/*L_success*\/nullptr);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16238,1 +16268,1 @@\n-  ins_cost(700);  \/\/ smaller than the next version\n+  ins_cost(5 * INSN_COST);  \/\/ smaller than the next version\n@@ -16245,5 +16275,6 @@\n-      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n-                                                 $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n-                                                 $vtemp$$FloatRegister,\n-                                                 $result$$Register,\n-                                                 super_klass_slot);\n+      success =\n+        __ lookup_secondary_supers_table_const($sub$$Register, $super_reg$$Register,\n+                                               $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                               $vtemp$$FloatRegister,\n+                                               $result$$Register,\n+                                               super_klass_slot);\n@@ -16263,15 +16294,0 @@\n-instruct partialSubtypeCheckVsZero(iRegP_R4 sub, iRegP_R0 super, iRegP_R2 temp, iRegP_R5 result, immP0 zero, rFlagsReg cr)\n-%{\n-  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));\n-  effect(KILL temp, KILL result);\n-\n-  ins_cost(1100);  \/\/ slightly larger than the next version\n-  format %{ \"partialSubtypeCheck $result, $sub, $super == 0\" %}\n-\n-  ins_encode(aarch64_enc_partial_subtype_check(sub, super, temp, result));\n-\n-  opcode(0x0); \/\/ Don't zero result reg on hit\n-\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":38,"deletions":22,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -845,1 +845,7 @@\n-        __ check_klass_subtype_slow_path(r4, r0, r2, r5, nullptr, &miss);\n+        __ check_klass_subtype_slow_path(\/*sub_klass*\/r4,\n+                                         \/*super_klass*\/r0,\n+                                         \/*temp_reg*\/r2,\n+                                         \/*temp2_reg*\/r5,\n+                                         \/*L_success*\/nullptr,\n+                                         \/*L_failure*\/&miss);\n+        \/\/ Need extras for table lookup: r1, r3, vtemp\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1390,7 +1390,4 @@\n-                                        RegisterOrConstant super_check_offset) {\n-  assert_different_registers(sub_klass, super_klass, temp_reg);\n-  bool must_load_sco = (super_check_offset.constant_or_zero() == -1);\n-  if (super_check_offset.is_register()) {\n-    assert_different_registers(sub_klass, super_klass,\n-                               super_check_offset.as_register());\n-  } else if (must_load_sco) {\n+                                                   Register super_check_offset) {\n+  assert_different_registers(sub_klass, super_klass, temp_reg, super_check_offset);\n+  bool must_load_sco = ! super_check_offset->is_valid();\n+  if (must_load_sco) {\n@@ -1407,1 +1404,0 @@\n-  int sc_offset = in_bytes(Klass::secondary_super_cache_offset());\n@@ -1429,1 +1425,1 @@\n-    super_check_offset = RegisterOrConstant(temp_reg);\n+    super_check_offset = temp_reg;\n@@ -1431,0 +1427,1 @@\n+\n@@ -1434,0 +1431,1 @@\n+  br(Assembler::EQ, *L_success);\n@@ -1446,17 +1444,3 @@\n-  if (super_check_offset.is_register()) {\n-    br(Assembler::EQ, *L_success);\n-    subs(zr, super_check_offset.as_register(), sc_offset);\n-    if (L_failure == &L_fallthrough) {\n-      br(Assembler::EQ, *L_slow_path);\n-    } else {\n-      br(Assembler::NE, *L_failure);\n-      final_jmp(*L_slow_path);\n-    }\n-  } else if (super_check_offset.as_constant() == sc_offset) {\n-    \/\/ Need a slow path; fast failure is impossible.\n-    if (L_slow_path == &L_fallthrough) {\n-      br(Assembler::EQ, *L_success);\n-    } else {\n-      br(Assembler::NE, *L_slow_path);\n-      final_jmp(*L_success);\n-    }\n+  sub(rscratch1, super_check_offset, in_bytes(Klass::secondary_super_cache_offset()));\n+  if (L_failure == &L_fallthrough) {\n+    cbz(rscratch1, *L_slow_path);\n@@ -1464,7 +1448,2 @@\n-    \/\/ No slow path; it's a fast decision.\n-    if (L_failure == &L_fallthrough) {\n-      br(Assembler::EQ, *L_success);\n-    } else {\n-      br(Assembler::NE, *L_failure);\n-      final_jmp(*L_success);\n-    }\n+    cbnz(rscratch1, *L_failure);\n+    final_jmp(*L_slow_path);\n@@ -1510,7 +1489,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register temp_reg,\n-                                                   Register temp2_reg,\n-                                                   Label* L_success,\n-                                                   Label* L_failure,\n-                                                   bool set_cond_codes) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register temp_reg,\n+                                                          Register temp2_reg,\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes) {\n@@ -1584,1 +1563,4 @@\n-  str(super_klass, super_cache_addr);\n+\n+  if (UseSecondarySupersCache) {\n+    str(super_klass, super_cache_addr);\n+  }\n@@ -1595,0 +1577,97 @@\n+\/\/ If Register r is invalid, remove a new register from\n+\/\/ available_regs, and add new register to regs_to_push.\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs;\n+    ++available_regs;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+\/\/ check_klass_subtype_slow_path_table() looks for super_klass in the\n+\/\/ hash table belonging to super_klass, branching to L_success or\n+\/\/ L_failure as appropriate. This is essentially a shim which\n+\/\/ allocates registers as necessary then calls\n+\/\/ lookup_secondary_supers_table() to do the work. Any of the temp\n+\/\/ regs may be noreg, in which case this logic will chooses some\n+\/\/ registers push and pop them from the stack.\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register result_reg,\n+                                                         FloatRegister vtemp,\n+                                                         Label* L_success,\n+                                                         Label* L_failure,\n+                                                         bool set_cond_codes) {\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path\");\n+\n+  RegSetIterator<Register> available_regs\n+    = (RegSet::range(r0, r15) - temps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg = allocate_if_noreg(temp_reg, available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  push(pushed_regs, sp);\n+\n+  lookup_secondary_supers_table_var(sub_klass,\n+                                    super_klass,\n+                                    temp_reg, temp2_reg, temp3_reg, vtemp, result_reg,\n+                                    nullptr);\n+  cmp(result_reg, zr);\n+\n+  \/\/ Unspill the temp. registers:\n+  pop(pushed_regs, sp);\n+\n+  \/\/ NB! Callers may assume that, when set_cond_codes is true, this\n+  \/\/ code sets temp2_reg to a nonzero value.\n+  if (set_cond_codes) {\n+    mov(temp2_reg, 1);\n+  }\n+\n+  br(Assembler::NE, *L_failure);\n+\n+  if (L_success != &L_fallthrough) {\n+    b(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table\n+      (sub_klass, super_klass, temp_reg, temp2_reg, \/*temp3*\/noreg, \/*result*\/noreg,\n+       \/*vtemp*\/fnoreg,\n+       L_success, L_failure, set_cond_codes);\n+  } else {\n+    check_klass_subtype_slow_path_linear\n+      (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, set_cond_codes);\n+  }\n+}\n+\n+\n@@ -1607,10 +1686,9 @@\n-\/\/ Return true: we succeeded in generating this code\n-bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n-                                                   Register r_super_klass,\n-                                                   Register temp1,\n-                                                   Register temp2,\n-                                                   Register temp3,\n-                                                   FloatRegister vtemp,\n-                                                   Register result,\n-                                                   u1 super_klass_slot,\n-                                                   bool stub_is_near) {\n+bool MacroAssembler::lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                                         Register r_super_klass,\n+                                                         Register temp1,\n+                                                         Register temp2,\n+                                                         Register temp3,\n+                                                         FloatRegister vtemp,\n+                                                         Register result,\n+                                                         u1 super_klass_slot,\n+                                                         bool stub_is_near) {\n@@ -1638,1 +1716,1 @@\n-  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n@@ -1640,1 +1718,1 @@\n-    ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+    ldrd(vtemp, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n@@ -1704,0 +1782,108 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table_var(Register r_sub_klass,\n+                                                       Register r_super_klass,\n+                                                       Register temp1,\n+                                                       Register temp2,\n+                                                       Register temp3,\n+                                                       FloatRegister vtemp,\n+                                                       Register result,\n+                                                       Label *L_success) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, result, rscratch1, rscratch2);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index = temp3,\n+    slot          = rscratch1,\n+    r_bitmap      = rscratch2;\n+\n+  ldrb(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+\n+  \/\/ Make sure that result is nonzero if the test below misses.\n+  mov(result, 1);\n+\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+\n+  \/\/ This next instruction is equivalent to:\n+  \/\/ mov(r_array_index, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  \/\/ sub(slot, r_array_index, slot);\n+  eor(slot, slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  lslv(temp2, r_bitmap, slot);\n+  tbz(temp2, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1, L_fallthrough);\n+\n+  bool must_save_v0 = (vtemp == fnoreg);\n+  if (must_save_v0) {\n+    \/\/ temp1 and result are free, so use them to preserve vtemp\n+    vtemp = v0;\n+    mov(temp1,  vtemp, D, 0);\n+    mov(result, vtemp, D, 1);\n+  }\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  mov(vtemp, D, 0, temp2);\n+  cnt(vtemp, T8B, vtemp);\n+  addv(vtemp, T8B, vtemp);\n+  mov(r_array_index, vtemp, D, 0);\n+\n+  if (must_save_v0) {\n+    mov(vtemp, D, 0, temp1 );\n+    mov(vtemp, D, 1, result);\n+  }\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2;\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_success ? *L_success : L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  eor(slot, slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1));\n+  rorv(r_bitmap, r_bitmap, slot);\n+  \/\/ rol(r_bitmap, r_bitmap, 1);\n+  tbz(r_bitmap, 1, L_fallthrough);\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, r_array_length, result, \/*is_stub*\/false);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ r4, r0\n+                                  temp1, temp2, result);      \/\/ r1, r2, r5\n+  }\n+\n+  if (L_success) {\n+    cbz(result, *L_success);\n+  }\n+}\n+\n@@ -1712,1 +1898,2 @@\n-                                                             Register result) {\n+                                                             Register result,\n+                                                             bool is_stub) {\n@@ -1719,1 +1906,3 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  if (is_stub) {\n+    LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  }\n@@ -1791,2 +1980,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":244,"deletions":57,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-                RegisterOrConstant super_check_offset = RegisterOrConstant(-1));\n+                                     Register super_check_offset = noreg);\n@@ -1013,0 +1013,37 @@\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register result_reg,\n+                                           FloatRegister vtemp_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure,\n+                                           bool set_cond_codes = false);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Secondary subtype checking\n+  void lookup_secondary_supers_table_var(Register sub_klass,\n+                                         Register r_super_klass,\n+                                         Register temp1,\n+                                         Register temp2,\n+                                         Register temp3,\n+                                         FloatRegister vtemp,\n+                                         Register result,\n+                                         Label *L_success);\n+\n+\n@@ -1015,9 +1052,9 @@\n-  bool lookup_secondary_supers_table(Register r_sub_klass,\n-                                     Register r_super_klass,\n-                                     Register temp1,\n-                                     Register temp2,\n-                                     Register temp3,\n-                                     FloatRegister vtemp,\n-                                     Register result,\n-                                     u1 super_klass_slot,\n-                                     bool stub_is_near = false);\n+  bool lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                           Register r_super_klass,\n+                                           Register temp1,\n+                                           Register temp2,\n+                                           Register temp3,\n+                                           FloatRegister vtemp,\n+                                           Register result,\n+                                           u1 super_klass_slot,\n+                                           bool stub_is_near = false);\n@@ -1036,1 +1073,2 @@\n-                                               Register result);\n+                                               Register result,\n+                                               bool is_stub = true);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":49,"deletions":11,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1834,0 +1834,3 @@\n+                           Register temp1,\n+                           Register temp2,\n+                           Register result,\n@@ -1843,1 +1846,1 @@\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1, temp2, &L_success, nullptr);\n@@ -1979,1 +1982,11 @@\n-    generate_type_check(r19_klass, ckoff, ckval, L_store_element);\n+\n+    BLOCK_COMMENT(\"type_check:\");\n+    generate_type_check(\/*sub_klass*\/r19_klass,\n+                        \/*super_check_offset*\/ckoff,\n+                        \/*super_klass*\/ckval,\n+                        \/*r_array_base*\/gct1,\n+                        \/*temp2*\/gct2,\n+                        \/*result*\/r10, L_store_element);\n+\n+    \/\/ Fall through on failure!\n+\n@@ -1988,1 +2001,1 @@\n-    __ eon(count, count, zr);                   \/\/ report (-1^K) to caller\n+    __ eon(count, count, zr);              \/\/ report (-1^K) to caller\n@@ -2355,1 +2368,2 @@\n-      generate_type_check(scratch_src_klass, sco_temp, dst_klass, L_plain_copy);\n+      generate_type_check(scratch_src_klass, sco_temp, dst_klass, \/*temps*\/ noreg, noreg, noreg,\n+                          L_plain_copy);\n@@ -6788,4 +6802,4 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     vtemp, result, super_klass_index,\n-                                     \/*stub_is_near*\/true);\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           r_array_base, r_array_length, r_array_index,\n+                                           vtemp, result, super_klass_index,\n+                                           \/*stub_is_near*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2196,1 +2196,1 @@\n-  ld(r_bitmap, in_bytes(Klass::bitmap_offset()), r_sub_klass);\n+  ld(r_bitmap, in_bytes(Klass::secondary_supers_bitmap_offset()), r_sub_klass);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3889,1 +3889,1 @@\n-  ld(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  ld(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4652,7 +4652,7 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register temp_reg,\n-                                                   Register temp2_reg,\n-                                                   Label* L_success,\n-                                                   Label* L_failure,\n-                                                   bool set_cond_codes) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register temp_reg,\n+                                                          Register temp2_reg,\n+                                                          Label* L_success,\n+                                                          Label* L_failure,\n+                                                          bool set_cond_codes) {\n@@ -4744,1 +4744,123 @@\n-#ifdef _LP64\n+#ifndef _LP64\n+\n+\/\/ 32-bit x86 only: always use the linear search.\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  check_klass_subtype_slow_path_linear\n+    (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, set_cond_codes);\n+}\n+\n+#else \/\/ _LP64\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure,\n+                                                   bool set_cond_codes) {\n+  assert(set_cond_codes == false, \"must be false on 64-bit x86\");\n+  check_klass_subtype_slow_path\n+    (sub_klass, super_klass, temp_reg, temp2_reg, noreg, noreg,\n+     L_success, L_failure);\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp_reg,\n+                                                   Register temp2_reg,\n+                                                   Register temp3_reg,\n+                                                   Register temp4_reg,\n+                                                   Label* L_success,\n+                                                   Label* L_failure) {\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table\n+      (sub_klass, super_klass, temp_reg, temp2_reg, temp3_reg, temp4_reg,\n+       L_success, L_failure);\n+  } else {\n+    check_klass_subtype_slow_path_linear\n+      (sub_klass, super_klass, temp_reg, temp2_reg, L_success, L_failure, \/*set_cond_codes*\/false);\n+  }\n+}\n+\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs;\n+    ++available_regs;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp_reg,\n+                                                         Register temp2_reg,\n+                                                         Register temp3_reg,\n+                                                         Register result_reg,\n+                                                         Label* L_success,\n+                                                         Label* L_failure) {\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+  bool temp2_reg_was_valid = temp2_reg->is_valid();\n+\n+  RegSet temps = RegSet::of(temp_reg, temp2_reg, temp3_reg);\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_table\");\n+\n+  RegSetIterator<Register> available_regs\n+    = (RegSet::of(rax, rcx, rdx, r8) + r9 + r10 + r11 + r12 - temps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp_reg = allocate_if_noreg(temp_reg, available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+  Register temp4_reg = allocate_if_noreg(noreg, available_regs, pushed_regs);\n+\n+  assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, temp3_reg, result_reg);\n+\n+  {\n+\n+    int register_push_size = pushed_regs.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int aligned_size = align_up(register_push_size, StackAlignmentInBytes);\n+    subptr(rsp, aligned_size);\n+    push_set(pushed_regs, 0);\n+\n+    lookup_secondary_supers_table(sub_klass,\n+                                  super_klass,\n+                                  temp_reg, temp2_reg, temp3_reg, temp4_reg, result_reg);\n+    cmpq(result_reg, 0);\n+\n+    \/\/ Unspill the temp. registers:\n+    pop_set(pushed_regs, 0);\n+    \/\/ Increment SP but do not clobber flags.\n+    lea(rsp, Address(rsp, aligned_size));\n+  }\n+\n+  if (temp2_reg_was_valid) {\n+    movq(temp2_reg, 1);\n+  }\n+\n+  jcc(Assembler::notEqual, *L_failure);\n+\n+  if (L_success != &L_fallthrough) {\n+    jmp(*L_success);\n+  }\n+\n+  bind(L_fallthrough);\n+}\n@@ -4791,0 +4913,30 @@\n+\/\/ Versions of salq and rorq that don't need count to be in rcx\n+\n+void MacroAssembler::salq(Register dest, Register count) {\n+  if (count == rcx) {\n+    Assembler::salq(dest);\n+  } else {\n+    assert_different_registers(rcx, dest);\n+    xchgq(rcx, count);\n+    Assembler::salq(dest);\n+    xchgq(rcx, count);\n+  }\n+}\n+\n+void MacroAssembler::rorq(Register dest, Register count) {\n+  if (count == rcx) {\n+    Assembler::rorq(dest);\n+  } else {\n+    assert_different_registers(rcx, dest);\n+    xchgq(rcx, count);\n+    Assembler::rorq(dest);\n+    xchgq(rcx, count);\n+  }\n+}\n+\n+\/\/ Return true: we succeeded in generating this code\n+\/\/\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this if you know the\n+\/\/ super_klass_slot of the class you're looking for. This is always\n+\/\/ the case for instanceof and checkcast.\n@@ -4815,1 +4967,1 @@\n-  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n@@ -4888,0 +5040,116 @@\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+  assert_different_registers(r_sub_klass, r_super_klass, rcx);\n+  RegSet temps = RegSet::of(temp1, temp2, temp3, temp4);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  RegSetIterator<Register> available_regs = (temps - rcx).begin();\n+\n+  \/\/ FIXME. Once we are sure that all paths reaching this point really\n+  \/\/ do pass rcx as one of our temps we can get rid of the following\n+  \/\/ workaround.\n+  assert(temps.contains(rcx), \"fix this code\");\n+\n+  \/\/ We prefer to have our shift count in rcx. If rcx is one of our\n+  \/\/ temps, use it for slot. If not, pick any of our temps.\n+  Register slot;\n+  if (!temps.contains(rcx)) {\n+    slot = *available_regs; ++available_regs;\n+  } else {\n+    slot = rcx;\n+  }\n+\n+  const Register r_array_index = *available_regs; ++available_regs;\n+  const Register r_bitmap      = *available_regs; ++available_regs;\n+\n+  \/\/ The logic above guarantees this property, but we state it here.\n+  assert_different_registers(r_array_index, r_bitmap, rcx);\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::secondary_supers_bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  movb(slot, Address(r_super_klass, Klass::hash_slot_offset()));\n+  xorl(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+  salq(r_array_index, slot);\n+\n+  testq(r_array_index, r_array_index);\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  const Register r_array_base = *available_regs; ++available_regs;\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  population_count(r_array_index, r_array_index, \/*temp2*\/r_array_base, \/*temp3*\/slot);\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jccb(Assembler::equal, L_success);\n+\n+  \/\/ Restore slot to its true value\n+  xorl(slot, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 1)); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  rorq(r_bitmap, slot);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, 1);\n+  jccb(Assembler::carryClear, L_failure);\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  lookup_secondary_supers_table_slow_path(r_super_klass,\n+                                          r_array_base,\n+                                          r_array_index,\n+                                          r_bitmap,\n+                                          \/*temp1*\/result,\n+                                          \/*temp2*\/slot,\n+                                          &L_success,\n+                                          nullptr);\n+\n+  bind(L_failure);\n+  movq(result, 1);\n+  jmpb(L_fallthrough);\n+\n+  bind(L_success);\n+  xorq(result, result); \/\/ = 0\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n@@ -4928,2 +5196,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n@@ -5027,2 +5293,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":277,"deletions":13,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -649,1 +649,4 @@\n-  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+\n+#ifdef _LP64\n+  \/\/ The 64-bit version, which may do a hashed subclass lookup.\n+  void check_klass_subtype_slow_path(Register sub_klass,\n@@ -653,0 +656,2 @@\n+                                     Register temp3_reg,\n+                                     Register temp4_reg,\n@@ -654,2 +659,26 @@\n-                                     Label* L_failure,\n-                                     bool set_cond_codes = false);\n+                                     Label* L_failure);\n+#endif\n+\n+  \/\/ Three parts of a hashed subclass lookup: a simple linear search,\n+  \/\/ a table lookup, and a fallback that does linear probing in the\n+  \/\/ event of a hash collision.\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure,\n+                                            bool set_cond_codes = false);\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp_reg,\n+                                           Register temp2_reg,\n+                                           Register temp3_reg,\n+                                           Register result_reg,\n+                                           Label* L_success,\n+                                           Label* L_failure);\n+  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp_reg,\n+                                            Label* L_success,\n+                                            Label* L_failure);\n@@ -668,0 +697,13 @@\n+#ifdef _LP64\n+  using Assembler::salq;\n+  void salq(Register dest, Register count);\n+  using Assembler::rorq;\n+  void rorq(Register dest, Register count);\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result);\n+\n@@ -683,0 +725,1 @@\n+#endif\n@@ -688,1 +731,8 @@\n-    \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Simplified, combined version, good for typical uses.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1720,1 +1720,3 @@\n-    __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,\n+    \/\/ NB: Callers may assume that, when $result is a valid register,\n+    \/\/ check_klass_subtype_slow_path sets it to a nonzero value.\n+     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1837,18 +1837,0 @@\n-  enc_class enc_PartialSubtypeCheck()\n-  %{\n-    Register Rrdi = as_Register(RDI_enc); \/\/ result register\n-    Register Rrax = as_Register(RAX_enc); \/\/ super class\n-    Register Rrcx = as_Register(RCX_enc); \/\/ killed\n-    Register Rrsi = as_Register(RSI_enc); \/\/ sub class\n-    Label miss;\n-    const bool set_cond_codes = true;\n-\n-    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,\n-                                     nullptr, &miss,\n-                                     \/*set_cond_codes:*\/ true);\n-    if ($primary) {\n-      __ xorptr(Rrdi, Rrdi);\n-    }\n-    __ bind(miss);\n-  %}\n-\n@@ -12181,0 +12163,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -12193,2 +12176,13 @@\n-  opcode(0x1); \/\/ Force a XOR of RDI\n-  ins_encode(enc_PartialSubtypeCheck());\n+  ins_encode %{\n+    Label miss;\n+    \/\/ NB: Callers may assume that, when $result is a valid register,\n+    \/\/ check_klass_subtype_slow_path_linear sets it to a nonzero\n+    \/\/ value.\n+    __ check_klass_subtype_slow_path_linear($sub$$Register, $super$$Register,\n+                                            $rcx$$Register, $result$$Register,\n+                                            nullptr, &miss,\n+                                            \/*set_cond_codes:*\/ true);\n+    __ xorptr($result$$Register, $result$$Register);\n+    __ bind(miss);\n+  %}\n+\n@@ -12198,0 +12192,8 @@\n+\/\/ ============================================================================\n+\/\/ Two versions of hashtable-based partialSubtypeCheck, both used when\n+\/\/ we need to search for a super class in the secondary supers array.\n+\/\/ The first is used when we don't know _a priori_ the class being\n+\/\/ searched for. The second, far more common, is used when we do know:\n+\/\/ this is used for instanceof, checkcast, and any case where C2 can\n+\/\/ determine it by constant propagation.\n+\n@@ -12223,4 +12225,3 @@\n-instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,\n-                                     rsi_RegP sub, rax_RegP super, rcx_RegI rcx,\n-                                     immP0 zero,\n-                                     rdi_RegP result)\n+instruct partialSubtypeCheckVarSuper(rsi_RegP sub, rax_RegP super, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n@@ -12228,2 +12229,3 @@\n-  match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));\n-  effect(KILL rcx, KILL result);\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n@@ -12232,7 +12234,6 @@\n-  format %{ \"movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\\n\\t\"\n-            \"movl    rcx, [rdi + Array<Klass*>::length_offset_in_bytes()]\\t# length to scan\\n\\t\"\n-            \"addq    rdi, Array<Klass*>::base_offset_in_bytes()\\t# Skip to start of data; set NZ in case count is zero\\n\\t\"\n-            \"repne   scasq\\t# Scan *rdi++ for a match with rax while cx-- != 0\\n\\t\"\n-            \"jne,s   miss\\t\\t# Missed: flags nz\\n\\t\"\n-            \"movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\\t# Hit: update cache\\n\\t\"\n-    \"miss:\\t\" %}\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table($sub$$Register, $super$$Register, $temp1$$Register, $temp2$$Register,\n+                                     $temp3$$Register, $temp4$$Register, $result$$Register);\n+  %}\n@@ -12240,2 +12241,0 @@\n-  opcode(0x0); \/\/ No need to XOR RDI\n-  ins_encode(enc_PartialSubtypeCheck());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -214,1 +214,0 @@\n-  _use_secondary_supers_table = UseSecondarySupersTable;\n@@ -278,1 +277,0 @@\n-  st->print_cr(\"- use_secondary_supers_table:     %d\", _use_secondary_supers_table);\n@@ -2449,5 +2447,0 @@\n-  if (! _use_secondary_supers_table && UseSecondarySupersTable) {\n-    log_warning(cds)(\"The shared archive was created without UseSecondarySupersTable.\");\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  bool    _use_secondary_supers_table;            \/\/ save the flag UseSecondarySupersTable\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  nonstatic_field(Klass,                       _bitmap,                                       uintx)                                 \\\n+  nonstatic_field(Klass,                       _secondary_supers_bitmap,                      uintx)                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,4 +442,2 @@\n-    if (UseSecondarySupersTable) {\n-      Universe::_the_array_interfaces_bitmap = Klass::compute_secondary_supers_bitmap(_the_array_interfaces_array);\n-      Universe::_the_empty_klass_bitmap      = Klass::compute_secondary_supers_bitmap(_the_empty_klass_array);\n-    }\n+    _the_array_interfaces_bitmap = Klass::compute_secondary_supers_bitmap(_the_array_interfaces_array);\n+    _the_empty_klass_bitmap      = Klass::compute_secondary_supers_bitmap(_the_empty_klass_array);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"klass.inline.hpp\"\n@@ -1410,15 +1411,6 @@\n-  } else if (num_extra_slots == 0) {\n-    \/\/ The secondary super list is exactly the same as the transitive interfaces, so\n-    \/\/ let's use it instead of making a copy.\n-    \/\/ Redefine classes has to be careful not to delete this!\n-    if (!UseSecondarySupersTable) {\n-      set_secondary_supers(interfaces);\n-      return nullptr;\n-    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n-      \/\/ We will reuse the transitive interfaces list if we're certain\n-      \/\/ it's in hash order.\n-      uintx bitmap = compute_secondary_supers_bitmap(interfaces);\n-      set_secondary_supers(interfaces, bitmap);\n-      return nullptr;\n-    }\n-    \/\/ ... fall through if that didn't work.\n+  } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+    \/\/ We will reuse the transitive interfaces list if we're certain\n+    \/\/ it's in hash order.\n+    uintx bitmap = compute_secondary_supers_bitmap(interfaces);\n+    set_secondary_supers(interfaces, bitmap);\n+    return nullptr;\n@@ -3531,4 +3523,4 @@\n-  if (UseSecondarySupersTable) {\n-    st->print(BULLET\"hash_slot:         %d\", hash_slot()); st->cr();\n-    st->print(BULLET\"bitmap:            \" UINTX_FORMAT_X_0, _bitmap); st->cr();\n-  }\n+\n+  st->print(BULLET\"hash_slot:         %d\", hash_slot()); st->cr();\n+  st->print(BULLET\"secondary bitmap: \" UINTX_FORMAT_X_0, _secondary_supers_bitmap); st->cr();\n+\n@@ -3537,1 +3529,1 @@\n-      bool is_hashed = UseSecondarySupersTable && (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n+      bool is_hashed = (_secondary_supers_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n@@ -3544,1 +3536,1 @@\n-          int home_slot = compute_home_slot(secondary_super, _bitmap);\n+          int home_slot = compute_home_slot(secondary_super, _secondary_supers_bitmap);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  if (UseSecondarySupersTable) {\n+  {\n@@ -166,7 +166,1 @@\n-bool Klass::search_secondary_supers(Klass* k) const {\n-  \/\/ Put some extra logic here out-of-line, before the search proper.\n-  \/\/ This cuts down the size of the inline method.\n-\n-  \/\/ This is necessary, since I am never in my own secondary_super list.\n-  if (this == k)\n-    return true;\n+bool Klass::linear_search_secondary_supers(const Klass* k) const {\n@@ -174,0 +168,3 @@\n+  \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+  \/\/ comparison or a binary search, but is that worth any added\n+  \/\/ complexity?\n@@ -177,1 +174,0 @@\n-      ((Klass*)this)->set_secondary_super_cache(k);\n@@ -184,0 +180,26 @@\n+\/\/ Given a secondary superklass k, an initial array index, and an\n+\/\/ occupancy bitmap rotated such that Bit 1 is the next bit to test,\n+\/\/ search for k.\n+bool Klass::fallback_search_secondary_supers(const Klass* k, int index, uintx rotated_bitmap) const {\n+  if (rotated_bitmap == SECONDARY_SUPERS_BITMAP_FULL) {\n+    return linear_search_secondary_supers(k);\n+  }\n+\n+  \/\/ This is conventional linear probing, but instead of terminating\n+  \/\/ when a null entry is found in the table, we maintain a bitmap\n+  \/\/ in which a 0 indicates missing entries.\n+\n+  \/\/ The check in search_secondary_supers guarantees there are 0s in\n+  \/\/ the bitmap, so this loop eventually terminates.\n+  while ((rotated_bitmap & 2) != 0) {\n+    if (++index == secondary_supers()->length()) {\n+      index = 0;\n+    }\n+    if (secondary_supers()->at(index) == k) {\n+      return true;\n+    }\n+    rotated_bitmap = rotate_right(rotated_bitmap, 1);\n+  }\n+  return false;\n+}\n+\n@@ -263,1 +285,2 @@\n-                           _shared_class_path_index(-1) {\n+                               _secondary_supers_bitmap(SECONDARY_SUPERS_BITMAP_EMPTY),\n+                               _shared_class_path_index(-1) {\n@@ -306,1 +329,1 @@\n-  if (UseSecondarySupersTable && secondaries != nullptr) {\n+  if (secondaries != nullptr) {\n@@ -311,1 +334,1 @@\n-  _bitmap = bitmap;\n+  _secondary_supers_bitmap = bitmap;\n@@ -447,5 +470,1 @@\n-  if (UseSecondarySupersTable) {\n-    bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n-  } else {\n-    bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n-  }\n+  bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n@@ -775,1 +794,1 @@\n-  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _bitmap, \"broken table\");\n+  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _secondary_supers_bitmap, \"broken table\");\n@@ -1256,8 +1275,7 @@\n-    if (UseSecondarySupersTable) {\n-      st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n-      st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n-      if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n-          _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n-        st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n-        st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n-      }\n+    st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n+    st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _secondary_supers_bitmap);\n+    if (_secondary_supers_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n+        _secondary_supers_bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n+      st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(),\n+                                                     _secondary_supers_bitmap, st); st->cr();\n+      st->print(\"  - \"); print_negative_lookup_stats(_secondary_supers_bitmap, st); st->cr();\n@@ -1274,3 +1292,2 @@\n-  fatal(\"%s: %s implements %s: is_subtype_of: %d; linear_search: %d; table_lookup: %d\",\n-        msg, sub->external_name(), super->external_name(),\n-        sub->is_subtype_of(super), linear_result, table_result);\n+  fatal(\"%s: %s implements %s: linear_search: %d; table_lookup: %d\",\n+        msg, sub->external_name(), super->external_name(), linear_result, table_result);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":46,"deletions":29,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+\n@@ -162,0 +163,3 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _secondary_supers_bitmap;\n+  uint8_t  _hash_slot;\n@@ -171,4 +175,0 @@\n-  \/\/ Bitmap and hash code used by hashed secondary supers.\n-  uintx    _bitmap;\n-  uint8_t  _hash_slot;\n-\n@@ -398,0 +398,5 @@\n+  bool search_secondary_supers(Klass* k) const;\n+  bool lookup_secondary_supers_table(Klass *k) const;\n+  bool linear_search_secondary_supers(const Klass* k) const;\n+  bool fallback_search_secondary_supers(const Klass* k, int index, uintx rotated_bitmap) const;\n+\n@@ -409,1 +414,1 @@\n-  static constexpr int SECONDARY_SUPERS_TABLE_SIZE = sizeof(_bitmap) * 8;\n+  static constexpr int SECONDARY_SUPERS_TABLE_SIZE = sizeof(_secondary_supers_bitmap) * 8;\n@@ -430,1 +435,3 @@\n-  static ByteSize bitmap_offset()                { return byte_offset_of(Klass, _bitmap); }\n+  static ByteSize secondary_supers_bitmap_offset()\n+                                                 { return byte_offset_of(Klass, _secondary_supers_bitmap); }\n+  static ByteSize hash_slot_offset()             { return byte_offset_of(Klass, _hash_slot); }\n@@ -530,13 +537,0 @@\n-  \/\/ subtype check: true if is_subclass_of, or if k is interface and receiver implements it\n-  bool is_subtype_of(Klass* k) const {\n-    juint    off = k->super_check_offset();\n-    Klass* sup = *(Klass**)( (address)this + off );\n-    const juint secondary_offset = in_bytes(secondary_super_cache_offset());\n-    if (sup == k) {\n-      return true;\n-    } else if (off != secondary_offset) {\n-      return false;\n-    } else {\n-      return search_secondary_supers(k);\n-    }\n-  }\n@@ -544,1 +538,2 @@\n-  bool search_secondary_supers(Klass* k) const;\n+  \/\/ subtype check: true if is_subclass_of, or if k is interface and receiver implements it\n+  bool is_subtype_of(Klass* k) const;\n@@ -546,0 +541,1 @@\n+public:\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/rotate_bits.hpp\"\n@@ -79,0 +80,66 @@\n+\/\/ subtype check: true if is_subclass_of, or if k is interface and receiver implements it\n+inline bool Klass::is_subtype_of(Klass* k) const {\n+  guarantee(secondary_supers() != nullptr, \"must be\");\n+  const juint off = k->super_check_offset();\n+  const juint secondary_offset = in_bytes(secondary_super_cache_offset());\n+  if (off == secondary_offset) {\n+    return search_secondary_supers(k);\n+  } else {\n+    Klass* sup = *(Klass**)( (address)this + off );\n+    return (sup == k);\n+  }\n+}\n+\n+\/\/ Hashed search for secondary super k.\n+inline bool Klass::lookup_secondary_supers_table(Klass* k) const {\n+  uintx bitmap = _secondary_supers_bitmap;\n+\n+  constexpr int highest_bit_number = SECONDARY_SUPERS_TABLE_SIZE - 1;\n+  uint8_t slot = k->_hash_slot;\n+  uintx shifted_bitmap = bitmap << (highest_bit_number - slot);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  if ((shifted_bitmap >> highest_bit_number) == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Calculate the initial hash probe\n+  int index = population_count(shifted_bitmap) - 1;\n+  if (secondary_supers()->at(index) == k) {\n+    \/\/ Yes! It worked the first time.\n+    return true;\n+  }\n+\n+  \/\/ Is there another entry to check? Consult the bitmap. If Bit 1,\n+  \/\/ the next bit to test, is zero, we are certain that super_klass is\n+  \/\/ not one of the secondary supers.\n+  bitmap = rotate_right(bitmap, slot);\n+  if ((bitmap & 2) == 0) {\n+    return false;\n+  }\n+\n+  \/\/ Continue probing the hash table\n+  return fallback_search_secondary_supers(k, index, bitmap);\n+}\n+\n+inline bool Klass::search_secondary_supers(Klass *k) const {\n+  \/\/ This is necessary because I am never in my own secondary_super list.\n+  if (this == k)\n+    return true;\n+\n+  bool result = lookup_secondary_supers_table(k);\n+\n+#ifndef PRODUCT\n+  if (VerifySecondarySupers) {\n+    bool linear_result = linear_search_secondary_supers(k);\n+    if (linear_result != result) {\n+      on_secondary_supers_verification_failure((Klass*)this, k, linear_result, result, \"mismatch\");\n+    }\n+  }\n+#endif \/\/ PRODUCT\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"}]}