{"files":[{"patch":"@@ -303,1 +303,6 @@\n-  return SafeFetchN((intptr_t*)&block->_active_index, 0);\n+  \/\/ Be careful, because block could be a false positive from block_for_ptr.\n+  assert(block != nullptr, \"precondition\");\n+  uintptr_t block_addr = reinterpret_cast<uintptr_t>(block);\n+  uintptr_t index_loc = block_addr + offset_of(Block, _active_index);\n+  static_assert(sizeof(size_t) == sizeof(intptr_t), \"assumption\");\n+  return static_cast<size_t>(SafeFetchN(reinterpret_cast<intptr_t*>(index_loc), 0));\n@@ -369,1 +374,1 @@\n-  \/\/ Const-ness of ptr is not related to const-ness of containing block.\n+  assert(ptr != nullptr, \"precondition\");\n@@ -371,1 +376,1 @@\n-  oop* section_start = align_down(const_cast<oop*>(ptr), block_alignment);\n+  uintptr_t section_start = align_down(reinterpret_cast<uintptr_t>(ptr), block_alignment);\n@@ -374,1 +379,2 @@\n-  oop* section = section_start - (section_size * (section_count - 1));\n+  size_t section_size_in_bytes = sizeof(oop) * section_size;\n+  uintptr_t section = section_start - (section_size_in_bytes * (section_count - 1));\n@@ -380,4 +386,5 @@\n-  for (unsigned i = 0; i < section_count; ++i, section += section_size) {\n-    Block* candidate = reinterpret_cast<Block*>(section);\n-    if (SafeFetchN(&candidate->_owner_address, 0) == owner_addr) {\n-      return candidate;\n+  for (unsigned i = 0; i < section_count; ++i, section += section_size_in_bytes) {\n+    uintptr_t owner_loc = section + offset_of(Block, _owner_address);\n+    static_assert(sizeof(OopStorage*) == sizeof(intptr_t), \"assumption\");\n+    if (SafeFetchN(reinterpret_cast<intptr_t*>(owner_loc), 0) == owner_addr) {\n+      return reinterpret_cast<Block*>(section);\n@@ -646,2 +653,1 @@\n-OopStorage::Block* OopStorage::find_block_or_null(const oop* ptr) const {\n-  assert(ptr != nullptr, \"precondition\");\n+OopStorage::Block* OopStorage::block_for_ptr(const oop* ptr) const {\n@@ -774,1 +780,1 @@\n-  Block* block = find_block_or_null(ptr);\n+  Block* block = block_for_ptr(ptr);\n@@ -785,1 +791,1 @@\n-    Block* block = find_block_or_null(ptrs[i]);\n+    Block* block = block_for_ptr(ptrs[i]);\n@@ -992,1 +998,2 @@\n-  const Block* block = find_block_or_null(ptr);\n+  if (ptr == nullptr) return INVALID_ENTRY;\n+  const Block* block = block_for_ptr(ptr);\n@@ -1140,1 +1147,1 @@\n-    Block* block = find_block_or_null(addr);\n+    Block* block = block_for_ptr(addr);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-  Block* find_block_or_null(const oop* ptr) const;\n+  Block* block_for_ptr(const oop* ptr) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,4 @@\n-  \/\/ Returns null if ptr is not in a block or not allocated in that block.\n+  \/\/ Return block of owner containing ptr, if ptr is a valid entry of owner.\n+  \/\/ If ptr is not a valid entry of owner then returns either null or a \"false\n+  \/\/ positive\" pointer; see allocation_status.\n+  \/\/ precondition: ptr != nullptr\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -96,0 +96,12 @@\n+\n+  static const oop* get_block_pointer(const Block& block, unsigned index) {\n+    return block.get_pointer(index);\n+  }\n+\n+  static Block* new_block(const OopStorage& owner) {\n+    return Block::new_block(&owner);\n+  }\n+\n+  static void delete_block(const Block& block) {\n+    Block::delete_block(block);\n+  }\n@@ -521,9 +533,7 @@\n-#ifndef DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS\n-TEST_VM_F(OopStorageTest, invalid_pointer) {\n-  {\n-    char* mem = NEW_C_HEAP_ARRAY(char, 1000, mtInternal);\n-    oop* ptr = reinterpret_cast<oop*>(align_down(mem + 250, sizeof(oop)));\n-    \/\/ Predicate returns false for some malloc'ed block.\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n-    FREE_C_HEAP_ARRAY(char, mem);\n-  }\n+TEST_VM_F(OopStorageTest, invalid_malloc_pointer) {\n+  char* mem = NEW_C_HEAP_ARRAY(char, 1000, mtInternal);\n+  oop* ptr = reinterpret_cast<oop*>(align_down(mem + 250, sizeof(oop)));\n+  \/\/ Predicate returns false for some malloc'ed block.\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n+  FREE_C_HEAP_ARRAY(char, mem);\n+}\n@@ -531,6 +541,20 @@\n-  {\n-    oop obj;\n-    oop* ptr = &obj;\n-    \/\/ Predicate returns false for some \"random\" location.\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n-  }\n+TEST_VM_F(OopStorageTest, invalid_random_pointer) {\n+  oop obj;\n+  oop* ptr = &obj;\n+  \/\/ Predicate returns false for some \"random\" location.\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n+}\n+\n+TEST_VM_F(OopStorageTest, invalid_block_pointer) {\n+  \/\/ Allocate a block for storage, but don't insert it into the storage.  This\n+  \/\/ also tests the false positive case of block_for_ptr where we have a\n+  \/\/ reference to storage at just the \"right\" place.\n+  const OopBlock* block = TestAccess::new_block(storage());\n+  ASSERT_NE(block, NULL_BLOCK);\n+  const oop* ptr = TestAccess::get_block_pointer(*block, 0);\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n+  TestAccess::delete_block(*block);\n+}\n+\n+TEST_VM_F(OopStorageTest, invalid_null_pointer) {\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(nullptr));\n@@ -538,1 +562,0 @@\n-#endif \/\/ DISABLE_GARBAGE_ALLOCATION_STATUS_TESTS\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"}]}