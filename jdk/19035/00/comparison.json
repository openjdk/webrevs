{"files":[{"patch":"@@ -778,1 +778,1 @@\n-    if (_nmethod_entry_patch_offset == -1 && install_default) {\n+    if (_nmethod_entry_patch_offset == -1) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot.aarch64\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -246,0 +246,21 @@\n+    public class Bookmark implements AutoCloseable {\n+        private final int registerMark = nextRegister;\n+        private final int codePos = code.position();\n+        private final int dataPos = data.position();\n+\n+        @Override\n+        public void close() {\n+            nextRegister = registerMark;\n+            code.data.position(codePos);\n+            data.data.position(dataPos);\n+        }\n+    }\n+\n+    \/**\n+     * Enters a scope in which the current register, code and data emitting state\n+     * is restored upon leaving the scope.\n+     *\/\n+    public Bookmark bookmark() {\n+        return new Bookmark();\n+    }\n+\n@@ -299,0 +320,12 @@\n+    \/**\n+     * Emits the 32 bit constant `c` into the data section.\n+     *\/\n+    public DataSectionReference emitDataItem(int c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+\n+        recordDataPatchInCode(ref);\n+        data.emitInt(c);\n+        return ref;\n+    }\n+\n@@ -324,0 +357,44 @@\n+    \/**\n+     * @param n Number of bits that should be set to 1. Must be between 0 and 32 (inclusive).\n+     * @return A number with n bits set to 1.\n+     *\/\n+    public static int getNbitNumberInt(int n) {\n+        assert n >= 0 && n <= 32 : \"0 <= n <= 32; instead: \" + n;\n+        if (n < 32) {\n+            return (1 << n) - 1;\n+        } else {\n+            return 0xFFFFFFFF;\n+        }\n+    }\n+\n+    public static boolean isSignedNbit(int n, int value) {\n+        assert n > 0 && n < 32 : n;\n+        int min = -(1 << (n - 1));\n+        int max = (1 << (n - 1)) - 1;\n+        return value >= min && value <= max;\n+    }\n+\n+    public static boolean isUnsignedNbit(int n, int value) {\n+        assert n > 0 && n < 32 : n;\n+        return 32 - Integer.numberOfLeadingZeros(value) <= n;\n+    }\n+\n+    \/**\n+     * Determines if `x` is in the range of signed byte values.\n+     *\/\n+    public static boolean isByte(int x) {\n+        return (byte) x == x;\n+    }\n+\n+    \/**\n+     * Determines if `l` is in the range of signed int values.\n+     *\/\n+    public static boolean isInt(long l) {\n+        return (int) l == l;\n+    }\n+\n+    public static void check(boolean condition, String errorMessage, Object... args) {\n+        if (!condition) {\n+            throw new AssertionError(errorMessage.formatted(args));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestAssembler.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+        nmethodEntryBarrierConcurrentPatch = initNmethodEntryBarrierConcurrentPatch(arch);\n@@ -50,0 +51,2 @@\n+    public final int MARKID_FRAME_COMPLETE = getConstant(\"CodeInstaller::FRAME_COMPLETE\", Integer.class);\n+    public final int MARKID_ENTRY_BARRIER_PATCH = getConstant(\"CodeInstaller::ENTRY_BARRIER_PATCH\", Integer.class);\n@@ -56,0 +59,25 @@\n+\n+    private Boolean initNmethodEntryBarrierConcurrentPatch(Architecture arch) {\n+        Boolean patchConcurrent = null;\n+        if (arch instanceof AArch64 && nmethodEntryBarrier != 0) {\n+            Integer patchingType = getFieldValue(\"CompilerToVM::Data::BarrierSetAssembler_nmethod_patching_type\", Integer.class, \"int\");\n+            if (patchingType != null) {\n+                \/\/ There currently only 2 variants in use that differ only by the presence of a\n+                \/\/ dmb instruction\n+                int stw = getConstant(\"NMethodPatchingType::stw_instruction_and_data_patch\", Integer.class);\n+                int conc = getConstant(\"NMethodPatchingType::conc_data_patch\", Integer.class);\n+                if (patchingType == stw) {\n+                    patchConcurrent = false;\n+                } else if (patchingType == conc) {\n+                    patchConcurrent = true;\n+                } else {\n+                    throw new IllegalArgumentException(\"unsupported barrier sequence \" + patchingType);\n+                }\n+            }\n+        }\n+        return patchConcurrent;\n+    }\n+\n+    public final int threadDisarmedOffset = getFieldValue(\"CompilerToVM::Data::thread_disarmed_guard_value_offset\", Integer.class, \"int\");\n+    public final long nmethodEntryBarrier = getFieldValue(\"CompilerToVM::Data::nmethod_entry_barrier\", Long.class, \"address\");\n+    public final Boolean nmethodEntryBarrierConcurrentPatch;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestHotSpotVMConfig.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;\n@@ -49,0 +50,1 @@\n+    private static final Register scratchRegister2 = AArch64.rscratch2;\n@@ -51,0 +53,60 @@\n+    \/**\n+     * Condition Flags for branches. See C1.2.4\n+     *\/\n+    public enum ConditionFlag {\n+        \/\/ Integer | Floating-point meanings\n+        \/** Equal | Equal. *\/\n+        EQ(0x0),\n+\n+        \/** Not Equal | Not equal or unordered. *\/\n+        NE(0x1),\n+\n+        \/** Unsigned Higher or Same | Greater than, equal or unordered. *\/\n+        HS(0x2),\n+\n+        \/** Unsigned lower | less than. *\/\n+        LO(0x3),\n+\n+        \/** Minus (negative) | less than. *\/\n+        MI(0x4),\n+\n+        \/** Plus (positive or zero) | greater than, equal or unordered. *\/\n+        PL(0x5),\n+\n+        \/** Overflow set | unordered. *\/\n+        VS(0x6),\n+\n+        \/** Overflow clear | ordered. *\/\n+        VC(0x7),\n+\n+        \/** Unsigned higher | greater than or unordered. *\/\n+        HI(0x8),\n+\n+        \/** Unsigned lower or same | less than or equal. *\/\n+        LS(0x9),\n+\n+        \/** Signed greater than or equal | greater than or equal. *\/\n+        GE(0xA),\n+\n+        \/** Signed less than | less than or unordered. *\/\n+        LT(0xB),\n+\n+        \/** Signed greater than | greater than. *\/\n+        GT(0xC),\n+\n+        \/** Signed less than or equal | less than, equal or unordered. *\/\n+        LE(0xD),\n+\n+        \/** Always | always. *\/\n+        AL(0xE),\n+\n+        \/** Always | always (identical to AL, just to have valid 0b1111 encoding). *\/\n+        NV(0xF);\n+\n+        public final int encoding;\n+\n+        ConditionFlag(int encoding) {\n+            this.encoding = encoding;\n+        }\n+    }\n+\n@@ -218,0 +280,16 @@\n+    \/**\n+     * C6.2.25 Branch conditionally.\n+     *\n+     * @param condition may not be null.\n+     * @param imm21 Signed 21-bit offset, has to be 4-byte aligned.\n+     *\/\n+    protected void emitBranch(ConditionFlag condition, int imm21) {\n+        \/\/ B.cond\n+        check(isSignedNbit(21, imm21) && (imm21 & 0b11) == 0,\n+              \"0x%x must be a 21-bit signed number and 4-byte aligned\", imm21);\n+        int imm19 = (imm21 & getNbitNumberInt(21)) >> 2;\n+        code.emitInt(f(0b001010100, 31, 24)\n+                     | f(imm19, 23, 4)\n+                     | f(condition.encoding, 3, 0));\n+    }\n+\n@@ -264,0 +342,2 @@\n+        emitNMethodEntryBarrier();\n+\n@@ -267,0 +347,13 @@\n+    private void emitNMethodEntryBarrier() {\n+        recordMark(config.MARKID_ENTRY_BARRIER_PATCH);\n+        DataSectionReference ref = emitDataItem(0);\n+        emitLoadPointer(scratchRegister, AArch64Kind.DWORD, ref);\n+        if (config.nmethodEntryBarrierConcurrentPatch) {\n+            code.emitInt(0xd50339bf); \/\/ dmb ishld\n+        }\n+        emitLoadPointer(scratchRegister2, AArch64Kind.DWORD, AArch64HotSpotRegisterConfig.threadRegister, config.threadDisarmedOffset);\n+        code.emitInt(0x6b09011f);             \/\/ cmp w8, w9\n+        emitBranch(ConditionFlag.EQ, 8);      \/\/ jump over slow path, runtime call\n+        emitCall(config.nmethodEntryBarrier);\n+    }\n+\n@@ -364,2 +457,5 @@\n-        Register ret = newRegister();\n-        emitLoadRegister(ret, AArch64Kind.QWORD, b, offset);\n+        return emitLoadPointer(newRegister(), AArch64Kind.QWORD, b, offset);\n+    }\n+\n+    public Register emitLoadPointer(Register ret, AArch64Kind kind, Register b, int offset) {\n+        emitLoadRegister(ret, kind, b, offset);\n@@ -380,0 +476,4 @@\n+        return emitLoadPointer(newRegister(), AArch64Kind.QWORD, ref);\n+    }\n+\n+    public Register emitLoadPointer(Register ret, AArch64Kind kind, DataSectionReference ref) {\n@@ -382,2 +482,1 @@\n-        Register ret = newRegister();\n-        emitLoadRegister(ret, AArch64Kind.QWORD, 0xdead);\n+        emitLoadRegister(ret, kind, 0xdead);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":103,"deletions":4,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -52,0 +52,34 @@\n+    \/**\n+     * The x86 condition codes used for conditional jumps\/moves.\n+     *\/\n+    public enum ConditionFlag {\n+        Zero(0x4, \"|zero|\"),\n+        NotZero(0x5, \"|nzero|\"),\n+        Equal(0x4, \"=\"),\n+        NotEqual(0x5, \"!=\"),\n+        Less(0xc, \"<\"),\n+        LessEqual(0xe, \"<=\"),\n+        Greater(0xf, \">\"),\n+        GreaterEqual(0xd, \">=\"),\n+        Below(0x2, \"|<|\"),\n+        BelowEqual(0x6, \"|<=|\"),\n+        Above(0x7, \"|>|\"),\n+        AboveEqual(0x3, \"|>=|\"),\n+        Overflow(0x0, \"|of|\"),\n+        NoOverflow(0x1, \"|nof|\"),\n+        CarrySet(0x2, \"|carry|\"),\n+        CarryClear(0x3, \"|ncarry|\"),\n+        Negative(0x8, \"|neg|\"),\n+        Positive(0x9, \"|pos|\"),\n+        Parity(0xa, \"|par|\"),\n+        NoParity(0xb, \"|npar|\");\n+\n+        public final int value;\n+        public final String operator;\n+\n+        ConditionFlag(int value, String operator) {\n+            this.value = value;\n+            this.operator = operator;\n+        }\n+    }\n+\n@@ -66,0 +100,56 @@\n+    \/**\n+     * Emit the expected patchable code sequence for the nmethod entry barrier. The int sized\n+     * payload must be naturally aligned so it can be patched atomically.\n+     *\/\n+    private void emitNMethodEntryCompare(int displacement) {\n+        \/\/ cmp dword ptr [r15 + <displacement>], 0x00000000\n+        \/\/ 41 81 7f <db> 00 00 00 00\n+        code.emitByte(0x41);\n+        code.emitByte(0x81);\n+        code.emitByte(0x7f);\n+        check(isByte(displacement), \"expected byte sized displacement: 0x%x\", displacement);\n+        code.emitByte(displacement & 0xff);\n+        check(code.position() % 4 == 0, \"must be aligned\");\n+        code.emitInt(0);\n+    }\n+\n+    \/**\n+     * Emits a long (i.e. 6 byte) format conditional branch.\n+     *\n+     * @param offset the offset of the branch target wrt the start of the branch instruction\n+     *\/\n+    private void emitBranch(ConditionFlag condition, int offset) {\n+        final int longSize = 6;\n+        int disp32 = offset - longSize;\n+\n+        \/\/ 0000 1111 1000 tttn #32-bit disp\n+        check(isInt(disp32), \"must be 32bit disp: %d\", disp32);\n+        code.emitByte(0x0F);\n+        code.emitByte(0x80 | condition.value);\n+        code.emitInt(disp32);\n+    }\n+\n+    public void emitAlign(int modulus) {\n+        while (code.position() % modulus != 0) {\n+            code.emitByte(0x90);\n+        }\n+    }\n+\n+    private void emitNMethodEntryBarrier() {\n+        \/\/ The following code sequence must be emitted in exactly this fashion as HotSpot\n+        \/\/ will check that the barrier is the expected code sequence.\n+        emitAlign(4);\n+        recordMark(config.MARKID_FRAME_COMPLETE);\n+        recordMark(config.MARKID_ENTRY_BARRIER_PATCH);\n+        emitNMethodEntryCompare(config.threadDisarmedOffset);\n+        int branchOffset;\n+        try (Bookmark bm = bookmark()) {\n+            int pos = code.position();\n+            emitBranch(ConditionFlag.Equal, 0);\n+            emitCall(config.nmethodEntryBarrier);\n+            branchOffset = code.position() - pos;\n+        }\n+        emitBranch(ConditionFlag.Equal, branchOffset);\n+        emitCall(config.nmethodEntryBarrier);\n+    }\n+\n@@ -74,0 +164,1 @@\n+        emitNMethodEntryBarrier();\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/amd64\/AMD64TestAssembler.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"}]}