{"files":[{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEMONITOR_HPP\n+#define SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEMONITOR_HPP\n+\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+\n+class JfrSampleMonitor : public StackObj {\n+ private:\n+  JfrThreadLocal* const _tl;\n+  Monitor* const _sample_monitor;\n+  mutable bool _waiting;\n+ public:\n+  JfrSampleMonitor(JfrThreadLocal* tl) :\n+    _tl(tl), _sample_monitor(tl->sample_monitor()), _waiting(false) {\n+    assert(tl != nullptr, \"invariant\");\n+    assert(_sample_monitor != nullptr, \"invariant\");\n+    _sample_monitor->lock_without_safepoint_check();\n+  }\n+\n+  bool is_waiting() const {\n+    assert_lock_strong(_sample_monitor);\n+    _waiting = _tl->sample_state() == WAITING_FOR_NATIVE_SAMPLE;\n+    return _waiting;\n+  }\n+\n+  void install_java_sample_request() {\n+    assert_lock_strong(_sample_monitor);\n+    assert(_waiting, \"invariant\");\n+    assert(_tl->sample_state() == WAITING_FOR_NATIVE_SAMPLE, \"invariant\");\n+    JfrSampleRequest request;\n+    request._sample_ticks = JfrTicks::now();\n+    _tl->set_sample_request(request);\n+    _tl->set_sample_state(JAVA_SAMPLE);\n+    _sample_monitor->notify_all();\n+  }\n+\n+  ~JfrSampleMonitor() {\n+    assert_lock_strong(_sample_monitor);\n+    if (!_waiting) {\n+      _tl->set_sample_state(NO_SAMPLE);\n+      _sample_monitor->notify_all();\n+    }\n+    _sample_monitor->unlock();\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEMONITOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleMonitor.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -51,4 +51,5 @@\n-  NO_SAMPLE = 0,\n-  NATIVE_SAMPLE = 1,\n-  JAVA_SAMPLE = 2,\n-  NOF_SAMPLE_TYPES\n+  NO_SAMPLE,\n+  JAVA_SAMPLE,\n+  NATIVE_SAMPLE,\n+  WAITING_FOR_NATIVE_SAMPLE,\n+  NOF_SAMPLE_STATES\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrSampleMonitor.hpp\"\n@@ -233,29 +234,31 @@\n-  {\n-    MutexLocker tlock(Threads_lock);\n-    ThreadsListHandle tlh;\n-    \/\/ Resolve a sample session relative start position index into the thread list array.\n-    \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n-    _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n-    JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n-\n-    while (num_samples < sample_limit) {\n-      current = next_thread(tlh.list(), start, current);\n-      if (current == nullptr) {\n-        break;\n-      }\n-      if (is_excluded(current)) {\n-        continue;\n-      }\n-      if (start == nullptr) {\n-        start = current; \/\/ remember the thread where we started to attempt sampling\n-      }\n-      bool success;\n-      if (JAVA_SAMPLE == type) {\n-        success = sample_java_thread(current);\n-      } else {\n-        assert(type == NATIVE_SAMPLE, \"invariant\");\n-        success = sample_native_thread(current);\n-      }\n-      if (success) {\n-        num_samples++;\n-      }\n+  ThreadsListHandle tlh;\n+  \/\/ Resolve a sample session relative start position index into the thread list array.\n+  \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n+  _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n+  JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n+\n+  while (num_samples < sample_limit) {\n+    current = next_thread(tlh.list(), start, current);\n+    if (current == nullptr) {\n+      break;\n+    }\n+    if (is_excluded(current)) {\n+      continue;\n+    }\n+    if (start == nullptr) {\n+      start = current; \/\/ remember the thread where we started to attempt sampling\n+    }\n+    bool success;\n+    if (JAVA_SAMPLE == type) {\n+      success = sample_java_thread(current);\n+    } else {\n+      assert(type == NATIVE_SAMPLE, \"invariant\");\n+      success = sample_native_thread(current);\n+    }\n+    if (success) {\n+      num_samples++;\n+    }\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      \/\/ For _thread_in_native, we cannot get the Threads_lock.\n+      \/\/ For _thread_in_Java, well, there are none.\n+      break;\n@@ -263,1 +266,0 @@\n-    *last_thread = current; \/\/ remember the thread we last attempted to sample\n@@ -265,0 +267,2 @@\n+\n+  *last_thread = current; \/\/ remember the thread we last attempted to sample\n@@ -341,5 +345,14 @@\n-  \/\/ Barriers needed to keep the next read of thread state from floating up.\n-  if (UseSystemMemoryBarrier) {\n-    SystemMemoryBarrier::emit();\n-  } else {\n-    OrderAccess::storeload();\n+  \/\/ Take the Threads_lock for two purposes:\n+  \/\/ 1) Avoid sampling through a safepoint which could result\n+  \/\/    in touching oops in case of virtual threads.\n+  \/\/ 2) Prevent JFR from issuing an epoch rotation while the sampler thread\n+  \/\/    is actively processing a thread in native, as both threads are now\n+  \/\/    outside the safepoint protocol.\n+\n+  \/\/ OrderAccess::fence() as part of acquiring the lock prevents loads from floating up.\n+  JfrMutexTryLock threads_lock(Threads_lock);\n+\n+  if (!threads_lock.acquired() || !jt->has_last_Java_frame()) {\n+    \/\/ Remove the native sample request and release the potentially waiting thread.\n+    JfrSampleMonitor jsm(tl);\n+    return false;\n@@ -348,4 +361,10 @@\n-  if (jt->thread_state() != _thread_in_native || !jt->has_last_Java_frame()) {\n-    MonitorLocker lock(tl->sample_monitor(), Monitor::_no_safepoint_check_flag);\n-    tl->set_sample_state(NO_SAMPLE);\n-    lock.notify_all();\n+  if (jt->thread_state() != _thread_in_native) {\n+    assert_lock_strong(Threads_lock);\n+    JfrSampleMonitor jsm(tl);\n+    if (jsm.is_waiting()) {\n+      \/\/ The thread has already returned from native,\n+      \/\/ now in _thread_in_vm and is waiting to be sampled.\n+      \/\/ Convert the native sample request into a java sample request\n+      \/\/ and let the thread process the ljf on its own.\n+      jsm.install_java_sample_request();\n+    }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":58,"deletions":39,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrSampleMonitor.hpp\"\n@@ -310,18 +311,0 @@\n-class SampleMonitor : public StackObj {\n- private:\n-  JfrThreadLocal* const _tl;\n-  Monitor* const _sample_monitor;\n- public:\n-  SampleMonitor(JfrThreadLocal* tl) : _tl(tl), _sample_monitor(tl->sample_monitor()) {\n-    assert(tl != nullptr, \"invariant\");\n-    assert(_sample_monitor != nullptr, \"invariant\");\n-    _sample_monitor->lock_without_safepoint_check();\n-  }\n-  ~SampleMonitor() {\n-    assert_lock_strong(_sample_monitor);\n-    _tl->set_sample_state(NO_SAMPLE);\n-    _sample_monitor->notify_all();\n-    _sample_monitor->unlock();\n-  }\n-};\n-\n@@ -337,1 +320,3 @@\n-  assert(tl->sample_state() == NATIVE_SAMPLE, \"invariant\");\n+  assert(tl->sample_state() >= NATIVE_SAMPLE, \"invariant\");\n+\n+  assert_lock_strong(Threads_lock);\n@@ -345,1 +330,1 @@\n-    SampleMonitor sm(tl);\n+    JfrSampleMonitor sm(tl);\n@@ -387,0 +372,1 @@\n+      tl->set_sample_state(WAITING_FOR_NATIVE_SAMPLE);\n@@ -391,0 +377,3 @@\n+    } else if (sample_state == WAITING_FOR_NATIVE_SAMPLE) {\n+      \/\/ Handle spurious wakeups. Again wait until stack trace is processed.\n+      ml.wait();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"}]}