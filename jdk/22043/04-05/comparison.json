{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Arrays;\n@@ -39,1 +38,0 @@\n-import jdk.internal.util.ArraysSupport;\n@@ -231,2 +229,0 @@\n-     * Backing storage is expanded and trimmed automatically.\n-     * Insert\/remove run in amortized constant time.\n@@ -235,4 +231,11 @@\n-        private static final int MIN_CAPACITY = 16;\n-        private final Object lock = new Object();\n-        private PhantomCleanable<?>[] arr;\n-        private int size;\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node with variable size.\n+         * All nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n@@ -241,2 +244,1 @@\n-            this.arr = new PhantomCleanable<?>[MIN_CAPACITY];\n-            this.size = 0;\n+            this.head = new Node();\n@@ -250,4 +252,2 @@\n-        public boolean isEmpty() {\n-            synchronized (lock) {\n-                return size == 0;\n-            }\n+        public synchronized boolean isEmpty() {\n+            return (head.next == null && head.size == 0);\n@@ -259,12 +259,7 @@\n-        public void insert(PhantomCleanable<?> phc) {\n-            synchronized (lock) {\n-                \/\/ Resize if needed.\n-                int oldLen = arr.length;\n-                if (oldLen <= size) {\n-                    int newLen = ArraysSupport.newLength(oldLen, 1, oldLen);\n-                    arr = Arrays.copyOf(arr, newLen);\n-                }\n-                \/\/ Inserting at the end, record the indexes.\n-                phc.index = size;\n-                arr[size] = phc;\n-                size++;\n+        public synchronized void insert(PhantomCleanable<?> phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head is full, insert new one.\n+                Node newHead = new Node();\n+                newHead.next = head;\n+                head.prev = newHead;\n+                head = newHead;\n@@ -272,0 +267,7 @@\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            phc.node = head;\n+            phc.index = head.size;\n+            head.arr[head.size] = phc;\n+            head.size++;\n@@ -280,7 +282,17 @@\n-        public boolean remove(PhantomCleanable<?> phc) {\n-            synchronized (lock) {\n-                int thisIdx = phc.index;\n-                if (thisIdx == -1) {\n-                    \/\/ Not in the list.\n-                    return false;\n-                }\n+        public synchronized boolean remove(PhantomCleanable<?> phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+            assert head.size > 0;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            if (head != phc.node || (phc.index != head.size - 1)) {\n+                PhantomCleanable<?> mover = head.arr[head.size - 1];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n@@ -288,12 +300,12 @@\n-                \/\/ Unlink PhantomCleanable.\n-                assert arr[phc.index] == phc;\n-                phc.index = -1;\n-\n-                int lastIdx = size - 1;\n-                if (lastIdx != thisIdx) {\n-                    \/\/ Move the last, still alive element at current index,\n-                    \/\/ overwriting the removed one. Update its index to a new location.\n-                    PhantomCleanable<?> last = arr[lastIdx];\n-                    last.index = thisIdx;\n-                    arr[thisIdx] = last;\n-                }\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head.\n+            \/\/ If head node becomes empty after this, yank it.\n+            head.arr[head.size - 1] = null;\n+            head.size--;\n+            if (head.size == 0) {\n+               Node newHead = head.next;\n+               newHead.prev = null;\n+               head = newHead;\n+            }\n@@ -301,13 +313,2 @@\n-                \/\/ Cut the tail.\n-                arr[lastIdx] = null;\n-                size--;\n-\n-                \/\/ Capacity control: trim the backing storage if it looks like\n-                \/\/ we have a lot of wasted space there. Resizing on insertion would\n-                \/\/ double the array size, so this is our best case. Therefore, we want\n-                \/\/ to check if less than a quarter of the array is busy. We also do not\n-                \/\/ want to cause an immediate resize on next insertion.\n-                if ((size < arr.length \/ 4) && (size > MIN_CAPACITY)) {\n-                    int newLen = ArraysSupport.newLength(size, 1, size);\n-                    arr = Arrays.copyOf(arr, newLen);\n-                }\n+            return true;\n+        }\n@@ -315,2 +316,11 @@\n-                return true;\n-            }\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleanables, and the amount of elements in it.\n+            final PhantomCleanable<?>[] arr = new PhantomCleanable<?>[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node prev;\n+            Node next;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":70,"deletions":60,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -52,1 +52,7 @@\n-     * Index of this PhantomCleanable in the list.\n+     * Node for this PhantomCleanable in the list.\n+     * Synchronized by the same lock as the list itself.\n+     *\/\n+    CleanerImpl.PhantomCleanableList.Node node;\n+\n+    \/**\n+     * Index of this PhantomCleanable in the list node.\n@@ -73,1 +79,2 @@\n-        \/\/ Check that list insertion populated the index.\n+        \/\/ Check that list insertion populated the backlinks.\n+        assert node != null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"}]}