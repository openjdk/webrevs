{"files":[{"patch":"@@ -33,1 +33,1 @@\n-import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -39,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -234,2 +235,9 @@\n-        private final ArrayList<PhantomCleanable<?>> list = new ArrayList<>();\n-        private int maxIdx;\n+        private static final int MIN_CAPACITY = 16;\n+        private final Object lock = new Object();\n+        private PhantomCleanable<?>[] arr;\n+        private int size;\n+\n+        public PhantomCleanableList() {\n+            this.arr = new PhantomCleanable<?>[MIN_CAPACITY];\n+            this.size = 0;\n+        }\n@@ -243,2 +251,2 @@\n-            synchronized (list) {\n-                return list.isEmpty();\n+            synchronized (lock) {\n+                return size == 0;\n@@ -252,1 +260,7 @@\n-            synchronized (list) {\n+            synchronized (lock) {\n+                \/\/ Resize if needed.\n+                int oldLen = arr.length;\n+                if (oldLen <= size) {\n+                    int newLen = ArraysSupport.newLength(oldLen, 1, oldLen);\n+                    arr = Arrays.copyOf(arr, newLen);\n+                }\n@@ -254,3 +268,3 @@\n-                phc.index = maxIdx = list.size();\n-                list.add(phc);\n-                assert list.get(phc.index) == phc;\n+                phc.index = size;\n+                arr[size] = phc;\n+                size++;\n@@ -267,1 +281,1 @@\n-            synchronized (list) {\n+            synchronized (lock) {\n@@ -275,1 +289,1 @@\n-                assert list.get(phc.index) == phc;\n+                assert arr[phc.index] == phc;\n@@ -278,1 +292,1 @@\n-                int lastIdx = list.size() - 1;\n+                int lastIdx = size - 1;\n@@ -282,1 +296,1 @@\n-                    PhantomCleanable<?> last = list.get(lastIdx);\n+                    PhantomCleanable<?> last = arr[lastIdx];\n@@ -284,1 +298,1 @@\n-                    list.set(thisIdx, last);\n+                    arr[thisIdx] = last;\n@@ -287,2 +301,3 @@\n-                \/\/ Cut the tail. Runs in constant time.\n-                list.remove(lastIdx);\n+                \/\/ Cut the tail.\n+                arr[lastIdx] = null;\n+                size--;\n@@ -291,4 +306,7 @@\n-                \/\/ we have a lot of wasted space there.\n-                if (list.size() > maxIdx * 2) {\n-                    list.trimToSize();\n-                    maxIdx = list.size() - 1;\n+                \/\/ we have a lot of wasted space there. Resizing on insertion would\n+                \/\/ double the array size, so this is our best case. Therefore, we want\n+                \/\/ to check if less than a quarter of the array is busy. We also do not\n+                \/\/ want to cause an immediate resize on next insertion.\n+                if ((size < arr.length \/ 4) && (size > MIN_CAPACITY)) {\n+                    int newLen = ArraysSupport.newLength(size, 1, size);\n+                    arr = Arrays.copyOf(arr, newLen);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-        this.index = -1;\n-        this.list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+        index = -1;\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}