{"files":[{"patch":"@@ -51,1 +51,1 @@\n-     * Heads of a CleanableList for each reference type.\n+     * Currently active PhantomCleanable-s.\n@@ -53,1 +53,1 @@\n-    final PhantomCleanable<?> phantomCleanableList;\n+    final CleanableList activeList;\n@@ -85,1 +85,1 @@\n-        phantomCleanableList = new PhantomCleanableRef();\n+        activeList = new CleanableList();\n@@ -132,1 +132,1 @@\n-        while (!phantomCleanableList.isListEmpty()) {\n+        while (!activeList.isEmpty()) {\n@@ -168,8 +168,0 @@\n-        \/**\n-         * Constructor used only for root of phantom cleanable list.\n-         *\/\n-        PhantomCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n@@ -234,0 +226,130 @@\n+\n+    \/**\n+     * A specialized implementation that tracks phantom cleanables.\n+     *\/\n+    static final class CleanableList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node with variable size.\n+         * All nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanableList() {\n+            reset();\n+        }\n+\n+        \/**\n+         * Testing support: reset list to initial state.\n+         *\/\n+        synchronized void reset() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Returns true if cleanable list is empty.\n+         *\n+         * @return true if the list is empty\n+         *\/\n+        public synchronized boolean isEmpty() {\n+            \/\/ Head node size is zero only when the entire list is empty.\n+            return head.size == 0;\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleanable in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleanable<?> phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            phc.node = head;\n+            phc.index = head.size;\n+            head.arr[head.size] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleanable from the list.\n+         *\n+         * @return true if Cleanable was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleanable<?> phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+            assert head.size > 0;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            if (head != phc.node || (phc.index != head.size - 1)) {\n+                PhantomCleanable<?> mover = head.arr[head.size - 1];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[head.size - 1] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleanables, and the amount of elements in it.\n+            final PhantomCleanable<?>[] arr = new PhantomCleanable<?>[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":134,"deletions":12,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * Links to previous and next in a doubly-linked list.\n+     * The list of PhantomCleanable; synchronizes insert and remove.\n@@ -49,1 +49,1 @@\n-    PhantomCleanable<?> prev = this, next = this;\n+    private final CleanerImpl.CleanableList list;\n@@ -52,1 +52,2 @@\n-     * The list of PhantomCleanable; synchronizes insert and remove.\n+     * Node for this PhantomCleanable in the list.\n+     * Synchronized by the same lock as the list itself.\n@@ -54,1 +55,7 @@\n-    private final PhantomCleanable<?> list;\n+    CleanerImpl.CleanableList.Node node;\n+\n+    \/**\n+     * Index of this PhantomCleanable in the list node.\n+     * Synchronized by the same lock as the list itself.\n+     *\/\n+    int index;\n@@ -65,0 +72,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -67,2 +75,7 @@\n-        this.list = CleanerImpl.getCleanerImpl(cleaner).phantomCleanableList;\n-        insert();\n+        index = -1;\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+        list.insert(this);\n+\n+        \/\/ Check that list insertion populated the backlinks.\n+        assert node != null;\n+        assert index >= 0;\n@@ -75,50 +88,0 @@\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    PhantomCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this PhantomCleanable after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this PhantomCleanable from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n@@ -131,1 +94,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n@@ -143,1 +106,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":21,"deletions":58,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343704\n+ * @library \/test\/lib\n+ * @compile\/module=java.base jdk\/internal\/ref\/CleanableListTestHelper.java jdk\/internal\/ref\/TestCleanable.java\n+ * @modules java.base\/jdk.internal.ref\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.ref=ALL-UNNAMED CleanableListTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.Random;\n+import jdk.internal.ref.CleanableListTestHelper;\n+import jdk.internal.ref.TestCleanable;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.Ignore;\n+\n+public class CleanableListTest {\n+\n+    static final int SINGLE_NODE_CAPACITY = CleanableListTestHelper.NODE_CAPACITY - 1;\n+    static final int MULTI_NODE_CAPACITY = CleanableListTestHelper.NODE_CAPACITY * 4;\n+\n+    static final int RANDOM_ITERATIONS = 10_000_000;\n+\n+    @Test\n+    public void testSingle() {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+        TestCleanable tc = list.newCleanable();\n+        Assert.assertFalse(list.isEmpty());\n+        Assert.assertTrue(list.remove(tc));\n+        Assert.assertTrue(list.isEmpty());\n+        Assert.assertFalse(list.remove(tc));\n+    }\n+\n+    @Test\n+    public void testSequential_Single() {\n+        doSequential(SINGLE_NODE_CAPACITY);\n+    }\n+\n+    @Test\n+    public void testSequential_Multi() {\n+        doSequential(MULTI_NODE_CAPACITY);\n+    }\n+\n+    private void doSequential(int size) {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+\n+        List<TestCleanable> tcs = new ArrayList<>();\n+        for (int c = 0; c < size; c++) {\n+            tcs.add(list.newCleanable());\n+        }\n+        Assert.assertFalse(list.isEmpty());\n+\n+        for (TestCleanable tc : tcs) {\n+            Assert.assertTrue(list.remove(tc));\n+        }\n+        Assert.assertTrue(list.isEmpty());\n+    }\n+\n+    @Test\n+    public void testRandom_Single() {\n+        doRandom(SINGLE_NODE_CAPACITY);\n+    }\n+\n+    @Test\n+    public void testRandom_Multi() {\n+        doRandom(MULTI_NODE_CAPACITY);\n+    }\n+\n+    private void doRandom(int size) {\n+        CleanableListTestHelper list = new CleanableListTestHelper();\n+        Assert.assertTrue(list.isEmpty());\n+\n+        Random r = new Random(42);\n+        BitSet bs = new BitSet(size);\n+\n+        List<TestCleanable> tcs = new ArrayList<>();\n+        for (int c = 0; c < size; c++) {\n+            tcs.add(list.newCleanable());\n+            bs.set(c, true);\n+        }\n+        Assert.assertFalse(list.isEmpty());\n+\n+        for (int t = 0; t < RANDOM_ITERATIONS; t++) {\n+            int idx = r.nextInt(size);\n+            TestCleanable tc = tcs.get(idx);\n+            if (bs.get(idx)) {\n+                Assert.assertTrue(list.remove(tc));\n+                bs.set(idx, false);\n+            } else {\n+                Assert.assertFalse(list.remove(tc));\n+                list.insert(tc);\n+                bs.set(idx, true);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/CleanableListTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ref;\n+\n+import java.lang.ref.Cleaner;\n+import jdk.internal.ref.PhantomCleanable;\n+import jdk.internal.ref.CleanerImpl;\n+import jdk.internal.ref.CleanerImpl.CleanableList;\n+\n+\/**\n+ * This class provides package-private access to CleanableList internals.\n+ *\/\n+public class CleanableListTestHelper {\n+\n+    public static final int NODE_CAPACITY = CleanableList.NODE_CAPACITY;\n+\n+    final Cleaner cleaner;\n+    final CleanableList list;\n+\n+    public CleanableListTestHelper() {\n+        cleaner = Cleaner.create();\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+\n+        \/\/ List contains CleanerCleanable for Cleaner itself.\n+        \/\/ For testing empty list paths, we want to drop it.\n+        list.reset();\n+    }\n+\n+    public TestCleanable newCleanable() {\n+        return new TestCleanable(cleaner);\n+    }\n+\n+    public void insert(PhantomCleanable cl) {\n+        list.insert(cl);\n+    }\n+\n+    public boolean remove(PhantomCleanable cl) {\n+        return list.remove(cl);\n+    }\n+\n+    public boolean isEmpty() {\n+        return list.isEmpty();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/java.base\/jdk\/internal\/ref\/CleanableListTestHelper.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ref;\n+\n+import java.lang.ref.Cleaner;\n+\n+public class TestCleanable extends PhantomCleanable<Object> {\n+    static final Object TARGET = new Object();\n+\n+    public TestCleanable(Cleaner cleaner) {\n+        super(TARGET, cleaner);\n+    }\n+\n+    @Override\n+    protected void performCleanup() {\n+        \/\/ no action\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/java.base\/jdk\/internal\/ref\/TestCleanable.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean register = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return new Target(register);\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        public Target(boolean register) {\n+            if (register) {\n+                CLEANER.register(this, () -> {});\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerChurn.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 5, jvmArgs = {\"-Xmx512m\", \"-Xms512m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Deliberately a linked list to avoid exposing external parallelism to GC.\n+    Target prev;\n+\n+    @Setup\n+    public void setup() {\n+        Target prev = null;\n+        for (int c = 0; c < count; c++) {\n+            prev = new Target(prev);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        private final Target prev;\n+        public Target(Target prev) {\n+            this.prev = prev;\n+            CLEANER.register(this, () -> {});\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerGC.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}