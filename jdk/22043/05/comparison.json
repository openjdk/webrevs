{"files":[{"patch":"@@ -51,1 +51,1 @@\n-     * Heads of a CleanableList for each reference type.\n+     * Currently active PhantomCleanable-s.\n@@ -53,1 +53,1 @@\n-    final PhantomCleanable<?> phantomCleanableList;\n+    final PhantomCleanableList activeList;\n@@ -85,1 +85,1 @@\n-        phantomCleanableList = new PhantomCleanableRef();\n+        activeList = new PhantomCleanableList();\n@@ -132,1 +132,1 @@\n-        while (!phantomCleanableList.isListEmpty()) {\n+        while (!activeList.isEmpty()) {\n@@ -168,8 +168,0 @@\n-        \/**\n-         * Constructor used only for root of phantom cleanable list.\n-         *\/\n-        PhantomCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n@@ -234,0 +226,103 @@\n+\n+    \/**\n+     * A specialized implementation that tracks phantom cleanables.\n+     *\/\n+    static final class PhantomCleanableList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node with variable size.\n+         * All nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        public PhantomCleanableList() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Returns true if cleanable list is empty.\n+         *\n+         * @return true if the list is empty\n+         *\/\n+        public synchronized boolean isEmpty() {\n+            return (head.next == null && head.size == 0);\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleanable in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleanable<?> phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head is full, insert new one.\n+                Node newHead = new Node();\n+                newHead.next = head;\n+                head.prev = newHead;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            phc.node = head;\n+            phc.index = head.size;\n+            head.arr[head.size] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleanable from the list.\n+         *\n+         * @return true if Cleanable was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleanable<?> phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+            assert head.size > 0;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            if (head != phc.node || (phc.index != head.size - 1)) {\n+                PhantomCleanable<?> mover = head.arr[head.size - 1];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head.\n+            \/\/ If head node becomes empty after this, yank it.\n+            head.arr[head.size - 1] = null;\n+            head.size--;\n+            if (head.size == 0) {\n+               Node newHead = head.next;\n+               newHead.prev = null;\n+               head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleanables, and the amount of elements in it.\n+            final PhantomCleanable<?>[] arr = new PhantomCleanable<?>[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node prev;\n+            Node next;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":107,"deletions":12,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * Links to previous and next in a doubly-linked list.\n+     * The list of PhantomCleanable; synchronizes insert and remove.\n@@ -49,1 +49,1 @@\n-    PhantomCleanable<?> prev = this, next = this;\n+    private final CleanerImpl.PhantomCleanableList list;\n@@ -52,1 +52,2 @@\n-     * The list of PhantomCleanable; synchronizes insert and remove.\n+     * Node for this PhantomCleanable in the list.\n+     * Synchronized by the same lock as the list itself.\n@@ -54,1 +55,7 @@\n-    private final PhantomCleanable<?> list;\n+    CleanerImpl.PhantomCleanableList.Node node;\n+\n+    \/**\n+     * Index of this PhantomCleanable in the list node.\n+     * Synchronized by the same lock as the list itself.\n+     *\/\n+    int index;\n@@ -65,0 +72,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -67,2 +75,7 @@\n-        this.list = CleanerImpl.getCleanerImpl(cleaner).phantomCleanableList;\n-        insert();\n+        index = -1;\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+        list.insert(this);\n+\n+        \/\/ Check that list insertion populated the backlinks.\n+        assert node != null;\n+        assert index >= 0;\n@@ -75,50 +88,0 @@\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    PhantomCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this PhantomCleanable after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this PhantomCleanable from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n@@ -131,1 +94,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n@@ -143,1 +106,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":21,"deletions":58,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean register = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return new Target(register);\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        public Target(boolean register) {\n+            if (register) {\n+                CLEANER.register(this, () -> {});\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerChurn.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 5, jvmArgs = {\"-Xmx512m\", \"-Xms512m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Deliberately a linked list to avoid exposing external parallelism to GC.\n+    Target prev;\n+\n+    @Setup\n+    public void setup() {\n+        Target prev = null;\n+        for (int c = 0; c < count; c++) {\n+            prev = new Target(prev);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        private final Target prev;\n+        public Target(Target prev) {\n+            this.prev = prev;\n+            CLEANER.register(this, () -> {});\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerGC.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}