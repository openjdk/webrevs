{"files":[{"patch":"@@ -243,0 +243,8 @@\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n@@ -269,2 +277,9 @@\n-                \/\/ Head is full, insert new one.\n-                Node newHead = new Node();\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n@@ -312,3 +327,0 @@\n-            \/\/ If head node becomes empty after this, and there are\n-            \/\/ nodes that follow it, replace the head node with another\n-            \/\/ full one.\n@@ -317,0 +329,4 @@\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n@@ -318,3 +334,8 @@\n-               Node newHead = head.next;\n-               newHead.prev = null;\n-               head = newHead;\n+                Node newHead = head.next;\n+                newHead.prev = null;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.prev = null;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"}]}