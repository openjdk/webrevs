{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -38,0 +39,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -51,1 +53,1 @@\n-     * Heads of a CleanableList for each reference type.\n+     * Currently active PhantomCleanable-s.\n@@ -53,1 +55,1 @@\n-    final PhantomCleanable<?> phantomCleanableList;\n+    final PhantomCleanableList activeList;\n@@ -85,1 +87,1 @@\n-        phantomCleanableList = new PhantomCleanableRef();\n+        activeList = new PhantomCleanableList();\n@@ -132,1 +134,1 @@\n-        while (!phantomCleanableList.isListEmpty()) {\n+        while (!activeList.isEmpty()) {\n@@ -168,8 +170,0 @@\n-        \/**\n-         * Constructor used only for root of phantom cleanable list.\n-         *\/\n-        PhantomCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n@@ -234,0 +228,91 @@\n+\n+    \/**\n+     * A specialized implementation that tracks phantom cleanables.\n+     * Backing storage is expanded and trimmed automatically.\n+     * Insert\/remove run in amortized constant time.\n+     *\/\n+    static final class PhantomCleanableList {\n+        private static final int MIN_CAPACITY = 16;\n+        private final Object lock = new Object();\n+        private PhantomCleanable<?>[] arr;\n+        private int size;\n+\n+        public PhantomCleanableList() {\n+            this.arr = new PhantomCleanable<?>[MIN_CAPACITY];\n+            this.size = 0;\n+        }\n+\n+        \/**\n+         * Returns true if cleanable list is empty.\n+         *\n+         * @return true if the list is empty\n+         *\/\n+        public boolean isEmpty() {\n+            synchronized (lock) {\n+                return size == 0;\n+            }\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleanable in the list.\n+         *\/\n+        public void insert(PhantomCleanable<?> phc) {\n+            synchronized (lock) {\n+                \/\/ Resize if needed.\n+                int oldLen = arr.length;\n+                if (oldLen <= size) {\n+                    int newLen = ArraysSupport.newLength(oldLen, 1, oldLen);\n+                    arr = Arrays.copyOf(arr, newLen);\n+                }\n+                \/\/ Inserting at the end, record the indexes.\n+                phc.index = size;\n+                arr[size] = phc;\n+                size++;\n+            }\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleanable from the list.\n+         *\n+         * @return true if Cleanable was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public boolean remove(PhantomCleanable<?> phc) {\n+            synchronized (lock) {\n+                int thisIdx = phc.index;\n+                if (thisIdx == -1) {\n+                    \/\/ Not in the list.\n+                    return false;\n+                }\n+\n+                \/\/ Unlink PhantomCleanable.\n+                assert arr[phc.index] == phc;\n+                phc.index = -1;\n+\n+                int lastIdx = size - 1;\n+                if (lastIdx != thisIdx) {\n+                    \/\/ Move the last, still alive element at current index,\n+                    \/\/ overwriting the removed one. Update its index to a new location.\n+                    PhantomCleanable<?> last = arr[lastIdx];\n+                    last.index = thisIdx;\n+                    arr[thisIdx] = last;\n+                }\n+\n+                \/\/ Cut the tail.\n+                arr[lastIdx] = null;\n+                size--;\n+\n+                \/\/ Capacity control: trim the backing storage if it looks like\n+                \/\/ we have a lot of wasted space there. Resizing on insertion would\n+                \/\/ double the array size, so this is our best case. Therefore, we want\n+                \/\/ to check if less than a quarter of the array is busy. We also do not\n+                \/\/ want to cause an immediate resize on next insertion.\n+                if ((size < arr.length \/ 4) && (size > MIN_CAPACITY)) {\n+                    int newLen = ArraysSupport.newLength(size, 1, size);\n+                    arr = Arrays.copyOf(arr, newLen);\n+                }\n+\n+                return true;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":97,"deletions":12,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * Links to previous and next in a doubly-linked list.\n+     * The list of PhantomCleanable; synchronizes insert and remove.\n@@ -49,1 +49,1 @@\n-    PhantomCleanable<?> prev = this, next = this;\n+    private final CleanerImpl.PhantomCleanableList list;\n@@ -52,1 +52,2 @@\n-     * The list of PhantomCleanable; synchronizes insert and remove.\n+     * Index of this PhantomCleanable in the list.\n+     * Synchronized by the same lock as the list itself.\n@@ -54,1 +55,1 @@\n-    private final PhantomCleanable<?> list;\n+    int index;\n@@ -65,0 +66,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -67,2 +69,6 @@\n-        this.list = CleanerImpl.getCleanerImpl(cleaner).phantomCleanableList;\n-        insert();\n+        index = -1;\n+        list = CleanerImpl.getCleanerImpl(cleaner).activeList;\n+        list.insert(this);\n+\n+        \/\/ Check that list insertion populated the index.\n+        assert index >= 0;\n@@ -75,50 +81,0 @@\n-    \/**\n-     * Construct a new root of the list; not inserted.\n-     *\/\n-    PhantomCleanable() {\n-        super(null, null);\n-        this.list = this;\n-    }\n-\n-    \/**\n-     * Insert this PhantomCleanable after the list head.\n-     *\/\n-    private void insert() {\n-        synchronized (list) {\n-            prev = list;\n-            next = list.next;\n-            next.prev = this;\n-            list.next = this;\n-        }\n-    }\n-\n-    \/**\n-     * Remove this PhantomCleanable from the list.\n-     *\n-     * @return true if Cleanable was removed or false if not because\n-     * it had already been removed before\n-     *\/\n-    private boolean remove() {\n-        synchronized (list) {\n-            if (next != this) {\n-                next.prev = prev;\n-                prev.next = next;\n-                prev = this;\n-                next = this;\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the list's next reference refers to itself.\n-     *\n-     * @return true if the list is empty\n-     *\/\n-    boolean isListEmpty() {\n-        synchronized (list) {\n-            return list == list.next;\n-        }\n-    }\n-\n@@ -131,1 +87,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n@@ -143,1 +99,1 @@\n-        if (remove()) {\n+        if (list.remove(this)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":14,"deletions":58,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgs = {\"-Xmx256m\", \"-Xms256m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerChurn {\n+\n+    @Param({\"128\", \"256\", \"512\", \"1024\", \"2048\"})\n+    int recipFreq;\n+\n+    @Benchmark\n+    public Object test() {\n+        boolean register = ThreadLocalRandom.current().nextInt(recipFreq) == 0;\n+        return new Target(register);\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        public Target(boolean register) {\n+            if (register) {\n+                CLEANER.register(this, () -> {});\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerChurn.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Cleaner.Cleanable;\n+import java.util.LinkedList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 5, jvmArgs = {\"-Xmx512m\", \"-Xms512m\", \"-XX:+AlwaysPreTouch\"})\n+public class CleanerGC {\n+\n+    @Param({\"16384\", \"65536\", \"262144\", \"1048576\", \"4194304\"})\n+    int count;\n+\n+    \/\/ Deliberately a linked list to avoid exposing external parallelism to GC.\n+    Target prev;\n+\n+    @Setup\n+    public void setup() {\n+        Target prev = null;\n+        for (int c = 0; c < count; c++) {\n+            prev = new Target(prev);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void test() {\n+        System.gc();\n+    }\n+\n+    static class Target {\n+        private static final Cleaner CLEANER = Cleaner.create();\n+        private final Target prev;\n+        public Target(Target prev) {\n+            this.prev = prev;\n+            CLEANER.register(this, () -> {});\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/CleanerGC.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}