{"files":[{"patch":"@@ -754,0 +754,4 @@\n+  \/\/\n+  \/\/ In some cases, there are other relevant initial memory states besides\n+  \/\/ initial_mem. In such cases, we are rather dealing with multiple trees and\n+  \/\/ their fringes.\n@@ -772,0 +776,34 @@\n+  Block* initial_mem_block = get_block_for_node(initial_mem);\n+  assert(initial_mem_block != nullptr, \"sanity\");\n+  if (load->in(0) != nullptr) {\n+    \/\/ If the load has an explicit control input, walk up the dominator tree\n+    \/\/ from the early block (inclusive) to the initial memory block\n+    \/\/ (inclusive). When traversing the blocks, we look for Phi(s) that can alias\n+    \/\/ initial_mem, these are also potential initial memory states and there\n+    \/\/ may be further required anti-dependences due to them.\n+    assert(initial_mem_block->dominates(early), \"invariant\");\n+    Block* b = early;\n+    \/\/ Stop searching when we step past the initial memory block (b ==\n+    \/\/ initial_mem_block->_idom). The loop below always terminates because the\n+    \/\/ root block strictly dominates initial_mem_block.\n+    while (b != initial_mem_block->_idom) {\n+      assert(b != nullptr, \"sanity\");\n+      if (b == initial_mem_block && !initial_mem->is_Phi()) {\n+        \/\/ If we are in the initial memory block, and initial_mem is not itself\n+        \/\/ a Phi, no Phis in the block can be initial memory states.\n+        break;\n+      }\n+      \/\/ We need to process all memory Phi nodes in the block. We may not have\n+      \/\/ run LCM yet, so we cannot assume anything regarding the location of\n+      \/\/ Phi nodes within the block. Therefore, we must search the entire\n+      \/\/ block.\n+      for (uint i = 0; i < b->number_of_nodes(); ++i) {\n+        Node* n = b->get_node(i);\n+        if (n->is_memory_phi() && C->can_alias(n->adr_type(), load_alias_idx) && n != initial_mem) {\n+          \/\/ We have found a relevant Phi initial memory state\n+          worklist_def_use_mem_states.push(nullptr, n);\n+        }\n+      }\n+      b = b->_idom;\n+    }\n+  }\n@@ -794,2 +832,2 @@\n-    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n-        || op == Op_MergeMem    \/\/ internal node of tree we are searching\n+    if (def_mem_state == nullptr \/\/ root of a tree we are searching\n+        || op == Op_MergeMem     \/\/ internal node of tree we are searching\n@@ -798,2 +836,0 @@\n-      if (use_mem_state == initial_mem)\n-        initial_mem = nullptr;  \/\/ only process initial memory once\n@@ -867,3 +903,0 @@\n-      \/\/ Loop-phis need to raise load before input. (Other phis are treated\n-      \/\/ as store below.)\n-      \/\/\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.codegen;\n+\n+\/**\n+ * @test\n+ * @bug 8333393\n+ * @summary Test that loads are not scheduled too late.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main compiler.codegen.TestGCMLoadPlacement\n+ *\/\n+\n+public class TestGCMLoadPlacement {\n+\n+    public static void main(String[] args) {\n+        Test1.run();\n+        Test2.run();\n+        Test3.run();\n+        Test4.run();\n+        Test5.run();\n+    }\n+\n+    static class Test1 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int i = 0; i < 50; ++i)\n+                for (int j = 0; j < 50; ++j) {\n+                    if (flag) { return 0; } \/\/ Forces peeling\n+                    iFld = 0;\n+                    for (int k = 0; k < 1; ++k) {\n+\n+                    }\n+                }\n+            int res = iFld; \/\/ This load needs to schedule before the loop below ...\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 42;\n+            }\n+            \/\/ ... and was incorrectly scheduled here.\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test1 t = new Test1();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test2 {\n+        static void run() {\n+            for (int i = 0; i < 500; i++) {\n+                int res = test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"res = \" + res);\n+                }\n+            }\n+        }\n+\n+        static int test() {\n+            int res = 0;\n+            int array[] = new int[50];\n+            for (int j = 0; j < array.length; j++) {\n+                array[j] = 0;\n+            }\n+            int x = array[0];\n+            for (int i = 5; i < 10; i++) {\n+                array[0] = 42;\n+                for (int j = 0; j < 10; j++) {\n+                    dontInline();\n+                    res = x;\n+                }\n+            }\n+            return res;\n+        }\n+\n+        static void dontInline() {}\n+    }\n+\n+    static class Test3 {\n+        static boolean flag;\n+        static int N = 400;\n+        long instanceCount;\n+        float fFld = 2.957F;\n+        volatile short sFld;\n+        int iArrFld[] = new int[N];\n+\n+        int test() {\n+            int i22 = 7, i25, i27, i28 = 5, i29, i31, i33;\n+            for (i25 = 229; i25 > 2; --i25) {\n+                if (flag) { return 9; }\n+                iArrFld[1] *= instanceCount;\n+                for (i27 = 4; i27 < 116; ++i27) {\n+                }\n+            }\n+            i22 += fFld;\n+            for (i29 = 23; 8 < i29; i29--) {\n+                for (i31 = 2; i31 < 17; i31++) {\n+                    if (flag) { return 9; }\n+                    i28 = sFld;\n+                }\n+                for (i33 = 1; 7 > i33; ++i33) {\n+                    if (flag) { return 9; }\n+                    fFld = instanceCount;\n+                }\n+            }\n+            return i22;\n+        }\n+\n+        static void run() {\n+            Test3 r = new Test3();\n+            int result = r.test();\n+            if (result != 9) {\n+                throw new RuntimeException(\"Expected 9 but found \" + result);\n+            }\n+        }\n+    }\n+\n+    static class Test4 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int j = 0; j < 50; ++j) {\n+                iFld = 0;\n+                if (flag) { return 0; }\n+\n+                for (int k = 0; k < 2000; ++k) {\n+                }\n+            }\n+\n+            int res = iFld;\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 1;\n+            }\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test4 t = new Test4();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test5 {\n+        int a = 1;\n+        int test() {\n+            int f, g = 0, h[] = new int[a];\n+            double j = 72.18064;\n+            for (int i = 0; i < 7; ++i)\n+                for (int i2 = 0; i2 < 4; i2++) {\n+                    g += ++h[0];\n+                    while (--j > 0)\n+                        ;\n+                }\n+            int c = 0;\n+            for (int k = 0; k < h.length; k++) {\n+                c += h[k];\n+            }\n+            return c;\n+        }\n+        static void run() {\n+            Test5 s = new Test5();\n+            int res = s.test();\n+            if (res != 28) {\n+                throw new RuntimeException(\"Unexpected result: \" + res);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMLoadPlacement.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}