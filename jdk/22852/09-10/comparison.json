{"files":[{"patch":"@@ -785,5 +785,7 @@\n-  \/\/ There are rare situations where multiple memory nodes are valid inputs to\n-  \/\/ the load. That is, we could replace the actual memory input to the load\n-  \/\/ (initial_mem) with any of these nodes and still preserve ideal graph\n-  \/\/ validity. Whether such situations are accidental and possibly avoidable is\n-  \/\/ a topic for future investigation.\n+  \/\/ There are rare situations where multiple memory nodes represent the same\n+  \/\/ memory state for a load. That is, we could replace the actual memory input\n+  \/\/ to the load (initial_mem) with any of these nodes and the ideal graph\n+  \/\/ would still represent the same program. Whether such situations are\n+  \/\/ accidental and possibly avoidable is a topic for future investigation. We\n+  \/\/ first look at two examples of such situations, and then give a more formal\n+  \/\/ justification.\n@@ -791,5 +793,6 @@\n-  \/\/ In the following, we refer to equivalent memory nodes as additional\n-  \/\/ (search) roots. If we do not search for anti-dependences from all roots,\n-  \/\/ it is possible that we do not discover all relevant anti-dependences.\n-  \/\/ Below are two cases seen in practice where it is necessary to find the\n-  \/\/ additional roots.\n+  \/\/ In the following, we refer to the set of memory nodes representing the\n+  \/\/ same memory state of a load as the (search) roots. We refer to this set\n+  \/\/ with initial_mem removed as the additional (search) roots. If we do not\n+  \/\/ search for anti-dependences from all roots, it is possible that we do not\n+  \/\/ discover all relevant anti-dependences. Below are two cases seen in\n+  \/\/ practice where it is necessary to find the additional roots.\n@@ -863,5 +866,9 @@\n-  \/\/ We now turn to how to identify all search roots. First, a few more\n-  \/\/ definitions:\n-  \/\/ - L is live = an anti-dependent store has not yet written to L\n-  \/\/ - Phi = a memory Phi node that aliases L\n-  \/\/ - Def = a (non-Phi) memory-defining node (e.g., a store)\n+  \/\/ We now turn to a more formal definition of search roots and how to\n+  \/\/ identify them. A search root is a memory node M for which all items below\n+  \/\/ hold.\n+  \/\/   1. M aliases initial_mem.\n+  \/\/   2. M is scheduled in a block dominated by initial_mem_block.\n+  \/\/   3. If M is scheduled in initial_mem_block, M does not occur before\n+  \/\/      initial_mem.\n+  \/\/   4. M is scheduled in a block dominating early.\n+  \/\/   5. If M is scheduled in early, M occurs before the load.\n@@ -869,9 +876,4 @@\n-  \/\/ Facts:\n-  \/\/ - If L is live, any simultaneously live memory node that can alias L is a\n-  \/\/   potential root.\n-  \/\/ - Roots only reside in blocks dominating the early block.\n-  \/\/ - L is by definition live just after initial_mem.\n-  \/\/ - If the initial_mem block strictly dominates the early block, L is\n-  \/\/   necessarily live all the way to the start of the early block.\n-  \/\/ - If initial_mem is a Phi, L is live at the entry of the initial_mem block\n-  \/\/   (Phis execute in parallel at the start of the block by definition).\n+  \/\/ Item 1 ensures M represents the correct part of memory (the load's alias\n+  \/\/ category). Items 2 and 3 ensure the load's memory state is defined (which\n+  \/\/ it may not be prior to initial_mem). Items 4 and 5 ensure M occurs before\n+  \/\/ the earliest point at which we may schedule the load.\n@@ -879,4 +881,9 @@\n-  \/\/ These facts together identify a range where L is certainly live. L can of\n-  \/\/ course also be live below this range. The actual anti-dependence search\n-  \/\/ later on attempts to expand the range downwards as far as possible (to\n-  \/\/ allow maximum scheduling flexibility with a low LCA).\n+  \/\/ Items 3 and 5 call for further elaboration. As we may not have run LCM\n+  \/\/ yet, we can only reason about the order between Phi and non-Phi memory\n+  \/\/ nodes. Phis, by definition, execute in parallel at the start of the block,\n+  \/\/ before any non-Phi nodes. Consequently, if initial_mem is a non-Phi node,\n+  \/\/ item 3 disallows any roots in initial_mem_block (except initial_mem\n+  \/\/ itself). Inversely, if initial_mem is a Phi, item 3 permits all memory\n+  \/\/ nodes in initial_mem_block as roots. Item 5 effectively implies that only\n+  \/\/ Phis in the early block may be roots, as we do not yet know where the load\n+  \/\/ will be scheduled.\n@@ -884,3 +891,1 @@\n-  \/\/ See the illustrations below for a visual representation of the facts\n-  \/\/ above. Note: the graphs are branches in the dominator tree, and not from\n-  \/\/ the CFG. Observations indicate that it is only necessary to consider Phi\n+  \/\/ Observations indicate that it is only necessary to consider Phi\n@@ -890,0 +895,4 @@\n+  \/\/ To make sense of the definition above, consider the different cases below.\n+  \/\/ All shown nodes alias initial_mem (item 1). The graphs are\n+  \/\/ branches in the dominator tree, and not from the CFG.\n+  \/\/\n@@ -891,6 +900,4 @@\n-  \/\/ +---------------------+\n-  \/\/ | Phi (not a root)    |\n-  \/\/ | ...                 | initial_mem_block (L is not live at entry)\n-  \/\/ | Def (initial_mem)   |\n-  \/\/ | ...                 |\n-  \/\/ +---------------------+\n+  \/\/ +-----------------------+\n+  \/\/ | Phi (not a root)      | initial_mem_block\n+  \/\/ | Non-Phi (initial_mem) |\n+  \/\/ +-----------------------+\n@@ -902,3 +909,3 @@\n-  \/\/        +-----+\n-  \/\/        | ... + in-between block (L is live in the whole block)\n-  \/\/        +-----+\n+  \/\/    +--------------+\n+  \/\/    | Phi (a root) |\n+  \/\/    +--------------+\n@@ -910,3 +917,4 @@\n-  \/\/     +------------+\n-  \/\/     | ...        | early (L is live at entry)\n-  \/\/     +------------+\n+  \/\/ +----------------------+\n+  \/\/ | Phi (a root)         | early\n+  \/\/ | Non-Phi (not a root) |\n+  \/\/ +----------------------+\n@@ -916,1 +924,1 @@\n-  \/\/ | Phi (a root)      | initial_mem_block (L is live in the whole block)\n+  \/\/ | Phi (a root)      | initial_mem_block\n@@ -925,6 +933,4 @@\n-  \/\/ +---------------------+\n-  \/\/ | Phi (not a root)    | early = initial_mem_block (L is not live at entry)\n-  \/\/ | ...                 |\n-  \/\/ | Def (initial_mem)   |\n-  \/\/ | ...                 |\n-  \/\/ +---------------------+\n+  \/\/ +-------------------------+\n+  \/\/ | Phi (not a root)        | early = initial_mem_block\n+  \/\/ | Non-Phi (initial_mem)   |\n+  \/\/ +-------------------------+\n@@ -934,1 +940,1 @@\n-  \/\/ | Phi (a root)      | early = initial_mem_block (L is live at entry)\n+  \/\/ | Phi (a root)      | early = initial_mem_block\n@@ -936,1 +942,0 @@\n-  \/\/ | ...               |\n@@ -939,3 +944,3 @@\n-  \/\/ Finally, below is the code for finding additional roots. We add a guard\n-  \/\/ (load->in(0) != nullptr) as observations indicate that we only need to\n-  \/\/ find additional roots if the load has an explicit control input.\n+  \/\/ Finally, below is the code for finding the additional roots. We add a\n+  \/\/ guard (load->in(0) != nullptr) as observations indicate that we only need\n+  \/\/ to find additional roots if the load has an explicit control input.\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":60,"deletions":55,"binary":false,"changes":115,"status":"modified"}]}