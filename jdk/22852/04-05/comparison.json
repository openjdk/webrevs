{"files":[{"patch":"@@ -755,1 +755,1 @@\n-  \/\/ In some cases, there are relevant memory state modifying nodes that we\n+  \/\/ In some cases, there are relevant anti-dependent memory nodes that we\n@@ -759,2 +759,1 @@\n-  \/\/ worklist_def_use_mem_states, which, prior to the main worklist loop below,\n-  \/\/ contains the search roots.\n+  \/\/ worklist_def_use_mem_states.\n@@ -785,6 +784,77 @@\n-  \/\/ We sometimes need to add additional search roots to discover all relevant\n-  \/\/ anti-dependent stores. The additional required search roots are alias\n-  \/\/ memory nodes of initial_mem on the dominator tree path from the initial\n-  \/\/ memory block (inclusive) to the early block (inclusive). Specifically, we\n-  \/\/ must consider Phi memory nodes as search roots as they terminate\n-  \/\/ anti-dependence searches reaching them from above.\n+\n+  \/\/ There are rare situations where multiple memory nodes are valid inputs to\n+  \/\/ the load. That is, we could replace the actual memory input to the load\n+  \/\/ (initial_mem) with any of these nodes and still have a semantically\n+  \/\/ equivalent graph. Whether such situations are accidental and possibly\n+  \/\/ avoidable is a topic for future investigation.\n+  \/\/\n+  \/\/ In the following, we refer to equivalent memory nodes as (search) roots.\n+  \/\/ If we do not search for anti-dependences from all roots, it is possible\n+  \/\/ that we do not discover all relevant anti-dependences. Below are two cases\n+  \/\/ seen in practice where it is necessary to find the additional roots.\n+  \/\/\n+  \/\/ Definitions:\n+  \/\/ - A = all of memory\n+  \/\/ - L = the memory for the load's alias category\n+  \/\/ - !L = all of memory except L\n+  \/\/\n+  \/\/ EXAMPLE 1\n+  \/\/ +----------------+\n+  \/\/ | 1 MachProj (A) |\n+  \/\/ +----------------+  +-------------------------------+\n+  \/\/       |             |                               |\n+  \/\/       V             V                               |\n+  \/\/ +-----------------------+                           |\n+  \/\/ | 2 Phi (L) <- 1 6      |                           |\n+  \/\/ | 3 MergeMem (A) <- 1 2 |                           |\n+  \/\/ +-----------------------+                           |\n+  \/\/     |          |                                    |\n+  \/\/     |          V                                    |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |   | 4 Store (L) <- 2      |                   |\n+  \/\/     |   | 5 MergeMem (A) <- 1 4 |                   |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |          |                                    |\n+  \/\/     V          V                                    |\n+  \/\/ +-------------------------------+                   |\n+  \/\/ | 6 Phi (L, initial_mem) <- 2 4 | initial_mem_block |\n+  \/\/ | 7 Phi (A) <- 3 5              |                   |\n+  \/\/ +-------------------------------+                   |\n+  \/\/           |     |                                   |\n+  \/\/           V     +-----------------------------------+\n+  \/\/ +-----------------------+\n+  \/\/ | 8 membar_release <- 7 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this example, initial_mem is 6 Phi, but a critical anti-dependent\n+  \/\/ memory use for the load is 8 membar_release. If we do not consider 7 Phi\n+  \/\/ (which subsumes and overlaps 6 Phi) as a search root, we do not find this\n+  \/\/ anti dependence and will likely end up scheduling the load too late.\n+  \/\/\n+  \/\/ EXAMPLE 2\n+  \/\/ +-----------------------------+\n+  \/\/ | 1 MachProj (A, initial_mem) | initial_mem_block\n+  \/\/ +-----------------------------+\n+  \/\/     |             |\n+  \/\/     |             V\n+  \/\/     |   +-----------------------+\n+  \/\/     |   | 2 Store (!L) <- 1     |\n+  \/\/     |   | 3 MergeMem (A) <- 1 2 |\n+  \/\/     |   +-----------------------+\n+  \/\/     |             |\n+  \/\/     V             V\n+  \/\/ +-------------------------------+\n+  \/\/ | 4 Phi (A) <- 1 3              |\n+  \/\/ +-------------------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ +-----------------------+\n+  \/\/ | 5 membar_release <- 7 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this next similar example, initial_mem is instead 1 MachProj. We fail\n+  \/\/ to reach the critical anti-dependent use 5 membar_release because the\n+  \/\/ anti-dependence search starting from 1 MachProj terminates at 4 Phi. We\n+  \/\/ must add 4 Phi as a search root.\n@@ -792,1 +862,5 @@\n-  \/\/ A situation where we need to add Phi search roots is the below.\n+  \/\/ We now turn to how to identify all search roots. First, a few more\n+  \/\/ definitions:\n+  \/\/ - L is live = an anti-dependent store has not yet written to L\n+  \/\/ - Phi = a memory Phi node that aliases L\n+  \/\/ - Def = a (non-Phi) memory-defining node (e.g., a store)\n@@ -794,25 +868,9 @@\n-  \/\/                    |\n-  \/\/ initial_mem_block  |\n-  \/\/             +-------------+\n-  \/\/             |...          |\n-  \/\/             |initial_mem  |\n-  \/\/             |...          |\n-  \/\/             +-------------+\n-  \/\/                \/        \\\n-  \/\/               \/          \\\n-  \/\/              ...        ...\n-  \/\/               \\          \/\n-  \/\/                \\        \/\n-  \/\/               +----------+\n-  \/\/               |...       |\n-  \/\/               |Phi       |\n-  \/\/               |...       |\n-  \/\/               +----------+\n-  \/\/                    |\n-  \/\/                    |\n-  \/\/          early     |\n-  \/\/         +---------------------+\n-  \/\/         |...                  |\n-  \/\/         |anti-dependent store |\n-  \/\/         |...                  |\n-  \/\/         +---------------------+\n+  \/\/ Facts:\n+  \/\/ - If L is live, any simultaneously live memory node that can alias L is a\n+  \/\/   potential root.\n+  \/\/ - Roots only reside in blocks dominating the early block.\n+  \/\/ - L is by definition live just after initial_mem.\n+  \/\/ - If the initial_mem block strictly dominates the early block, L is\n+  \/\/   necessarily live all the way to the start of the early block.\n+  \/\/ - If initial_mem is a Phi, L is live at the entry of the initial_mem block\n+  \/\/   (Phis execute in parallel at the start of the block by definition).\n@@ -820,5 +878,65 @@\n-  \/\/ Here, there are multiple CFG paths from initial_mem_block to the early\n-  \/\/ block. Importantly, there is a Phi memory node with initial_mem alive (not\n-  \/\/ overwritten) on all of its inputs. If we only add initial_mem as our\n-  \/\/ search root, our anti-dependence search will terminate at the Phi, and we\n-  \/\/ will never discover the anti-dependent store in the early block.\n+  \/\/ These facts together identify a range where L is certainly live. L can of\n+  \/\/ course also be live elsewhere both above and below this range. The actual\n+  \/\/ anti-dependence search later on attempts to expand the range downwards as\n+  \/\/ far as possible (to allow maximum scheduling flexibility with a low LCA).\n+  \/\/\n+  \/\/ See the illustrations below for a visual representation of the facts\n+  \/\/ above. Note: the graphs are branches in the dominator tree, and not from\n+  \/\/ the CFG. Observations indicate that it is only necessary to consider Phi\n+  \/\/ nodes as roots. From the Phi nodes, we then discover other relevant\n+  \/\/ non-Phi nodes naturally as part of the anti-dependence search.\n+  \/\/\n+  \/\/ CASE 1\n+  \/\/ +---------------------+\n+  \/\/ | Phi (not a root)    |\n+  \/\/ | ...                 | initial_mem_block (L is not live at entry)\n+  \/\/ | Def (initial_mem)   |\n+  \/\/ | ...                 |\n+  \/\/ +---------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/        +-----+\n+  \/\/        | ... + in-between block (L is live in the whole block)\n+  \/\/        +-----+\n+  \/\/           |\n+  \/\/           V\n+  \/\/          ...\n+  \/\/           |\n+  \/\/           V\n+  \/\/        +-----+\n+  \/\/        | ... + in-between block (L is live in the whole block)\n+  \/\/        +-----+\n+  \/\/           |\n+  \/\/           v\n+  \/\/     +------------+\n+  \/\/     | ...        | early (L is live at entry)\n+  \/\/     +------------+\n+  \/\/\n+  \/\/ CASE 2\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | initial_mem_block (L is live in whole block)\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ | ...               |\n+  \/\/ +-------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ ... (same as CASE 1) ...\n+  \/\/\n+  \/\/ CASE 3\n+  \/\/ +---------------------+\n+  \/\/ | Phi (not a root)    | early = initial_mem_block (L is not live at entry)\n+  \/\/ | ...                 |\n+  \/\/ | Def (initial_mem)   |\n+  \/\/ | ...                 |\n+  \/\/ +---------------------+\n+  \/\/\n+  \/\/ CASE 4\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | early = initial_mem_block (L is live at entry)\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ | ...               |\n+  \/\/ +-------------------+\n+  \/\/\n+  \/\/ Finally, below is the code for finding the roots. We add a guard\n+  \/\/ (load->in(0) != nullptr) as observations indicate that we only need to\n+  \/\/ find the roots if the load has an explicit control input.\n@@ -826,3 +944,0 @@\n-  \/\/ Observations indicate that extra search roots are only required if the\n-  \/\/ load has an explicit control input (hence the load->in(0) != nullptr check\n-  \/\/ below).\n@@ -830,1 +945,3 @@\n-    for(Block* b = early; b != initial_mem_block->_idom; b = b->_idom) {\n+    \/\/ Walk the relevant blocks from early (inclusive) up to initial_mem_block\n+    \/\/ (inclusive).\n+    for (Block* b = early; b != initial_mem_block->_idom; b = b->_idom) {\n@@ -833,4 +950,3 @@\n-        \/\/ If we are in initial_mem_block, and initial_mem is not itself\n-        \/\/ a Phi, it necessarily means that initial_mem is defined after all\n-        \/\/ Phis in the block. Therefore, no Phis in the block are relevant\n-        \/\/ search roots.\n+        \/\/ If we are in initial_mem_block, and initial_mem is not itself a Phi,\n+        \/\/ it necessarily means that initial_mem is defined after all Phis in\n+        \/\/ the block. Therefore, no Phis in the block are roots.\n@@ -839,4 +955,3 @@\n-      \/\/ We need to process all memory Phi nodes in the block. We may not have\n-      \/\/ run LCM yet, so we cannot assume anything regarding the location of\n-      \/\/ Phi nodes within the block. Therefore, we must search the entire\n-      \/\/ block.\n+      \/\/ We need to process all memory Phi nodes in the block. LCM may not have\n+      \/\/ run yet, so we cannot assume anything regarding the location of Phi\n+      \/\/ nodes within the block. Therefore, we must search the entire block.\n@@ -847,1 +962,2 @@\n-          \/\/ We have found a relevant Phi search root\n+          \/\/ We have found a relevant Phi search root. Add it to the worklist\n+          \/\/ in addition to initial_mem.\n@@ -853,0 +969,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":170,"deletions":53,"binary":false,"changes":223,"status":"modified"}]}