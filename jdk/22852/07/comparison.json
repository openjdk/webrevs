{"files":[{"patch":"@@ -754,0 +754,6 @@\n+  \/\/\n+  \/\/ In some cases, there are relevant anti-dependent memory nodes that we\n+  \/\/ cannot discover by searching from initial_mem. In such cases, we need to\n+  \/\/ expand our search with additional search roots. For details, see comments\n+  \/\/ and code below related to the initialization of\n+  \/\/ worklist_def_use_mem_states.\n@@ -771,0 +777,2 @@\n+\n+  \/\/ initial_mem is always a search root\n@@ -772,0 +780,190 @@\n+\n+  Block* initial_mem_block = get_block_for_node(initial_mem);\n+  assert(initial_mem_block != nullptr, \"sanity\");\n+  assert(initial_mem_block->dominates(early), \"invariant\");\n+\n+  \/\/ There are rare situations where multiple memory nodes are valid inputs to\n+  \/\/ the load. That is, we could replace the actual memory input to the load\n+  \/\/ (initial_mem) with any of these nodes and still have a semantically\n+  \/\/ equivalent graph. Whether such situations are accidental and possibly\n+  \/\/ avoidable is a topic for future investigation.\n+  \/\/\n+  \/\/ In the following, we refer to equivalent memory nodes as (search) roots.\n+  \/\/ If we do not search for anti-dependences from all roots, it is possible\n+  \/\/ that we do not discover all relevant anti-dependences. Below are two cases\n+  \/\/ seen in practice where it is necessary to find the additional roots.\n+  \/\/\n+  \/\/ Definitions:\n+  \/\/ - A = all of memory\n+  \/\/ - L = the memory for the load's alias category\n+  \/\/ - !L = all of memory except L\n+  \/\/\n+  \/\/ EXAMPLE 1\n+  \/\/ +----------------+\n+  \/\/ | 1 MachProj (A) |\n+  \/\/ +----------------+  +-------------------------------+\n+  \/\/       |             |                               |\n+  \/\/       V             V                               |\n+  \/\/ +-----------------------+                           |\n+  \/\/ | 2 Phi (L) <- 1 6      |                           |\n+  \/\/ | 3 MergeMem (A) <- 1 2 |                           |\n+  \/\/ +-----------------------+                           |\n+  \/\/     |          |                                    |\n+  \/\/     |          V                                    |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |   | 4 Store (L) <- 2      |                   |\n+  \/\/     |   | 5 MergeMem (A) <- 1 4 |                   |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |          |                                    |\n+  \/\/     V          V                                    |\n+  \/\/ +-------------------------------+                   |\n+  \/\/ | 6 Phi (L, initial_mem) <- 2 4 | initial_mem_block |\n+  \/\/ | 7 Phi (A) <- 3 5              |                   |\n+  \/\/ +-------------------------------+                   |\n+  \/\/           |     |                                   |\n+  \/\/           V     +-----------------------------------+\n+  \/\/ +-----------------------+\n+  \/\/ | 8 membar_release <- 7 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this example, initial_mem is 6 Phi, but a critical anti-dependent\n+  \/\/ memory use for the load is 8 membar_release. If we do not consider 7 Phi\n+  \/\/ (which subsumes and overlaps 6 Phi) as a search root, we do not find this\n+  \/\/ anti-dependence and will likely end up scheduling the load too late.\n+  \/\/\n+  \/\/ EXAMPLE 2\n+  \/\/ +-----------------------------+\n+  \/\/ | 1 MachProj (A, initial_mem) | initial_mem_block\n+  \/\/ +-----------------------------+\n+  \/\/     |             |\n+  \/\/     |             V\n+  \/\/     |   +-----------------------+\n+  \/\/     |   | 2 Store (!L) <- 1     |\n+  \/\/     |   | 3 MergeMem (A) <- 1 2 |\n+  \/\/     |   +-----------------------+\n+  \/\/     |             |\n+  \/\/     V             V\n+  \/\/ +-------------------------------+\n+  \/\/ | 4 Phi (A) <- 1 3              |\n+  \/\/ +-------------------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ +-----------------------+\n+  \/\/ | 5 membar_release <- 4 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this next example, initial_mem is instead 1 MachProj. We fail\n+  \/\/ to reach the critical anti-dependent use 5 membar_release because the\n+  \/\/ anti-dependence search starting from 1 MachProj terminates at 4 Phi. We\n+  \/\/ must add 4 Phi as a search root.\n+  \/\/\n+  \/\/ We now turn to how to identify all search roots. First, a few more\n+  \/\/ definitions:\n+  \/\/ - L is live = an anti-dependent store has not yet written to L\n+  \/\/ - Phi = a memory Phi node that aliases L\n+  \/\/ - Def = a (non-Phi) memory-defining node (e.g., a store)\n+  \/\/\n+  \/\/ Facts:\n+  \/\/ - If L is live, any simultaneously live memory node that can alias L is a\n+  \/\/   potential root.\n+  \/\/ - Roots only reside in blocks dominating the early block.\n+  \/\/ - L is by definition live just after initial_mem.\n+  \/\/ - If the initial_mem block strictly dominates the early block, L is\n+  \/\/   necessarily live all the way to the start of the early block.\n+  \/\/ - If initial_mem is a Phi, L is live at the entry of the initial_mem block\n+  \/\/   (Phis execute in parallel at the start of the block by definition).\n+  \/\/\n+  \/\/ These facts together identify a range where L is certainly live. L can of\n+  \/\/ course also be live below this range. The actual anti-dependence search\n+  \/\/ later on attempts to expand the range downwards as far as possible (to\n+  \/\/ allow maximum scheduling flexibility with a low LCA).\n+  \/\/\n+  \/\/ See the illustrations below for a visual representation of the facts\n+  \/\/ above. Note: the graphs are branches in the dominator tree, and not from\n+  \/\/ the CFG. Observations indicate that it is only necessary to consider Phi\n+  \/\/ nodes as roots. From the Phi nodes, we then discover other relevant\n+  \/\/ non-Phi nodes naturally as part of the anti-dependence search.\n+  \/\/\n+  \/\/ CASE 1\n+  \/\/ +---------------------+\n+  \/\/ | Phi (not a root)    |\n+  \/\/ | ...                 | initial_mem_block (L is not live at entry)\n+  \/\/ | Def (initial_mem)   |\n+  \/\/ | ...                 |\n+  \/\/ +---------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/        +-----+\n+  \/\/        | ... + in-between block (L is live in the whole block)\n+  \/\/        +-----+\n+  \/\/           |\n+  \/\/           V\n+  \/\/          ...\n+  \/\/           |\n+  \/\/           V\n+  \/\/        +-----+\n+  \/\/        | ... + in-between block (L is live in the whole block)\n+  \/\/        +-----+\n+  \/\/           |\n+  \/\/           v\n+  \/\/     +------------+\n+  \/\/     | ...        | early (L is live at entry)\n+  \/\/     +------------+\n+  \/\/\n+  \/\/ CASE 2\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | initial_mem_block (L is live in the whole block)\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ | ...               |\n+  \/\/ +-------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ ... (same as CASE 1) ...\n+  \/\/\n+  \/\/ CASE 3\n+  \/\/ +---------------------+\n+  \/\/ | Phi (not a root)    | early = initial_mem_block (L is not live at entry)\n+  \/\/ | ...                 |\n+  \/\/ | Def (initial_mem)   |\n+  \/\/ | ...                 |\n+  \/\/ +---------------------+\n+  \/\/\n+  \/\/ CASE 4\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | early = initial_mem_block (L is live at entry)\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ | ...               |\n+  \/\/ +-------------------+\n+  \/\/\n+  \/\/ Finally, below is the code for finding the roots. We add a guard\n+  \/\/ (load->in(0) != nullptr) as observations indicate that we only need to\n+  \/\/ find the roots if the load has an explicit control input.\n+  \/\/\n+  if (load->in(0) != nullptr) {\n+    \/\/ Walk the relevant blocks from early (inclusive) up to initial_mem_block\n+    \/\/ (inclusive).\n+    for (Block* b = early; b != initial_mem_block->_idom; b = b->_idom) {\n+      assert(b != nullptr, \"sanity\");\n+      if (b == initial_mem_block && !initial_mem->is_Phi()) {\n+        \/\/ If we are in initial_mem_block, and initial_mem is not itself a Phi,\n+        \/\/ it necessarily means that initial_mem is defined after all Phis in\n+        \/\/ the block. Therefore, no Phis in the block are roots.\n+        break;\n+      }\n+      \/\/ We need to process all memory Phi nodes in the block. LCM may not have\n+      \/\/ run yet, so we cannot assume anything regarding the location of Phi\n+      \/\/ nodes within the block. Therefore, we must search the entire block.\n+      for (uint i = 0; i < b->number_of_nodes(); ++i) {\n+        Node* n = b->get_node(i);\n+        if (n->is_memory_phi() && C->can_alias(n->adr_type(), load_alias_idx)\n+            && n != initial_mem) {\n+          \/\/ We have found a relevant Phi search root. Add it to the worklist\n+          \/\/ in addition to initial_mem.\n+          worklist_def_use_mem_states.push(nullptr, n);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -794,2 +992,2 @@\n-    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n-        || op == Op_MergeMem    \/\/ internal node of tree we are searching\n+    if (def_mem_state == nullptr \/\/ root of a tree we are searching\n+        || op == Op_MergeMem     \/\/ internal node of tree we are searching\n@@ -798,2 +996,0 @@\n-      if (use_mem_state == initial_mem)\n-        initial_mem = nullptr;  \/\/ only process initial memory once\n@@ -867,3 +1063,0 @@\n-      \/\/ Loop-phis need to raise load before input. (Other phis are treated\n-      \/\/ as store below.)\n-      \/\/\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":200,"deletions":7,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.codegen;\n+\n+\/**\n+ * @test\n+ * @bug 8333393\n+ * @summary Test that loads are not scheduled too late.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main compiler.codegen.TestGCMLoadPlacement\n+ *\/\n+\n+public class TestGCMLoadPlacement {\n+\n+    public static void main(String[] args) {\n+        Test1.run();\n+        Test2.run();\n+        Test3.run();\n+        Test4.run();\n+        Test5.run();\n+    }\n+\n+    static class Test1 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int i = 0; i < 50; ++i)\n+                for (int j = 0; j < 50; ++j) {\n+                    if (flag) { return 0; } \/\/ Forces peeling\n+                    iFld = 0;\n+                    for (int k = 0; k < 1; ++k) {\n+\n+                    }\n+                }\n+            int res = iFld; \/\/ This load needs to schedule before the loop below ...\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 42;\n+            }\n+            \/\/ ... and was incorrectly scheduled here.\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test1 t = new Test1();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test2 {\n+        static void run() {\n+            for (int i = 0; i < 500; i++) {\n+                int res = test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"res = \" + res);\n+                }\n+            }\n+        }\n+\n+        static int test() {\n+            int res = 0;\n+            int array[] = new int[50];\n+            for (int j = 0; j < array.length; j++) {\n+                array[j] = 0;\n+            }\n+            int x = array[0];\n+            for (int i = 5; i < 10; i++) {\n+                array[0] = 42;\n+                for (int j = 0; j < 10; j++) {\n+                    dontInline();\n+                    res = x;\n+                }\n+            }\n+            return res;\n+        }\n+\n+        static void dontInline() {}\n+    }\n+\n+    static class Test3 {\n+        static boolean flag;\n+        static int N = 400;\n+        long instanceCount;\n+        float fFld = 2.957F;\n+        volatile short sFld;\n+        int iArrFld[] = new int[N];\n+\n+        int test() {\n+            int i22 = 7, i25, i27, i28 = 5, i29, i31, i33;\n+            for (i25 = 229; i25 > 2; --i25) {\n+                if (flag) { return 9; }\n+                iArrFld[1] *= instanceCount;\n+                for (i27 = 4; i27 < 116; ++i27) {\n+                }\n+            }\n+            i22 += fFld;\n+            for (i29 = 23; 8 < i29; i29--) {\n+                for (i31 = 2; i31 < 17; i31++) {\n+                    if (flag) { return 9; }\n+                    i28 = sFld;\n+                }\n+                for (i33 = 1; 7 > i33; ++i33) {\n+                    if (flag) { return 9; }\n+                    fFld = instanceCount;\n+                }\n+            }\n+            return i22;\n+        }\n+\n+        static void run() {\n+            Test3 r = new Test3();\n+            int result = r.test();\n+            if (result != 9) {\n+                throw new RuntimeException(\"Expected 9 but found \" + result);\n+            }\n+        }\n+    }\n+\n+    static class Test4 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int j = 0; j < 50; ++j) {\n+                iFld = 0;\n+                if (flag) { return 0; }\n+\n+                for (int k = 0; k < 2000; ++k) {\n+                }\n+            }\n+\n+            int res = iFld;\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 1;\n+            }\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test4 t = new Test4();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test5 {\n+        int a = 1;\n+        int test() {\n+            int f, g = 0, h[] = new int[a];\n+            double j = 72.18064;\n+            for (int i = 0; i < 7; ++i)\n+                for (int i2 = 0; i2 < 4; i2++) {\n+                    g += ++h[0];\n+                    while (--j > 0)\n+                        ;\n+                }\n+            int c = 0;\n+            for (int k = 0; k < h.length; k++) {\n+                c += h[k];\n+            }\n+            return c;\n+        }\n+        static void run() {\n+            Test5 s = new Test5();\n+            int res = s.test();\n+            if (res != 28) {\n+                throw new RuntimeException(\"Unexpected result: \" + res);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMLoadPlacement.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}