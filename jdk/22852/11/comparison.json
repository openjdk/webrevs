{"files":[{"patch":"@@ -753,0 +753,6 @@\n+  \/\/\n+  \/\/ In some cases, there are relevant anti-dependent memory nodes that we\n+  \/\/ cannot discover by searching from initial_mem. In such cases, we need to\n+  \/\/ expand our search with additional search roots. For details, see comments\n+  \/\/ and code below related to the initialization of\n+  \/\/ worklist_def_use_mem_states.\n@@ -770,0 +776,2 @@\n+\n+  \/\/ initial_mem is always a search root\n@@ -771,0 +779,195 @@\n+\n+  Block* initial_mem_block = get_block_for_node(initial_mem);\n+  assert(initial_mem_block != nullptr, \"sanity\");\n+  assert(initial_mem_block->dominates(early), \"invariant\");\n+\n+  \/\/ There are rare situations where multiple memory nodes represent the same\n+  \/\/ memory state for a load. That is, we could replace the actual memory input\n+  \/\/ to the load (initial_mem) with any of these nodes and the ideal graph\n+  \/\/ would still represent the same program. Whether such situations are\n+  \/\/ accidental and possibly avoidable is a topic for future investigation. We\n+  \/\/ first look at two examples of such situations, and then give a more formal\n+  \/\/ justification.\n+  \/\/\n+  \/\/ In the following, we refer to the set of memory nodes representing the\n+  \/\/ same memory state of a load as the (search) roots. We refer to this set\n+  \/\/ with initial_mem removed as the additional (search) roots. If we do not\n+  \/\/ search for anti-dependences from all roots, it is possible that we do not\n+  \/\/ discover all relevant anti-dependences. Below are two cases seen in\n+  \/\/ practice where it is necessary to find the additional roots.\n+  \/\/\n+  \/\/ Definitions:\n+  \/\/ - A = all of memory\n+  \/\/ - L = the memory for the load's alias category\n+  \/\/ - !L = all of memory except L\n+  \/\/\n+  \/\/ EXAMPLE 1\n+  \/\/ +----------------+\n+  \/\/ | 1 MachProj (A) |\n+  \/\/ +----------------+  +-------------------------------+\n+  \/\/       |             |                               |\n+  \/\/       V             V                               |\n+  \/\/ +-----------------------+                           |\n+  \/\/ | 2 Phi (L) <- 1 6      |                           |\n+  \/\/ | 3 MergeMem (A) <- 1 2 |                           |\n+  \/\/ +-----------------------+                           |\n+  \/\/     |          |                                    |\n+  \/\/     |          V                                    |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |   | 4 Store (L) <- 2      |                   |\n+  \/\/     |   | 5 MergeMem (A) <- 1 4 |                   |\n+  \/\/     |   +-----------------------+                   |\n+  \/\/     |          |                                    |\n+  \/\/     V          V                                    |\n+  \/\/ +-------------------------------+                   |\n+  \/\/ | 6 Phi (L, initial_mem) <- 2 4 | initial_mem_block |\n+  \/\/ | 7 Phi (A) <- 3 5              |                   |\n+  \/\/ +-------------------------------+                   |\n+  \/\/           |     |                                   |\n+  \/\/           V     +-----------------------------------+\n+  \/\/ +-----------------------+\n+  \/\/ | 8 membar_release <- 7 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this example, initial_mem is 6 Phi, but a critical anti-dependent\n+  \/\/ memory use for the load is 8 membar_release. If we do not consider 7 Phi\n+  \/\/ (which subsumes and overlaps 6 Phi) as a search root, we do not find this\n+  \/\/ anti-dependence and will likely end up scheduling the load too late.\n+  \/\/\n+  \/\/ EXAMPLE 2\n+  \/\/ +-----------------------------+\n+  \/\/ | 1 MachProj (A, initial_mem) | initial_mem_block\n+  \/\/ +-----------------------------+\n+  \/\/     |             |\n+  \/\/     |             V\n+  \/\/     |   +-----------------------+\n+  \/\/     |   | 2 Store (!L) <- 1     |\n+  \/\/     |   | 3 MergeMem (A) <- 1 2 |\n+  \/\/     |   +-----------------------+\n+  \/\/     |             |\n+  \/\/     V             V\n+  \/\/ +-------------------------------+\n+  \/\/ | 4 Phi (A) <- 1 3              |\n+  \/\/ +-------------------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ +-----------------------+\n+  \/\/ | 5 membar_release <- 4 | early\n+  \/\/ | ...                   |\n+  \/\/ +-----------------------+\n+  \/\/\n+  \/\/ In this next example, initial_mem is instead 1 MachProj. We fail\n+  \/\/ to reach the critical anti-dependent use 5 membar_release because the\n+  \/\/ anti-dependence search starting from 1 MachProj terminates at 4 Phi. We\n+  \/\/ must add 4 Phi as a search root.\n+  \/\/\n+  \/\/ We now turn to a more formal definition of search roots and how to\n+  \/\/ identify them. A search root is a memory node M for which all items below\n+  \/\/ hold.\n+  \/\/   1. M aliases initial_mem.\n+  \/\/   2. M is scheduled in a block dominated by initial_mem_block.\n+  \/\/   3. If M is scheduled in initial_mem_block, M does not occur before\n+  \/\/      initial_mem.\n+  \/\/   4. M is scheduled in a block dominating early.\n+  \/\/   5. If M is scheduled in early, M occurs before the load.\n+  \/\/\n+  \/\/ Item 1 ensures M represents the correct part of memory (the load's alias\n+  \/\/ category). Items 2 and 3 ensure the load's memory state is defined (which\n+  \/\/ it may not be prior to initial_mem). Items 4 and 5 ensure M occurs before\n+  \/\/ the earliest point at which we may schedule the load.\n+  \/\/\n+  \/\/ Items 3 and 5 call for further elaboration. As we may not have run LCM\n+  \/\/ yet, we can only reason about the order between Phi and non-Phi memory\n+  \/\/ nodes. Phis, by definition, execute in parallel at the start of the block,\n+  \/\/ before any non-Phi nodes. Consequently, if initial_mem is a non-Phi node,\n+  \/\/ item 3 disallows any roots in initial_mem_block (except initial_mem\n+  \/\/ itself). Inversely, if initial_mem is a Phi, item 3 permits all memory\n+  \/\/ nodes in initial_mem_block as roots. Item 5 effectively implies that only\n+  \/\/ Phis in the early block may be roots, as we do not yet know where the load\n+  \/\/ will be scheduled.\n+  \/\/\n+  \/\/ Observations indicate that it is only necessary to consider Phi\n+  \/\/ nodes as additional roots. From the Phi nodes, we then discover other\n+  \/\/ relevant non-Phi nodes naturally as part of the anti-dependence search.\n+  \/\/\n+  \/\/ To make sense of the definition above, consider the different cases below.\n+  \/\/ All shown nodes alias initial_mem (item 1). The graphs are\n+  \/\/ branches in the dominator tree, and not from the CFG.\n+  \/\/\n+  \/\/ CASE 1\n+  \/\/ +-----------------------+\n+  \/\/ | Phi (not a root)      | initial_mem_block\n+  \/\/ | Non-Phi (initial_mem) |\n+  \/\/ +-----------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/          ...\n+  \/\/           |\n+  \/\/           V\n+  \/\/    +--------------+\n+  \/\/    | Phi (a root) |\n+  \/\/    +--------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/          ...\n+  \/\/           |\n+  \/\/           v\n+  \/\/ +----------------------+\n+  \/\/ | Phi (a root)         | early\n+  \/\/ | Non-Phi (not a root) |\n+  \/\/ +----------------------+\n+  \/\/\n+  \/\/ CASE 2\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | initial_mem_block\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ | ...               |\n+  \/\/ +-------------------+\n+  \/\/           |\n+  \/\/           V\n+  \/\/ ... (same as CASE 1) ...\n+  \/\/\n+  \/\/ CASE 3\n+  \/\/ +-------------------------+\n+  \/\/ | Phi (not a root)        | early = initial_mem_block\n+  \/\/ | Non-Phi (initial_mem)   |\n+  \/\/ +-------------------------+\n+  \/\/\n+  \/\/ CASE 4\n+  \/\/ +-------------------+\n+  \/\/ | Phi (a root)      | early = initial_mem_block\n+  \/\/ | Phi (initial_mem) |\n+  \/\/ +-------------------+\n+  \/\/\n+  \/\/ Finally, below is the code for finding the additional roots. We add a\n+  \/\/ guard (load->in(0) != nullptr) as observations indicate that we only need\n+  \/\/ to find additional roots if the load has an explicit control input.\n+  \/\/\n+  if (load->in(0) != nullptr) {\n+    \/\/ Walk the relevant blocks from early (inclusive) up to initial_mem_block\n+    \/\/ (inclusive).\n+    for (Block* b = early; b != initial_mem_block->_idom; b = b->_idom) {\n+      assert(b != nullptr, \"sanity\");\n+      if (b == initial_mem_block && !initial_mem->is_Phi()) {\n+        \/\/ If we are in initial_mem_block, and initial_mem is not itself a Phi,\n+        \/\/ it necessarily means that initial_mem is defined after all Phis in\n+        \/\/ the block. Therefore, no Phis in the block are roots. This\n+        \/\/ corresponds to CASE 1 and CASE 3 above.\n+        break;\n+      }\n+      \/\/ We need to process all memory Phi nodes in the block. LCM may not have\n+      \/\/ run yet, so we cannot assume anything regarding the location of Phi\n+      \/\/ nodes within the block. Therefore, we must search the entire block.\n+      for (uint i = 0; i < b->number_of_nodes(); ++i) {\n+        Node* n = b->get_node(i);\n+        if (n->is_memory_phi() && C->can_alias(n->adr_type(), load_alias_idx)\n+            && n != initial_mem) {\n+          \/\/ We have found a relevant Phi search root. Add it to the worklist\n+          \/\/ in addition to initial_mem.\n+          worklist_def_use_mem_states.push(nullptr, n);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -793,2 +996,2 @@\n-    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n-        || op == Op_MergeMem    \/\/ internal node of tree we are searching\n+    if (def_mem_state == nullptr \/\/ root of a tree we are searching\n+        || op == Op_MergeMem     \/\/ internal node of tree we are searching\n@@ -797,2 +1000,0 @@\n-      if (use_mem_state == initial_mem)\n-        initial_mem = nullptr;  \/\/ only process initial memory once\n@@ -866,3 +1067,0 @@\n-      \/\/ Loop-phis need to raise load before input. (Other phis are treated\n-      \/\/ as store below.)\n-      \/\/\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":205,"deletions":7,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.codegen;\n+\n+\/**\n+ * @test\n+ * @bug 8333393\n+ * @summary Test that loads are not scheduled too late.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main compiler.codegen.TestGCMLoadPlacement\n+ *\/\n+\n+public class TestGCMLoadPlacement {\n+\n+    public static void main(String[] args) {\n+        Test1.run();\n+        Test2.run();\n+        Test3.run();\n+        Test4.run();\n+        Test5.run();\n+    }\n+\n+    static class Test1 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int i = 0; i < 50; ++i)\n+                for (int j = 0; j < 50; ++j) {\n+                    if (flag) { return 0; } \/\/ Forces peeling\n+                    iFld = 0;\n+                    for (int k = 0; k < 1; ++k) {\n+\n+                    }\n+                }\n+            int res = iFld; \/\/ This load needs to schedule before the loop below ...\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 42;\n+            }\n+            \/\/ ... and was incorrectly scheduled here.\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test1 t = new Test1();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test2 {\n+        static void run() {\n+            for (int i = 0; i < 500; i++) {\n+                int res = test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"res = \" + res);\n+                }\n+            }\n+        }\n+\n+        static int test() {\n+            int res = 0;\n+            int array[] = new int[50];\n+            for (int j = 0; j < array.length; j++) {\n+                array[j] = 0;\n+            }\n+            int x = array[0];\n+            for (int i = 5; i < 10; i++) {\n+                array[0] = 42;\n+                for (int j = 0; j < 10; j++) {\n+                    dontInline();\n+                    res = x;\n+                }\n+            }\n+            return res;\n+        }\n+\n+        static void dontInline() {}\n+    }\n+\n+    static class Test3 {\n+        static boolean flag;\n+        static int N = 400;\n+        long instanceCount;\n+        float fFld = 2.957F;\n+        volatile short sFld;\n+        int iArrFld[] = new int[N];\n+\n+        int test() {\n+            int i22 = 7, i25, i27, i28 = 5, i29, i31, i33;\n+            for (i25 = 229; i25 > 2; --i25) {\n+                if (flag) { return 9; }\n+                iArrFld[1] *= instanceCount;\n+                for (i27 = 4; i27 < 116; ++i27) {\n+                }\n+            }\n+            i22 += fFld;\n+            for (i29 = 23; 8 < i29; i29--) {\n+                for (i31 = 2; i31 < 17; i31++) {\n+                    if (flag) { return 9; }\n+                    i28 = sFld;\n+                }\n+                for (i33 = 1; 7 > i33; ++i33) {\n+                    if (flag) { return 9; }\n+                    fFld = instanceCount;\n+                }\n+            }\n+            return i22;\n+        }\n+\n+        static void run() {\n+            Test3 r = new Test3();\n+            int result = r.test();\n+            if (result != 9) {\n+                throw new RuntimeException(\"Expected 9 but found \" + result);\n+            }\n+        }\n+    }\n+\n+    static class Test4 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int j = 0; j < 50; ++j) {\n+                iFld = 0;\n+                if (flag) { return 0; }\n+\n+                for (int k = 0; k < 2000; ++k) {\n+                }\n+            }\n+\n+            int res = iFld;\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 1;\n+            }\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test4 t = new Test4();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test5 {\n+        int a = 1;\n+        int test() {\n+            int f, g = 0, h[] = new int[a];\n+            double j = 72.18064;\n+            for (int i = 0; i < 7; ++i)\n+                for (int i2 = 0; i2 < 4; i2++) {\n+                    g += ++h[0];\n+                    while (--j > 0)\n+                        ;\n+                }\n+            int c = 0;\n+            for (int k = 0; k < h.length; k++) {\n+                c += h[k];\n+            }\n+            return c;\n+        }\n+        static void run() {\n+            Test5 s = new Test5();\n+            int res = s.test();\n+            if (res != 28) {\n+                throw new RuntimeException(\"Unexpected result: \" + res);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMLoadPlacement.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}