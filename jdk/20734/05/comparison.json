{"files":[{"patch":"@@ -107,2 +107,3 @@\n-void os::check_dump_limit(char* buffer, size_t bufferSize) {\n-  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !CreateCoredumpOnCrash) {\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n+  bool will_dump_core = !(!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !CreateCoredumpOnCrash);\n+  if (!will_dump_core) {\n@@ -110,14 +111,8 @@\n-    VMError::record_coredump_status(buffer, false);\n-    return;\n-  }\n-\n-  int n;\n-  struct rlimit rlim;\n-  bool success;\n-\n-  char core_path[PATH_MAX];\n-  n = get_core_path(core_path, PATH_MAX);\n-\n-  if (n <= 0) {\n-    jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n-    success = true;\n+  } else {\n+    char core_path[PATH_MAX];\n+    if (os::get_core_path(core_path, PATH_MAX) <= 0) {\n+      jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", os::current_process_id());\n+      if (!check_only) {\n+        \/\/ TODO: why is this true for general case?\n+        will_dump_core = true;\n+      }\n@@ -125,3 +120,3 @@\n-  } else if (core_path[0] == '\"') { \/\/ redirect to user process\n-    jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n-    success = true;\n+    } else if (core_path[0] == '\"') { \/\/ redirect to user process\n+      jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n+      will_dump_core = true;\n@@ -129,17 +124,28 @@\n-  } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n-    jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n-    success = true;\n-  } else {\n-    switch(rlim.rlim_cur) {\n-      case RLIM_INFINITY:\n-        jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n-        success = true;\n-        break;\n-      case 0:\n-        jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n-        success = false;\n-        break;\n-      default:\n-        jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n-        success = true;\n-        break;\n+    } else {\n+      struct rlimit rlim;\n+      if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n+        jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+        if (!check_only) {\n+          \/\/ TODO: why is this true for general case?\n+          will_dump_core = true;\n+        }\n+      } else {\n+        switch(rlim.rlim_cur) {\n+          case RLIM_INFINITY:\n+            jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+            will_dump_core = true;\n+            break;\n+          case 0:\n+            jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+            will_dump_core = false;\n+            break;\n+          default:\n+            jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+            if (!check_only) {\n+              will_dump_core = true;\n+            } else {\n+              will_dump_core = uint64_t(rlim.rlim_cur) > uint64_t(4*MaxHeapSize);\n+            }\n+            break;\n+        }\n+      }\n@@ -149,1 +155,7 @@\n-  VMError::record_coredump_status(buffer, success);\n+  if (!check_only) {\n+    VMError::record_coredump_status(buffer, will_dump_core);\n+  } else {\n+    if (!will_dump_core) {\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n+    }\n+  }\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":49,"deletions":37,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1289,8 +1289,6 @@\n-\/\/ Check if dump file can be created.\n-void os::check_dump_limit(char* buffer, size_t buffsz) {\n-  bool status = true;\n-  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !CreateCoredumpOnCrash) {\n-    jio_snprintf(buffer, buffsz, \"CreateCoredumpOnCrash is disabled from command line\");\n-    status = false;\n-  }\n-\n+\/\/ Check if core dump is active and if a core dump file can be created\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n+  bool will_dump_core = !(!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !CreateCoredumpOnCrash);\n+  if (!will_dump_core) {\n+    jio_snprintf(buffer, bufferSize, \"CreateCoredumpOnCrash is disabled from command line\");\n+  } else {\n@@ -1298,4 +1296,4 @@\n-  if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n-    jio_snprintf(buffer, buffsz, \"Minidumps are not enabled by default on client versions of Windows\");\n-    status = false;\n-  }\n+    will_dump_core = !(FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !os::win32::is_windows_server());\n+    if (!will_dump_core) {\n+      jio_snprintf(buffer, bufferSize, \"Minidumps are not enabled by default on client versions of Windows\");\n+    }\n@@ -1303,0 +1301,8 @@\n+    if (will_dump_core) {\n+      const char* cwd = get_current_directory(nullptr, 0);\n+      int pid = current_process_id();\n+      if (cwd != nullptr) {\n+        jio_snprintf(buffer, bufferSize, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n+      } else {\n+        jio_snprintf(buffer, bufferSize, \".\\\\hs_err_pid%u.mdmp\", pid);\n+      }\n@@ -1304,7 +1310,12 @@\n-  if (status) {\n-    const char* cwd = get_current_directory(nullptr, 0);\n-    int pid = current_process_id();\n-    if (cwd != nullptr) {\n-      jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n-    } else {\n-      jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n+      if (!check_only) {\n+        will_dump_core = !(dumpFile == nullptr &&\n+                           (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n+                             == INVALID_HANDLE_VALUE);\n+        if (!will_dump_core) {\n+          jio_snprintf(buffer, bufferSize, \"Failed to create minidump file (0x%x).\", GetLastError());\n+        }\n+      } else {\n+        \/\/ For check_only, which is done at the startup, we DO NOT want to create a file,\n+        \/\/ which would slow startup down, so simply assume here that we can do it\n+        will_dump_core = true;\n+      }\n@@ -1312,0 +1323,1 @@\n+  }\n@@ -1313,5 +1325,6 @@\n-    if (dumpFile == nullptr &&\n-       (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n-                 == INVALID_HANDLE_VALUE) {\n-      jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n-      status = false;\n+  if (!check_only) {\n+    VMError::record_coredump_status(buffer, will_dump_core);\n+  } else {\n+    if (!will_dump_core) {\n+      \/\/ The code logic is provided, but currently there is no path to get here on Windows\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n@@ -1320,1 +1333,0 @@\n-  VMError::record_coredump_status(buffer, status);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-  static void check_dump_limit(char* buffer, size_t bufferSize);\n+  static void check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -667,0 +668,5 @@\n+  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && CreateCoredumpOnCrash) {\n+    char buffer[2*JVM_MAXPATHLEN];\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer), true);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1699,1 +1699,1 @@\n-    os::check_dump_limit(buffer, sizeof(buffer));\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer));\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,4 @@\n-            runTest(\"-XX:+CreateCoredumpOnCrash\").shouldNotContain(\"CreateCoredumpOnCrash turned off, no core file dumped\")\n-                                                 .shouldNotHaveExitValue(0);\n+          OutputAnalyzer oa = runTest(\"-XX:+CreateCoredumpOnCrash\");\n+          oa.reportDiagnosticSummary();\n+          oa.shouldContain(\"core dump info\").shouldNotContain(\"CreateCoredumpOnCrash turned off, no core file dumped\").\n+                  shouldNotHaveExitValue(0);\n@@ -58,1 +60,0 @@\n-\n@@ -60,0 +61,1 @@\n+\n@@ -63,1 +65,1 @@\n-            \"-Xmx128m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", option, Crasher.class.getName())\n+            \"-Xmx128m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"-Xlog:os=info:stdout\", option, Crasher.class.getName())\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}