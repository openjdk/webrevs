{"files":[{"patch":"@@ -107,1 +107,2 @@\n-bool os::check_core_dump_enabled(char* buffer, size_t bufferSize) {\n+void os::check_core_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n+  bool status = true;\n@@ -110,2 +111,1 @@\n-    VMError::record_coredump_status(buffer, false);\n-    return false;\n+    status = false;\n@@ -114,5 +114,4 @@\n-  bool success;\n-  char core_path[PATH_MAX];\n-  if (get_core_path(core_path, PATH_MAX) <= 0) {\n-    jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n-    success = true;\n+  if (status) {\n+    char core_path[PATH_MAX];\n+    if (os::get_core_path(core_path, PATH_MAX) <= 0) {\n+      jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", os::current_process_id());\n@@ -120,3 +119,2 @@\n-  } else if (core_path[0] == '\"') { \/\/ redirect to user process\n-    jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n-    success = true;\n+    } else if (core_path[0] == '\"') { \/\/ redirect to user process\n+      jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n@@ -124,5 +122,0 @@\n-  } else {\n-    struct rlimit rlim;\n-    if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n-      jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n-      success = true;\n@@ -130,13 +123,16 @@\n-      switch(rlim.rlim_cur) {\n-        case RLIM_INFINITY:\n-          jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n-          success = true;\n-          break;\n-        case 0:\n-          jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n-          success = false;\n-          break;\n-        default:\n-          jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n-          success = true;\n-          break;\n+      struct rlimit rlim;\n+      if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n+        jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+      } else {\n+        switch(rlim.rlim_cur) {\n+          case RLIM_INFINITY:\n+            jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+            break;\n+          case 0:\n+            jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+            status = false;\n+            break;\n+          default:\n+            jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+            break;\n+        }\n@@ -147,6 +143,1 @@\n-  VMError::record_coredump_status(buffer, success);\n-  return success;\n-}\n-\n-void os::prepare_core_dump(char* buffer, size_t buffsz) {\n-  \/\/ nothing to do\n+  VMError::record_coredump_status(buffer, status);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":26,"deletions":35,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1289,2 +1289,3 @@\n-\/\/ Check if core dump is enabled.\n-bool os::check_core_dump_enabled(char* buffer, size_t buffsz) {\n+\/\/ Check if dump file can be created.\n+void os::check_core_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n+  bool status = true;\n@@ -1293,2 +1294,1 @@\n-    VMError::record_coredump_status(buffer, false);\n-    return false;\n+    status = false;\n@@ -1298,1 +1298,1 @@\n-  if (FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !os::win32::is_windows_server()) {\n+  if (status && FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !os::win32::is_windows_server()) {\n@@ -1300,2 +1300,1 @@\n-    VMError::record_coredump_status(buffer, false);\n-    return false;\n+    status = false;\n@@ -1305,11 +1304,8 @@\n-  const char* cwd = get_current_directory(nullptr, 0);\n-  int pid = current_process_id();\n-  if (cwd != nullptr) {\n-    jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n-  } else {\n-    jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n-  }\n-\n-  VMError::record_coredump_status(buffer, success);\n-  return true;\n-}\n+  if (status) {\n+    const char* cwd = get_current_directory(nullptr, 0);\n+    int pid = current_process_id();\n+    if (cwd != nullptr) {\n+      jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n+    } else {\n+      jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n+    }\n@@ -1317,7 +1313,6 @@\n-\/\/ Prepare core dump file, if it can not be created then make a note.\n-void os::prepare_core_dump(char* buffer, size_t buffsz) {\n-  if (dumpFile == nullptr &&\n-     (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n-               == INVALID_HANDLE_VALUE) {\n-    jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n-    VMError::record_coredump_status(buffer, false);\n+    if (check_only == false && dumpFile == nullptr &&\n+       (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n+                 == INVALID_HANDLE_VALUE) {\n+      jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n+      status = false;\n+    }\n@@ -1325,0 +1320,2 @@\n+\n+  VMError::record_coredump_status(buffer, status);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -937,1 +937,2 @@\n-  \/\/ it will check for a client versions of Windows. Use the caller\n+  \/\/ it will check if dump file can be created. Check or prepare a core dump to be\n+  \/\/ taken at a later point in the same thread in os::abort(). Use the caller\n@@ -941,4 +942,1 @@\n-  static bool check_core_dump_enabled(char* buffer, size_t bufferSize);\n-  \/\/ On Windows it will check if dump file can be created and it will prepare\n-  \/\/ a core dump to be taken at a later point in the same thread in os::abort()\n-  static void prepare_core_dump(char* buffer, size_t bufferSize);\n+  static void check_core_prerequisites(char* buffer, size_t bufferSize, bool check_only = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-    os::check_core_dump_enabled(buffer, sizeof(buffer));\n+    os::check_core_prerequisites(buffer, sizeof(buffer), true);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1699,3 +1699,1 @@\n-    if (os::check_core_dump_enabled(buffer, sizeof(buffer))) {\n-      os::prepare_core_dump(buffer, sizeof(buffer));\n-    }\n+    os::check_core_prerequisites(buffer, sizeof(buffer));\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}