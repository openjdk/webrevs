{"files":[{"patch":"@@ -107,1 +107,1 @@\n-void os::check_dump_limit(char* buffer, size_t bufferSize) {\n+bool os::check_core_dump_enabled(char* buffer, size_t bufferSize) {\n@@ -111,1 +111,1 @@\n-    return;\n+    return false;\n@@ -114,2 +114,0 @@\n-  int n;\n-  struct rlimit rlim;\n@@ -117,1 +115,0 @@\n-\n@@ -119,3 +116,1 @@\n-  n = get_core_path(core_path, PATH_MAX);\n-\n-  if (n <= 0) {\n+  if (get_core_path(core_path, PATH_MAX) <= 0) {\n@@ -129,3 +124,0 @@\n-  } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n-    jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n-    success = true;\n@@ -133,13 +125,19 @@\n-    switch(rlim.rlim_cur) {\n-      case RLIM_INFINITY:\n-        jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n-        success = true;\n-        break;\n-      case 0:\n-        jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n-        success = false;\n-        break;\n-      default:\n-        jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n-        success = true;\n-        break;\n+    struct rlimit rlim;\n+    if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n+      jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+      success = true;\n+    } else {\n+      switch(rlim.rlim_cur) {\n+        case RLIM_INFINITY:\n+          jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+          success = true;\n+          break;\n+        case 0:\n+          jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+          success = false;\n+          break;\n+        default:\n+          jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+          success = true;\n+          break;\n+      }\n@@ -150,0 +148,5 @@\n+  return success;\n+}\n+\n+void os::prepare_core_dump(char* buffer, size_t buffsz) {\n+  \/\/ nothing to do\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1289,3 +1289,2 @@\n-\/\/ Check if dump file can be created.\n-void os::check_dump_limit(char* buffer, size_t buffsz) {\n-  bool status = true;\n+\/\/ Check if core dump is enabled.\n+bool os::check_core_dump_enabled(char* buffer, size_t buffsz) {\n@@ -1294,1 +1293,2 @@\n-    status = false;\n+    VMError::record_coredump_status(buffer, false);\n+    return false;\n@@ -1298,1 +1298,1 @@\n-  if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n+  if (FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && !os::win32::is_windows_server()) {\n@@ -1300,1 +1300,2 @@\n-    status = false;\n+    VMError::record_coredump_status(buffer, false);\n+    return false;\n@@ -1304,8 +1305,7 @@\n-  if (status) {\n-    const char* cwd = get_current_directory(nullptr, 0);\n-    int pid = current_process_id();\n-    if (cwd != nullptr) {\n-      jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n-    } else {\n-      jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n-    }\n+  const char* cwd = get_current_directory(nullptr, 0);\n+  int pid = current_process_id();\n+  if (cwd != nullptr) {\n+    jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n+  } else {\n+    jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n+  }\n@@ -1313,6 +1313,11 @@\n-    if (dumpFile == nullptr &&\n-       (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n-                 == INVALID_HANDLE_VALUE) {\n-      jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n-      status = false;\n-    }\n+  VMError::record_coredump_status(buffer, success);\n+  return true;\n+}\n+\n+\/\/ Prepare core dump file, if it can not be created then make a note.\n+void os::prepare_core_dump(char* buffer, size_t buffsz) {\n+  if (dumpFile == nullptr &&\n+     (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n+               == INVALID_HANDLE_VALUE) {\n+    jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n+    VMError::record_coredump_status(buffer, false);\n@@ -1320,1 +1325,0 @@\n-  VMError::record_coredump_status(buffer, status);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -937,2 +937,1 @@\n-  \/\/ it will check if dump file can be created. Check or prepare a core dump to be\n-  \/\/ taken at a later point in the same thread in os::abort(). Use the caller\n+  \/\/ it will check for a client versions of Windows. Use the caller\n@@ -942,1 +941,4 @@\n-  static void check_dump_limit(char* buffer, size_t bufferSize);\n+  static bool check_core_dump_enabled(char* buffer, size_t bufferSize);\n+  \/\/ On Windows it will check if dump file can be created and it will prepare\n+  \/\/ a core dump to be taken at a later point in the same thread in os::abort()\n+  static void prepare_core_dump(char* buffer, size_t bufferSize);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -666,0 +666,5 @@\n+  if (log_is_enabled(Info, os)) {\n+    char buffer[2*PATH_MAX];\n+    os::check_core_dump_enabled(buffer, sizeof(buffer));\n+    log_info(os)(\"core dump info: %s\", buffer);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1699,1 +1699,3 @@\n-    os::check_dump_limit(buffer, sizeof(buffer));\n+    if (os::check_core_dump_enabled(buffer, sizeof(buffer))) {\n+      os::prepare_core_dump(buffer, sizeof(buffer));\n+    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,4 @@\n-            runTest(\"-XX:+CreateCoredumpOnCrash\").shouldNotContain(\"CreateCoredumpOnCrash turned off, no core file dumped\")\n-                                                 .shouldNotHaveExitValue(0);\n+          OutputAnalyzer oa = runTest(\"-XX:+CreateCoredumpOnCrash\");\n+          oa.reportDiagnosticSummary();\n+          oa.shouldContain(\"core dump info\").shouldNotContain(\"CreateCoredumpOnCrash turned off, no core file dumped\").\n+                  shouldNotHaveExitValue(0);\n@@ -58,1 +60,0 @@\n-\n@@ -60,0 +61,1 @@\n+\n@@ -63,1 +65,1 @@\n-            \"-Xmx128m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", option, Crasher.class.getName())\n+            \"-Xmx128m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"-Xlog:os=info:stdout\", option, Crasher.class.getName())\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}