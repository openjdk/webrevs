{"files":[{"patch":"@@ -443,2 +443,13 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n-    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+  if (lock_order.is_nonempty()) {\n+    const int bci = chunk->first()->bci();\n+    const Bytecodes::Code bc = chunk->first()->method()->code_at(bci);\n+    const bool previous_bc_not_monitorenter = bci == 0 ? !chunk->first()->method()->is_synchronized()\n+                                                       : chunk->first()->method()->code_at(bci - 1) != Bytecodes::_monitorenter;\n+    const bool is_synchronized_entry = chunk->first()->method()->is_synchronized() &&\n+                                       chunk->first()->raw_bci() == SynchronizationEntryBCI;\n+    \/\/ If deoptimizing from monitorenter bytecode we may be in a transitional state. Skip verification.\n+    \/\/ When reexecuting the current bc, the previous monitorenter bc may not have finished yet.\n+    if (!is_synchronized_entry && bc != Bytecodes::Code::_monitorenter &&\n+        (!chunk->first()->should_reexecute() || previous_bc_not_monitorenter)) {\n+      deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"}]}