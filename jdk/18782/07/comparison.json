{"files":[{"patch":"@@ -394,1 +394,0 @@\n-  DEBUG_ONLY(GrowableArray<oop> lock_order{0};)\n@@ -404,7 +403,0 @@\n-#ifdef ASSERT\n-      if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n-        for (MonitorInfo* mi : *monitors) {\n-          lock_order.push(mi->owner());\n-        }\n-      }\n-#endif \/\/ ASSERT\n@@ -442,5 +434,0 @@\n-#ifdef ASSERT\n-  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n-    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n-  }\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -106,54 +106,0 @@\n-#ifdef ASSERT\n-void LockStack::verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const {\n-  int top_index = to_index(_top);\n-  int lock_index = lock_order.length();\n-\n-  if (!leaf_frame) {\n-    \/\/ If the lock_order is not from the leaf frame we must search\n-    \/\/ for the top_index which fits with the most recent fast_locked\n-    \/\/ objects in the lock stack.\n-    while (lock_index-- > 0) {\n-      const oop obj = lock_order.at(lock_index);\n-      if (contains(obj)) {\n-        for (int index = 0; index < top_index; index++) {\n-          if (_base[index] == obj) {\n-            \/\/ Found top index\n-            top_index = index + 1;\n-            break;\n-          }\n-        }\n-\n-        if (VM_Version::supports_recursive_lightweight_locking()) {\n-          \/\/ With recursive looks there may be more of the same object\n-          while (lock_index-- > 0 && lock_order.at(lock_index) == obj) {\n-            top_index++;\n-          }\n-          assert(top_index <= to_index(_top), \"too many obj in lock_order\");\n-        }\n-\n-        break;\n-      }\n-    }\n-\n-    lock_index = lock_order.length();\n-  }\n-\n-  while (lock_index-- > 0) {\n-    const oop obj = lock_order.at(lock_index);\n-    const markWord mark = obj->mark_acquire();\n-    assert(obj->is_locked(), \"must be locked\");\n-    if (top_index > 0 && obj == _base[top_index - 1]) {\n-      assert(mark.is_fast_locked() || mark.monitor()->is_owner_anonymous(),\n-             \"must be fast_locked or inflated by other thread\");\n-      top_index--;\n-    } else {\n-      assert(!mark.is_fast_locked(), \"must be inflated\");\n-      assert(mark.monitor()->owner_raw() == get_thread() ||\n-             (!leaf_frame && get_thread()->current_waiting_monitor() == mark.monitor()),\n-             \"must be owned by (or waited on by) thread\");\n-      assert(!contains(obj), \"must not be on lock_stack\");\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -124,3 +124,0 @@\n-\n-  \/\/ Verify Lock Stack consistent with lock order\n-  void verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}