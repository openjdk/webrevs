{"files":[{"patch":"@@ -394,1 +394,0 @@\n-  DEBUG_ONLY(GrowableArray<oop> lock_order{0};)\n@@ -404,7 +403,0 @@\n-#ifdef ASSERT\n-      if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n-        for (MonitorInfo* mi : *monitors) {\n-          lock_order.push(mi->owner());\n-        }\n-      }\n-#endif \/\/ ASSERT\n@@ -442,21 +434,0 @@\n-#ifdef ASSERT\n-  if (lock_order.is_nonempty()) {\n-    const int bci = chunk->first()->bci();\n-    const Bytecodes::Code bc = chunk->first()->method()->code_at(bci);\n-    \/\/ Using raw constMethod::bcp_from as bci-1 may be an operand and not a opcode.\n-    \/\/ Interpreting operands as a monitorenter bytecode will only result in missing\n-    \/\/ out on some cases where verification would have been valid and possible.\n-    \/\/ Similarly filter out breakpoint bytecode as it may have been a monitorenter.\n-    const bool previous_bc_not_monitorenter = bci == 0 ? !chunk->first()->method()->is_synchronized()\n-                                                       : !(*chunk->first()->method()->bcp_from(bci - 1) == Bytecodes::_monitorenter ||\n-                                                           *chunk->first()->method()->bcp_from(bci - 1) == Bytecodes::_breakpoint);\n-    const bool is_synchronized_entry = chunk->first()->method()->is_synchronized() &&\n-                                       chunk->first()->raw_bci() == SynchronizationEntryBCI;\n-    \/\/ If deoptimizing from monitorenter bytecode we may be in a transitional state. Skip verification.\n-    \/\/ When reexecuting the current bc, the previous monitorenter bc may not have finished yet.\n-    if (!is_synchronized_entry && bc != Bytecodes::Code::_monitorenter &&\n-        (!chunk->first()->should_reexecute() || previous_bc_not_monitorenter)) {\n-      deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n-    }\n-  }\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -106,54 +106,0 @@\n-#ifdef ASSERT\n-void LockStack::verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const {\n-  int top_index = to_index(_top);\n-  int lock_index = lock_order.length();\n-\n-  if (!leaf_frame) {\n-    \/\/ If the lock_order is not from the leaf frame we must search\n-    \/\/ for the top_index which fits with the most recent fast_locked\n-    \/\/ objects in the lock stack.\n-    while (lock_index-- > 0) {\n-      const oop obj = lock_order.at(lock_index);\n-      if (contains(obj)) {\n-        for (int index = 0; index < top_index; index++) {\n-          if (_base[index] == obj) {\n-            \/\/ Found top index\n-            top_index = index + 1;\n-            break;\n-          }\n-        }\n-\n-        if (VM_Version::supports_recursive_lightweight_locking()) {\n-          \/\/ With recursive looks there may be more of the same object\n-          while (lock_index-- > 0 && lock_order.at(lock_index) == obj) {\n-            top_index++;\n-          }\n-          assert(top_index <= to_index(_top), \"too many obj in lock_order\");\n-        }\n-\n-        break;\n-      }\n-    }\n-\n-    lock_index = lock_order.length();\n-  }\n-\n-  while (lock_index-- > 0) {\n-    const oop obj = lock_order.at(lock_index);\n-    const markWord mark = obj->mark_acquire();\n-    assert(obj->is_locked(), \"must be locked\");\n-    if (top_index > 0 && obj == _base[top_index - 1]) {\n-      assert(mark.is_fast_locked() || mark.monitor()->is_owner_anonymous(),\n-             \"must be fast_locked or inflated by other thread\");\n-      top_index--;\n-    } else {\n-      assert(!mark.is_fast_locked(), \"must be inflated\");\n-      assert(mark.monitor()->owner_raw() == get_thread() ||\n-             (!leaf_frame && get_thread()->current_waiting_monitor() == mark.monitor()),\n-             \"must be owned by (or waited on by) thread\");\n-      assert(!contains(obj), \"must not be on lock_stack\");\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -124,3 +124,0 @@\n-\n-  \/\/ Verify Lock Stack consistent with lock order\n-  void verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -302,1 +302,0 @@\n-        new EARelockingWhileTargetOnMonitorenterTarget()                                    .run();\n@@ -427,1 +426,0 @@\n-        new EARelockingWhileTargetOnMonitorenter()                                    .run(this);\n@@ -2277,61 +2275,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-class EARelockingWhileTargetOnMonitorenter extends EATestCaseBaseDebugger {\n-\n-    public void runTestCase() throws Exception {\n-        Object lock = getField(testCase, \"sharedLock\");\n-        boolean inMonitorEnter = false;\n-        env.vm().resume();\n-        do {\n-            Thread.sleep(100);\n-            env.targetMainThread.suspend();\n-            printStack(env.targetMainThread);\n-            inMonitorEnter = env.targetMainThread.currentContendedMonitor() == lock;\n-            if (!inMonitorEnter) {\n-                msg(\"Target not yet blocked in monitorenter\");\n-                env.targetMainThread.resume();\n-            }\n-        } while(!inMonitorEnter);\n-        StackFrame testMethodFrame = env.targetMainThread.frame(1);\n-        ObjectReference l1 = getLocalRef(testMethodFrame, XYVAL_NAME, \"l1\");\n-        setField(testCase, \"releaseLock\", env.vm().mirrorOf(true));\n-    }\n-}\n-\n-class EARelockingWhileTargetOnMonitorenterTarget extends EATestCaseBaseTarget {\n-\n-    public Object sharedLock = new Object();\n-    public volatile boolean releaseLock;\n-    public int counter;\n-\n-    @Override\n-    public void warmupDone() {\n-        super.warmupDone();\n-        Thread t = new Thread(() -> contendOnLock());\n-        t.start();\n-    }\n-\n-    public void contendOnLock() {\n-        synchronized (sharedLock) {\n-            while (!releaseLock) {\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) { \/* ignored *\/ }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void dontinline_testMethod() throws Exception {\n-        XYVal l1 = new XYVal(1, 1);\n-        synchronized (l1) {\n-            testMethod_inlined(l1);\n-        }\n-    }\n-\n-    public void testMethod_inlined(XYVal l2) throws Exception {\n-        synchronized (sharedLock) {\n-            counter++;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"}]}