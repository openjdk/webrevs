{"files":[{"patch":"@@ -443,2 +443,18 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n-    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+  if (lock_order.is_nonempty()) {\n+    const int bci = chunk->first()->bci();\n+    const Bytecodes::Code bc = chunk->first()->method()->code_at(bci);\n+    \/\/ Using raw constMethod::bcp_from as bci-1 may be an operand and not a opcode.\n+    \/\/ Interpreting operands as a monitorenter bytecode will only result in missing\n+    \/\/ out on some cases where verification would have been valid and possible.\n+    \/\/ Similarly filter out breakpoint bytecode as it may have been a monitorenter.\n+    const bool previous_bc_not_monitorenter = bci == 0 ? !chunk->first()->method()->is_synchronized()\n+                                                       : (*chunk->first()->method()->bcp_from(bci - 1) != Bytecodes::_monitorenter ||\n+                                                          *chunk->first()->method()->bcp_from(bci - 1) != Bytecodes::_breakpoint);\n+    const bool is_synchronized_entry = chunk->first()->method()->is_synchronized() &&\n+                                       chunk->first()->raw_bci() == SynchronizationEntryBCI;\n+    \/\/ If deoptimizing from monitorenter bytecode we may be in a transitional state. Skip verification.\n+    \/\/ When reexecuting the current bc, the previous monitorenter bc may not have finished yet.\n+    if (!is_synchronized_entry && bc != Bytecodes::Code::_monitorenter &&\n+        (!chunk->first()->should_reexecute() || previous_bc_not_monitorenter)) {\n+      deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -302,0 +302,1 @@\n+        new EARelockingWhileTargetOnMonitorenterTarget()                                    .run();\n@@ -426,0 +427,1 @@\n+        new EARelockingWhileTargetOnMonitorenter()                                    .run(this);\n@@ -2275,0 +2277,61 @@\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EARelockingWhileTargetOnMonitorenter extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        Object lock = getField(testCase, \"sharedLock\");\n+        boolean inMonitorEnter = false;\n+        env.vm().resume();\n+        do {\n+            Thread.sleep(100);\n+            env.targetMainThread.suspend();\n+            printStack(env.targetMainThread);\n+            inMonitorEnter = env.targetMainThread.currentContendedMonitor() == lock;\n+            if (!inMonitorEnter) {\n+                msg(\"Target not yet blocked in monitorenter\");\n+                env.targetMainThread.resume();\n+            }\n+        } while(!inMonitorEnter);\n+        StackFrame testMethodFrame = env.targetMainThread.frame(1);\n+        ObjectReference l1 = getLocalRef(testMethodFrame, XYVAL_NAME, \"l1\");\n+        setField(testCase, \"releaseLock\", env.vm().mirrorOf(true));\n+    }\n+}\n+\n+class EARelockingWhileTargetOnMonitorenterTarget extends EATestCaseBaseTarget {\n+\n+    public Object sharedLock = new Object();\n+    public volatile boolean releaseLock;\n+    public int counter;\n+\n+    @Override\n+    public void warmupDone() {\n+        super.warmupDone();\n+        Thread t = new Thread(() -> contendOnLock());\n+        t.start();\n+    }\n+\n+    public void contendOnLock() {\n+        synchronized (sharedLock) {\n+            while (!releaseLock) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) { \/* ignored *\/ }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dontinline_testMethod() throws Exception {\n+        XYVal l1 = new XYVal(1, 1);\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) throws Exception {\n+        synchronized (sharedLock) {\n+            counter++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"}]}